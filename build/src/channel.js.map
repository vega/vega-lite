{"version":3,"file":"channel.js","sourceRoot":"","sources":["../../src/channel.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\n\nimport {isBinned} from './bin';\nimport {RangeType} from './compile/scale/type';\nimport {Encoding} from './encoding';\nimport {FacetMapping} from './facet';\nimport {isFieldDef} from './fielddef';\nimport {CIRCLE, Mark, POINT, SQUARE, TICK} from './mark';\nimport {contains, Flag, flagKeys} from './util';\n\nexport namespace Channel {\n  // Facet\n  export const ROW: 'row' = 'row';\n  export const COLUMN: 'column' = 'column';\n\n  // Position\n  export const X: 'x' = 'x';\n  export const Y: 'y' = 'y';\n  export const X2: 'x2' = 'x2';\n  export const Y2: 'y2' = 'y2';\n\n  // Geo Position\n  export const LATITUDE: 'latitude' = 'latitude';\n  export const LONGITUDE: 'longitude' = 'longitude';\n  export const LATITUDE2: 'latitude2' = 'latitude2';\n  export const LONGITUDE2: 'longitude2' = 'longitude2';\n\n  // Mark property with scale\n  export const COLOR: 'color' = 'color';\n\n  export const FILL: 'fill' = 'fill';\n\n  export const STROKE: 'stroke' = 'stroke';\n\n  export const SHAPE: 'shape' = 'shape';\n  export const SIZE: 'size' = 'size';\n  export const OPACITY: 'opacity' = 'opacity';\n\n  // Non-scale channel\n  export const TEXT: 'text' = 'text';\n  export const ORDER: 'order' = 'order';\n  export const DETAIL: 'detail' = 'detail';\n  export const KEY: 'key' = 'key';\n\n  export const TOOLTIP: 'tooltip' = 'tooltip';\n  export const HREF: 'href' = 'href';\n}\n\nexport type Channel = keyof Encoding<any> | keyof FacetMapping<any>;\n\nexport const X = Channel.X;\nexport const Y = Channel.Y;\nexport const X2 = Channel.X2;\nexport const Y2 = Channel.Y2;\n\nexport const LATITUDE = Channel.LATITUDE;\nexport const LATITUDE2 = Channel.LATITUDE2;\nexport const LONGITUDE = Channel.LONGITUDE;\nexport const LONGITUDE2 = Channel.LONGITUDE2;\n\nexport const ROW = Channel.ROW;\nexport const COLUMN = Channel.COLUMN;\nexport const SHAPE = Channel.SHAPE;\nexport const SIZE = Channel.SIZE;\nexport const COLOR = Channel.COLOR;\n\nexport const FILL = Channel.FILL;\nexport const STROKE = Channel.STROKE;\nexport const TEXT = Channel.TEXT;\nexport const DETAIL = Channel.DETAIL;\nexport const KEY = Channel.KEY;\nexport const ORDER = Channel.ORDER;\nexport const OPACITY = Channel.OPACITY;\nexport const TOOLTIP = Channel.TOOLTIP;\nexport const HREF = Channel.HREF;\n\nexport type GeoPositionChannel = 'longitude' | 'latitude' | 'longitude2' | 'latitude2';\n\nexport const GEOPOSITION_CHANNEL_INDEX: Flag<GeoPositionChannel> = {\n  longitude: 1,\n  longitude2: 1,\n  latitude: 1,\n  latitude2: 1\n};\n\nexport const GEOPOSITION_CHANNELS = flagKeys(GEOPOSITION_CHANNEL_INDEX);\n\nconst UNIT_CHANNEL_INDEX: Flag<keyof Encoding<any>> = {\n  // position\n  x: 1,\n  y: 1,\n  x2: 1,\n  y2: 1,\n\n  ...GEOPOSITION_CHANNEL_INDEX,\n\n  // color\n  color: 1,\n  fill: 1,\n  stroke: 1,\n\n  // other non-position with scale\n  opacity: 1,\n  size: 1,\n  shape: 1,\n\n  // channels without scales\n  order: 1,\n  text: 1,\n  detail: 1,\n  key: 1,\n  tooltip: 1,\n  href: 1\n};\n\nexport type ColorChannel = 'color' | 'fill' | 'stroke';\n\nexport function isColorChannel(channel: Channel): channel is ColorChannel {\n  return channel === 'color' || channel === 'fill' || channel === 'stroke';\n}\n\nconst FACET_CHANNEL_INDEX: Flag<keyof FacetMapping<any>> = {\n  row: 1,\n  column: 1\n};\n\nconst CHANNEL_INDEX = {\n  ...UNIT_CHANNEL_INDEX,\n  ...FACET_CHANNEL_INDEX\n};\n\nexport const CHANNELS = flagKeys(CHANNEL_INDEX);\n\nconst {order: _o, detail: _d, ...SINGLE_DEF_CHANNEL_INDEX} = CHANNEL_INDEX;\n/**\n * Channels that cannot have an array of channelDef.\n * model.fieldDef, getFieldDef only work for these channels.\n *\n * (The only two channels that can have an array of channelDefs are \"detail\" and \"order\".\n * Since there can be multiple fieldDefs for detail and order, getFieldDef/model.fieldDef\n * are not applicable for them.  Similarly, selection projection won't work with \"detail\" and \"order\".)\n */\n\nexport const SINGLE_DEF_CHANNELS: SingleDefChannel[] = flagKeys(SINGLE_DEF_CHANNEL_INDEX);\n\n// Using the following line leads to TypeError: Cannot read property 'elementTypes' of undefined\n// when running the schema generator\n// export type SingleDefChannel = typeof SINGLE_DEF_CHANNELS[0];\nexport type SingleDefChannel =\n  | 'x'\n  | 'y'\n  | 'x2'\n  | 'y2'\n  | 'longitude'\n  | 'latitude'\n  | 'longitude2'\n  | 'latitude2'\n  | 'row'\n  | 'column'\n  | 'color'\n  | 'fill'\n  | 'stroke'\n  | 'size'\n  | 'shape'\n  | 'opacity'\n  | 'text'\n  | 'tooltip'\n  | 'href'\n  | 'key';\n\nexport function isChannel(str: string): str is Channel {\n  return !!CHANNEL_INDEX[str];\n}\n\n// CHANNELS without COLUMN, ROW\nexport const UNIT_CHANNELS = flagKeys(UNIT_CHANNEL_INDEX);\n\n// NONPOSITION_CHANNELS = UNIT_CHANNELS without X, Y, X2, Y2;\nconst {\n  x: _x,\n  y: _y,\n  // x2 and y2 share the same scale as x and y\n  x2: _x2,\n  y2: _y2,\n  latitude: _latitude,\n  longitude: _longitude,\n  latitude2: _latitude2,\n  longitude2: _longitude2,\n  // The rest of unit channels then have scale\n  ...NONPOSITION_CHANNEL_INDEX\n} = UNIT_CHANNEL_INDEX;\n\nexport const NONPOSITION_CHANNELS = flagKeys(NONPOSITION_CHANNEL_INDEX);\nexport type NonPositionChannel = typeof NONPOSITION_CHANNELS[0];\n\n// POSITION_SCALE_CHANNELS = X and Y;\nconst POSITION_SCALE_CHANNEL_INDEX: {x: 1; y: 1} = {x: 1, y: 1};\nexport const POSITION_SCALE_CHANNELS = flagKeys(POSITION_SCALE_CHANNEL_INDEX);\nexport type PositionScaleChannel = typeof POSITION_SCALE_CHANNELS[0];\n\n// NON_POSITION_SCALE_CHANNEL = SCALE_CHANNELS without X, Y\nconst {\n  // x2 and y2 share the same scale as x and y\n  // text and tooltip have format instead of scale,\n  // href has neither format, nor scale\n  text: _t,\n  tooltip: _tt,\n  href: _hr,\n  // detail and order have no scale\n  detail: _dd,\n  key: _k,\n  order: _oo,\n  ...NONPOSITION_SCALE_CHANNEL_INDEX\n} = NONPOSITION_CHANNEL_INDEX;\nexport const NONPOSITION_SCALE_CHANNELS = flagKeys(NONPOSITION_SCALE_CHANNEL_INDEX);\nexport type NonPositionScaleChannel = typeof NONPOSITION_SCALE_CHANNELS[0];\n\n// Declare SCALE_CHANNEL_INDEX\nconst SCALE_CHANNEL_INDEX = {\n  ...POSITION_SCALE_CHANNEL_INDEX,\n  ...NONPOSITION_SCALE_CHANNEL_INDEX\n};\n\n/** List of channels with scales */\nexport const SCALE_CHANNELS = flagKeys(SCALE_CHANNEL_INDEX);\nexport type ScaleChannel = typeof SCALE_CHANNELS[0];\n\nexport function isScaleChannel(channel: Channel): channel is ScaleChannel {\n  return !!SCALE_CHANNEL_INDEX[channel];\n}\n\nexport type SupportedMark = {[mark in Mark]?: boolean};\n\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\nexport function supportMark(encoding: Encoding<string>, channel: Channel, mark: Mark) {\n  if (contains([CIRCLE, POINT, SQUARE, TICK], mark) && contains([X2, Y2], channel)) {\n    const primaryFieldDef = encoding[channel === X2 ? X : Y];\n    // circle, point, square and tick only support x2/y2 when their corresponding x/y fieldDef\n    // has \"binned\" data and thus need x2/y2 to specify the bin-end field.\n    if (isFieldDef(primaryFieldDef) && isFieldDef(encoding[channel]) && isBinned(primaryFieldDef.bin)) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return mark in getSupportedMark(channel);\n  }\n}\n\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to boolean values.\n */\nexport function getSupportedMark(channel: Channel): SupportedMark {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE:\n\n    case DETAIL:\n    case KEY:\n    case TOOLTIP:\n    case HREF:\n    case ORDER: // TODO: revise (order might not support rect, which is not stackable?)\n    case OPACITY:\n    case ROW:\n    case COLUMN:\n      return {\n        // all marks\n        point: true,\n        tick: true,\n        rule: true,\n        circle: true,\n        square: true,\n        bar: true,\n        rect: true,\n        line: true,\n        trail: true,\n        area: true,\n        text: true,\n        geoshape: true\n      };\n    case X:\n    case Y:\n    case LATITUDE:\n    case LONGITUDE:\n      return {\n        // all marks except geoshape. geoshape does not use X, Y -- it uses a projection\n        point: true,\n        tick: true,\n        rule: true,\n        circle: true,\n        square: true,\n        bar: true,\n        rect: true,\n        line: true,\n        trail: true,\n        area: true,\n        text: true\n      };\n    case X2:\n    case Y2:\n    case LATITUDE2:\n    case LONGITUDE2:\n      return {\n        rule: true,\n        bar: true,\n        rect: true,\n        area: true\n      };\n    case SIZE:\n      return {\n        point: true,\n        tick: true,\n        rule: true,\n        circle: true,\n        square: true,\n        bar: true,\n        text: true,\n        line: true,\n        trail: true\n      };\n    case SHAPE:\n      return {point: true, geoshape: true};\n    case TEXT:\n      return {text: true};\n  }\n}\n\nexport function rangeType(channel: Channel): RangeType {\n  switch (channel) {\n    case X:\n    case Y:\n    case SIZE:\n    case OPACITY:\n    // X2 and Y2 use X and Y scales, so they similarly have continuous range.\n    case X2:\n    case Y2:\n      return 'continuous';\n\n    case ROW:\n    case COLUMN:\n    case SHAPE:\n    // TEXT, TOOLTIP, and HREF have no scale but have discrete output\n    case TEXT:\n    case TOOLTIP:\n    case HREF:\n      return 'discrete';\n\n    // Color can be either continuous or discrete, depending on scale type.\n    case COLOR:\n    case FILL:\n    case STROKE:\n      return 'flexible';\n\n    // No scale, no range type.\n\n    case LATITUDE:\n    case LONGITUDE:\n    case LATITUDE2:\n    case LONGITUDE2:\n    case DETAIL:\n    case KEY:\n    case ORDER:\n      return undefined;\n  }\n  /* istanbul ignore next: should never reach here. */\n  throw new Error('rangeType not implemented for ' + channel);\n}\n"]}