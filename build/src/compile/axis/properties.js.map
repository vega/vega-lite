{"version":3,"file":"properties.js","sourceRoot":"","sources":["../../../../src/compile/axis/properties.ts"],"names":[],"mappings":"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","sourcesContent":["import {truncate} from 'vega-util';\nimport {Axis} from '../../axis';\nimport {binToString} from '../../bin';\nimport {PositionScaleChannel, X, Y} from '../../channel';\nimport {Config} from '../../config';\nimport {FieldDef, title as fieldDefTitle, valueArray} from '../../fielddef';\nimport * as log from '../../log';\nimport {hasDiscreteDomain, isSelectionDomain, ScaleType} from '../../scale';\nimport {QUANTITATIVE} from '../../type';\nimport {contains} from '../../util';\nimport {VgSignalRef} from '../../vega.schema';\nimport {UnitModel} from '../unit';\n\n\n// TODO: we need to refactor this method after we take care of config refactoring\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\nexport function grid(scaleType: ScaleType, fieldDef: FieldDef<string>) {\n  return !hasDiscreteDomain(scaleType) && !fieldDef.bin;\n}\n\nexport function gridScale(model: UnitModel, channel: PositionScaleChannel) {\n  const gridChannel: PositionScaleChannel = channel === 'x' ? 'y' : 'x';\n  if (model.getScaleComponent(gridChannel)) {\n    return model.scaleName(gridChannel);\n  }\n  return undefined;\n}\n\nexport function labelFlush(fieldDef: FieldDef<string>, channel: PositionScaleChannel, specifiedAxis: Axis) {\n  if (specifiedAxis.labelFlush !== undefined) {\n    return specifiedAxis.labelFlush;\n  }\n  if (channel === 'x' && contains(['quantitative', 'temporal'], fieldDef.type)) {\n    return true;\n  }\n  return undefined;\n}\n\nexport function labelOverlap(fieldDef: FieldDef<string>, specifiedAxis: Axis, channel: PositionScaleChannel, scaleType: ScaleType) {\n  if (specifiedAxis.labelOverlap !== undefined) {\n    return specifiedAxis.labelOverlap;\n  }\n\n  // do not prevent overlap for nominal data because there is no way to infer what the missing labels are\n  if (fieldDef.type !== 'nominal') {\n    if (scaleType === 'log') {\n      return 'greedy';\n    }\n    return true;\n  }\n\n  return undefined;\n}\n\nexport function orient(channel: PositionScaleChannel) {\n  switch (channel) {\n    case X:\n      return 'bottom';\n    case Y:\n      return 'left';\n  }\n  /* istanbul ignore next: This should never happen. */\n  throw new Error(log.message.INVALID_CHANNEL_FOR_AXIS);\n}\n\nexport function tickCount(channel: PositionScaleChannel, fieldDef: FieldDef<string>, scaleType: ScaleType, size: VgSignalRef) {\n  if (!hasDiscreteDomain(scaleType) && scaleType !== 'log' && !contains(['month', 'hours', 'day', 'quarter'], fieldDef.timeUnit)) {\n\n    if (fieldDef.bin) {\n      // for binned data, we don't want more ticks than maxbins\n      return {signal: `ceil(${size.signal}/20)`};\n    }\n    return {signal: `ceil(${size.signal}/40)`};\n  }\n\n  return undefined;\n}\n\nexport function title(maxLength: number, fieldDef: FieldDef<string>, config: Config) {\n  // if not defined, automatically determine axis title from field def\n  const fieldTitle = fieldDefTitle(fieldDef, config);\n  return maxLength ? truncate(fieldTitle, maxLength) : fieldTitle;\n}\n\nexport function values(specifiedAxis: Axis, model: UnitModel, fieldDef: FieldDef<string>, channel: PositionScaleChannel) {\n  const vals = specifiedAxis.values;\n\n  if (vals) {\n    return valueArray(fieldDef, vals);\n  }\n\n  if (fieldDef.bin && fieldDef.type === QUANTITATIVE) {\n    const domain = model.scaleDomain(channel);\n    if (domain && domain !== 'unaggregated' && !isSelectionDomain(domain)) { // explicit value\n      return undefined;\n    }\n\n    const signal = model.getName(`${binToString(fieldDef.bin)}_${fieldDef.field}_bins`);\n    return {signal: `sequence(${signal}.start, ${signal}.stop + ${signal}.step, ${signal}.step)`};\n  }\n\n  return undefined;\n}\n"]}