{"version":3,"file":"bin.js","sourceRoot":"","sources":["../../../../src/compile/data/bin.ts"],"names":[],"mappings":"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","sourcesContent":["import {isString} from 'vega-util';\nimport {BinParams, binToString, isBinning} from '../../bin';\nimport {Channel} from '../../channel';\nimport {Config} from '../../config';\nimport {FieldDef, normalizeBin, vgField} from '../../fielddef';\nimport {BinTransform} from '../../transform';\nimport {Dict, duplicate, flatten, hash, keys, vals} from '../../util';\nimport {VgBinTransform, VgTransform} from '../../vega.schema';\nimport {binFormatExpression, binRequiresRange} from '../common';\nimport {isUnitModel, Model, ModelWithField} from '../model';\nimport {DataFlowNode, TransformNode} from './dataflow';\n\nfunction rangeFormula(model: ModelWithField, fieldDef: FieldDef<string>, channel: Channel, config: Config) {\n  if (binRequiresRange(fieldDef, channel)) {\n    // read format from axis or legend, if there is no format then use config.numberFormat\n\n    const guide = isUnitModel(model) ? model.axis(channel) || model.legend(channel) || {} : {};\n\n    const startField = vgField(fieldDef, {expr: 'datum'});\n    const endField = vgField(fieldDef, {expr: 'datum', binSuffix: 'end'});\n\n    return {\n      formulaAs: vgField(fieldDef, {binSuffix: 'range', forAs: true}),\n      formula: binFormatExpression(startField, endField, guide.format, config)\n    };\n  }\n  return {};\n}\n\nfunction binKey(bin: BinParams, field: string) {\n  return `${binToString(bin)}_${field}`;\n}\n\nfunction getSignalsFromModel(model: Model, key: string) {\n  return {\n    signal: model.getName(`${key}_bins`),\n    extentSignal: model.getName(`${key}_extent`)\n  };\n}\n\nfunction isBinTransform(t: FieldDef<string> | BinTransform): t is BinTransform {\n  return 'as' in t;\n}\n\nfunction createBinComponent(t: FieldDef<string> | BinTransform, bin: boolean | BinParams, model: Model) {\n  let as: [string, string];\n\n  if (isBinTransform(t)) {\n    as = isString(t.as) ? [t.as, `${t.as}_end`] : [t.as[0], t.as[1]];\n  } else {\n    as = [vgField(t, {forAs: true}), vgField(t, {binSuffix: 'end', forAs: true})];\n  }\n\n  const normalizedBin = normalizeBin(bin, undefined) || {};\n  const key = binKey(normalizedBin, t.field);\n  const {signal, extentSignal} = getSignalsFromModel(model, key);\n\n  const binComponent: BinComponent = {\n    bin: normalizedBin,\n    field: t.field,\n    as: as,\n    ...(signal ? {signal} : {}),\n    ...(extentSignal ? {extentSignal} : {})\n  };\n\n  return {key, binComponent};\n}\n\nexport interface BinComponent {\n  bin: BinParams;\n  field: string;\n  extentSignal?: string;\n  signal?: string;\n  as: string[];\n\n  // Range Formula\n\n  formula?: string;\n  formulaAs?: string;\n}\n\nexport class BinNode extends TransformNode {\n  public clone() {\n    return new BinNode(null, duplicate(this.bins));\n  }\n\n  constructor(parent: DataFlowNode, private bins: Dict<BinComponent>) {\n    super(parent);\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: ModelWithField) {\n    const bins = model.reduceFieldDef((binComponentIndex: Dict<BinComponent>, fieldDef, channel) => {\n      if (isBinning(fieldDef.bin)) {\n        const {key, binComponent} = createBinComponent(fieldDef, fieldDef.bin, model);\n        binComponentIndex[key] = {\n          ...binComponent,\n          ...binComponentIndex[key],\n          ...rangeFormula(model, fieldDef, channel, model.config)\n        };\n      }\n      return binComponentIndex;\n    }, {});\n\n    if (keys(bins).length === 0) {\n      return null;\n    }\n\n    return new BinNode(parent, bins);\n  }\n\n  /**\n   * Creates a bin node from BinTransform.\n   * The optional parameter should provide\n   */\n  public static makeFromTransform(parent: DataFlowNode, t: BinTransform, model: Model) {\n    const {key, binComponent} = createBinComponent(t, t.bin, model);\n    return new BinNode(parent, {\n      [key]: binComponent\n    });\n  }\n\n  public merge(other: BinNode) {\n    this.bins = {...this.bins, ...other.bins};\n    other.remove();\n  }\n\n  public producedFields() {\n    const out = {};\n\n    vals(this.bins).forEach(c => {\n      c.as.forEach(f => (out[f] = true));\n    });\n\n    return out;\n  }\n\n  public dependentFields() {\n    const out = {};\n\n    vals(this.bins).forEach(c => {\n      out[c.field] = true;\n    });\n\n    return out;\n  }\n\n  public hash() {\n    return `Bin ${hash(this.bins)}`;\n  }\n\n  public assemble(): VgTransform[] {\n    return flatten(\n      vals(this.bins).map(bin => {\n        const transform: VgTransform[] = [];\n\n        const binTrans: VgBinTransform = {\n          type: 'bin',\n          field: bin.field,\n          as: bin.as,\n          signal: bin.signal,\n          ...bin.bin\n        };\n\n        if (!bin.bin.extent && bin.extentSignal) {\n          transform.push({\n            type: 'extent',\n            field: bin.field,\n            signal: bin.extentSignal\n          });\n          binTrans.extent = {signal: bin.extentSignal};\n        }\n\n        transform.push(binTrans);\n\n        if (bin.formula) {\n          transform.push({\n            type: 'formula',\n            expr: bin.formula,\n            as: bin.formulaAs\n          });\n        }\n\n        return transform;\n      })\n    );\n  }\n}\n"]}