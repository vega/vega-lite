{"version":3,"file":"calculate.js","sourceRoot":"","sources":["../../../../src/compile/data/calculate.ts"],"names":[],"mappings":";;;AACA,2CAAkE;AAClE,6CAAsD;AACtD,mCAAuC;AACvC,mCAAqC;AAKrC,uCAAwC;AAExC;;GAEG;AACH;IAAmC,yCAAY;IAK7C,uBAAY,MAAoB,EAAU,SAA6B;QAAvE,YACE,kBAAM,MAAM,CAAC,SACd;QAFyC,eAAS,GAAT,SAAS,CAAoB;;IAEvE,CAAC;IANM,6BAAK,GAAZ;QACE,OAAO,IAAI,aAAa,CAAC,IAAI,EAAE,gBAAS,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC;IAC5D,CAAC;IAMa,kCAAoB,GAAlC,UAAmC,MAAoB,EAAE,KAAqB;QAC5E,mDAAmD;QACnD,KAAK,CAAC,eAAe,CAAC,UAAC,QAA0B,EAAE,OAAyB;YAC1E,IAAI,CAAC,0BAAe,CAAC,QAAQ,CAAC,EAAE;gBAC9B,OAAO;aACR;YACD,IAAI,kBAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;gBACvB,IAAA,wBAAK,EAAE,8BAAQ,CAAa;gBACnC,IAAM,IAAI,GAA6C,QAAQ,CAAC,IAAI,CAAC;gBACrE,iGAAiG;gBACjG,IAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,UAAC,SAAS,EAAE,CAAC;oBACtC,OAAU,iCAAqB,CAAC,EAAC,KAAK,SAAA,EAAE,QAAQ,YAAA,EAAE,KAAK,EAAE,SAAS,EAAC,CAAC,WAAM,CAAC,QAAK,CAAC;gBACnF,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC;gBAE1B,MAAM,GAAG,IAAI,aAAa,CAAC,MAAM,EAAE;oBACjC,SAAS,WAAA;oBACT,EAAE,EAAE,mBAAmB,CAAC,QAAQ,EAAE,OAAO,CAAC;iBAC3C,CAAC,CAAC;aACJ;QACH,CAAC,CAAC,CAAC;QACH,OAAO,MAAM,CAAC;IAChB,CAAC;IAEM,sCAAc,GAArB;QACE,IAAM,GAAG,GAAG,EAAE,CAAC;QACf,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC;QAC9B,OAAO,GAAG,CAAC;IACb,CAAC;IAEM,gCAAQ,GAAf;QACE,OAAO;YACL,IAAI,EAAE,SAAS;YACf,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,SAAS;YAC9B,EAAE,EAAE,IAAI,CAAC,SAAS,CAAC,EAAE;SACtB,CAAC;IACJ,CAAC;IACH,oBAAC;AAAD,CAAC,AA7CD,CAAmC,uBAAY,GA6C9C;AA7CY,sCAAa;AA+C1B,6BAAoC,QAA0B,EAAE,OAAyB,EAAE,IAAc;IACvG,OAAO,kBAAO,CAAC,QAAQ,EAAE,EAAC,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,YAAY,EAAE,IAAI,MAAA,EAAC,CAAC,CAAC;AAC1E,CAAC;AAFD,kDAEC","sourcesContent":["import {DateTime} from '../../datetime';\nimport {FieldDef, isScaleFieldDef, vgField} from '../../fielddef';\nimport {fieldFilterExpression} from '../../predicate';\nimport {isSortArray} from '../../sort';\nimport {duplicate} from '../../util';\nimport {VgFormulaTransform} from '../../vega.schema';\nimport {ModelWithField} from '../model';\nimport {SingleDefChannel} from './../../channel';\nimport {CalculateTransform} from './../../transform';\nimport {DataFlowNode} from './dataflow';\n\n/**\n * We don't know what a calculate node depends on so we should never move it beyond anything that produces fields.\n */\nexport class CalculateNode extends DataFlowNode {\n  public clone() {\n    return new CalculateNode(null, duplicate(this.transform));\n  }\n\n  constructor(parent: DataFlowNode, private transform: CalculateTransform) {\n    super(parent);\n  }\n\n  public static parseAllForSortIndex(parent: DataFlowNode, model: ModelWithField) {\n    // get all the encoding with sort fields from model\n    model.forEachFieldDef((fieldDef: FieldDef<string>, channel: SingleDefChannel) => {\n      if (!isScaleFieldDef(fieldDef)) {\n        return;\n      }\n      if (isSortArray(fieldDef.sort)) {\n        const {field, timeUnit} = fieldDef;\n        const sort: (number | string | boolean | DateTime)[] = fieldDef.sort;\n        // generate `datum[\"a\"] === val0 ? 0 : datum[\"a\"] === val1 ? 1 : ... : n` via FieldEqualPredicate\n        const calculate = sort.map((sortValue, i) => {\n          return `${fieldFilterExpression({field, timeUnit, equal: sortValue})} ? ${i} : `;\n        }).join('') + sort.length;\n\n        parent = new CalculateNode(parent, {\n          calculate,\n          as: sortArrayIndexField(fieldDef, channel)\n        });\n      }\n    });\n    return parent;\n  }\n\n  public producedFields() {\n    const out = {};\n    out[this.transform.as] = true;\n    return out;\n  }\n\n  public assemble(): VgFormulaTransform {\n    return {\n      type: 'formula',\n      expr: this.transform.calculate,\n      as: this.transform.as\n    };\n  }\n}\n\nexport function sortArrayIndexField(fieldDef: FieldDef<string>, channel: SingleDefChannel, expr?: 'datum') {\n  return vgField(fieldDef, {prefix: channel, suffix: 'sort_index', expr});\n}\n"]}