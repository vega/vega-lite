{"version":3,"file":"dataflow.js","sourceRoot":"","sources":["../../../../src/compile/data/dataflow.ts"],"names":[],"mappings":";AAGA;;GAEG;AACH;IAKE,sBAAY,MAAoB,EAAkB,SAAkB;QAAlB,cAAS,GAAT,SAAS,CAAS;QAJ5D,cAAS,GAAmB,EAAE,CAAC;QAE/B,YAAO,GAAiB,IAAI,CAAC;QAGnC,IAAI,MAAM,EAAE;YACV,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;SACtB;IACH,CAAC;IAED;;OAEG;IACI,4BAAK,GAAZ;QACE,MAAM,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;IACvC,CAAC;IAED;;OAEG;IACI,qCAAc,GAArB;QACE,OAAO,EAAE,CAAC;IACZ,CAAC;IAEM,sCAAe,GAAtB;QACE,OAAO,EAAE,CAAC;IACZ,CAAC;IAED,sBAAI,gCAAM;aAAV;YACE,OAAO,IAAI,CAAC,OAAO,CAAC;QACtB,CAAC;QAED;;WAEG;aACH,UAAW,MAAoB;YAC7B,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;YACtB,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QACxB,CAAC;;;OARA;IAUD,sBAAI,kCAAQ;aAAZ;YACE,OAAO,IAAI,CAAC,SAAS,CAAC;QACxB,CAAC;;;OAAA;IAEM,kCAAW,GAAlB;QACE,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC;IAC/B,CAAC;IAEM,+BAAQ,GAAf,UAAgB,KAAmB,EAAE,GAAY;QAC/C,IAAI,GAAG,KAAK,SAAS,EAAE;YACrB,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,EAAE,KAAK,CAAC,CAAC;SACtC;aAAM;YACL,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SAC5B;IACH,CAAC;IAEM,kCAAW,GAAlB,UAAmB,QAAsB;QACvC,IAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;QAC7C,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;QAC9B,OAAO,GAAG,CAAC;IACb,CAAC;IAED;;OAEG;IACI,6BAAM,GAAb;QACE,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QACzC,KAAoB,UAAc,EAAd,KAAA,IAAI,CAAC,SAAS,EAAd,cAAc,EAAd,IAAc,EAAE;YAA/B,IAAM,KAAK,SAAA;YACd,+EAA+E;YAC/E,KAAK,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;YAC7B,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,KAAK,EAAE,GAAG,EAAE,CAAC,CAAC;SACrC;IACH,CAAC;IAED;;OAEG;IACI,uCAAgB,GAAvB,UAAwB,KAAmB;QACzC,IAAM,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;QAC5B,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QACzB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC;IACtB,CAAC;IAEM,qCAAc,GAArB;QACE,IAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC;QAC5B,IAAM,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC;QAEhC,yBAAyB;QACzB,KAAoB,UAAc,EAAd,KAAA,IAAI,CAAC,SAAS,EAAd,cAAc,EAAd,IAAc,EAAE;YAA/B,IAAM,KAAK,SAAA;YACd,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC;SACvB;QAED,mBAAmB;QACnB,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC,CAAC,qDAAqD;QAC1E,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QACzB,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;QAElC,iBAAiB;QACjB,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC;QACxB,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC;IACvB,CAAC;IACH,mBAAC;AAAD,CAAC,AAvGD,IAuGC;;AAED;IAAgC,sCAAY;IAgB1C;;;;OAIG;IACH,oBACE,MAAoB,EACpB,MAAc,EACE,IAAoB,EACnB,SAAuB;QAJ1C,YAME,kBAAM,MAAM,EAAE,MAAM,CAAC,SAOtB;QAViB,UAAI,GAAJ,IAAI,CAAgB;QACnB,eAAS,GAAT,SAAS,CAAc;QAIxC,KAAI,CAAC,OAAO,GAAG,KAAI,CAAC,KAAK,GAAG,MAAM,CAAC;QAEnC,IAAI,KAAI,CAAC,SAAS,IAAI,CAAC,CAAC,KAAI,CAAC,KAAK,IAAI,KAAI,CAAC,SAAS,CAAC,EAAE;YACrD,KAAI,CAAC,SAAS,CAAC,KAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;SAChC;;IACH,CAAC;IA7BM,0BAAK,GAAZ;QACE,IAAM,QAAQ,GAAG,IAAK,IAAI,CAAC,WAAmB,EAAE,CAAC;QACjD,QAAQ,CAAC,SAAS,GAAG,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC;QAC/C,QAAQ,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;QAChC,QAAQ,CAAC,KAAK,GAAG,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC;QACvC,QAAQ,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QAC1B,QAAQ,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;QACpC,QAAQ,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACvC,OAAO,QAAQ,CAAC;IAClB,CAAC;IAsBD;;;;;;;;OAQG;IACI,8BAAS,GAAhB;QACE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;QAC7B,OAAO,IAAI,CAAC,OAAO,CAAC;IACtB,CAAC;IAEM,+BAAU,GAAjB;QACE,OAAO,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACtC,CAAC;IAEM,8BAAS,GAAhB,UAAiB,MAAc;QAC7B,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IACxB,CAAC;IACH,iBAAC;AAAD,CAAC,AAzDD,CAAgC,YAAY,GAyD3C;;AAED;IAA4C,yCAAY;IAAxD;;IAEA,CAAC;IAAD,oBAAC;AAAD,CAAC,AAFD,CAA4C,YAAY,GAEvD;;AAED,MAAM,UAAU,eAAe,CAAC,CAAe;IAC7C,OAAO,CAAC,YAAY,aAAa,CAAC;AACpC,CAAC","sourcesContent":["import {DataSourceType} from '../../data';\nimport {Dict, StringSet} from '../../util';\n\n/**\n * A node in the dataflow tree.\n */\nexport class DataFlowNode {\n  private _children: DataFlowNode[] = [];\n\n  private _parent: DataFlowNode = null;\n\n  constructor(parent: DataFlowNode, public readonly debugName?: string) {\n    if (parent) {\n      this.parent = parent;\n    }\n  }\n\n  /**\n   * Clone this node with a deep copy but don't clone links to children or parents.\n   */\n  public clone(): DataFlowNode {\n    throw new Error('Cannot clone node');\n  }\n\n  /**\n   * Set of fields that are being created by this node.\n   */\n  public producedFields(): StringSet {\n    return {};\n  }\n\n  public dependentFields(): StringSet {\n    return {};\n  }\n\n  get parent() {\n    return this._parent;\n  }\n\n  /**\n   * Set the parent of the node and also add this not to the parent's children.\n   */\n  set parent(parent: DataFlowNode) {\n    this._parent = parent;\n    parent.addChild(this);\n  }\n\n  get children() {\n    return this._children;\n  }\n\n  public numChildren() {\n    return this._children.length;\n  }\n\n  public addChild(child: DataFlowNode, loc?: number) {\n    if (loc !== undefined) {\n      this._children.splice(loc, 0, child);\n    } else {\n      this._children.push(child);\n    }\n  }\n\n  public removeChild(oldChild: DataFlowNode) {\n    const loc = this._children.indexOf(oldChild);\n    this._children.splice(loc, 1);\n    return loc;\n  }\n\n  /**\n   * Remove node from the dataflow.\n   */\n  public remove() {\n    let loc = this._parent.removeChild(this);\n    for (const child of this._children) {\n      // do not use the set method because we want to insert at a particular location\n      child._parent = this._parent;\n      this._parent.addChild(child, loc++);\n    }\n  }\n\n  /**\n   * Insert another node as a parent of this node.\n   */\n  public insertAsParentOf(other: DataFlowNode) {\n    const parent = other.parent;\n    parent.removeChild(this);\n    this.parent = parent;\n    other.parent = this;\n  }\n\n  public swapWithParent() {\n    const parent = this._parent;\n    const newParent = parent.parent;\n\n    // reconnect the children\n    for (const child of this._children) {\n      child.parent = parent;\n    }\n\n    // remove old links\n    this._children = []; // equivalent to removing every child link one by one\n    parent.removeChild(this);\n    parent.parent.removeChild(parent);\n\n    // swap two nodes\n    this.parent = newParent;\n    parent.parent = this;\n  }\n}\n\nexport class OutputNode extends DataFlowNode {\n  private _source: string;\n\n  private _name: string;\n\n  public clone(): this {\n    const cloneObj = new (this.constructor as any)();\n    cloneObj.debugName = 'clone_' + this.debugName;\n    cloneObj._source = this._source;\n    cloneObj._name = 'clone_' + this._name;\n    cloneObj.type = this.type;\n    cloneObj.refCounts = this.refCounts;\n    cloneObj.refCounts[cloneObj._name] = 0;\n    return cloneObj;\n  }\n\n  /**\n   * @param source The name of the source. Will change in assemble.\n   * @param type The type of the output node.\n   * @param refCounts A global ref counter map.\n   */\n  constructor(\n    parent: DataFlowNode,\n    source: string,\n    public readonly type: DataSourceType,\n    private readonly refCounts: Dict<number>\n  ) {\n    super(parent, source);\n\n    this._source = this._name = source;\n\n    if (this.refCounts && !(this._name in this.refCounts)) {\n      this.refCounts[this._name] = 0;\n    }\n  }\n\n  /**\n   * Request the datasource name and increase the ref counter.\n   *\n   * During the parsing phase, this will return the simple name such as 'main' or 'raw'.\n   * It is crucial to request the name from an output node to mark it as a required node.\n   * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.\n   *\n   * In the assemble phase, this will return the correct name.\n   */\n  public getSource() {\n    this.refCounts[this._name]++;\n    return this._source;\n  }\n\n  public isRequired(): boolean {\n    return !!this.refCounts[this._name];\n  }\n\n  public setSource(source: string) {\n    this._source = source;\n  }\n}\n\nexport abstract class TransformNode extends DataFlowNode {\n  public abstract hash(): string | number;\n}\n\nexport function isTransformNode(x: DataFlowNode) {\n  return x instanceof TransformNode;\n}\n"]}