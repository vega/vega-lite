{"version":3,"file":"dataflow.js","sourceRoot":"","sources":["../../../../src/compile/data/dataflow.ts"],"names":[],"mappings":"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","sourcesContent":["import {DataSourceType} from '../../data';\nimport {Dict, uniqueId} from '../../util';\n\n/**\n * A node in the dataflow tree.\n */\nexport abstract class DataFlowNode {\n  private _children: DataFlowNode[] = [];\n\n  private _parent: DataFlowNode = null;\n\n  protected _hash: string | number;\n\n  constructor(parent: DataFlowNode, public readonly debugName?: string) {\n    if (parent) {\n      this.parent = parent;\n    }\n  }\n\n  /**\n   * Clone this node with a deep copy but don't clone links to children or parents.\n   */\n  public clone(): DataFlowNode {\n    throw new Error('Cannot clone node');\n  }\n\n  /**\n   * Return a hash of the node.\n   */\n  public abstract hash(): string | number;\n\n  /**\n   * Set of fields that this node depends on.\n   */\n  public abstract dependentFields(): Set<string>;\n\n  /**\n   * Set of fields that are being created by this node.\n   */\n  public abstract producedFields(): Set<string>;\n\n  get parent() {\n    return this._parent;\n  }\n\n  /**\n   * Set the parent of the node and also add this node to the parent's children.\n   */\n  set parent(parent: DataFlowNode) {\n    this._parent = parent;\n    if (parent) {\n      parent.addChild(this);\n    }\n  }\n\n  get children() {\n    return this._children;\n  }\n\n  public numChildren() {\n    return this._children.length;\n  }\n\n  public addChild(child: DataFlowNode, loc?: number) {\n    // do not add the same child twice\n    if (this._children.indexOf(child) > -1) {\n      console.warn('Attempt to add the same child twice.');\n      return;\n    }\n\n    if (loc !== undefined) {\n      this._children.splice(loc, 0, child);\n    } else {\n      this._children.push(child);\n    }\n  }\n\n  public removeChild(oldChild: DataFlowNode) {\n    const loc = this._children.indexOf(oldChild);\n    this._children.splice(loc, 1);\n    return loc;\n  }\n\n  /**\n   * Remove node from the dataflow.\n   */\n  public remove() {\n    let loc = this._parent.removeChild(this);\n    for (const child of this._children) {\n      // do not use the set method because we want to insert at a particular location\n      child._parent = this._parent;\n      this._parent.addChild(child, loc++);\n    }\n  }\n\n  /**\n   * Insert another node as a parent of this node.\n   */\n  public insertAsParentOf(other: DataFlowNode) {\n    const parent = other.parent;\n    parent.removeChild(this);\n    this.parent = parent;\n    other.parent = this;\n  }\n\n  public swapWithParent() {\n    const parent = this._parent;\n    const newParent = parent.parent;\n\n    // reconnect the children\n    for (const child of this._children) {\n      child.parent = parent;\n    }\n\n    // remove old links\n    this._children = []; // equivalent to removing every child link one by one\n    parent.removeChild(this);\n    parent.parent.removeChild(parent);\n\n    // swap two nodes\n    this.parent = newParent;\n    parent.parent = this;\n  }\n}\n\nexport class OutputNode extends DataFlowNode {\n  private _source: string;\n\n  private _name: string;\n\n  public clone(): this {\n    const cloneObj = new (this.constructor as any)();\n    cloneObj.debugName = 'clone_' + this.debugName;\n    cloneObj._source = this._source;\n    cloneObj._name = 'clone_' + this._name;\n    cloneObj.type = this.type;\n    cloneObj.refCounts = this.refCounts;\n    cloneObj.refCounts[cloneObj._name] = 0;\n    return cloneObj;\n  }\n\n  /**\n   * @param source The name of the source. Will change in assemble.\n   * @param type The type of the output node.\n   * @param refCounts A global ref counter map.\n   */\n  constructor(\n    parent: DataFlowNode,\n    source: string,\n    public readonly type: DataSourceType,\n    private readonly refCounts: Dict<number>\n  ) {\n    super(parent, source);\n\n    this._source = this._name = source;\n\n    if (this.refCounts && !(this._name in this.refCounts)) {\n      this.refCounts[this._name] = 0;\n    }\n  }\n\n  public dependentFields() {\n    return new Set<string>();\n  }\n\n  public producedFields() {\n    return new Set<string>();\n  }\n\n  public hash() {\n    if (this._hash === undefined) {\n      this._hash = `Output ${uniqueId()}`;\n    }\n    return this._hash;\n  }\n\n  /**\n   * Request the datasource name and increase the ref counter.\n   *\n   * During the parsing phase, this will return the simple name such as 'main' or 'raw'.\n   * It is crucial to request the name from an output node to mark it as a required node.\n   * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.\n   *\n   * In the assemble phase, this will return the correct name.\n   */\n  public getSource() {\n    this.refCounts[this._name]++;\n    return this._source;\n  }\n\n  public isRequired(): boolean {\n    return !!this.refCounts[this._name];\n  }\n\n  public setSource(source: string) {\n    this._source = source;\n  }\n}\n"]}