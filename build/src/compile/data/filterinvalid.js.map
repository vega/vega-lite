{"version":3,"file":"filterinvalid.js","sourceRoot":"","sources":["../../../../src/compile/data/filterinvalid.ts"],"names":[],"mappings":";;;AAAA,yCAA6C;AAC7C,2CAA6D;AAC7D,mCAAsC;AACtC,qCAA2D;AAC3D,mCAAsC;AAGtC,uCAAwC;AAExC;IAAuC,6CAAY;IAKjD,2BAAY,MAAoB,EAAU,SAAiC;QAA3E,YACC,kBAAM,MAAM,CAAC,SACb;QAFyC,eAAS,GAAT,SAAS,CAAwB;;IAE3E,CAAC;IANM,iCAAK,GAAZ;QACE,OAAO,IAAI,iBAAiB,CAAC,IAAI,uBAAM,IAAI,CAAC,SAAS,EAAE,CAAC;IAC1D,CAAC;IAMa,sBAAI,GAAlB,UAAmB,MAAoB,EAAE,KAAgB;QAChD,IAAA,qBAAM,EAAE,iBAAI,CAAU;QAC7B,IAAI,MAAM,CAAC,aAAa,KAAK,QAAQ,EAAG;YACtC,OAAO,IAAI,CAAC;SACb;QAED,IAAM,MAAM,GAAG,KAAK,CAAC,cAAc,CAAC,UAAC,UAAkC,EAAE,QAAQ,EAAE,OAAO;YACxF,IAAM,cAAc,GAAG,wBAAc,CAAC,OAAO,CAAC,IAAI,KAAK,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;YACnF,IAAI,cAAc,EAAE;gBAClB,IAAM,SAAS,GAAG,cAAc,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;gBAG7C,mFAAmF;gBACnF,uFAAuF;gBACvF,kFAAkF;gBAClF,IAAI,2BAAmB,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,IAAI,CAAC,iBAAU,CAAC,IAAI,CAAC,EAAE;oBAC9E,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,QAAQ,CAAC;iBACvC;aACF;YACD,OAAO,UAAU,CAAC;QACpB,CAAC,EAAE,EAA4B,CAAC,CAAC;QAEjC,IAAI,CAAC,WAAI,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE;YACxB,OAAO,IAAI,CAAC;SACb;QAED,OAAO,IAAI,iBAAiB,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IAC/C,CAAC;IAED,sBAAI,qCAAM;aAAV;YACE,OAAO,IAAI,CAAC,SAAS,CAAC;QACxB,CAAC;;;OAAA;IAED,0DAA0D;IACnD,oCAAQ,GAAf;QAAA,iBAiBC;QAhBC,IAAM,OAAO,GAAG,WAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,UAAC,WAAW,EAAE,KAAK;YAC1D,IAAM,QAAQ,GAAG,KAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;YACvC,IAAM,GAAG,GAAG,kBAAQ,CAAC,QAAQ,EAAE,EAAC,IAAI,EAAE,OAAO,EAAC,CAAC,CAAC;YAEhD,IAAI,QAAQ,KAAK,IAAI,EAAE;gBACrB,WAAW,CAAC,IAAI,CAAI,GAAG,cAAW,CAAC,CAAC;gBACpC,WAAW,CAAC,IAAI,CAAC,YAAU,GAAG,MAAG,CAAC,CAAC;aACpC;YACD,OAAO,WAAW,CAAC;QACrB,CAAC,EAAE,EAAE,CAAC,CAAC;QAEP,OAAO,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YAC3B;gBACI,IAAI,EAAE,QAAQ;gBACd,IAAI,EAAE,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC;aAC7B,CAAC,CAAC,CAAC,IAAI,CAAC;IACX,CAAC;IACH,wBAAC;AAAD,CAAC,AA7DD,CAAuC,uBAAY,GA6DlD;AA7DY,8CAAiB","sourcesContent":["import {isScaleChannel} from '../../channel';\nimport {FieldDef, vgField as fieldRef} from '../../fielddef';\nimport {isPathMark} from '../../mark';\nimport {hasContinuousDomain, ScaleType} from '../../scale';\nimport {Dict, keys} from '../../util';\nimport {VgFilterTransform} from '../../vega.schema';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\n\nexport class FilterInvalidNode extends DataFlowNode {\n  public clone() {\n    return new FilterInvalidNode(null, {...this.fieldDefs});\n  }\n\n  constructor(parent: DataFlowNode, private fieldDefs: Dict<FieldDef<string>>) {\n   super(parent);\n  }\n\n  public static make(parent: DataFlowNode, model: UnitModel): FilterInvalidNode {\n    const {config, mark} = model;\n    if (config.invalidValues !== 'filter' ) {\n      return null;\n    }\n\n    const filter = model.reduceFieldDef((aggregator: Dict<FieldDef<string>>, fieldDef, channel) => {\n      const scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);\n      if (scaleComponent) {\n        const scaleType = scaleComponent.get('type');\n\n\n        // While discrete domain scales can handle invalid values, continuous scales can't.\n        // Thus, for non-path marks, we have to filter null for scales with continuous domains.\n        // (For path marks, we will use \"defined\" property and skip these values instead.)\n        if (hasContinuousDomain(scaleType) && !fieldDef.aggregate && !isPathMark(mark)) {\n          aggregator[fieldDef.field] = fieldDef;\n        }\n      }\n      return aggregator;\n    }, {} as Dict<FieldDef<string>>);\n\n    if (!keys(filter).length) {\n      return null;\n    }\n\n    return new FilterInvalidNode(parent, filter);\n  }\n\n  get filter() {\n    return this.fieldDefs;\n  }\n\n  // create the VgTransforms for each of the filtered fields\n  public assemble(): VgFilterTransform {\n    const filters = keys(this.filter).reduce((vegaFilters, field) => {\n      const fieldDef = this.fieldDefs[field];\n      const ref = fieldRef(fieldDef, {expr: 'datum'});\n\n      if (fieldDef !== null) {\n        vegaFilters.push(`${ref} !== null`);\n        vegaFilters.push(`!isNaN(${ref})`);\n      }\n      return vegaFilters;\n    }, []);\n\n    return filters.length > 0 ?\n    {\n        type: 'filter',\n        expr: filters.join(' && ')\n    } : null;\n  }\n}\n"]}