{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/compile/data/index.ts"],"names":[],"mappings":";AAEA,OAAO,EAAC,KAAK,EAAC,MAAM,UAAU,CAAC;AAkD/B;;;;GAIG;AACH;IAAmC,yCAAY;IAC7C,uBACkB,QAA6B,EAC7B,QAA6B,EACtC,YAAoB;QAFX,yBAAA,EAAA,aAA6B;QAC7B,yBAAA,EAAA,aAA6B;QACtC,6BAAA,EAAA,oBAAoB;QAH7B,YAKE,kBAAM,QAAQ,EAAE,QAAQ,CAAC,SAC1B;QALiB,cAAQ,GAAR,QAAQ,CAAqB;QAC7B,cAAQ,GAAR,QAAQ,CAAqB;QACtC,kBAAY,GAAZ,YAAY,CAAQ;;IAG7B,CAAC;IAEM,6BAAK,GAAZ;QACE,IAAM,KAAK,GAAG,iBAAM,KAAK,WAAmB,CAAC;QAC7C,KAAK,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;QACvC,OAAO,KAAK,CAAC;IACf,CAAC;IACH,oBAAC;AAAD,CAAC,AAdD,CAAmC,KAAK,GAcvC","sourcesContent":["import {Parse} from '../../data';\nimport {Dict} from '../../util';\nimport {Split} from '../split';\nimport {OutputNode} from './dataflow';\nimport {FacetNode} from './facet';\nimport {SourceNode} from './source';\n\nexport interface DataComponent {\n  /**\n   * A dictionary of sources indexed by a hash.\n   */\n  sources: Dict<SourceNode>;\n\n  /**\n   * Registry of output nodes.\n   */\n  outputNodes: Dict<OutputNode | FacetNode>;\n\n  /**\n   * How often is an output node used. If it is not used, we don't need to\n   * instantiate it in the assemble step.\n   */\n  outputNodeRefCounts: Dict<number>;\n\n  /**\n   * The output node before aggregation.\n   */\n  raw?: OutputNode;\n\n  /**\n   * The main output node.\n   */\n  main?: OutputNode;\n\n  /**\n   * For facets, we store the reference to the root node.\n   */\n  facetRoot?: FacetNode;\n\n  /**\n   * True if the data for this model is faceted.\n   * A dataset is faceted if a parent model is a facet and no new dataset is\n   * defined (which would make the data unfaceted again).\n   */\n  isFaceted: boolean;\n\n  /**\n   * Parse properties passed down from ancestors. Helps us to keep track of what has been parsed or is derived.\n   */\n  ancestorParse?: AncestorParse;\n}\n\n/**\n * Class to track interesting properties (see https://15721.courses.cs.cmu.edu/spring2016/papers/graefe-ieee1995.pdf)\n * about how fields have been parsed or whether they have been derived in a transform. We use this to not parse the\n * same field again (or differently).\n */\nexport class AncestorParse extends Split<Parse> {\n  constructor(\n    public readonly explicit: Partial<Parse> = {},\n    public readonly implicit: Partial<Parse> = {},\n    public parseNothing = false\n  ) {\n    super(explicit, implicit);\n  }\n\n  public clone(): AncestorParse {\n    const clone = super.clone() as AncestorParse;\n    clone.parseNothing = this.parseNothing;\n    return clone;\n  }\n}\n"]}