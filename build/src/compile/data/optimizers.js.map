{"version":3,"file":"optimizers.js","sourceRoot":"","sources":["../../../../src/compile/data/optimizers.ts"],"names":[],"mappings":"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","sourcesContent":["import {hasIntersection, keys} from '../../util';\nimport {DataFlowNode, isTransformNode, OutputNode, TransformNode} from './dataflow';\nimport {FacetNode} from './facet';\nimport {ParseNode} from './formatparse';\nimport {SourceNode} from './source';\nimport {TimeUnitNode} from './timeunit';\n\n/**\n * Start optimization path at the leaves. Useful for merging up or removing things.\n *\n * If the callback returns true, the recursion continues.\n */\nexport function iterateFromLeaves(f: (node: DataFlowNode) => boolean) {\n  function optimizeNextFromLeaves(node: DataFlowNode) {\n    if (node instanceof SourceNode) {\n      return;\n    }\n\n    const next = node.parent;\n    if (f(node)) {\n      optimizeNextFromLeaves(next);\n    }\n  }\n\n  return optimizeNextFromLeaves;\n}\n\n/**\n * Move parse nodes up to forks.\n */\nexport function moveParseUp(node: DataFlowNode) {\n  const parent = node.parent;\n\n  // move parse up by merging or swapping\n  if (node instanceof ParseNode) {\n    if (parent instanceof SourceNode) {\n      return false;\n    }\n\n    if (parent.numChildren() > 1) {\n      // don't move parse further up but continue with parent.\n      return true;\n    }\n\n    if (parent instanceof ParseNode) {\n      parent.merge(node);\n    } else {\n      // don't swap with nodes that produce something that the parse node depends on (e.g. lookup)\n      if (hasIntersection(parent.producedFields(), node.dependentFields())) {\n        return true;\n      }\n\n      node.swapWithParent();\n    }\n  }\n\n  return true;\n}\n\nfunction mergeBucket(parent: DataFlowNode, nodes: DataFlowNode[]) {\n  const mergedTransform = nodes.shift();\n  nodes.forEach(x => {\n    parent.removeChild(x);\n    x.parent = mergedTransform;\n    x.remove();\n  });\n}\n\n/**\n * Merge Identical Transforms at forks by comparing hashes.\n */\nexport function mergeIdenticalTransforms(node: DataFlowNode) {\n  const transforms = node.children.filter((x): x is TransformNode => isTransformNode(x));\n  const hashes = transforms.map(x => x.hash());\n  const buckets = {};\n  for (let i = 0; i < hashes.length; i++) {\n    if (buckets[hashes[i]] === undefined) {\n      buckets[hashes[i]] = [transforms[i]];\n    } else {\n      buckets[hashes[i]].push(transforms[i]);\n    }\n  }\n  for (const k of keys(buckets)) {\n    mergeBucket(node, buckets[k]);\n  }\n  node.children.forEach(mergeIdenticalTransforms);\n}\n\n/**\n * Repeatedly remove leaf nodes that are not output or facet nodes.\n * The reason is that we don't need subtrees that don't have any output nodes.\n * Facet nodes are needed for the row or column domains.\n */\nexport function removeUnusedSubtrees(node: DataFlowNode) {\n  if (node instanceof OutputNode || node.numChildren() > 0 || node instanceof FacetNode) {\n    // no need to continue with parent because it is output node or will have children (there was a fork)\n    return false;\n  } else {\n    node.remove();\n  }\n  return true;\n}\n\n/**\n * Removes duplicate time unit nodes (as determined by the name of the\n * output field) that may be generated due to selections projected over\n * time units.\n */\nexport function removeDuplicateTimeUnits(leaf: DataFlowNode) {\n  let fields = {};\n  return iterateFromLeaves((node: DataFlowNode) => {\n    if (node instanceof TimeUnitNode) {\n      const pfields = node.producedFields();\n      const dupe = keys(pfields).every(k => !!fields[k]);\n\n      if (dupe) {\n        node.remove();\n      } else {\n        fields = {...fields, ...pfields};\n      }\n    }\n\n    return true;\n  })(leaf);\n}\n"]}