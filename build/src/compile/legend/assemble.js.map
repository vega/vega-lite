{"version":3,"file":"assemble.js","sourceRoot":"","sources":["../../../../src/compile/legend/assemble.ts"],"names":[],"mappings":"AACA,OAAO,EAAC,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,MAAM,YAAY,CAAC;AAG1D,OAAO,EAAC,oBAAoB,EAAC,MAAM,SAAS,CAAC;AAE7C,MAAM,UAAU,eAAe,CAAC,KAAY;IAC1C,IAAM,oBAAoB,GAAG,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC;IACrD,IAAM,cAAc,GAA8C,EAAE,CAAC;IAErE,KAAsB,UAA0B,EAA1B,KAAA,IAAI,CAAC,oBAAoB,CAAC,EAA1B,cAA0B,EAA1B,IAA0B,EAAE;QAA7C,IAAM,OAAO,SAAA;QAChB,IAAM,cAAc,GAAG,KAAK,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;QACxD,IAAM,UAAU,GAAG,SAAS,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;QACrD,IAAI,cAAc,CAAC,UAAU,CAAC,EAAE;YAC9B,KAAoC,UAA0B,EAA1B,KAAA,cAAc,CAAC,UAAU,CAAC,EAA1B,cAA0B,EAA1B,IAA0B,EAAE;gBAA3D,IAAM,qBAAqB,SAAA;gBAC9B,IAAM,MAAM,GAAG,oBAAoB,CAAC,qBAAqB,EAAE,oBAAoB,CAAC,OAAO,CAAC,CAAC,CAAC;gBAC1F,IAAI,CAAC,MAAM,EAAE;oBACX,sDAAsD;oBACtD,cAAc,CAAC,UAAU,CAAC,CAAC,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC,CAAC;iBAChE;aACF;SACF;aAAM;YACL,cAAc,CAAC,UAAU,CAAC,GAAG,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC;SACtE;KACF;IAED,OAAO,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,GAAG,CAAC,UAAC,UAA2B,IAAK,OAAA,UAAU,CAAC,OAAO,EAAE,EAApB,CAAoB,CAAC,CAAC;AAClG,CAAC","sourcesContent":["import {Legend as VgLegend} from 'vega';\nimport {flatten, keys, stringify, vals} from '../../util';\nimport {Model} from '../model';\nimport {LegendComponent} from './component';\nimport {mergeLegendComponent} from './parse';\n\nexport function assembleLegends(model: Model): VgLegend[] {\n  const legendComponentIndex = model.component.legends;\n  const legendByDomain: {[domainHash: string]: LegendComponent[]} = {};\n\n  for (const channel of keys(legendComponentIndex)) {\n    const scaleComponent = model.getScaleComponent(channel);\n    const domainHash = stringify(scaleComponent.domains);\n    if (legendByDomain[domainHash]) {\n      for (const mergedLegendComponent of legendByDomain[domainHash]) {\n        const merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);\n        if (!merged) {\n          // If cannot merge, need to add this legend separately\n          legendByDomain[domainHash].push(legendComponentIndex[channel]);\n        }\n      }\n    } else {\n      legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];\n    }\n  }\n\n  return flatten(vals(legendByDomain)).map((legendCmpt: LegendComponent) => legendCmpt.combine());\n}\n"]}