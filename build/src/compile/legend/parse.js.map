{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../../../src/compile/legend/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import {COLOR, FILL, NonPositionScaleChannel, OPACITY, SHAPE, SIZE, STROKE} from '../../channel';\nimport {isFieldDef, title as fieldDefTitle} from '../../fielddef';\nimport {Legend, LEGEND_PROPERTIES, VG_LEGEND_PROPERTIES} from '../../legend';\nimport {GEOJSON} from '../../type';\nimport {deleteNestedProperty, keys} from '../../util';\nimport {VgLegend, VgLegendEncode} from '../../vega.schema';\nimport {getSpecifiedOrDefaultValue, guideEncodeEntry, mergeTitleComponent, numberFormat} from '../common';\nimport {isUnitModel, Model} from '../model';\nimport {parseGuideResolve} from '../resolve';\nimport {defaultTieBreaker, Explicit, makeImplicit, mergeValuesWithExplicit} from '../split';\nimport {UnitModel} from '../unit';\nimport {LegendComponent, LegendComponentIndex} from './component';\nimport * as encode from './encode';\nimport * as properties from './properties';\n\n\nexport function parseLegend(model: Model) {\n  if (isUnitModel(model)) {\n    model.component.legends = parseUnitLegend(model);\n  } else {\n    model.component.legends = parseNonUnitLegend(model);\n  }\n}\n\nfunction parseUnitLegend(model: UnitModel): LegendComponentIndex {\n  const {encoding} = model;\n  return [COLOR, FILL, STROKE, SIZE, SHAPE, OPACITY].reduce(function (legendComponent, channel) {\n    const def = encoding[channel];\n    if (model.legend(channel) && model.getScaleComponent(channel) && !(isFieldDef(def) && (channel === SHAPE && def.type === GEOJSON))) {\n      legendComponent[channel] = parseLegendForChannel(model, channel);\n    }\n    return legendComponent;\n  }, {});\n}\n\nfunction getLegendDefWithScale(model: UnitModel, channel: NonPositionScaleChannel): VgLegend {\n  // For binned field with continuous scale, use a special scale so we can overrride the mark props and labels\n  switch (channel) {\n    case COLOR:\n      const scale = model.scaleName(COLOR);\n      return model.markDef.filled ? {fill: scale} : {stroke: scale};\n    case FILL:\n    case STROKE:\n    case SIZE:\n    case SHAPE:\n    case OPACITY:\n      return {[channel]: model.scaleName(channel)};\n  }\n}\n\nexport function parseLegendForChannel(model: UnitModel, channel: NonPositionScaleChannel): LegendComponent {\n  const fieldDef = model.fieldDef(channel);\n  const legend = model.legend(channel);\n\n  const legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));\n\n  LEGEND_PROPERTIES.forEach(function(property) {\n    const value = getProperty(property, legend, channel, model);\n    if (value !== undefined) {\n      const explicit =\n        // specified legend.values is already respected, but may get transformed.\n        property === 'values' ? !!legend.values :\n        // title can be explicit if fieldDef.title is set\n        property === 'title' && value === model.fieldDef(channel).title ? true :\n        // Otherwise, things are explicit if the returned value matches the specified property\n        value === legend[property];\n      if (explicit || model.config.legend[property] === undefined) {\n        legendCmpt.set(property, value, explicit);\n      }\n    }\n  });\n\n  // 2) Add mark property definition groups\n  const legendEncoding = legend.encoding || {};\n  const legendEncode = ['labels', 'legend', 'title', 'symbols', 'gradient'].reduce((e: VgLegendEncode, part) => {\n    const legendEncodingPart = guideEncodeEntry(legendEncoding[part] || {}, model);\n    const value = encode[part] ?\n      // TODO: replace legendCmpt with type is sufficient\n      encode[part](fieldDef, legendEncodingPart, model, channel, legendCmpt.get('type')) : // apply rule\n      legendEncodingPart; // no rule -- just default values\n    if (value !== undefined && keys(value).length > 0) {\n      e[part] = {update: value};\n    }\n    return e;\n  }, {} as VgLegendEncode);\n\n  if (keys(legendEncode).length > 0) {\n    legendCmpt.set('encode', legendEncode, !!legend.encoding);\n  }\n\n  return legendCmpt;\n}\n\nfunction getProperty(property: keyof (Legend | VgLegend), specifiedLegend: Legend, channel: NonPositionScaleChannel, model: UnitModel) {\n  const fieldDef = model.fieldDef(channel);\n\n  switch (property) {\n    case 'format':\n      // We don't include temporal field here as we apply format in encode block\n      return numberFormat(fieldDef, specifiedLegend.format, model.config);\n    case 'title':\n      // For falsy value, keep undefined so we use default,\n      // but use null for '', null, and false to hide the title\n      const specifiedTitle = fieldDef.title !== undefined ? fieldDef.title :\n        specifiedLegend.title || (specifiedLegend.title === undefined ? undefined : null);\n\n      return getSpecifiedOrDefaultValue(\n        specifiedTitle,\n        fieldDefTitle(fieldDef, model.config)\n      ) || undefined; // make falsy value undefined so output Vega spec is shorter\n    case 'values':\n      return properties.values(specifiedLegend, fieldDef);\n    case 'type':\n      return getSpecifiedOrDefaultValue(specifiedLegend.type, properties.type(fieldDef.type, channel, model.getScaleComponent(channel).get('type')));\n  }\n\n  // Otherwise, return specified property.\n  return specifiedLegend[property];\n}\n\nfunction parseNonUnitLegend(model: Model) {\n  const {legends, resolve} = model.component;\n\n  for (const child of model.children) {\n    parseLegend(child);\n\n    keys(child.component.legends).forEach((channel: NonPositionScaleChannel) => {\n      resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);\n\n      if (resolve.legend[channel] === 'shared') {\n        // If the resolve says shared (and has not been overridden)\n        // We will try to merge and see if there is a conflict\n\n        legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);\n\n        if (!legends[channel]) {\n          // If merge returns nothing, there is a conflict so we cannot make the legend shared.\n          // Thus, mark legend as independent and remove the legend component.\n          resolve.legend[channel] = 'independent';\n          delete legends[channel];\n        }\n      }\n    });\n  }\n\n  keys(legends).forEach((channel: NonPositionScaleChannel) => {\n    for (const child of model.children) {\n      if (!child.component.legends[channel]) {\n        // skip if the child does not have a particular legend\n        continue;\n      }\n\n      if (resolve.legend[channel] === 'shared') {\n        // After merging shared legend, make sure to remove legend from child\n        delete child.component.legends[channel];\n      }\n    }\n  });\n  return legends;\n}\n\nexport function mergeLegendComponent(mergedLegend: LegendComponent, childLegend: LegendComponent): LegendComponent {\n  if (!mergedLegend) {\n    return childLegend.clone();\n  }\n  const mergedOrient = mergedLegend.getWithExplicit('orient');\n  const childOrient = childLegend.getWithExplicit('orient');\n\n\n  if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n    // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n    // Cannot merge due to inconsistent orient\n    return undefined;\n  }\n  let typeMerged = false;\n  // Otherwise, let's merge\n  for (const prop of VG_LEGEND_PROPERTIES) {\n    const mergedValueWithExplicit = mergeValuesWithExplicit<VgLegend, any>(\n      mergedLegend.getWithExplicit(prop),\n      childLegend.getWithExplicit(prop),\n      prop, 'legend',\n\n      // Tie breaker function\n      (v1: Explicit<any>, v2: Explicit<any>): any => {\n        switch (prop) {\n          case 'title':\n            return mergeTitleComponent(v1, v2);\n          case 'type':\n            // There are only two types. If we have different types, then prefer symbol over gradient.\n            typeMerged = true;\n            return makeImplicit('symbol');\n        }\n        return defaultTieBreaker<VgLegend, any>(v1, v2, prop, 'legend');\n      }\n    );\n    mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);\n  }\n  if (typeMerged) {\n    if(((mergedLegend.implicit || {}).encode || {}).gradient) {\n      deleteNestedProperty(mergedLegend.implicit, ['encode', 'gradient']);\n    }\n    if (((mergedLegend.explicit || {}).encode || {}).gradient) {\n      deleteNestedProperty(mergedLegend.explicit, ['encode', 'gradient']);\n    }\n  }\n\n\n  return mergedLegend;\n}\n\n"]}