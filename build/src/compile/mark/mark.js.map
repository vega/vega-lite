{"version":3,"file":"mark.js","sourceRoot":"","sources":["../../../../src/compile/mark/mark.ts"],"names":[],"mappings":"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","sourcesContent":["import {isArray} from 'vega-util';\nimport {MAIN} from '../../data';\nimport {Encoding, isAggregate} from '../../encoding';\nimport {getFieldDef, isFieldDef, isValueDef, vgField} from '../../fielddef';\nimport {AREA, isPathMark, LINE, Mark, TRAIL} from '../../mark';\nimport {isSortField} from '../../sort';\nimport {contains, keys} from '../../util';\nimport {getStyles, sortParams} from '../common';\nimport {UnitModel} from '../unit';\nimport {area} from './area';\nimport {bar} from './bar';\nimport {MarkCompiler} from './base';\nimport {geoshape} from './geoshape';\nimport {line, trail} from './line';\nimport {circle, point, square} from './point';\nimport {rect} from './rect';\nimport {rule} from './rule';\nimport {text} from './text';\nimport {tick} from './tick';\n\n\nconst markCompiler: {[m in Mark]: MarkCompiler} = {\n  area,\n  bar,\n  circle,\n  geoshape,\n  line,\n  point,\n  rect,\n  rule,\n  square,\n  text,\n  tick,\n  trail\n};\n\nexport function parseMarkGroup(model: UnitModel): any[] {\n  if (contains([LINE, AREA, TRAIL], model.mark)) {\n    return parsePathMark(model);\n  } else {\n    return getMarkGroups(model);\n  }\n}\n\nconst FACETED_PATH_PREFIX = 'faceted_path_';\n\nfunction parsePathMark(model: UnitModel) {\n  const details = pathGroupingFields(model.mark, model.encoding);\n\n  const pathMarks = getMarkGroups(model, {\n    // If has subfacet for line/area group, need to use faceted data from below.\n    fromPrefix: (details.length > 0 ? FACETED_PATH_PREFIX : '')\n  });\n\n  if (details.length > 0) { // have level of details - need to facet line into subgroups\n    // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n\n    return [{\n      name: model.getName('pathgroup'),\n      type: 'group',\n      from: {\n        facet: {\n          name: FACETED_PATH_PREFIX + model.requestDataName(MAIN),\n          data: model.requestDataName(MAIN),\n          groupby: details,\n        }\n      },\n      encode: {\n        update: {\n          width: {field: {group: 'width'}},\n          height: {field: {group: 'height'}}\n        }\n      },\n      marks: pathMarks\n    }];\n  } else {\n    return pathMarks;\n  }\n}\n\nexport function getSort(model: UnitModel) {\n  const {encoding, stack, mark, markDef} = model;\n  const order = encoding.order;\n  if (!isArray(order) && isValueDef(order)) {\n    return undefined;\n  } else if ((isArray(order) || isFieldDef(order)) && !stack) {\n    // Sort by the order field if it is specified and the field is not stacked. (For stacked field, order specify stack order.)\n    return sortParams(order, {expr: 'datum'});\n  } else if (isPathMark(mark)) {\n    // For both line and area, we sort values based on dimension by default\n    const dimensionChannelDef = encoding[markDef.orient === 'horizontal' ? 'y' : 'x'];\n    if (isFieldDef(dimensionChannelDef)) {\n      const s = dimensionChannelDef.sort;\n      const sortField = isSortField(s) ?\n        vgField({\n          // FIXME: this op might not already exist?\n          // FIXME: what if dimensionChannel (x or y) contains custom domain?\n          aggregate: isAggregate(model.encoding) ? s.op : undefined,\n          field: s.field\n        }, {expr: 'datum'}) :\n        vgField(dimensionChannelDef, {\n          // For stack with imputation, we only have bin_mid\n          binSuffix: model.stack && model.stack.impute ? 'mid' : undefined,\n          expr: 'datum'\n        });\n\n      return {\n        field: sortField,\n        order: 'descending'\n      };\n    }\n    return undefined;\n  }\n  return undefined;\n}\n\nfunction getMarkGroups(model: UnitModel, opt: {\n  fromPrefix: string\n} = {fromPrefix: ''}) {\n  const mark = model.mark;\n\n  const clip = model.markDef.clip !== undefined ?\n    !!model.markDef.clip : scaleClip(model);\n  const style = getStyles(model.markDef);\n  const key = model.encoding.key;\n  const sort = getSort(model);\n\n  const postEncodingTransform = markCompiler[mark].postEncodingTransform ? markCompiler[mark].postEncodingTransform(model) : null;\n\n  return [{\n    name: model.getName('marks'),\n    type: markCompiler[mark].vgMark,\n    ...(clip ? {clip: true} : {}),\n    ...(style ? {style} : {}),\n    ...(key ? {key: {field: key.field}} : {}),\n    ...(sort ? {sort} : {}),\n    from: {data: opt.fromPrefix + model.requestDataName(MAIN)},\n    encode: {\n      update: markCompiler[mark].encodeEntry(model)\n    },\n    ...(postEncodingTransform ? {\n      transform: postEncodingTransform\n    } : {})\n  }];\n\n}\n\n/**\n * Returns list of path grouping fields\n * that the model's spec contains.\n */\nexport function pathGroupingFields(mark: Mark, encoding: Encoding<string>): string[] {\n  return keys(encoding).reduce((details, channel) => {\n    switch (channel) {\n      // x, y, x2, y2, lat, long, lat1, long2, order, tooltip, href, cursor should not cause lines to group\n      case 'x':\n      case 'y':\n      case 'order':\n      case 'tooltip':\n      case 'href':\n      case 'x2':\n      case 'y2':\n\n      case 'latitude':\n      case 'longitude':\n      case 'latitude2':\n      case 'longitude2':\n      // TODO: case 'cursor':\n\n      // text, shape, shouldn't be a part of line/trail/area\n      case 'text':\n      case 'shape':\n        return details;\n\n      case 'detail':\n      case 'key':\n        const channelDef = encoding[channel];\n        if (channelDef) {\n          (isArray(channelDef) ? channelDef : [channelDef]).forEach((fieldDef) => {\n            if (!fieldDef.aggregate) {\n              details.push(vgField(fieldDef, {}));\n            }\n          });\n        }\n        return details;\n\n      case 'size':\n        if (mark === 'trail') {\n          // For trail, size should not group trail lines.\n          return details;\n        }\n        // For line, it should group lines.\n\n      /* tslint:disable */\n      // intentional fall through\n\n      case 'color':\n      case 'fill':\n      case 'stroke':\n      case 'opacity':\n      // TODO strokeDashOffset:\n\n      /* tslint:enable */\n        const fieldDef = getFieldDef<string>(encoding[channel]);\n        if (fieldDef && !fieldDef.aggregate) {\n          details.push(vgField(fieldDef, {}));\n        }\n        return details;\n      default:\n        throw new Error(`Bug: Channel ${channel} unimplemented for line mark`);\n    }\n  }, []);\n}\n\n/**\n * If scales are bound to interval selections, we want to automatically clip\n * marks to account for panning/zooming interactions. We identify bound scales\n * by the domainRaw property, which gets added during scale parsing.\n */\nfunction scaleClip(model: UnitModel) {\n  const xScale = model.getScaleComponent('x');\n  const yScale = model.getScaleComponent('y');\n  return (xScale && xScale.get('domainRaw')) ||\n    (yScale && yScale.get('domainRaw')) ? true : false;\n}\n"]}