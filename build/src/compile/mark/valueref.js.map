{"version":3,"file":"valueref.js","sourceRoot":"","sources":["../../../../src/compile/mark/valueref.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Utility files for producing Vega ValueRef for marks\n */\nimport {isArray, isFunction, isString} from 'vega-util';\n\nimport {Channel, X, Y} from '../../channel';\nimport {Config} from '../../config';\nimport {\n  ChannelDef,\n  ChannelDefWithCondition,\n  FieldDef,\n  FieldRefOption,\n  isFieldDef,\n  isValueDef,\n  TextFieldDef,\n  vgField,\n} from '../../fielddef';\nimport * as log from '../../log';\nimport {Mark, MarkDef} from '../../mark';\nimport {hasDiscreteDomain, ScaleType} from '../../scale';\nimport {StackProperties} from '../../stack';\nimport {QUANTITATIVE} from '../../type';\nimport {contains, some} from '../../util';\nimport {VgSignalRef, VgValueRef} from '../../vega.schema';\nimport {binRequiresRange, formatSignalRef} from '../common';\nimport {ScaleComponent} from '../scale/component';\n\n\n// TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated.  For now, this is a huge step moving forward.\n\n/**\n * @return Vega ValueRef for normal x- or y-position without projection\n */\nexport function position(channel: 'x' | 'y', channelDef: ChannelDef<string>, scaleName: string, scale: ScaleComponent,\n    stack: StackProperties, defaultRef: VgValueRef | (() => VgValueRef)): VgValueRef {\n  if (isFieldDef(channelDef) && stack && channel === stack.fieldChannel) {\n    // x or y use stack_end so that stacked line's point mark use stack_end too.\n    return fieldRef(channelDef, scaleName, {suffix: 'end'});\n  }\n  return midPoint(channel, channelDef, scaleName, scale, stack, defaultRef);\n}\n\n/**\n * @return Vega ValueRef for normal x2- or y2-position without projection\n */\nexport function position2(channel: 'x2' | 'y2', aFieldDef: ChannelDef<string>, a2fieldDef: ChannelDef<string>, scaleName: string, scale: ScaleComponent,\n  stack: StackProperties, defaultRef: VgValueRef | (() => VgValueRef)): VgValueRef {\n  if (isFieldDef(aFieldDef) && stack &&\n      // If fieldChannel is X and channel is X2 (or Y and Y2)\n      channel.charAt(0) === stack.fieldChannel.charAt(0)\n      ) {\n    return fieldRef(aFieldDef, scaleName, {suffix: 'start'});\n  }\n  return midPoint(channel, a2fieldDef, scaleName, scale, stack, defaultRef);\n}\n\n\n\nexport function getOffset(channel: 'x' | 'y' | 'x2' | 'y2', markDef: MarkDef) {\n  const offsetChannel = channel + 'Offset';\n  // TODO: in the future read from encoding channel too\n\n  const markDefOffsetValue = markDef[offsetChannel];\n  if (markDefOffsetValue) {\n    return markDefOffsetValue;\n  }\n\n  return undefined;\n}\n\n/**\n * Value Ref for binned fields\n */\nexport function bin(fieldDef: FieldDef<string>, scaleName: string, side: 'start' | 'end', offset?: number) {\n  const binSuffix = side === 'start' ? undefined : 'end';\n  return fieldRef(fieldDef, scaleName, {binSuffix}, offset ? {offset} : {});\n}\n\nexport function fieldRef(\n    fieldDef: FieldDef<string>, scaleName: string, opt: FieldRefOption,\n    mixins?: {offset?: number | VgValueRef, band?: number|boolean}\n  ): VgValueRef {\n\n  const ref: VgValueRef = {\n    ...(scaleName ? {scale: scaleName} : {}),\n    field: vgField(fieldDef, opt),\n  };\n\n  if (mixins) {\n    return {\n      ...ref,\n      ...mixins\n    };\n  }\n  return ref;\n}\n\nexport function bandRef(scaleName: string, band: number|boolean = true): VgValueRef {\n  return {\n    scale: scaleName,\n    band: band\n  };\n}\n\n/**\n * Signal that returns the middle of a bin. Should only be used with x and y.\n */\nfunction binMidSignal(fieldDef: FieldDef<string>, scaleName: string) {\n  return {\n    signal: `(` +\n      `scale(\"${scaleName}\", ${vgField(fieldDef, {expr: 'datum'})})` +\n      ` + ` +\n      `scale(\"${scaleName}\", ${vgField(fieldDef, {binSuffix: 'end', expr: 'datum'})})`+\n    `)/2`\n  };\n}\n\n/**\n * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.\n */\nexport function midPoint(\n  channel: Channel,\n  channelDef: ChannelDef<string>,\n  scaleName: string,\n  scale: ScaleComponent,\n  stack: StackProperties,\n  defaultRef: VgValueRef | (() => VgValueRef)\n): VgValueRef {\n  // TODO: datum support\n\n  if (channelDef) {\n    /* istanbul ignore else */\n\n    if (isFieldDef(channelDef)) {\n      if (channelDef.bin) {\n        // Use middle only for x an y to place marks in the center between start and end of the bin range.\n        // We do not use the mid point for other channels (e.g. size) so that properties of legends and marks match.\n        if (contains([X, Y], channel) && channelDef.type === QUANTITATIVE) {\n          if (stack && stack.impute) {\n            // For stack, we computed bin_mid so we can impute.\n            return fieldRef(channelDef, scaleName, {binSuffix: 'mid'});\n          }\n          // For non-stack, we can just calculate bin mid on the fly using signal.\n          return binMidSignal(channelDef, scaleName);\n        }\n        return fieldRef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? {binSuffix: 'range'} : {});\n      }\n\n      if (scale) {\n        const scaleType = scale.get('type');\n        if (hasDiscreteDomain(scaleType)) {\n          if (scaleType === 'band') {\n            // For band, to get mid point, need to offset by half of the band\n            return fieldRef(channelDef, scaleName, {binSuffix: 'range'}, {band: 0.5});\n          }\n          return fieldRef(channelDef, scaleName, {binSuffix: 'range'});\n        }\n      }\n      return fieldRef(channelDef, scaleName, {}); // no need for bin suffix\n    } else if (isValueDef(channelDef)) {\n      const value = channelDef.value;\n\n      if (contains(['x', 'x2'], channel) && value === 'width') {\n        return {field: {group: 'width'}};\n      } else if (contains(['y', 'y2'], channel) && value === 'height') {\n        return {field: {group: 'height'}};\n      }\n\n      return {value};\n    }\n\n    // If channelDef is neither field def or value def, it's a condition-only def.\n    // In such case, we will use default ref.\n  }\n\n  return isFunction(defaultRef) ? defaultRef() : defaultRef;\n}\n\nexport function text(textDef: ChannelDefWithCondition<TextFieldDef<string>>, config: Config): VgValueRef {\n  // text\n  if (textDef) {\n    if (isFieldDef(textDef)) {\n      return formatSignalRef(textDef, textDef.format, 'datum', config);\n    } else if (isValueDef(textDef)) {\n      return {value: textDef.value};\n    }\n  }\n  return undefined;\n}\n\nexport function mid(sizeRef: VgSignalRef): VgValueRef {\n  return {...sizeRef, mult: 0.5};\n}\n\n/**\n * Whether the scale definitely includes zero in the domain\n */\nfunction domainDefinitelyIncludeZero(scale: ScaleComponent) {\n  if (scale.get('zero') !== false) {\n    return true;\n  }\n  const domains = scale.domains;\n  if (isArray(domains)) {\n    return some(domains, (d) => isArray(d) && d.length === 2 && d[0] <=0 && d[1] >= 0);\n  }\n  return false;\n}\n\nexport function getDefaultRef(\n  defaultRef: VgValueRef | 'zeroOrMin' | 'zeroOrMax',\n  channel: 'x' | 'y', scaleName: string, scale: ScaleComponent, mark: Mark\n) {\n  return () => {\n    if (isString(defaultRef)) {\n      if (scaleName) {\n        const scaleType = scale.get('type');\n        if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType)) {\n          // Log scales cannot have zero.\n          // Zero in time scale is arbitrary, and does not affect ratio.\n          // (Time is an interval level of measurement, not ratio).\n          // See https://en.wikipedia.org/wiki/Level_of_measurement for more info.\n          if (mark === 'bar' || mark === 'area') {\n            log.warn(log.message.nonZeroScaleUsedWithLengthMark(mark, channel, {scaleType}));\n          }\n        } else {\n          if (domainDefinitelyIncludeZero(scale)) {\n            return {\n              scale: scaleName,\n              value: 0\n            };\n          }\n          if (mark === 'bar' || mark === 'area') {\n            log.warn(log.message.nonZeroScaleUsedWithLengthMark(\n              mark, channel, {zeroFalse: scale.explicit.zero === false}\n            ));\n          }\n        }\n      }\n\n      if (defaultRef === 'zeroOrMin') {\n        return channel === 'x' ? {value: 0} : {field: {group: 'height'}};\n      } else { // zeroOrMax\n        return channel === 'x' ? {field: {group: 'width'}} : {value: 0};\n      }\n    }\n    return defaultRef;\n  };\n}\n\n"]}