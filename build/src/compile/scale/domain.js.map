{"version":3,"file":"domain.js","sourceRoot":"","sources":["../../../../src/compile/scale/domain.ts"],"names":[],"mappings":"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","sourcesContent":["import {isString} from 'vega-util';\nimport {SHARED_DOMAIN_OP_INDEX} from '../../aggregate';\nimport {binToString, isBinParams} from '../../bin';\nimport {isScaleChannel, ScaleChannel} from '../../channel';\nimport {MAIN, RAW} from '../../data';\nimport {DateTime} from '../../datetime';\nimport {FieldDef, ScaleFieldDef, valueExpr, vgField} from '../../fielddef';\nimport * as log from '../../log';\nimport {Domain, hasDiscreteDomain, isBinScale, isSelectionDomain, ScaleConfig, ScaleType} from '../../scale';\nimport {EncodingSortField, isSortArray, isSortField} from '../../sort';\nimport {TimeUnit} from '../../timeunit';\nimport {Type} from '../../type';\nimport * as util from '../../util';\nimport {isDataRefDomain, isDataRefUnionedDomain, isFieldRefUnionDomain, VgDataRef, VgDomain, VgFieldRefUnionDomain, VgNonUnionDomain, VgSortField, VgUnionSortField} from '../../vega.schema';\nimport {binRequiresRange} from '../common';\nimport {sortArrayIndexField} from '../data/calculate';\nimport {FACET_SCALE_PREFIX} from '../data/optimize';\nimport {isFacetModel, isUnitModel, Model} from '../model';\nimport {SELECTION_DOMAIN} from '../selection/selection';\nimport {UnitModel} from '../unit';\nimport {ScaleComponentIndex} from './component';\n\n\nexport function parseScaleDomain(model: Model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleDomain(model);\n  } else {\n    parseNonUnitScaleDomain(model);\n  }\n}\n\nfunction parseUnitScaleDomain(model: UnitModel) {\n  const scales = model.specifiedScales;\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  util.keys(localScaleComponents).forEach((channel: ScaleChannel) => {\n    const specifiedScale = scales[channel];\n    const specifiedDomain = specifiedScale ? specifiedScale.domain : undefined;\n\n    const domains = parseDomainForChannel(model, channel);\n    const localScaleCmpt = localScaleComponents[channel];\n    localScaleCmpt.domains = domains;\n\n    if (isSelectionDomain(specifiedDomain)) {\n      // As scale parsing occurs before selection parsing, we use a temporary\n      // signal here and append the scale.domain definition. This is replaced\n      // with the correct domainRaw signal during scale assembly.\n      // For more information, see isRawSelectionDomain in selection.ts.\n\n      // FIXME: replace this with a special property in the scaleComponent\n      localScaleCmpt.set('domainRaw', {\n        signal: SELECTION_DOMAIN + util.hash(specifiedDomain)\n      }, true);\n    }\n\n    if (model.component.data.isFaceted) {\n      // get resolve from closest facet parent as this decides whether we need to refer to cloned subtree or not\n      let facetParent: Model = model;\n      while (!isFacetModel(facetParent) && facetParent.parent) {\n        facetParent = facetParent.parent;\n      }\n\n      const resolve = facetParent.component.resolve.scale[channel];\n\n      if (resolve === 'shared') {\n        for (const domain of domains) {\n          // Replace the scale domain with data output from a cloned subtree after the facet.\n          if (isDataRefDomain(domain)) {\n            // use data from cloned subtree (which is the same as data but with a prefix added once)\n            domain.data = FACET_SCALE_PREFIX + domain.data.replace(FACET_SCALE_PREFIX, '');\n          }\n        }\n      }\n    }\n  });\n}\n\nfunction parseNonUnitScaleDomain(model: Model) {\n  for (const child of model.children) {\n    parseScaleDomain(child);\n  }\n\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  util.keys(localScaleComponents).forEach((channel: ScaleChannel) => {\n    let domains: VgNonUnionDomain[];\n    let domainRaw = null;\n\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n      if (childComponent) {\n        if (domains === undefined) {\n          domains = childComponent.domains;\n        } else {\n          domains = domains.concat(childComponent.domains);\n        }\n\n        const dr = childComponent.get('domainRaw');\n        if (domainRaw && dr && domainRaw.signal !== dr.signal) {\n          log.warn('The same selection must be used to override scale domains in a layered view.');\n        }\n        domainRaw = dr;\n      }\n    }\n\n    localScaleComponents[channel].domains = domains;\n\n    if (domainRaw) {\n      localScaleComponents[channel].set('domainRaw', domainRaw, true);\n    }\n  });\n}\n\n\n/**\n * Remove unaggregated domain if it is not applicable\n * Add unaggregated domain if domain is not specified and config.scale.useUnaggregatedDomain is true.\n */\nfunction normalizeUnaggregatedDomain(domain: Domain, fieldDef: FieldDef<string>, scaleType: ScaleType, scaleConfig: ScaleConfig) {\n  if (domain === 'unaggregated') {\n    const {valid, reason} = canUseUnaggregatedDomain(fieldDef, scaleType);\n    if(!valid) {\n      log.warn(reason);\n      return undefined;\n    }\n  } else if (domain === undefined && scaleConfig.useUnaggregatedDomain) {\n    // Apply config if domain is not specified.\n    const {valid} = canUseUnaggregatedDomain(fieldDef, scaleType);\n    if (valid) {\n      return 'unaggregated';\n    }\n  }\n\n  return domain;\n}\n\nexport function parseDomainForChannel(model: UnitModel, channel: ScaleChannel): VgNonUnionDomain[] {\n  const scaleType = model.getScaleComponent(channel).get('type');\n\n  const domain = normalizeUnaggregatedDomain(model.scaleDomain(channel), model.fieldDef(channel), scaleType, model.config.scale);\n  if (domain !== model.scaleDomain(channel)) {\n    model.specifiedScales[channel] = {\n      ...model.specifiedScales[channel],\n      domain\n    };\n  }\n\n  // If channel is either X or Y then union them with X2 & Y2 if they exist\n  if (channel === 'x' && model.channelHasField('x2')) {\n    if (model.channelHasField('x')) {\n      return parseSingleChannelDomain(scaleType, domain, model, 'x').concat(parseSingleChannelDomain(scaleType, domain, model, 'x2'));\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'x2');\n    }\n  } else if (channel === 'y' && model.channelHasField('y2')) {\n    if (model.channelHasField('y')) {\n      return parseSingleChannelDomain(scaleType, domain, model, 'y').concat(parseSingleChannelDomain(scaleType, domain, model, 'y2'));\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'y2');\n    }\n  }\n  return parseSingleChannelDomain(scaleType, domain, model, channel);\n}\n\nfunction mapDomainToDataSignal<T>(domain: T[], type: Type, timeUnit: TimeUnit) {\n  return domain.map(v => {\n    const data = valueExpr(v, {timeUnit, type});\n    return {signal: `{data: ${data}}`};\n  });\n}\n\nfunction parseSingleChannelDomain(scaleType: ScaleType, domain: Domain, model: UnitModel, channel: ScaleChannel | 'x2' | 'y2'): VgNonUnionDomain[] {\n  const fieldDef = model.fieldDef(channel);\n\n  if (domain && domain !== 'unaggregated' && !isSelectionDomain(domain)) { // explicit value\n    const {type, timeUnit} = fieldDef;\n    if (type === 'temporal' || timeUnit) {\n      return mapDomainToDataSignal<number|string|boolean|DateTime>(domain, type, timeUnit);\n    }\n\n    return [domain];\n  }\n\n  const stack = model.stack;\n  if (stack && channel === stack.fieldChannel) {\n    if(stack.offset === 'normalize') {\n      return [[0, 1]];\n    }\n\n    const data = model.requestDataName(MAIN);\n    return [{\n      data,\n      field: model.vgField(channel, {suffix: 'start'})\n    }, {\n      data,\n      field: model.vgField(channel, {suffix: 'end'})\n    }];\n  }\n\n  const sort = isScaleChannel(channel) ? domainSort(model, channel, scaleType) : undefined;\n\n  if (domain === 'unaggregated') {\n    const data = model.requestDataName(MAIN);\n    const {field} = fieldDef;\n    return [{\n      data,\n      field: vgField({field, aggregate: 'min'})\n    }, {\n      data,\n      field: vgField({field, aggregate: 'max'})\n    }];\n  } else if (fieldDef.bin) { // bin\n    if (isBinScale(scaleType)) {\n      const signal = model.getName(`${binToString(fieldDef.bin)}_${fieldDef.field}_bins`);\n      return [{signal: `sequence(${signal}.start, ${signal}.stop + ${signal}.step, ${signal}.step)`}];\n    }\n\n    if (hasDiscreteDomain(scaleType)) {\n      // ordinal bin scale takes domain from bin_range, ordered by bin start\n      // This is useful for both axis-based scale (x/y) and legend-based scale (other channels).\n      return [{\n        // If sort by aggregation of a specified sort field, we need to use RAW table,\n        // so we can aggregate values for the scale independently from the main aggregation.\n        data: util.isBoolean(sort) ? model.requestDataName(MAIN) : model.requestDataName(RAW),\n        // Use range if we added it and the scale does not support computing a range as a signal.\n        field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? {binSuffix: 'range'} : {}),\n        // we have to use a sort object if sort = true to make the sort correct by bin start\n        sort: sort === true || !isSortField(sort) ? {\n          field: model.vgField(channel, {}),\n          op: 'min' // min or max doesn't matter since we sort by the start of the bin range\n        } : sort\n      }];\n    } else { // continuous scales\n      if (channel === 'x' || channel === 'y') {\n        if (isBinParams(fieldDef.bin) && fieldDef.bin.extent) {\n          return [fieldDef.bin.extent];\n        }\n        // X/Y position have to include start and end for non-ordinal scale\n        const data = model.requestDataName(MAIN);\n        return [{\n          data,\n          field: model.vgField(channel, {})\n        }, {\n          data,\n          field: model.vgField(channel, {binSuffix: 'end'})\n        }];\n      } else {\n        // TODO: use bin_mid\n        return [{\n          data: model.requestDataName(MAIN),\n          field: model.vgField(channel, {})\n        }];\n      }\n    }\n  } else if (sort) {\n    return [{\n      // If sort by aggregation of a specified sort field, we need to use RAW table,\n      // so we can aggregate values for the scale independently from the main aggregation.\n      data: util.isBoolean(sort) ? model.requestDataName(MAIN) : model.requestDataName(RAW),\n      field: model.vgField(channel),\n      sort: sort\n    }];\n  } else {\n    return [{\n      data: model.requestDataName(MAIN),\n      field: model.vgField(channel)\n    }];\n  }\n}\n\n\nexport function domainSort(model: UnitModel, channel: ScaleChannel, scaleType: ScaleType): true | EncodingSortField<string> {\n  if (!hasDiscreteDomain(scaleType)) {\n    return undefined;\n  }\n\n  const fieldDef: ScaleFieldDef<string> = model.fieldDef(channel);\n  const sort = fieldDef.sort;\n\n  // if the sort is specified with array, use the derived sort index field\n  if (isSortArray(sort)) {\n    return {\n      op: 'min',\n      field: sortArrayIndexField(fieldDef, channel),\n      order: 'ascending'\n    };\n  }\n\n  // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n  if (isSortField(sort)) {\n    // flatten nested fields\n    return {\n      ...sort,\n      ...(sort.field ? {field: util.replacePathInField(sort.field)} : {})\n    };\n  }\n\n  if (sort === 'descending') {\n    return {\n      op: 'min',\n      field: model.vgField(channel),\n      order: 'descending'\n    };\n  }\n\n  if (util.contains(['ascending', undefined /* default =ascending*/], sort)) {\n    return true;\n  }\n\n  // sort == null\n  return undefined;\n}\n\n\n\n/**\n * Determine if a scale can use unaggregated domain.\n * @return {Boolean} Returns true if all of the following conditons applies:\n * 1. `scale.domain` is `unaggregated`\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\nexport function canUseUnaggregatedDomain(fieldDef: FieldDef<string>, scaleType: ScaleType): {valid: boolean, reason?: string} {\n  if (!fieldDef.aggregate) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainHasNoEffectForRawField(fieldDef)\n    };\n  }\n\n  if (!SHARED_DOMAIN_OP_INDEX[fieldDef.aggregate]) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainWithNonSharedDomainOp(fieldDef.aggregate)\n    };\n  }\n\n  if (fieldDef.type === 'quantitative') {\n    if (scaleType === 'log') {\n      return {\n        valid: false,\n        reason: log.message.unaggregatedDomainWithLogScale(fieldDef)\n      };\n    }\n  }\n\n  return {valid: true};\n}\n\n/**\n * Converts an array of domains to a single Vega scale domain.\n */\nexport function mergeDomains(domains: VgNonUnionDomain[]): VgDomain {\n  const uniqueDomains = util.unique(domains.map(domain => {\n    // ignore sort property when computing the unique domains\n    if (isDataRefDomain(domain)) {\n      const {sort: _s, ...domainWithoutSort} = domain;\n      return domainWithoutSort;\n    }\n    return domain;\n  }), util.hash);\n\n  const sorts: VgSortField[] = util.unique(domains.map(d => {\n    if (isDataRefDomain(d)) {\n      const s = d.sort;\n      if (s !== undefined && !util.isBoolean(s)) {\n        if (s.op === 'count') {\n          // let's make sure that if op is count, we don't use a field\n          delete s.field;\n        }\n        if (s.order === 'ascending') {\n          // drop order: ascending as it is the default\n          delete s.order;\n        }\n      }\n      return s;\n    }\n    return undefined;\n  }).filter(s => s !== undefined), util.hash);\n\n  if (uniqueDomains.length === 1) {\n    const domain = domains[0];\n    if (isDataRefDomain(domain) && sorts.length > 0) {\n      let sort = sorts[0];\n      if (sorts.length > 1) {\n        log.warn(log.message.MORE_THAN_ONE_SORT);\n        sort = true;\n      }\n      return {\n        ...domain,\n        sort\n      };\n    }\n    return domain;\n  }\n\n  // only keep simple sort properties that work with unioned domains\n  const simpleSorts = util.unique(sorts.map(s => {\n    if (s === true) {\n      return s;\n    }\n    if (s.op === 'count') {\n      return s;\n    }\n    log.warn(log.message.domainSortDropped(s));\n    return true;\n  }), util.hash) as VgUnionSortField[];\n\n  let sort: VgUnionSortField = undefined;\n\n  if (simpleSorts.length === 1) {\n    sort = simpleSorts[0];\n  } else if (simpleSorts.length > 1) {\n    log.warn(log.message.MORE_THAN_ONE_SORT);\n    sort = true;\n  }\n\n  const allData = util.unique(domains.map(d => {\n    if (isDataRefDomain(d)) {\n      return d.data;\n    }\n    return null;\n  }), x => x);\n\n  if (allData.length === 1 && allData[0] !== null) {\n    // create a union domain of different fields with a single data source\n    const domain: VgFieldRefUnionDomain = {\n      data: allData[0],\n      fields: uniqueDomains.map(d => (d as VgDataRef).field),\n      ...(sort ? {sort} : {})\n    };\n\n    return domain;\n  }\n\n  return {fields: uniqueDomains, ...(sort ? {sort} : {})};\n}\n\n/**\n * Return a field if a scale single field.\n * Return `undefined` otherwise.\n *\n */\nexport function getFieldFromDomain(domain: VgDomain): string {\n  if (isDataRefDomain(domain) && isString(domain.field)) {\n    return domain.field;\n  } else if (isDataRefUnionedDomain(domain)) {\n    let field;\n    for (const nonUnionDomain of domain.fields) {\n      if (isDataRefDomain(nonUnionDomain) && isString(nonUnionDomain.field)) {\n        if (!field) {\n          field = nonUnionDomain.field;\n        } else if (field !== nonUnionDomain.field) {\n          log.warn('Detected faceted independent scales that union domain of multiple fields from different data sources.  We will use the first field.  The result view size may be incorrect.');\n          return field;\n        }\n      }\n    }\n    log.warn('Detected faceted independent scales that union domain of identical fields from different source detected.  We will assume that this is the same field from a different fork of the same data source.  However, if this is not case, the result view size maybe incorrect.');\n    return field;\n  } else if (isFieldRefUnionDomain(domain)) {\n    log.warn('Detected faceted independent scales that union domain of multiple fields from the same data source.  We will use the first field.  The result view size may be incorrect.');\n    const field = domain.fields[0];\n    return isString(field) ? field : undefined;\n  }\n\n  return undefined;\n}\n\nexport function assembleDomain(model: Model, channel: ScaleChannel) {\n  const scaleComponent = model.component.scales[channel];\n  const domains = scaleComponent.domains.map(domain => {\n    // Correct references to data as the original domain's data was determined\n    // in parseScale, which happens before parseData. Thus the original data\n    // reference can be incorrect.\n\n    if (isDataRefDomain(domain)) {\n      domain.data = model.lookupDataSource(domain.data);\n    }\n    return domain;\n  });\n\n  // domains is an array that has to be merged into a single vega domain\n  return mergeDomains(domains);\n}\n"]}