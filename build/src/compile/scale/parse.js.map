{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../../../src/compile/scale/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import {SCALE_CHANNELS, ScaleChannel, SHAPE, X, Y} from '../../channel';\nimport {FieldDef, getFieldDef, hasConditionalFieldDef, isFieldDef} from '../../fielddef';\nimport {GEOSHAPE} from '../../mark';\nimport {\n  NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES,\n  Scale,\n  scaleCompatible,\n  ScaleType,\n  scaleTypePrecedence,\n} from '../../scale';\nimport {GEOJSON} from '../../type';\nimport {keys} from '../../util';\nimport {VgScale} from '../../vega.schema';\nimport {isUnitModel, Model} from '../model';\nimport {defaultScaleResolve} from '../resolve';\nimport {Explicit, mergeValuesWithExplicit, tieBreakByComparing} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponent, ScaleComponentIndex} from './component';\nimport {parseScaleDomain} from './domain';\nimport {parseScaleProperty} from './properties';\nimport {parseScaleRange} from './range';\nimport {scaleType} from './type';\n\nexport function parseScale(model: Model) {\n  parseScaleCore(model);\n  parseScaleDomain(model);\n  for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {\n    parseScaleProperty(model, prop);\n  }\n  // range depends on zero\n  parseScaleRange(model);\n}\n\nexport function parseScaleCore(model: Model) {\n  if (isUnitModel(model)) {\n    model.component.scales = parseUnitScaleCore(model);\n  } else {\n    model.component.scales = parseNonUnitScaleCore(model);\n  }\n}\n\n/**\n * Parse scales for all channels of a model.\n */\nfunction parseUnitScaleCore(model: UnitModel): ScaleComponentIndex {\n  const {encoding, config, mark} = model;\n\n  return SCALE_CHANNELS.reduce((scaleComponents: ScaleComponentIndex, channel: ScaleChannel) => {\n    let fieldDef: FieldDef<string>;\n    let specifiedScale: Scale | null = undefined;\n\n    const channelDef = encoding[channel];\n\n    // Don't generate scale for shape of geoshape\n    if (\n      isFieldDef(channelDef) && mark === GEOSHAPE &&\n      channel === SHAPE && channelDef.type === GEOJSON\n    ) {\n      return scaleComponents;\n    }\n\n    if (isFieldDef(channelDef)) {\n      fieldDef = channelDef;\n      specifiedScale = channelDef.scale;\n    } else if (hasConditionalFieldDef(channelDef)) {\n      fieldDef = channelDef.condition;\n      specifiedScale = channelDef.condition['scale']; // We use ['scale'] since we know that channel here has scale for sure\n    } else if (channel === X) {\n      fieldDef = getFieldDef(encoding.x2);\n    } else if (channel === Y) {\n      fieldDef = getFieldDef(encoding.y2);\n    }\n\n    if (fieldDef && specifiedScale !== null && specifiedScale !== false) {\n      specifiedScale = specifiedScale || {};\n      const specifiedScaleType = specifiedScale.type;\n      const sType = scaleType(specifiedScale.type, channel, fieldDef, mark, config.scale);\n      scaleComponents[channel] = new ScaleComponent(\n        model.scaleName(channel + '', true),\n        {value: sType, explicit: specifiedScaleType === sType}\n      );\n    }\n    return scaleComponents;\n  }, {});\n}\n\nconst scaleTypeTieBreaker = tieBreakByComparing(\n  (st1: ScaleType, st2: ScaleType) => (scaleTypePrecedence(st1) - scaleTypePrecedence(st2))\n);\n\n\nfunction parseNonUnitScaleCore(model: Model) {\n  const scaleComponents: ScaleComponentIndex = model.component.scales = {};\n\n  const scaleTypeWithExplicitIndex: {\n    // Using Mapped Type to declare type (https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types)\n    [k in ScaleChannel]?: Explicit<ScaleType>\n  } = {};\n  const resolve = model.component.resolve;\n\n  // Parse each child scale and determine if a particular channel can be merged.\n  for (const child of model.children) {\n    parseScaleCore(child);\n\n    // Instead of always merging right away -- check if it is compatible to merge first!\n    keys(child.component.scales).forEach((channel: ScaleChannel) => {\n      // if resolve is undefined, set default first\n      resolve.scale[channel] = resolve.scale[channel] || defaultScaleResolve(channel, model);\n\n      if (resolve.scale[channel] === 'shared') {\n        const explicitScaleType = scaleTypeWithExplicitIndex[channel];\n        const childScaleType = child.component.scales[channel].getWithExplicit('type');\n\n        if (explicitScaleType) {\n          if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {\n            // merge scale component if type are compatible\n            scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit<VgScale, ScaleType>(\n              explicitScaleType, childScaleType, 'type', 'scale', scaleTypeTieBreaker\n            );\n          } else {\n            // Otherwise, update conflicting channel to be independent\n            resolve.scale[channel] = 'independent';\n            // Remove from the index so they don't get merged\n            delete scaleTypeWithExplicitIndex[channel];\n          }\n        } else {\n          scaleTypeWithExplicitIndex[channel] = childScaleType;\n        }\n      }\n    });\n  }\n\n  // Merge each channel listed in the index\n  keys(scaleTypeWithExplicitIndex).forEach((channel: ScaleChannel) => {\n    // Create new merged scale component\n    const name = model.scaleName(channel, true);\n    const typeWithExplicit = scaleTypeWithExplicitIndex[channel];\n    scaleComponents[channel] = new ScaleComponent(name, typeWithExplicit);\n\n    // rename each child and mark them as merged\n    for (const child of model.children) {\n      const childScale = child.component.scales[channel];\n      if (childScale) {\n        child.renameScale(childScale.get('name'), name);\n        childScale.merged = true;\n      }\n    }\n  });\n\n  return scaleComponents;\n}\n"]}