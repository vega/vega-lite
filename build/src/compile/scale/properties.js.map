{"version":3,"file":"properties.js","sourceRoot":"","sources":["../../../../src/compile/scale/properties.ts"],"names":[],"mappings":"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","sourcesContent":["import {Channel, ScaleChannel, X, Y} from '../../channel';\nimport {Config} from '../../config';\nimport {FieldDef, ScaleFieldDef} from '../../fielddef';\nimport * as log from '../../log';\nimport {BarConfig, MarkDef} from '../../mark';\nimport {channelScalePropertyIncompatability, Domain, hasContinuousDomain, isContinuousToContinuous, NiceTime, Scale, ScaleConfig, ScaleType, scaleTypeSupportProperty} from '../../scale';\nimport {Sort} from '../../sort';\nimport * as util from '../../util';\nimport {contains, keys} from '../../util';\nimport {VgScale} from '../../vega.schema';\nimport {isUnitModel, Model} from '../model';\nimport {Explicit, mergeValuesWithExplicit, tieBreakByComparing} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponentIndex, ScaleComponentProps} from './component';\nimport {parseScaleRange} from './range';\n\nexport function parseScaleProperty(model: Model, property: keyof (Scale | ScaleComponentProps)) {\n  if (isUnitModel(model)) {\n    parseUnitScaleProperty(model, property);\n  } else {\n    parseNonUnitScaleProperty(model, property);\n  }\n}\n\nfunction parseUnitScaleProperty(model: UnitModel, property: keyof (Scale | ScaleComponentProps)) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  keys(localScaleComponents).forEach((channel: ScaleChannel) => {\n    const specifiedScale = model.specifiedScales[channel];\n    const localScaleCmpt = localScaleComponents[channel];\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n    const fieldDef = model.fieldDef(channel);\n    const config = model.config;\n\n    const specifiedValue = specifiedScale[property];\n    const sType = mergedScaleCmpt.get('type');\n\n    const supportedByScaleType = scaleTypeSupportProperty(sType, property);\n    const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n\n    if (specifiedValue !== undefined) {\n      // If there is a specified value, check if it is compatible with scale type and channel\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(sType, property, channel));\n      } else if (channelIncompatability) { // channel\n        log.warn(channelIncompatability);\n      }\n    }\n    if (supportedByScaleType && channelIncompatability === undefined) {\n      if (specifiedValue !== undefined) {\n        // copyKeyFromObject ensure type safety\n        localScaleCmpt.copyKeyFromObject(property, specifiedScale);\n      } else {\n        const value = getDefaultValue(\n          property, channel, fieldDef,\n          mergedScaleCmpt.get('type'),\n          mergedScaleCmpt.get('padding'),\n          mergedScaleCmpt.get('paddingInner'),\n          specifiedScale.domain,\n          model.markDef, config\n        );\n        if (value !== undefined) {\n          localScaleCmpt.set(property, value, false);\n        }\n      }\n    }\n  });\n}\n\n// Note: This method is used in Voyager.\nexport function getDefaultValue(\n  property: keyof Scale, channel: Channel, fieldDef: ScaleFieldDef<string>,\n  scaleType: ScaleType, scalePadding: number, scalePaddingInner: number,\n  specifiedDomain: Scale['domain'], markDef: MarkDef, config: Config) {\n  const scaleConfig = config.scale;\n\n  // If we have default rule-base, determine default value first\n  switch (property) {\n    case 'nice':\n      return nice(scaleType, channel, fieldDef);\n    case 'padding':\n      return padding(channel, scaleType, scaleConfig, fieldDef, markDef, config.bar);\n    case 'paddingInner':\n      return paddingInner(scalePadding, channel, scaleConfig);\n    case 'paddingOuter':\n      return paddingOuter(scalePadding, channel, scaleType, scalePaddingInner, scaleConfig);\n    case 'reverse':\n      return reverse(scaleType, fieldDef.sort);\n    case 'zero':\n      return zero(channel, fieldDef, specifiedDomain, markDef);\n  }\n  // Otherwise, use scale config\n  return scaleConfig[property];\n}\n\nexport function parseNonUnitScaleProperty(model: Model, property: keyof (Scale | ScaleComponentProps)) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  for (const child of model.children) {\n    if (property === 'range') {\n      parseScaleRange(child);\n    } else {\n      parseScaleProperty(child, property);\n    }\n  }\n\n  keys(localScaleComponents).forEach((channel: ScaleChannel) => {\n    let valueWithExplicit: Explicit<any>;\n\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n      if (childComponent) {\n        const childValueWithExplicit = childComponent.getWithExplicit(property);\n        valueWithExplicit = mergeValuesWithExplicit<VgScale, any>(\n          valueWithExplicit, childValueWithExplicit,\n          property,\n          'scale',\n          tieBreakByComparing<VgScale, any>((v1, v2) => {\n            switch (property) {\n              case 'range':\n                // For range step, prefer larger step\n                if (v1.step && v2.step) {\n                  return v1.step - v2.step;\n                }\n                return 0;\n              // TODO: precedence rule for other properties\n            }\n            return 0;\n          })\n        );\n      }\n    }\n    localScaleComponents[channel].setWithExplicit(property, valueWithExplicit);\n  });\n}\n\nexport function nice(scaleType: ScaleType, channel: Channel, fieldDef: FieldDef<string>): boolean | NiceTime {\n  if (fieldDef.bin || util.contains([ScaleType.TIME, ScaleType.UTC], scaleType)) {\n    return undefined;\n  }\n  return util.contains([X, Y], channel); // return true for quantitative X/Y unless binned\n}\n\nexport function padding(channel: Channel, scaleType: ScaleType, scaleConfig: ScaleConfig, fieldDef: FieldDef<string>, markDef: MarkDef, barConfig: BarConfig) {\n  if (util.contains([X, Y], channel)) {\n    if (isContinuousToContinuous(scaleType)) {\n      if (scaleConfig.continuousPadding !== undefined) {\n        return scaleConfig.continuousPadding;\n      }\n\n      const {type, orient} = markDef;\n      if (type === 'bar' && !fieldDef.bin) {\n        if (\n          (orient === 'vertical' && channel === 'x') ||\n          (orient === 'horizontal' && channel === 'y')\n        ) {\n          return barConfig.continuousBandSize;\n        }\n      }\n    }\n\n    if (scaleType === ScaleType.POINT) {\n      return scaleConfig.pointPadding;\n    }\n  }\n  return undefined;\n}\n\nexport function paddingInner(paddingValue: number, channel: Channel, scaleConfig: ScaleConfig) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingInner.\n    return undefined;\n  }\n\n  if (util.contains([X, Y], channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n\n    // paddingOuter would only be called if it's a band scale, just return the default for bandScale.\n    return scaleConfig.bandPaddingInner;\n  }\n  return undefined;\n}\n\nexport function paddingOuter(paddingValue: number, channel: Channel, scaleType: ScaleType, paddingInnerValue: number, scaleConfig: ScaleConfig) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingOuter.\n    return undefined;\n  }\n\n  if (util.contains([X, Y], channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    if (scaleType === ScaleType.BAND) {\n      if (scaleConfig.bandPaddingOuter !== undefined) {\n        return scaleConfig.bandPaddingOuter;\n      }\n      /* By default, paddingOuter is paddingInner / 2. The reason is that\n          size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).\n          and we want the width/height to be integer by default.\n          Note that step (by default) and cardinality are integers.) */\n      return paddingInnerValue / 2;\n    }\n  }\n  return undefined;\n}\n\nexport function reverse(scaleType: ScaleType, sort: Sort<string>) {\n  if (hasContinuousDomain(scaleType) && sort === 'descending') {\n    // For continuous domain scales, Vega does not support domain sort.\n    // Thus, we reverse range instead if sort is descending\n    return true;\n  }\n  return undefined;\n}\n\nexport function zero(channel: Channel, fieldDef: FieldDef<string>, specifiedScale: Domain, markDef: MarkDef) {\n\n  // If users explicitly provide a domain range, we should not augment zero as that will be unexpected.\n  const hasCustomDomain = !!specifiedScale && specifiedScale !== 'unaggregated';\n  if (hasCustomDomain) {\n    return false;\n  }\n\n  // If there is no custom domain, return true only for the following cases:\n\n  // 1) using quantitative field with size\n  // While this can be either ratio or interval fields, our assumption is that\n  // ratio are more common.\n  if (channel === 'size' && fieldDef.type === 'quantitative') {\n    return true;\n  }\n\n  // 2) non-binned, quantitative x-scale or y-scale\n  // (For binning, we should not include zero by default because binning are calculated without zero.)\n  if (!fieldDef.bin && util.contains([X, Y], channel)) {\n    const {orient, type} = markDef;\n    if (contains(['bar', 'area', 'line', 'trail'], type)) {\n      if (\n        (orient === 'horizontal' && channel === 'y') ||\n        (orient === 'vertical' && channel === 'x')\n      ) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  return false;\n}\n"]}