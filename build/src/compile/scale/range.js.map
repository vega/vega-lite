{"version":3,"file":"range.js","sourceRoot":"","sources":["../../../../src/compile/scale/range.ts"],"names":[],"mappings":"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","sourcesContent":["import {isNumber} from 'vega-util';\n\nimport {Channel, COLOR, FILL, OPACITY, SCALE_CHANNELS, ScaleChannel, SHAPE, SIZE, STROKE, X, Y} from '../../channel';\nimport {Config} from '../../config';\nimport * as log from '../../log';\nimport {Mark} from '../../mark';\nimport {\n  channelScalePropertyIncompatability,\n  isExtendedScheme,\n  Range,\n  Scale,\n  ScaleConfig,\n  ScaleType,\n  scaleTypeSupportProperty,\n  Scheme,\n} from '../../scale';\nimport {hasContinuousDomain} from '../../scale';\nimport {Type} from '../../type';\nimport * as util from '../../util';\nimport {isVgRangeStep, VgRange, VgScheme} from '../../vega.schema';\nimport {isUnitModel, Model} from '../model';\nimport {Explicit, makeExplicit, makeImplicit} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponentIndex} from './component';\nimport {parseNonUnitScaleProperty} from './properties';\n\n\nexport type RangeMixins = {range: Range} | {rangeStep: number} | {scheme: Scheme};\n\nexport const RANGE_PROPERTIES: (keyof Scale)[] = ['range', 'rangeStep', 'scheme'];\n\n\nexport function parseScaleRange(model: Model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleRange(model);\n  } else {\n    parseNonUnitScaleProperty(model, 'range');\n  }\n}\n\nfunction parseUnitScaleRange(model: UnitModel) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  // use SCALE_CHANNELS instead of scales[channel] to ensure that x, y come first!\n  SCALE_CHANNELS.forEach((channel: ScaleChannel) => {\n    const localScaleCmpt = localScaleComponents[channel];\n    if (!localScaleCmpt) {\n      return;\n    }\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n\n\n    const specifiedScale = model.specifiedScales[channel];\n    const fieldDef = model.fieldDef(channel);\n\n    // Read if there is a specified width/height\n    const sizeType = channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n    let sizeSpecified = sizeType ? !!model.component.layoutSize.get(sizeType) : undefined;\n\n    const scaleType = mergedScaleCmpt.get('type');\n\n    // if autosize is fit, size cannot be data driven\n    const rangeStep = util.contains(['point', 'band'], scaleType) || !!specifiedScale.rangeStep;\n    if (sizeType && model.fit && !sizeSpecified && rangeStep) {\n      log.warn(log.message.CANNOT_FIX_RANGE_STEP_WITH_FIT);\n      sizeSpecified = true;\n    }\n\n    const xyRangeSteps = getXYRangeStep(model);\n\n    const rangeWithExplicit = parseRangeForChannel(\n      channel, scaleType, fieldDef.type, specifiedScale, model.config,\n      localScaleCmpt.get('zero'), model.mark, sizeSpecified, model.getName(sizeType), xyRangeSteps\n    );\n\n    localScaleCmpt.setWithExplicit('range', rangeWithExplicit);\n  });\n}\n\nfunction getXYRangeStep(model: UnitModel) {\n  const xyRangeSteps: number[] = [];\n\n  const xScale = model.getScaleComponent('x');\n  const xRange = xScale && xScale.get('range');\n  if (xRange && isVgRangeStep(xRange) && isNumber(xRange.step)) {\n    xyRangeSteps.push(xRange.step);\n  }\n\n  const yScale = model.getScaleComponent('y');\n  const yRange = yScale && yScale.get('range');\n  if (yRange && isVgRangeStep(yRange) && isNumber(yRange.step)) {\n    xyRangeSteps.push(yRange.step);\n  }\n\n  return xyRangeSteps;\n}\n\n/**\n * Return mixins that includes one of the range properties (range, rangeStep, scheme).\n */\nexport function parseRangeForChannel(\n    channel: Channel, scaleType: ScaleType, type: Type, specifiedScale: Scale, config: Config,\n    zero: boolean, mark: Mark, sizeSpecified: boolean, sizeSignal: string, xyRangeSteps: number[]\n  ): Explicit<VgRange> {\n\n  const noRangeStep = sizeSpecified || specifiedScale.rangeStep === null;\n\n  // Check if any of the range properties is specified.\n  // If so, check if it is compatible and make sure that we only output one of the properties\n  for (const property of RANGE_PROPERTIES) {\n    if (specifiedScale[property] !== undefined) {\n      const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n      const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) { // channel\n        log.warn(channelIncompatability);\n      } else {\n        switch (property) {\n          case 'range':\n            return makeExplicit(specifiedScale[property]);\n          case 'scheme':\n            return makeExplicit(parseScheme(specifiedScale[property]));\n          case 'rangeStep':\n            const rangeStep = specifiedScale[property];\n            if (rangeStep !== null) {\n              if (!sizeSpecified) {\n                return makeExplicit({step: rangeStep});\n              } else {\n                // If top-level size is specified, we ignore specified rangeStep.\n                log.warn(log.message.rangeStepDropped(channel));\n              }\n            }\n        }\n      }\n    }\n  }\n  return makeImplicit(\n    defaultRange(\n      channel, scaleType, type, config,\n      zero, mark, sizeSignal, xyRangeSteps, noRangeStep\n    )\n  );\n}\n\nfunction parseScheme(scheme: Scheme) {\n  if (isExtendedScheme(scheme)) {\n    const r: VgScheme = {scheme: scheme.name};\n    if (scheme.count) {\n      r.count = scheme.count;\n    }\n    if (scheme.extent) {\n      r.extent = scheme.extent;\n    }\n    return r;\n  }\n  return {scheme: scheme};\n}\n\nexport function defaultRange(\n  channel: Channel, scaleType: ScaleType, type: Type, config: Config, zero: boolean, mark: Mark,\n  sizeSignal: string, xyRangeSteps: number[], noRangeStep: boolean\n): VgRange {\n  switch (channel) {\n    case X:\n    case Y:\n      if (util.contains(['point', 'band'], scaleType) && !noRangeStep) {\n        if (channel === X && mark === 'text') {\n          if (config.scale.textXRangeStep) {\n            return {step: config.scale.textXRangeStep};\n          }\n        } else {\n          if (config.scale.rangeStep) {\n            return {step: config.scale.rangeStep};\n          }\n        }\n      }\n\n      // If range step is null, use zero to width or height.\n      // Note that these range signals are temporary\n      // as they can be merged and renamed.\n      // (We do not have the right size signal here since parseLayoutSize() happens after parseScale().)\n      // We will later replace these temporary names with\n      // the final name in assembleScaleRange()\n\n      if (channel === Y && hasContinuousDomain(scaleType)) {\n        // For y continuous scale, we have to start from the height as the bottom part has the max value.\n        return [{signal: sizeSignal}, 0];\n      } else {\n        return [0, {signal: sizeSignal}];\n      }\n    case SIZE:\n      // TODO: support custom rangeMin, rangeMax\n      const rangeMin = sizeRangeMin(mark, zero, config);\n      const rangeMax = sizeRangeMax(mark, xyRangeSteps, config);\n      return [rangeMin, rangeMax];\n    case SHAPE:\n      return 'symbol';\n    case COLOR:\n    case FILL:\n    case STROKE:\n      if (scaleType === 'ordinal') {\n        // Only nominal data uses ordinal scale by default\n        return type === 'nominal' ? 'category' : 'ordinal';\n      }\n      return mark === 'rect' || mark === 'geoshape' ? 'heatmap' : 'ramp';\n    case OPACITY:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minOpacity, config.scale.maxOpacity];\n  }\n  /* istanbul ignore next: should never reach here */\n  throw new Error(`Scale range undefined for channel ${channel}`);\n}\n\nfunction sizeRangeMin(mark: Mark, zero: boolean, config: Config) {\n  if (zero) {\n    return 0;\n  }\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      return config.scale.minBandSize;\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.minStrokeWidth;\n    case 'text':\n      return config.scale.minFontSize;\n    case 'point':\n    case 'square':\n    case 'circle':\n      return config.scale.minSize;\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMin not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\nfunction sizeRangeMax(mark: Mark, xyRangeSteps: number[], config: Config) {\n  const scaleConfig = config.scale;\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      if (config.scale.maxBandSize !== undefined) {\n        return config.scale.maxBandSize;\n      }\n      return minXYRangeStep(xyRangeSteps, config.scale) - 1;\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.maxStrokeWidth;\n    case 'text':\n      return config.scale.maxFontSize;\n    case 'point':\n    case 'square':\n    case 'circle':\n      if (config.scale.maxSize) {\n        return config.scale.maxSize;\n      }\n\n      // FIXME this case totally should be refactored\n      const pointStep = minXYRangeStep(xyRangeSteps, scaleConfig);\n      return (pointStep - 2) * (pointStep - 2);\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMax not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\n/**\n * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.\n */\nfunction minXYRangeStep(xyRangeSteps: number[], scaleConfig: ScaleConfig): number {\n  if (xyRangeSteps.length > 0) {\n    return Math.min.apply(null, xyRangeSteps);\n  }\n  if (scaleConfig.rangeStep) {\n    return scaleConfig.rangeStep;\n  }\n  return 21; // FIXME: re-evaluate the default value here.\n}\n"]}