{"version":3,"file":"interval.js","sourceRoot":"","sources":["../../../../src/compile/selection/interval.ts"],"names":[],"mappings":"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","sourcesContent":["import {stringValue} from 'vega-util';\nimport {X, Y} from '../../channel';\nimport {warn} from '../../log';\nimport {hasContinuousDomain, isBinScale} from '../../scale';\nimport {keys} from '../../util';\nimport {VgEventStream} from '../../vega.schema';\nimport {UnitModel} from '../unit';\nimport {\n  channelSignalName,\n  positionalProjections,\n  SelectionCompiler,\n  SelectionComponent,\n  STORE,\n  TUPLE,\n  unitName\n} from './selection';\nimport scales from './transforms/scales';\n\nexport const BRUSH = '_brush';\nexport const SCALE_TRIGGER = '_scale_trigger';\n\nconst interval: SelectionCompiler = {\n  predicate: 'vlInterval',\n  scaleDomain: 'vlIntervalDomain',\n\n  signals: (model, selCmpt) => {\n    const name = selCmpt.name;\n    const hasScales = scales.has(selCmpt);\n    const signals: any[] = [];\n    const intervals: any[] = [];\n    const tupleTriggers: string[] = [];\n    const scaleTriggers: any[] = [];\n\n    if (selCmpt.translate && !hasScales) {\n      const filterExpr = `!event.item || event.item.mark.name !== ${stringValue(name + BRUSH)}`;\n      events(selCmpt, (_: any[], evt: VgEventStream) => {\n        const filters = evt.between[0].filter || (evt.between[0].filter = []);\n        if (filters.indexOf(filterExpr) < 0) {\n          filters.push(filterExpr);\n        }\n      });\n    }\n\n    for (const p of selCmpt.project) {\n      const channel = p.channel;\n      if (channel !== X && channel !== Y) {\n        warn('Interval selections only support x and y encoding channels.');\n        continue;\n      }\n\n      const cs = channelSignals(model, selCmpt, channel);\n      const dname = channelSignalName(selCmpt, channel, 'data');\n      const vname = channelSignalName(selCmpt, channel, 'visual');\n      const scaleStr = stringValue(model.scaleName(channel));\n      const scaleType = model.getScaleComponent(channel).get('type');\n      const toNum = hasContinuousDomain(scaleType) ? '+' : '';\n\n      signals.push.apply(signals, cs);\n      tupleTriggers.push(dname);\n      intervals.push(`{encoding: ${stringValue(channel)}, ` + `field: ${stringValue(p.field)}, extent: ${dname}}`);\n\n      scaleTriggers.push({\n        scaleName: model.scaleName(channel),\n        expr:\n          `(!isArray(${dname}) || ` +\n          `(${toNum}invert(${scaleStr}, ${vname})[0] === ${toNum}${dname}[0] && ` +\n          `${toNum}invert(${scaleStr}, ${vname})[1] === ${toNum}${dname}[1]))`\n      });\n    }\n\n    // Proxy scale reactions to ensure that an infinite loop doesn't occur\n    // when an interval selection filter touches the scale.\n    if (!hasScales) {\n      signals.push({\n        name: name + SCALE_TRIGGER,\n        update: scaleTriggers.map(t => t.expr).join(' && ') + ` ? ${name + SCALE_TRIGGER} : {}`\n      });\n    }\n\n    // Only add an interval to the store if it has valid data extents. Data extents\n    // are set to null if pixel extents are equal to account for intervals over\n    // ordinal/nominal domains which, when inverted, will still produce a valid datum.\n    return signals.concat({\n      name: name + TUPLE,\n      on: [\n        {\n          events: tupleTriggers.map(t => ({signal: t})),\n          update:\n            tupleTriggers.join(' && ') + ` ? {unit: ${unitName(model)}, intervals: [${intervals.join(', ')}]} : null`\n        }\n      ]\n    });\n  },\n\n  modifyExpr: (model, selCmpt) => {\n    const tpl = selCmpt.name + TUPLE;\n    return tpl + ', ' + (selCmpt.resolve === 'global' ? 'true' : `{unit: ${unitName(model)}}`);\n  },\n\n  marks: (model, selCmpt, marks) => {\n    const name = selCmpt.name;\n    const {xi, yi} = positionalProjections(selCmpt);\n    const store = `data(${stringValue(selCmpt.name + STORE)})`;\n\n    // Do not add a brush if we're binding to scales.\n    if (scales.has(selCmpt)) {\n      return marks;\n    }\n\n    const update: any = {\n      x: xi !== null ? {signal: `${name}_x[0]`} : {value: 0},\n      y: yi !== null ? {signal: `${name}_y[0]`} : {value: 0},\n      x2: xi !== null ? {signal: `${name}_x[1]`} : {field: {group: 'width'}},\n      y2: yi !== null ? {signal: `${name}_y[1]`} : {field: {group: 'height'}}\n    };\n\n    // If the selection is resolved to global, only a single interval is in\n    // the store. Wrap brush mark's encodings with a production rule to test\n    // this based on the `unit` property. Hide the brush mark if it corresponds\n    // to a unit different from the one in the store.\n    if (selCmpt.resolve === 'global') {\n      for (const key of keys(update)) {\n        update[key] = [\n          {\n            test: `${store}.length && ${store}[0].unit === ${unitName(model)}`,\n            ...update[key]\n          },\n          {value: 0}\n        ];\n      }\n    }\n\n    // Two brush marks ensure that fill colors and other aesthetic choices do\n    // not interefere with the core marks, but that the brushed region can still\n    // be interacted with (e.g., dragging it around).\n    const {fill, fillOpacity, ...stroke} = selCmpt.mark;\n    const vgStroke = keys(stroke).reduce((def, k) => {\n      def[k] = [\n        {\n          test: [xi !== null && `${name}_x[0] !== ${name}_x[1]`, yi != null && `${name}_y[0] !== ${name}_y[1]`]\n            .filter(x => x)\n            .join(' && '),\n          value: stroke[k]\n        },\n        {value: null}\n      ];\n      return def;\n    }, {});\n\n    return [\n      {\n        name: name + BRUSH + '_bg',\n        type: 'rect',\n        clip: true,\n        encode: {\n          enter: {\n            fill: {value: fill},\n            fillOpacity: {value: fillOpacity}\n          },\n          update: update\n        }\n      } as any\n    ].concat(marks, {\n      name: name + BRUSH,\n      type: 'rect',\n      clip: true,\n      encode: {\n        enter: {\n          fill: {value: 'transparent'}\n        },\n        update: {...update, ...vgStroke}\n      }\n    });\n  }\n};\nexport default interval;\n\n/**\n * Returns the visual and data signals for an interval selection.\n */\nfunction channelSignals(model: UnitModel, selCmpt: SelectionComponent, channel: 'x' | 'y'): any {\n  const vname = channelSignalName(selCmpt, channel, 'visual');\n  const dname = channelSignalName(selCmpt, channel, 'data');\n  const hasScales = scales.has(selCmpt);\n  const scaleName = model.scaleName(channel);\n  const scaleStr = stringValue(scaleName);\n  const scale = model.getScaleComponent(channel);\n  const scaleType = scale ? scale.get('type') : undefined;\n  const size = model.getSizeSignalRef(channel === X ? 'width' : 'height').signal;\n  const coord = `${channel}(unit)`;\n\n  const on = events(selCmpt, (def: any[], evt: VgEventStream) => {\n    return def.concat(\n      {events: evt.between[0], update: `[${coord}, ${coord}]`}, // Brush Start\n      {events: evt, update: `[${vname}[0], clamp(${coord}, 0, ${size})]`} // Brush End\n    );\n  });\n\n  // React to pan/zooms of continuous scales. Non-continuous scales\n  // (bin-linear, band, point) cannot be pan/zoomed and any other changes\n  // to their domains (e.g., filtering) should clear the brushes.\n  on.push({\n    events: {signal: selCmpt.name + SCALE_TRIGGER},\n    update:\n      hasContinuousDomain(scaleType) && !isBinScale(scaleType)\n        ? `[scale(${scaleStr}, ${dname}[0]), scale(${scaleStr}, ${dname}[1])]`\n        : `[0, 0]`\n  });\n\n  return hasScales\n    ? [{name: dname, on: []}]\n    : [\n        {\n          name: vname,\n          value: [],\n          on: on\n        },\n        {\n          name: dname,\n          on: [{events: {signal: vname}, update: `${vname}[0] === ${vname}[1] ? null : invert(${scaleStr}, ${vname})`}]\n        }\n      ];\n}\n\nfunction events(selCmpt: SelectionComponent, cb: (...args: any[]) => void) {\n  return selCmpt.events.reduce((on: any[], evt: VgEventStream) => {\n    if (!evt.between) {\n      warn(`${evt} is not an ordered event stream for interval selections`);\n      return on;\n    }\n    return cb(on, evt);\n  }, []);\n}\n"]}