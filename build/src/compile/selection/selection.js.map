{"version":3,"file":"selection.js","sourceRoot":"","sources":["../../../../src/compile/selection/selection.ts"],"names":[],"mappings":"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","sourcesContent":["import {selector as parseSelector} from 'vega-event-selector';\nimport {isString, stringValue} from 'vega-util';\nimport {Channel, ScaleChannel, X, Y} from '../../channel';\nimport {warn} from '../../log';\nimport {LogicalOperand} from '../../logical';\nimport {BrushConfig, SELECTION_ID, SelectionDef, SelectionResolution, SelectionType} from '../../selection';\nimport {accessPathWithDatum, Dict, logicalExpr, varName} from '../../util';\nimport {VgBinding, VgData, VgEventStream, VgSignalRef} from '../../vega.schema';\nimport {DataFlowNode} from '../data/dataflow';\nimport {TimeUnitNode} from '../data/timeunit';\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {isFacetModel, isUnitModel, Model} from '../model';\nimport {UnitModel} from '../unit';\nimport intervalCompiler from './interval';\nimport multiCompiler from './multi';\nimport {SelectionComponent} from './selection';\nimport singleCompiler from './single';\nimport {forEachTransform} from './transforms/transforms';\n\n\nexport const STORE = '_store';\nexport const TUPLE = '_tuple';\nexport const MODIFY = '_modify';\nexport const SELECTION_DOMAIN = '_selection_domain_';\n\nexport interface SelectionComponent {\n  name: string;\n  type: SelectionType;\n  events: VgEventStream;\n  // predicate?: string;\n  bind?: 'scales' | VgBinding | {[key: string]: VgBinding};\n  resolve: SelectionResolution;\n  empty: 'all' | 'none';\n  mark?: BrushConfig;\n\n  _signalNames: {};\n\n  // Transforms\n  project?: ProjectComponent[];\n  fields?: any;\n  timeUnit?: TimeUnitNode;\n  scales?: Channel[];\n  toggle?: any;\n  translate?: any;\n  zoom?: any;\n  nearest?: any;\n}\n\nexport interface ProjectComponent {\n  field?: string;\n  channel?: ScaleChannel;\n}\n\nexport interface SelectionCompiler {\n  signals: (model: UnitModel, selCmpt: SelectionComponent) => any[];\n  topLevelSignals?: (model: Model, selCmpt: SelectionComponent, signals: any[]) => any[];\n  modifyExpr: (model: UnitModel, selCmpt: SelectionComponent) => string;\n  marks?: (model: UnitModel, selCmpt:SelectionComponent, marks: any[]) => any[];\n  predicate: string;  // Vega expr string to determine inclusion in selection.\n  scaleDomain: string;  // Vega expr string to materialize a scale domain.\n}\n\nexport function parseUnitSelection(model: UnitModel, selDefs: Dict<SelectionDef>) {\n  const selCmpts: Dict<SelectionComponent> = {};\n  const selectionConfig = model.config.selection;\n\n  for (let name in selDefs) {\n    if (!selDefs.hasOwnProperty(name)) {\n      continue;\n    }\n\n    const selDef = selDefs[name];\n    const cfg = selectionConfig[selDef.type];\n\n    // Set default values from config if a property hasn't been specified,\n    // or if it is true. E.g., \"translate\": true should use the default\n    // event handlers for translate. However, true may be a valid value for\n    // a property (e.g., \"nearest\": true).\n    for (const key in cfg) {\n      // A selection should contain either `encodings` or `fields`, only use\n      // default values for these two values if neither of them is specified.\n      if ((key === 'encodings' && selDef.fields) || (key === 'fields' && selDef.encodings)) {\n        continue;\n      }\n\n      if (key === 'mark') {\n        selDef[key] = {...cfg[key], ...selDef[key]};\n      }\n\n      if (selDef[key] === undefined || selDef[key] === true) {\n        selDef[key] = cfg[key] || selDef[key];\n      }\n    }\n\n    name = varName(name);\n    const selCmpt = selCmpts[name] = {\n      ...selDef,\n      name: name,\n      events: isString(selDef.on) ? parseSelector(selDef.on, 'scope') : selDef.on,\n    } as SelectionComponent;\n\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.parse) {\n        txCompiler.parse(model, selDef, selCmpt);\n      }\n    });\n  }\n\n  return selCmpts;\n}\n\nexport function assembleUnitSelectionSignals(model: UnitModel, signals: any[]) {\n  forEachSelection(model, (selCmpt, selCompiler) => {\n    const name = selCmpt.name;\n    let modifyExpr = selCompiler.modifyExpr(model, selCmpt);\n\n    signals.push.apply(signals, selCompiler.signals(model, selCmpt));\n\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.signals) {\n        signals = txCompiler.signals(model, selCmpt, signals);\n      }\n      if (txCompiler.modifyExpr) {\n        modifyExpr = txCompiler.modifyExpr(model, selCmpt, modifyExpr);\n      }\n    });\n\n    signals.push({\n      name: name + MODIFY,\n      on: [{\n        events: {signal: name + TUPLE},\n        update: `modify(${stringValue(selCmpt.name + STORE)}, ${modifyExpr})`\n      }]\n    });\n  });\n\n  const facetModel = getFacetModel(model);\n  if (signals.length && facetModel) {\n    const name = stringValue(facetModel.getName('cell'));\n    signals.unshift({\n      name: 'facet',\n      value: {},\n      on: [{\n        events: parseSelector('mousemove', 'scope'),\n        update: `isTuple(facet) ? facet : group(${name}).datum`\n      }]\n    });\n  }\n\n  return signals;\n}\n\nexport function assembleTopLevelSignals(model: UnitModel, signals: any[]) {\n  let needsUnit = false;\n  forEachSelection(model, (selCmpt, selCompiler) => {\n    if (selCompiler.topLevelSignals) {\n      signals = selCompiler.topLevelSignals(model, selCmpt, signals);\n    }\n\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.topLevelSignals) {\n        signals = txCompiler.topLevelSignals(model, selCmpt, signals);\n      }\n    });\n\n    needsUnit = true;\n  });\n\n  if (needsUnit) {\n    const hasUnit = signals.filter((s) => s.name === 'unit');\n    if (!(hasUnit.length)) {\n      signals.unshift({\n        name: 'unit',\n        value: {},\n        on: [{events: 'mousemove', update: 'isTuple(group()) ? group() : unit'}]\n      });\n    }\n  }\n\n  return signals;\n}\n\nexport function assembleUnitSelectionData(model: UnitModel, data: VgData[]): VgData[] {\n  forEachSelection(model, selCmpt => {\n    const contains = data.filter((d) => d.name === selCmpt.name + STORE);\n    if (!contains.length) {\n      data.push({name: selCmpt.name + STORE});\n    }\n  });\n\n  return data;\n}\n\nexport function assembleUnitSelectionMarks(model: UnitModel, marks: any[]): any[] {\n  forEachSelection(model, (selCmpt, selCompiler) => {\n    marks = selCompiler.marks ? selCompiler.marks(model, selCmpt, marks) : marks;\n    forEachTransform(selCmpt, (txCompiler) => {\n      if (txCompiler.marks) {\n        marks = txCompiler.marks(model, selCmpt, marks);\n      }\n    });\n  });\n\n  return marks;\n}\n\nexport function assembleLayerSelectionMarks(model: LayerModel, marks: any[]): any[] {\n  model.children.forEach(child => {\n    if (isUnitModel(child)) {\n      marks = assembleUnitSelectionMarks(child, marks);\n    }\n  });\n\n  return marks;\n}\n\nexport function selectionPredicate(model: Model, selections: LogicalOperand<string>, dfnode?: DataFlowNode): string {\n  const stores: string[] = [];\n  function expr(name: string): string {\n    const vname = varName(name);\n    const selCmpt = model.getSelectionComponent(vname, name);\n    const store = stringValue(vname + STORE);\n\n    if (selCmpt.timeUnit) {\n      const child = dfnode || model.component.data.raw;\n      const tunode = selCmpt.timeUnit.clone();\n      if (child.parent) {\n        tunode.insertAsParentOf(child);\n      } else {\n        child.parent = tunode;\n      }\n    }\n\n    if (selCmpt.empty !== 'none') {\n      stores.push(store);\n    }\n\n    return compiler(selCmpt.type).predicate + `(${store}, datum` +\n      (selCmpt.resolve === 'global' ? ')' : `, ${stringValue(selCmpt.resolve)})`);\n  }\n\n  const predicateStr = logicalExpr(selections, expr);\n  return (stores.length\n    ? '!(' + stores.map((s) => `length(data(${s}))`).join(' || ') + ') || '\n    : ''\n  ) + `(${predicateStr})`;\n}\n\n// Selections are parsed _after_ scales. If a scale domain is set to\n// use a selection, the SELECTION_DOMAIN constant is used as the\n// domainRaw.signal during scale.parse and then replaced with the necessary\n// selection expression function during scale.assemble. To not pollute the\n// type signatures to account for this setup, the selection domain definition\n// is coerced to a string and appended to SELECTION_DOMAIN.\nexport function isRawSelectionDomain(domainRaw: VgSignalRef) {\n  return domainRaw.signal.indexOf(SELECTION_DOMAIN) >= 0;\n}\nexport function selectionScaleDomain(model: Model, domainRaw: VgSignalRef): VgSignalRef {\n  const selDomain = JSON.parse(domainRaw.signal.replace(SELECTION_DOMAIN, ''));\n  const name = varName(selDomain.selection);\n\n  let selCmpt = model.component.selection && model.component.selection[name];\n  if (selCmpt) {\n    warn('Use \"bind\": \"scales\" to setup a binding for scales and selections within the same view.');\n  } else {\n    selCmpt = model.getSelectionComponent(name, selDomain.selection);\n    if (!selDomain.encoding && !selDomain.field) {\n      selDomain.field = selCmpt.project[0].field;\n      if (selCmpt.project.length > 1) {\n        warn('A \"field\" or \"encoding\" must be specified when using a selection as a scale domain. ' +\n        `Using \"field\": ${stringValue(selDomain.field)}.`);\n      }\n    }\n    return {\n      signal: compiler(selCmpt.type).scaleDomain +\n        `(${stringValue(name + STORE)}, ${stringValue(selDomain.encoding || null)}, ` +\n          stringValue(selDomain.field || null) +\n          (selCmpt.resolve === 'global' ? ')' : `, ${stringValue(selCmpt.resolve)})`)\n    };\n  }\n\n  return {signal: 'null'};\n}\n\n// Utility functions\n\nfunction forEachSelection(model: Model, cb: (selCmpt: SelectionComponent, selCompiler: SelectionCompiler) => void) {\n  const selections = model.component.selection;\n  for (const name in selections) {\n    if (selections.hasOwnProperty(name)) {\n      const sel = selections[name];\n      cb(sel, compiler(sel.type));\n    }\n  }\n}\n\nfunction compiler(type: SelectionType): SelectionCompiler {\n  switch (type) {\n    case 'single':\n      return singleCompiler;\n    case 'multi':\n      return multiCompiler;\n    case 'interval':\n      return intervalCompiler;\n  }\n  return null;\n}\n\nfunction getFacetModel(model: Model): FacetModel {\n  let parent = model.parent;\n  while (parent) {\n    if (isFacetModel(parent)) {\n      break;\n    }\n    parent = parent.parent;\n  }\n\n  return parent as FacetModel;\n}\n\nexport function unitName(model: Model) {\n  let name = stringValue(model.name);\n  const facet = getFacetModel(model);\n  if (facet) {\n    name += (facet.facet.row ? ` + '_' + (${accessPathWithDatum(facet.vgField('row'), 'facet')})` : '')\n      + (facet.facet.column ? ` + '_' + (${accessPathWithDatum(facet.vgField('column'), 'facet')})` : '');\n  }\n  return name;\n}\n\nexport function requiresSelectionId(model: Model) {\n  let identifier = false;\n  forEachSelection(model, (selCmpt) => {\n    identifier = identifier || selCmpt.project.some((proj) => proj.field === SELECTION_ID);\n  });\n  return identifier;\n}\n\nexport function channelSignalName(selCmpt: SelectionComponent, channel: Channel, range: 'visual' | 'data') {\n  const sgNames = selCmpt._signalNames || (selCmpt._signalNames = {});\n  if (sgNames[channel] && sgNames[channel][range]) {\n    return sgNames[channel][range];\n  }\n\n  sgNames[channel] = sgNames[channel] || {};\n  const basename = varName(selCmpt.name + '_' + (range === 'visual' ? channel : selCmpt.fields[channel]));\n  let name = basename;\n  let counter = 1;\n  while (sgNames[name]) {\n    name = `${basename}_${counter++}`;\n  }\n\n  return (sgNames[name] = sgNames[channel][range] = name);\n}\n\nexport function positionalProjections(selCmpt: SelectionComponent) {\n  let x:ProjectComponent = null;\n  let xi:number = null;\n  let y:ProjectComponent = null;\n  let yi: number = null;\n\n  selCmpt.project.forEach((p, i) => {\n    if (p.channel === X) {\n      x = p;\n      xi = i;\n    } else if (p.channel === Y) {\n      y = p;\n      yi = i;\n    }\n  });\n  return {x, xi, y, yi};\n}\n"]}