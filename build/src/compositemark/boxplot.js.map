{"version":3,"file":"boxplot.js","sourceRoot":"","sources":["../../../src/compositemark/boxplot.ts"],"names":[],"mappings":"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","sourcesContent":["import {isNumber} from 'vega-util';\nimport {Channel} from '../channel';\nimport {Config} from '../config';\nimport {reduce} from '../encoding';\nimport {AggregatedFieldDef, BinTransform, CalculateTransform, TimeUnitTransform} from '../transform';\nimport {Encoding, forEach} from './../encoding';\nimport {Field, FieldDef, isContinuous, isFieldDef, PositionFieldDef, vgField} from './../fielddef';\nimport * as log from './../log';\nimport {MarkConfig} from './../mark';\nimport {GenericUnitSpec, NormalizedLayerSpec} from './../spec';\nimport {Orient} from './../vega.schema';\nimport {getMarkSpecificConfigMixins} from './common';\n\n\nexport const BOXPLOT: 'box-plot' = 'box-plot';\nexport type BOXPLOT = typeof BOXPLOT;\nexport type BoxPlotStyle = 'boxWhisker' | 'box' | 'boxMid';\n\n\nexport interface BoxPlotDef {\n  /**\n   * Type of the mark.  For box plots, this should always be `\"box-plot\"`.\n   * [boxplot](https://vega.github.io/vega-lite/docs/compositemark.html#boxplot)\n   */\n  type: BOXPLOT;\n\n  /**\n   * Orientation of the box plot.  This is normally automatically determined, but can be specified when the orientation is ambiguous and cannot be automatically determined.\n   */\n  orient?: Orient;\n\n  /**\n   * Extent is used to determine where the whiskers extend to. The options are\n   * - `\"min-max\": min and max are the lower and upper whiskers respectively.\n   * -  A scalar (integer or floating point number) that will be multiplied by the IQR and the product will be added to the third quartile to get the upper whisker and subtracted from the first quartile to get the lower whisker.\n   * __Default value:__ `\"1.5\"`.\n   */\n  extent?: 'min-max' | number;\n}\n\nexport function isBoxPlotDef(mark: BOXPLOT | BoxPlotDef): mark is BoxPlotDef {\n  return !!mark['type'];\n}\n\nexport const BOXPLOT_STYLES: BoxPlotStyle[] = ['boxWhisker', 'box', 'boxMid'];\n\nexport interface BoxPlotConfig extends MarkConfig {\n  /** Size of the box and mid tick of a box plot */\n  size?: number;\n  /** The default extent, which is used to determine where the whiskers extend to. The options are\n   * - `\"min-max\": min and max are the lower and upper whiskers respectively.\n   * - `\"number\": A scalar (integer or floating point number) that will be multiplied by the IQR and the product will be added to the third quartile to get the upper whisker and subtracted from the first quartile to get the lower whisker.\n   */\n  extent?: 'min-max' | number;\n}\n\nexport interface BoxPlotConfigMixins {\n  /**\n   * Box Config\n   * @hide\n   */\n  box?: BoxPlotConfig;\n\n  /**\n   * @hide\n   */\n  boxWhisker?: MarkConfig;\n\n  /**\n   * @hide\n   */\n  boxMid?: MarkConfig;\n}\n\nexport const VL_ONLY_BOXPLOT_CONFIG_PROPERTY_INDEX: {\n  [k in keyof BoxPlotConfigMixins]?: (keyof BoxPlotConfigMixins[k])[]\n} = {\n  box: ['size', 'color', 'extent'],\n  boxWhisker: ['color'],\n  boxMid: ['color']\n};\n\nconst supportedChannels: Channel[] = ['x', 'y', 'color', 'detail', 'opacity', 'size'];\nexport function filterUnsupportedChannels(spec: GenericUnitSpec<Encoding<string>, BOXPLOT | BoxPlotDef>): GenericUnitSpec<Encoding<string>, BOXPLOT | BoxPlotDef> {\n  return {\n    ...spec,\n    encoding: reduce(spec.encoding, (newEncoding, fieldDef, channel) => {\n      if (supportedChannels.indexOf(channel) > -1) {\n        newEncoding[channel] = fieldDef;\n      } else {\n        log.warn(log.message.incompatibleChannel(channel, BOXPLOT));\n      }\n      return newEncoding;\n    }, {}),\n  };\n}\n\nexport function normalizeBoxPlot(spec: GenericUnitSpec<Encoding<string>, BOXPLOT | BoxPlotDef>, config: Config): NormalizedLayerSpec {\n  spec = filterUnsupportedChannels(spec);\n  // TODO: use selection\n  const {mark, encoding, selection, projection: _p, ...outerSpec} = spec;\n\n  let kIQRScalar: number = undefined;\n  if (isNumber(config.box.extent)) {\n    kIQRScalar = config.box.extent;\n  }\n\n  if (isBoxPlotDef(mark)) {\n    if (mark.extent) {\n      if(mark.extent === 'min-max') {\n        kIQRScalar = undefined;\n      }\n    }\n  }\n\n  const orient: Orient = boxOrient(spec);\n  const {transform, continuousAxisChannelDef, continuousAxis, encodingWithoutContinuousAxis} = boxParams(spec, orient, kIQRScalar);\n\n  const {color, size, ...encodingWithoutSizeColorAndContinuousAxis} = encodingWithoutContinuousAxis;\n\n  // Size encoding or the default config.box.size is applied to box and boxMid\n  const sizeMixins = size ? {size} : getMarkSpecificConfigMixins(config.box, 'size');\n\n  const continuousAxisScaleAndAxis = {};\n  if (continuousAxisChannelDef.scale) {\n    continuousAxisScaleAndAxis['scale'] = continuousAxisChannelDef.scale;\n  }\n  if (continuousAxisChannelDef.axis) {\n    continuousAxisScaleAndAxis['axis'] = continuousAxisChannelDef.axis;\n  }\n\n  return {\n    ...outerSpec,\n    transform,\n    layer: [\n      { // lower whisker\n        mark: {\n          type: 'rule',\n          style: 'boxWhisker'\n        },\n        encoding: {\n          [continuousAxis]: {\n            field: 'lower_whisker_' + continuousAxisChannelDef.field,\n            type: continuousAxisChannelDef.type,\n            ...continuousAxisScaleAndAxis\n          },\n          [continuousAxis + '2']: {\n            field: 'lower_box_' + continuousAxisChannelDef.field,\n            type: continuousAxisChannelDef.type\n          },\n          ...encodingWithoutSizeColorAndContinuousAxis,\n          ...getMarkSpecificConfigMixins(config.boxWhisker, 'color')\n        }\n      }, { // upper whisker\n        mark: {\n          type: 'rule',\n          style: 'boxWhisker'\n        },\n        encoding: {\n          [continuousAxis]: {\n            field: 'upper_box_' + continuousAxisChannelDef.field,\n            type: continuousAxisChannelDef.type\n          },\n          [continuousAxis + '2']: {\n            field: 'upper_whisker_' + continuousAxisChannelDef.field,\n            type: continuousAxisChannelDef.type\n          },\n          ...encodingWithoutSizeColorAndContinuousAxis,\n          ...getMarkSpecificConfigMixins(config.boxWhisker, 'color')\n        }\n      }, { // box (q1 to q3)\n        ...(selection ? {selection} : {}),\n        mark: {\n          type: 'bar',\n          style: 'box'\n        },\n        encoding: {\n          [continuousAxis]: {\n            field: 'lower_box_' + continuousAxisChannelDef.field,\n            type: continuousAxisChannelDef.type\n          },\n          [continuousAxis + '2']: {\n            field: 'upper_box_' + continuousAxisChannelDef.field,\n            type: continuousAxisChannelDef.type\n          },\n          ...encodingWithoutContinuousAxis,\n          ...(encodingWithoutContinuousAxis.color ? {} : getMarkSpecificConfigMixins(config.box, 'color')),\n          ...sizeMixins,\n        }\n      }, { // mid tick\n        mark: {\n          type: 'tick',\n          style: 'boxMid'\n        },\n        encoding: {\n          [continuousAxis]: {\n            field: 'mid_box_' + continuousAxisChannelDef.field,\n            type: continuousAxisChannelDef.type\n          },\n          ...encodingWithoutSizeColorAndContinuousAxis,\n          ...getMarkSpecificConfigMixins(config.boxMid, 'color'),\n          ...sizeMixins,\n        }\n      }\n    ]\n  };\n}\n\nfunction boxOrient(spec: GenericUnitSpec<Encoding<Field>, BOXPLOT | BoxPlotDef>): Orient {\n  const {mark: mark, encoding: encoding, projection: _p, ..._outerSpec} = spec;\n\n  if (isFieldDef(encoding.x) && isContinuous(encoding.x)) {\n    // x is continuous\n    if (isFieldDef(encoding.y) && isContinuous(encoding.y)) {\n      // both x and y are continuous\n      if (encoding.x.aggregate === undefined && encoding.y.aggregate === BOXPLOT) {\n        return 'vertical';\n      } else if (encoding.y.aggregate === undefined && encoding.x.aggregate === BOXPLOT) {\n        return 'horizontal';\n      } else if (encoding.x.aggregate === BOXPLOT && encoding.y.aggregate === BOXPLOT) {\n        throw new Error('Both x and y cannot have aggregate');\n      } else {\n        if (isBoxPlotDef(mark) && mark.orient) {\n          return mark.orient;\n        }\n\n        // default orientation = vertical\n        return 'vertical';\n      }\n    }\n\n    // x is continuous but y is not\n    return 'horizontal';\n  } else if (isFieldDef(encoding.y) && isContinuous(encoding.y)) {\n    // y is continuous but x is not\n    return 'vertical';\n  } else {\n    // Neither x nor y is continuous.\n    throw new Error('Need a valid continuous axis for boxplots');\n  }\n}\n\n\nfunction boxContinousAxis(spec: GenericUnitSpec<Encoding<string>, BOXPLOT | BoxPlotDef>, orient: Orient) {\n  const {mark: mark, encoding: encoding, projection: _p, ..._outerSpec} = spec;\n\n  let continuousAxisChannelDef: PositionFieldDef<string>;\n  let continuousAxis: 'x' | 'y';\n\n  if (orient === 'vertical') {\n    continuousAxis = 'y';\n    continuousAxisChannelDef = encoding.y as FieldDef<string>; // Safe to cast because if y is not continuous fielddef, the orient would not be vertical.\n  } else {\n    continuousAxis = 'x';\n    continuousAxisChannelDef = encoding.x as FieldDef<string>; // Safe to cast because if x is not continuous fielddef, the orient would not be horizontal.\n  }\n\n  if (continuousAxisChannelDef && continuousAxisChannelDef.aggregate) {\n    const {aggregate, ...continuousAxisWithoutAggregate} = continuousAxisChannelDef;\n    if (aggregate !== BOXPLOT) {\n      log.warn(`Continuous axis should not have customized aggregation function ${aggregate}`);\n    }\n    continuousAxisChannelDef = continuousAxisWithoutAggregate;\n  }\n\n  return {\n    continuousAxisChannelDef,\n    continuousAxis\n  };\n}\n\nfunction boxParams(spec: GenericUnitSpec<Encoding<string>, BOXPLOT | BoxPlotDef>, orient: Orient, kIQRScalar: 'min-max' | number) {\n\n  const {continuousAxisChannelDef, continuousAxis} = boxContinousAxis(spec, orient);\n  const encoding = spec.encoding;\n\n  const isMinMax = kIQRScalar === undefined;\n  const aggregate: AggregatedFieldDef[] = [\n    {\n      op: 'q1',\n      field: continuousAxisChannelDef.field,\n      as: 'lower_box_' + continuousAxisChannelDef.field\n    },\n    {\n      op: 'q3',\n      field: continuousAxisChannelDef.field,\n      as: 'upper_box_' + continuousAxisChannelDef.field\n    },\n    {\n      op: 'median',\n      field: continuousAxisChannelDef.field,\n      as: 'mid_box_' + continuousAxisChannelDef.field\n    }\n  ];\n  let postAggregateCalculates: CalculateTransform[] = [];\n\n  aggregate.push({\n    op: 'min',\n    field: continuousAxisChannelDef.field,\n    as: (isMinMax ? 'lower_whisker_' : 'min_') + continuousAxisChannelDef.field\n  });\n  aggregate.push({\n    op: 'max',\n    field: continuousAxisChannelDef.field,\n    as:  (isMinMax ? 'upper_whisker_' : 'max_') + continuousAxisChannelDef.field\n  });\n\n  if (!isMinMax) {\n    postAggregateCalculates = [\n      {\n        calculate: `datum.upper_box_${continuousAxisChannelDef.field} - datum.lower_box_${continuousAxisChannelDef.field}`,\n        as: 'iqr_' + continuousAxisChannelDef.field\n      },\n      {\n        calculate: `min(datum.upper_box_${continuousAxisChannelDef.field} + datum.iqr_${continuousAxisChannelDef.field} * ${kIQRScalar}, datum.max_${continuousAxisChannelDef.field})`,\n        as: 'upper_whisker_' + continuousAxisChannelDef.field\n      },\n      {\n        calculate: `max(datum.lower_box_${continuousAxisChannelDef.field} - datum.iqr_${continuousAxisChannelDef.field} * ${kIQRScalar}, datum.min_${continuousAxisChannelDef.field})`,\n        as: 'lower_whisker_' + continuousAxisChannelDef.field\n      }\n    ];\n  }\n\n  const groupby: string[] = [];\n  const bins: BinTransform[] = [];\n  const timeUnits: TimeUnitTransform[] = [];\n\n  const encodingWithoutContinuousAxis: Encoding<string> = {};\n  forEach(encoding, (channelDef, channel) => {\n    if (channel === continuousAxis) {\n      // Skip continuous axis as we already handle it separately\n      return;\n    }\n    if (isFieldDef(channelDef)) {\n      if (channelDef.aggregate && channelDef.aggregate !== BOXPLOT) {\n        aggregate.push({\n          op: channelDef.aggregate,\n          field: channelDef.field,\n          as: vgField(channelDef)\n        });\n      } else if (channelDef.aggregate === undefined) {\n        const transformedField = vgField(channelDef);\n\n        // Add bin or timeUnit transform if applicable\n        const bin = channelDef.bin;\n        if (bin) {\n          const {field} = channelDef;\n          bins.push({bin, field, as: transformedField});\n        } else if (channelDef.timeUnit) {\n          const {timeUnit, field} = channelDef;\n          timeUnits.push({timeUnit, field, as: transformedField});\n        }\n\n        groupby.push(transformedField);\n      }\n      // now the field should refer to post-transformed field instead\n      encodingWithoutContinuousAxis[channel] = {\n        field: vgField(channelDef),\n        type: channelDef.type\n      };\n    } else {\n      // For value def, just copy\n      encodingWithoutContinuousAxis[channel] = encoding[channel];\n    }\n  });\n\n  return {\n    transform: [].concat(\n      bins,\n      timeUnits,\n      [{aggregate, groupby}],\n      postAggregateCalculates\n    ),\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis\n  };\n}\n"]}