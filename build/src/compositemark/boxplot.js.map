{"version":3,"file":"boxplot.js","sourceRoot":"","sources":["../../../src/compositemark/boxplot.ts"],"names":[],"mappings":"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","sourcesContent":["import {isNumber, isObject} from 'vega-util';\nimport {Channel} from '../channel';\nimport {Config} from '../config';\nimport {Encoding, extractTransformsFromEncoding} from '../encoding';\nimport * as log from '../log';\nimport {isMarkDef, MarkDef} from '../mark';\nimport {GenericUnitSpec, NormalizedLayerSpec, NormalizedUnitSpec} from '../spec';\nimport {AggregatedFieldDef, CalculateTransform} from '../transform';\nimport {Flag, getFirstDefined, keys} from '../util';\nimport {Orient} from '../vega.schema';\nimport {\n  compositeMarkContinuousAxis,\n  compositeMarkOrient,\n  filterUnsupportedChannels,\n  GenericCompositeMarkDef,\n  makeCompositeAggregatePartFactory,\n  partLayerMixins,\n  PartsMixins\n} from './common';\n\nexport const BOXPLOT: 'boxplot' = 'boxplot';\nexport type BoxPlot = typeof BOXPLOT;\n\nexport type BoxPlotPart = 'box' | 'median' | 'outliers' | 'rule' | 'ticks';\n\nconst BOXPLOT_PART_INDEX: Flag<BoxPlotPart> = {\n  box: 1,\n  median: 1,\n  outliers: 1,\n  rule: 1,\n  ticks: 1\n};\n\nexport const BOXPLOT_PARTS = keys(BOXPLOT_PART_INDEX);\n\nexport type BoxPlotPartsMixins = PartsMixins<BoxPlotPart>;\n\nexport interface BoxPlotConfig extends BoxPlotPartsMixins {\n  /** Size of the box and median tick of a box plot */\n  size?: number;\n\n  /**\n   * The extent of the whiskers. Available options include:\n   * - `\"min-max\"`: min and max are the lower and upper whiskers respectively.\n   * - A number representing multiple of the interquartile range (Q3-Q1).  This number will be multiplied by the IQR. the product will be added to the third quartile to get the upper whisker and subtracted from the first quartile to get the lower whisker.\n   *\n   * __Default value:__ `1.5`.\n   */\n  extent?: 'min-max' | number;\n}\n\nexport type BoxPlotDef = GenericCompositeMarkDef<BoxPlot> &\n  BoxPlotConfig & {\n    /**\n     * Type of the mark.  For box plots, this should always be `\"box-plot\"`.\n     * [boxplot](https://vega.github.io/vega-lite/docs/compositemark.html#boxplot)\n     */\n    type: BoxPlot;\n\n    /**\n     * Orientation of the box plot.  This is normally automatically determined based on types of fields on x and y channels. However, an explicit `orient` be specified when the orientation is ambiguous.\n     *\n     * __Default value:__ `\"vertical\"`.\n     */\n    orient?: Orient;\n  };\n\nexport interface BoxPlotConfigMixins {\n  /**\n   * Box Config\n   */\n  boxplot?: BoxPlotConfig;\n}\n\nconst boxPlotSupportedChannels: Channel[] = ['x', 'y', 'color', 'detail', 'opacity', 'size'];\n\nexport function normalizeBoxPlot(\n  spec: GenericUnitSpec<Encoding<string>, BoxPlot | BoxPlotDef>,\n  config: Config\n): NormalizedLayerSpec {\n  spec = filterUnsupportedChannels(spec, boxPlotSupportedChannels, BOXPLOT);\n\n  // TODO: use selection\n  const {mark, encoding: _encoding, selection, projection: _p, ...outerSpec} = spec;\n  const markDef: BoxPlotDef = isMarkDef(mark) ? mark : {type: mark};\n\n  // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n  if (selection) {\n    log.warn(log.message.selectionNotSupported('boxplot'));\n  }\n\n  const extent = markDef.extent || config.boxplot.extent;\n  const sizeValue = getFirstDefined(markDef.size, config.boxplot.size);\n  const isMinMax = !isNumber(extent);\n\n  const {\n    transform,\n    continuousAxisChannelDef,\n    continuousAxis,\n    groupby,\n    encodingWithoutContinuousAxis,\n    tickOrient\n  } = boxParams(spec, extent, config);\n\n  const {color, size, ...encodingWithoutSizeColorAndContinuousAxis} = encodingWithoutContinuousAxis;\n\n  const makeBoxPlotPart = (sharedEncoding: Encoding<string>) => {\n    return makeCompositeAggregatePartFactory<BoxPlotPartsMixins>(\n      markDef,\n      continuousAxis,\n      continuousAxisChannelDef,\n      sharedEncoding,\n      config.boxplot\n    );\n  };\n\n  const makeBoxPlotExtent = makeBoxPlotPart(encodingWithoutSizeColorAndContinuousAxis);\n  const makeBoxPlotBox = makeBoxPlotPart(encodingWithoutContinuousAxis);\n  const makeBoxPlotMidTick = makeBoxPlotPart({...encodingWithoutSizeColorAndContinuousAxis, ...(size ? {size} : {})});\n\n  const endTick: MarkDef = {type: 'tick', color: 'black', opacity: 1, orient: tickOrient};\n\n  const bar: MarkDef = {type: 'bar', ...(sizeValue ? {size: sizeValue} : {})};\n\n  const midTick: MarkDef = {\n    type: 'tick',\n    ...(isObject(config.boxplot.median) && config.boxplot.median.color ? {color: config.boxplot.median.color} : {}),\n    ...(sizeValue ? {size: sizeValue} : {}),\n    orient: tickOrient\n  };\n\n  const boxLayer: NormalizedUnitSpec[] = [\n    ...makeBoxPlotExtent('rule', 'rule', 'lower_whisker', 'lower_box'),\n    ...makeBoxPlotExtent('rule', 'rule', 'upper_box', 'upper_whisker'),\n    ...makeBoxPlotExtent('ticks', endTick, 'lower_whisker'),\n    ...makeBoxPlotExtent('ticks', endTick, 'upper_whisker'),\n    ...makeBoxPlotBox('box', bar, 'lower_box', 'upper_box'),\n    ...makeBoxPlotMidTick('median', midTick, 'mid_box')\n  ];\n\n  let outliersLayerMixins: NormalizedUnitSpec[] = [];\n\n  if (!isMinMax) {\n    const lowerBoxExpr: string = 'datum.lower_box_' + continuousAxisChannelDef.field;\n    const upperBoxExpr: string = 'datum.upper_box_' + continuousAxisChannelDef.field;\n    const iqrExpr = `(${upperBoxExpr} - ${lowerBoxExpr})`;\n    const lowerWhiskerExpr = `${lowerBoxExpr} - ${extent} * ${iqrExpr}`;\n    const upperWhiskerExpr = `${upperBoxExpr} + ${extent} * ${iqrExpr}`;\n    const fieldExpr = `datum.${continuousAxisChannelDef.field}`;\n\n    outliersLayerMixins = partLayerMixins<BoxPlotPartsMixins>(markDef, 'outliers', config.boxplot, {\n      transform: [\n        {\n          window: boxParamsQuartiles(continuousAxisChannelDef.field),\n          frame: [null, null],\n          groupby\n        },\n        {\n          filter: `(${fieldExpr} < ${lowerWhiskerExpr}) || (${fieldExpr} > ${upperWhiskerExpr})`\n        }\n      ],\n      mark: 'point',\n      encoding: {\n        [continuousAxis]: {\n          field: continuousAxisChannelDef.field,\n          type: continuousAxisChannelDef.type\n        },\n        ...encodingWithoutSizeColorAndContinuousAxis\n      }\n    });\n  }\n\n  if (outliersLayerMixins.length > 0) {\n    // tukey box plot with outliers included\n    return {\n      ...outerSpec,\n      layer: [\n        {\n          // boxplot\n          transform,\n          layer: boxLayer\n        },\n        ...outliersLayerMixins\n      ]\n    };\n  }\n  return {\n    ...outerSpec,\n    transform: (outerSpec.transform || []).concat(transform),\n    layer: boxLayer\n  };\n}\n\nfunction boxParamsQuartiles(continousAxisField: string): AggregatedFieldDef[] {\n  return [\n    {\n      op: 'q1',\n      field: continousAxisField,\n      as: 'lower_box_' + continousAxisField\n    },\n    {\n      op: 'q3',\n      field: continousAxisField,\n      as: 'upper_box_' + continousAxisField\n    }\n  ];\n}\n\nfunction boxParams(\n  spec: GenericUnitSpec<Encoding<string>, BoxPlot | BoxPlotDef>,\n  extent: 'min-max' | number,\n  config: Config\n) {\n  const orient = compositeMarkOrient(spec, BOXPLOT);\n  const {continuousAxisChannelDef, continuousAxis} = compositeMarkContinuousAxis(spec, orient, BOXPLOT);\n  const continuousFieldName: string = continuousAxisChannelDef.field;\n\n  const isMinMax = !isNumber(extent);\n  const boxplotSpecificAggregate: AggregatedFieldDef[] = [\n    ...boxParamsQuartiles(continuousFieldName),\n    {\n      op: 'median',\n      field: continuousFieldName,\n      as: 'mid_box_' + continuousFieldName\n    },\n    {\n      op: 'min',\n      field: continuousFieldName,\n      as: (isMinMax ? 'lower_whisker_' : 'min_') + continuousFieldName\n    },\n    {\n      op: 'max',\n      field: continuousFieldName,\n      as: (isMinMax ? 'upper_whisker_' : 'max_') + continuousFieldName\n    }\n  ];\n\n  const postAggregateCalculates: CalculateTransform[] = isMinMax\n    ? []\n    : [\n        {\n          calculate: `datum.upper_box_${continuousFieldName} - datum.lower_box_${continuousFieldName}`,\n          as: 'iqr_' + continuousFieldName\n        },\n        {\n          calculate: `min(datum.upper_box_${continuousFieldName} + datum.iqr_${continuousFieldName} * ${extent}, datum.max_${continuousFieldName})`,\n          as: 'upper_whisker_' + continuousFieldName\n        },\n        {\n          calculate: `max(datum.lower_box_${continuousFieldName} - datum.iqr_${continuousFieldName} * ${extent}, datum.min_${continuousFieldName})`,\n          as: 'lower_whisker_' + continuousFieldName\n        }\n      ];\n\n  const {[continuousAxis]: oldContinuousAxisChannelDef, ...oldEncodingWithoutContinuousAxis} = spec.encoding;\n\n  const {bins, timeUnits, aggregate, groupby, encoding: encodingWithoutContinuousAxis} = extractTransformsFromEncoding(\n    oldEncodingWithoutContinuousAxis,\n    config\n  );\n\n  const tickOrient: Orient = orient === 'vertical' ? 'horizontal' : 'vertical';\n\n  return {\n    transform: [\n      ...bins,\n      ...timeUnits,\n      {\n        aggregate: [...aggregate, ...boxplotSpecificAggregate],\n        groupby\n      },\n      ...postAggregateCalculates\n    ],\n    groupby,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    tickOrient\n  };\n}\n"]}