{"version":3,"file":"encoding.js","sourceRoot":"","sources":["../../src/encoding.ts"],"names":[],"mappings":"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","sourcesContent":["\nimport {isArray} from 'vega-util';\nimport {Channel, CHANNELS, isChannel, supportMark} from './channel';\nimport {FacetMapping} from './facet';\nimport {\n  ChannelDef,\n  Field,\n  FieldDef,\n  FieldDefWithCondition,\n  getFieldDef,\n  hasConditionalFieldDef,\n  isConditionalDef,\n  isFieldDef,\n  isValueDef,\n  MarkPropFieldDef,\n  normalize,\n  normalizeFieldDef,\n  OrderFieldDef,\n  PositionFieldDef,\n  TextFieldDef,\n  ValueDef,\n  ValueDefWithCondition\n} from './fielddef';\nimport * as log from './log';\nimport {Mark} from './mark';\nimport {Type} from './type';\nimport {contains, keys, some} from './util';\n\nexport interface Encoding<F> {\n  /**\n   * X coordinates of the marks, or width of horizontal `\"bar\"` and `\"area\"`.\n   */\n  x?: PositionFieldDef<F> | ValueDef;\n\n  /**\n   * Y coordinates of the marks, or height of vertical `\"bar\"` and `\"area\"`.\n   */\n  y?: PositionFieldDef<F> | ValueDef;\n\n  /**\n   * X2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n   */\n  // TODO: Ham need to add default behavior\n  x2?: FieldDef<F> | ValueDef;\n\n  /**\n   * Y2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n   */\n  // TODO: Ham need to add default behavior\n  y2?: FieldDef<F> | ValueDef;\n\n\n  /**\n   * Longitude position of geographically projected marks.\n   */\n  longitude?: FieldDef<F>;\n\n  /**\n   * Latitude position of geographically projected marks.\n   */\n  latitude?: FieldDef<F>;\n\n  /**\n   * Longitude-2 position for geographically projected ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n   */\n  longitude2?: FieldDef<F>;\n\n  /**\n   * Latitude-2 position for geographically projected ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n   */\n  latitude2?: FieldDef<F>;\n\n  /**\n   * Color of the marks – either fill or stroke color based on  the `filled` property of mark definition.\n   * By default, `color` represents fill color for `\"area\"`, `\"bar\"`, `\"tick\"`,\n   * `\"text\"`, `\"trail\"`, `\"circle\"`, and `\"square\"` / stroke color for `\"line\"` and `\"point\"`.\n   *\n   * __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `color` property.\n   *\n   * _Note:_\n   * 1) For fine-grained control over both fill and stroke colors of the marks, please use the `fill` and `stroke` channels.  If either `fill` or `stroke` channel is specified, `color` channel will be ignored.\n   * 2) See the scale documentation for more information about customizing [color scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme).\n   */\n  color?: FieldDefWithCondition<MarkPropFieldDef<F>> | ValueDefWithCondition<MarkPropFieldDef<F>>;\n\n  /**\n   * Fill color of the marks.\n   * __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `color` property.\n   *\n   * _Note:_ When using `fill` channel, `color ` channel will be ignored. To customize both fill and stroke, please use `fill` and `stroke` channels (not `fill` and `color`).\n   */\n  fill?: FieldDefWithCondition<MarkPropFieldDef<F>> | ValueDefWithCondition<MarkPropFieldDef<F>>;\n\n\n  /**\n   * Stroke color of the marks.\n   * __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `color` property.\n   *\n   * _Note:_ When using `stroke` channel, `color ` channel will be ignored. To customize both stroke and fill, please use `stroke` and `fill` channels (not `stroke` and `color`).\n   */\n  stroke?: FieldDefWithCondition<MarkPropFieldDef<F>> | ValueDefWithCondition<MarkPropFieldDef<F>>;\n\n\n  /**\n   * Opacity of the marks – either can be a value or a range.\n   *\n   * __Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `opacity` property.\n   */\n  opacity?: FieldDefWithCondition<MarkPropFieldDef<F>> | ValueDefWithCondition<MarkPropFieldDef<F>>;\n\n  /**\n   * Size of the mark.\n   * - For `\"point\"`, `\"square\"` and `\"circle\"`, – the symbol size, or pixel area of the mark.\n   * - For `\"bar\"` and `\"tick\"` – the bar and tick's size.\n   * - For `\"text\"` – the text's font size.\n   * - Size is unsupported for `\"line\"`, `\"area\"`, and `\"rect\"`. (Use `\"trail\"` instead of line with varying size)\n   */\n  size?: FieldDefWithCondition<MarkPropFieldDef<F>> | ValueDefWithCondition<MarkPropFieldDef<F>>;\n\n  /**\n   * For `point` marks the supported values are\n   * `\"circle\"` (default), `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`,\n   * or `\"triangle-down\"`, or else a custom SVG path string.\n   * For `geoshape` marks it should be a field definition of the geojson data\n   *\n   * __Default value:__ If undefined, the default shape depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#point-config)'s `shape` property.\n   */\n  shape?: FieldDefWithCondition<MarkPropFieldDef<F>> | ValueDefWithCondition<MarkPropFieldDef<F>>; // TODO: maybe distinguish ordinal-only\n\n  /**\n   * Additional levels of detail for grouping data in aggregate views and\n   * in line, trail, and area marks without mapping data to a specific visual channel.\n   */\n  detail?: FieldDef<F> | FieldDef<F>[];\n\n  /**\n   * A data field to use as a unique key for data binding. When a visualization’s data is updated, the key value will be used to match data elements to existing mark instances. Use a key channel to enable object constancy for transitions over dynamic data.\n   */\n  key?: FieldDef<F>;\n\n  /**\n   * Text of the `text` mark.\n   */\n  text?: FieldDefWithCondition<TextFieldDef<F>> | ValueDefWithCondition<TextFieldDef<F>>;\n\n  /**\n   * The tooltip text to show upon mouse hover.\n   */\n  tooltip?: FieldDefWithCondition<TextFieldDef<F>> | ValueDefWithCondition<TextFieldDef<F>> | TextFieldDef<F>[];\n\n  /**\n   * A URL to load upon mouse click.\n   */\n  href?: FieldDefWithCondition<FieldDef<F>> | ValueDefWithCondition<FieldDef<F>>;\n\n  /**\n   * Order of the marks.\n   * - For stacked marks, this `order` channel encodes [stack order](https://vega.github.io/vega-lite/docs/stack.html#order).\n   * - For line and trail marks, this `order` channel encodes order of data points in the lines. This can be useful for creating [a connected scatterplot](https://vega.github.io/vega-lite/examples/connected_scatterplot.html).  Setting `order` to `{\"value\": null}` makes the line marks use the original order in the data sources.\n   * - Otherwise, this `order` channel encodes layer order of the marks.\n   *\n   * __Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating additional aggregation grouping.\n   */\n  order?: OrderFieldDef<F> | OrderFieldDef<F>[] | ValueDef;\n}\n\nexport interface EncodingWithFacet<F> extends Encoding<F>, FacetMapping<F> {}\n\nexport function channelHasField(encoding: EncodingWithFacet<Field>, channel: Channel): boolean {\n  const channelDef = encoding && encoding[channel];\n  if (channelDef) {\n    if (isArray(channelDef)) {\n      return some(channelDef, (fieldDef) => !!fieldDef.field);\n    } else {\n      return isFieldDef(channelDef) || hasConditionalFieldDef(channelDef);\n    }\n  }\n  return false;\n}\n\n\nexport function isAggregate(encoding: EncodingWithFacet<Field>) {\n  return some(CHANNELS, (channel) => {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      if (isArray(channelDef)) {\n        return some(channelDef, (fieldDef) => !!fieldDef.aggregate);\n      } else {\n        const fieldDef = getFieldDef(channelDef);\n        return fieldDef && !!fieldDef.aggregate;\n      }\n    }\n    return false;\n  });\n}\n\nexport function normalizeEncoding(encoding: Encoding<string>, mark: Mark): Encoding<string> {\n   return keys(encoding).reduce((normalizedEncoding: Encoding<string>, channel: Channel | string) => {\n    if (!isChannel(channel)) {\n      // Drop invalid channel\n      log.warn(log.message.invalidEncodingChannel(channel));\n      return normalizedEncoding;\n    }\n\n    if (!supportMark(channel, mark)) {\n      // Drop unsupported channel\n\n      log.warn(log.message.incompatibleChannel(channel, mark));\n      return normalizedEncoding;\n    }\n\n    // Drop line's size if the field is aggregated.\n    if (channel === 'size' && mark === 'line') {\n      const fieldDef = getFieldDef(encoding[channel]);\n      if (fieldDef && fieldDef.aggregate) {\n        log.warn(log.message.LINE_WITH_VARYING_SIZE);\n        return normalizedEncoding;\n      }\n    }\n\n    // Drop color if either fill or stroke is specified\n     if (channel === 'color' && ('fill' in encoding || 'stroke' in encoding) ) {\n       log.warn(log.message.droppingColor('encoding', {fill: 'fill' in encoding, stroke: 'stroke' in encoding}));\n       return normalizedEncoding;\n    }\n\n    const channelDef = encoding[channel];\n    if (\n      channel === 'detail' ||\n      (channel === 'order' && !isArray(channelDef) && !isValueDef(channelDef)) ||\n      (channel === 'tooltip' && isArray(channelDef))\n    ) {\n      if (channelDef) {\n        // Array of fieldDefs for detail channel (or production rule)\n        normalizedEncoding[channel] = (isArray(channelDef) ? channelDef : [channelDef])\n          .reduce((defs: FieldDef<string>[], fieldDef: FieldDef<string>) => {\n            if (!isFieldDef(fieldDef)) {\n              log.warn(log.message.emptyFieldDef(fieldDef, channel));\n            } else {\n              defs.push(normalizeFieldDef(fieldDef, channel));\n            }\n            return defs;\n          }, []);\n      }\n    } else {\n\n      const fieldDef = getFieldDef(encoding[channel]);\n      if (fieldDef && contains([Type.LATITUDE, Type.LONGITUDE], fieldDef.type)) {\n        const {[channel]: _, ...newEncoding} = normalizedEncoding;\n        const newChannel = channel === 'x' ? 'longitude' :\n          channel === 'y' ? 'latitude' :\n          channel === 'x2' ? 'longitude2' :\n          channel === 'y2' ? 'latitude2' : undefined;\n        log.warn(log.message.latLongDeprecated(channel, fieldDef.type, newChannel));\n        return {\n          ...newEncoding,\n          [newChannel]: {\n            ...normalize(fieldDef as any, channel),\n            type: 'quantitative'\n          }\n        };\n      }\n\n      if (!isFieldDef(channelDef) && !isValueDef(channelDef) && !isConditionalDef(channelDef)) {\n        log.warn(log.message.emptyFieldDef(channelDef, channel));\n        return normalizedEncoding;\n      }\n      normalizedEncoding[channel] = normalize(channelDef as ChannelDef<string>, channel);\n    }\n    return normalizedEncoding;\n  }, {});\n}\n\n\nexport function isRanged(encoding: EncodingWithFacet<any>) {\n  return encoding && ((!!encoding.x && !!encoding.x2) || (!!encoding.y && !!encoding.y2));\n}\n\nexport function fieldDefs(encoding: EncodingWithFacet<Field>): FieldDef<Field>[] {\n  const arr: FieldDef<Field>[] = [];\n  CHANNELS.forEach(function(channel) {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      (isArray(channelDef) ? channelDef : [channelDef]).forEach((def) => {\n        if (isFieldDef(def)) {\n          arr.push(def);\n        } else if (hasConditionalFieldDef(def)) {\n          arr.push(def.condition);\n        }\n      });\n    }\n  });\n  return arr;\n}\n\nexport function forEach(mapping: any,\n    f: (fd: FieldDef<string>, c: Channel) => void,\n    thisArg?: any) {\n  if (!mapping) {\n    return;\n  }\n\n  for (const channel of keys(mapping)) {\n    if (isArray(mapping[channel])) {\n      mapping[channel].forEach(function(channelDef: ChannelDef<string>) {\n        f.call(thisArg, channelDef, channel);\n      });\n    } else {\n      f.call(thisArg, mapping[channel], channel);\n    }\n  }\n}\n\nexport function reduce<T, U extends {[k in Channel]?: any}>(mapping: U,\n    f: (acc: any, fd: FieldDef<string>, c: Channel) => U,\n    init: T, thisArg?: any) {\n  if (!mapping) {\n    return init;\n  }\n\n  return keys(mapping).reduce((r, channel) => {\n    const map = mapping[channel];\n    if (isArray(map)) {\n      return map.reduce((r1: T, channelDef: ChannelDef<string>) => {\n        return f.call(thisArg, r1, channelDef, channel);\n      }, r);\n    } else {\n      return f.call(thisArg, r, map, channel);\n    }\n  }, init);\n}\n"]}