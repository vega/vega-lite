{"version":3,"file":"stack.js","sourceRoot":"","sources":["../../src/stack.ts"],"names":[],"mappings":"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","sourcesContent":["import {isArray} from 'vega-util';\nimport {SUM_OPS} from './aggregate';\nimport {NONPOSITION_CHANNELS, NonPositionChannel, X, X2, Y2} from './channel';\nimport {channelHasField, Encoding} from './encoding';\nimport {Field, FieldDef, getFieldDef, isFieldDef, isStringFieldDef, PositionFieldDef, vgField} from './fielddef';\nimport * as log from './log';\nimport {AREA, BAR, CIRCLE, isMarkDef, isPathMark, LINE, Mark, MarkDef, POINT, RULE, SQUARE, TEXT, TICK} from './mark';\nimport {ScaleType} from './scale';\nimport {contains, Flag} from './util';\n\n\nexport type StackOffset = 'zero' | 'center' | 'normalize';\n\nconst STACK_OFFSET_INDEX: Flag<StackOffset> = {\n  zero: 1,\n  center: 1,\n  normalize: 1\n};\n\nexport function isStackOffset(s: string): s is StackOffset {\n  return !!STACK_OFFSET_INDEX[s];\n}\n\nexport interface StackProperties {\n  /** Dimension axis of the stack. */\n  groupbyChannel: 'x' | 'y';\n\n  /** Measure axis of the stack. */\n  fieldChannel: 'x' | 'y';\n\n  /** Stack-by fields e.g., color, detail */\n  stackBy: {\n    fieldDef: FieldDef<string>,\n    channel: NonPositionChannel\n  }[];\n\n  /**\n   * See `\"stack\"` property of Position Field Def.\n   */\n  offset: StackOffset;\n\n  /**\n   * Whether this stack will produce impute transform\n   */\n  impute: boolean;\n}\n\nexport const STACKABLE_MARKS = [BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK];\nexport const STACK_BY_DEFAULT_MARKS = [BAR, AREA];\n\n\nfunction potentialStackedChannel(encoding: Encoding<Field>): 'x' | 'y' | undefined {\n  const xDef = encoding.x;\n  const yDef = encoding.y;\n\n  if (isFieldDef(xDef) && isFieldDef(yDef)) {\n    if (xDef.type === 'quantitative' && yDef.type === 'quantitative') {\n      if (xDef.stack) {\n        return 'x';\n      } else if (yDef.stack) {\n        return 'y';\n      }\n      // if there is no explicit stacking, only apply stack if there is only one aggregate for x or y\n      if ((!!xDef.aggregate) !== (!!yDef.aggregate)) {\n        return xDef.aggregate ? 'x' : 'y';\n      }\n    } else if (xDef.type === 'quantitative') {\n      return 'x';\n    } else if (yDef.type === 'quantitative') {\n      return 'y';\n    }\n  } else if (isFieldDef(xDef) && xDef.type === 'quantitative') {\n    return 'x';\n  } else if (isFieldDef(yDef) && yDef.type === 'quantitative') {\n    return 'y';\n  }\n  return undefined;\n}\n\n// Note: CompassQL uses this method and only pass in required properties of each argument object.\n// If required properties change, make sure to update CompassQL.\nexport function stack(m: Mark | MarkDef, encoding: Encoding<Field>, stackConfig: StackOffset): StackProperties {\n  const mark = isMarkDef(m) ? m.type : m;\n  // Should have stackable mark\n  if (!contains(STACKABLE_MARKS, mark)) {\n    return null;\n  }\n\n  const fieldChannel = potentialStackedChannel(encoding);\n  if (!fieldChannel) {\n    return null;\n  }\n\n  const stackedFieldDef = encoding[fieldChannel] as PositionFieldDef<string>;\n  const stackedField = isStringFieldDef(stackedFieldDef) ? vgField(stackedFieldDef, {}) : undefined;\n\n  const dimensionChannel = fieldChannel === 'x' ? 'y' : 'x';\n  const dimensionDef = encoding[dimensionChannel];\n  const dimensionField = isStringFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : undefined;\n\n  // Should have grouping level of detail that is different from the dimension field\n  const stackBy = NONPOSITION_CHANNELS.reduce((sc, channel) => {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      (isArray(channelDef) ? channelDef : [channelDef]).forEach((cDef) => {\n        const fieldDef = getFieldDef(cDef);\n        if (fieldDef.aggregate) {\n          return;\n        }\n\n        // Check whether the channel's field is identical to x/y's field or if the channel is a repeat\n        const f = isStringFieldDef(fieldDef) ? vgField(fieldDef, {}) : undefined;\n        if (\n          // if fielddef is a repeat, just include it in the stack by\n          !f ||\n          // otherwise, the field must be different from x and y fields.\n          (f !== dimensionField && f !== stackedField)\n        ) {\n          sc.push({channel, fieldDef});\n        }\n      });\n    }\n    return sc;\n  }, []);\n\n  if (stackBy.length === 0) {\n    return null;\n  }\n\n  // Automatically determine offset\n  let offset: StackOffset = undefined;\n  if (stackedFieldDef.stack !== undefined) {\n    offset = stackedFieldDef.stack;\n  } else if (contains(STACK_BY_DEFAULT_MARKS, mark)) {\n    // Bar and Area with sum ops are automatically stacked by default\n    offset = stackConfig === undefined ? 'zero' : stackConfig;\n  } else {\n    offset = stackConfig;\n  }\n\n  if (!offset || !isStackOffset(offset)) {\n    return null;\n  }\n\n  // warn when stacking non-linear\n  if (stackedFieldDef.scale && stackedFieldDef.scale.type && stackedFieldDef.scale.type !== ScaleType.LINEAR) {\n    log.warn(log.message.cannotStackNonLinearScale(stackedFieldDef.scale.type));\n  }\n\n  // Check if it is a ranged mark\n  if (channelHasField(encoding, fieldChannel === X ? X2 : Y2)) {\n    if (stackedFieldDef.stack !== undefined) {\n      log.warn(log.message.cannotStackRangedMark(fieldChannel));\n    }\n    return null;\n  }\n\n  // Warn if stacking summative aggregate\n  if (stackedFieldDef.aggregate && !contains(SUM_OPS, stackedFieldDef.aggregate)) {\n    log.warn(log.message.stackNonSummativeAggregate(stackedFieldDef.aggregate));\n  }\n\n  return {\n    groupbyChannel: dimensionDef ? dimensionChannel : undefined,\n    fieldChannel,\n    impute: isPathMark(mark),\n    stackBy,\n    offset\n  };\n}\n"]}