{"version":3,"file":"formatparse.test.js","sourceRoot":"","sources":["../../../../test/compile/data/formatparse.test.ts"],"names":[],"mappings":"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","sourcesContent":["/* tslint:disable:quotemark */\nimport {assert} from 'chai';\nimport {AncestorParse} from '../../../src/compile/data';\nimport {DataFlowNode} from '../../../src/compile/data/dataflow';\nimport {ParseNode} from '../../../src/compile/data/formatparse';\nimport {parseTransformArray} from '../../../src/compile/data/parse';\nimport {ModelWithField} from '../../../src/compile/model';\nimport * as log from '../../../src/log';\nimport {parseFacetModel, parseUnitModel} from '../../util';\n\ndescribe('compile/data/formatparse', () => {\n  describe('parseUnit', () => {\n    it('should flatten nested fields that are used to sort domains', () => {\n      const model = parseUnitModel({\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'ordinal', sort: {field: 'foo.bar', op: 'mean'}}\n        }\n      });\n\n      assert.deepEqual(ParseNode.makeImplicitFromEncoding(null, model, new AncestorParse()).parse, {\n        'foo.bar': 'flatten'\n      });\n    });\n\n    it('should return a correct customized parse.', () => {\n      const model = parseUnitModel({\n        data: {url: 'a.json', format: {parse: {c: 'number', d: 'date'}}},\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'quantitative'},\n          y: {field: 'b', type: 'temporal'},\n          color: {field: 'c', type: 'ordinal'},\n          shape: {field: 'c', type: 'nominal'}\n        }\n      });\n\n      const ancestorParese = new AncestorParse();\n      expect(ParseNode.makeImplicitFromEncoding(null, model, ancestorParese).parse).toEqual({\n        b: 'date'\n      });\n\n      expect(ParseNode.makeExplicit(null, model, ancestorParese).parse).toEqual({\n        c: 'number',\n        d: 'date'\n      });\n    });\n\n    it('should include parse for all applicable fields, and exclude calculated fields', () => {\n      const model = parseUnitModel({\n        transform: [{calculate: 'datum[\"b\"] * 2', as: 'b2'}],\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'temporal'},\n          y: {field: 'b', type: 'quantitative'},\n          color: {type: 'quantitative', aggregate: 'count'},\n          size: {field: 'b2', type: 'quantitative'}\n        }\n      });\n\n      const ancestorParse = new AncestorParse();\n      const parent = new DataFlowNode(null);\n      parseTransformArray(parent, model, ancestorParse);\n      expect(ancestorParse.combine()).toEqual({b2: 'derived'});\n      expect(ParseNode.makeImplicitFromEncoding(null, model, ancestorParse).parse).toEqual({\n        a: 'date'\n      });\n    });\n\n    it('should not parse fields with aggregate=missing/valid/distinct', () => {\n      const model = parseUnitModel({\n        mark: 'point',\n        encoding: {\n          x: {aggregate: 'missing', field: 'b', type: 'quantitative'},\n          y: {aggregate: 'valid', field: 'b', type: 'quantitative'},\n          color: {aggregate: 'distinct', field: 'b', type: 'quantitative'}\n        }\n      });\n\n      assert.deepEqual(ParseNode.makeImplicitFromEncoding(null, model, new AncestorParse()), null);\n    });\n\n    it('should not parse the same field twice', () => {\n      const model = parseFacetModel({\n        data: {\n          values: [],\n          format: {\n            parse: {\n              a: 'number'\n            }\n          }\n        },\n        facet: {\n          row: {field: 'a', type: 'ordinal'}\n        },\n        spec: {\n          mark: 'point',\n          encoding: {\n            x: {field: 'a', type: 'quantitative'},\n            y: {field: 'b', type: 'temporal'}\n          }\n        }\n      });\n\n      assert.deepEqual(ParseNode.makeExplicit(null, model, new AncestorParse()).parse, {\n        a: 'number'\n      });\n      model.parseScale();\n      model.parseData();\n\n      assert.deepEqual(model.child.component.data.ancestorParse.combine(), {\n        a: 'number',\n        b: 'date'\n      });\n\n      // set the ancestor parse to see whether fields from it are not parsed\n      model.child.component.data.ancestorParse = new AncestorParse({a: 'number'});\n      assert.deepEqual(\n        ParseNode.makeImplicitFromEncoding(\n          null,\n          model.child as ModelWithField,\n          model.child.component.data.ancestorParse\n        ).parse,\n        {\n          b: 'date'\n        }\n      );\n    });\n\n    it('should not parse the same field twice in explicit', () => {\n      const model = parseUnitModel({\n        data: {\n          values: [],\n          format: {\n            parse: {\n              a: 'number'\n            }\n          }\n        },\n        mark: 'point',\n        encoding: {}\n      });\n\n      assert.isNull(ParseNode.makeExplicit(null, model, new AncestorParse({a: 'number'}, {})));\n    });\n\n    it('should not parse the same field twice in implicit', () => {\n      const model = parseUnitModel({\n        mark: 'point',\n        encoding: {\n          x: {field: 'a', type: 'quantitative'}\n        }\n      });\n\n      assert.isNull(ParseNode.makeExplicit(null, model, new AncestorParse({a: 'number'}, {})));\n    });\n\n    it('should not parse counts', () => {\n      const model = parseUnitModel({\n        mark: 'point',\n        encoding: {\n          x: {aggregate: 'sum', field: 'foo', type: 'quantitative'},\n          y: {aggregate: 'count', type: 'quantitative'}\n        }\n      });\n\n      expect(ParseNode.makeImplicitFromEncoding(null, model, new AncestorParse())).toBeNull();\n    });\n\n    it('should add flatten for nested fields', () => {\n      const model = parseUnitModel({\n        mark: 'point',\n        encoding: {\n          x: {field: 'foo.bar', type: 'quantitative'},\n          y: {field: 'foo.baz', type: 'ordinal'}\n        }\n      });\n\n      expect(ParseNode.makeImplicitFromEncoding(null, model, new AncestorParse()).parse).toEqual({\n        'foo.bar': 'flatten',\n        'foo.baz': 'flatten'\n      });\n    });\n\n    it('should not parse if parse is disabled for a field', () => {\n      const model = parseUnitModel({\n        mark: 'point',\n        data: {\n          values: [],\n          format: {\n            parse: {\n              b: null\n            }\n          }\n        },\n        encoding: {\n          x: {field: 'a', type: 'quantitative'},\n          y: {field: 'b', type: 'quantitative'}\n        }\n      });\n\n      const ancestorParse = new AncestorParse();\n      assert.isNull(ParseNode.makeExplicit(null, model, ancestorParse), null);\n      assert.deepEqual(ancestorParse.combine(), {\n        b: null\n      });\n      expect(ParseNode.makeImplicitFromEncoding(null, model, ancestorParse)).toBeNull();\n    });\n\n    it('should not parse if parse is disabled', () => {\n      const model = parseUnitModel({\n        mark: 'point',\n        data: {\n          values: [],\n          format: {\n            parse: null // implies AncestorParse.makeExplicit = true\n          }\n        },\n        encoding: {\n          x: {field: 'a', type: 'quantitative'},\n          y: {field: 'b', type: 'quantitative'}\n        }\n      });\n\n      assert.isNull(ParseNode.makeExplicit(null, model, new AncestorParse({}, {}, true)));\n    });\n  });\n\n  describe('assembleTransforms', () => {\n    it('should assemble correct parse expressions', () => {\n      const p = new ParseNode(null, {\n        n: 'number',\n        b: 'boolean',\n        s: 'string',\n        d1: 'date',\n        d2: 'date:\"%y\"',\n        d3: 'utc:\"%y\"'\n      });\n\n      assert.deepEqual(p.assembleTransforms(), [\n        {type: 'formula', expr: 'toNumber(datum[\"n\"])', as: 'n'},\n        {type: 'formula', expr: 'toBoolean(datum[\"b\"])', as: 'b'},\n        {type: 'formula', expr: 'toString(datum[\"s\"])', as: 's'},\n        {type: 'formula', expr: 'toDate(datum[\"d1\"])', as: 'd1'},\n        {type: 'formula', expr: 'timeParse(datum[\"d2\"],\"%y\")', as: 'd2'},\n        {type: 'formula', expr: 'utcParse(datum[\"d3\"],\"%y\")', as: 'd3'}\n      ]);\n    });\n\n    it('should assemble flatten for nested fields', () => {\n      const p = new ParseNode(null, {\n        flat: 'number',\n        'nested.field': 'flatten'\n      });\n\n      assert.deepEqual(p.assembleTransforms(true), [\n        {type: 'formula', expr: 'datum[\"nested\"] && datum[\"nested\"][\"field\"]', as: 'nested.field'}\n      ]);\n    });\n\n    it(\n      'should show warning for unrecognized types',\n      log.wrap(localLogger => {\n        const p = new ParseNode(null, {\n          x: 'foo'\n        });\n\n        assert.deepEqual(p.assembleTransforms(), []);\n        assert.equal(localLogger.warns[0], log.message.unrecognizedParse('foo'));\n      })\n    );\n  });\n\n  describe('assembleFormatParse', () => {\n    it('should assemble correct parse', () => {\n      const p = new ParseNode(null, {\n        n: 'number',\n        b: 'boolean',\n        'nested.field': 'flatten'\n      });\n\n      assert.deepEqual(p.assembleFormatParse(), {\n        n: 'number',\n        b: 'boolean'\n      });\n    });\n  });\n\n  describe('producedFields', () => {\n    it('should produce the correct fields', () => {\n      const p = new ParseNode(null, {\n        n: 'number',\n        b: 'boolean',\n        'nested.field': 'flatten'\n      });\n\n      assert.deepEqual(p.producedFields(), {n: true, b: true, 'nested.field': true});\n    });\n  });\n\n  describe('clone', () => {\n    it('should never clone parent', () => {\n      const parent = new DataFlowNode(null);\n      const parse = new ParseNode(parent, {});\n      expect(parse.clone().parent).toBeNull();\n    });\n  });\n});\n"]}