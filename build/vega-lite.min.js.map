{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/json-stable-stringify/index.js","node_modules/jsonify/index.js","node_modules/jsonify/lib/parse.js","node_modules/jsonify/lib/stringify.js","node_modules/tslib/tslib.js","node_modules/vega-event-selector/build/vega-event-selector.js","node_modules/vega-util/build/vega-util.js","package.json","src/aggregate.ts","src/axis.ts","src/bin.ts","src/channel.ts","src/compile/axis/encode.ts","src/compile/axis/parse.ts","src/compile/axis/rules.ts","src/compile/common.ts","src/compile/compile.ts","src/compile/concat.ts","src/compile/data/aggregate.ts","src/compile/data/assemble.ts","src/compile/data/bin.ts","src/compile/data/dataflow.ts","src/compile/data/facet.ts","src/compile/data/formatparse.ts","src/compile/data/nonpositivefilter.ts","src/compile/data/nullfilter.ts","src/compile/data/optimizers.ts","src/compile/data/parse.ts","src/compile/data/pathorder.ts","src/compile/data/source.ts","src/compile/data/stack.ts","src/compile/data/timeunit.ts","src/compile/data/transforms.ts","src/compile/facet.ts","src/compile/layer.ts","src/compile/layout/header.ts","src/compile/layout/index.ts","src/compile/legend/encode.ts","src/compile/legend/parse.ts","src/compile/legend/rules.ts","src/compile/mark/area.ts","src/compile/mark/bar.ts","src/compile/mark/init.ts","src/compile/mark/line.ts","src/compile/mark/mark.ts","src/compile/mark/mixins.ts","src/compile/mark/point.ts","src/compile/mark/rect.ts","src/compile/mark/rule.ts","src/compile/mark/text.ts","src/compile/mark/tick.ts","src/compile/mark/valueref.ts","src/compile/model.ts","src/compile/repeat.ts","src/compile/scale/assemble.ts","src/compile/scale/domain.ts","src/compile/scale/init.ts","src/compile/scale/parse.ts","src/compile/scale/range.ts","src/compile/scale/rules.ts","src/compile/scale/type.ts","src/compile/selection/interval.ts","src/compile/selection/multi.ts","src/compile/selection/selection.ts","src/compile/selection/single.ts","src/compile/selection/transforms/inputs.ts","src/compile/selection/transforms/nearest.ts","src/compile/selection/transforms/project.ts","src/compile/selection/transforms/scales.ts","src/compile/selection/transforms/toggle.ts","src/compile/selection/transforms/transforms.ts","src/compile/selection/transforms/translate.ts","src/compile/selection/transforms/zoom.ts","src/compile/unit.ts","src/compositemark/boxplot.ts","src/compositemark/errorbar.ts","src/compositemark/index.ts","src/config.ts","src/data.ts","src/datetime.ts","src/encoding.ts","src/fielddef.ts","src/filter.ts","src/legend.ts","src/log.ts","src/mark.ts","src/scale.ts","src/selection.ts","src/sort.ts","src/spec.ts","src/stack.ts","src/timeunit.ts","src/toplevelprops.ts","src/transform.ts","src/type.ts","src/util.ts","src/validate.ts","src/vega.schema.ts","src/vl.ts"],"names":["f","exports","module","define","amd","g","window","global","self","this","vl","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","json","JSON","obj","opts","cmp","space","Array","join","cycles","replacer","key","value","node","b","aobj","bobj","seen","stringify","parent","level","indent","colonSeparator","toJSON","undefined","isArray","out","item","push","indexOf","TypeError","keys","objectKeys","sort","keyValue","splice","","x","toString","Object","has","prototype","hasOwnProperty","parse","at","ch","text","escapee","\"","\\","/","error","m","name","message","next","c","charAt","number","string","isFinite","hex","uffff","parseInt","String","fromCharCode","white","word","array","object","source","reviver","result","walk","holder","k","v","quote","escapable","lastIndex","test","replace","meta","charCodeAt","slice","str","partial","mind","gap","rep","apply","\b","\t","\n","\f","\r","__extends","__assign","__rest","__decorate","__param","__metadata","__awaiter","__generator","__exportStar","__values","__read","__spread","__asyncGenerator","__asyncDelegator","__asyncValues","factory","createExporter","previous","id","root","exporter","extendStatics","setPrototypeOf","__proto__","d","p","__","constructor","create","assign","arguments","getOwnPropertySymbols","decorators","target","desc","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","paramIndex","decorator","metadataKey","metadataValue","metadata","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","rejected","done","then","body","verb","op","_","y","label","ops","pop","trys","sent","throw","return","Symbol","iterator","ar","concat","q","resume","shift","settle","send","fulfill","asyncIterator","vega","isMarkType","type","MARKS","find","endChar","pushChar","popChar","count","parseMerge","output","start","COMMA","LBRACK","LBRACE","RBRACK","RBRACE","substring","trim","parseSelector","parseBetween","parseStream","stream","GT","map","between","j","filter","DEFAULT_SOURCE","throttle","markname","lastIndexOf","parseThrottle","NAME","COLON","ILLEGAL","marktype","consume","debounce","split","eventSelector","selector","marks","VIEW","DEFAULT_MARKS","*","arc","area","group","image","line","path","rect","rule","shape","symbol","trail","accessorName","fn","fname","accessorFields","fields","$","isObject","isString","log","method","input","args","console","accessor","splitAccessPath","field","Function","empty","identity","zero","one","truthy","falsy","logger","warn","info","debug","compare","orders","lt","gt","idx","ord","isFunction","constant","extend","len","extentIndex","NULL","fastmap","size","get","set","delete","clear","clean","forEach","inherits","child","proto","isBoolean","isDate","isNumber","isRegExp","merge","array0","array1","n0","n1","merged","i0","i1","repeat","reps","pad","padchar","align","Math","ceil","peek","toBoolean","toDate","parser","Date","toNumber","toSet","truncate","ellipsis","max","visitArray","visitor","None","Warn","Info","Debug","stringValue","author","version","collaborators","homepage","description","main","types","bin","vl2png","vl2svg","vl2vg","directories","scripts","tsc","prebuild","build","postbuild","build:examples","build:images","build:toc","build:site","build:versions","build:test-gallery","check:examples","check:schema","data","link","deploy","deploy:gh","deploy:schema","prestart","poststart","preschema","schema","replaceschema","presite","site","lint","posttest","test:nocompile","test:only","test:debug","mocha:test","mocha:examples","codecov","watch:build","watch:test","watch","repository","url","license","bugs","devDependencies","@types/chai","@types/d3","@types/highlight.js","@types/json-stable-stringify","@types/mocha","@types/node","ajv","browser-sync","browserify","browserify-shim","chai","cheerio","d3","exorcist","highlight.js","mocha","nodemon","nyc","source-map-support","tsify","tslint","tslint-eslint-rules","typescript","typescript-json-schema","uglify-js","vega-datasets","vega-embed","watchify","yaml-front-matter","dependencies","json-stable-stringify","tslib","vega-event-selector","vega-util","yargs","util_1","AGGREGATE_OPS","AGGREGATE_OP_INDEX","SUM_OPS","SHARED_DOMAIN_OPS","SHARED_DOMAIN_OP_INDEX","AXIS_PROPERTIES","binToString","autoMaxBins","channel","channel_1","ROW","COLUMN","SIZE","COLOR","OPACITY","SHAPE","isChannel","CHANNEL_INDEX","supportMark","mark","getSupportedMark","X","Y","DETAIL","ORDER","point","tick","circle","square","bar","X2","Y2","TEXT","hasScale","contains","supportScaleType","scaleType","POSITION_SCALE_TYPE_INDEX","rangeType","Channel","scale_1","CHANNELS","UNIT_CHANNELS","UNIT_SCALE_CHANNELS","SCALE_CHANNELS","NONSPATIAL_CHANNELS","NONSPATIAL_SCALE_CHANNELS","LEVEL_OF_DETAIL_CHANNELS","without","STACK_GROUP_CHANNELS","SCALE_TYPES","labels","model","labelsSpec","def","fieldDef","axis","config","type_1","TEMPORAL","signal","common_1","timeFormatExpression","timeUnit","format","shortTimeLabels","timeFormat","labelAngle","angle","NOMINAL","ORDINAL","orient","baseline","parseAxisComponent","axisChannels","reduce","axisComponent","axes","gridAxes","parseMainAxis","isVisibleAxis","grid","parseGridAxis","isFalseOrNull","some","AXIS_PARTS","part","hasAxisPart","parseAxis","isGridAxis","vgAxis","scale","scaleName","axis_1","property","getSpecifiedOrDefaultValue","gridScale","encodeSpec","encode","update","specifiedAxis","rules","domain","ticks","tickCount","title","values","zindex","numberFormat","gridShow","hasDiscreteDomain","gridChannel","INVALID_CHANNEL_FOR_AXIS","fieldTitle","fielddef_1","maxLength","titleMaxLength","vals","datetime_1","isDateTime","dt","timestamp","z","domainAndTicks","buildModel","spec","parentGivenName","repeater","spec_1","isFacetSpec","facet_1","FacetModel","isLayerSpec","layer_1","LayerModel","isUnitSpec","unit_1","UnitModel","isRepeatSpec","repeat_1","RepeatModel","isConcatSpec","concat_1","ConcatModel","INVALID_SPEC","applyConfig","propsList","applyMarkConfig","getMarkConfig","prop","markSpecificConfig","formatSignalRef","expr","useBinRange","binSuffix","specifiedFormat","QUANTITATIVE","aggregate","timeFormatConfig","timeunit_1","formatExpression","sortParams","orderDef","orderChannelDef","order","compile","inputSpec","config_1","initConfig","normalize","assemble","getTopLevelProperties","reset","topLevelSpec","tslib_1","toplevelprops_1","extractTopLevelProperties","topLevelProperties","$schema","autosize","assembleData","assembleSelectionData","signals","getName","assembleLayoutSignals","assembleSelectionTopLevelSignals","assembleNestedMainGroup","_a","assembleGroup","layout","hasLayout","assembleLayout","parentEncodeEntry","width","height","assembleParentGroupProperties","assemble_1","parse_1","model_1","_super","_this","children","vconcat","parseData","component","parseSelection","selection","_i","parseScale","scales","parseMark","parseAxisAndHeader","parseAxisGroup","parseLegend","legends","sources","sg","assembleSelectionSignals","db","assembleScales","padding","row","column","offset","columns","bounds","assembleMarks","getSizeSignalRef","Model","addDimension","dims","mergeMeasures","parentMeasures","childMeasures","field_1","dataflow_1","AggregateNode","dimensions","measures","clone","duplicate","make","isAggregate","forEachFieldDef","fd","meas","other","differ","remove","addDimensions","dependentFields","producedFields","groupby","DataFlowNode","removeUnnecessaryNodes","nonpositivefilter_1","NonPositiveFilterNode","every","nullfilter_1","NullFilterNode","filteredFields","OutputNode","required","cloneSubtree","facet","pathorder_1","OrderNode","copy_1","newName","FACET_SCALE_PREFIX","outputNodes","flatten","aggregate_1","stack_1","StackNode","moveFacetDown","FacetNode","numChildren","moveMainDownToFacet","copy","swapWithParent","data_1","MAIN","getLeaves","roots","append","leaves","makeWalkTree","walkTree","dataSource","formatparse_1","ParseNode","source_1","SourceNode","assembleFormatParse","transform","assembleTransforms","datasetIndex","transforms_1","FilterNode","CalculateNode","bin_1","BinNode","TimeUnitNode","newData","source_2","assembleFacetData","optimizers_1","iterateFromLeaves","optimizers","removeUnusedSubtrees","moveParseUp","sourceIndex","hasName","dataName","numberFormatExpr","rangeFormula","guide","legend","startField","endField","formulaAs","formula","bins","reduceFieldDef","binComponent","fieldDefBin","as","extentSignal","binTrans","extent","debugName","_children","_parent","addChild","removeChild","oldChild","newParent","_refcount","_source","cloneObj","columnField","columnName","rowField","rowName","parseExpression","unrecognizedParse","filter_1","transform_1","_parse","calcFieldMap","transforms","isCalculate","fieldMap","isFilter","val","isEqualFilter","equal","isRangeFilter","range","isOneOfFilter","oneOf","ModelWithField","isCount","p_1","_filter","channels","nonPositiveComponent","ScaleType","LOG","DEFAULT_NULL_FILTERS","nominal","ordinal","quantitative","temporal","_filteredFields","aggregator","filterInvalid","hash","differArray","filters","_filters","optimizeNextFromLeaves","parseRoot","facetRoot","head","parseTransformArray","first","last","nullFilter","tu","rawName","RAW","raw","agg","stack","nonPosFilter","mainName","facetName","facet_2","encoding_1","sort_1","channelHasField","encoding","dimensionChannel","markDef","isSortField","isInlineData","_data","isUrlData","defaultExtension","exec","dataFormat","formatType","feature","mesh","isNamedData","_name","getStackByFields","stackBy","by","_field","vega_util_1","_stack","stackProperties","groupbyChannel","stackby","fieldChannel","impute","orderby","timeUnitComponent","fieldExpr","invalidTransformIgnored","expression","calculate","hasSubPlotWithXy","hasDescendantWithFieldOnChannel","childSizeEncodeEntryMixins","sizeType","getFacetGroupProperties","cell","mark_1","FILL_STROKE_CONFIG","vega_schema_1","header_1","replaceRepeaterInFacet","initFacet","normalizedFacet","emptyFieldDef","incompatibleChannel","scaleComponent","scaleNameWithoutPrefix","substr","renameScale","isDataRefDomain","isFieldRefUnionDomain","isDataRefUnionedDomain","from","parseHeader","mergeChildAxis","layoutHeaders","fieldRef","header","makeHeaderComponent","sizeChannel","sizeSignal","headerChannel","layoutHeader","headerType","getHeaderType","columnDistinctSignal","prefix","correctDataNames","getMapping","index_1","domain_1","selection_1","layer","childScale","modelScale","isSignalRefDomain","unionDomains","legendComponent","assembleLayoutLayerSignals","assembleLayerSelectionMarks","getTitleGroup","positionChannel","textOrient","role","fill","fontWeight","getHeaderGroup","fontSize","hasAxes","HEADER_CHANNELS","HEADER_TYPES","layerSizeExpr","assembleLayoutUnitSignals","unitSizeExpr","rangeStep","cardinality","paddingOuter","paddingInner","symbols","symbolsSpec","BAR","TICK","CIRCLE","SQUARE","POINT","LINE","AREA","cfg","filled","strokeWidth","colorDef","color","isValueDef","stroke","shapeDef","parseLegendComponent","getLegendDefWithScale","opacity","legend_1","LEGEND_PROPERTIES","specifiedLegend","isBinScale","mixins","vgMark","defaultRole","encodeEntry","pointPosition","pointPosition2","nonPosition","markDefProperties","sizeDef","xDef","xScaleName","xScale","isFieldDef","binnedPosition","binSpacing","BAND","bandPosition","centeredBandPosition","ref","midX","defaultSizeRef","yDef","yScaleName","yScale","midY","discreteBandSize","band","continuousBandSize","BAR_WITH_POINT_SCALE_AND_RANGESTEP_NULL","initMarkDef","isMarkDef","specifiedOrient","orientOverridden","initEncoding","stacked","opacityConfig","defaultOpacity","filledConfig","RULE","RECT","yIsRange","y2","xIsRange","x2","xScaleType","yScaleType","xIsContinuous","isContinuous","yIsContinuous","xIsTemporal","yIsTemporal","unclearOrientContinuous","unclearOrientDiscreteOrEmpty","vgChannel","parsePathMark","parseNonPathMark","details","detailFields","pathMarks","markCompiler","FACETED_PATH_PREFIX","requestDataName","area_1","bar_1","line_1","point_1","rect_1","rule_1","text_1","tick_1","defaultValue","util","props","valueIfDefined","opt","defaultRef","channelDef","valueRef","midPoint","wrapCondition","condition","selectionTest","_b","selectionName","negate","predicate","getComponent","defaultPosRef","centerChannel","spacing","stackable","baseChannel","stackable2","fixedShape","shapeMixins","x2Def","scaleTypeNotWorkWithMark","y2Def","xDefault","textDef","textXRangeStep","defaultSize","scaleRangeStep","bandSize","vgSizeChannel","vgThicknessChannel","thickness","suffix","aFieldDef","a2fieldDef","side","binMidSignal","zeroOrMinX","zeroOrMinY","zeroOrMaxX","zeroOrMaxY","TIME","UTC","NameMap","nameMap","rename","oldName","lookupDataSource","scaleNameMap","sizeNameMap","assembleScale","assembleHeaderMarks","headerMarks","HEADER_CHANNELS_1","HEADER_CHANNELS_2","HEADER_TYPES_1","_c","_d","headerGroup","assembleAxes","assembleLegends","varName","fullName","renameSize","channelSizeName","sizeName","originalScaleName","init","acc","cd","replaceRepeater","replaceRepeaterInEncoding","replaceRepeaterInFieldDef","isRepeatRef","noSuchRepeatedValue","mapping","repeatValues","_initChildren","row_1","column_1","name_1","childRepeat","initDomain","scaleConfig","canUseUnaggregatedDomain","valid","reason","useUnaggregatedDomain","parseDomain","parseSingleChannelDomain","domainSort","unaggregatedDomainWithLogScale","unaggregateDomainWithNonSharedDomainOp","unaggregateDomainHasNoEffectForRawField","normalizeDomain","INVAID_DOMAIN","domain1","domain2","UNABLE_TO_MERGE_DOMAINS","normalizedDomain1","normalizedDomain2","domains","unique","allData","topLevelSize","xyRangeSteps","specifiedScale","default","NON_TYPE_RANGE_SCALE_PROPERTIES","specifiedValue","supportedByScaleType","scaleTypeSupportProperty","channelIncompatability","channelScalePropertyIncompatability","scalePropertyNotWorkWithScaleType","getValue","range_1","getDefaultValue","nice","round","parseScaleComponent","scaleComponentsIndex","scaleComponents","parseRange","NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES","reverse","scheme","isExtendedScheme","rangeMixins","specifiedRangeStepIsNull","RANGE_PROPERTIES_1","RANGE_PROPERTIES","stepSize","rangeStepDropped","sizeRangeMin","sizeRangeMax","defaultRange","minOpacity","maxOpacity","minBandSize","minStrokeWidth","minFontSize","minSize","maxBandSize","minXYRangeStep","maxStrokeWidth","maxFontSize","maxSize","pointStep","min","smallestUnit","pointPadding","bandPaddingInner","bandPaddingOuter","specifiedType","hasTopLevelSize","specifiedRangeStep","defaultScaleType","defaultType","fieldDefMatchScaleType","scaleTypeNotWorkWithFieldDef","scaleTypeNotWorkWithChannel","discreteToContinuousType","discreteChannelCannotEncode","isDiscreteByDefault","invalidFieldType","haveRangeStep","Type","scale_2","BIN_LINEAR","BIN_ORDINAL","POW","SQRT","QUANTILE","QUANTIZE","LINEAR","projections","selCmpt","xi","yi","project","channelSignal","channelSignalName","coord","invert","bind","on","scales_1","events","evt","cb","log_1","BRUSH","interval","intervals","translate","cs","tupleExpr","modifyExpr","tpl","TUPLE","store","STORE","enter","multi","proj","datum","parseUnitSelection","selDefs","selCmpts","selectionConfig","selDef","encodings","vega_event_selector_1","forEachTransform","txCompiler","assembleUnitSelectionSignals","forEachSelection","selCompiler","MODIFY","assembleTopLevelSignals","topLevelSignals","assembleUnitSelectionData","assembleUnitSelectionMarks","clipGroup","selMarks","clipMarks","unit","PREDICATES_OPS","compiler","selections","name_2","sel","single_1","multi_1","interval_1","clip","independent","union","union_others","intersect","intersect_others","single","inputBindings","unshift","nearest","index","isPathgroup","exists","cellDef","isVoronoi","projection","scaleBindings","bound","hasContinuousDomain","domainRaw","toggle","compilers","inputs_1","nearest_1","project_1","toggle_1","translate_1","zoom_1","zoom","inputs","getSign","onDelta","anchor","ANCHOR","delta","DELTA","sign","lo","hi","base","sx","sy","force","sname","vlEncoding","parse_2","parse_3","init_1","mark_2","init_2","parse_4","initFacetCellConfig","providedWidth","providedHeight","normalizeEncoding","initScales","initAxes","initLegend","initSize","ancestor","hasFacetAncestor","topLevelWidth","topLevelHeight","cellConfig","_axis","axisSpec","_legend","legendSpec","toSpec","excludeConfig","excludeData","isUnit","normalizeBoxPlot","discreteAxisFieldDef","continuousAxisChannelDef","discreteAxis","continuousAxis","outerSpec","nonPositionEncoding","nonPositionEncodingWithoutSize","nonPositionEncodingWithoutColorSize","midTickAndBarSizeChannelDef","box","isDiscrete","BOXPLOT","baseContinuousFieldDef","minFieldDef","minWithAxisFieldDef","q1FieldDef","medianFieldDef","q3FieldDef","maxFieldDef","discreteAxisEncodingMixin","_e","normalizeErrorBar","encodingWithoutSize","encodingWithoutX2Y2","encodingWithoutX_X2_Y_Y2","ERRORBAR","add","normalizer","normalizerRegistry","boxplot_1","errorbar_1","mergeDeep","defaultConfig","defaultCellConfig","defaultFacetCellConfig","defaultFacetConfig","defaultOverlayConfig","countTitle","defaultMarkConfig","defaultBarConfig","defaultTextConfig","defaultTickConfig","boxWhisker","boxMid","overlay","defaultScaleConfig","axisX","axisY","axisLeft","axisRight","axisTop","axisBottom","axisBand","defaultLegendConfig","year","quarter","month","date","day","hours","minutes","seconds","milliseconds","normalizeQuarter","invalidTimeUnit","normalizeMonth","lowerM","toLowerCase","monthIndex","MONTHS","shortM","shortMonthIndex","SHORT_MONTHS","normalizeDay","lowerD","dayIndex","DAYS","shortD","shortDayIndex","SHORT_DAYS","droppedDay","setFullYear","SUNDAY_YEAR","setDate","setMonth","setHours","setMinutes","setSeconds","setMilliseconds","getTime","dateTimeExpr","units","normalizedEncoding","channelDefs","isRanged","fieldDefs","arr","r1","nofn","toUpperCase","fieldDefWithoutAggregate","invalidAggregate","maxbins","fullType","getFullName","newType","emptyOrInvalidFieldType","channelCompatibility","compatible","warning","facetChannelShouldBeDiscrete","COMPATIBLE","in","valueExpr","lower","upper","isSingleTimeUnit","datetime","runLocalLogger","current","LocalLogger","wrap","warns","infos","debugs","markOrFacet","when","original","actual","cannotUseScalePropertyWithNonColor","cannotUseRangePropertyWithFacet","propName","cannotStackRangedMark","cannotStackNonLinearScale","cannotStackNonSummativeAggregate","unitName","dayReplacedWithDate","fullTimeUnit","CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN","CANNOT_USE_RANGE_WITH_POSITION","CANNOT_USE_PADDING_WITH_FACET","isPrimitiveMark","PRIMITIVE_MARK_INDEX","Mark","PRIMITIVE_MARKS","STROKE_CONFIG","FILL_CONFIG","DISCRETE_DOMAIN_INDEX","BIN_SCALES_INDEX","CONTINUOUS_DOMAIN_INDEX","isContinuousToContinuous","CONTINUOUS_TO_CONTINUOUS_INDEX","SEQUENTIAL","THRESHOLD","CONTINUOUS_TO_CONTINUOUS_SCALES","CONTINUOUS_DOMAIN_SCALES","DISCRETE_DOMAIN_SCALES","TIME_SCALE_TYPES","facetSpacing","shapes","SCALE_PROPERTIES","normalizeFacet","normalizeLayer","normalizeRepeat","normalizeConcat","hasRow","hasColumn","normalizeFacetedUnit","normalizeNonFacetUnit","normalizeNonFacet","normalizeNonFacetWithRepeat","subspec","rest","isNonFacetUnitSpecWithPrimitiveMark","normalizeRangedUnit","overlayConfig","overlayWithLine","overlayWithPoint","normalizeOverlay","compositeMark","hasX","hasY","hasX2","hasY2","normalizedSpec","stackProps","overlayEncoding","stackFieldChannel","accumulate","dict","pureFieldDef","fieldDefIndex","isStacked","stackConfig","STACKABLE_MARKS","sc","hasXField","hasYField","xIsAggregate","fieldChannelAggregate","fieldChannelScale","stackOffset","STACK_BY_DEFAULT_MARKS","SINGLE_TIMEUNIT_INDEX","convert","SINGLE_TIMEUNITS","singleUnit","containsTimeUnit","TimeUnit","DAY","YEAR","getFullYear","QUARTER","floor","getMonth","MONTH","DATE","getDate","HOURS","getHours","MINUTES","getMinutes","SECONDS","getSeconds","MILLISECONDS","getMilliseconds","isMultiTimeUnit","MULTI_TIMEUNIT_INDEX","func","dateComponents","hasYear","timeComponents","dateTimeComponents","YEARMONTH","YEARMONTHDATE","YEARMONTHDATEHOURS","YEARMONTHDATEHOURSMINUTES","YEARMONTHDATEHOURSMINUTESSECONDS","MONTHDATE","HOURSMINUTES","HOURSMINUTESSECONDS","MINUTESSECONDS","SECONDSMILLISECONDS","YEARQUARTER","QUARTERMONTH","YEARQUARTERMONTH","MULTI_TIMEUNITS","TIMEUNITS","TOP_LEVEL_PROPERTIES","pick","omit","vega_util_2","excludedItems","arrays","dest","src","src_1","deepMerge_","results","values_1","hasIntersection","_vals","alphanumericS","match","getEncodingMappingError","requiredChannelMap","supportedChannelMap","DEFAULT_REQUIRED_CHANNEL_MAP","DEFAULT_SUPPORTED_CHANNEL_TYPE","requiredChannels","supportedChannels","compile_1","validate"],"mappings":"CAAA,SAAAA,GAAA,GAAA,gBAAAC,UAAA,mBAAAC,QAAAA,OAAAD,QAAAD,QAAA,IAAA,kBAAAG,SAAAA,OAAAC,IAAAD,UAAAH,OAAA,CAAA,GAAAK,EAAAA,GAAA,mBAAAC,QAAAA,OAAA,mBAAAC,QAAAA,OAAA,mBAAAC,MAAAA,KAAAC,KAAAJ,EAAAK,GAAAV,MAAA,WAAA,GAAAG,EAAA,OAAA,SAAAQ,GAAAC,EAAAC,EAAAC,GAAA,QAAAC,GAAAC,EAAAC,GAAA,IAAAJ,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,GAAAE,GAAA,kBAAAC,UAAAA,OAAA,KAAAF,GAAAC,EAAA,MAAAA,GAAAF,GAAA,EAAA,IAAAI,EAAA,MAAAA,GAAAJ,GAAA,EAAA,IAAAhB,GAAA,GAAAqB,OAAA,uBAAAL,EAAA,IAAA,MAAAhB,GAAAsB,KAAA,mBAAAtB,EAAA,GAAAuB,GAAAV,EAAAG,IAAAf,WAAAW,GAAAI,GAAA,GAAAQ,KAAAD,EAAAtB,QAAA,SAAAU,GAAA,GAAAE,GAAAD,EAAAI,GAAA,GAAAL,EAAA,OAAAI,GAAAF,GAAAF,IAAAY,EAAAA,EAAAtB,QAAAU,EAAAC,EAAAC,EAAAC,GAAA,MAAAD,GAAAG,GAAAf,QAAA,IAAA,GAAAmB,GAAA,kBAAAD,UAAAA,QAAAH,EAAA,EAAAA,EAAAF,EAAAW,OAAAT,IAAAD,EAAAD,EAAAE,GAAA,OAAAD,KAAAW,GAAA,SAAAP,EAAAjB,EAAAD,GCAA,GAAA0B,GAAA,mBAAAC,MAAAA,KAAAT,EAAA,UAEAjB,GAAAD,QAAA,SAAA4B,EAAAC,GACAA,IAAAA,MACA,kBAAAA,KAAAA,GAAAC,IAAAD,GACA,IAAAE,GAAAF,EAAAE,OAAA,EACA,iBAAAA,KAAAA,EAAAC,MAAAD,EAAA,GAAAE,KAAA,KACA,IAAAC,GAAA,iBAAAL,GAAAK,QAAAL,EAAAK,OACAC,EAAAN,EAAAM,UAAA,SAAAC,EAAAC,GAAA,MAAAA,IAEAP,EAAAD,EAAAC,KAAA,SAAA/B,GACA,MAAA,UAAAuC,GACA,MAAA,UAAArB,EAAAsB,GACA,GAAAC,IAAAJ,IAAAnB,EAAAoB,MAAAC,EAAArB,IACAwB,GAAAL,IAAAG,EAAAF,MAAAC,EAAAC,GACA,OAAAxC,GAAAyC,EAAAC,MAGAZ,EAAAC,KAEAY,IACA,OAAA,SAAAC,GAAAC,EAAAR,EAAAE,EAAAO,GACA,GAAAC,GAAAf,EAAA,KAAA,GAAAC,OAAAa,EAAA,GAAAZ,KAAAF,GAAA,GACAgB,EAAAhB,EAAA,KAAA,GAQA,IANAO,GAAAA,EAAAU,QAAA,kBAAAV,GAAAU,SACAV,EAAAA,EAAAU,cAKAC,MAFAX,EAAAH,EAAAZ,KAAAqB,EAAAR,EAAAE,IAEA,CAGA,GAAA,gBAAAA,IAAA,OAAAA,EACA,MAAAZ,GAAAiB,UAAAL,EAEA,IAAAY,EAAAZ,GAAA,CAEA,IAAA,GADAa,MACAhC,EAAA,EAAAA,EAAAmB,EAAAd,OAAAL,IAAA,CACA,GAAAiC,GAAAT,EAAAL,EAAAnB,EAAAmB,EAAAnB,GAAA0B,EAAA,IAAAnB,EAAAiB,UAAA,KACAQ,GAAAE,KAAAP,EAAAf,EAAAqB,GAEA,MAAA,IAAAD,EAAAlB,KAAA,KAAAa,EAAA,IAGA,IAAA,IAAAJ,EAAAY,QAAAhB,GAAA,CACA,GAAAJ,EAAA,MAAAR,GAAAiB,UAAA,YACA,MAAA,IAAAY,WAAA,yCAEAb,EAAAW,KAAAf,EAIA,KAAA,GAFAkB,GAAAC,EAAAnB,GAAAoB,KAAA5B,GAAAA,EAAAQ,IACAa,KACAhC,EAAA,EAAAA,EAAAqC,EAAAhC,OAAAL,IAAA,CACA,GAAAiB,GAAAoB,EAAArC,GACAkB,EAAAM,EAAAL,EAAAF,EAAAE,EAAAF,GAAAS,EAAA,EAEA,IAAAR,EAAA,CAEA,GAAAsB,GAAAjC,EAAAiB,UAAAP,GACAW,EACAV,CAEAc,GAAAE,KAAAP,EAAAf,EAAA4B,IAGA,MADAjB,GAAAkB,OAAAlB,EAAAY,QAAAhB,GAAA,GACA,IAAAa,EAAAlB,KAAA,KAAAa,EAAA,OAEAe,GAAAjC,GAAA,GAAAA,EAAA,GAGA,IAAAsB,GAAAlB,MAAAkB,SAAA,SAAAY,GACA,MAAA,sBAAAC,SAAAxC,KAAAuC,IAGAL,EAAAO,OAAAR,MAAA,SAAA5B,GACA,GAAAqC,GAAAD,OAAAE,UAAAC,gBAAA,WAAA,OAAA,GACAX,IACA,KAAA,GAAApB,KAAAR,GACAqC,EAAA1C,KAAAK,EAAAQ,IAAAoB,EAAAH,KAAAjB,EAEA,OAAAoB,qCClFAxD,EAAAoE,MAAAlD,EAAA,eACAlB,EAAA2C,UAAAzB,EAAA,8ECDA,GAAAmD,GACAC,EAWAC,EA4IAlC,EAtJAmC,GACAC,IAAA,IACAC,KAAA,KACAC,IAAA,IACApC,EAAA,KACAxC,EAAA,KACAa,EAAA,KACAC,EAAA,KACAF,EAAA,MAIAiE,EAAA,SAAAC,GAEA,MACAC,KAAA,cACAC,QAAAF,EACAR,GAAAA,EACAE,KAAAA,IAIAS,EAAA,SAAAC,GAWA,MATAA,IAAAA,IAAAX,GACAM,EAAA,aAAAK,EAAA,iBAAAX,EAAA,KAMAA,EAAAC,EAAAW,OAAAb,GACAA,GAAA,EACAC,GAGAa,EAAA,WAEA,GAAAA,GACAC,EAAA,EAMA,KAJA,MAAAd,IACAc,EAAA,IACAJ,EAAA,MAEAV,GAAA,KAAAA,GAAA,KACAc,GAAAd,EACAU,GAEA,IAAA,MAAAV,EAEA,IADAc,GAAA,IACAJ,KAAAV,GAAA,KAAAA,GAAA,KACAc,GAAAd,CAGA,IAAA,MAAAA,GAAA,MAAAA,EAOA,IANAc,GAAAd,EACAU,IACA,MAAAV,GAAA,MAAAA,IACAc,GAAAd,EACAU,KAEAV,GAAA,KAAAA,GAAA,KACAc,GAAAd,EACAU,GAIA,IADAG,GAAAC,EACAC,SAAAF,GAGA,MAAAA,EAFAP,GAAA,eAMAQ,EAAA,WAEA,GAAAE,GACAnE,EAEAoE,EADAH,EAAA,EAIA,IAAA,MAAAd,EACA,KAAAU,KAAA,CACA,GAAA,MAAAV,EAEA,MADAU,KACAI,CACA,IAAA,OAAAd,EAEA,GADAU,IACA,MAAAV,EAAA,CAEA,IADAiB,EAAA,EACApE,EAAA,EAAAA,EAAA,IACAmE,EAAAE,SAAAR,IAAA,IACAK,SAAAC,IAFAnE,GAAA,EAKAoE,EAAA,GAAAA,EAAAD,CAEAF,IAAAK,OAAAC,aAAAH,OACA,CAAA,GAAA,gBAAAf,GAAAF,GAGA,KAFAc,IAAAZ,EAAAF,OAKAc,IAAAd,EAIAM,EAAA,eAGAe,EAAA,WAIA,KAAArB,GAAAA,GAAA,KACAU,KAIAY,EAAA,WAIA,OAAAtB,GACA,IAAA,IAKA,MAJAU,GAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,MACA,CACA,KAAA,IAMA,MALAA,GAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,MACA,CACA,KAAA,IAKA,MAJAA,GAAA,KACAA,EAAA,KACAA,EAAA,KACAA,EAAA,KACA,KAEAJ,EAAA,eAAAN,EAAA,MAKAuB,EAAA,WAIA,GAAAA,KAEA,IAAA,MAAAvB,EAAA,CAGA,GAFAU,EAAA,KACAW,IACA,MAAArB,EAEA,MADAU,GAAA,KACAa,CAEA,MAAAvB,GAAA,CAGA,GAFAuB,EAAAxC,KAAAhB,KACAsD,IACA,MAAArB,EAEA,MADAU,GAAA,KACAa,CAEAb,GAAA,KACAW,KAGAf,EAAA,cAGAkB,EAAA,WAIA,GAAA1D,GACA0D,IAEA,IAAA,MAAAxB,EAAA,CAGA,GAFAU,EAAA,KACAW,IACA,MAAArB,EAEA,MADAU,GAAA,KACAc,CAEA,MAAAxB,GAAA,CASA,GARAlC,EAAAgD,IACAO,IACAX,EAAA,KACAhB,OAAAG,eAAA5C,KAAAuE,EAAA1D,IACAwC,EAAA,kBAAAxC,EAAA,KAEA0D,EAAA1D,GAAAC,IACAsD,IACA,MAAArB,EAEA,MADAU,GAAA,KACAc,CAEAd,GAAA,KACAW,KAGAf,EAAA,cAGAvC,GAAA,WAMA,OADAsD,IACArB,GACA,IAAA,IACA,MAAAwB,IACA,KAAA,IACA,MAAAD,IACA,KAAA,IACA,MAAAT,IACA,KAAA,IACA,MAAAD,IACA,SACA,MAAAb,IAAA,KAAAA,GAAA,IAAAa,IAAAS,MAOA3F,EAAAD,QAAA,SAAA+F,EAAAC,GACA,GAAAC,EAiBA,OAfA1B,GAAAwB,EACA1B,EAAA,EACAC,EAAA,IACA2B,EAAA5D,IACAsD,IACArB,GACAM,EAAA,gBASA,kBAAAoB,GAAA,QAAAE,GAAAC,EAAA/D,GACA,GAAAgE,GAAAC,EAAAhE,EAAA8D,EAAA/D,EACA,IAAAC,GAAA,gBAAAA,GACA,IAAA+D,IAAA/D,GACA2B,OAAAE,UAAAC,eAAA5C,KAAAc,EAAA+D,KACAC,EAAAH,EAAA7D,EAAA+D,OACAnD,KAAAoD,EACAhE,EAAA+D,GAAAC,QAEAhE,GAAA+D,GAKA,OAAAJ,GAAAzE,KAAA4E,EAAA/D,EAAAC,KACAwB,GAAAoC,GAAA,IAAAA,2BChQA,QAAAK,GAAAlB,GAOA,MADAmB,GAAAC,UAAA,EACAD,EAAAE,KAAArB,GAAA,IAAAA,EAAAsB,QAAAH,EAAA,SAAAtF,GACA,GAAAgE,GAAA0B,EAAA1F,EACA,OAAA,gBAAAgE,GAAAA,EACA,OAAA,OAAAhE,EAAA2F,WAAA,GAAA7C,SAAA,KAAA8C,OAAA,KACA,IAAA,IAAAzB,EAAA,IAGA,QAAA0B,GAAA1E,EAAA+D,GAEA,GAAAhF,GACAiF,EACAC,EACA7E,EAEAuF,EADAC,EAAAC,EAEA5E,EAAA8D,EAAA/D,EAeA,QAZAC,GAAA,gBAAAA,IACA,kBAAAA,GAAAW,SACAX,EAAAA,EAAAW,OAAAZ,IAKA,kBAAA8E,KACA7E,EAAA6E,EAAA3F,KAAA4E,EAAA/D,EAAAC,UAIAA,IACA,IAAA,SACA,MAAAiE,GAAAjE,EAEA,KAAA,SAEA,MAAAgD,UAAAhD,GAAAoD,OAAApD,GAAA,MAEA,KAAA,UACA,IAAA,OAIA,MAAAoD,QAAApD,EAEA,KAAA,SACA,IAAAA,EAAA,MAAA,MAKA,IAJA4E,GAAAnE,EACAiE,KAGA,mBAAA/C,OAAAE,UAAAH,SAAAoD,MAAA9E,GAAA,CAEA,IADAb,EAAAa,EAAAb,OACAL,EAAA,EAAAA,EAAAK,EAAAL,GAAA,EACA4F,EAAA5F,GAAA2F,EAAA3F,EAAAkB,IAAA,MASA,OAJAgE,GAAA,IAAAU,EAAAvF,OAAA,KAAAyF,EACA,MAAAA,EAAAF,EAAA9E,KAAA,MAAAgF,GAAA,KAAAD,EAAA,IACA,IAAAD,EAAA9E,KAAA,KAAA,IACAgF,EAAAD,EACAX,EAKA,GAAAa,GAAA,gBAAAA,GAEA,IADA1F,EAAA0F,EAAA1F,OACAL,EAAA,EAAAA,EAAAK,EAAAL,GAAA,EAEA,iBADAiF,EAAAc,EAAA/F,MAEAkF,EAAAS,EAAAV,EAAA/D,KAEA0E,EAAA1D,KAAAiD,EAAAF,IAAAa,EAAA,KAAA,KAAAZ,OAOA,KAAAD,IAAA/D,GACA2B,OAAAE,UAAAC,eAAA5C,KAAAc,EAAA+D,KACAC,EAAAS,EAAAV,EAAA/D,KAEA0E,EAAA1D,KAAAiD,EAAAF,IAAAa,EAAA,KAAA,KAAAZ,EAaA,OAJAA,GAAA,IAAAU,EAAAvF,OAAA,KAAAyF,EACA,MAAAA,EAAAF,EAAA9E,KAAA,MAAAgF,GAAA,KAAAD,EAAA,IACA,IAAAD,EAAA9E,KAAA,KAAA,IACAgF,EAAAD,EACAX,GAzHA,GAEAY,GACAnE,EAUAoE,EAZAX,EAAA,2HAGAI,GACAS,KAAA,MACAC,KAAA,MACAC,KAAA,MACAC,KAAA,MACAC,KAAA,MACA/C,IAAA,MACAC,KAAA,OAkHAzE,GAAAD,QAAA,SAAAqC,EAAAF,EAAAJ,GACA,GAAAZ,EAMA,IALA8F,EAAA,GACAnE,EAAA,GAIA,gBAAAf,GACA,IAAAZ,EAAA,EAAAA,EAAAY,EAAAZ,GAAA,EACA2B,GAAA,QAIA,gBAAAf,KACAe,EAAAf,EAMA,IADAmF,EAAA/E,EACAA,GAAA,kBAAAA,KACA,gBAAAA,IAAA,gBAAAA,GAAAX,QACA,KAAA,IAAAJ,OAAA,iBAKA,OAAA0F,GAAA,IAAAjD,GAAAxB,0CCzIA,GAAAoF,GACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GACA,SAAAC,GAWA,QAAAC,GAAAzI,EAAA0I,GACA,MAAA,UAAAC,EAAAtC,GAAA,MAAArG,GAAA2I,GAAAD,EAAAA,EAAAC,EAAAtC,GAAAA,GAXA,GAAAuC,GAAA,gBAAAtI,GAAAA,EAAA,gBAAAC,MAAAA,KAAA,gBAAAC,MAAAA,OACA,mBAAAN,IAAAA,EAAAC,IACAD,EAAA,SAAA,WAAA,SAAAF,GAAAwI,EAAAC,EAAAG,EAAAH,EAAAzI,OAGAwI,EADA,gBAAAvI,IAAA,gBAAAA,GAAAD,QACAyI,EAAAG,EAAAH,EAAAxI,EAAAD,UAGAyI,EAAAG,KAMA,SAAAC,GACA,GAAAC,GAAA9E,OAAA+E,iBACAC,uBAAAhH,QAAA,SAAAiH,EAAA1G,GAAA0G,EAAAD,UAAAzG,IACA,SAAA0G,EAAA1G,GAAA,IAAA,GAAA2G,KAAA3G,GAAAA,EAAA4B,eAAA+E,KAAAD,EAAAC,GAAA3G,EAAA2G,IAEAzB,GAAA,SAAAwB,EAAA1G,GAEA,QAAA4G,KAAA3I,KAAA4I,YAAAH,EADAH,EAAAG,EAAA1G,GAEA0G,EAAA/E,UAAA,OAAA3B,EAAAyB,OAAAqF,OAAA9G,IAAA4G,EAAAjF,UAAA3B,EAAA2B,UAAA,GAAAiF,KAGAzB,EAAA1D,OAAAsF,QAAA,SAAA3I,GACA,IAAA,GAAAG,GAAAK,EAAA,EAAAP,EAAA2I,UAAA/H,OAAAL,EAAAP,EAAAO,IAAA,CACAL,EAAAyI,UAAApI,EACA,KAAA,GAAA+H,KAAApI,GAAAkD,OAAAE,UAAAC,eAAA5C,KAAAT,EAAAoI,KAAAvI,EAAAuI,GAAApI,EAAAoI,IAEA,MAAAvI,IAGAgH,EAAA,SAAA7G,EAAAJ,GACA,GAAAC,KACA,KAAA,GAAAuI,KAAApI,GAAAkD,OAAAE,UAAAC,eAAA5C,KAAAT,EAAAoI,IAAAxI,EAAA4C,QAAA4F,GAAA,IACAvI,EAAAuI,GAAApI,EAAAoI,GACA,IAAA,MAAApI,GAAA,kBAAAkD,QAAAwF,sBACA,IAAA,GAAArI,GAAA,EAAA+H,EAAAlF,OAAAwF,sBAAA1I,GAAAK,EAAA+H,EAAA1H,OAAAL,IAAAT,EAAA4C,QAAA4F,EAAA/H,IAAA,IACAR,EAAAuI,EAAA/H,IAAAL,EAAAoI,EAAA/H,IACA,OAAAR,IAGAiH,EAAA,SAAA6B,EAAAC,EAAAtH,EAAAuH,GACA,GAAAV,GAAAhE,EAAAsE,UAAA/H,OAAAX,EAAAoE,EAAA,EAAAyE,EAAA,OAAAC,EAAAA,EAAA3F,OAAA4F,yBAAAF,EAAAtH,GAAAuH,CACA,IAAA,gBAAAE,UAAA,kBAAAA,SAAAC,SAAAjJ,EAAAgJ,QAAAC,SAAAL,EAAAC,EAAAtH,EAAAuH,OACA,KAAA,GAAAxI,GAAAsI,EAAAjI,OAAA,EAAAL,GAAA,EAAAA,KAAA8H,EAAAQ,EAAAtI,MAAAN,GAAAoE,EAAA,EAAAgE,EAAApI,GAAAoE,EAAA,EAAAgE,EAAAS,EAAAtH,EAAAvB,GAAAoI,EAAAS,EAAAtH,KAAAvB,EACA,OAAAoE,GAAA,GAAApE,GAAAmD,OAAA+F,eAAAL,EAAAtH,EAAAvB,GAAAA,GAGAgH,EAAA,SAAAmC,EAAAC,GACA,MAAA,UAAAP,EAAAtH,GAAA6H,EAAAP,EAAAtH,EAAA4H,KAGAlC,EAAA,SAAAoC,EAAAC,GACA,GAAA,gBAAAN,UAAA,kBAAAA,SAAAO,SAAA,MAAAP,SAAAO,SAAAF,EAAAC,IAGApC,EAAA,SAAAsC,EAAAC,EAAAC,EAAAC,GACA,MAAA,KAAAD,IAAAA,EAAAE,UAAA,SAAAC,EAAAC,GACA,QAAAC,GAAAvI,GAAA,IAAAwI,EAAAL,EAAAxF,KAAA3C,IAAA,MAAA3B,GAAAiK,EAAAjK,IACA,QAAAoK,GAAAzI,GAAA,IAAAwI,EAAAL,EAAA,MAAAnI,IAAA,MAAA3B,GAAAiK,EAAAjK,IACA,QAAAmK,GAAA5E,GAAAA,EAAA8E,KAAAL,EAAAzE,EAAA5D,OAAA,GAAAkI,GAAA,SAAAG,GAAAA,EAAAzE,EAAA5D,SAAA2I,KAAAJ,EAAAE,GACAD,GAAAL,EAAAA,EAAArD,MAAAkD,EAAAC,QAAAtF,WAIAgD,EAAA,SAAAqC,EAAAY,GAGA,QAAAC,GAAAtK,GAAA,MAAA,UAAAyF,GAAA,MAAAwE,IAAAjK,EAAAyF,KACA,QAAAwE,GAAAM,GACA,GAAApL,EAAA,KAAA,IAAAwD,WAAA,kCACA,MAAA6H,GAAA,IACA,GAAArL,EAAA,EAAAsL,IAAA1K,EAAA0K,EAAA,EAAAF,EAAA,GAAA,SAAAA,EAAA,GAAA,QAAA,YAAAxK,EAAAA,EAAAY,KAAA8J,EAAAF,EAAA,KAAAJ,KAAA,MAAApK,EAEA,QADA0K,EAAA,EAAA1K,IAAAwK,GAAA,EAAAxK,EAAA0B,QACA8I,EAAA,IACA,IAAA,GAAA,IAAA,GAAAxK,EAAAwK,CAAA,MACA,KAAA,GAAA,MAAAC,GAAAE,SAAAjJ,MAAA8I,EAAA,GAAAJ,MAAA,EACA,KAAA,GAAAK,EAAAE,QAAAD,EAAAF,EAAA,GAAAA,GAAA,EAAA,SACA,KAAA,GAAAA,EAAAC,EAAAG,IAAAC,MAAAJ,EAAAK,KAAAD,KAAA,SACA,SACA,GAAA7K,EAAAyK,EAAAK,OAAA9K,EAAAA,EAAAa,OAAA,GAAAb,EAAAA,EAAAa,OAAA,MAAA,IAAA2J,EAAA,IAAA,IAAAA,EAAA,IAAA,CAAAC,EAAA,CAAA,UACA,GAAA,IAAAD,EAAA,MAAAxK,GAAAwK,EAAA,GAAAxK,EAAA,IAAAwK,EAAA,GAAAxK,EAAA,IAAA,CAAAyK,EAAAE,MAAAH,EAAA,EAAA,OACA,GAAA,IAAAA,EAAA,IAAAC,EAAAE,MAAA3K,EAAA,GAAA,CAAAyK,EAAAE,MAAA3K,EAAA,GAAAA,EAAAwK,CAAA,OACA,GAAAxK,GAAAyK,EAAAE,MAAA3K,EAAA,GAAA,CAAAyK,EAAAE,MAAA3K,EAAA,GAAAyK,EAAAG,IAAAlI,KAAA8H,EAAA,OACAxK,EAAA,IAAAyK,EAAAG,IAAAC,MACAJ,EAAAK,KAAAD,KAAA,UAEAL,EAAAF,EAAA1J,KAAA8I,EAAAe,GACA,MAAA1K,GAAAyK,GAAA,EAAAzK,GAAA2K,EAAA,EAAA,QAAAtL,EAAAY,EAAA,EACA,GAAA,EAAAwK,EAAA,GAAA,KAAAA,GAAA,EAAA,QAAA9I,MAAA8I,EAAA,GAAAA,EAAA,OAAA,GAAAJ,MAAA,GAvBA,GAAAhL,GAAAsL,EAAA1K,EAAAP,EAAAgL,GAAAE,MAAA,EAAAI,KAAA,WAAA,GAAA,EAAA/K,EAAA,GAAA,KAAAA,GAAA,EAAA,OAAAA,GAAA,IAAA8K,QAAAF,OACA,OAAAnL,IAAA4E,KAAAkG,EAAA,GAAAS,MAAAT,EAAA,GAAAU,OAAAV,EAAA,IAAA,kBAAAW,UAAAzL,EAAAyL,OAAAC,UAAA,WAAA,MAAAtL,QAAAJ,GA0BA6H,EAAA,SAAApD,EAAA7E,GACA,IAAA,GAAAkJ,KAAArE,GAAA7E,EAAAmE,eAAA+E,KAAAlJ,EAAAkJ,GAAArE,EAAAqE,KAGAhB,EAAA,SAAAnH,GACA,GAAA8D,GAAA,kBAAAgH,SAAA9K,EAAA8K,OAAAC,UAAA3K,EAAA,CACA,OAAA0D,GAAAA,EAAAtD,KAAAR,IAEAiE,KAAA,WAEA,MADAjE,IAAAI,GAAAJ,EAAAS,SAAAT,MAAA,KACAsB,MAAAtB,GAAAA,EAAAI,KAAA4J,MAAAhK,MAKAoH,EAAA,SAAApH,EAAAH,GACA,GAAAiE,GAAA,kBAAAgH,SAAA9K,EAAA8K,OAAAC,SACA,KAAAjH,EAAA,MAAA9D,EACA,IAAAF,GAAAH,EAAAS,EAAA0D,EAAAtD,KAAAR,GAAAgL,IACA,KACA,UAAA,KAAAnL,GAAAA,KAAA,MAAAC,EAAAM,EAAA6D,QAAA+F,MAAAgB,EAAA1I,KAAAxC,EAAAwB,OAEA,MAAAuC,GAAAlE,GAAAkE,MAAAA,GACA,QACA,IACA/D,IAAAA,EAAAkK,OAAAlG,EAAA1D,EAAA,SAAA0D,EAAAtD,KAAAJ,GAEA,QAAA,GAAAT,EAAA,KAAAA,GAAAkE,OAEA,MAAAmH,IAGA3D,EAAA,WACA,IAAA,GAAA2D,MAAA5K,EAAA,EAAAA,EAAAoI,UAAA/H,OAAAL,IACA4K,EAAAA,EAAAC,OAAA7D,EAAAoB,UAAApI,IACA,OAAA4K,IAGA1D,EAAA,SAAAgC,EAAAC,EAAAE,GAIA,QAAAU,GAAAtK,GAAA,MAAA,UAAAyF,GAAA,MAAA,IAAAoE,SAAA,SAAAxJ,EAAAsB,GAAA0J,EAAA5I,MAAAzC,EAAAyF,EAAApF,EAAAsB,IAAAyC,OACA,QAAAA,MAAAC,GAAAgH,EAAAzK,QAAA0K,GAAAjH,EAAAgH,EAAAE,SAAA,GAAAlH,EAAA,IACA,QAAAiH,GAAAtL,EAAAyF,GAAA,IAAAwE,EAAAzK,EAAAQ,GAAAyF,IAAA,MAAA3F,GAAA0L,EAAAnH,EAAA,GAAAvE,IACA,QAAAmK,GAAAhK,GAAAA,EAAAkK,KAAAqB,EAAAnH,EAAA,GAAApE,GAAA4J,QAAAC,QAAA7J,EAAAwB,MAAA,IAAA2I,KAAA,UAAAnK,EAAAwB,MAAA,GAAAgK,EAAAC,EAAA3B,GACA,QAAA0B,GAAAhK,GAAA+J,EAAAnH,EAAA,IAAA5C,MAAAA,EAAA0I,MAAA,IACA,QAAAuB,GAAAjK,GAAA6J,EAAA,OAAA7J,GACA,QAAAsI,GAAAtI,GAAA6J,EAAA,QAAA7J,GACA,QAAA+J,GAAArM,EAAAsG,GAAApB,MAAA,GAAAlF,EAAAsG,GAAArB,IAVA,IAAA6G,OAAAU,cAAA,KAAA,IAAAhJ,WAAA,uCACA,IAAA0B,GAAA9D,EAAAf,EAAAoK,EAAArD,MAAAkD,EAAAC,OAAA2B,IACA,OAAA9K,IAAA6D,KAAAkG,EAAA,QAAAS,MAAAT,EAAA,SAAAU,OAAAV,EAAA,WAAA/J,EAAA0K,OAAAU,eAAA,WAAA,MAAA/L,OAAAW,GAWAmH,EAAA,SAAAvH,GAGA,QAAAmK,GAAAtK,EAAAb,GAAA,MAAA,UAAAsG,GAAA,MAAAA,GAAA6C,GAAA,UAAAtI,EAAAb,EAAAsG,GAAA6C,GAAA7C,EAAA0E,KAAA1E,GAAAhE,MAAA6G,GAAA,QAAA7C,EAAAhE,QAAA,SAAAtB,EAAAH,IAAAb,GAAAwB,KAAAR,EAAAsF,IAAA0E,MAAA,GAAA7B,GAAAA,EAAA7C,GAFA,GAAA6C,GAAA/H,GAAA6D,KAAAkG,EAAA,QAAAS,MAAAT,EAAA,QAAA,SAAAxK,GAAA,KAAAA,KAAAkL,OAAAV,EAAA,SAAA,SAAA7E,GAAA,OAAAhE,MAAAgE,EAAA0E,MAAA,KACA,OAAAhK,GAAAwH,EAAAxH,GAAAI,EAAA0K,OAAAC,UAAA,WAAA,MAAAtL,OAAAW,GAIAoH,EAAA,SAAAxH,GACA,IAAA8K,OAAAU,cAAA,KAAA,IAAAhJ,WAAA,uCACA,IAAAsB,GAAA9D,EAAA8K,OAAAU,cACA,OAAA1H,GAAAA,EAAAtD,KAAAR,GAAA,kBAAAmH,GAAAA,EAAAnH,GAAAA,EAAA8K,OAAAC,aAGAjD,EAAA,YAAApB,GACAoB,EAAA,WAAAnB,GACAmB,EAAA,SAAAlB,GACAkB,EAAA,aAAAjB,GACAiB,EAAA,UAAAhB,GACAgB,EAAA,aAAAf,GACAe,EAAA,YAAAd,GACAc,EAAA,cAAAb,GACAa,EAAA,eAAAZ,GACAY,EAAA,WAAAX,GACAW,EAAA,SAAAV,GACAU,EAAA,WAAAT,GACAS,EAAA,mBAAAR,GACAQ,EAAA,mBAAAP,GACAO,EAAA,gBAAAN,gJC5MA,SAAAjI,EAAAkI,GACA,gBAAAxI,QAAA,KAAAC,EAAAuI,EAAAxI,GACA,kBAAAE,IAAAA,EAAAC,IAAAD,GAAA,WAAAsI,GACAA,EAAAlI,EAAAkM,KAAAlM,EAAAkM,WACAhM,KAAA,SAAAR,GAAA,YAwCA,SAAAyM,GAAAC,GACA,MAAAC,GAAAxI,eAAAuI,GAGA,QAAAE,GAAA9L,EAAAK,EAAA0L,EAAAC,EAAAC,GAIA,IAHA,GAEA9H,GAFA+H,EAAA,EACApM,EAAAE,EAAAU,OAEAL,EAAAP,IAAAO,EAAA,CAEA,GADA8D,EAAAnE,EAAAK,IACA6L,GAAA/H,IAAA4H,EAAA,MAAA1L,EACA4L,IAAAA,EAAAzJ,QAAA2B,IAAA,IAAA+H,EACAF,GAAAA,EAAAxJ,QAAA2B,IAAA,KAAA+H,EAEA,MAAA7L,GAGA,QAAA8L,GAAAnM,GAMA,IALA,GAAAoM,MACAC,EAAA,EACAvM,EAAAE,EAAAU,OACAL,EAAA,EAEAA,EAAAP,GACAO,EAAAyL,EAAA9L,EAAAK,EAAAiM,EAAAC,EAAAC,EAAAC,EAAAC,GACAN,EAAA7J,KAAAvC,EAAA2M,UAAAN,EAAAhM,GAAAuM,QACAP,IAAAhM,CAGA,IAAA,IAAA+L,EAAA1L,OACA,KAAA,yBAAAV,CAEA,OAAAoM,GAGA,QAAAS,GAAA7M,GACA,MAAA,MAAAA,EAAA,GACA8M,EAAA9M,GACA+M,EAAA/M,GAGA,QAAA8M,GAAA9M,GACA,GAEAyB,GAAAuL,EAFAlN,EAAAE,EAAAU,OACAL,EAAA,CAIA,KADAA,EAAAyL,EAAA9L,EAAAK,EAAAoM,EAAAF,EAAAE,MACA3M,EACA,KAAA,2BAAAE,CAIA,IADAyB,EAAA0K,EAAAnM,EAAA2M,UAAA,EAAAtM,IACA,IAAAoB,EAAAf,OACA,KAAA,4CAAAV,CAIA,IADAA,EAAAA,EAAA+F,MAAA1F,EAAA,GAAAuM,OACA5M,EAAA,KAAAiN,EACA,KAAA,wCAAAjN,CAMA,OAHAyB,GAAAA,EAAAyL,IAAAL,GAEAG,EAAAH,EAAA7M,EAAA+F,MAAA,GAAA6G,QACAI,EAAAG,SAEAA,QAAA1L,EACAuL,OAAAA,IAGAA,EAAAG,QAAA1L,EAGAuL,GAGA,QAAAD,GAAA/M,GACA,GAMAoN,GACAC,EAPAL,GAAA/H,OAAAqI,GACArI,KACAsI,GAAA,EAAA,GACAC,EAAA,EACAnB,EAAA,EACAvM,EAAAE,EAAAU,OACAL,EAAA,CAIA,IAAAL,EAAAF,EAAA,KAAA4M,EAAA,CAEA,MADArM,EAAAL,EAAAyN,YAAAjB,KACA,GAQA,KAAA,0BAAAxM,CAPA,KACAuN,EAAAG,EAAA1N,EAAA2M,UAAAtM,EAAA,EAAAP,EAAA,IACA,MAAAF,GACA,KAAA,mCAAAI,EAEAA,EAAAA,EAAA+F,MAAA,EAAA1F,GAAAuM,OACA9M,EAAAE,EAAAU,OAEAL,EAAA,EAGA,IAAAP,EAAA,KAAAE,EAcA,IAXAA,EAAA,KAAA2N,IAAAH,IAAAnN,GAGA+M,EAAAtB,EAAA9L,EAAAK,EAAAuN,GACAR,EAAAtN,IACAmF,EAAA1C,KAAAvC,EAAA2M,UAAAN,EAAAe,GAAAR,QACAP,EAAAhM,IAAA+M,IAIA/M,EAAAyL,EAAA9L,EAAAK,EAAAkM,MACAzM,EACAmF,EAAA1C,KAAAvC,EAAA2M,UAAAN,EAAAvM,GAAA8M,YAKA,IAHA3H,EAAA1C,KAAAvC,EAAA2M,UAAAN,EAAAhM,GAAAuM,QACAS,MACAhB,IAAAhM,KACAP,EAAA,KAAA,2BAAAE,CAIA,MAAAK,EAAAP,GAAA,CAEA,IADAO,EAAAyL,EAAA9L,EAAAK,EAAAoM,MACA3M,EAAA,KAAA,2BAAAE,CAEA,IADAqN,EAAA9K,KAAAvC,EAAA2M,UAAAN,EAAAhM,GAAAuM,QACAvM,EAAAP,EAAA,GAAAE,IAAAK,KAAAkM,EAAA,KAAA,0BAAAvM,CACAqM,KAAAhM,EAIA,KAAAP,EAAAmF,EAAAvE,SAAAmN,EAAAlI,KAAAV,EAAAnF,EAAA,IACA,KAAA,2BAAAE,CAuBA,OApBAF,GAAA,GACAkN,EAAApB,KAAA3G,EAAA,GACAuI,EACAR,EAAAQ,SAAAvI,EAAA,GAAAc,MAAA,GACA4F,EAAA1G,EAAA,IACA+H,EAAAc,SAAA7I,EAAA,GAEA+H,EAAA/H,OAAAA,EAAA,IAGA+H,EAAApB,KAAA3G,EAAA,GAEA,MAAA+H,EAAApB,KAAA7F,OAAA,KACAiH,EAAAe,SAAA,EACAf,EAAApB,KAAAoB,EAAApB,KAAA7F,MAAA,GAAA,IAEA,MAAAsH,IAAAL,EAAAK,OAAAA,GACAE,EAAA,KAAAP,EAAAO,SAAAA,EAAA,IACAA,EAAA,KAAAP,EAAAgB,SAAAT,EAAA,IAEAP,EAGA,QAAAU,GAAA1N,GACA,GAAAG,GAAAH,EAAAiO,MAAA3B,EACA,KAAAtM,EAAAU,QAAAP,EAAAO,OAAA,EAAA,KAAAV,EACA,OAAAG,GAAA+M,IAAA,SAAA5C,GACA,GAAAtH,IAAAsH,CACA,IAAAtH,IAAAA,EAAA,KAAAhD,EACA,OAAAgD,KAzMA,GAgBAsK,GACAzB,EAjBAqC,EAAA,SAAAC,EAAAlJ,EAAAmJ,GAGA,MAFAd,GAAArI,GAAAoJ,EACAxC,EAAAuC,GAAAE,EACAnC,EAAAgC,EAAAvB,QAAAM,IAAAL,IAGAwB,EAAA,OACA9B,EAAA,IACAE,EAAA,IACAD,EAAA,IACAE,EAAA,IACAkB,EAAA,IACAtB,EAAA,IACAqB,EAAA,IACAV,EAAA,IACAY,EAAA,aAGAS,GACAC,IAAA,EACAC,IAAA,EACAC,KAAA,EACAC,MAAA,EACAC,MAAA,EACAC,KAAA,EACAC,KAAA,EACAC,KAAA,EACAC,KAAA,EACAC,MAAA,EACAC,OAAA,EACAxL,KAAA,EACAyL,MAAA,EA8KAhQ,GAAAiP,SAAAD,EAEAhL,OAAA+F,eAAA/J,EAAA,cAAAqC,OAAA,+BCzNA,SAAA/B,EAAAkI,GACA,gBAAAxI,QAAA,KAAAC,EAAAuI,EAAAxI,GACA,kBAAAE,IAAAA,EAAAC,IAAAD,GAAA,WAAAsI,GACAA,EAAAlI,EAAAkM,KAAAlM,EAAAkM,WACAhM,KAAA,SAAAR,GAAA,YAUA,SAAAiQ,GAAAC,GACA,MAAA,OAAAA,EAAA,KAAAA,EAAAC,MAGA,QAAAC,GAAAF,GACA,MAAA,OAAAA,EAAA,KAAAA,EAAAG,OA2DA,QAAAC,GAAAxM,GACA,MAAAZ,GAAAY,GAAA,IAAAA,EAAAkK,IAAAsC,GAAA,IACAC,EAAAzM,IAAA0M,EAAA1M,GAGAnC,KAAAgB,UAAAmB,GAAA4C,QAAA,SAAA,WAAAA,QAAA,SAAA,WACA5C,EA4BA,QAAA2M,GAAAC,EAAA7N,EAAA8N,GACA,GAAAC,IAAA/N,GAAAmJ,UAAAnF,MAAAtF,KAAAoP,GACAE,SAAAH,GAAAvJ,MAAA0J,QAAAD,GA5GA,GAAAE,GAAA,SAAAZ,EAAAG,EAAAvL,GACA,MACAoL,GAAAG,OAAAA,MACAH,EAAAC,MAAArL,EACAoL,GAYAtL,EAAA,SAAAG,GACA,KAAA3D,OAAA2D,IAGAgM,EAAA,SAAA7H,GAUA,QAAA7F,KACAsM,EAAAtM,KAAAvC,EAAAoI,EAAAuE,UAAAtM,EAAA+M,IACApN,EAAA,GACAK,EAAA+M,EAAA,EAZA,GAKA/M,GAAA+M,EAAAjJ,EALA0K,KACA1D,EAAA,KACA1J,EAAA,EACA3B,EAAAsI,EAAA1H,OACAV,EAAA,EAWA,KARAoI,GAAA,GAQA/H,EAAA+M,EAAA,EAAAA,EAAAtN,IAAAsN,EAEA,GAAA,QADAjJ,EAAAiE,EAAAgF,IACApN,GAAAoI,EAAAuE,UAAAtM,EAAA+M,GAAA/M,IAAA+M,MACA,IAAAjJ,IAAAgH,EAAA5I,IAAA4I,EAAA,KAAA1J,GAAA,MACA,CAAA,GAAA0J,EAAA,QACA9K,KAAAoB,GAAA,MAAA0C,GAAA9D,EAAA+M,EAAA,EAAAjC,EAAAhH,GACA9D,IAAAoB,GAAA,MAAA0C,GAAA9D,EAAA+M,EAAA,EAAAjC,EAAAhH,GACA,MAAAA,GAAA1C,EACA,MAAA0C,GACAiJ,EAAA/M,GAAAkC,IACAd,EAAApB,EAAA+M,EAAA,GAEA,MAAAjJ,IACA1C,GAAAqC,EAAA,qCAAAsE,GACA3G,EAAA,GAAAc,IACAd,EAAA,EACApB,EAAA+M,EAAA,GATAA,EAAA/M,EAAAkC,IAAAlC,EAAA+M,EAAA,EAgBA,MAHA3L,IAAAqC,EAAA,wCAAAsE,GACA+C,GAAArH,EAAA,sCAAAsE,GACAgF,EAAA/M,MAAA+M,EAAA7K,KACAsM,GAGAzM,EAAAlB,MAAAkB,QAEAqN,EAAA,SAAAnF,GACA,MAAAA,KAAApH,OAAAoH,IAGAoF,EAAA,SAAApF,GACA,MAAA,gBAAAA,IAYA4F,EAAA,SAAAA,EAAAlM,GACA,GAAA6K,GAAAoB,EAAAC,GACA3P,EAAA,YAAAsO,EAAA3B,IAAAsC,GAAArO,KAAA,MAAA,IAEA,OAAA6O,GACAG,SAAA,IAAA5P,IACA2P,EAAA,IAAArB,EAAAnO,OAAAmO,EAAA,GAAAqB,GACAlM,GAAAkM,IAIAE,KAEAvI,EAAAqI,EAAA,MAEAG,EAAAL,EAAA,SAAA1F,GAAA,MAAAA,IAAA8F,EAAA,YAEAE,EAAAN,EAAA,WAAA,MAAA,IAAAI,EAAA,QAEAG,EAAAP,EAAA,WAAA,MAAA,IAAAI,EAAA,OAEAI,EAAAR,EAAA,WAAA,OAAA,GAAAI,EAAA,QAEAK,EAAAT,EAAA,WAAA,OAAA,GAAAI,EAAA,SAYAM,EAAA,SAAApG,GACA,GAAAvI,GAAAuI,GANA,CAOA,QACAvI,MAAA,SAAAuI,GACA,MAAA7B,WAAA/H,QAAAqB,GAAAuI,EAAA5K,MAAAqC,GAEA4O,KAAA,WAEA,MADA5O,IAXA,GAWA4N,EAAA,OAAA,OAAAlH,WACA/I,MAEAkR,KAAA,WAEA,MADA7O,IAdA,GAcA4N,EAAA,MAAA,OAAAlH,WACA/I,MAEAmR,MAAA,WAEA,MADA9O,IAjBA,GAiBA4N,EAAA,MAAA,QAAAlH,WACA/I,QAKAqF,EAAA,SAAAuF,GACA,MAAA,OAAAA,EAAAlI,EAAAkI,GAAAA,GAAAA,OAGAwG,EAAA,SAAAvB,EAAAwB,GACA,GAQA1Q,GAAA+M,EAAAnO,EAAAiB,EAAAqF,EAAA4C,EAAA6I,EAAAC,EARAC,KACAlQ,GAAAuO,EAAAxK,EAAAwK,IAAArC,IAAA,SAAAjO,EAAAoB,GACA,MAAA,OAAApB,EAAA,MACAiS,EAAA3O,KAAAlC,GAAA4P,EAAAhR,GAAAiO,IAAAsC,GAAArO,KAAA,SAEArB,EAAAoR,EAAAxQ,OAAA,EACAyQ,EAAApM,EAAAgM,GACAxQ,EAAA,iBAGA,IAAAT,EAAA,EAAA,MAAA,KAEA,KAAAsN,EAAA,EAAAA,GAAAtN,IAAAsN,EACA/M,EAAA6Q,EAAA9D,GACAnO,EAAA+B,EAAAX,GACAH,EAAA,QAAAjB,EAAA,KACAsG,EAAA,QAAAtG,EAAA,KACAkJ,EAAA,0DACA6I,EAAA,eAAAG,EAAA9Q,IAAA4Q,EAAA,GAAA,IAAAA,GAAA,EAAA,GACA1Q,GAAA,IAAAL,EAAA,IAAAqF,EAAA,uBAAAyL,EACA,4BAAAC,EACA,IAAA9I,EAAA,eAAA6I,EACA,iBAAAC,GACA5Q,EAAAP,EAAA,IAAA,KAGA,OAAAkQ,GACAG,SAAA,IAAA,IAAA5P,EAAA,KACAgP,EAAAlC,OAAA,SAAA/C,GAAA,MAAA,OAAAA,MAIA8G,EAAA,SAAA9G,GACA,MAAA,kBAAAA,IAGA+G,EAAA,SAAA/G,GACA,MAAA8G,GAAA9G,GAAAA,EAAA,WAAA,MAAAA,KAGAgH,EAAA,SAAAhH,GACA,IAAA,GAAAtH,GAAAsC,EAAAjF,EAAA,EAAAkR,EAAA9I,UAAA/H,OAAAL,EAAAkR,IAAAlR,EAAA,CACA2C,EAAAyF,UAAApI,EACA,KAAAiF,IAAAtC,GAAAsH,EAAAhF,GAAAtC,EAAAsC,GAEA,MAAAgF,IAGAkH,EAAA,SAAAzM,EAAA9F,GACA,GAEAkB,GAAAsB,EAAA0C,EAAAjE,EAAAqF,EAFAlF,GAAA,EACAP,EAAAiF,EAAArE,MAGA,IAAA,MAAAzB,EAAA,CACA,OAAAoB,EAAAP,GAAA,GAAA,OAAA2B,EAAAsD,EAAA1E,KAAAoB,GAAAA,EAAA,CAAAtB,EAAAgE,EAAA1C,CAAA,OAEA,IADAvB,EAAAqF,EAAAlF,IACAA,EAAAP,GAAA,OAAA2B,EAAAsD,EAAA1E,MACAF,EAAAsB,IAAAtB,EAAAsB,EAAAvB,EAAAG,GACA8D,EAAA1C,IAAA0C,EAAA1C,EAAA8D,EAAAlF,QAEA,CACA,OAAAA,EAAAP,GAAA,GAAA,OAAA2B,EAAAxC,EAAA8F,EAAA1E,GAAAA,EAAA0E,KAAAtD,GAAAA,EAAA,CAAAtB,EAAAgE,EAAA1C,CAAA,OAEA,IADAvB,EAAAqF,EAAAlF,IACAA,EAAAP,GAAA,OAAA2B,EAAAxC,EAAA8F,EAAA1E,GAAAA,EAAA0E,MACA5E,EAAAsB,IAAAtB,EAAAsB,EAAAvB,EAAAG,GACA8D,EAAA1C,IAAA0C,EAAA1C,EAAA8D,EAAAlF,IAIA,OAAAH,EAAAqF,IAGAkM,KAEAC,EAAA,SAAA7B,GAKA,QAAA1M,GAAA7B,GACA,MAAAR,GAAAuC,eAAA/B,IAAAR,EAAAQ,KAAAmQ,EALA,GACAvE,GACAvH,EAFA7E,IA4DA,OApDAoM,IACAyE,KAAA,EACAvB,MAAA,EACApL,OAAAlE,EACAqC,IAAAA,EACAyO,IAAA,SAAAtQ,GACA,MAAA6B,GAAA7B,GAAAR,EAAAQ,OAAAa,IAEA0P,IAAA,SAAAvQ,EAAAC,GAMA,MALA4B,GAAA7B,OACA4L,EAAAyE,KACA7Q,EAAAQ,KAAAmQ,KAAAvE,EAAAkD,OAEAtP,EAAAQ,GAAAC,EACA7B,MAEAoS,OAAA,SAAAxQ,GAMA,MALA6B,GAAA7B,OACA4L,EAAAyE,OACAzE,EAAAkD,MACAtP,EAAAQ,GAAAmQ,GAEA/R,MAEAqS,MAAA,WACA7E,EAAAyE,KAAAzE,EAAAkD,MAAA,EACAlD,EAAAlI,OAAAlE,MAEA6E,KAAA,SAAA2E,GACA,MAAA7B,WAAA/H,QAAAiF,EAAA2E,EAAA4C,GAAAvH,GAEAqM,MAAA,WACA,GAEA1Q,GAAAC,EAFA2C,KACAyN,EAAA,CAEA,KAAArQ,IAAAR,IACAS,EAAAT,EAAAQ,MACAmQ,GAAA9L,GAAAA,EAAApE,KACA2C,EAAA5C,GAAAC,IACAoQ,EAGAzE,GAAAyE,KAAAA,EACAzE,EAAAkD,MAAA,EACAlD,EAAAlI,OAAAlE,EAAAoD,IAIA2L,GAAA3M,OAAAR,KAAAmN,GAAAoC,QAAA,SAAA3Q,GACA4L,EAAA2E,IAAAvQ,EAAAuO,EAAAvO,MAGA4L,GAGAgF,EAAA,SAAAC,EAAArQ,GACA,GAAAsQ,GAAAD,EAAA/O,UAAAF,OAAAqF,OAAAzG,EAAAsB,UAEA,OADAgP,GAAA9J,YAAA6J,EACAC,GAGAC,EAAA,SAAA/H,GACA,MAAA,iBAAAA,IAGAgI,EAAA,SAAAhI,GACA,MAAA,kBAAApH,OAAAE,UAAAH,SAAAxC,KAAA6J,IAGAiI,EAAA,SAAAjI,GACA,MAAA,gBAAAA,IAGAkI,EAAA,SAAAlI,GACA,MAAA,oBAAApH,OAAAE,UAAAH,SAAAxC,KAAA6J,IAGAhJ,EAAA,SAAAiO,GACAA,EAAAA,EAAAxK,EAAAwK,GAAAA,CACA,IAAAH,GAAAG,GAAAA,EAAA7O,OAEAyP,SAAA,IAAA,aACAZ,EAAArC,IAAA,SAAAjO,GACA,MAAA,KAAAgR,EAAAhR,GAAAiO,IAAAsC,GAAArO,KAAA,MAAA,MACAA,KAAA,SAAA,KAJA,WAAA,MAAA,GAKA,OAAA6O,GAAAZ,EAAAG,EAAA,QAGAkD,EAAA,SAAA3B,EAAA4B,EAAAC,EAAAvG,GACA,GAAAwG,GAAAF,EAAAhS,OACAmS,EAAAF,EAAAjS,MAEA,KAAAmS,EAAA,MAAAH,EACA,KAAAE,EAAA,MAAAD,EAKA,KAHA,GAAAG,GAAA1G,GAAA,GAAAsG,GAAApK,YAAAsK,EAAAC,GACAE,EAAA,EAAAC,EAAA,EAAA3S,EAAA,EAEA0S,EAAAH,GAAAI,EAAAH,IAAAxS,EACAyS,EAAAzS,GAAAyQ,EAAA4B,EAAAK,GAAAJ,EAAAK,IAAA,EACAL,EAAAK,KACAN,EAAAK,IAGA,MAAAA,EAAAH,IAAAG,IAAA1S,EACAyS,EAAAzS,GAAAqS,EAAAK,EAGA,MAAAC,EAAAH,IAAAG,IAAA3S,EACAyS,EAAAzS,GAAAsS,EAAAK,EAGA,OAAAF,IAGAG,EAAA,SAAAjN,EAAAkN,GAEA,IADA,GAAAlT,GAAA,KACAkT,GAAA,GAAAlT,GAAAgG,CACA,OAAAhG,IAGAmT,EAAA,SAAAnN,EAAAtF,EAAA0S,EAAAC,GACA,GAAAlP,GAAAiP,GAAA,IACApT,EAAAgG,EAAA,GACAlG,EAAAY,EAAAV,EAAAU,MAEA,OAAAZ,IAAA,EAAAE,EACA,SAAAqT,EAAAJ,EAAA9O,EAAArE,GAAAE,EACA,WAAAqT,EAAAJ,EAAA9O,KAAArE,EAAA,IAAAE,EAAAiT,EAAA9O,EAAAmP,KAAAC,KAAAzT,EAAA,IACAE,EAAAiT,EAAA9O,EAAArE,IAGA0T,EAAA,SAAAzO,GACA,MAAAA,GAAAA,EAAArE,OAAA,IAGA+S,EAAA,SAAAnJ,GACA,MAAA,OAAAA,GAAA,KAAAA,EAAA,QAAAA,GAAA,UAAAA,MAAAA,GAGAoJ,EAAA,SAAApJ,EAAAqJ,GACA,MAAA,OAAArJ,GAAA,KAAAA,EAAA,KAAAqJ,EAAAA,EAAArJ,GAAAsJ,KAAAtQ,MAAAgH,IAGAuJ,EAAA,SAAAvJ,GACA,MAAA,OAAAA,GAAA,KAAAA,EAAA,MAAAA,GAGArH,EAAA,SAAAqH,GACA,MAAA,OAAAA,GAAA,KAAAA,EAAA,KAAAA,EAAA,IAGAwJ,EAAA,SAAAxJ,GACA,IAAA,GAAAtK,MAAAK,EAAA,EAAAP,EAAAwK,EAAA5J,OAAAL,EAAAP,IAAAO,EAAAL,EAAAsK,EAAAjK,IAAA,CACA,OAAAL,IAGA+T,EAAA,SAAA/N,EAAAtF,EAAA2S,EAAAW,GACA,GAAApU,GAAA,MAAAoU,EAAAA,EAAA,IACAhU,EAAAgG,EAAA,GACAlG,EAAAE,EAAAU,OACAF,EAAA8S,KAAAW,IAAA,EAAAvT,EAAAd,EAAAc,OAEA,OAAAZ,IAAAY,EAAAV,EACA,SAAAqT,EAAAzT,EAAAI,EAAA+F,MAAAjG,EAAAU,GACA,WAAA6S,EAAArT,EAAA+F,MAAA,EAAAuN,KAAAC,KAAA/S,EAAA,IAAAZ,EAAAI,EAAA+F,MAAAjG,KAAAU,EAAA,IACAR,EAAA+F,MAAA,EAAAvF,GAAAZ,GAGAsU,EAAA,SAAAnP,EAAAsI,EAAA8G,GACA,GAAApP,EAAA,CACA,GAAAlF,GAAAQ,EAAA,EAAAP,EAAAiF,EAAArE,MACA,IAAA2M,EACA,KAAAhN,EAAAP,IAAAO,GACAR,EAAAwN,EAAAtI,EAAA1E,MAAA8T,EAAAtU,EAAAQ,EAAA0E,OAGAA,GAAAkN,QAAAkC,IAKAjV,GAAA8Q,SAAAA,EACA9Q,EAAAiQ,aAAAA,EACAjQ,EAAAoQ,eAAAA,EACApQ,EAAA2I,GAAAA,EACA3I,EAAAmR,SAAAA,EACAnR,EAAAoR,KAAAA,EACApR,EAAAqR,IAAAA,EACArR,EAAAsR,OAAAA,EACAtR,EAAAuR,MAAAA,EACAvR,EAAAwR,OAAAA,EACAxR,EAAAkV,KAlTA,EAmTAlV,EAAAmV,KAlTA,EAmTAnV,EAAAoV,KAlTA,EAmTApV,EAAAqV,MAlTA,EAmTArV,EAAA6F,MAAAA,EACA7F,EAAA4R,QAAAA,EACA5R,EAAAmS,SAAAA,EACAnS,EAAA4E,MAAAA,EACA5E,EAAAoS,OAAAA,EACApS,EAAAsS,YAAAA,EACAtS,EAAAwS,QAAAA,EACAxS,EAAAgR,MAAAA,EACAhR,EAAAgT,SAAAA,EACAhT,EAAAkD,QAAAA,EACAlD,EAAAmT,UAAAA,EACAnT,EAAAoT,OAAAA,EACApT,EAAAkS,WAAAA,EACAlS,EAAAqT,SAAAA,EACArT,EAAAuQ,SAAAA,EACAvQ,EAAAsT,SAAAA,EACAtT,EAAAwQ,SAAAA,EACAxQ,EAAAoC,IAAAA,EACApC,EAAAuT,MAAAA,EACAvT,EAAAiU,IAAAA,EACAjU,EAAAsU,KAAAA,EACAtU,EAAA+T,OAAAA,EACA/T,EAAA+Q,gBAAAA,EACA/Q,EAAAsV,YAAAhF,EACAtQ,EAAAuU,UAAAA,EACAvU,EAAAwU,OAAAA,EACAxU,EAAA2U,SAAAA,EACA3U,EAAA+D,SAAAA,EACA/D,EAAA4U,MAAAA,EACA5U,EAAA6U,SAAAA,EACA7U,EAAAgV,WAAAA,EAEAhR,OAAA+F,eAAA/J,EAAA,cAAAqC,OAAA,8BC3cApC,EAAAD,SACA8E,KAAA,YACAyQ,OAAA,2DACAC,QAAA,gBACAC,eACA,yEACA,wEACA,kDAEAC,SAAA,oCACAC,YAAA,+IACAC,KAAA,kBACAC,MAAA,oBACAC,KACAC,OAAA,eACAC,OAAA,eACAC,MAAA,eAEAC,aACAzP,KAAA,QAEA0P,SACAC,IAAA,2BACAC,SAAA,+DACAC,MAAA,wIACAC,UAAA,4JACAC,iBAAA,8BACAC,eAAA,6CACAC,YAAA,sDACAC,aAAA,8HACAC,iBAAA,4BACAC,qBAAA,6FACAC,iBAAA,4BACAC,eAAA,0BACAjE,MAAA,kIACAkE,KAAA,kDACAC,KAAA,iCAEAC,OAAA,oBACAC,YAAA,uBACAC,gBAAA,2BAEAC,SAAA,0DACAlK,MAAA,+IACAmK,UAAA,gCAEAC,UAAA,mBACAC,OAAA,mOACAC,cAAA,qPACAC,QAAA,qGACAC,KAAA,2BAEAC,KAAA,6DACAnR,KAAA,mDACAoR,SAAA,2DACAC,iBAAA,8DACAC,YAAA,iEACAC,aAAA,6EACAC,aAAA,oFACAC,iBAAA,wFAEAC,QAAA,2DACAC,cAAA,oGACAC,aAAA,wBACAC,MAAA,sFAEAC,YACA7L,KAAA,MACA8L,IAAA,yCAEAC,QAAA,eACAC,MACAF,IAAA,4CAEAG,iBACAC,cAAA,SACAC,YAAA,SACAC,sBAAA,SACAC,+BAAA,UACAC,eAAA,UACAC,cAAA,UACAC,IAAA,eACAC,eAAA,UACAC,WAAA,UACAC,kBAAA,UACAC,KAAA,SACAC,QAAA,UACApB,QAAA,SACAqB,GAAA,SACAC,SAAA,SACAC,eAAA,UACAC,MAAA,SACAC,QAAA,UACAC,IAAA,UACAC,qBAAA,UACAC,MAAA,SACAC,OAAA,SACAC,sBAAA,SACAC,WAAA,SACAC,yBAAA,UACAC,YAAA,UACA5N,KAAA,gBACA6N,gBAAA,8BACAC,aAAA,gBACAC,SAAA,SACAC,oBAAA,UAEAC,cACAC,wBAAA,SACAC,MAAA,SACAC,sBAAA,cACAC,YAAA,SACAC,MAAA,gGChHA,IAAAC,GAAA7Z,EAAA,SAMalB,GAAAgb,eACT,SACA,QACA,QACA,UACA,WACA,MACA,OACA,UACA,WACA,YACA,QACA,SACA,SACA,KACA,KACA,MACA,MACA,WACA,MACA,MACA,SACA,UAGShb,EAAAib,mBAAqBF,EAAAnG,MAAM5U,EAAAgb,eAG3Bhb,EAAAkb,SACT,QACA,MACA,WACA,QACA,WAMSlb,EAAAmb,mBACT,OACA,UACA,SACA,KACA,KACA,MACA,OAGSnb,EAAAob,uBAAyBL,EAAAnG,MAAM5U,EAAAmb,qHC8B/Bnb,EAAAqb,iBACX,SAAU,SAAU,OAAQ,eAAgB,SAAU,YAAa,YAAa,SAAU,SAAU,WAAY,YAAa,QAAS,WAAY,QAAS,eAAgB,SAAU,+CC1BvL,SAAAC,GAA4BxF,GAC1B,MAAIiF,GAAA5H,UAAU2C,GACL,MAEF,MAAQ9R,OAAOR,KAAKsS,GAAK9H,IAAI,SAAA9E,GAAK,MAAA,IAAIA,EAAC,IAAI4M,EAAI5M,KAAMjH,KAAK,IAGnE,QAAAsZ,GAA4BC,GAC1B,OAAQA,GACN,IAAKC,GAAAC,IACL,IAAKD,GAAAE,OACL,IAAKF,GAAAG,KACL,IAAKH,GAAAI,MACL,IAAKJ,GAAAK,QAGL,IAAKL,GAAAM,MACH,MAAO,EACT,SACE,MAAO,qDA/Eb,IAAAN,GAAAva,EAAA,aACA6Z,EAAA7Z,EAAA,SA2DAlB,GAAAsb,YAAAA,EAOAtb,EAAAub,YAAAA,iECZA,SAAAS,GAA0BlV,GACxB,QAASmV,EAAcnV,GA0CzB,QAAAoV,GAA4BV,EAAkBW,GAC5C,MAAOA,KAAQC,GAAiBZ,GAQlC,QAAAY,GAAiCZ,GAC/B,OAAQA,GACN,IAAKxb,GAAAqc,EACL,IAAKrc,GAAAsc,EACL,IAAKtc,GAAA6b,MACL,IAAK7b,GAAAuc,OACL,IAAKvc,GAAAwc,MACL,IAAKxc,GAAA8b,QACL,IAAK9b,GAAA0b,IACL,IAAK1b,GAAA2b,OACH,OACEc,OAAO,EAAMC,MAAM,EAAM7M,MAAM,EAAM8M,QAAQ,EAAMC,QAAQ,EAC3DC,KAAK,EAAMjN,MAAM,EAAMF,MAAM,EAAMH,MAAM,EAAMhL,MAAM,EAEzD,KAAKvE,GAAA8c,GACL,IAAK9c,GAAA+c,GACH,OACElN,MAAM,EAAMgN,KAAK,EAAMjN,MAAM,EAAML,MAAM,EAE7C,KAAKvP,GAAA4b,KACH,OACEa,OAAO,EAAMC,MAAM,EAAM7M,MAAM,EAAM8M,QAAQ,EAAMC,QAAQ,EAC3DC,KAAK,EAAMtY,MAAM,EAAMmL,MAAM,EAEjC,KAAK1P,GAAA+b,MACH,OAAQU,OAAO,EACjB,KAAKzc,GAAAgd,KACH,OAAQzY,MAAM,GAElB,SAGF,QAAA0Y,GAAyBzB,GACvB,OAAQT,EAAAmC,UAAUld,EAAAuc,OAAQvc,EAAAgd,KAAMhd,EAAAwc,OAAQhB,GAM1C,QAAA2B,GAAiC3B,EAAkB4B,GACjD,OAAQ5B,GACN,IAAKxb,GAAA0b,IACL,IAAK1b,GAAA2b,OACH,MAAqB,SAAdyB,CACT,KAAKpd,GAAAqc,EACL,IAAKrc,GAAAsc,EACL,IAAKtc,GAAA4b,KACL,IAAK5b,GAAA8b,QAGH,MAAOsB,KAAaC,EACtB,KAAKrd,GAAA6b,MACH,MAAqB,SAAduB,CACT,KAAKpd,GAAA+b,MACH,MAAqB,YAAdqB,EAGX,OAAO,EAGT,QAAAE,GAA0B9B,GACxB,OAAQA,GACN,IAAKxb,GAAAqc,EACL,IAAKrc,GAAAsc,EACL,IAAKtc,GAAA4b,KACL,IAAK5b,GAAA8b,QACH,MAAO,YAET,KAAK9b,GAAA0b,IACL,IAAK1b,GAAA2b,OACL,IAAK3b,GAAA+b,MACH,MAAO,UAGT,KAAK/b,GAAA6b,MACH,MAAO,UAGT,KAAK7b,GAAA8c,GACL,IAAK9c,GAAA+c,GACL,IAAK/c,GAAAuc,OACL,IAAKvc,GAAAgd,KACL,IAAKhd,GAAAwc,MACH,OAGJ,KAAM,IAAIpb,OAAM,wCAA0Coa,mDAxL5D,IAGiB+B,GAHjBC,EAAAtc,EAAA,WACA6Z,EAAA7Z,EAAA,WAEA,SAAiBqc,GAEFA,EAAA7B,IAAa,MACb6B,EAAA5B,OAAmB,SAGnB4B,EAAAlB,EAAS,IACTkB,EAAAjB,EAAS,IACTiB,EAAAT,GAAW,KACXS,EAAAR,GAAW,KAGXQ,EAAA1B,MAAiB,QACjB0B,EAAAxB,MAAiB,QACjBwB,EAAA3B,KAAe,OACf2B,EAAAzB,QAAqB,UAGrByB,EAAAP,KAAe,OACfO,EAAAf,MAAiB,QACjBe,EAAAhB,OAAmB,UApBjBgB,EAAAvd,EAAAud,UAAAvd,EAAAud,aAyBJvd,EAAAqc,EAAIkB,EAAQlB,EACZrc,EAAAsc,EAAIiB,EAAQjB,EACZtc,EAAA8c,GAAKS,EAAQT,GACb9c,EAAA+c,GAAKQ,EAAQR,GACb/c,EAAA0b,IAAM6B,EAAQ7B,IACd1b,EAAA2b,OAAS4B,EAAQ5B,OACjB3b,EAAA+b,MAAQwB,EAAQxB,MAChB/b,EAAA4b,KAAO2B,EAAQ3B,KACf5b,EAAA6b,MAAQ0B,EAAQ1B,MAChB7b,EAAAgd,KAAOO,EAAQP,KACfhd,EAAAuc,OAASgB,EAAQhB,OACjBvc,EAAAwc,MAAQe,EAAQf,MAChBxc,EAAA8b,QAAUyB,EAAQzB,QAGlB9b,EAAAyd,UAAYzd,EAAAqc,EAAGrc,EAAAsc,EAAGtc,EAAA8c,GAAI9c,EAAA+c,GAAI/c,EAAA0b,IAAK1b,EAAA2b,OAAQ3b,EAAA4b,KAAM5b,EAAA+b,MAAO/b,EAAA6b,MAAO7b,EAAAwc,MAAOxc,EAAA8b,QAAS9b,EAAAgd,KAAMhd,EAAAuc,OAC9F,IAAMN,GAAgBlB,EAAAnG,MAAM5U,EAAAyd,SAE5Bzd,GAAAgc,UAAAA,EAKahc,EAAA0d,eAAiB1d,EAAAqc,EAAGrc,EAAAsc,EAAGtc,EAAA8c,GAAI9c,EAAA+c,GAAI/c,EAAA4b,KAAM5b,EAAA+b,MAAO/b,EAAA6b,MAAO7b,EAAAwc,MAAOxc,EAAA8b,QAAS9b,EAAAgd,KAAMhd,EAAAuc,QAGzEvc,EAAA2d,qBAAuB3d,EAAAqc,EAAGrc,EAAAsc,EAAGtc,EAAA4b,KAAM5b,EAAA+b,MAAO/b,EAAA6b,MAAO7b,EAAA8b,SAGjD9b,EAAA4d,gBAAkB5d,EAAAqc,EAAGrc,EAAAsc,EAAGtc,EAAA4b,KAAM5b,EAAA+b,MAAO/b,EAAA6b,MAAO7b,EAAA8b,QAAS9b,EAAA0b,IAAK1b,EAAA2b,QAG1D3b,EAAA6d,qBAAuB7d,EAAA4b,KAAM5b,EAAA+b,MAAO/b,EAAA6b,MAAO7b,EAAAwc,MAAOxc,EAAA8b,QAAS9b,EAAAgd,KAAMhd,EAAAuc,QAGjEvc,EAAA8d,2BAA6B9d,EAAA4b,KAAM5b,EAAA+b,MAAO/b,EAAA6b,MAAO7b,EAAA8b,SAEjD9b,EAAA+d,yBAA2BhD,EAAAiD,QAAQhe,EAAA6d,qBAAsB,UAGzD7d,EAAAie,sBAAwBje,EAAA6b,MAAO7b,EAAAuc,OAAQvc,EAAAwc,MAAOxc,EAAA8b,QAAS9b,EAAA4b,MAqBpE5b,EAAAkc,YAAAA,EASAlc,EAAAoc,iBAAAA,EAgCApc,EAAAid,SAAAA,CAKA,IAAMI,GAA4BtC,EAAAnG,MAAMmG,EAAAiD,QAAQR,EAAAU,aAAc,UAAW,eAEzEle,GAAAmd,iBAAAA,EAqBAnd,EAAAsd,UAAAA,+DC/JA,SAAAa,GAAuBC,EAAkB5C,EAAkB6C,EAAiBC,GAC1E,GAAMC,GAAWH,EAAMG,SAAS/C,GAC1BgD,EAAOJ,EAAMI,KAAKhD,GAClBiD,EAASL,EAAMK,MA6CrB,OA1CIF,GAAS7R,OAASgS,EAAAC,WACpBN,EAAatD,EAAA3I,QACX7N,MACEqa,OAAQC,EAAAC,qBAAqB,cAAeP,EAASQ,SAAUP,EAAKQ,OAAQP,EAAOD,KAAKS,gBAAiBR,EAAOS,cAEjHb,QAImBpb,KAApBub,EAAKW,WACPd,EAAWe,OAAS/c,MAAOmc,EAAKW,YAG5B3D,IAAYC,EAAAY,IAAMtB,EAAAmC,UAAUwB,EAAAW,QAASX,EAAAY,SAAUf,EAAS7R,OAAW6R,EAASzI,KAAOyI,EAAS7R,OAASgS,EAAAC,YACvGN,EAAWe,OAAS/c,MAAO,MAM3Bgc,EAAWe,QACkB,MAA3Bf,EAAWe,MAAM/c,MACnBgc,EAAWlK,OACT9R,MAAsB,QAAfic,EAAIiB,OAAmB,OACrB/D,IAAYC,EAAAY,EAAK,QAClB,UAE0B,KAA3BgC,EAAWe,MAAM/c,QAC1Bgc,EAAWlK,OAAS9R,MAAO,YAI3Bgc,EAAWe,QAGkB,MAA3Bf,EAAWe,MAAM/c,MACnBgc,EAAWmB,UAAYnd,MAAQmZ,IAAYC,EAAAY,EAAK,SAAW,UACvB,KAA3BgC,EAAWe,MAAM/c,QAC1Bgc,EAAWmB,UAAYnd,MAAO,YAIC,IAA5B0Y,EAAAvX,KAAK6a,GAAY7c,WAAeyB,GAAYob,kDAxDrD,IAAA5C,GAAAva,EAAA,iBACAwd,EAAAxd,EAAA,cACA6Z,EAAA7Z,EAAA,cAGA2d,EAAA3d,EAAA,YAGAlB,GAAAme,OAAAA,wGCMA,SAAAsB,GAAmCrB,EAAkBsB,GACnD,MAAOA,GAAaC,OAAO,SAASnB,EAAMhD,GACxC,GAAMoE,IAAgCC,QAASC,YAC/C,IAAI1B,EAAMI,KAAKhD,GAAU,CAEvB,GAAM5F,GAAOmK,EAAcvE,EAAS4C,EAChCxI,IAAQoK,EAAcpK,IACxBgK,EAAcC,KAAKxc,KAAKuS,EAG1B,IAAMqK,GAAOC,EAAc1E,EAAS4C,EAChC6B,IAAQD,EAAcC,IACxBL,EAAcE,SAASzc,KAAK4c,GAG9BzB,EAAKhD,GAAWoE,EAElB,MAAOpB,QAIX,QAAA2B,GAAuB9Z,GACrB,OAAa,IAANA,GAAqB,OAANA,EAMxB,QAAA2Z,GAAuBxB,GACrB,MAAOzD,GAAAqF,KAAKC,EAAY,SAACC,GAAS,MAAAC,GAAY/B,EAAM8B,KAGtD,QAAAC,GAAqB/B,EAAc8B,GAIjC,MAAa,SAATA,GAA4B,UAATA,IACZ9B,EAAK8B,IAGRH,EAAc3B,EAAK8B,IAM7B,QAAAJ,GAA8B1E,EAAkB4C,GAE9C,MAAOoC,GAAUhF,EAAS4C,GAAO,GAGnC,QAAA2B,GAA8BvE,EAAkB4C,GAC9C,MAAOoC,GAAUhF,EAAS4C,GAAO,GAGnC,QAAAoC,GAAmBhF,EAAkB4C,EAAkBqC,GACrD,GAAMjC,GAAOJ,EAAMI,KAAKhD,GAElBkF,GACJC,MAAOvC,EAAMwC,UAAUpF,GAIzBqF,GAAAxF,gBAAgBtI,QAAQ,SAAS+N,GAC/B,GAAMze,GAAQ0e,EAA2BD,EAAUtC,EAAMhD,EAAS4C,EAAOqC,OAC3Dxd,KAAVZ,IACFqe,EAAOI,GAAYze,IAKvB,IAAM2e,GAAYD,EAA2B,YAAavC,EAAMhD,EAAS4C,EAAOqC,OAC9Dxd,KAAd+d,IACAN,EAAOM,UAAYA,EAKvB,IAAMC,GAAazC,EAAK0C,UAqBxB,OApBAb,GAAWtN,QAAQ,SAASuN,GAC1B,GAAKC,EAAYG,EAAQJ,GAAzB,CAMA,GAAIje,EAEAA,GADS,WAATie,EACQY,EAAO/C,OAAOC,EAAO5C,EAASyF,EAAW9C,WAAcuC,GAEvDO,EAAWX,WAGTrd,KAAVZ,GAAuB0Y,EAAAvX,KAAKnB,GAAOb,OAAS,IAC9Ckf,EAAOQ,OAASR,EAAOQ,WACvBR,EAAOQ,OAAOZ,IAASa,OAAQ9e,OAI5Bqe,EAGT,QAAAK,GAAoCD,EAAwBM,EAAqB5F,EAAkB4C,EAAkBqC,GACnH,GAAMlC,GAAWH,EAAMG,SAAS/C,EAEhC,QAAQsF,GACN,IAAK,SACH,OAAOL,GAAqBW,EAAcN,EAC5C,KAAK,SACH,MAAOO,GAAMC,OAAOR,EAAUM,EAAeX,EAAYjF,EAC3D,KAAK,QACH,MAAO6F,GAAME,MAAMT,EAAUM,EAAeX,EAAYjF,EAC1D,KAAK,SACH,MAAO6F,GAAMrC,OAAOoC,EAAe5F,EAAS+C,EAAUH,EAAMK,OAC9D,KAAK,OACH,MAAO4C,GAAMpB,KAAK7B,EAAO5C,EAASiF,EACpC,KAAK,YACH,MAAOY,GAAML,UAAU5C,EAAO5C,EAASiF,EACzC,KAAK,SACH,MAAOY,GAAM9B,OAAO6B,EAAe5F,EACrC,KAAK,YACH,MAAO6F,GAAMG,UAAUJ,EAAe5F,EAAS+C,EACjD,KAAK,QACH,MAAO8C,GAAMI,MAAML,EAAe7C,EAAUH,EAAMK,OAAQgC,EAC5D,KAAK,SACH,MAAOY,GAAMK,OAAON,EACtB,KAAK,SACH,MAAOC,GAAMM,OAAOP,EAAeX,GAGvC,MAAOW,GAAcN,mDAhJvB,IAAAD,GAAA3f,EAAA,cAIAggB,EAAAhgB,EAAA,YACAmgB,EAAAngB,EAAA,WAEA6Z,EAAA7Z,EAAA,cAKMmf,GAA0B,SAAU,OAAQ,SAAU,QAAS,QAErErgB,GAAAyf,mBAAAA,EA8CAzf,EAAAkgB,cAAAA,EAKAlgB,EAAA+f,cAAAA,iGCpDA,SAAAf,GAAuBoC,EAAqB5F,EAAkB+C,EAA4BE,GACxF,MAAOI,GAAA+C,aAAarD,EAAU6C,EAAcpC,OAAQP,EAAQjD,GAQ9D,QAAAqG,GAAyBzD,EAAkB5C,GACzC,GAAMyE,GAAO7B,EAAMI,KAAKhD,GAASyE,IACjC,YAAahd,KAATgd,EACKA,GAGD7B,EAAM0D,kBAAkBtG,KAAa4C,EAAMG,SAAS/C,GAAS1F,IAGvE,QAAAmK,GAAqB7B,EAAkB5C,EAAkBiF,GACvD,GAAIjF,IAAYC,EAAAC,KAAOF,IAAYC,EAAAE,OAEjC,OAAO,CAGT,IAAK8E,EAIL,MAAOoB,GAASzD,EAAO5C,GAGzB,QAAAwF,GAA0B5C,EAAkB5C,EAAkBiF,GAC5D,GAAIA,EAAY,CACd,GAAMsB,GAAmC,MAAZvG,EAAkB,IAAM,GACrD,IAAI4C,EAAMuC,MAAMoB,GACd,MAAO3D,GAAMwC,UAAUmB,IAM7B,QAAAxC,GAAuB6B,EAAqB5F,GAC1C,GAAM+D,GAAS6B,EAAc7B,MAC7B,IAAIA,EACF,MAAOA,EAGT,QAAQ/D,GACN,IAAKC,GAAAE,OAEH,MAAO,KACT,KAAKF,GAAAY,EACH,MAAO,QACT,KAAKZ,GAAAC,IACL,IAAKD,GAAAa,EACH,MAAO,OAGX,KAAM,IAAIlb,OAAMqP,EAAI1L,QAAQid,0BAG9B,QAAAR,GAA0BJ,EAAqB5F,EAAkB+C,GAC/D,GAAMvR,GAAQoU,EAAcI,SAC5B,YAAcve,KAAV+J,EACKA,EAILwO,IAAYC,EAAAY,GAAMkC,EAASzI,QAA/B,GAES,EAMX,QAAA2L,GAAsBL,EAAqB7C,EAA4BE,EAAgBgC,GACrF,IAAIA,GAIwB,KAAxBW,EAAcK,MAAlB,CAIA,OAA4Bxe,KAAxBme,EAAcK,MAChB,MAAOL,GAAcK,KAIvB,IAAMQ,GAAaC,EAAAT,MAAclD,EAAUE,GAErC0D,EAAoBf,EAAcgB,cACxC,OAAOD,GAAYpH,EAAAlG,SAASoN,EAAYE,GAAaF,GAGvD,QAAAP,GAAuBN,GACrB,GAAMiB,GAAOjB,EAAcM,MAC3B,OAAIN,GAAcM,QAAUY,EAAAC,WAAWF,EAAK,IAClCA,EAAoBrU,IAAI,SAACwU,GAE/B,MAAOF,GAAAG,UAAUD,GAAI,KAGlBH,EAGT,QAAAV,GAAuBP,EAAqBX,GAC1C,GAAMiC,GAAItB,EAAcO,MACxB,YAAU1e,KAANyf,EACKA,EAELjC,EAEK,EAEF,EAGT,QAAAkC,GAA+B7B,EAAwBM,EAAqBX,EAAqBjF,GAC/F,OAAIiF,GAAcjF,IAAYC,EAAAC,KAAOF,IAAYC,EAAAE,QAG1CyF,EAAcN,mDAxIvB,IAAArQ,GAAAvP,EAAA,aAGAua,EAAAva,EAAA,iBAEAohB,EAAAphB,EAAA,kBACAghB,EAAAhhB,EAAA,kBACA6Z,EAAA7Z,EAAA,cAGA2d,EAAA3d,EAAA,YAGAlB,GAAAgf,OAAAA,EASAhf,EAAA6hB,SAAAA,EASA7hB,EAAAigB,KAAAA,EAaAjgB,EAAAghB,UAAAA,EAUAhhB,EAAAuf,OAAAA,EAoBAvf,EAAAwhB,UAAAA,EAeAxhB,EAAAyhB,MAAAA,EAoBAzhB,EAAA0hB,OAAAA,EAWA1hB,EAAA2hB,OAAAA,EAYA3hB,EAAA2iB,eAAAA,EAOa3iB,EAAAshB,OAASqB,EACT3iB,EAAAuhB,MAAQoB,+ICxHrB,SAAAC,GAA2BC,EAAYjgB,EAAekgB,EAAyBC,EAAyBtE,GACtG,GAAIuE,EAAAC,YAAYJ,GACd,MAAO,IAAIK,GAAAC,WAAWN,EAAMjgB,EAAQkgB,EAAiBC,EAAUtE,EAGjE,IAAIuE,EAAAI,YAAYP,GACd,MAAO,IAAIQ,GAAAC,WAAWT,EAAMjgB,EAAQkgB,EAAiBC,EAAUtE,EAGjE,IAAIuE,EAAAO,WAAWV,GACb,MAAO,IAAIW,GAAAC,UAAUZ,EAAMjgB,EAAQkgB,EAAiBC,EAAUtE,EAGhE,IAAIuE,EAAAU,aAAab,GACf,MAAO,IAAIc,GAAAC,YAAYf,EAAMjgB,EAAQkgB,EAAiBC,EAAUtE,EAGlE,IAAIuE,EAAAa,aAAahB,GACf,MAAO,IAAIiB,GAAAC,YAAYlB,EAAMjgB,EAAQkgB,EAAiBC,EAAUtE,EAGlE,MAAM,IAAIrd,OAAMqP,EAAI1L,QAAQif,cAG9B,QAAAC,GAA4BvjB,EACxB+d,EACAyF,GAOF,MANAA,GAAUnR,QAAQ,SAAC+N,GACjB,GAAMze,GAAQoc,EAAOqC,OACP7d,KAAVZ,IACF3B,EAAEogB,IAAaze,MAAOA,MAGnB3B,EAGT,QAAAyjB,GAAgCzjB,EAAkB0d,EAAkB8F,GAOlE,MANAA,GAAUnR,QAAQ,SAAC+N,GACjB,GAAMze,GAAQ+hB,EAActD,EAAU1C,EAAMjC,OAAQiC,EAAMK,YAC5Cxb,KAAVZ,IACF3B,EAAEogB,IAAaze,MAAOA,MAGnB3B,EAOT,QAAA0jB,GAA0DC,EAASlI,EAAYsC,GAC7E,GAAM6F,GAAqB7F,EAAOtC,EAClC,YAAiClZ,KAA7BqhB,EAAmBD,GACdC,EAAmBD,GAErB5F,EAAOtC,KAAKkI,GAGrB,QAAAE,GAAgChG,EAA4BiG,EAA0B/F,EAAgBgG,GACpG,GAAsB,iBAAlBlG,EAAS7R,KAAyB,CACpC,GAAMsS,GAAS4C,EAAarD,EAAUA,EAASS,OAAQP,EAAQ,OAC/D,OAAIF,GAASzI,IACP2O,GAEM7F,OAAQsD,EAAAlR,MAAMuN,GAAWiG,KAAIA,EAAEE,UAAW,YAGhD9F,OAAQ,UAAUsD,EAAAlR,MAAMuN,GAAWiG,KAAIA,EAAEE,UAAW,UAAS,MAAM1F,EAAM,iBAC7DkD,EAAAlR,MAAMuN,GAAWiG,KAAIA,EAAEE,UAAW,QAAO,MAAM1F,EAAM,OAKnEJ,OAAQ,UAAUsD,EAAAlR,MAAMuN,GAAWiG,KAAIA,IAAE,MAAMxF,EAAM,MAGpD,MAAsB,aAAlBT,EAAS7R,MAEhBkS,OAAQE,EAAqBoD,EAAAlR,MAAMuN,GAAWiG,KAAIA,IAAIjG,EAASQ,SAAUR,EAASS,OAAQP,EAAOla,KAAK0a,gBAAiBR,EAAOS;8DAGxHN,OAAQsD,EAAAlR,MAAMuN,GAAWiG,KAAIA,KASzC,QAAA5C,GAA6BrD,EAA4BoG,EAAyBlG,EAAgBjD,GAEhG,GAAMwD,GAAS2F,GAAmBpG,EAASS,MAC3C,IAAIT,EAAS7R,OAASgS,EAAAkG,aAGpB,MAAI5F,KAE8B,UAAvBT,EAASsG,WAAyBrJ,IAAYC,EAAAuB,KAEhD,IAGFyB,EAAOmD,cAQlB,QAAA9C,GAAqC9N,EAAe+N,EAAoBC,EAAgBC,EAA0B6F,GAChH,IAAK/F,GAAYC,EAAQ,CAGvB,MAAO,cAAchO,EAAK,OADVgO,GAAU8F,GACa,KAEvC,MAAOC,GAAAC,iBAAiBjG,EAAU/N,EAAOiO,GAO7C,QAAAgG,GAA2BC,GACzB,OAAQnK,EAAA7X,QAAQgiB,GAAYA,GAAYA,IAAWvF,OAAO,SAAC7e,EAAGqkB,GAG5D,MAFArkB,GAAEkQ,MAAM3N,KAAK6e,EAAAlR,MAAMmU,GAAkBT,UAAW,WAChD5jB,EAAEskB,MAAM/hB,KAAK8hB,EAAgBzhB,MAAQ,aAC9B5C,IACLkQ,SAAUoU,2DArJhB,IAAA3U,GAAAvP,EAAA,UAEAua,EAAAva,EAAA,cAEAghB,EAAAhhB,EAAA,eAEA8hB,EAAA9hB,EAAA,WAEA6jB,EAAA7jB,EAAA,eACAwd,EAAAxd,EAAA,WACA6Z,EAAA7Z,EAAA,WAEA4iB,EAAA5iB,EAAA,YACAgiB,EAAAhiB,EAAA,WACAmiB,EAAAniB,EAAA,WAEAyiB,EAAAziB,EAAA,YACAsiB,EAAAtiB,EAAA,SAGAlB,GAAA4iB,WAAAA,EAwBA5iB,EAAAikB,YAAAA,EAYAjkB,EAAAmkB,gBAAAA,EAcAnkB,EAAAokB,cAAAA,EAQApkB,EAAAukB,gBAAAA,EAgCAvkB,EAAA4hB,aAAAA,EAqBA5hB,EAAA8e,qBAAAA,EAaA9e,EAAAilB,WAAAA,6MCrIA,SAAAI,GAAwBC,EAAiC9T,GACnDA,GAEFf,EAAIkC,IAAInB,EAGV,KAEE,GAAMiN,GAAS8G,EAAAC,WAAWF,EAAU7G,QAI9BoE,EAAOG,EAAAyC,UAAUH,EAAW7G,GAG5BL,EAAQS,EAAA+D,WAAWC,EAAM,KAAM,GAAI,KAAMpE,EAS/C,OAHAL,GAAMha,QAGCshB,EAAStH,EAAOuH,EAAsBL,EAAW7G,YAGpDjN,GACFf,EAAImV,SAMV,QAAAD,GAA+BE,EAA6BpH,GAC1D,MAAMqH,GAAApe,YACDqe,EAAAC,0BAA0BvH,GAC1BsH,EAAAC,0BAA0BH,IAIjC,QAAAH,GAAkBtH,EAAc6H,GAoC9B,OACEpD,KAlCUiD,EAAApe,UACVwe,QAAS,+CACL9H,EAAMzI,aAAeA,YAAayI,EAAMzI,iBAC5CwQ,SAAU,OACPF,GACHjP,QAAShL,OACPoS,EAAMgI,eACNhI,EAAMiI,2BAERC,WACKta,OAKCoS,EAAMtZ,OAEHA,KAAM,QAASqc,OAAQ/C,EAAMmI,QAAQ,WACrCzhB,KAAM,SAAUqc,OAAQ/C,EAAMmI,QAAQ,eAG3CnI,EAAMoI,wBACNpI,EAAMqI,uCAQPC,EAAwBtI,KAS/B,QAAAsI,GAAwCtI,GACtC,GAAMuI,GAAAvI,EAAAwI,kBAACC,EAAAF,EAAAE,OAAQP,EAAAK,EAAAL,QAAS9W,EAAAsW,EAAAne,OAAAgf,GAAA,SAAA,YAClBzX,EAAQM,EAAMN,MAEd4X,IAAc1I,EAAM2I,iBACpBC,EAAiBlB,EAAApe,YAChBof,MACHG,OAAQrI,OAAQ,SAChBsI,QAAStI,OAAQ,WAEhBR,EAAM+I,gCAIX,OAAMrB,GAAApe,YACD8H,GACHN,OAAO4W,EAAApe,UACL5C,KAAMsZ,EAAMmI,QAAQ,qBACpB7Z,KAAM,QACNma,OAAMA,EACNP,QAAOA,GACHvL,EAAAvX,KAAKwjB,GAAmBxlB,OAAS,GACnC0f,QACEC,OAAQ6F,QAGZ9X,MAAKA,yEArHXqW,EAAArkB,EAAA,aACAuP,EAAAvP,EAAA,UACA8hB,EAAA9hB,EAAA,WACA6kB,EAAA7kB,EAAA,oBACA6Z,EAAA7Z,EAAA,WACA2d,EAAA3d,EAAA,WAGAlB,GAAAqlB,QAAAA,EAmFArlB,EAAA0mB,wBAAAA,0MC3FA3L,EAAA7Z,EAAA,WAEA2d,EAAA3d,EAAA,YACAkmB,EAAAlmB,EAAA,mBACAmmB,EAAAnmB,EAAA,gBACAomB,EAAApmB,EAAA,WAIA6iB,EAAA,SAAAwD,GAIE,QAAAxD,GAAYlB,EAAkBjgB,EAAekgB,EAAyBC,EAAyBtE,GAA/F,GAAA+I,GACED,EAAAhmB,KAAAf,KAAMqiB,EAAMjgB,EAAQkgB,EAAiBrE,IAAOje,WAE5CgnB,GAAKC,SAAW5E,EAAK6E,QAAQ1Z,IAAI,SAACiF,EAAO9R,GACvC,MAAO0d,GAAA+D,WAAW3P,EAAOuU,EAAMA,EAAKjB,QAAQ,UAAYplB,GAAI4hB,EAAUtE,OA0H5E,MAlIiCqH,GAAAre,UAAAsc,EAAAwD,GAYxBxD,EAAA7f,UAAAyjB,UAAP,WACEnnB,KAAKonB,UAAU5Q,KAAOqQ,EAAAM,UAAUnnB,MAChCA,KAAKinB,SAAS1U,QAAQ,SAACE,GACrBA,EAAM0U,eAIH5D,EAAA7f,UAAA2jB,eAAP,WAAA,GAAAL,GAAAhnB,IAIEA,MAAKonB,UAAUE,YACf,KAAoB,GAAAC,GAAA,EAAApB,EAAAnmB,KAAKinB,SAALM,EAAApB,EAAAnlB,OAAAumB,IAAa,CAA5B,GAAM9U,GAAK0T,EAAAoB,aAAL9U,GACTA,EAAM4U,iBACN9M,EAAAvX,KAAKyP,EAAM2U,UAAUE,WAAW/U,QAAQ,SAAC3Q,GACvColB,EAAKI,UAAUE,UAAU1lB,GAAO6Q,EAAM2U,UAAUE,UAAU1lB,MAHnD6Q,KAQN8Q,EAAA7f,UAAA8jB,WAAP,WAGwCxnB,KAAKonB,UAAUK,SAErDznB,MAAKinB,SAAS1U,QAAQ,SAASE,GAC7BA,EAAM+U,gBAIHjE,EAAA7f,UAAAgkB,UAAP,WACE,IAAoB,GAAAH,GAAA,EAAApB,EAAAnmB,KAAKinB,SAALM,EAAApB,EAAAnlB,OAAAumB,IAAa,CAAjBpB,EAAAoB,GACRG,cAIHnE,EAAA7f,UAAAikB,mBAAP,WACE,IAAoB,GAAAJ,GAAA,EAAApB,EAAAnmB,KAAKinB,SAALM,EAAApB,EAAAnlB,OAAAumB,IAAa,CAAjBpB,EAAAoB,GACRI,uBAIHpE,EAAA7f,UAAAkkB,eAAP,WACE,MAAO,OAGFrE,EAAA7f,UAAAmkB,YAAP,WAGE,IAAoB,GAAAN,IAFIvnB,KAAKonB,UAAUU,WAEnB,GAAA3B,EAAAnmB,KAAKinB,SAALM,EAAApB,EAAAnlB,OAAAumB,IAAa,CAAjBpB,EAAAoB,GACRM,gBAIHtE,EAAA7f,UAAAkiB,aAAP,WACG,MAAK5lB,MAAKoC,UAEFwkB,EAAAhB,aAAarL,EAAAsH,KAAK7hB,KAAKonB,UAAU5Q,KAAKuR,WAM1CxE,EAAA7f,UAAAijB,8BAAP,WACE,MAAO,OAGFpD,EAAA7f,UAAAuiB,iCAAP,SAAwCH,GACtC,MAAO9lB,MAAKinB,SAAS9H,OAAO,SAAC6I,EAAIvV,GAAU,MAAAA,GAAMwT,iCAAiC+B,IAAKlC,IAGlFvC,EAAA7f,UAAAukB,yBAAP,WAEE,MADAjoB,MAAKinB,SAAS1U,QAAQ,SAACE,GAAU,MAAAA,GAAMwV,iCAIlC1E,EAAA7f,UAAAsiB,sBAAP,WACE,MAAOhmB,MAAKinB,SAAS9H,OAAO,SAAC2G,EAASrT,GACpC,MAAOqT,GAAQta,OAAOiH,EAAMuT,+BAGzBzC,EAAA7f,UAAAmiB,sBAAP,SAA6BrP,GAC3B,MAAOxW,MAAKinB,SAAS9H,OAAO,SAAC+I,EAAIzV,GAAU,MAAAA,GAAMoT,sBAAsBqC,SAGlE3E,EAAA7f,UAAAykB,eAAP,WAEE,MAAOnoB,MAAKinB,SAAS9H,OAAO,SAACsI,EAAQhjB,GACnC,MAAOgjB,GAAOjc,OAAO/G,EAAE0jB,mBACtBpB,EAAArjB,UAAMykB,eAAcpnB,KAAAf,QAGlBujB,EAAA7f,UAAA6iB,eAAP,WAEE,OACE6B,SAAUC,IAAK,GAAIC,OAAQ,IAC3BC,OAAQ,GACRC,QAAS,EACTC,OAAQ,OACR9U,MAAO,QAIJ4P,EAAA7f,UAAAglB,cAAP,WAEE,MAAO1oB,MAAKinB,SAASzZ,IAAI,SAAAiF,GAAS,MAAA6S,GAAApe,UAChCgF,KAAM,QACN5H,KAAMmO,EAAMsT,QAAQ,SACpBrF,QACEC,OAAM2E,EAAApe,UACJuf,MAAOhU,EAAMkW,iBAAiB,SAC9BjC,OAAQjU,EAAMkW,iBAAiB,WAC5BlW,EAAMkU,mCAGVlU,EAAM2T,oBAGf7C,GAlIiCuD,EAAA8B,MAApBppB,GAAA+jB,YAAAA,6HCFb,SAAAsF,GAAsBC,EAAkC/K,GAatD,MAZIA,GAASzI,KACXwT,EAAKpH,EAAAlR,MAAMuN,GAAWmG,UAAW,YAAa,EAC9C4E,EAAKpH,EAAAlR,MAAMuN,GAAWmG,UAAW,UAAW,EAIxCnG,EAAS7R,OAASgS,EAAAY,UACpBgK,EAAKpH,EAAAlR,MAAMuN,GAAWmG,UAAW,YAAa,IAGhD4E,EAAKpH,EAAAlR,MAAMuN,KAAa,EAEnB+K,EAGT,QAAAC,GAAuBC,EAAqCC,GAC1D,IAAK,GAAMC,KAASD,GAClB,GAAIA,EAActlB,eAAeulB,GAAQ,CAEvC,GAAMne,GAAMke,EAAcC,EAC1B,KAAK,GAAMve,KAAMI,GACXA,EAAIpH,eAAegH,KACjBue,IAASF,GAEXA,EAAeE,GAAOve,IAAM,EAE5Bqe,EAAeE,IAAUve,IAAI,uEApCzC+W,EAAAhhB,EAAA,kBACAuP,EAAAvP,EAAA,aACAwd,EAAAxd,EAAA,cACA6Z,EAAA7Z,EAAA,cAIAyoB,EAAAzoB,EAAA,cAqCA0oB,EAAA,SAAArC,GASE,QAAAqC,GAAoBC,EAA+BC,GAAnD,GAAAtC,GACED,EAAAhmB,KAAAf,OAAOA,WADWgnB,GAAAqC,WAAAA,EAA+BrC,EAAAsC,SAAAA,IAqGrD,MA9GmChE,GAAAre,UAAAmiB,EAAArC,GAC1BqC,EAAA1lB,UAAA6lB,MAAP,WACE,MAAO,IAAIH,GAAc7O,EAAA3I,UAAW5R,KAAKqpB,YAAa9O,EAAAiP,UAAUxpB,KAAKspB,YAWzDF,EAAAK,KAAd,SAAmB7L,GACjB,GAAI8L,IAAc,CAClB9L,GAAM+L,gBAAgB,SAAAC,GAChBA,EAAGvF,YACLqF,GAAc,IAIlB,IAAMG,MACAf,IAEN,OAAKY,IAKL9L,EAAM+L,gBAAgB,SAAC5L,EAAU/C,GAC/B,GAAI+C,EAASsG,UACX,GAA2B,UAAvBtG,EAASsG,UACXwF,EAAK,KAAOA,EAAK,SAEjBA,EAAK,KAAY,OAAI,MAEhB,CACLA,EAAK9L,EAASvN,OAASqZ,EAAK9L,EAASvN,WACrCqZ,EAAK9L,EAASvN,OAAOuN,EAASsG,YAAa,CAG3C,IAAMlE,GAAQvC,EAAMuC,MAAMnF,EACtBmF,IAA0B,iBAAjBA,EAAMW,SACjB+I,EAAK9L,EAASvN,OAAY,KAAI,EAC9BqZ,EAAK9L,EAASvN,OAAY,KAAI,OAIlCqY,GAAaC,EAAM/K,KAIlBva,OAAOR,KAAK8lB,GAAM9nB,OAASwC,OAAOR,KAAK6mB,GAAM7oB,SAAY,EACrD,KAGF,GAAIooB,GAAcN,EAAMe,IA9BtB,MAiCJT,EAAA1lB,UAAAqP,MAAP,SAAa+W,GACNvP,EAAAwP,OAAO/pB,KAAKqpB,WAAYS,EAAMT,YAIjCpZ,EAAIkB,MAAM,uCAHV4X,EAAc/oB,KAAKspB,SAAUQ,EAAMR,UACnCQ,EAAME,WAMHZ,EAAA1lB,UAAAumB,cAAP,SAAqBpa,GAArB,GAAAmX,GAAAhnB,IACE6P,GAAO0C,QAAQ,SAAAhT,GAAK,MAAAynB,GAAKqC,WAAW9pB,IAAK,KAGpC6pB,EAAA1lB,UAAAwmB,gBAAP,WACE,GAAMvnB,KAKN,OAHA4X,GAAAvX,KAAKhD,KAAKqpB,YAAY9W,QAAQ,SAAAhT,GAAK,MAAAoD,GAAIpD,IAAK,IAC5Cgb,EAAAvX,KAAKhD,KAAKspB,UAAU/W,QAAQ,SAAAlO,GAAK,MAAA1B,GAAI0B,IAAK,IAEnC1B,GAGFymB,EAAA1lB,UAAAymB,eAAP,WAAA,GAAAnD,GAAAhnB,KACQ2C,IAQN,OANA4X,GAAAvX,KAAKhD,KAAKspB,UAAU/W,QAAQ,SAAA/B,GAC1B+J,EAAAvX,KAAKgkB,EAAKsC,SAAS9Y,IAAQ+B,QAAQ,SAAA5H,GACjChI,EAAOgI,EAAE,IAAI6F,IAAW,MAIrB7N,GAGFymB,EAAA1lB,UAAAwhB,SAAP,WAAA,GAAA8B,GAAAhnB,KACQ+K,KACA8E,IAQN,OAPA0K,GAAAvX,KAAKhD,KAAKspB,UAAU/W,QAAQ,SAAA/B,GAC1B+J,EAAAvX,KAAKgkB,EAAKsC,SAAS9Y,IAAQ+B,QAAQ,SAAA5H,GACjCI,EAAIlI,KAAK8H,GACTkF,EAAOhN,KAAK2N,QAKdtE,KAAM,YACNke,QAAS7P,EAAAvX,KAAKhD,KAAKqpB,YACnBte,IAAGA,EACH8E,OAAMA,IAGZuZ,GA9GmCD,EAAAkB,aAAtB7qB,GAAA4pB,cAAAA,iICnBb,SAAAkB,GAAgCxoB,GAE1BA,YAAgByoB,GAAAC,uBAAyBjQ,EAAAkQ,MAAMlQ,EAAAsH,KAAK/f,EAAK6L,QAAS,SAAA5L,GAAK,OAAM,IAANA,KACzED,EAAKkoB,SAIHloB,YAAgB4oB,GAAAC,gBAAkBpQ,EAAAkQ,MAAMlQ,EAAAsH,KAAK/f,EAAK8oB,gBAAiB,SAAArrB,GAAK,MAAM,QAANA,KAC1EuC,EAAKkoB,SAIHloB,YAAgBqnB,GAAA0B,aAAe/oB,EAAKgpB,UACtChpB,EAAKkoB,SAGPloB,EAAKmlB,SAAS1U,QAAQ+X,GAMxB,QAAAS,GAAsBC,GACpB,QAAAzB,GAAeznB,GACb,KAAMA,YAAgBmpB,GAAAC,WAAY,CAChC,GAAMC,GAAOrpB,EAAKynB,OAElB,IAAI4B,YAAgBhC,GAAA0B,WAAY,CAC9B,GAAMO,GAAU5rB,EAAA6rB,mBAAqBL,EAAMpN,MAAMmI,QAAQoF,EAAK5lB,OAC9D4lB,GAAK5lB,OAAS6lB,EAEdJ,EAAMpN,MAAMwJ,UAAU5Q,KAAK8U,YAAYF,GAAWD,EAElD5Q,EAAAgR,QAAQzpB,EAAKmlB,SAASzZ,IAAI+b,IAAQhX,QAAQ,SAACnS,GAAoB,MAAAA,GAAEgC,OAAS+oB,QACjEA,aAAgBK,GAAApC,eAAiB+B,YAAgBM,GAAAC,WAC1DP,EAAKlB,cAAce,EAAMnb,QAEzB0K,EAAAgR,QAAQzpB,EAAKmlB,SAASzZ,IAAI+b,IAAQhX,QAAQ,SAACnS,GAAoB,MAAAA,GAAEgC,OAAS+oB,KAE1E5Q,EAAAgR,QAAQzpB,EAAKmlB,SAASzZ,IAAI+b,IAAQhX,QAAQ,SAACnS,GAAoB,MAAAA,GAAEgC,OAAS+oB,GAG5E,QAAQA,GAGV,MAAO5Q,GAAAgR,QAAQzpB,EAAKmlB,SAASzZ,IAAI+b,IAEnC,MAAOA,GAOT,QAAAoC,GAAuB7pB,GACrB,GAAIA,YAAgB4gB,GAAAkJ,UAClB,GAA2B,IAAvB9pB,EAAK+pB,eAAyB/pB,EAAKmlB,SAAS,YAAckC,GAAA0B,WAWvD,CAELiB,EAAoBhqB,EAAK8b,MAAMwJ,UAAU5Q,KAAKpB,KAG9C,IAAM2W,GAAuBxR,EAAAgR,QAAQzpB,EAAKmlB,SAASzZ,IAAIud,EAAajpB,IACpEiqB,GAAKxZ,QAAQ,SAAA9N,GAAK,MAAAA,GAAErC,OAASN,EAAK8b,MAAMwJ,UAAU5Q,KAAKpB,WAjBkB,CAGzE,GAAM3C,GAAQ3Q,EAAKmlB,SAAS,IAExBxU,YAAiB+Y,GAAApC,eAAiB3W,YAAiBgZ,GAAAC,YACrDjZ,EAAMwX,cAAcnoB,EAAK+N,QAG3B4C,EAAMuZ,iBACNL,EAAc7pB,OAUhBA,GAAKmlB,SAAS1U,QAAQoZ,GAI1B,QAAAG,GAA6BhqB,GAC3B,GAAIA,YAAgBqnB,GAAA0B,YAAc/oB,EAAKoK,OAAS+f,EAAAC,MACnB,IAAvBpqB,EAAK+pB,cAAqB,CAC5B,GAAMpZ,GAAQ3Q,EAAKmlB,SAAS,EAEtBxU,aAAiBiQ,GAAAkJ,YACrBnZ,EAAMuZ,iBACNF,EAAoBhqB,KAU5B,QAAAqqB,GAAmBC,GAEjB,QAAAC,GAAgBvqB,GACa,IAAvBA,EAAK+pB,cACPS,EAAOzpB,KAAKf,GAEZA,EAAKmlB,SAAS1U,QAAQ8Z,GAL1B,GAAMC,KAUN,OADAF,GAAM7Z,QAAQ8Z,GACPC,EAgBT,QAAAC,GAAsB/V,GAOpB,QAAAgW,GAAkB1qB,EAAoB2qB,GAcpC,GAbI3qB,YAAgB4qB,GAAAC,YACd7qB,EAAKM,iBAAkBwqB,GAAAC,aAAeJ,EAAWlnB,OAEnDknB,EAAWjO,OAAM8G,EAAApe,YACZulB,EAAWjO,YACd5a,MAAO9B,EAAKgrB,wBAIdL,EAAWM,UAAYN,EAAWM,UAAUvhB,OAAO1J,EAAKkrB,uBAIxDlrB,YAAgB4gB,GAAAkJ,UAelB,MAdKa,GAAWnoB,OACdmoB,EAAWnoB,KAAO,QAAQ2oB,MAGvBR,EAAWlnB,QAAUknB,EAAWM,UAAU/rB,OAAS,GACtDwV,EAAK3T,KAAK4pB,GACV3qB,EAAK0U,KAAOiW,EAAWnoB,MAEvBxC,EAAK0U,KAAOiW,EAAWlnB,WAGzBzD,GAAKojB,WAAW3S,QAAQ,SAAA9J,GAAK,MAAA+N,GAAK3T,KAAK4F,IAqBzC,KAfI3G,YAAgBorB,GAAAC,YAClBrrB,YAAgB4oB,GAAAC,gBAChB7oB,YAAgBorB,GAAAE,eAChBtrB,YAAgB0pB,GAAApC,eAChBtnB,YAAgBmpB,GAAAC,YAChBuB,EAAWM,UAAUlqB,KAAKf,EAAKojB,aAG7BpjB,YAAgByoB,GAAAC,uBAClB1oB,YAAgBurB,GAAAC,SAChBxrB,YAAgByiB,GAAAgJ,cAChBzrB,YAAgB2pB,GAAAC,aAChBe,EAAWM,UAAYN,EAAWM,UAAUvhB,OAAO1J,EAAKojB,aAGtDpjB,YAAgBqnB,GAAA0B,WAClB,GAAI4B,EAAWlnB,QAA0C,IAAhCknB,EAAWM,UAAU/rB,OAC5Cc,EAAKyD,OAASknB,EAAWlnB,WACpB,IAAIzD,EAAKM,iBAAkB+mB,GAAA0B,WAGhC/oB,EAAKyD,OAASknB,EAAWnoB,SAWzB,IATKmoB,EAAWnoB,OACdmoB,EAAWnoB,KAAO,QAAQ2oB,KAK5BnrB,EAAKyD,OAASknB,EAAWnoB,KAGE,IAAvBxC,EAAK+pB,eAAuBY,EAAWM,UAAU/rB,OAAS,EAAG,CAC/DwV,EAAK3T,KAAK4pB,EACV,IAAMe,IACJlpB,KAAM,KACNiB,OAAQknB,EAAWnoB,KACnByoB,aAEFN,GAAae,EAKnB,OAAQ1rB,EAAK+pB,eACX,IAAK,GAEC/pB,YAAgBqnB,GAAA0B,cAAgB4B,EAAWlnB,QAAUknB,EAAWM,UAAU/rB,OAAS,IAErFwV,EAAK3T,KAAK4pB,EAEZ,MACF,KAAK,GACHD,EAAS1qB,EAAKmlB,SAAS,GAAIwF,EAC3B,MACF,SACE,GAAIgB,GAAShB,EAAWnoB,MACnBmoB,EAAWlnB,QAAUknB,EAAWM,UAAU/rB,OAAS,EACtDwV,EAAK3T,KAAK4pB,GAEVgB,EAAShB,EAAWlnB,OAGtBzD,EAAKmlB,SAAS1U,QAAQ,SAAAE,GAMpB+Z,EAAS/Z,GAJPnO,KAAM,KACNiB,OAAQkoB,EACRV,kBAxGV,GAAIE,GAAe,CAgHnB,OAAOT,GAMT,QAAAkB,GAAkCtlB,GAChC,GAAMoO,MACAgW,EAAWD,EAAa/V,EAQ9B,OANApO,GAAK6e,SAAS1U,QAAQ,SAAAE,GAAS,MAAA+Z,GAAS/Z,GACtClN,OAAQ6C,EAAK9D,KACbA,KAAM,KACNyoB,iBAGKvW,EAUT,QAAAoP,GAA6BwG,GAC3B,GAAM5V,KAEN4V,GAAM7Z,QAAQ+X,GAGd8B,EAAQA,EAAMze,OAAO,SAAAtN,GAAK,MAAAA,GAAEwrB,cAAgB,IAC5CM,EAAUC,GAAO7Z,QAAQob,EAAAC,kBAAkBC,EAAWC,uBACtD1B,EAAQA,EAAMze,OAAO,SAAAtN,GAAK,MAAAA,GAAEwrB,cAAgB,IAE5CM,EAAUC,GAAO7Z,QAAQob,EAAAC,kBAAkBC,EAAWE,cAEtD3B,EAAM7Z,QAAQoZ,EAId,IAAMa,GAAWD,EAAa/V,GAE1BwX,EAAc,CAoBlB,OAlBA5B,GAAM7Z,QAAQ,SAAAnK,GAEPA,EAAK6lB,YACR7lB,EAAK8lB,SAAW,UAAUF,IAG5B,IAAMR,GAAkBplB,EAAK8c,UAE7BsH,GAASpkB,EAAMolB,KAIjBhX,EAAKjE,QAAQ,SAAA9J,GACgB,IAAvBA,EAAEskB,UAAU/rB,cACPyH,GAAEskB,YAINvW,oEAxUTyV,EAAAvrB,EAAA,cAEA6Z,EAAA7Z,EAAA,cAGA8qB,EAAA9qB,EAAA,eACA2sB,EAAA3sB,EAAA,SACAyoB,EAAAzoB,EAAA,cACAgiB,EAAAhiB,EAAA,WACAgsB,EAAAhsB,EAAA,iBACA6pB,EAAA7pB,EAAA,uBACAgqB,EAAAhqB,EAAA,gBACAitB,EAAAjtB,EAAA,gBACAmtB,EAAAntB,EAAA,gBACAuqB,EAAAvqB,EAAA,eACAksB,EAAAlsB,EAAA,YACA+qB,EAAA/qB,EAAA,WACA6jB,EAAA7jB,EAAA,cACAwsB,EAAAxsB,EAAA,eAGalB,GAAA6rB,mBAAqB,SAyPlC7rB,EAAAkuB,kBAAAA,EAoBAluB,EAAAomB,aAAAA,qSCrRA,SAAAuI,GAA0BnK,EAAcxF,GACtC,MAAO,UAAUwF,EAAI,MAAMxF,EAAM,KAGnC,QAAA4P,GAAsBxQ,EAAuBG,EAA4B/C,EAAkBiD,GAGvF,GAFuBL,EAAM0D,kBAAkBtG,GAE3B,CAGlB,GAAMqT,GAASzQ,YAAiBoF,GAAAC,UAAcrF,EAAMI,KAAKhD,IAAY4C,EAAM0Q,OAAOtT,UAC5EwD,EAASH,EAAA+C,aAAarD,EAAUsQ,EAAM7P,OAAQP,EAAQjD,GAEtDuT,EAAa7M,EAAAlR,MAAMuN,GAAWiG,KAAM,QAASE,UAAW,UACxDsK,EAAW9M,EAAAlR,MAAMuN,GAAWiG,KAAM,QAASE,UAAW,OAE5D,QACEuK,UAAW/M,EAAAlR,MAAMuN,GAAWmG,UAAW,UACvCwK,QAAYP,EAAiBI,EAAY/P,GAAO,cAAc2P,EAAiBK,EAAUhQ,IAG7F,2EAlCJ6O,EAAA3sB,EAAA,aAGAghB,EAAAhhB,EAAA,kBAEA6Z,EAAA7Z,EAAA,cAEA2d,EAAA3d,EAAA,aAEAsiB,EAAAtiB,EAAA,WACAyoB,EAAAzoB,EAAA,cAwCA4sB,EAAA,SAAAvG,GAKE,QAAAuG,GAAoBqB,GAApB,GAAA3H,GACED,EAAAhmB,KAAAf,OAAOA,WADWgnB,GAAA2H,KAAAA,IA+FtB,MApG6BrJ,GAAAre,UAAAqmB,EAAAvG,GACpBuG,EAAA5pB,UAAA6lB,MAAP,WACE,MAAO,IAAI+D,GAAQ/S,EAAAiP,UAAUxpB,KAAK2uB,QAOtBrB,EAAA7D,KAAd,SAAmB7L,GACjB,GAAM+Q,GAAO/Q,EAAMgR,eAAe,SAACC,EAAkC9Q,EAAU/C,GAC7E,GAAM8T,GAAclR,EAAMG,SAAS/C,GAAS1F,GAC5C,IAAIwZ,EAAa,CACf,GAAMxZ,GAAWiF,EAAA5H,UAAUmc,MAAoBA,EACzCltB,EAASyrB,EAAAvS,YAAYiD,EAASzI,KAAI,IAAIyI,EAASvN,KAE/C5O,KAAOitB,KACXA,EAAajtB,IACX0T,IAAKA,EACL9E,MAAOuN,EAASvN,MAChBue,IAAKrN,EAAAlR,MAAMuN,GAAWmG,UAAW,UAAWxC,EAAAlR,MAAMuN,GAAWmG,UAAW,SACxE9F,OAAQR,EAAMmI,QAAWnkB,EAAG,SAC5BotB,aAAcpR,EAAMmI,QAAQnkB,EAAM,aAItCitB,EAAajtB,GAAI0jB,EAAApe,YACZ2nB,EAAajtB,GACbwsB,EAAaxQ,EAAOG,EAAU/C,EAAS4C,EAAMK,SAGpD,MAAO4Q,OAGT,OAAiC,KAA7BrrB,OAAOR,KAAK2rB,GAAM3tB,OACb,KAGF,GAAIssB,GAAQqB,IAGdrB,EAAA5pB,UAAAqP,MAAP,SAAa+W,GACX9pB,KAAK2uB,KAAOpU,EAAA3I,OAAOkY,EAAM6E,MACzB7E,EAAME,UAGDsD,EAAA5pB,UAAAymB,eAAP,WACE,GAAMxnB,KAMN,OAJA4X,GAAAsH,KAAK7hB,KAAK2uB,MAAMpc,QAAQ,SAAA9N,GACtBA,EAAEsqB,GAAGxc,QAAQ,SAAAhT,GAAK,MAAAoD,GAAIpD,IAAK,MAGtBoD,GAGF2qB,EAAA5pB,UAAAwmB,gBAAP,WACE,GAAMvnB,KAMN,OAJA4X,GAAAsH,KAAK7hB,KAAK2uB,MAAMpc,QAAQ,SAAA9N,GACtB9B,EAAI8B,EAAE+L,QAAS,IAGV7N,GAGF2qB,EAAA5pB,UAAAwhB,SAAP,WACE,MAAO3K,GAAAgR,QAAQhR,EAAAsH,KAAK7hB,KAAK2uB,MAAMnhB,IAAI,SAAA8H,GACjC,GAAMyX,MAEAkC,EAAQ3J,EAAApe,UACVgF,KAAM,MACNsE,MAAO8E,EAAI9E,MACXue,GAAIzZ,EAAIyZ,GACR3Q,OAAQ9I,EAAI8I,QACT9I,EAAIA,IAsBX,OAnBKA,GAAIA,IAAI4Z,SACXnC,EAAUlqB,MACRqJ,KAAM,SACNsE,MAAO8E,EAAI9E,MACX4N,OAAQ9I,EAAI0Z,eAEdC,EAASC,QAAU9Q,OAAQ9I,EAAI0Z,eAGjCjC,EAAUlqB,KAAKosB,GAEX3Z,EAAIoZ,SACN3B,EAAUlqB,MACRqJ,KAAM,UACN8X,KAAM1O,EAAIoZ,QACVK,GAAIzZ,EAAImZ,YAIL1B,MAGbO,GApG6BnE,EAAAkB,aAAhB7qB,GAAA8tB,QAAAA,gNC1CbjD,EAAA,WAKE,QAAAA,GAA4B8E,GAAAnvB,KAAAmvB,UAAAA,EAJpBnvB,KAAAovB,aAEApvB,KAAAqvB,QAAwB,KA2ElC,MApEShF,GAAA3mB,UAAA6lB,MAAP,WACE,KAAM,IAAI3oB,OAAM,sBAMXypB,EAAA3mB,UAAAymB,eAAP,WACE,UAGKE,EAAA3mB,UAAAwmB,gBAAP,WACE,UAGF1mB,OAAA+F,eAAI8gB,EAAA3mB,UAAA,cAAJ,WACE,MAAO1D,MAAKqvB,aAMd,SAAWjtB,GACTpC,KAAKqvB,QAAUjtB,EACfA,EAAOktB,SAAStvB,uCAGlBwD,OAAA+F,eAAI8gB,EAAA3mB,UAAA,gBAAJ,WACE,MAAO1D,MAAKovB,2CAGP/E,EAAA3mB,UAAAmoB,YAAP,WACE,MAAO7rB,MAAKovB,UAAUpuB,QAGjBqpB,EAAA3mB,UAAA4rB,SAAP,SAAgB7c,GACdzS,KAAKovB,UAAUvsB,KAAK4P,IAGf4X,EAAA3mB,UAAA6rB,YAAP,SAAmBC,GACjBxvB,KAAKovB,UAAUhsB,OAAOpD,KAAKovB,UAAUtsB,QAAQ0sB,GAAW,IAMnDnF,EAAA3mB,UAAAsmB,OAAP,WAAA,GAAAhD,GAAAhnB,IACEA,MAAKovB,UAAU7c,QAAQ,SAAAE,GAAS,MAAAA,GAAMrQ,OAAS4kB,EAAKqI,UACpDrvB,KAAKqvB,QAAQE,YAAYvvB,OAGpBqqB,EAAA3mB,UAAAsoB,eAAP,WACE,GAAM5pB,GAASpC,KAAKqvB,QACdI,EAAYrtB,EAAOA,MAGzBpC,MAAKovB,UAAU7c,QAAQ,SAAA9N,GAAK,MAAAA,GAAErC,OAASA,IAGvCpC,KAAKovB,aACLhtB,EAAOmtB,YAAYvvB,MACnBoC,EAAOA,OAAOmtB,YAAYntB,GAI1BpC,KAAKoC,OAASqtB,EACdrtB,EAAOA,OAASpC,MAEpBqqB,IA9Ea7qB,GAAA6qB,aAAAA,CAgFb,IAAAQ,GAAA,SAAA9D,GAcE,QAAA8D,GAAYtlB,EAAgC2G,GAA5C,GAAA8a,GACED,EAAAhmB,KAAAf,KAAMuF,IAAOvF,WAD6BgnB,GAAA9a,KAAAA,EAVpC8a,EAAA0I,UAAY,EAalB1I,EAAK2I,QAAUpqB,IAwBnB,MAzCgC+f,GAAAre,UAAA4jB,EAAA9D,GAMvB8D,EAAAnnB,UAAA6lB,MAAP,WACE,GAAMqG,GAAW,GAAU5vB,MAAK4I,WAIhC,OAHAgnB,GAASD,QAAU3vB,KAAK2vB,QACxBC,EAAST,UAAY,SAAWnvB,KAAKmvB,UACrCS,EAASF,UAAY1vB,KAAK0vB,UACnBE,GAkBTpsB,OAAA+F,eAAIshB,EAAAnnB,UAAA,cAAJ,WAEE,MADA1D,MAAK0vB,YACE1vB,KAAK2vB,aAGd,SAAWpqB,GACTvF,KAAK2vB,QAAUpqB,mCAGjB/B,OAAA+F,eAAIshB,EAAAnnB,UAAA,gBAAJ,WACE,MAAO1D,MAAK0vB,UAAY,mCAE5B7E,GAzCgCR,EAAnB7qB,GAAAqrB,WAAAA,iHCxFb5P,EAAAva,EAAA,iBAGAyoB,EAAAzoB,EAAA,cAKAkrB,EAAA,SAAA7E,GAYE,QAAA6E,GAAmChO,EAAmCtZ,EAAqBkS,GAA3F,GAAAwQ,GACED,EAAAhmB,KAAAf,OAAOA,WAD0BgnB,GAAApJ,MAAAA,EAAmCoJ,EAAA1iB,KAAAA,EAAqB0iB,EAAAxQ,KAAAA,EAGrFoH,EAAMoN,MAAM1C,SACdtB,EAAK6I,YAAcjS,EAAMpN,MAAMyK,EAAAE,QAC/B6L,EAAK8I,WAAalS,EAAMmI,QAAQ,WAG9BnI,EAAMoN,MAAM3C,MACdrB,EAAK+I,SAAWnS,EAAMpN,MAAMyK,EAAAC,KAC5B8L,EAAKgJ,QAAUpS,EAAMmI,QAAQ,UA4DnC,MAlF+BT,GAAAre,UAAA2kB,EAAA7E,GA0B7BvjB,OAAA+F,eAAIqiB,EAAAloB,UAAA,cAAJ,WACE,GAAMmM,KAON,OANI7P,MAAK6vB,aACPhgB,EAAOhN,KAAK7C,KAAK6vB,aAEf7vB,KAAK+vB,UACPlgB,EAAOhN,KAAK7C,KAAK+vB,UAEZlgB,mCAMTrM,OAAA+F,eAAIqiB,EAAAloB,UAAA,cAAJ,WACE,MAAO1D,MAAKsE,sCAGPsnB,EAAAloB,UAAAwhB,SAAP,WACE,GAAM1O,KAmCN,OAjCIxW,MAAK8vB,aACPtZ,EAAK3T,MACHyB,KAAMtE,KAAK8vB,WACXvqB,OAAQvF,KAAKwW,KACbuW,YACE7gB,KAAM,YACNke,SAAUpqB,KAAK6vB,iBAKnBrZ,EAAK3T,MACHyB,KAAMtE,KAAK8vB,WAAa,UACxBvqB,OAAQvF,KAAK8vB,WACb/C,YACE7gB,KAAM,YACNnB,KAAM,YACN8E,QAAS7P,KAAK6vB,kBAKhB7vB,KAAKgwB,SACPxZ,EAAK3T,MACHyB,KAAMtE,KAAKgwB,QACXzqB,OAAQvF,KAAKwW,KACbuW,YACE7gB,KAAM,YACNke,SAAUpqB,KAAK+vB,cAKdvZ,GAEXoV,GAlF+BzC,EAAAkB,aAAlB7qB,GAAAosB,UAAAA,iFCIb,SAAAqE,GAAyBzf,EAAe5M,GACtC,GAAMrE,GAAI,UAAUiR,EAAK,IACzB,IAAc,WAAV5M,EACF,MAAO,YAAYrE,EAAC,GACf,IAAc,YAAVqE,EACT,MAAO,aAAarE,EAAC,GAChB,IAAc,WAAVqE,EACT,MAAO,YAAYrE,EAAC,GACf,IAAc,SAAVqE,EACT,MAAO,UAAUrE,EAAC,GACb,IAA+B,IAA3BqE,EAAMd,QAAQ,SAAgB,CAEvC,MAAO,aAAavD,EAAC,KADHqE,EAAMyC,MAAM,EAAGzC,EAAM5C,OAAS,GACb,KAGnC,MADAiP,GAAIgB,KAAKhB,EAAI1L,QAAQ2rB,kBAAkBtsB,IAChC,uEA3BXke,EAAAphB,EAAA,kBACAghB,EAAAhhB,EAAA,kBACAyvB,EAAAzvB,EAAA,gBACAuP,EAAAvP,EAAA,aACA0vB,EAAA1vB,EAAA,mBACAwd,EAAAxd,EAAA,cACA6Z,EAAA7Z,EAAA,cAEAomB,EAAApmB,EAAA,YACAyoB,EAAAzoB,EAAA,cAsBAisB,EAAA,SAAA5F,GAOE,QAAA4F,GAAY/oB,GAAZ,GAAAojB,GACED,EAAAhmB,KAAAf,OAAOA,WAPDgnB,GAAAqJ,UASNrJ,EAAKqJ,OAASzsB,IAqGlB,MA/G+B0hB,GAAAre,UAAA0lB,EAAA5F,GAGtB4F,EAAAjpB,UAAA6lB,MAAP,WACE,MAAO,IAAIoD,GAAUpS,EAAAiP,UAAUxpB,KAAK4D,SASxB+oB,EAAAlD,KAAd,SAAmB7L,GACjB,GAAMha,MAEA0sB,EAAe1S,EAAM2S,WAAW5iB,OAAOyiB,EAAAI,aAAarR,OAAO,SAACsR,EAAU/B,GAE1E,MADA+B,GAAS/B,EAAQK,KAAM,EAChB0B,MAIT7S,GAAM2S,WAAW5iB,OAAOyiB,EAAAM,UAAUne,QAAQ,SAACwa,GACzC,GAAIpf,GAASof,EAAUpf,MAClB4M,GAAA7X,QAAQiL,KACXA,GAAUA,IAEZA,EAAO4E,QAAQ,SAAAhT,GACb,GAAIoxB,GAA4C,IAI5CR,GAAAS,cAAcrxB,GAChBoxB,EAAMpxB,EAAEsxB,MACCV,EAAAW,cAAcvxB,GACvBoxB,EAAMpxB,EAAEwxB,MAAM,GACLZ,EAAAa,cAAczxB,KACvBoxB,GAAOpxB,EAAE0xB,OAAS1xB,EAAM,IAAG,IAGzBoxB,IACE7O,EAAAC,WAAW4O,GACb/sB,EAAMrE,EAAS,OAAK,OACXgb,EAAA1H,SAAS8d,GAClB/sB,EAAMrE,EAAS,OAAK,SACXgb,EAAAvK,SAAS2gB,KAClB/sB,EAAMrE,EAAS,OAAK,eAMxBqe,YAAiBkJ,GAAAoK,gBAEnBtT,EAAM+L,gBAAgB,SAAA5L,GACpB,GAAIA,EAAS7R,OAASgS,EAAAC,SACpBva,EAAMma,EAASvN,OAAS,WACnB,IAAIuN,EAAS7R,OAASgS,EAAAkG,aAAc,CACzC,GAAI1C,EAAAyP,QAAQpT,IAAauS,EAAavS,EAASvN,OAC7C,MAEF5M,GAAMma,EAASvN,OAAS,WAM9B,IAAMgG,GAAOoH,EAAMpH,IACnB,IAAIA,GAAQA,EAAKgI,QAAUhI,EAAKgI,OAAO5a,MAAO,CAC5C,GAAMwtB,GAAI5a,EAAKgI,OAAO5a,KACtB2W,GAAAvX,KAAKouB,GAAG7e,QAAQ,SAAC/B,GACf5M,EAAM4M,GAAS4gB,EAAE5gB,KAIrB,MAA2B,KAAvB+J,EAAAvX,KAAKY,GAAO5C,OACP,KAGF,GAAI2rB,GAAU/oB,IAGvBJ,OAAA+F,eAAWojB,EAAAjpB,UAAA,aAAX,WACE,MAAO1D,MAAKqwB,wCAIP1D,EAAAjpB,UAAAqP,MAAP,SAAa+W,GACX9pB,KAAKqwB,OAAS9V,EAAA3I,OAAO5R,KAAKqwB,OAAQvG,EAAMlmB,OACxCkmB,EAAME,UAGD2C,EAAAjpB,UAAAopB,oBAAP,WACE,MAAO9sB,MAAKqwB,QAGP1D,EAAAjpB,UAAAspB,mBAAP,WAAA,GAAAhG,GAAAhnB,IACE,OAAOwD,QAAOR,KAAKhD,KAAKqwB,QAAQ7iB,IAAI,SAAAgD,GAClC,GAAMwT,GAAOiM,EAAgBzf,EAAOwW,EAAKqJ,OAAO7f,GAChD,OAAKwT,IAKH9X,KAAM,UACN8X,KAAIA,EACJ+K,GAAIve,GANG,OASR7C,OAAO,SAAAxN,GAAK,MAAM,QAANA,KAEnBwsB,GA/G+BxD,EAAAkB,aAAlB7qB,GAAAmtB,UAAAA,6QC/Bb3P,EAAAtc,EAAA,eACA6Z,EAAA7Z,EAAA,cAGAyoB,EAAAzoB,EAAA,cAEA8pB,EAAA,SAAAzD,GAOE,QAAAyD,GAAY7c,GAAZ,GAAAqZ,GACED,EAAAhmB,KAAAf,OAAOA,WAEPgnB,GAAKqK,QAAU1jB,IAoCnB,MA9C2C2X,GAAAre,UAAAujB,EAAAzD,GAGlCyD,EAAA9mB,UAAA6lB,MAAP,WACE,MAAO,IAAIiB,GAAsBjQ,EAAA3I,UAAW5R,KAAKqxB,WASrC7G,EAAAf,KAAd,SAAmB7L,GACjB,GAAMjQ,GAASiQ,EAAM0T,WAAWnS,OAAO,SAASoS,EAAsBvW,GACpE,GAAMmF,GAAQvC,EAAMuC,MAAMnF,EAC1B,OAAKmF,IAAUvC,EAAMpN,MAAMwK,IAI3BuW,EAAqB3T,EAAMpN,MAAMwK,IAAYmF,EAAMjU,OAAS8Q,EAAAwU,UAAUC,IAC/DF,GAHEA,MAMX,OAAK/tB,QAAOR,KAAK2K,GAAQ3M,OAIlB,GAAIwpB,GAAsB7c,GAHxB,MAMXnK,OAAA+F,eAAIihB,EAAA9mB,UAAA,cAAJ,WACE,MAAO1D,MAAKqxB,yCAGP7G,EAAA9mB,UAAAwhB,SAAP,WAAA,GAAA8B,GAAAhnB,IACE,OAAOua,GAAAvX,KAAKhD,KAAKqxB,SAAS1jB,OAAO,SAAC6C,GAEhC,MAAOwW,GAAKqK,QAAQ7gB,KACnBhD,IAAI,SAASgD,GACd,OACEtE,KAAM,SACN8X,KAAM,UAAYxT,EAAQ,aAIlCga,GA9C2CrB,EAAAkB,aAA9B7qB,GAAAgrB,sBAAAA,kKCLbtM,EAAAxd,EAAA,cACA6Z,EAAA7Z,EAAA,cAIAyoB,EAAAzoB,EAAA,cAGMgxB,GACJC,SAAS,EACTC,SAAS,EACTC,cAAc,EACdC,UAAU,GAGZnH,EAAA,SAAA5D,GAOE,QAAA4D,GAAY9a,GAAZ,GAAAmX,GACED,EAAAhmB,KAAAf,OAAOA,WAEPgnB,GAAK+K,gBAAkBliB,IA4D3B,MAtEoCyV,GAAAre,UAAA0jB,EAAA5D,GAG3B4D,EAAAjnB,UAAA6lB,MAAP,WACE,MAAO,IAAIoB,GAAepQ,EAAAiP,UAAUxpB,KAAK+xB,mBAS7BpH,EAAAlB,KAAd,SAAmB7L,GACjB,GAAM/N,GAAS+N,EAAMgR,eAAe,SAACoD,EAAoCjU,GAWvE,MAV2B,UAAvBA,EAASsG,YACPzG,EAAMK,OAAOgU,mBACiBxvB,KAA/Bmb,EAAMK,OAAOgU,eAAgClU,EAASvN,OAASkhB,EAAqB3T,EAAS7R,MAC9F8lB,EAAWjU,EAASvN,OAASuN,EAI7BiU,EAAWjU,EAASvN,OAAS,MAG1BwhB,MAGT,OAAmC,KAA/BxuB,OAAOR,KAAK6M,GAAQ7O,OACf,KAGF,GAAI2pB,GAAe9a,IAG5BrM,OAAA+F,eAAIohB,EAAAjnB,UAAA,sBAAJ,WACI,MAAO1D,MAAK+xB,iDAGTpH,EAAAjnB,UAAAqP,MAAP,SAAa+W,GAAb,GAAA9C,GAAAhnB,KACQG,EAAIqD,OAAOR,KAAKhD,KAAK+xB,iBAAiBvkB,IAAI,SAAA5H,GAAK,MAAAA,GAAI,IAAM2U,EAAA2X,KAAKlL,EAAK+K,gBAAgBnsB,MACnFrF,EAAIiD,OAAOR,KAAK8mB,EAAMc,gBAAgBpd,IAAI,SAAA5H,GAAK,MAAAA,GAAI,IAAM2U,EAAA2X,KAAKpI,EAAMc,eAAehlB,KAEpF2U,GAAA4X,YAAYhyB,EAAGI,KAClBP,KAAK+xB,gBAAkBxX,EAAA3I,OAAO5R,KAAK+xB,gBAAiBjI,EAAMiI,iBAC1DjI,EAAME,WAIHW,EAAAjnB,UAAAwhB,SAAP,WAAA,GAAA8B,GAAAhnB,KACQoyB,EAAU7X,EAAAvX,KAAKhD,KAAK+xB,iBAAiB5S,OAAO,SAACkT,EAAU7hB,GAC3D,GAAMuN,GAAWiJ,EAAK+K,gBAAgBvhB,EAUtC,OATiB,QAAbuN,IACFsU,EAASxvB,KAAK,UAAYkb,EAASvN,MAAQ,eACvC+J,EAAAmC,UAAUwB,EAAAkG,aAAclG,EAAAC,UAAWJ,EAAS7R,OAI9CmmB,EAASxvB,KAAK,iBAAkBkb,EAASvN,MAAQ,QAG9C6hB,MAGT,OAAOD,GAAQpxB,OAAS,GAEpBkL,KAAM,SACN8X,KAAMoO,EAAQ3wB,KAAK,SACjB,MAEVkpB,GAtEoCxB,EAAAkB,aAAvB7qB,GAAAmrB,eAAAA,8FCCb,SAAAiD,GAAkCruB,GAChC,QAAA+yB,GAAgCxwB,GAC9B,KAAIA,YAAgB8qB,GAAAC,YAApB,CAIA,GAAMroB,GAAO1C,EAAKM,MACd7C,GAAEuC,IACJwwB,EAAuB9tB,IAI3B,MAAO8tB,GAMT,QAAAvE,GAA4BjsB,GAC1B,GAAMM,GAASN,EAAKM,MAGpB,IAAIN,YAAgB4qB,GAAAC,UAAW,CAC7B,GAAIvqB,YAAkBwqB,GAAAC,WACpB,OAAO,CAGT,IAAIzqB,EAAOypB,cAAgB,EACzB,OAAO,CAGLzpB,aAAkBsqB,GAAAC,UACpBvqB,EAAO2Q,MAAMjR,GAEbA,EAAKkqB,iBAIT,OAAO,EAOT,QAAA8B,GAAqChsB,GACpBA,EAAKM,MAEpB,SAAIN,YAAgBqnB,GAAA0B,YAAc/oB,EAAK+pB,cAAgB,KAIrD/pB,EAAKkoB,UAEA,mDApET,IAAAb,GAAAzoB,EAAA,cAEAgsB,EAAAhsB,EAAA,iBAEAksB,EAAAlsB,EAAA,WAUAlB,GAAAouB,kBAAAA,EAkBApuB,EAAAuuB,YAAAA,EA2BAvuB,EAAAsuB,qBAAAA,uFC3CA,SAAAyE,GAAmB3U,EAAcmK,GAC/B,GAAInK,EAAMpH,OAASoH,EAAMxb,OAAQ,CAE/B,GAAMmD,GAAS,GAAIqnB,GAAAC,WAAWjP,GACxBsU,EAAO3sB,EAAO2sB,MACpB,OAAIA,KAAQnK,GAEHA,EAAQmK,IAGfnK,EAAQmK,GAAQ3sB,EACTA,GAIT,MAAOqY,GAAMxb,OAAOglB,UAAU5Q,KAAKgc,UAAY5U,EAAMxb,OAAOglB,UAAU5Q,KAAKgc,UAAY5U,EAAMxb,OAAOglB,UAAU5Q,KAAKpB,KA2DvH,QAAA+R,GAA0BvJ,GACxB,GAAMxV,GAAOmqB,EAAU3U,EAAOA,EAAMwJ,UAAU5Q,KAAKuR,SAE7CuD,EAAc1N,EAAMwJ,UAAU5Q,KAAK8U,YAGrCmH,EAAOrqB,EAELxE,EAAQ8oB,EAAAC,UAAUlD,KAAK7L,EAM7B,IALIha,IACFA,EAAMxB,OAASgG,EACfqqB,EAAO7uB,GAGLga,EAAM2S,WAAWvvB,OAAS,EAAG,CACzB,GAAAmlB,GAAA+G,EAAAwF,oBAAA9U,GAAC+U,EAAAxM,EAAAwM,MAAOC,EAAAzM,EAAAyM,IACdD,GAAMvwB,OAASqwB,EACfA,EAAOG,EAGT,GAAIhV,YAAiBkJ,GAAAoK,eAAgB,CACnC,GAAM2B,GAAanI,EAAAC,eAAelB,KAAK7L,EACnCiV,KACFA,EAAWzwB,OAASqwB,EACpBA,EAAOI,EAGT,IAAMvd,GAAM+X,EAAAC,QAAQ7D,KAAK7L,EACrBtI,KACFA,EAAIlT,OAASqwB,EACbA,EAAOnd,EAGT,IAAMwd,GAAKvO,EAAAgJ,aAAa9D,KAAK7L,EACzBkV,KACFA,EAAG1wB,OAASqwB,EACZA,EAAOK,GAKX,GAAMC,GAAUnV,EAAMmI,QAAQkG,EAAA+G,KACxBC,EAAM,GAAI9J,GAAA0B,WAAWkI,EAAS9G,EAAA+G,IAKpC,IAJA1H,EAAYyH,GAAWE,EACvBA,EAAI7wB,OAASqwB,EACbA,EAAOQ,EAEHrV,YAAiBoF,GAAAC,UAAW,CAC9B,GAAMiQ,GAAM1H,EAAApC,cAAcK,KAAK7L,EAC3BsV,KACFA,EAAI9wB,OAASqwB,EACbA,EAAOS,EAGT,IAAMC,GAAQ1H,EAAAC,UAAUjC,KAAK7L,EACzBuV,KACFA,EAAM/wB,OAASqwB,EACfA,EAAOU,EAGT,IAAMC,GAAe7I,EAAAC,sBAAsBf,KAAK7L,EAC5CwV,KACFA,EAAahxB,OAASqwB,EACtBA,EAAOW,GAIX,GAAIxV,YAAiBoF,GAAAC,UAAW,CAC9B,GAAM2B,GAAQqG,EAAAC,UAAUzB,KAAK7L,EACzBgH,KACFA,EAAMxiB,OAASqwB,EACfA,EAAO7N,GAKX,GAAMyO,GAAWzV,EAAMmI,QAAQkG,EAAAC,MACzB9W,EAAO,GAAI+T,GAAA0B,WAAWwI,EAAUpH,EAAAC,KACtCZ,GAAY+H,GAAYje,EACxBA,EAAKhT,OAASqwB,EACdA,EAAOrd,CAGP,IAAIod,GAAY,IAChB,IAAI5U,YAAiB8E,GAAAC,WAAY,CAC/B,GAAM2Q,GAAY1V,EAAMmI,QAAQ,QAChCyM,GAAY,GAAIe,GAAA3H,UAAUhO,EAAO0V,EAAWle,EAAK7P,QACjD+lB,EAAYgI,GAAad,EACzBA,EAAUpwB,OAASqwB,EACnBA,EAAOD,EAGT,OACEzK,QAASnK,EAAMwJ,UAAU5Q,KAAKuR,QAC9BuD,YAAWA,EACXlW,KAAIA,EACJod,UAASA,mDA7Lb,IAAAvG,GAAAvrB,EAAA,cAEAgiB,EAAAhiB,EAAA,YACAomB,EAAApmB,EAAA,YACAsiB,EAAAtiB,EAAA,WACA8qB,EAAA9qB,EAAA,eACA2sB,EAAA3sB,EAAA,SACAyoB,EAAAzoB,EAAA,cACA6yB,EAAA7yB,EAAA,WACAgsB,EAAAhsB,EAAA,iBAEA6pB,EAAA7pB,EAAA,uBACAgqB,EAAAhqB,EAAA,gBACAuqB,EAAAvqB,EAAA,eACAksB,EAAAlsB,EAAA,YACA+qB,EAAA/qB,EAAA,WACA6jB,EAAA7jB,EAAA,cACAwsB,EAAAxsB,EAAA,eA4EAlB,GAAA2nB,UAAAA,uWC7FAqM,EAAA9yB,EAAA,kBACAghB,EAAAhhB,EAAA,kBACA+yB,EAAA/yB,EAAA,cACA6Z,EAAA7Z,EAAA,cAGA2d,EAAA3d,EAAA,aAEAyoB,EAAAzoB,EAAA,cAEAwqB,EAAA,SAAAnE,GAKE,QAAAmE,GAAoBhoB,GAApB,GAAA8jB,GACED,EAAAhmB,KAAAf,OAAOA,WADWgnB,GAAA9jB,KAAAA,IA0CtB,MA/C+BoiB,GAAAre,UAAAikB,EAAAnE,GACtBmE,EAAAxnB,UAAA6lB,MAAP,WACE,MAAO,IAAI2B,GAAU3Q,EAAAiP,UAAUxpB,KAAKkD,QAOxBgoB,EAAAzB,KAAd,SAAmB7L,GACjB,GAAI1a,GAAe,IAEnB,KAAIqX,EAAAmC,UAAU,OAAQ,QAASkB,EAAMjC,QAuBnC,MAAO,KAtBP,IAAqB,SAAjBiC,EAAMjC,QAAqBiC,EAAM8V,gBAAgB,SAEnDxwB,EAAOmb,EAAAoG,WAAW7G,EAAM+V,SAAS/O,WAC5B,CAEL,GAAMgP,GAAuD,eAAzBhW,EAAMiW,QAAQ9U,OAA0B,IAAM,IAC5Eze,EAAIsd,EAAM1a,KAAK0wB,EAUrB1wB,IACEsN,MAVgBijB,EAAAK,YAAYxzB,GAC5BohB,EAAAlR,OAGE6T,UAAWmP,EAAA9J,YAAY9L,EAAM+V,UAAYrzB,EAAEqK,OAAKlI,GAChD+N,MAAOlQ,EAAEkQ,QAEXoN,EAAMpN,MAAMojB,GAAmB1P,UAAW,UAI1CU,MAAO,cAOb,MAAO,IAAIsG,GAAUhoB,IAGhBgoB,EAAAxnB,UAAAwhB,SAAP,WACE,OACEhZ,KAAM,UACNhJ,KAAMlD,KAAKkD,OAGjBgoB,GA/C+B/B,EAAAkB,aAAlB7qB,GAAA0rB,UAAAA,wNCVbe,EAAAvrB,EAAA,cACA6Z,EAAA7Z,EAAA,cAGAyoB,EAAAzoB,EAAA,cAEAmsB,EAAA,SAAA9F,GAKE,QAAA8F,GAAYjP,GAAZ,GAAAoJ,GACED,EAAAhmB,KAAAf,OAAOA,KAEDwW,EAAOoH,EAAMpH,OAASlS,KAAM,SAElC,IAAI2nB,EAAA8H,aAAavd,GACfwQ,EAAKgN,OACH9S,OAAQ1K,EAAK0K,OACb1C,QAAStS,KAAM,aAEZ,IAAI+f,EAAAgI,UAAUzd,GAAO,CAG1B,GAAI0d,GAAmB,kBAAkBC,KAAK3d,EAAKwB,KAAK,EACnDuC,GAAAmC,UAAU,OAAQ,MAAO,MAAO,YAAawX,KAChDA,EAAmB,OAErB,IAAME,GAAa5d,EAAKgI,WAGlB6V,EAAyBD,EAAWloB,MAAQsK,EAAiB,WAC5D8J,EAAA8T,EAAA9T,SAAUgU,EAAAF,EAAAE,QAASC,EAAAH,EAAAG,KAEpB/V,EAAM8G,EAAApe,UACVgF,KAAMmoB,GAA0BH,GAC5B5T,GAAYA,SAAQA,MACpBgU,GAAWA,QAAOA,MAClBC,GAAQA,KAAIA,MAGlBvN,GAAKgN,OACHhc,IAAKxB,EAAKwB,IACVwG,OAAMA,OAECyN,GAAAuI,YAAYhe,KACrBwQ,EAAKyN,MAAQje,EAAKlS,KAClB0iB,EAAKgN,mBAgDX,MAzFgC1O,GAAAre,UAAA4lB,EAAA9F,GA6C9BvjB,OAAA+F,eAAIsjB,EAAAnpB,UAAA,YAAJ,WACE,MAAO1D,MAAKg0B,uCAGPnH,EAAAnpB,UAAAuqB,QAAP,WACE,QAASjuB,KAAKy0B,OAGhBjxB,OAAA+F,eAAIsjB,EAAAnpB,UAAA,gBAAJ,WACE,MAAO1D,MAAKy0B,WAGd,SAAanwB,GACXtE,KAAKy0B,MAAQnwB,mCAGfd,OAAA+F,eAAIsjB,EAAAnpB,UAAA,cAAJ,SAAWtB,GACT,KAAM,IAAIxB,OAAM,mEAGXisB,EAAAnpB,UAAAsmB,OAAP,WACE,KAAM,IAAIppB,OAAM,kDAMXisB,EAAAnpB,UAAAwuB,KAAP,WACE,MAAIjG,GAAA8H,aAAa/zB,KAAKg0B,OACbzZ,EAAA2X,KAAKlyB,KAAKg0B,OACR/H,EAAAgI,UAAUj0B,KAAKg0B,OACdh0B,KAAKg0B,MAAMhc,IAAG,IAAIuC,EAAA2X,KAAKlyB,KAAKg0B,MAAMxV,QAErCxe,KAAKy0B,OAIT5H,EAAAnpB,UAAAwhB,SAAP,WACE,MAAMI,GAAApe,UACJ5C,KAAMtE,KAAKy0B,OACRz0B,KAAKg0B,OACRjH,gBAGNF,GAzFgC1D,EAAAkB,aAAnB7qB,GAAAqtB,WAAAA,8FCIb,SAAA6H,GAA0B9W,GACxB,MAAOA,GAAMuV,MAAMwB,QAAQxV,OAAO,SAACtP,EAAQ+kB,GACzC,GAAM5Z,GAAU4Z,EAAG5Z,QACb+C,EAAW6W,EAAG7W,SAEdoC,EAAQvC,EAAMuC,MAAMnF,GACpB6Z,EAASnT,EAAAlR,MAAMuN,GACnBmG,UAAW/D,GAASnD,EAAAsE,kBAAkBnB,EAAMjU,MAAQ,QAAU,SAKhE,OAHI2oB,IACFhlB,EAAOhN,KAAKgyB,GAEPhlB,yEAtBXilB,EAAAp0B,EAAA,aACAghB,EAAAhhB,EAAA,kBACAsc,EAAAtc,EAAA,eAEA6Z,EAAA7Z,EAAA,cAEA2d,EAAA3d,EAAA,aAEAyoB,EAAAzoB,EAAA,cAgDAgrB,EAAA,SAAA3E,GAOE,QAAA2E,GAAYyH,GAAZ,GAAAnM,GACED,EAAAhmB,KAAAf,OAAOA,WAEPgnB,GAAK+N,OAAS5B,IA8GlB,MAxH+B7N,GAAAre,UAAAykB,EAAA3E,GAGtB2E,EAAAhoB,UAAA6lB,MAAP,WACE,MAAO,IAAImC,GAAUnR,EAAAiP,UAAUxpB,KAAK+0B,UASxBrJ,EAAAjC,KAAd,SAAmB7L,GAEjB,GAAMoX,GAAkBpX,EAAMuV,KAE9B,KAAK6B,EACH,MAAO,KAGT,IAAM5K,KACN,IAAI4K,EAAgBC,eAAgB,CACVrX,EAAMG,SAASiX,EAAgBC,gBACnC3f,KAGlB8U,EAAQvnB,KAAK+a,EAAMpN,MAAMwkB,EAAgBC,gBAAiB/Q,UAAW,WACrEkG,EAAQvnB,KAAK+a,EAAMpN,MAAMwkB,EAAgBC,gBAAiB/Q,UAAW,UAErEkG,EAAQvnB,KAAK+a,EAAMpN,MAAMwkB,EAAgBC,iBAI7C,GAGI/xB,GAHEgyB,EAAUR,EAAiB9W,GAC3B8G,EAAW9G,EAAM+V,SAAS/O,KAehC,OAXE1hB,GADEwhB,EACKrG,EAAAoG,WAAWC,GAIXwQ,EAAQ/V,OAAO,SAAC7e,EAAGkQ,GAGxB,MAFAlQ,GAAEkQ,MAAM3N,KAAK2N,GACblQ,EAAEskB,MAAM/hB,KAAK,cACNvC,IACLkQ,SAAUoU,WAGT,GAAI8G,IACTtB,QAAOA,EACP5Z,MAAOoN,EAAMpN,MAAMwkB,EAAgBG,cACnCD,QAAOA,EACPhyB,KAAIA,EACJqlB,OAAQyM,EAAgBzM,OACxB6M,OAAQ7a,EAAAmC,UAAU,OAAQ,QAASkB,EAAMjC,WAI7CnY,OAAA+F,eAAImiB,EAAAhoB,UAAA,aAAJ,WACE,MAAO1D,MAAK+0B,wCAGPrJ,EAAAhoB,UAAAumB,cAAP,SAAqBpa,GACnB7P,KAAK+0B,OAAO3K,QAAUpqB,KAAK+0B,OAAO3K,QAAQ5e,OAAOqE,IAG5C6b,EAAAhoB,UAAAwmB,gBAAP,WACE,GAAMvnB,KAENA,GAAI3C,KAAK+0B,OAAOvkB,QAAS,EACzBxQ,KAAK+0B,OAAO3K,QAAQ7X,QAAQ,SAAAhT,GAAK,MAAAoD,GAAIpD,IAAK,GAC1C,IAAMiR,GAAQxQ,KAAK+0B,OAAO7xB,KAAKsN,KAG/B,OAFAskB,GAAApyB,QAAQ8N,GAASA,EAAM+B,QAAQ,SAAAhT,GAAK,MAAAoD,GAAIpD,IAAK,IAAQoD,EAAI6N,IAAS,EAE3D7N,GAGF+oB,EAAAhoB,UAAAymB,eAAP,WACE,GAAMxnB,KAKN,OAHAA,GAAI3C,KAAK+0B,OAAOvkB,MAAQ,WAAY,EACpC7N,EAAI3C,KAAK+0B,OAAOvkB,MAAQ,SAAU,EAE3B7N,GAGF+oB,EAAAhoB,UAAAwhB,SAAP,WACE,GAAM6H,MAEAoG,EAAQnzB,KAAK+0B,MA2BnB,OAxBI5B,GAAMiC,QACRrI,EAAUlqB,MACRqJ,KAAM,SACNsE,MAAO2iB,EAAM3iB,MACb4Z,QAAS+I,EAAM+B,QACfG,QAASlC,EAAM/I,QACfla,OAAQ,QACRrO,MAAO,IAKXkrB,EAAUlqB,MACRqJ,KAAM,QACNke,QAAS+I,EAAM/I,QACf5Z,MAAO2iB,EAAM3iB,MACbtN,KAAMiwB,EAAMjwB,KACZ6rB,IACEoE,EAAM3iB,MAAQ,SACd2iB,EAAM3iB,MAAQ,QAEhB+X,OAAQ4K,EAAM5K,SAGTwE,GAEXrB,GAxH+BvC,EAAAkB,aAAlB7qB,GAAAksB,UAAAA,mNCvDbhK,EAAAhhB,EAAA,kBACA6jB,EAAA7jB,EAAA,kBACAwd,EAAAxd,EAAA,cACA6Z,EAAA7Z,EAAA,cAIAyoB,EAAAzoB,EAAA,cASA6sB,EAAA,SAAAxG,GAKE,QAAAwG,GAAoBmB,GAApB,GAAA1H,GACED,EAAAhmB,KAAAf,OAAOA,WADWgnB,GAAA0H,QAAAA,IA0DtB,MA/DkCpJ,GAAAre,UAAAsmB,EAAAxG,GACzBwG,EAAA7pB,UAAA6lB,MAAP,WACE,MAAO,IAAIgE,GAAahT,EAAAiP,UAAUxpB,KAAK0uB,WAO3BnB,EAAA9D,KAAd,SAAmB7L,GACjB,GAAM8Q,GAAU9Q,EAAMgR,eAAe,SAAC0G,EAAsCvX,GAC1E,GAAIA,EAAS7R,OAASgS,EAAAC,UAAYJ,EAASQ,SAAU,CACnD,GAAMhf,GAAImiB,EAAAlR,MAAMuN,EAChBuX,GAAkB/1B,IAChBwvB,GAAIxvB,EACJgf,SAAUR,EAASQ,SACnB/N,MAAOuN,EAASvN,OAGpB,MAAO8kB,OAGT,OAAoC,KAAhC9xB,OAAOR,KAAK0rB,GAAS1tB,OAChB,KAGF,GAAIusB,GAAamB,IAGnBnB,EAAA7pB,UAAAqP,MAAP,SAAa+W,GACX9pB,KAAK0uB,QAAUnU,EAAA3I,OAAO5R,KAAK0uB,QAAS5E,EAAM4E,SAC1C5E,EAAME,UAGDuD,EAAA7pB,UAAAymB,eAAP,WACE,GAAMxnB,KAMN,OAJA4X,GAAAsH,KAAK7hB,KAAK0uB,SAASnc,QAAQ,SAAAhT,GACzBoD,EAAIpD,EAAEwvB,KAAM,IAGPpsB,GAGF4qB,EAAA7pB,UAAAwmB,gBAAP,WACE,GAAMvnB,KAMN,OAJA4X,GAAAsH,KAAK7hB,KAAK0uB,SAASnc,QAAQ,SAAAhT,GACzBoD,EAAIpD,EAAEiR,QAAS,IAGV7N,GAGF4qB,EAAA7pB,UAAAwhB,SAAP,WACE,MAAO3K,GAAAsH,KAAK7hB,KAAK0uB,SAASlhB,IAAI,SAAA/I,GAC5B,OACEyH,KAAM,UACN6iB,GAAItqB,EAAEsqB,GACN/K,KAAMO,EAAAgR,UAAU9wB,EAAE8Z,SAAU9Z,EAAE+L,WAItC+c,GA/DkCpE,EAAAkB,aAArB7qB,GAAA+tB,aAAAA,sIC+Cb,SAAAmF,GAAoC9U,GAClC,GAAI+U,GACAC,EACA9wB,EACAoG,CAsBJ,OApBA0V,GAAM2S,WAAWhe,QAAQ,SAACpS,EAAGQ,GAC3B,GAAIyvB,EAAAI,YAAYrwB,GACd2B,EAAO,GAAIsrB,GAAcjtB,OACpB,CAAA,IAAIiwB,EAAAM,SAASvwB,GAIlB,WADA8P,GAAIgB,KAAKhB,EAAI1L,QAAQixB,wBAAwBr1B,GAF7C2B,GAAO,GAAIqrB,GAAWhtB,EAAEwN,QAMhB,IAANhN,EACFgyB,EAAQ7wB,EAERA,EAAKM,OAAS8F,EAEhBA,EAAWpG,IAGb8wB,EAAO9wB,GAEC6wB,MAAKA,EAAEC,KAAIA,qEA1FrBkC,EAAAp0B,EAAA,aACAyvB,EAAAzvB,EAAA,gBACAuP,EAAAvP,EAAA,aACA0vB,EAAA1vB,EAAA,mBACA6Z,EAAA7Z,EAAA,cAGAyoB,EAAAzoB,EAAA,cAGAysB,EAAA,SAAApG,GAKE,QAAAoG,GAAoBxf,GAApB,GAAAqZ,GACED,EAAAhmB,KAAAf,OAAOA,WADWgnB,GAAArZ,OAAAA,IAiBtB,MAtBgC2X,GAAAre,UAAAkmB,EAAApG,GACvBoG,EAAAzpB,UAAA6lB,MAAP,WACE,MAAO,IAAI4D,GAAW5S,EAAAiP,UAAUxpB,KAAK2N,UAOhCwf,EAAAzpB,UAAAqP,MAAP,SAAa+W,GACX9pB,KAAK2N,QAAUmnB,EAAApyB,QAAQ1C,KAAK2N,QAAU3N,KAAK2N,QAAU3N,KAAK2N,SAASnC,OACjEspB,EAAApyB,QAAQonB,EAAMnc,QAAUmc,EAAMnc,QAAUmc,EAAMnc,SAEhD3N,KAAKgqB,UAGAmD,EAAAzpB,UAAAwhB,SAAP,WACE,OACEhZ,KAAM,SACN8X,KAAMmM,EAAAsF,WAAWz1B,KAAK2N,UAG5Bwf,GAtBgChE,EAAAkB,aAAnB7qB,GAAA2tB,WAAAA,CA2Bb,IAAAC,GAAA,SAAArG,GAKE,QAAAqG,GAAoBL,GAApB,GAAA/F,GACED,EAAAhmB,KAAAf,OAAOA,WADWgnB,GAAA+F,UAAAA,IAiBtB,MAtBmCzH,GAAAre,UAAAmmB,EAAArG,GAC1BqG,EAAA1pB,UAAA6lB,MAAP,WACE,MAAO,IAAI6D,GAAc7S,EAAAiP,UAAUxpB,KAAK+sB,aAOnCK,EAAA1pB,UAAAymB,eAAP,WACE,GAAMxnB,KAEN,OADAA,GAAI3C,KAAK+sB,UAAUgC,KAAM,EAClBpsB,GAGFyqB,EAAA1pB,UAAAwhB,SAAP,WACE,OACEhZ,KAAM,UACN8X,KAAMhkB,KAAK+sB,UAAU2I,UACrB3G,GAAI/uB,KAAK+sB,UAAUgC,KAGzB3B,GAtBmCjE,EAAAkB,aAAtB7qB,GAAA4tB,cAAAA,EA2Bb5tB,EAAAkzB,oBAAAA,kJCgQA,SAAAiD,GAAiC/X,GAC/B,MAAOA,GAAMgY,gCAAgC,MAC3ChY,EAAMgY,gCAAgC,KAG1C,QAAAC,GAAoCjY,EAAmBkY,GACrD,MAAM3P,MAAEA,EAAC2P,GAAWlY,EAAMnL,MAAMkW,iBAAiBmN,GAAS3P,QAI5D,QAAA4P,GAAiCnY,GAC/B,GAAMnL,GAAQmL,EAAMnL,KAEpB,OAAM6S,GAAApe,YACD2uB,EAA2BjY,EAAO,SAClCiY,EAA2BjY,EAAO,UAGjC+X,EAAiB/X,GAASnL,EAAMkU,mCAEjCtI,EAAAoF,eAAgB7F,EAAMK,OAAO+M,MAAMgL,KAAMC,EAAAC,mBAAmB1qB,QAAQ,6EApV3EyP,EAAAva,EAAA,cAGA8yB,EAAA9yB,EAAA,eAEAghB,EAAAhhB,EAAA,eACAuP,EAAAvP,EAAA,UACAu1B,EAAAv1B,EAAA,WAGA6Z,EAAA7Z,EAAA,WAEAy1B,EAAAz1B,EAAA,kBAWA2d,EAAA3d,EAAA,YACAkmB,EAAAlmB,EAAA,mBACAmmB,EAAAnmB,EAAA,gBACA01B,EAAA11B,EAAA,mBAEAomB,EAAApmB,EAAA,WACAyiB,EAAAziB,EAAA,YAIAiiB,EAAA,SAAAoE,GAOE,QAAApE,GAAYN,EAAiBjgB,EAAekgB,EAAyBC,EAAyBtE,GAA9F,GAAA+I,GACED,EAAAhmB,KAAAf,KAAMqiB,EAAMjgB,EAAQkgB,EAAiBrE,IAAOje,IAE5CgnB,GAAKvU,MAAQ4L,EAAA+D,WAAWC,EAAKA,KAAM2E,EAAMA,EAAKjB,QAAQ,SAAUxD,EAAUtE,GAC1E+I,EAAKC,UAAYD,EAAKvU,MAEtB,IAAMuY,GAAuB7H,EAAAkT,uBAAuBhU,EAAK2I,MAAOzI,SAEhEyE,GAAKgE,MAAQhE,EAAKsP,UAAUtL,KA8QhC,MA7RgC1F,GAAAre,UAAA0b,EAAAoE,GAkBtBpE,EAAAjf,UAAA4yB,UAAR,SAAkBtL,GAEhB,MAAOwI,GAAArU,OAAO6L,EAAO,SAASuL,EAAiBxY,EAA4B/C,GACzE,MAAKT,GAAAmC,UAAUzB,EAAAC,IAAKD,EAAAE,QAASH,OAMNvY,KAAnBsb,EAASvN,OACXP,EAAIgB,KAAKhB,EAAI1L,QAAQiyB,cAAczY,EAAU/C,IACtCub,IAITA,EAAgBvb,GAAW0G,EAAAuD,UAAUlH,EAAU/C;0BACxCub,IAXLtmB,EAAIgB,KAAKhB,EAAI1L,QAAQkyB,oBAAoBzb,EAAS,UAC3Cub,SAcN5T,EAAAjf,UAAAgwB,gBAAP,SAAuB1Y,GACrB,QAAShb,KAAKgrB,MAAMhQ,IAGf2H,EAAAjf,UAAA4d,kBAAP,SAAyBtG,GACvB,OAAO,GAGF2H,EAAAjf,UAAAqa,SAAP,SAAgB/C,GACd,MAAOhb,MAAKgrB,MAAMhQ,IAGb2H,EAAAjf,UAAAyjB,UAAP,WACEnnB,KAAKonB,UAAU5Q,KAAOqQ,EAAAM,UAAUnnB,MAChCA,KAAKyS,MAAM0U,aAGNxE,EAAAjf,UAAA2jB,eAAP,WAIErnB,KAAKyS,MAAM4U,iBACXrnB,KAAKonB,UAAUE,UAAYtnB,KAAKyS,MAAM2U,UAAUE,WAG3C3E,EAAAjf,UAAA8jB,WAAP,WAAA,GAAAR,GAAAhnB,KACQyS,EAAQzS,KAAKyS,MACbmL,EAAQ5d,IAEdyS,GAAM+U,YAEN,IAAMkP,GAAiB12B,KAAKonB,UAAUK,SAGtClN,GAAAvX,KAAKyP,EAAM2U,UAAUK,QAAQlV,QAAQ,SAAAyI,GAGjC,GAAMmF,GAAQuW,EAAe1b,GAAWvI,EAAM2U,UAAUK,OAAOzM,GAEzD2b,EAAyBxW,EAAM7b,KAAKsyB,OAAOnkB,EAAMsT,QAAQ,IAAI/kB,QAC7DoqB,EAAUxN,EAAMwC,UAAUuW,GAAwB,EACxDlkB,GAAMokB,YAAY1W,EAAM7b,KAAM8mB,GAC9BjL,EAAM7b,KAAO8mB,CAGb,IAAMtK,GAASX,EAAMW,MAEjBqV,GAAAW,gBAAgBhW,IAAWqV,EAAAY,sBAAsBjW,GACnDA,EAAOtK,KAAOoQ,EAAAyE,mBAAqBrE,EAAKjB,QAAQjF,EAAOtK,MAC9C2f,EAAAa,uBAAuBlW,KAChCA,EAAOjR,OAASiR,EAAOjR,OAAOrC,IAAI,SAACjO,GACjC,MAAM+lB,GAAApe,YACD3H,GACHiX,KAAMoQ,EAAAyE,mBAAqBrE,EAAKjB,QAAQxmB,EAAEiX,iBAMzC/D,GAAM2U,UAAUK,OAAOzM,MAK7B2H,EAAAjf,UAAAgkB,UAAP,WACE1nB,KAAKyS,MAAMiV,YAEX1nB,KAAKonB,UAAUzL,OACbrX,KAAMtE,KAAK+lB,QAAQ,QACnB7Z,KAAM,QACN+qB,MACEjM,OACE1mB,KAAMtE,KAAKonB,UAAU5Q,KAAKgc,UAAUluB,KACpCkS,KAAMxW,KAAKonB,UAAU5Q,KAAKgc,UAAUhc,KACpC4T,WAAY5e,OACVxL,KAAK0zB,gBAAgBzY,EAAAC,MAAQlb,KAAKwQ,MAAMyK,EAAAC,SACxClb,KAAK0zB,gBAAgBzY,EAAAE,SAAWnb,KAAKwQ,MAAMyK,EAAAE,eAIjDuF,QACEC,OAAQoV,EAAwB/1B,UAK/B2iB,EAAAjf,UAAAikB,mBAAP,WACE3nB,KAAKyS,MAAMkV,qBAEX3nB,KAAKk3B,YAAY,UACjBl3B,KAAKk3B,YAAY,OAEjBl3B,KAAKm3B,eAAe,KACpBn3B,KAAKm3B,eAAe,MAGdxU,EAAAjf,UAAAwzB,YAAR,SAAoBlc,GAElB,GAAIhb,KAAK0zB,gBAAgB1Y,GAAU,CACjC,GAAM+C,GAAW/d,KAAKgrB,MAAMhQ,GACxBiG,EAAQS,EAAAT,MAAclD,EAAU/d,KAAKie,OAErCje,MAAKyS,MAAM2U,UAAUgQ,cAAcpc,GAASiG,QAE9CA,GAAS,MAAQjhB,KAAKyS,MAAM2U,UAAUgQ,cAAcpc,GAASiG,MAC7DjhB,KAAKyS,MAAM2U,UAAUgQ,cAAcpc,GAASiG,MAAQ,MAGtDjhB,KAAKonB,UAAUgQ,cAAcpc,IAC3BiG,MAAKA,EACLoW,SAAUhZ,EAAA0F,gBAAgBhG,EAAU,SAAU/d,KAAKie,QAAQ,GAE3DqZ,QAASt3B,KAAKu3B,oBAAoBvc,GAAS,OAKzC2H,EAAAjf,UAAA6zB,oBAAR,SAA4Bvc,EAAwB2C,GAClD,GAAM6Z,GAA0B,QAAZxc,EAAoB,SAAW,OAEnD,QACE2C,OAAMA,EACN8Z,WAAYz3B,KAAKyS,MAAMkW,iBAAiB6O,GACxCnY,UAIIsD,EAAAjf,UAAAyzB,eAAR,SAAuBnc,GACd,GAAAvI,GAAAzS,KAAAyS,KACP,IAAIA,EAAM2U,UAAU/H,KAAKrE,GAAU,CAU/B,IAAmB,GAHb0c,GAA4B,MAAZ1c,EAAkB,SAAW,MAE7C2c,EAAe33B,KAAKonB,UAAUgQ,cAAcM,GAC/BnQ,EAAA,EAAApB,EAAA1T,EAAM2U,UAAU/H,KAAKrE,GAASqE,KAA9BkI,EAAApB,EAAAnlB,OAAAumB,IAAkC,CAAhD,GAAMvJ,GAAImI,EAAAoB,GACPqQ,EAAaxB,EAAAyB,cAAc7Z,EAAKe,OACtC4Y,GAAaC,GAAcD,EAAaC,KACrC53B,KAAKu3B,oBAAoBG,GAAe,IAC3CC,EAAaC,GAAY,GAAGvY,KAAKxc,KAAKmb,GAExCvL,EAAM2U,UAAU/H,KAAKrE,GAASqE,UAO7BsD,EAAAjf,UAAAmkB,YAAP,WACE7nB,KAAKyS,MAAMoV,cAOX7nB,KAAKonB,UAAUU,QAAU9nB,KAAKyS,MAAM2U,UAAUU,QAC9C9nB,KAAKyS,MAAM2U,UAAUU,YAGhBnF,EAAAjf,UAAAkiB,aAAP,WACE,MAAK5lB,MAAKoC,UAEDwkB,EAAAhB,aAAarL,EAAAsH,KAAK7hB,KAAKonB,UAAU5Q,KAAKuR,WAM1CpF,EAAAjf,UAAAijB,8BAAP,WACE,MAAO,OAGFhE,EAAAjf,UAAAuiB,iCAAP,SAAwCH,GACtC,MAAO9lB,MAAKyS,MAAMwT,iCAAiCH,IAG9CnD,EAAAjf,UAAAukB,yBAAP,WACE,MAAOjoB,MAAKyS,MAAMwV,4BAGbtF,EAAAjf,UAAAmiB,sBAAP,SAA6BrP,GAC3B,MAAOxW,MAAKyS,MAAMoT,sBAAsBrP,IAGnCmM,EAAAjf,UAAA6iB,eAAP,WAOE,OACE6B,SAAUC,IAAK,GAAIC,OAAQ,IAG3BC,OAAQ,GACRC,QAXcxoB,KAAK0zB,gBAAgB,WACnCtV,OAAQpe,KAAK83B,wBACX,EAUFrP,OAAQ,SAIL9F,EAAAjf,UAAAsiB,sBAAP,WAEE,MAAOhmB,MAAKyS,MAAMuT,yBAGZrD,EAAAjf,UAAAo0B,qBAAR,WAIE,MAAO,SAFqB93B,KAAK+lB,QAAQ,UAAY,gBAC9B/lB,KAAKwQ,MAAM,UAAYunB,OAAQ,cAIjDpV,EAAAjf,UAAAglB,cAAP,WACE,GAAM8J,GAAYxyB,KAAKonB,UAAU5Q,KAAKgc,UAChChc,EAAOoQ,EAAA8G,kBAAkB8E,GAEzB7W,EAAO3b,KAAKonB,UAAUzL,KAAK,EAejC,OAZAA,GAAKsb,KAAKjM,MAAK1F,EAAApe,YACVyU,EAAKsb,KAAKjM,OACb1mB,KAAMkuB,EAAUluB,KAChBkS,KAAMgc,EAAUhc,QAGJ8O,EAAApe,YACRsP,EAAKxV,OAAS,GAAKwV,KAAMA,MAC1BmF,EACA3b,KAAKyS,MAAM2T,kBAGH5Y,IAAIxN,KAAKg4B,mBAGjBrV,EAAAjf,UAAA4tB,SAAP,WACE,OAAQrW,EAAAC,IAAKD,EAAAE,SAGLwH,EAAAjf,UAAAu0B,WAAV,WACE,MAAOj4B,MAAKgrB,OAEhBrI,GA7RgCmE,EAAAoK,eAAnB1xB,GAAAmjB,WAAAA,EA+RbnjB,EAAAm2B,iBAAAA,kUC3TAM,EAAAv1B,EAAA,WAIA6Z,EAAA7Z,EAAA,WACAy1B,EAAAz1B,EAAA,kBAEA2d,EAAA3d,EAAA,YACAkmB,EAAAlmB,EAAA,mBACAmmB,EAAAnmB,EAAA,gBACAw3B,EAAAx3B,EAAA,kBACAomB,EAAApmB,EAAA,WAEAy3B,EAAAz3B,EAAA,kBACA03B,EAAA13B,EAAA,yBAIAoiB,EAAA,SAAAiE,GAiBE,QAAAjE,GAAYT,EAAiBjgB,EAAekgB,EAAyBC,EAAyBtE,GAA9F,GAAA+I,GAEED,EAAAhmB,KAAAf,KAAMqiB,EAAMjgB,EAAQkgB,EAAiBrE,IAAOje,WAE5CgnB,GAAKP,MAAQpE,EAAKoE,MAClBO,EAAKN,OAASrE,EAAKqE,OAEnBM,EAAKC,SAAW5E,EAAKgW,MAAM7qB,IAAI,SAAC6qB,EAAO13B,GAGrC,MAAO0d,GAAA+D,WAAWiW,EAAOrR,EAAMA,EAAKjB,QAAQ,SAAWplB,GAAI4hB,EAAUtE,OAmK3E,MA9LgCqH,GAAAre,UAAA6b,EAAAiE,GA+BvBjE,EAAApf,UAAAyjB,UAAP,WACEnnB,KAAKonB,UAAU5Q,KAAOqQ,EAAAM,UAAUnnB,KAChC,KAAoB,GAAAunB,GAAA,EAAApB,EAAAnmB,KAAKinB,SAALM,EAAApB,EAAAnlB,OAAAumB,IAAa,CAAjBpB,EAAAoB,GACRJ,cAIHrE,EAAApf,UAAA2jB,eAAP,WAAA,GAAAL,GAAAhnB,IAIEA,MAAKonB,UAAUE,YACf,KAAoB,GAAAC,GAAA,EAAApB,EAAAnmB,KAAKinB,SAALM,EAAApB,EAAAnlB,OAAAumB,IAAa,CAA5B,GAAM9U,GAAK0T,EAAAoB,aAAL9U,GACTA,EAAM4U,iBACN9M,EAAAvX,KAAKyP,EAAM2U,UAAUE,WAAW/U,QAAQ,SAAC3Q,GACvColB,EAAKI,UAAUE,UAAU1lB,GAAO6Q,EAAM2U,UAAUE,UAAU1lB,MAHnD6Q,KAQNqQ,EAAApf,UAAA8jB,WAAP,WAKE,IAAoB,GAJd5J,GAAQ5d,KAER02B,EAAgC12B,KAAKonB,UAAUK,UAEjCF,EAAA,EAAApB,EAAAnmB,KAAKinB,SAALM,EAAApB,EAAAnlB,OAAAumB,IAAa,CAA5B,GAAM9U,GAAK0T,EAAAoB,aAAL9U,GACTA,EAAM+U,aAKJjN,EAAAvX,KAAKyP,EAAM2U,UAAUK,QAAQlV,QAAQ,SAASyI,GAC5C,GAAMsd,GAAa7lB,EAAM2U,UAAUK,OAAOzM,GACpCud,EAAa7B,EAAe1b,EAElC,OAAKsd,GAAcnC,EAAAqC,kBAAkBF,EAAWxX,SAAYyX,GAAcpC,EAAAqC,kBAAkBD,EAAWzX,SAAvG,CAKIyX,EACFA,EAAWzX,OAASqX,EAAAM,aAAaF,EAAWzX,OAAQwX,EAAWxX,QAE/D4V,EAAe1b,GAAWsd,CAI5B,IAAM3B,GAAyB2B,EAAWh0B,KAAKsyB,OAAOnkB,EAAMsT,QAAQ,IAAI/kB,QAClEoqB,EAAUxN,EAAMwC,UAAUuW,GAAwB,EACxDlkB,GAAMokB,YAAYyB,EAAWh0B,KAAM8mB,GACnCkN,EAAWh0B,KAAO8mB,QAGX3Y,GAAM2U,UAAUK,OAAOzM,OA5BzBvI,KAkCNqQ,EAAApf,UAAAgkB,UAAP,WACE,IAAoB,GAAAH,GAAA,EAAApB,EAAAnmB,KAAKinB,SAALM,EAAApB,EAAAnlB,OAAAumB,IAAa,CAAjBpB,EAAAoB,GACRG,cAIH5E,EAAApf,UAAAikB,mBAAP,WAGE,IAAoB,GAFdvI,GAAgBpf,KAAKonB,UAAU/H,QAEjBkI,EAAA,EAAApB,EAAAnmB,KAAKinB,SAALM,EAAApB,EAAAnlB,OAAAumB,IAAa,CAA5B,GAAM9U,GAAK0T,EAAAoB,aAAL9U,GACTA,EAAMkV,qBACNpN,EAAAvX,KAAKyP,EAAM2U,UAAU/H,MAAM9M,QAAQ,SAAAyI,GAU1BoE,EAAcpE,KACjBoE,EAAcpE,GAAWvI,EAAM2U,UAAU/H,KAAKrE,SACvCvI,GAAM2U,UAAU/H,KAAKrE,OAdzBvI,KAuBNqQ,EAAApf,UAAAmkB,YAAP,WAGE,IAAoB,GAFd6Q,GAAkB14B,KAAKonB,UAAUU,WAEnBP,EAAA,EAAApB,EAAAnmB,KAAKinB,SAALM,EAAApB,EAAAnlB,OAAAumB,IAAa,CAA5B,GAAM9U,GAAK0T,EAAAoB,aAAL9U,GACTA,EAAMoV,cAIJtN,EAAAvX,KAAKyP,EAAM2U,UAAUU,SAASvV,QAAQ,SAAAyI,GAE/B0d,EAAgB1d,KACnB0d,EAAgB1d,GAAWvI,EAAM2U,UAAUU,QAAQ9M,OARhDvI,KAeNqQ,EAAApf,UAAAijB,8BAAP,WACE,MAAOtI,GAAAoF,eAAgBzjB,KAAKie,OAAO+X,KAAMC,EAAAC,mBAAmB1qB,QAAQ,WAG/DsX,EAAApf,UAAAuiB,iCAAP,SAAwCH,GACtC,MAAO9lB,MAAKinB,SAAS9H,OAAO,SAAC6I,EAAIvV,GAAU,MAAAA,GAAMwT,iCAAiC+B,IAAKlC,IAIlFhD,EAAApf,UAAAukB,yBAAP,WACE,MAAOjoB,MAAKinB,SAAS9H,OAAO,SAAC2G,EAASrT,GACpC,MAAOqT,GAAQta,OAAOiH,EAAMwV,kCAKzBnF,EAAApf,UAAAsiB,sBAAP,WACE,MAAOhmB,MAAKinB,SAAS9H,OAAO,SAAC2G,EAASrT,GACpC,MAAOqT,GAAQta,OAAOiH,EAAMuT,0BAC3BkS,EAAAS,2BAA2B34B,QAGzB8iB,EAAApf,UAAAmiB,sBAAP,SAA6BrP,GAC3B,MAAOxW,MAAKinB,SAAS9H,OAAO,SAAC+I,EAAIzV,GAAU,MAAAA,GAAMoT,sBAAsBqC,SAGlEpF,EAAApf,UAAAkiB,aAAP,WACG,MAAK5lB,MAAKoC,UAEFwkB,EAAAhB,aAAarL,EAAAsH,KAAK7hB,KAAKonB,UAAU5Q,KAAKuR,WAK1CjF,EAAApf,UAAAykB,eAAP,WAEE,MAAOnoB,MAAKinB,SAAS9H,OAAO,SAACsI,EAAQhjB,GACnC,MAAOgjB,GAAOjc,OAAO/G,EAAE0jB,mBACtBpB,EAAArjB,UAAMykB,eAAcpnB,KAAAf,QAGlB8iB,EAAApf,UAAA6iB,eAAP,WACE,MAAO,OAGFzD,EAAApf,UAAAglB,cAAP,WACE,MAAO0P,GAAAQ,4BAA4B54B,KAAMua,EAAAgR,QAAQvrB,KAAKinB,SAASzZ,IAAI,SAACiF,GAClE,MAAOA,GAAMiW,qBAGnB5F,GA9LgCgE,EAAA8B,MAAnBppB,GAAAsjB,WAAAA,iOCkCb,SAAA+U,GAA8B9Y,GAC5B,MAAe,QAAXA,GAA+B,SAAXA,EACf,SAEF,SAGT,QAAA8Z,GAA8Bjb,EAAc5C,GAC1C,GAAMwc,GAA0B,QAAZxc,EAAoB,SAAW,QAC7CiG,EAAQrD,EAAMwJ,UAAUgQ,cAAcpc,GAASiG,MAC/C6X,EAA8B,QAAZ9d,EAAoB,IAAM,IAC5CrH,EAAoB,QAAZqH,EAAoB,QAAU,SACtC+d,EAAyB,QAAZ/d,EAAoB,eAAavY,EAEpD,QACE6B,KAAOsZ,EAAMmI,QAAW/K,EAAO,UAC/Bge,KAAShe,EAAO,SAChB9O,KAAM,QACNwC,QACExC,KAAM,OACN8sB,KAAShe,EAAO,cAChB0F,QACEC,OAAM2E,EAAApe,UAAAif,KAAAA,EAEH2S,IAAmB1a,OAAQ,SAASoZ,GACrCrR,EAAAxS,OAAQ9R,MAAO8R,GACfwS,EAAApiB,MAAOlC,MAAOof,GACdkF,EAAA8S,MAAOp3B,MAAO,SACdskB,EAAA+S,YAAar3B,MAAO,QAAOskB,GACR,aAAf4S,GAA6Bna,OAAQ/c,MAAO,oBAO1D,QAAAs3B,GAA+Bvb,EAAc5C,EAAwB4c,EAAwBD,EAAqCL,GAChI,GAAIA,EAAQ,CACV,GAAIrW,GAAQ,IACR0W,GAAaN,UAAYC,EAAO3Z,SAClCsD,GACEld,KAAM4zB,EAAaN,SACnB9O,OAAQ,GACRxJ,OAAoB,QAAZ/D,EAAoB,OAAS,MACrC0F,QACEC,OAAM2E,EAAApe,UACJgyB,YAAar3B,MAAO,UACpB+c,OAAQ/c,MAAO,GACfu3B,UAAWv3B,MAAO,KACD,QAAZmZ,GACHrH,OAAQ9R,MAAO,SACfmd,UAAWnd,MAAO,iBAO5B,IAAMwd,GAAOiY,EAAOjY,KAEdga,EAAUha,GAAQA,EAAKre,OAAS,CACtC,IAAIigB,GAASoY,EAAS,CACpB,GAAM7B,GAA0B,QAAZxc,EAAoB,SAAW,OAEnD,OAAMsK,GAAApe,UACJ5C,KAAMsZ,EAAMmI,QAAW/K,EAAO,IAAI4c,GAClC1rB,KAAM,QACN8sB,KAAShe,EAAO,IAAI4c,GAChBD,EAAaN,UAAYJ,MAAOzgB,KAAMoH,EAAMmI,QAAQ/K,QACpDiG,GAASA,MAAKA,OAClBP,QACEC,QAAMwF,KACJA,EAACqR,GAAcF,EAAOG,gBAGtB4B,GAAWha,KAAIA,QAIzB,MAAO,6EA7HI7f,GAAA85B,iBAAoC,MAAO,UAG3C95B,EAAA+5B,cAA8B,SAAU,UA2CrD/5B,EAAAq4B,cAAAA,EAOAr4B,EAAAq5B,cAAAA,EA6BAr5B,EAAA25B,eAAAA,8CC/EA,SAAAR,GAA2C/a,GACzC,QACGtZ,KAAMsZ,EAAMmI,QAAQ,SAAUpF,OAAQ6Y,EAAc5b,EAAO,WAC3DtZ,KAAMsZ,EAAMmI,QAAQ,UAAWpF,OAAQ6Y,EAAc5b,EAAO,YAIjE,QAAA4b,GAA8B5b,EAAmBkY,GAE/C,MAAO,OADqBlY,EAAMqJ,SAASzZ,IAAI,SAAAiF,GAAS,MAAAA,GAAMsT,QAAQ+P,KAAWr0B,KAAK,MACrD,IAGnC,QAAAg4B,GAA0C7b,GACxC,QACGtZ,KAAMsZ,EAAMmI,QAAQ,SAAUpF,OAAQ+Y,EAAa9b,EAAO,WAC1DtZ,KAAMsZ,EAAMmI,QAAQ,UAAWpF,OAAQ+Y,EAAa9b,EAAO,YAIhE,QAAA8b,GAA6B9b,EAAkBkY,GAC7C,GAAM9a,GAAqB,UAAX8a,EAAqB,IAAM,IACrC3V,EAAQvC,EAAMuC,MAAMnF,EAC1B,IAAImF,GACEnD,EAAAsE,kBAAkBnB,EAAMjU,OAASiU,EAAMwZ,UAAW,CACpD,GAAMvZ,GAAYxC,EAAMwC,UAAUpF,GAE5B4e,EAAc,WAAWxZ,EAAS,YAClCyZ,MAAsCp3B,KAAvB0d,EAAM0Z,aAA6B1Z,EAAM0Z,aAAe1Z,EAAMiI,OAQnF,OAAO,aAAawR,EAAW,MAPK,SAAfzZ,EAAMjU,SAEDzJ,KAAvB0d,EAAM2Z,aAA6B3Z,EAAM2Z,aAAe3Z,EAAMiI,QAG/D,GAE8C,KAAKyR,EAAY,OAAO1Z,EAAMwZ,UAGlF,MAAO,GAAG/b,EAAMkY,mDAjDlB,IAAA9Y,GAAAtc,EAAA,cAWAlB,GAAAm5B,2BAAAA,EAOAn5B,EAAAg6B,cAAAA,EAKAh6B,EAAAi6B,0BAAAA,EAOAj6B,EAAAk6B,aAAAA,uDCtBA,SAAAK,GAAwBhc,EAA4Bic,EAAkBpc,EAAkB5C,GACtF,GAAI+e,MACEpe,EAAOiC,EAAMjC,MAEnB,QAAQA,GACN,IAAKsa,GAAAgE,IACL,IAAKhE,GAAAiE,KACL,IAAKjE,GAAAzZ,KACHud,EAAQzqB,OAASzN,MAAO,SACxB,MACF,KAAKo0B,GAAAkE,OACL,IAAKlE,GAAAmE,OACHL,EAAQzqB,OAASzN,MAAO8Z,EACxB,MACF,KAAKsa,GAAAoE,MACL,IAAKpE,GAAAqE,KACL,IAAKrE,GAAAsE,MAKP,GAAMC,GAAM5c,EAAMK,OACZwc,EAAS7c,EAAMiW,QAAQ4G,OAEzBxc,EAASjD,IAAYC,EAAAI,MAErBd,EAAAiD,QAAQyY,EAAAC,oBAAsBuE,EAAS,OAAS,SAAU,aAAc,qBAExExE,EAAAC,kBAEJjY,GAAS1D,EAAAiD,QAAQS,GAAS,aAAc,qBAExCI,EAAAsF,gBAAgBoW,EAASnc,EAAOK,GAE5Bwc,IACFV,EAAQW,aAAe74B,MAAO,GAGhC,IAAIA,GACE84B,EAAW/c,EAAM+V,SAASiH,KAC5BlZ,GAAAmZ,WAAWF,KACb94B,GAASA,MAAO84B,EAAS94B,YAGbY,KAAVZ,EAEE44B,EACFV,EAAQd,KAAOp3B,EAEfk4B,EAAQe,OAASj5B,EAEVmZ,IAAYC,EAAAI,QAGrB0e,EAAQU,EAAS,OAAS,UAAYV,EAAQU,EAAS,OAAS,YAC7D54B,MAAO24B,EAAI7e,KAAKif,YAGAn4B,KAAjBs3B,EAAQd,WAEYx2B,KAAlB+3B,EAAI7e,KAAKsd,KACXc,EAAQd,MAAQp3B,MAAO24B,EAAI7e,KAAKsd,UACHx2B,KAApB+3B,EAAI7e,KAAKmf,SAClBf,EAAQe,QAAUj5B,MAAO24B,EAAI7e,KAAKmf,SAItC,IAAMC,GAAWnd,EAAM+V,SAASrkB,KAShC,OARI0L,KAAYC,EAAAM,OACVmG,EAAAmZ,WAAWE,KACbhB,EAAQzqB,OAASzN,MAAOk5B,EAASl5B,QAIrCk4B,EAAUxf,EAAA3I,OAAOmoB,EAASC,OAEnBzf,EAAAvX,KAAK+2B,GAAS/4B,OAAS,EAAI+4B,MAAUt3B,GAG9C,QAAAkb,GAAuBI,EAA4BF,EAAiBD,EAAkB5C,GACpF,GAAMsT,GAAS1Q,EAAM0Q,OAAOtT,GACtBiD,EAASL,EAAMK,OAEjBN,IAYJ,OAVII,GAAS7R,OAASgS,EAAAC,WACpBN,EAAatD,EAAA3I,QACX7N,MACEqa,OAAQC,EAAAC,qBAAqB,cAAeP,EAASQ,SAAU+P,EAAO9P,OAAQP,EAAOqQ,OAAO7P,gBAAiBR,EAAOS,cAErHb,QAGLF,EAASpD,EAAA3I,OAAO+L,EAAQE,OAEjBtD,EAAAvX,KAAK2a,GAAQ3c,OAAS,EAAI2c,MAASlb,mDA1G5C,IAAAwY,GAAAva,EAAA,iBACAghB,EAAAhhB,EAAA,kBACAu1B,EAAAv1B,EAAA,cACAwd,EAAAxd,EAAA,cACA6Z,EAAA7Z,EAAA,cAIA2d,EAAA3d,EAAA,YAGAlB,GAAAu6B,QAAAA,EA+EAv6B,EAAAme,OAAAA,4IC/EA,SAAAqd,GAAqCpd,GACnC,OAAQ3C,EAAAI,MAAOJ,EAAAG,KAAMH,EAAAM,MAAON,EAAAK,SAAS6D,OAAO,SAASuZ,EAAiB1d,GAIpE,MAHI4C,GAAM0Q,OAAOtT,KACf0d,EAAgB1d,GAAW6M,EAAYjK,EAAO5C,IAEzC0d,OAIX,QAAAuC,GAA+Brd,EAAkB5C,GAE/C,OAAQA,GACN,IAAKC,GAAAI,MACH,GAAM8E,GAAQvC,EAAMwC,UAAUnF,EAAAI,MAC9B,OAAOuC,GAAMiW,QAAQ4G,QAAUxB,KAAM9Y,IAAU2a,OAAQ3a,EACzD,KAAKlF,GAAAG,KACH,OAAQnJ,KAAM2L,EAAMwC,UAAUnF,EAAAG,MAChC,KAAKH,GAAAM,MACH,OAAQjM,MAAOsO,EAAMwC,UAAUnF,EAAAM,OACjC,KAAKN,GAAAK,QACH,OAAQ4f,QAAStd,EAAMwC,UAAUnF,EAAAK,UAErC,MAAO,MAGT,QAAAuM,GAA4BjK,EAAkB5C,GAC5C,GAAM+C,GAAWH,EAAMG,SAAS/C,GAC1BsT,EAAS1Q,EAAM0Q,OAAOtT,GAEtB8C,EAAgBmd,EAAsBrd,EAAO5C,EAEnDmgB,GAAAC,kBAAkB7oB,QAAQ,SAAS+N,GACjC,GAAMze,GAAQ0e,EAA2BD,EAAUgO,EAAQtT,EAAS4C,OACtDnb,KAAVZ,IACFic,EAAIwC,GAAYze,IAKpB,IAAM4e,GAAa6N,EAAO5N,UAW1B,QAVC,SAAU,SAAU,QAAS,WAAWnO,QAAQ,SAASuN,GACxD,GAAMje,GAAQ6e,EAAOZ,GACnBY,EAAOZ,GAAM/B,EAAU0C,EAAWX,GAAOlC,EAAO5C,GAChDyF,EAAWX,OACCrd,KAAVZ,GAAuB0Y,EAAAvX,KAAKnB,GAAOb,OAAS,IAC9C8c,EAAI4C,OAAS5C,EAAI4C,WACjB5C,EAAI4C,OAAOZ,IAASa,OAAQ9e,MAIzBic,EAGT,QAAAyC,GAAoCD,EAA0B+a,EAAyBrgB,EAAkB4C,GACvG,GAAMG,GAAWH,EAAMG,SAAS/C,EAEhC,QAAQsF,GACN,IAAK,SACH,MAAOjC,GAAA+C,aAAarD,EAAUsd,EAAgB7c,OAAQZ,EAAMK,OAAQjD,EACtE,KAAK,QACH,MAAO6F,GAAMI,MAAMoa,EAAiBtd,EAAUH,EAAMK,OACtD,KAAK,SACH,MAAO4C,GAAMK,OAAOma,EACtB,KAAK,OACH,MAAOxa,GAAM3U,KAAKmvB,EAAiBtd,EAAS7R,KAAM8O,EAAS4C,EAAMuC,MAAMnF,GAAS9O,MAIpF,MAAOmvB,GAAgB/a,mDA/EzB,IAAArF,GAAAva,EAAA,iBACAy6B,EAAAz6B,EAAA,gBACA6Z,EAAA7Z,EAAA,cAGA2d,EAAA3d,EAAA,aAGAggB,EAAAhgB,EAAA,YACAmgB,EAAAngB,EAAA,UAEAlB,GAAAw7B,qBAAAA,EAyBAx7B,EAAAqoB,YAAAA,qIC1BA,SAAA5G,GAAsBqN,EAAgBvQ,EAA4BE,GAChE,WAAqBxb,KAAjB6rB,EAAOrN,MACFqN,EAAOrN,MAGTS,EAAAT,MAAWlD,EAAUE,GAG9B,QAAAiD,GAAuBoN,GACrB,GAAMzM,GAAOyM,EAAOpN,MACpB,OAAIW,IAAQC,EAAAC,WAAWF,EAAK,IAClBA,EAAoBrU,IAAI,SAACwU,GAE/B,MAAOF,GAAAG,UAAUD,GAAI,KAGlBH,EAGT,QAAA3V,GAAqBoiB,EAAgBpiB,EAAY8O,EAAkB4B,GACjE,MAAI0R,GAAOpiB,KACFoiB,EAAOpiB,KAEZ8O,IAAYC,EAAAI,QAAoB,iBAATnP,IAA4B8Q,EAAAse,WAAW1e,IAAyB,aAAT1Q,GAAuBqO,EAAAmC,UAAqB,OAAQ,OAAQE,IACrI,eADT,mDAjCF,IAAA3B,GAAAva,EAAA,iBAEAohB,EAAAphB,EAAA,kBAEAghB,EAAAhhB,EAAA,kBAEAsc,EAAAtc,EAAA,eAEA6Z,EAAA7Z,EAAA,aAEAlB,GAAAyhB,MAAAA,EAQAzhB,EAAA0hB,OAAAA,EAWA1hB,EAAA0M,KAAAA,qMC5BAqvB,EAAA76B,EAAA,WAIalB,GAAAuP,MACXysB,OAAQ,OACRC,gBAAah5B,GACbi5B,YAAa,SAAC9d,GACZ,MAAM0H,GAAApe,YACDq0B,EAAOI,cAAc,IAAK/d,EAAO,aACjC2d,EAAOI,cAAc,IAAK/d,EAAO,aACjC2d,EAAOK,eAAehe,EAAO,aAE7B2d,EAAOX,MAAMhd,GACb2d,EAAOM,YAAY,UAAWje,GAC9B2d,EAAOO,kBAAkBle,EAAMiW,SAAU,SAAU,cAAe,yECa3E,SAAAvwB,GAAWsa,EAAkBuV,GACpB,GAAAlV,GAAAL,EAAAK,OAAQwI,EAAA7I,EAAA6I,MACT1H,EAASnB,EAAMiW,QAAQ9U,OACvBgd,EAAUne,EAAM+V,SAAS1hB,KAEzB+pB,EAAOpe,EAAM+V,SAASrwB,EACtB24B,EAAare,EAAMwC,UAAUnF,EAAAY,GAC7BqgB,EAASte,EAAMuC,MAAMlF,EAAAY,EAE3B,IAAe,eAAXkD,EACF,MAAMuG,GAAApe,YACDq0B,EAAOI,cAAc,IAAK/d,EAAO,aACjC2d,EAAOK,eAAehe,EAAO,aAGlC,IAAI8D,EAAAya,WAAWH,GAAO,CACpB,IAAKD,GAAW/e,EAAAse,WAAWY,EAAOhwB,MAChC,MAAOqvB,GAAOa,eAAe,IAAKxe,EAAOK,EAAO5B,IAAIggB,WAC/C,IAAIH,EAAOhwB,OAAS8Q,EAAAwU,UAAU8K,KACnC,MAAOf,GAAOgB,aAAa,IAAK3e,GAKpC,MAAO2d,GAAOiB,qBAAqB,IAAK5e,EAAK0H,EAAApe,YACvCu1B,EAAIC,KAAKjW,EAAOxI,IACpB0e,EAAeV,EAAYre,EAAMuC,MAAMlF,EAAAY,GAAIoC,IAKjD,QAAApT,GAAW+S,EAAkBuV,GACpB,GAAAlV,GAAAL,EAAAK,OAAQ0V,EAAA/V,EAAA+V,SAAUjN,EAAA9I,EAAA8I,OACnB3H,EAASnB,EAAMiW,QAAQ9U,OACvBgd,EAAUpI,EAAS1hB,KAEnB2qB,EAAOjJ,EAAS9oB,EAChBgyB,EAAajf,EAAMwC,UAAUnF,EAAAa,GAC7BghB,EAASlf,EAAMuC,MAAMlF,EAAAa,EAE3B,IAAe,aAAXiD,EACF,MAAMuG,GAAApe,YACDq0B,EAAOI,cAAc,IAAK/d,EAAO,aACjC2d,EAAOK,eAAehe,EAAO,aAGlC,IAAI8D,EAAAya,WAAWS,GAAO,CACpB,GAAIA,EAAKtnB,MAAQymB,EACf,MAAOR,GAAOa,eAAe,IAAKxe,EAAOK,EAAO5B,IAAIggB,WAC/C,IAAIS,EAAO5wB,OAAS8Q,EAAAwU,UAAU8K,KACnC,MAAOf,GAAOgB,aAAa,IAAK3e,GAGpC,MAAO2d,GAAOiB,qBAAqB,IAAK5e,EAAO6e,EAAIM,KAAKrW,EAAQzI,GAAS0e,EAAeE,EAAYjf,EAAMuC,MAAMlF,EAAAa,GAAImC,IAIxH,QAAA0e,GAAwBvc,EAAmBD,EAAclC,GACvD,GAAIA,EAAO5B,IAAI2gB,iBACb,OAAQn7B,MAAOoc,EAAO5B,IAAI2gB,iBAG5B,IAAI7c,EAAO,CACT,GAAIA,EAAMjU,OAAS8Q,EAAAwU,UAAU6I,MAKtB,MAAIla,GAAMjU,OAAS8Q,EAAAwU,UAAU8K,KAC3BG,EAAIQ,KAAK7c,IAERve,MAAOoc,EAAO5B,IAAI6gB,mBAP1B,IAAwB,OAApB/c,EAAMwZ,UACR,OAAQ93B,MAAOse,EAAMwZ,UAAY,EAEnC1pB,GAAIgB,KAAKhB,EAAI1L,QAAQ44B,yCAOzB,MAAIlf,GAAOkC,MAAMwZ,WAAwC,OAA3B1b,EAAOkC,MAAMwZ,WACjC93B,MAAOoc,EAAOkC,MAAMwZ,UAAY,IAGlC93B,MAAO,sEA3GjBoZ,EAAAva,EAAA,iBAEAghB,EAAAhhB,EAAA,kBACAuP,EAAAvP,EAAA,aACAsc,EAAAtc,EAAA,eAMA66B,EAAA76B,EAAA,YAGA+7B,EAAA/7B,EAAA,aAEalB,GAAA6c,KACXmf,OAAQ,OACRC,YAAa,MACbC,YAAa,SAAC9d,GACZ,GAAMuV,GAAQvV,EAAMuV,KACpB,OAAM7N,GAAApe,YACD5D,EAAEsa,EAAOuV,GACTtoB,EAAE+S,EAAOuV,GACToI,EAAOX,MAAMhd,GACb2d,EAAOM,YAAY,UAAWje,uJCbvC,SAAAwf,GAA4BzhB,EAAsBgY,EAA4BxT,EAAoBlC,GAChG,GAAM4V,GAAUoC,EAAAoH,UAAU1hB,GAAK2J,EAAApe,YAAOyU,IAASzP,KAAMyP,GAE/C2hB,EAAkBzJ,EAAQ9U,QAAUV,EAAAuF,cAAc,SAAUiQ,EAAQ3nB,KAAM+R,EAWhF,OAVA4V,GAAQ9U,OAASA,EAAO8U,EAAQ3nB,KAAMynB,EAAUxT,EAAOmd,OAC/B76B,KAApB66B,GAAiCA,IAAoBzJ,EAAQ9U,QAC/D9O,EAAIgB,KAAKhB,EAAI1L,QAAQg5B,iBAAiB1J,EAAQ9U,OAAOue,QAI/B76B,KADAoxB,EAAQ4G,SAE9B5G,EAAQ4G,OAASA,EAAO5G,EAAQ3nB,KAAM+R,IAGjC4V,EAMT,QAAA2J,GAA6B7hB,EAAYgY,EAA4B8J,EAA0Bxf,GAC7F,GAAMyf,GAAgBrf,EAAAuF,cAAc,UAAWjI,EAAMsC,EACrD,KAAK0V,EAASuH,aAA6Bz4B,KAAlBi7B,EAA6B,CACpD,GAAMxC,GAAUyC,EAAehiB,EAAMgY,EAAU8J,OAC/Bh7B,KAAZy4B,IACFvH,EAASuH,SAAWr5B,MAAOq5B,IAG/B,MAAOvH,GAIT,QAAAgK,GAAwBhiB,EAAYgY,EAA4B8J,GAC9D,GAAIljB,EAAAmC,UAAUuZ,EAAAoE,MAAOpE,EAAAiE,KAAMjE,EAAAkE,OAAQlE,EAAAmE,QAASze,KAErC6X,EAAA9J,YAAYiK,GACf,MAAO,GAMb,QAAA8G,GAAgB9e,EAAYsC,GAC1B,GAAM2f,GAAevf,EAAAuF,cAAc,SAAUjI,EAAMsC,EACnD,YAAwBxb,KAAjBm7B,EAA6BA,EAAejiB,IAASsa,EAAAoE,OAAS1e,IAASsa,EAAAqE,MAAQ3e,IAASsa,EAAA4H,KAGjG,QAAA9e,GAAgBpD,EAAYgY,EAA4BxT,EAAoBmd,GAC1E,OAAQ3hB,GACN,IAAKsa,GAAAoE,MACL,IAAKpE,GAAAkE,OACL,IAAKlE,GAAAmE,OACL,IAAKnE,GAAAzZ,KACL,IAAKyZ,GAAA6H,KAEH,OAGJ,GAAMC,GAAWpK,EAAS9oB,GAAK8oB,EAASqK,GAClCC,EAAWtK,EAASrwB,GAAKqwB,EAASuK,EAExC,QAAQviB,GACN,IAAKsa,GAAAiE,KACH,GAAMiE,GAAahe,EAAS,EAAIA,EAAS,EAAEjU,KAAO,KAC5CkyB,EAAaje,EAAS,EAAIA,EAAS,EAAEjU,KAAO,IAGlD,QAAK8Q,EAAAsE,kBAAkB6c,MAChBxK,EAAS9oB,GACVmS,EAAAsE,kBAAkB8c,IACjB1c,EAAAya,WAAWxI,EAAS9oB,IAAM8oB,EAAS9oB,EAAEyK,KAEnC,WAGF,YAET,KAAK2gB,GAAA4H,KACL,IAAK5H,GAAAgE,IACL,IAAKhE,GAAAsE,KAEH,GAAIwD,EACF,MAAO,UACF,IAAIE,EACT,MAAO,YACF,IAAItiB,IAASsa,EAAA4H,KAAM,CACxB,GAAIlK,EAASrwB,IAAMqwB,EAAS9oB,EAC1B,MAAO,UACF,IAAI8oB,EAAS9oB,IAAM8oB,EAASrwB,EACjC,MAAO,aAKb,IAAK2yB,GAAAqE,KAEH,GAAM+D,GAAgB3c,EAAAya,WAAWxI,EAASrwB,IAAMoe,EAAA4c,aAAa3K,EAASrwB,GAChEi7B,EAAgB7c,EAAAya,WAAWxI,EAAS9oB,IAAM6W,EAAA4c,aAAa3K,EAAS9oB,EACtE,IAAIwzB,IAAkBE,EACpB,MAAO,YACF,KAAKF,GAAiBE,EAC3B,MAAO,UACF,IAAIF,GAAiBE,EAAe,CACzC,GAAMvC,GAAOrI,EAASrwB,EAChBs5B,EAAOjJ,EAAS9oB,EAEhB2zB,EAAcxC,EAAK9vB,OAASgS,EAAAC,SAC5BsgB,EAAc7B,EAAK1wB,OAASgS,EAAAC,QAGlC,OAAIqgB,KAAgBC,EACX,YACGD,GAAeC,EAClB,cAGJzC,EAAK3X,WAAauY,EAAKvY,UACnB,WACE2X,EAAK3X,YAAcuY,EAAKvY,UAC1B,aAGLiZ,IAKE3hB,IAASsa,EAAAqE,MAAQ3G,EAAS/O,OAE9B3U,EAAIgB,KAAKhB,EAAI1L,QAAQm6B,wBAAwB/iB,IAExC,YAIP,WADA1L,GAAIgB,KAAKhB,EAAI1L,QAAQo6B,6BAA6BhjB,IAIxD,MAAO,6EApJT6X,EAAA9yB,EAAA,kBACAghB,EAAAhhB,EAAA,kBACAuP,EAAAvP,EAAA,aACAu1B,EAAAv1B,EAAA,cACAsc,EAAAtc,EAAA,eAEAwd,EAAAxd,EAAA,cACA6Z,EAAA7Z,EAAA,cACA2d,EAAA3d,EAAA,YAEAlB,GAAA49B,YAAAA,EAoBA59B,EAAAg+B,aAAAA,wPC9BAjC,EAAA76B,EAAA,WAIalB,GAAA0P,MACXssB,OAAQ,OACRC,gBAAah5B,GACbi5B,YAAa,SAAC9d,GACZ,MAAM0H,GAAApe,YACDq0B,EAAOI,cAAc,IAAK/d,EAAO,aACjC2d,EAAOI,cAAc,IAAK/d,EAAO,aACjC2d,EAAOX,MAAMhd,GACb2d,EAAOM,YAAY,UAAWje,GAC9B2d,EAAOM,YAAY,OAAQje,GAC5BghB,UAAW,gBAEVrD,EAAOO,kBAAkBle,EAAMiW,SAAU,cAAe,yECcjE,SAAAnM,GAA0B9J,GACxB,MAAIrD,GAAAmC,UAAUuZ,EAAAqE,KAAMrE,EAAAsE,MAAO3c,EAAMjC,QACxBkjB,EAAcjhB,GAEdkhB,EAAiBlhB,GAM5B,QAAAihB,GAAuBjhB,GACrB,GAAMjC,GAAOiC,EAAMjC,OAEbojB,EAAUC,EAAaphB,GAEvBqhB,IAEF36B,KAAMsZ,EAAMmI,QAAQ,SACpB7Z,KAAMgzB,EAAavjB,GAAM6f,OAGzBvE,MAAOzgB,MAAOuoB,EAAQ/9B,OAAS,EAAIm+B,EAAsB,IAAMvhB,EAAMwhB,gBAAgBnT,EAAAC,OACrFxL,QAASC,OAAQue,EAAavjB,GAAM+f,YAAY9d,KAIpD,OAAImhB,GAAQ/9B,OAAS,IAIjBsD,KAAMsZ,EAAMmI,QAAQ,aACpB7Z,KAAM,QACN+qB,MACEjM,OACE1mB,KAAM66B,EAAsBvhB,EAAMwhB,gBAAgBnT,EAAAC,MAClD1V,KAAMoH,EAAMwhB,gBAAgBnT,EAAAC,MAC5B9B,QAAS2U,IAGbre,QACEC,QACE8F,OAAQjW,OAAQxB,MAAO,UACvB0X,QAASlW,OAAQxB,MAAO,aAG5BN,MAAOuwB,IAGFA,EAIX,QAAAH,GAA0BlhB,GACxB,GAAMjC,GAAOiC,EAAMjC,OAEbqd,EAAOpb,EAAMiW,QAAQmF,MAAQkG,EAAavjB,GAAM8f,YAEhD/sB,IAYN,OARAA,GAAM7L,KAAIyiB,EAAApe,UACR5C,KAAMsZ,EAAMmI,QAAQ,SACpB7Z,KAAMgzB,EAAavjB,GAAM6f,QACrBxC,GAAOA,KAAIA,OACf/B,MAAOzgB,KAAMoH,EAAMwhB,gBAAgBnT,EAAAC,OACnCxL,QAASC,OAAQue,EAAavjB,GAAM+f,YAAY9d,OAG3ClP,EAST,QAAAswB,GAAsBphB,GACpB,MAAO3C,GAAAsC,yBAAyB4B,OAAO,SAAS4f,EAAS/jB,GAIvD,MAHI4C,GAAM8V,gBAAgB1Y,KAAa4C,EAAMG,SAAS/C,GAASqJ,WAC7D0a,EAAQl8B,KAAK+a,EAAMpN,MAAMwK,IAEpB+jB,yEAlHX9jB,EAAAva,EAAA,iBACAu1B,EAAAv1B,EAAA,cACA6Z,EAAA7Z,EAAA,cAEA2+B,EAAA3+B,EAAA,UACA4+B,EAAA5+B,EAAA,SAEA6+B,EAAA7+B,EAAA,UACA8+B,EAAA9+B,EAAA,WACA++B,EAAA/+B,EAAA,UACAg/B,EAAAh/B,EAAA,UACAi/B,EAAAj/B,EAAA,UACAk/B,EAAAl/B,EAAA,UAEAurB,EAAAvrB,EAAA,cAIMw+B,GACJnwB,KAAMswB,EAAAtwB,KACNsN,IAAKijB,EAAAjjB,IACLnN,KAAMqwB,EAAArwB,KACN+M,MAAOujB,EAAAvjB,MACPlY,KAAM47B,EAAA57B,KACNmY,KAAM0jB,EAAA1jB,KACN9M,KAAMqwB,EAAArwB,KACNC,KAAMqwB,EAAArwB,KACN8M,OAAQqjB,EAAArjB,OACRC,OAAQojB,EAAApjB,OAGV5c,GAAAkoB,UAAAA,CAQA,IAAMyX,GAAsB,+NC3B5B,SAAAvE,GAAsBhd,GACpB,GAAMK,GAASL,EAAMK,OACfwc,EAAS7c,EAAMiW,QAAQ4G,OAEvBv6B,EAAI27B,EAAY,QAASje,GAC7BghB,UAAWnE,EAAS,OAAS,SAC7BoF,aAAcxhB,EAAAuF,cAAc,QAAShG,EAAMjC,OAAQsC,IAQrD,QAHK/d,EAAE+4B,MAAQ6G,EAAKpjB,UAAU,MAAO,QAAS,SAAU,UAAWkB,EAAMjC,UACvEzb,EAAE+4B,MAAQp3B,MAAO,gBAEZ3B,EAGT,QAAA47B,GAAkCngB,EAAeokB,GAC/C,MAAOA,GAAM5gB,OAAO,SAAC9a,EAAGwf,GAItB,MAHIlI,GAAKkI,KACPxf,EAAEwf,IAAShiB,MAAO8Z,EAAKkI,KAElBxf,OAIX,QAAA27B,GAA+Bnc,EAAchiB,GAC3C,OAAcY,KAAVZ,EACF,MAAMskB,MAAEA,EAACtC,IAAQhiB,MAAOA,GAAMskB,CAEhC,cAMF,QAAA0V,GAA4B7gB,EAA8C4C,EAAkBqiB,OAAA,KAAAA,IAAAA,KAGnF,IAAAJ,GAAAI,EAAAJ,aAAcjB,EAAAqB,EAAArB,UACfsB,EAAaD,EAAIC,iBAAgCz9B,KAAjBo9B,GAA8Bh+B,MAAOg+B,OAAgBp9B,IAErF09B,EAAaviB,EAAM+V,SAAS3Y,GAC5BolB,EAAW3D,EAAI4D,SAASrlB,EAASmlB,EAAYviB,EAAMwC,UAAUpF,GAAU4C,EAAMuC,MAAMnF,GAAUklB,EAEnG,OAAOI,GAAc1iB,EAAOuiB,GAAcA,EAAWI,UAAW3B,GAAa5jB,EAASolB,GAOxF,QAAAE,GAAuB1iB,EAAkB2iB,EAA2B3B,EAAmBwB,GACrF,GAAIG,EAAW,CACN,GAAAjZ,GAAAiZ,EAAAjZ,UAAWzlB,EAAA0+B,EAAA1+B,KAClB,OAAMskB,MACJA,EAACyY,KACE34B,KAAMu6B,EAAc5iB,EAAO0J,GAAYzlB,MAAKA,eAC5BY,KAAb29B,GAA0BA,SAIlC,WAAoB39B,KAAb29B,GAAsBK,KAAIA,EAAC7B,GAAYwB,EAAQK,cAI1D,QAAAD,GAAuB5iB,EAAkB8iB,GACvC,GAAMC,GAAqC,MAA5BD,EAAch8B,OAAO,GAClCJ,EAAOq8B,EAASD,EAAcr6B,MAAM,GAAKq6B,CAC3C,QAAQC,EAAS,IAAM,IAAMvI,EAAAwI,UAAUhjB,EAAMijB,aAAa,YAAav8B,IAGzE,QAAAP,GAAqB6Z,GACnB,GAAMuiB,GAAaviB,EAAM+V,SAAS5vB,IAClC,OAAOu8B,GAAc1iB,EAAOuiB,GAAcA,EAAWI,UAAW,OAAQ9D,EAAI14B,KAAKo8B,EAAYviB,EAAMK,SAGrG,QAAAse,GAA6BvhB,EAAkB4C,GAE7C,GAAMG,GAAWH,EAAM+V,SAAS3Y,GAC1BoF,EAAYxC,EAAMwC,UAAUpF,GAC5Bwc,EAA0B,MAAZxc,EAAkB,QAAU,QAChD,OAAMmL,MACJA,EAACnL,GAAUyhB,EAAIpF,SAAStZ,EAAUqC,MAClC+F,EAACqR,GAAciF,EAAIQ,KAAK7c,WAI5B,QAAAoc,GAAqCxhB,EAAoB4C,EAAkBkjB,EAA2BnE,GACpG,GAAMoE,GAAyC,MAAZ/lB,EAAkB,KAAO,KACtDwc,EAA0B,MAAZxc,EAAkB,QAAU,QAChD,OAAMsK,GAAApe,YACDy0B,EAAc3gB,EAAS4C,EAAOkjB,EAAeC,GAC7ClF,EAAY,OAAQje,GAAQsiB,WAAYvD,EAAgBiC,UAAWpH,KAI1E,QAAA4E,GAA+BphB,EAAkB4C,EAAkBojB,GACjE,GAAMjjB,GAAWH,EAAM+V,SAAS3Y,GAC1BoF,EAAYxC,EAAMwC,UAAUpF,EAClC,OAAgB,MAAZA,GAEAkjB,GAAIzB,EAAInnB,IAAIyI,EAAUqC,EAAW,QAAS4gB,GAC1C19B,EAAGm5B,EAAInnB,IAAIyI,EAAUqC,EAAW,SAIhC4d,GAAIvB,EAAInnB,IAAIyI,EAAUqC,EAAW,SACjCvV,EAAG4xB,EAAInnB,IAAIyI,EAAUqC,EAAW,MAAO4gB,IAQ7C,QAAArF,GAA8B3gB,EAAkB4C,EAAkBsiB,EAAoDtB,GAG7G,GAAAjL,GAAA/V,EAAA+V,SAAUR,EAAAvV,EAAAuV,MACXiN,EAAW3D,EAAIwE,UAAUjmB,EAAS2Y,EAAS3Y,GAAU4C,EAAMwC,UAAUpF,GAAU4C,EAAMuC,MAAMnF,GAAUmY,EAAO+M,EAElH,OAAM/Z,MACJA,EAACyY,GAAa5jB,GAAUolB,UAQ5B,QAAAxE,GAA+Bhe,EAAkBsiB,EAAuCllB,GAC/E,GAAA2Y,GAAA/V,EAAA+V,SAAUE,EAAAjW,EAAAiW,QAASV,EAAAvV,EAAAuV,KAC1BnY,GAAUA,IAA+B,eAAnB6Y,EAAQ9U,OAA0B,KAAO,KAC/D,IAAMmiB,GAA0B,OAAZlmB,EAAmB,IAAM,IAEvColB,EAAW3D,EAAI0E,WAAWnmB,EAAS2Y,EAASuN,GAAcvN,EAAS3Y,GAAU4C,EAAMwC,UAAU8gB,GAActjB,EAAMuC,MAAM+gB,GAAc/N,EAAO+M,EAClJ,OAAM/Z,MAAEA,EAACnL,GAAUolB,EAAQja,0EApJ7B2Z,EAAAp/B,EAAA,cAEA2d,EAAA3d,EAAA,aAGA+7B,EAAA/7B,EAAA,cAIA03B,EAAA13B,EAAA,yBAEAlB,GAAAo7B,MAAAA,EAiBAp7B,EAAAs8B,kBAAAA,EASAt8B,EAAAwgC,eAAAA,EAUAxgC,EAAAq8B,YAAAA,EAoCAr8B,EAAAuE,KAAAA,EAKAvE,EAAA+8B,aAAAA,EAWA/8B,EAAAg9B,qBAAAA,EASAh9B,EAAA48B,eAAAA,EAmBA58B,EAAAm8B,cAAAA,EAeAn8B,EAAAo8B,eAAAA,yHCrIA,SAAAF,GAAqB9d,EAAkBwjB,GAC9B,GAAAnjB,GAAAL,EAAAK,OAAQwI,EAAA7I,EAAA6I,MAAOC,EAAA9I,EAAA8I,MAEtB,OAAMpB,GAAApe,YACDq0B,EAAOI,cAAc,IAAK/d,EAAO6e,EAAIC,KAAKjW,EAAOxI,IACjDsd,EAAOI,cAAc,IAAK/d,EAAO6e,EAAIM,KAAKrW,EAAQzI,IAElDsd,EAAOX,MAAMhd,GACb2d,EAAOM,YAAY,OAAQje,GAC3ByjB,EAAYzjB,EAAOK,EAAQmjB,GAC3B7F,EAAOM,YAAY,UAAWje,IAIrC,QAAAyjB,GAA4BzjB,EAAkBK,EAAgBmjB,GAC5D,MAAIA,IACM9xB,OAAQzN,MAAOu/B,IAElB7F,EAAOM,YAAY,QAASje,GAAQiiB,aAAcxhB,EAAAuF,cAAc,QAAS,QAAS3F,uEAzB3Fsd,EAAA76B,EAAA,YAGA2d,EAAA3d,EAAA,aAEA+7B,EAAA/7B,EAAA,aAgBAlB,GAAA6hC,YAAAA,EAOa7hC,EAAAyc,OACXuf,OAAQ,SACRC,YAAa,QACbC,YAAa,SAAC9d,GACZ,MAAO8d,GAAY9d,KAIVpe,EAAA2c,QACXqf,OAAQ,SACRC,YAAa,SACbC,YAAa,SAAC9d,GACZ,MAAO8d,GAAY9d,EAAO,YAIjBpe,EAAA4c,QACXof,OAAQ,SACRC,YAAa,SACbC,YAAa,SAAC9d,GACZ,MAAO8d,GAAY9d,EAAO,qGC3B9B,SAAAta,GAAWsa,GACT,GAAMoe,GAAOpe,EAAM+V,SAASrwB,EACtBg+B,EAAQ1jB,EAAM+V,SAASuK,GACvBhC,EAASte,EAAMuC,MAAMlF,EAAAY,EAE3B,IAAI6F,EAAAya,WAAWH,IAASA,EAAK1mB,MAAQgsB,EACnC,MAAO/F,GAAOa,eAAe,IAAKxe,EAAO,EACpC,IAAIse,GAAUlf,EAAAsE,kBAAkB4a,EAAOhwB,MAAO,CAEnD,GAAIgwB,EAAOhwB,OAAS8Q,EAAAwU,UAAU8K,KAC5B,MAAOf,GAAOgB,aAAa,IAAK3e,EAGhC,MAAM,IAAIhd,OAAMqP,EAAI1L,QAAQg9B,yBAAyBtL,EAAA6H,KAAM5B,EAAOhwB,OAGpE,MAAMoZ,GAAApe,YACDq0B,EAAOI,cAAc,IAAK/d,EAAO,aACjC2d,EAAOK,eAAehe,EAAO,YAAa,OAKnD,QAAA/S,GAAW+S,GACT,GAAMgf,GAAOhf,EAAM+V,SAAS9oB,EACtB22B,EAAQ5jB,EAAM+V,SAASqK,GACvBlB,EAASlf,EAAMuC,MAAMlF,EAAAa,EAE3B,IAAI4F,EAAAya,WAAWS,IAASA,EAAKtnB,MAAQksB,EACnC,MAAOjG,GAAOa,eAAe,IAAKxe,EAAO,EACpC,IAAIkf,GAAU9f,EAAAsE,kBAAkBwb,EAAO5wB,MAAO,CAEnD,GAAI4wB,EAAO5wB,OAAS8Q,EAAAwU,UAAU8K,KAC5B,MAAOf,GAAOgB,aAAa,IAAK3e,EAGhC,MAAM,IAAIhd,OAAMqP,EAAI1L,QAAQg9B,yBAAyBtL,EAAA6H,KAAMhB,EAAO5wB,OAGpE,MAAMoZ,GAAApe,YACDq0B,EAAOI,cAAc,IAAK/d,EAAO,aACjC2d,EAAOK,eAAehe,EAAO,YAAa,yEAjEnD3C,EAAAva,EAAA,iBACAghB,EAAAhhB,EAAA,kBACAuP,EAAAvP,EAAA,aACAu1B,EAAAv1B,EAAA,cACAsc,EAAAtc,EAAA,eAGA66B,EAAA76B,EAAA,WAIalB,GAAA4P,MACXosB,OAAQ,OACRC,gBAAah5B,GACbi5B,YAAa,SAAC9d,GACZ,MAAM0H,GAAApe,YACD5D,EAAEsa,GACF/S,EAAE+S,GACF2d,EAAOX,MAAMhd,GACb2d,EAAOM,YAAY,UAAWje,0NCjBvC2d,EAAA76B,EAAA,YACA+7B,EAAA/7B,EAAA,aAEalB,GAAA6P,MACXmsB,OAAQ,OACRC,gBAAah5B,GACbi5B,YAAa,SAAC9d,GACL,GAAAK,GAAAL,EAAAK,OAAQ4V,EAAAjW,EAAAiW,QAASpN,EAAA7I,EAAA6I,MAAOC,EAAA9I,EAAA8I,OACzB3H,EAAS8U,EAAQ9U,MAEvB,OAAMuG,GAAApe,YACDq0B,EAAOI,cAAc,IAAK/d,EAAkB,eAAXmB,EAA0B,YAAc0d,EAAIC,KAAKjW,EAAOxI,IACzFsd,EAAOI,cAAc,IAAK/d,EAAkB,aAAXmB,EAAwB,YAAc0d,EAAIM,KAAKrW,EAAQzI,IACxFsd,EAAOK,eAAehe,EAAO,aAE7B2d,EAAOX,MAAMhd,GACb2d,EAAOM,YAAY,UAAWje,GAC9B2d,EAAOM,YAAY,OAAQje,GAC5BghB,UAAW,6FCgBnB,SAAA6C,GAAkBxjB,EAAgByjB,GAChC,MAAIhgB,GAAAya,WAAWuF,IAAYA,EAAQx1B,OAASgS,EAAAkG,cAClC5T,OAAQxB,MAAO,SAAUuZ,QAAS,IAGpC1mB,MAAOoc,EAAOkC,MAAMwhB,eAAiB,GAG/C,QAAAhuB,GAAeggB,EAA4B1V,GAEzC,OAAoBxb,KADA4b,EAAAuF,cAAc,QAAS,OAAQ3F,GAEjD,MAAOuV,GAAAE,gBAAgBC,EAAU1Y,EAAAY,GAAK,SAAW,0EA/CrDZ,EAAAva,EAAA,iBACA2d,EAAA3d,EAAA,aAGAghB,EAAAhhB,EAAA,kBACAwd,EAAAxd,EAAA,cAGA66B,EAAA76B,EAAA,YAEA8yB,EAAA9yB,EAAA,kBAEA+7B,EAAA/7B,EAAA,aAEalB,GAAAuE,MACXy3B,OAAQ,OACRC,gBAAah5B,GAEbi5B,YAAa,SAAC9d,GACL,GAAAK,GAAAL,EAAAK,OAAQ0V,EAAA/V,EAAA+V,SAAUjN,EAAA9I,EAAA8I,OACnBgb,EAAU/N,EAAS5vB,IAEzB,OAAMuhB,GAAApe,YACDq0B,EAAOI,cAAc,IAAK/d,EAAO6jB,EAASxjB,EAAQyjB,IAClDnG,EAAOI,cAAc,IAAK/d,EAAO6e,EAAIM,KAAKrW,EAAQzI,IAClDsd,EAAOx3B,KAAK6Z,GACZ2d,EAAOX,MAAMhd,GACb2d,EAAOM,YAAY,UAAWje,GAC9B2d,EAAOM,YAAY,OAAQje,GAC5BghB,UAAW,aAEVrD,EAAOyE,eAAe,QAASrsB,EAAMggB,EAAU1V,2KCKxD,SAAA2jB,GAAqBhkB,GACZ,GAAAK,GAAAL,EAAAK,OACDc,EAASnB,EAAMiW,QAAQ9U,OAEvB8iB,GAAiCjkB,EAAMuC,MAAiB,eAAXpB,EAA0B,IAAM,UAAY4a,SAE/F,QAA6Bl3B,KAAzBwb,EAAO/B,KAAK4lB,SACd,MAAO7jB,GAAO/B,KAAK4lB,QAEnB,IAAMnI,OAA+Bl3B,KAAnBo/B,EAChBA,EACA5jB,EAAOkC,MAAMwZ,SACf,IAAyB,gBAAdA,GAET,KAAM,IAAI/4B,OAAM,iDAElB,OAAO+4B,GAAY,sEAjDvB4B,EAAA76B,EAAA,YAGA+7B,EAAA/7B,EAAA,aAEalB,GAAA0c,MACXsf,OAAQ,OACRC,YAAa,OAEbC,YAAa,SAAC9d,GACL,GAAAK,GAAAL,EAAAK,OAAQ4V,EAAAjW,EAAAiW,QAASpN,EAAA7I,EAAA6I,MAAOC,EAAA9I,EAAA8I,OACzB3H,EAAS8U,EAAQ9U,OAEjBgjB,EAA2B,eAAXhjB,EAA0B,QAAU,SACpDijB,EAAgC,eAAXjjB,EAA0B,SAAW,OAEhE,OAAMuG,GAAApe,YACDq0B,EAAOI,cAAc,IAAK/d,EAAO6e,EAAIC,KAAKjW,EAAOxI,GAAS,MAC1Dsd,EAAOI,cAAc,IAAK/d,EAAO6e,EAAIM,KAAKrW,EAAQzI,GAAS,MAG3Dsd,EAAOM,YAAY,OAAQje,GAC5BiiB,aAAc+B,EAAYhkB,GAC1BghB,UAAWmD,KACX5b,KAAAA,EACD6b,IAAsBngC,MAAOoc,EAAO/B,KAAK+lB,WAAU9b,GAEjDoV,EAAOX,MAAMhd,GACb2d,EAAOM,YAAY,UAAWje,sFCZvC,SAAAqjB,GAA0BjmB,EAAoBmlB,EAAgC/f,EAAmBD,EAC7FgT,EAAwB+M,GAC1B,MAAIC,IAAchN,GAASnY,IAAYmY,EAAMgC,aAEpCkC,EAAS8I,EAAY/f,GAAY8hB,OAAQ,QAE3C7B,EAASrlB,EAASmlB,EAAY/f,EAAWD,EAAO+f,GAMzD,QAAAiB,GAA2BnmB,EAAsBmnB,EAA6BC,EAA8BhiB,EAAmBD,EAC3HgT,EAAwB+M,GAC1B,MAAIiC,IAAahP,GAEbnY,EAAQtW,OAAO,KAAOyuB,EAAMgC,aAAazwB,OAAO,GAE3C2yB,EAAS8K,EAAW/hB,GAAY8hB,OAAQ,UAE1C7B,EAASrlB,EAASonB,EAAYhiB,EAAWD,EAAO+f,GAMzD,QAAA5qB,GAAoByI,EAA4BqC,EAAmBiiB,EAAwB9Z,GACzF,MAAO8O,GAAStZ,EAAUqC,GAAY8D,UAAWme,GAAO9Z,GAG1D,QAAA8O,GAAyBtZ,EAA4BqC,EAAmB6f,EAAqB1X,GAC3F,GAAMkU,IACJtc,MAAOC,EACP5P,MAAOkR,EAAAlR,MAAMuN,EAAUkiB,GAKzB,OAHI1X,KACFkU,EAAIlU,OAASA,GAERkU,EAGT,QAAAQ,GAAqB7c,EAAmB6c,GACtC,WADsC,KAAAA,IAAAA,GAAA,IAEpC9c,MAAOC,EACP6c,KAAMA,GAOV,QAAAqF,GAAsBvkB,EAA4BqC,GAChD,OACEhC,OAAQ,WACIgC,EAAS,MAAMsB,EAAAlR,MAAMuN,GAAWmG,UAAW,QAASF,KAAM,UAAS,cAEnE5D,EAAS,MAAMsB,EAAAlR,MAAMuN,GAAWmG,UAAW,MAAOF,KAAM,UAAS,QAQjF,QAAAqc,GAAyBrlB,EAAkBmlB,EAAgC/f,EAAmBD,EAC5F+f,GAGA,GAAIC,EAAY,CAEd,GAAIze,EAAAya,WAAWgE,GACb,MAAInjB,GAAAse,WAAWnb,EAAMjU,MAGfqO,EAAAmC,UAAU,IAAK,KAAM1B,GAChBsnB,EAAanC,EAAY/f,GAE3BiX,EAAS8I,EAAY/f,GAAY8D,UAAW,UAGjDlH,EAAAsE,kBAAkBnB,EAAMjU,MACP,SAAfiU,EAAMjU,KAEDmrB,EAAS8I,EAAY/f,GAAY8D,UAAW,SAAU+Y,EAAK7c,EAAW,KAExEiX,EAAS8I,EAAY/f,GAAY8D,UAAW,UAE5CmT,EAAS8I,EAAY/f,KAEzB,QAAyB3d,KAArB09B,EAAWt+B,MACpB,OAAQA,MAAOs+B,EAAWt+B,MAE1B,MAAM,IAAIjB,OAAM,oCAIpB,GAAmB,cAAfs/B,EAA4B,CAE9B,GAAIllB,IAAYC,EAAAY,GAAKb,IAAYC,EAAAqB,GAC/B,MAAOimB,GAAWniB,EAAWD,EACxB,IAAInF,IAAYC,EAAAa,GAAKd,IAAYC,EAAAsB,GACtC,MAAOimB,GAAWpiB,EAAWD,EAE7B,MAAM,IAAIvf,OAAM,uBAAuBoa,EAAO,sBAE3C,GAAmB,cAAfklB,EAA4B,CAErC,GAAIllB,IAAYC,EAAAY,GAAKb,IAAYC,EAAAqB,GAC/B,MAAOmmB,GAAWriB,EAAWD,EACxB,IAAInF,IAAYC,EAAAa,GAAKd,IAAYC,EAAAsB,GACtC,MAAOmmB,GAAWtiB,EAAWD,EAE7B,MAAM,IAAIvf,OAAM,uBAAuBoa,EAAO,sBAGlD,MAAOklB,GAGT,QAAAn8B,GAAqB29B,EAA+CzjB,GAElE,GAAIyjB,EAAS,CACX,GAAIhgB,EAAAya,WAAWuF,GACb,MAAOrjB,GAAA0F,gBAAgB2d,EAAS,QAASzjB,EACpC,IAAIyjB,EAAQ7/B,MACjB,OAAQA,MAAO6/B,EAAQ7/B,OAG3B,OAAQA,MAAOoc,EAAOla,KAAKA,MAG7B,QAAA24B,GAAqBjW,EAAexI,GAClC,GAAIwI,EACF,OAAQ5kB,MAAO4kB,EAAQ,EAGzB,IAAsC,gBAA3BxI,GAAOkC,MAAMwZ,UAEtB,KAAM,IAAI/4B,OAAM,wCAElB,QAAQiB,MAAOoc,EAAOkC,MAAMwZ,UAAY,GAG1C,QAAAoD,GAAqBrW,EAAgBzI,GACnC,GAAIyI,EACF,OAAQ7kB,MAAO6kB,EAAS,EAG1B,IAAsC,gBAA3BzI,GAAOkC,MAAMwZ,UAEtB,KAAM,IAAI/4B,OAAM,wCAElB,QAAQiB,MAAOoc,EAAOkC,MAAMwZ,UAAY,GAG1C,QAAA4I,GAAoBniB,EAAmBD,GACrC,MAAIC,KAEG7F,EAAAmC,UAAUM,EAAAwU,UAAUC,IAAKzU,EAAAwU,UAAUmR,KAAM3lB,EAAAwU,UAAUoR,KAAMziB,EAAMjU,QACnD,IAAfiU,EAAMvP,MAGJuP,MAAOC,EACPve,MAAO,IAKLA,MAAO,GAMjB,QAAA4gC,GAAoBriB,EAAmBD,GACrC,MAAIC,KAEG7F,EAAAmC,UAAUM,EAAAwU,UAAUC,IAAKzU,EAAAwU,UAAUmR,KAAM3lB,EAAAwU,UAAUoR,KAAMziB,EAAMjU,QACnD,IAAfiU,EAAMvP,MAGJuP,MAAOC,EACPve,MAAO,IAIL2O,OAAQxB,MAAO,UAGzB,QAAAwzB,GAAoBpiB,EAAmBD,GACrC,MAAIC,KAEG7F,EAAAmC,UAAUM,EAAAwU,UAAUC,IAAKzU,EAAAwU,UAAUmR,KAAM3lB,EAAAwU,UAAUoR,KAAMziB,EAAMjU,QACnD,IAAfiU,EAAMvP,MAGJuP,MAAOC,EACPve,MAAO,IAKL2O,OAAQxB,MAAO,WAMzB,QAAA0zB,GAAoBtiB,EAAmBD,GACrC,MAAIC,KAEG7F,EAAAmC,UAAUM,EAAAwU,UAAUC,IAAKzU,EAAAwU,UAAUmR,KAAM3lB,EAAAwU,UAAUoR,KAAMziB,EAAMjU,QACnD,IAAfiU,EAAMvP,MAGJuP,MAAOC,EACPve,MAAO,IAKLA,MAAO,mDA3OjB,IAAAoZ,GAAAva,EAAA,iBAEAghB,EAAAhhB,EAAA,kBACAsc,EAAAtc,EAAA,eAEA6Z,EAAA7Z,EAAA,cAEA2d,EAAA3d,EAAA,YAQAlB,GAAAyhC,UAAAA,EAYAzhC,EAAA2hC,WAAAA,EAcA3hC,EAAA8V,IAAAA,EAIA9V,EAAA63B,SAAAA,EAWA73B,EAAAy9B,KAAAA,EAuBAz9B,EAAA6gC,SAAAA,EAsDA7gC,EAAAuE,KAAAA,EAYAvE,EAAAk9B,KAAAA,EAYAl9B,EAAAu9B,KAAAA,gMChKA9hB,EAAAva,EAAA,cAGA8yB,EAAA9yB,EAAA,eACAghB,EAAAhhB,EAAA,eAOA6Z,EAAA7Z,EAAA,WAKA01B,EAAA11B,EAAA,mBAEAkmB,EAAAlmB,EAAA,oBAEAsiB,EAAAtiB,EAAA,UAgCAmiC,EAAA,WAGE,QAAAA,KACE7iC,KAAK8iC,WAqBT,MAlBSD,GAAAn/B,UAAAq/B,OAAP,SAAcC,EAAiB5X,GAC7BprB,KAAK8iC,QAAQE,GAAW5X,GAInByX,EAAAn/B,UAAAD,IAAP,SAAWa,GACT,WAA8B7B,KAAvBzC,KAAK8iC,QAAQx+B,IAGfu+B,EAAAn/B,UAAAwO,IAAP,SAAW5N,GAGT,KAAOtE,KAAK8iC,QAAQx+B,IAClBA,EAAOtE,KAAK8iC,QAAQx+B,EAGtB,OAAOA,IAEXu+B,IAzBarjC,GAAAqjC,QAAAA,CA2Bb,IAAAja,GAAA,WAoBE,QAAAA,GAAYvG,EAAgBjgB,EAAekgB,EAAyBrE,GAApE,GAAA+I,GAAAhnB,IAFyBA,MAAAinB,YA+OlBjnB,KAAAg4B,iBAAmB,SAACrc,GAazB,MATIA,GAAKsb,MAAQtb,EAAKsb,KAAKzgB,OACzBmF,EAAKsb,KAAKzgB,KAAOwQ,EAAKic,iBAAiBtnB,EAAKsb,KAAKzgB,OAI/CmF,EAAKsb,MAAQtb,EAAKsb,KAAKjM,OAASrP,EAAKsb,KAAKjM,MAAMxU,OAClDmF,EAAKsb,KAAKjM,MAAMxU,KAAOwQ,EAAKic,iBAAiBtnB,EAAKsb,KAAKjM,MAAMxU,OAGxDmF,GAzPP3b,KAAKoC,OAASA,EACdpC,KAAKie,OAASA,EAGdje,KAAKsE,KAAO+d,EAAK/d,MAAQge,EAGzBtiB,KAAKkjC,aAAe9gC,EAASA,EAAO8gC,aAAe,GAAIL,GACvD7iC,KAAKmjC,YAAc/gC,EAASA,EAAO+gC,YAAc,GAAIN,GAErD7iC,KAAKwW,KAAO6L,EAAK7L,KAEjBxW,KAAKmV,YAAckN,EAAKlN,YACxBnV,KAAKuwB,WAAalO,EAAK0K,cAEvB/sB,KAAKonB,WACH5Q,MACEuR,QAAS3lB,EAASA,EAAOglB,UAAU5Q,KAAKuR,WACxCuD,YAAalpB,EAASA,EAAOglB,UAAU5Q,KAAK8U,gBAE9C3P,KAAM,KAAM8L,OAAQ,KAAMpI,MAAO/b,EAAG,KAAMuH,EAAG,MAC7CusB,eAAe/O,OAASC,WAAaR,QAAS,KAAMR,UAAW,MA+OrE,MA3OSsB,GAAAllB,UAAAE,MAAP,WACE5D,KAAKmnB,YACLnnB,KAAKwnB,aACLxnB,KAAKqnB,iBACLrnB,KAAK2nB,qBACL3nB,KAAK6nB,cACL7nB,KAAK0nB,aA0BAkB,EAAAllB,UAAAykB,eAAP,WACE,MAAOvB,GAAAwc,cAAcpjC,OAGhB4oB,EAAAllB,UAAA2/B,oBAAP,WAIE,IAAsB,GAHfjM,GAAAp3B,KAAAonB,UAAAgQ,cACDkM,KAEgB/b,EAAA,EAAAgc,EAAAnN,EAAAkD,gBAAA/R,EAAAgc,EAAAviC,OAAAumB,IAAe,CAAhC,GAAMvM,GAAOuoB,EAAAhc,EACZ6P,GAAcpc,GAASiG,OACzBqiB,EAAYzgC,KAAKuzB,EAAAyC,cAAc74B,KAAMgb,IAIzC,IAAsB,GAAAmL,GAAA,EAAAqd,EAAApN,EAAAkD,gBAAAnT,EAAAqd,EAAAxiC,OAAAmlB,IAEpB,IAAyB,GAFhBnL,GAAOwoB,EAAArd,GACVwR,EAAeP,EAAcpc,GACVylB,EAAA,EAAAgD,EAAArN,EAAAmD,aAAAkH,EAAAgD,EAAAziC,OAAAy/B,IAAY,CAAhC,GAAM7I,GAAU6L,EAAAhD,EACnB,IAAI9I,EAAaC,GACf,IAAqB,GAAA8L,GAAA,EAAAC,EAAAhM,EAAaC,GAAb8L,EAAAC,EAAA3iC,OAAA0iC,IAAwB,CAAxC,GAAMpM,GAAMqM,EAAAD,GACTE,EAAcxN,EAAA+C,eAAen5B,KAAMgb,EAAS4c,EAAYD,EAAcL,EACxEsM,IACFN,EAAYzgC,KAAK+gC,IAM3B,MAAON,IAKF1a,EAAAllB,UAAAmgC,aAAP,WACQ,GAAA1d,GAAAnmB,KAAAonB,UAAA/H,KAAC/b,EAAA6iB,EAAA7iB,EAAGuH,EAAAsb,EAAAtb,CAEV,QACMvH,EAAIA,EAAE+b,KAAK7T,OAAOlI,EAAEgc,cAAe9T,OACnCX,EAAIA,EAAEwU,KAAK7T,OAAOX,EAAEyU,eAIrBsJ,EAAAllB,UAAAogC,gBAAP,WACE,MAAOvpB,GAAAsH,KAAK7hB,KAAKonB,UAAUU,UAGtBc,EAAAllB,UAAA0iB,cAAP,SAAqBN,OAAA,KAAAA,IAAAA,KACnB,IAAM9W,KAEN8W,GAAUA,EAAQta,OAAOxL,KAAKioB,4BAC1BnC,EAAQ9kB,OAAS,IACnBgO,EAAM8W,QAAUA,EAGlB,IAAMO,GAASrmB,KAAKumB,gBAChBF,KACFrX,EAAMqX,OAASA,GAGjBrX,EAAMN,SAAWlD,OACfxL,KAAKqjC,sBACLrjC,KAAK0oB,gBAEP,IAAMjB,GAASznB,KAAKmoB,gBAChBV,GAAOzmB,OAAS,IAClBgO,EAAMyY,OAASA,EAGjB,IAAMpI,GAAOrf,KAAK6jC,cACdxkB,GAAKre,OAAS,IAChBgO,EAAMqQ,KAAOA,EAGf,IAAMyI,GAAU9nB,KAAK8jC,iBAKrB,OAJIhc,GAAQ9mB,OAAS,IACnBgO,EAAM8Y,QAAUA,GAGX9Y,GAKF4Z,EAAAllB,UAAAkyB,gCAAP,SAAuC5a,GACrC,IAAoB,GAAAuM,GAAA,EAAApB,EAAAnmB,KAAKinB,SAALM,EAAApB,EAAAnlB,OAAAumB,IAAa,CAA5B,GAAM9U,GAAK0T,EAAAoB,EACd,IAAI9U,YAAiBuQ,GAAAC,WACnB,GAAIxQ,EAAMihB,gBAAgB1Y,GACxB,OAAO,MAGT,IAAIvI,EAAMmjB,gCAAgC5a,GACxC,OAAO,EAIb,OAAO,GAGF4N,EAAAllB,UAAAqiB,QAAP,SAAehiB,GACb,MAAOwW,GAAAwpB,SAAS/jC,KAAKsE,KAAOtE,KAAKsE,KAAO,IAAM,IAAMP,IAM/C6kB,EAAAllB,UAAA07B,gBAAP,SAAuB96B,GACrB,GAAM0/B,GAAWhkC,KAAK+lB,QAAQzhB,EAE9B,OAAOtE,MAAKijC,iBAAiBe,IAGxBpb,EAAAllB,UAAAilB,iBAAP,SAAwBmN,GAEtB,OACE1X,OAAQpe,KAAK+lB,QAAQ+P,KAOlBlN,EAAAllB,UAAAu/B,iBAAP,SAAwB3+B,GACtB,GAAMxC,GAAO9B,KAAKonB,UAAU5Q,KAAK8U,YAAYhnB,EAE7C,OAAKxC,GAKEA,EAAKyD,OAHHjB,GAMJskB,EAAAllB,UAAAugC,WAAP,SAAkBjB,EAAiB5X,GACjCprB,KAAKmjC,YAAYJ,OAAOC,EAAS5X,IAG5BxC,EAAAllB,UAAAwgC,gBAAP,SAAuBlpB,GACrB,MAAOhb,MAAKmkC,SAASnpB,IAAYC,EAAAY,GAAKb,IAAYC,EAAAE,OAAS,QAAU,WAGhEyN,EAAAllB,UAAAygC,SAAP,SAAgBlyB,GACb,MAAOjS,MAAKmjC,YAAYjxB,IAAIlS,KAAK+lB,QAAQ9T;EAGrC2W,EAAAllB,UAAAmzB,YAAP,SAAmBmM,EAAiB5X,GAClCprB,KAAKkjC,aAAaH,OAAOC,EAAS5X,IAI7BxC,EAAAllB,UAAAyc,MAAP,SAAanF,GACX,MAAO,OAMF4N,EAAAllB,UAAA0c,UAAP,SAA8BgkB,EAAqCxgC,GACjE,MAAIA,GAIK5D,KAAK+lB,QAAQqe,GAOjBpkC,KAAKmgB,OAASlF,EAAAO,UAAU4oB,IAAsBpkC,KAAKmgB,MAAMikB,IAE1DpkC,KAAKkjC,aAAaz/B,IAAIzD,KAAK+lB,QAAQqe,IAE9BpkC,KAAKkjC,aAAahxB,IAAIlS,KAAK+lB,QAAQqe,QAN5C,IAmCKxb,EAAAllB,UAAAm9B,aAAP,SAAoB30B,EAA8B5H,GAChD,MAAOtE,MAAKonB,UAAUlb,GAAM5H,IAAStE,KAAKoC,OAAOy+B,aAAa30B,EAAM5H,IAExEskB,IAzRsBppB,GAAAopB,MAAAA,CA4RtB,IAAAsI,GAAA,SAAAnK,GAAA,QAAAmK,oDAqCA,MArC6C5L,GAAAre,UAAAiqB,EAAAnK,GAIpCmK,EAAAxtB,UAAA8M,MAAP,SAAawK,EAAkBilB,OAAA,KAAAA,IAAAA,KAC7B,IAAMliB,GAAW/d,KAAK+d,SAAS/C,EAQ/B,OANI+C,GAASzI,MACX2qB,EAAM1lB,EAAA3I,QACJsS,UAAWlkB,KAAKshB,kBAAkBtG,GAAW,QAAU,SACtDilB,IAGEve,EAAAlR,MAAMuN,EAAUkiB,IAUlB/O,EAAAxtB,UAAAkrB,eAAP,SAA4BrvB,EAAoD8kC,EAASlkC,GACvF,MAAOqzB,GAAArU,OAAOnf,KAAKi4B,aAAc,SAACqM,EAAQC,EAAwB9/B,GAChE,MAAOid,GAAAya,WAAWoI,GAAMhlC,EAAE+kC,EAAKC,EAAI9/B,GAAK6/B,GACvCD,EAAMlkC,IAGJ+wB,EAAAxtB,UAAAimB,gBAAP,SAAuBpqB,EAA+CY,GACpEqzB,EAAAjhB,QAAQvS,KAAKi4B,aAAc,SAACsM,EAAwB9/B,GAC9Cid,EAAAya,WAAWoI,IACbhlC,EAAEglC,EAAI9/B,IAEPtE,IAGP+wB,GArC6CtI,EAAvBppB,GAAA0xB,eAAAA,oKCpVtB,SAAAmF,GAAuCrL,EAAqBzI,GAC1D,MAAOiiB,GAAgBxZ,EAAOzI,GAGhC,QAAAkiB,GAA0C9Q,EAA2BpR,GACnE,MAAOiiB,GAAgB7Q,EAAUpR,GAQnC,QAAAmiB,GAAmC3mB,EAA2BwE,GAC5D,GAAM/R,GAAQuN,EAASvN,KACvB,OAAIkR,GAAAijB,YAAYn0B,GACVA,EAAM+C,SAAUgP,GACZ+C,EAAApe,YACD6W,GACHvN,MAAO+R,EAAS/R,EAAM+C,WAGxBtD,EAAIgB,KAAKhB,EAAI1L,QAAQqgC,oBAAoBp0B,EAAM+C,SACxC,MAIFwK,EAIX,QAAAymB,GAAyBK,EAAiCtiB,GACxD,GAAM5f,KACN,KAAK,GAAMqY,KAAW6pB,GACpB,GAAIA,EAAQlhC,eAAeqX,GAAU,CACnC,GAAM+C,GAAgD8mB,EAAQ7pB,EAE9D,IAAI8Z,EAAApyB,QAAQqb,GACVpb,EAAIqY,GAAW+C,EAASvQ,IAAI,SAAAoc,GAAM,MAAA8a,GAA0B9a,EAAIrH,KAC7D5U,OAAO,SAACic,GAAgC,MAAO,QAAPA,QACtC,CACL,GAAMA,GAAK8a,EAA0B3mB,EAAUwE,EACpC,QAAPqH,IACFjnB,EAAIqY,GAAW4O,IAKvB,MAAOjnB,qEAxETmyB,EAAAp0B,EAAA,aACAua,EAAAva,EAAA,cAIAghB,EAAAhhB,EAAA,eACAuP,EAAAvP,EAAA,UAGA6Z,EAAA7Z,EAAA,WACAy1B,EAAAz1B,EAAA,kBACA2d,EAAA3d,EAAA,YACAkmB,EAAAlmB,EAAA,mBACAmmB,EAAAnmB,EAAA,gBAEAomB,EAAApmB,EAAA,WACAy3B,EAAAz3B,EAAA,iBAQAlB,GAAA62B,uBAAAA,EAIA72B,EAAAilC,0BAAAA,CA+CA,IAAArhB,GAAA,SAAA2D,GAKE,QAAA3D,GAAYf,EAAkBjgB,EAAekgB,EAAyBwiB,EAA6B7mB,GAAnG,GAAA+I,GACED,EAAAhmB,KAAAf,KAAMqiB,EAAMjgB,EAAQkgB,EAAiBrE,IAAOje,WAE5CgnB,GAAKzT,OAAS8O,EAAK9O,OACnByT,EAAKC,SAAWD,EAAK+d,cAAc1iB,EAAM2E,EAAKzT,OAAQuxB,EAAc7mB,KA0LxE,MAnMiCqH,GAAAre,UAAAmc,EAAA2D,GAYvB3D,EAAA1f,UAAAqhC,cAAR,SAAsB1iB,EAAkB9O,EAAgBgP,EAAyBtE,GAM/E,IAAuB,GALjBgJ,MACAoB,EAAM9U,EAAO8U,MAAQ9F,EAAWA,EAAS8F,IAAM,MAC/CC,EAAS/U,EAAO+U,SAAW/F,EAAWA,EAAS+F,OAAS,MAGvCf,EAAA,EAAAyd,EAAA3c,EAAAd,EAAAyd,EAAAhkC,OAAAumB,IACrB,IAA0B,GADjBwI,GAAQiV,EAAAzd,GACSpB,EAAA,EAAA8e,EAAA3c,EAAAnC,EAAA8e,EAAAjkC,OAAAmlB,IAAM,CAA3B,GAAM0J,GAAWoV,EAAA9e,GACd+e,GAAQnV,EAAW,IAAMA,EAAW,KAAOF,EAAc,IAAMA,EAAc,IAE7EsV,GACJ9c,IAAK0H,EACLzH,OAAQuH,EAGV5I,GAASpkB,KAAKwb,EAAA+D,WAAWC,EAAKA,KAAMriB,KAAMA,KAAK+lB,QAAQ,QAAUmf,GAAOC,EAAalnB,IAIzF,MAAOgJ,IAGF7D,EAAA1f,UAAAyjB,UAAP,WACEnnB,KAAKonB,UAAU5Q,KAAOqQ,EAAAM,UAAUnnB,MAChCA,KAAKinB,SAAS1U,QAAQ,SAACE,GACrBA,EAAM0U,eAIH/D,EAAA1f,UAAA2jB,eAAP,WAAA,GAAAL,GAAAhnB,IAIEA,MAAKonB,UAAUE,YACf,KAAoB,GAAAC,GAAA,EAAApB,EAAAnmB,KAAKinB,SAALM,EAAApB,EAAAnlB,OAAAumB,IAAa,CAA5B,GAAM9U,GAAK0T,EAAAoB,aAAL9U,GACTA,EAAM4U,iBACN9M,EAAAvX,KAAKyP,EAAM2U,UAAUE,WAAW/U,QAAQ,SAAC3Q,GACvColB,EAAKI,UAAUE,UAAU1lB,GAAO6Q,EAAM2U,UAAUE,UAAU1lB,MAHnD6Q,KAQN2Q,EAAA1f,UAAA8jB,WAAP,WACE,GAAM5J,GAAQ5d,KAER02B,EAAgC12B,KAAKonB,UAAUK,SAErDznB,MAAKinB,SAAS1U,QAAQ,SAASE,GAC7BA,EAAM+U,aAKJjN,EAAAvX,KAAKyP,EAAM2U,UAAUK,QAAQlV,QAAQ,SAASyI,GAC5C,GAAIT,EAAAmC,SAASzB,EAAAqC,0BAA2BtC,GAAU,CAChD,GAAMsd,GAAa7lB,EAAM2U,UAAUK,OAAOzM,GACpCud,EAAa7B,EAAe1b,EAElC,KAAKsd,GAAcnC,EAAAqC,kBAAkBF,EAAWxX,SAAYyX,GAAcpC,EAAAqC,kBAAkBD,EAAWzX,QAErG,MAGEyX,GACFA,EAAWzX,OAASqX,EAAAM,aAAaF,EAAWzX,OAAQwX,EAAWxX,QAE/D4V,EAAe1b,GAAWsd,CAI5B,IAAM3B,GAAyB2B,EAAWh0B,KAAKsyB,OAAOnkB,EAAMsT,QAAQ,IAAI/kB,QAClEoqB,EAAUxN,EAAMwC,UAAUuW,GAAwB,EACxDlkB,GAAMokB,YAAYyB,EAAWh0B,KAAM8mB,GACnCkN,EAAWh0B,KAAO8mB,QAGX3Y,GAAM2U,UAAUK,OAAOzM,SAOjCoI,EAAA1f,UAAAgkB,UAAP,WACE,IAAoB,GAAAH,GAAA,EAAApB,EAAAnmB,KAAKinB,SAALM,EAAApB,EAAAnlB,OAAAumB,IAAa,CAAjBpB,EAAAoB,GACRG,cAIHtE,EAAA1f,UAAAikB,mBAAP,WACE,IAAoB,GAAAJ,GAAA,EAAApB,EAAAnmB,KAAKinB,SAALM,EAAApB,EAAAnlB,OAAAumB,IAAa,CAAjBpB,EAAAoB,GACRI,uBAIHvE,EAAA1f,UAAAkkB,eAAP,WACE,MAAO,OAGFxE,EAAA1f,UAAAmkB,YAAP,WAGE,IAAoB,GAFd6Q,GAAkB14B,KAAKonB,UAAUU,WAEnBP,EAAA,EAAApB,EAAAnmB,KAAKinB,SAALM,EAAApB,EAAAnlB,OAAAumB,IAAa,CAA5B,GAAM9U,GAAK0T,EAAAoB,aAAL9U,GACTA,EAAMoV,cAIJtN,EAAAvX,KAAKyP,EAAM2U,UAAUU,SAASvV,QAAQ,SAASyI,GAExC0d,EAAgB1d,KACnB0d,EAAgB1d,GAAWvI,EAAM2U,UAAUU,QAAQ9M,UAE9CvI,GAAM2U,UAAUU,QAAQ9M,MAV1BvI,KAgBN2Q,EAAA1f,UAAAkiB,aAAP,WACG,MAAK5lB,MAAKoC,UAEFwkB,EAAAhB,aAAarL,EAAAsH,KAAK7hB,KAAKonB,UAAU5Q,KAAKuR,WAM1C3E,EAAA1f,UAAAijB,8BAAP,WACE,MAAO,OAGFvD,EAAA1f,UAAAuiB,iCAAP,SAAwCH,GACtC,MAAO9lB,MAAKinB,SAAS9H,OAAO,SAAC6I,EAAIvV,GAAU,MAAAA,GAAMwT,iCAAiC+B,IAAKlC,IAGlF1C,EAAA1f,UAAAukB,yBAAP,WAEE,MADAjoB,MAAKinB,SAAS1U,QAAQ,SAACE,GAAU,MAAAA,GAAMwV,iCAIlC7E,EAAA1f,UAAAsiB,sBAAP,WACE,MAAOhmB,MAAKinB,SAAS9H,OAAO,SAAC2G,EAASrT,GACpC,MAAOqT,GAAQta,OAAOiH,EAAMuT,+BAIzB5C,EAAA1f,UAAAmiB,sBAAP,SAA6BrP,GAC3B,MAAOxW,MAAKinB,SAAS9H,OAAO,SAAC+I,EAAIzV,GAAU,MAAAA,GAAMoT,sBAAsBqC,SAGlE9E,EAAA1f,UAAAykB,eAAP,WAEE,MAAOnoB,MAAKinB,SAAS9H,OAAO,SAACsI,EAAQhjB,GACnC,MAAOgjB,GAAOjc,OAAO/G,EAAE0jB,mBACtBpB,EAAArjB,UAAMykB,eAAcpnB,KAAAf,QAGlBojB,EAAA1f,UAAA6iB,eAAP,WAEE,OACE6B,SAAUC,IAAK,GAAIC,OAAQ,IAC3BC,OAAQ,GACRC,QAASxoB,KAAKuT,QAAUvT,KAAKuT,OAAO+U,OAAStoB,KAAKuT,OAAO+U,OAAOtnB,OAAS,EACzEynB,OAAQ,OACR9U,MAAO,QAIJyP,EAAA1f,UAAAglB,cAAP,WAEE,MAAO1oB,MAAKinB,SAASzZ,IAAI,SAAAiF,GAAS,MAAA6S,GAAApe,UAChCgF,KAAM,QACN5H,KAAMmO,EAAMsT,QAAQ,SACpBrF,QACEC,OAAM2E,EAAApe,UACJuf,MAAOhU,EAAMkW,iBAAiB,SAC9BjC,OAAQjU,EAAMkW,iBAAiB,WAC5BlW,EAAMkU,mCAGVlU,EAAM2T,oBAGfhD,GAnMiC0D,EAAA8B,MAApBppB,GAAA4jB,YAAAA,gOCtEb,SAAAggB,GAA8BxlB,GAC1B,MAAOrD,GAAAsH,KAAKjE,EAAMwJ,UAAUK,QAAQja,IAAI,SAAA2S,GAEtC,GAAMW,GAASX,EAAMW,MACrB,IAAIqV,EAAAW,gBAAgBhW,IAAWqV,EAAAY,sBAAsBjW,GAEnD,MADAA,GAAOtK,KAAOoH,EAAMqlB,iBAAiBniB,EAAOtK,MACrC2J,CACF,IAAIgW,EAAAa,uBAAuBlW,GAOhC,MANAA,GAAOjR,OAASiR,EAAOjR,OAAOrC,IAAI,SAACjO,GACjC,MAAM+lB,GAAApe,YACD3H,GACHiX,KAAMoH,EAAMqlB,iBAAiB1jC,EAAEiX,UAG5B2J,CACF,IAAIgW,EAAAqC,kBAAkB1X,IAAWgU,EAAApyB,QAAQoe,GAC9C,MAAOX,EAEP,MAAM,IAAIvf,OAAM,4FAvBxBk0B,EAAAp0B,EAAA,aACA6Z,EAAA7Z,EAAA,cACAy1B,EAAAz1B,EAAA,oBAGAlB,GAAA4jC,cAAAA,mGCoBA,SAAAgC,GAA2BtkB,EAAgB/C,EAA4BoC,EAAkBklB,GACvF,GAAe,iBAAXvkB,EAA2B,CACvB,GAAAqF,GAAAmf,EAAAvnB,EAAAoC,GAAColB,EAAApf,EAAAof,MAAOC,EAAArf,EAAAqf,MACd,KAAID,EAEF,WADAt1B,GAAIgB,KAAKu0B,OAGN,QAAe/iC,KAAXqe,GAAwBukB,EAAYI,sBAAuB,CAE7D,GAAAF,GAAAD,EAAAvnB,EAAAoC,GAAAolB,KACP,IAAIA,EACF,MAAO,eAIX,MAAOzkB,GAIT,QAAA4kB,GAA4B9nB,EAAkB5C,GAC5C,GAAMmF,GAAQvC,EAAMuC,MAAMnF,EAG1B,OAAgB,MAAZA,GAAmB4C,EAAM8V,gBAAgB,MACvC9V,EAAM8V,gBAAgB,KACjB+E,EAAakN,EAAyBxlB,EAAOvC,EAAO,KAAM+nB,EAAyBxlB,EAAOvC,EAAO,OAEjG+nB,EAAyBxlB,EAAOvC,EAAO,MAE3B,MAAZ5C,GAAmB4C,EAAM8V,gBAAgB,MAC9C9V,EAAM8V,gBAAgB,KACjB+E,EAAakN,EAAyBxlB,EAAOvC,EAAO,KAAM+nB,EAAyBxlB,EAAOvC,EAAO,OAEjG+nB,EAAyBxlB,EAAOvC,EAAO,MAG3C+nB,EAAyBxlB,EAAOvC,EAAO5C,GAGhD,QAAA2qB,GAAkCxlB,EAAcvC,EAAkB5C,GAChE,GAAM+C,GAAWH,EAAMG,SAAS/C,EAEhC,IAAImF,EAAMW,QAA2B,iBAAjBX,EAAMW,OACxB,MAAIgB,GAAAC,WAAW5B,EAAMW,OAAO,IAClBX,EAAMW,OAAsBtT,IAAI,SAACwU,GACvC,MAAOF,GAAAG,UAAUD,GAAI,KAGlB7B,EAAMW,MAGf,IAAMqS,GAAQvV,EAAMuV,KACpB,IAAIA,GAASnY,IAAYmY,EAAMgC,aAC7B,MAAoB,cAAjBhC,EAAM5K,QACC,EAAG,IAGX/R,KAAMoH,EAAMwhB,gBAAgBnT,EAAAC,MAC5Brc,QACE+N,EAAMpN,MAAMwK,GAAUknB,OAAQ,UAC9BtkB,EAAMpN,MAAMwK,GAAUknB,OAAQ,SAKpC,IAAMh/B,GAAO0iC,EAAWhoB,EAAO5C,EAASmF,EAAMjU,KAE9C,IAAqB,iBAAjBiU,EAAMW,OACR,OACEtK,KAAMoH,EAAMwhB,gBAAgBnT,EAAAC,MAC5Brc,QACE+N,EAAMpN,MAAMwK,GAAUqJ,UAAW,QACjCzG,EAAMpN,MAAMwK,GAAUqJ,UAAW,SAGhC,IAAItG,EAASzI,IAAK,CACvB,GAAI0H,EAAAse,WAAWnb,EAAMjU,MAAO,CAC1B,GAAMkS,GAASR,EAAMmI,QAAWsH,EAAAvS,YAAYiD,EAASzI,KAAI,IAAIyI,EAASvN,MAAK,QAC3E,QAAQ4N,OAAQ,YAAYA,EAAM,WAAWA,EAAM,WAAWA,EAAM,UAAUA,EAAM,UAGtF,MAAIpB,GAAAsE,kBAAkBnB,EAAMjU,OAIxBsK,KAAMoH,EAAMwhB,gBAAgBnT,EAAAC,MAC5B1b,MAAOoN,EAAMpN,MAAMwK,GAAUkJ,UAAW,UACxChhB,MACEsN,MAAOoN,EAAMpN,MAAMwK,GAAUkJ,UAAW,UACxCvZ,GAAI,QAIQ,MAAZqQ,GAA+B,MAAZA,GAGnBxE,KAAMoH,EAAMwhB,gBAAgBnT,EAAAC,MAC5Brc,QACE+N,EAAMpN,MAAMwK,GAAUkJ,UAAW,UACjCtG,EAAMpN,MAAMwK,GAAUkJ,UAAW,WAMnC1N,KAAMoH,EAAMwhB,gBAAgBnT,EAAAC,MAC5B1b,MAAOoN,EAAMpN,MAAMwK,GAAUkJ,UAAW,WAIzC,MAAIhhB,IAKPsT,KAAMspB,EAAKntB,UAAUzP,GAAQ0a,EAAMwhB,gBAAgBnT,EAAAC,MAAQtO,EAAMwhB,gBAAgBnT,EAAA+G,KACjFxiB,MAAOoN,EAAMpN,MAAMwK,GACnB9X,KAAMA,IAINsT,KAAMoH,EAAMwhB,gBAAgBnT,EAAAC,MAC5B1b,MAAOoN,EAAMpN,MAAMwK,IAMzB,QAAA4qB,GAA2BhoB,EAAkB5C,EAAkB4B,GAC7D,GAAKI,EAAAsE,kBAAkB1E,GAAvB,CAIA,GAAM1Z,GAAO0a,EAAM1a,KAAK8X,EAGxB,OAAIyY,GAAAK,YAAY5wB,IAEZyH,GAAIzH,EAAKyH,GACT6F,MAAOtN,EAAKsN,SAIZsvB,EAAKpjB,UAAU,YAAa,iBAAcja,IAAoCS,QAAlF,IAiBF,QAAAoiC,GAAyCvnB,EAA4BnB,GACnE,MAAKmB,GAASsG,UAOTmH,EAAA5Q,uBAAuBmD,EAASsG,WAOf,iBAAlBtG,EAAS7R,MACO,QAAd0Q,GAEA2oB,OAAO,EACPC,OAAQv1B,EAAI1L,QAAQshC,+BAA+B9nB,KAKjDwnB,OAAO,IAdXA,OAAO,EACPC,OAAQv1B,EAAI1L,QAAQuhC,uCAAuC/nB,EAASsG,aARpEkhB,OAAO,EACPC,OAAQv1B,EAAI1L,QAAQwhC,wCAAwChoB,IAkClE,QAAAioB,GAAyBllB,GACvB,GAAIgf,EAAKp9B,QAAQoe,GACf,OAAQA,EACH,IAAIqV,EAAAW,gBAAgBhW,GAEzB,aADOA,GAAO5d,MACN4d,EACH,IAAGqV,EAAAY,sBAAsBjW,GAC9B,MAAOA,GAAOjR,OAAOrC,IAAI,SAAA/E,GACvB,OACE+N,KAAMsK,EAAOtK,KACbhG,MAAO/H,IAGN,IAAI0tB,EAAAa,uBAAuBlW,GAChC,MAAOA,GAAOjR,OAAOrC,IAAI,SAAA/E,GACvB,MAAIq3B,GAAKp9B,QAAQ+F,GACRA,GAGP+N,KAAM/N,EAAE+N,KACRhG,MAAO/H,EAAE+H,QAKf,MAAM,IAAI5P,OAAMqP,EAAI1L,QAAQ0hC,eAM9B,QAAAxN,GAA6ByN,EAAmBC,GAC9C,GAAIhQ,EAAAqC,kBAAkB0N,IAAY/P,EAAAqC,kBAAkB2N,GAAU,CAC5D,IAAKhQ,EAAAqC,kBAAkB0N,KAAa/P,EAAAqC,kBAAkB2N,IAAYD,EAAQ9nB,SAAW+nB,EAAQ/nB,OAC3F,KAAM,IAAIxd,OAAMqP,EAAI1L,QAAQ6hC,wBAE9B,OAAOF,GAGT,GAAMG,GAAoBL,EAAgBE,GACpCI,EAAoBN,EAAgBG,GAEtCI,EAAUF,EAAkB76B,OAAO86B,EAGvC,IAFAC,EAAUzG,EAAK0G,OAAOD,EAASzG,EAAK5N,MAEhCqU,EAAQvlC,OAAS,EAAG,CACtB,GAAMylC,GAAUF,EAAQ/4B,IAAI,SAAA/E,GAC1B,MAAI0tB,GAAAW,gBAAgBruB,GACXA,EAAE+N,KAEJ,MAGT,OAA4C,KAAxCspB,EAAK0G,OAAOC,EAAS,SAAAnjC,GAAK,MAAAA,KAAGtC,QAA+B,OAAfylC,EAAQ,IAErDjwB,KAAMiwB,EAAQ,GACd52B,OAAQ02B,EAAQ/4B,IAAI,SAAA/E,GAAK,MAACA,GAAgB+H,UAItCX,OAAQ02B,EAASrjC,MAAM,GAE/B,MAAOqjC,GAAQ,mDA7RnB,IAAAt2B,GAAAvP,EAAA,aAEA8qB,EAAA9qB,EAAA,mBACA2sB,EAAA3sB,EAAA,aAEAohB,EAAAphB,EAAA,kBAEAsc,EAAAtc,EAAA,eACA+yB,EAAA/yB,EAAA,cACAo/B,EAAAp/B,EAAA,cACAy1B,EAAAz1B,EAAA,qBAYAurB,EAAAvrB,EAAA,aAGAlB,GAAA4lC,WAAAA,EAmBA5lC,EAAAkmC,YAAAA,EA6GAlmC,EAAAomC,WAAAA,EAgCApmC,EAAA8lC,yBAAAA,EAqEA9lC,EAAAi5B,aAAAA,oMCxNA,SAAA4L,GACIrpB,EAAkB+C,EAAiCE,EACnDtC,EAAwB+qB,EAAkCC,GAC5D,GAAMC,IAAkB7oB,OAAgBoC,UAElCA,GACJjU,KAAMgS,EAAA2oB,QACJD,EAAe16B,KAAM8O,EAAS+C,EAAUpC,MAAuBlZ,KAAjBikC,EAC9CE,EAAejN,UAAW1b,EAAOkC,OA2BrC,OAtBA3gB,GAAAsnC,gCAAgCv0B,QAAQ,SAAS+N,GAC/C,GAAMymB,GAAiBH,EAAetmB,GAEhC0mB,EAAuBhqB,EAAAiqB,yBAAyB9mB,EAAMjU,KAAMoU,GAC5D4mB,EAAyBlqB,EAAAmqB,oCAAoCnsB,EAASsF,EAU5E,QARuB7d,KAAnBskC,IAEGC,EAEME,GACTj3B,EAAIgB,KAAKi2B,GAFTj3B,EAAIgB,KAAKhB,EAAI1L,QAAQ6iC,kCAAkCjnB,EAAMjU,KAAMoU,EAAUtF,KAK7EgsB,OAAmDvkC,KAA3BykC,EAAsC,CAChE,GAAMrlC,GAAQwlC,EAASN,EAAgBzmB,EAAUH,EAAOnF,EAAS+C,EAAUE,EAAOkC,WACpE1d,KAAVZ,IACFse,EAAMG,GAAYze,MAKjBi+B,EAAKluB,OACVuO,EACAmnB,EAAAT,QACE7rB,EAASmF,EAAMjU,KAAM6R,EAAS7R,KAAM06B,EAAgB3oB,EACpDkC,EAAMvP,KAAM+K,EAAM+qB,EAAcC,IAKtC,QAAAU,GAAkBN,EAAqBzmB,EAAuBH,EAAcnF,EAAkB+C,EAA4BsnB,GAExH,MAAiB,WAAb/kB,EACK6X,EAAAiN,WAAW2B,EAAgBhpB,EAAUoC,EAAMjU,KAAMm5B,OAInC5iC,KAAnBskC,EACKA,EAEFQ,EAAgBjnB,EAAUH,EAAOnF,EAAS+C,EAAUsnB,GAG7D,QAAAkC,GAAyBjnB,EAAuBH,EAAcnF,EAAkB+C,EAA4BsnB,GAG1G,OAAQ/kB,GACN,IAAK,OACH,MAAOO,GAAM2mB,KAAKrnB,EAAMjU,KAAM8O,EAAS+C,EACzC,KAAK,UACH,MAAO8C,GAAMuH,QAAQpN,EAASmF,EAAMjU,KAAMm5B,EAC5C,KAAK,eACH,MAAOxkB,GAAMiZ,aAAa3Z,EAAMiI,QAASpN,EAASqqB,EACpD,KAAK,eACH,MAAOxkB,GAAMgZ,aAAa1Z,EAAMiI,QAASpN,EAASmF,EAAMjU,KAAMiU,EAAM2Z,aAAcuL,EACpF,KAAK,QACH,MAAOxkB,GAAM4mB,MAAMzsB,EAASqqB,EAC9B,KAAK,OACH,MAAOxkB,GAAMjQ,KAAKuP,EAAOnF,EAAS+C,GAGtC,MAAOsnB,GAAY/kB,mDAjHrB,IAAArQ,GAAAvP,EAAA,aAMAsc,EAAAtc,EAAA,eACAo/B,EAAAp/B,EAAA,cAEAy3B,EAAAz3B,EAAA,YACA4mC,EAAA5mC,EAAA,WACAmgB,EAAAngB,EAAA,WACAwd,EAAAxd,EAAA,SAKalB,GAAAsnC,iCAEX,SACA,QAEA,QAAS,OAET,WAAY,OACZ,cAEA,UAAW,eAAgB,gBAW7BtnC,EAAAqnC,QAAAxC,0ICxBA,SAAAqD,GAA4C9pB,GAE1C,MAAOA,GAAM0T,WAAWnS,OAAO,SAASwoB,EAAqC3sB,GAC3E,GAAM4sB,GAAkBpgB,EAAW5J,EAAO5C,EAI1C,OAHI4sB,KACFD,EAAqB3sB,GAAW4sB,GAE3BD,OAiBX,QAAAngB,GAA2B5J,EAAkB5C,GAC3C,IAAK4C,EAAMuC,MAAMnF,GACf,MAAO,KAGT,IAAMmF,GAAQvC,EAAMuC,MAAMnF,GACpB9X,EAAO0a,EAAM1a,KAAK8X,GAElB0b,GACJpyB,KAAMsZ,EAAMwC,UAAUpF,EAAU,IAAI,GACpC9O,KAAMiU,EAAMjU,KACZ4U,OAAQqX,EAAAuN,YAAY9nB,EAAO5C,GAC3B+V,MAAOuW,EAAAO,WAAW1nB,GAUpB,OAPA3gB,GAAAsoC,4CAA4Cv1B,QAAQ,SAAC+N,GACnDoW,EAAepW,GAAYH,EAAMG,KAG/Bpd,GAAoD,gBAA3CuwB,EAAAK,YAAY5wB,GAAQA,EAAK0hB,MAAQ1hB,KAC5CwzB,EAAeqR,SAAU,GAEpBrR,kDA1DT,IAAAjD,GAAA/yB,EAAA,cAMAy3B,EAAAz3B,EAAA,YACA4mC,EAAA5mC,EAAA,UAKAlB,GAAAqnC,QAAAa,EAWaloC,EAAAsoC,6CACX,QAEA,QAAS,OAET,WAAY,cAAe,OAE3B,UAAW,eAAgB,gBAM7BtoC,EAAAgoB,WAAAA,iFC1BA,SAAAqgB,GAA2B1nB,GACzB,GAAIA,EAAMwZ,UACR,OAAQtvB,KAAM8V,EAAMwZ,UACf,IAAIxZ,EAAM6nB,OAAQ,CACvB,GAAMA,GAAS7nB,EAAM6nB,MACrB,IAAIhrB,EAAAirB,iBAAiBD,GAAS,CAC5B,GAAM3nC,IAAoB2nC,OAAQA,EAAO1jC,KAOzC,OANI0jC,GAAOx7B,QACTnM,EAAEmM,MAAQw7B,EAAOx7B,OAEfw7B,EAAO9Y,SACT7uB,EAAE6uB,OAAS8Y,EAAO9Y,QAEb7uB,EAEP,OAAQ2nC,OAAMA,GAGlB,MAAO7nB,GAAM4Q,MAQf,QAAAmX,GACEltB,EAAkB4B,EAAsB1Q,EAAY06B,EAAuB3oB,EAC3ErN,EAAe+K,EAAY+qB,EAAkCC,GAM7D,IAAuB,GAJnBwB,IAA2B,EAIR5gB,EAAA,EAAA6gB,EAAA5oC,EAAA6oC,iBAAA9gB,EAAA6gB,EAAApnC,OAAAumB,IAAgB,CAAlC,GAAMjH,GAAQ8nB,EAAA7gB,EACjB,QAAiC9kB,KAA7BmkC,EAAetmB,GAAyB,CAC1C,GAAM0mB,GAAuBhqB,EAAAiqB,yBAAyBrqB,EAAW0D,GAC3D4mB,EAAyBlqB,EAAAmqB,oCAAoCnsB,EAASsF,EAC5E,IAAK0mB,EAEE,GAAIE,EACTj3B,EAAIgB,KAAKi2B,OAET,QAAQ5mB,GACN,IAAK,QACH,OAAQyQ,MAAO6V,EAAetmB,GAChC,KAAK,SACH,OAAQ0nB,OAAQpB,EAAetmB,GACjC,KAAK,YACH,OAAqB7d,KAAjBikC,EAA4B,CAC9B,GAAM4B,GAAW1B,EAAetmB,EAChC,IAAiB,OAAbgoB,EACF,OAAQ3O,UAAW2O,EAEnBH,IAA2B,MAI7Bl4B,GAAIgB,KAAKhB,EAAI1L,QAAQgkC,iBAAiBvtB,QAnB5C/K,GAAIgB,KAAKhB,EAAI1L,QAAQ6iC,kCAAkCxqB,EAAW0D,EAAUtF,KA0BlF,OAAQA,GAEN,IAAKC,GAAAC,IACH,OAAQ6V,MAAO,SACjB,KAAK9V,GAAAE,OACH,OAAQ4V,MAAO,QACjB,KAAK9V,GAAAY,EACL,IAAKZ,GAAAa,EACH,OAAqBrZ,KAAjBikC,EAA4B,CAC9B,GAAI5G,EAAKpjB,UAAU,QAAS,QAASE,KAAeurB,EAClD,GAAIntB,IAAYC,EAAAY,GAAc,SAATF,GACnB,GAAIsC,EAAOkC,MAAMwhB,eACf,OAAQhI,UAAW1b,EAAOkC,MAAMwhB,oBAGlC,IAAI1jB,EAAOkC,MAAMwZ,UACf,OAAQA,UAAW1b,EAAOkC,MAAMwZ,UAMtC+M,GAAe1rB,IAAYC,EAAAY,EAAIoC,EAAO+X,KAAKvP,MAAQxI,EAAO+X,KAAKtP,OAEjE,OAAQqK,MAAO/V,IAAYC,EAAAY,GAAK,EAAG6qB,IAAiBA,EAAc,GAEpE,KAAKzrB,GAAAG,KAIH,OAAQ2V,OAFSyX,EAAa7sB,EAAM/K,EAAMqN,GACzBwqB,EAAa9sB,EAAMgrB,EAAc1oB,IAEpD,KAAKhD,GAAAM,MACL,IAAKN,GAAAI,MACH,OAAQ0V,MAAO2X,EAAa1tB,EAAS4B,EAAW1Q,EAAMyP,GAGxD,KAAKV,GAAAK,QAEH,OAAQyV,OAAQ9S,EAAOkC,MAAMwoB,WAAY1qB,EAAOkC,MAAMyoB,aAG1D,KAAM,IAAIhoC,OAAM,qCAAqCoa,GAGvD,QAAA0tB,GAAsB1tB,EAA4B4B,EAAsB1Q,EAAYyP,GAClF,OAAQX,GACN,IAAKC,GAAAM,MACH,MAAO,QACT,KAAKN,GAAAI,MACH,MAAkB,YAAduB,EAEc,YAAT1Q,EAAqB,WAAa,UAE3B,SAATyP,EAAkB,UAAY,QAI3C,QAAA6sB,GAAsB7sB,EAAY/K,EAAeqN,GAC/C,GAAIrN,EACF,MAAO,EAET,QAAQ+K,GACN,IAAK,MACH,WAAoClZ,KAA7Bwb,EAAOkC,MAAM0oB,YAA4B5qB,EAAOkC,MAAM0oB,YAAc5qB,EAAO5B,IAAI6gB,kBACxF,KAAK,OACH,MAAOjf,GAAOkC,MAAM0oB,WACtB,KAAK,OACL,IAAK,OACH,MAAO5qB,GAAOkC,MAAM2oB,cACtB,KAAK,OACH,MAAO7qB,GAAOkC,MAAM4oB,WACtB,KAAK,QACL,IAAK,SACL,IAAK,SACH,GAAI9qB,EAAOkC,MAAM6oB,QACf,MAAO/qB,GAAOkC,MAAM6oB,QAK1B,KAAM,IAAIpoC,OAAMqP,EAAI1L,QAAQkyB,oBAAoB,OAAQ9a,IAG1D,QAAA8sB,GAAsB9sB,EAAYgrB,EAAwB1oB,GACxD,GAAMonB,GAAcpnB,EAAOkC,KAE3B,QAAQxE,GACN,IAAK,MACL,IAAK,OACH,WAAiClZ,KAA7Bwb,EAAOkC,MAAM8oB,YACRhrB,EAAOkC,MAAM8oB,YAEfC,EAAevC,EAAc1oB,EAAOkC,OAAS,CACtD,KAAK,OACL,IAAK,OACH,MAAOlC,GAAOkC,MAAMgpB,cACtB,KAAK,OACH,MAAOlrB,GAAOkC,MAAMipB,WACtB,KAAK,QACL,IAAK,SACL,IAAK,SACH,GAAInrB,EAAOkC,MAAMkpB,QACf,MAAOprB,GAAOkC,MAAMkpB,OAItB,IAAMC,GAAYJ,EAAevC,EAActB,EAC/C,QAAQiE,EAAY,IAAMA,EAAY,GAI1C,KAAM,IAAI1oC,OAAMqP,EAAI1L,QAAQkyB,oBAAoB,OAAQ9a,IAM1D,QAAAutB,GAAwBvC,EAAwBtB,GAC9C,MAAIsB,GAAa3lC,OAAS,EACjB4S,KAAK21B,IAAI5iC,MAAM,KAAMggC,GAE1BtB,EAAY1L,UACP0L,EAAY1L,UAEd,mDAzMT,IAAA1pB,GAAAvP,EAAA,aAEAua,EAAAva,EAAA,iBAGAsc,EAAAtc,EAAA,eAEAo/B,EAAAp/B,EAAA,aAKAlB,GAAAqoC,WAAAA,EAqBaroC,EAAA6oC,kBAAqC,QAAS,YAAa,UAKxE7oC,EAAAqnC,QAAAqB,yGC/BA,SAAAV,GAAqB5qB,EAAsB5B,EAAkB+C,GAC3D,MAAI+hB,GAAKpjB,UAAUM,EAAAwU,UAAUmR,KAAM3lB,EAAAwU,UAAUoR,KAAMhmB,GAC1C2H,EAAAilB,aAAazrB,EAASQ,UAExBuhB,EAAKpjB,UAAUzB,EAAAY,EAAGZ,EAAAa,GAAId,GAG/B,QAAAoN,GAAwBpN,EAAkB4B,EAAsByoB,GAC9D,GAAIvF,EAAKpjB,UAAUzB,EAAAY,EAAGZ,EAAAa,GAAId,IACpB4B,IAAcI,EAAAwU,UAAU6I,MAC1B,MAAOgL,GAAYoE,aAMzB,QAAA3P,GAA6B1R,EAAiBpN,EAAmBqqB,GAC/D,OAAgB5iC,KAAZ2lB,EAKJ,MAAI0X,GAAKpjB,UAAUzB,EAAAY,EAAGZ,EAAAa,GAAId,GAKjBqqB,EAAYqE,qBALrB,GAUF,QAAA7P,GAA6BzR,EAAiBpN,EAAkB4B,EAAsBkd,EAAsBuL,GAC1G,OAAgB5iC,KAAZ2lB,EAKJ,MAAI0X,GAAKpjB,UAAUzB,EAAAY,EAAGZ,EAAAa,GAAId,IAGpB4B,IAAcI,EAAAwU,UAAU8K,SACW75B,KAAjC4iC,EAAYsE,iBACPtE,EAAYsE,iBAMd7P,EAAe,MAX1B,GAiBF,QAAA2N,GAAsBzsB,EAAkBqqB,GACtC,GAAIvF,EAAKpjB,UAAU,IAAK,IAAK,MAAO,UAAW1B,GAC7C,MAAOqqB,GAAYoC,MAKvB,QAAA72B,GAAqBg2B,EAAuB5rB,EAAkB+C,GAM5D,MAAgB,SAAZ/C,GAAwC,iBAAlB+C,EAAS7R,QAO9B06B,EAAe9lB,QAAW/C,EAASzI,MAAOwqB,EAAKpjB,UAAUzB,EAAAY,EAAGZ,EAAAa,GAAId,oDAjFvE,IAAAC,GAAAva,EAAA,iBAEAsc,EAAAtc,EAAA,eACA6jB,EAAA7jB,EAAA,kBACAo/B,EAAAp/B,EAAA,aAEAlB,GAAAgoC,KAAAA,EAOAhoC,EAAA4oB,QAAAA,EASA5oB,EAAAs6B,aAAAA,EAgBAt6B,EAAAq6B,aAAAA,EAuBAr6B,EAAAioC,MAAAA,EAOAjoC,EAAAoR,KAAAA,8GCjDA,SAAA1E,GACE09B,EAA0B5uB,EAAkB+C,EAA4BpC,EACxEkuB,EAA0BC,EAA4BzE,GAEtD,GAAM0E,GAAmBC,EAAYhvB,EAAS+C,EAAUpC,EAAMkuB,EAAiBC,EAAoBzE,EAEnG,OAAKpqB,GAAAwB,SAASzB,OAIQvY,KAAlBmnC,EAEG3uB,EAAA0B,iBAAiB3B,EAAS4uB,GAM1BK,EAAuBL,EAAe7rB,GAKpC6rB,GAJL35B,EAAIgB,KAAKhB,EAAI1L,QAAQ2lC,6BAA6BN,EAAeG,IAC1DA,IAPP95B,EAAIgB,KAAKhB,EAAI1L,QAAQ4lC,4BAA4BnvB,EAAS4uB,EAAeG,IAClEA,GAYJA,EAlBE,KAwBX,QAAAC,GAAqBhvB,EAAkB+C,EAA4BpC,EACjEkuB,EAA0BC,EAA4BzE,GAEtD,GAAIvF,EAAKpjB,UAAU,MAAO,UAAW1B,GACnC,MAAO,MAGT,QAAQ+C,EAAS7R,MACf,IAAK,UACH,MAAgB,UAAZ8O,GAA8C,aAAvBC,EAAA6B,UAAU9B,GAC5B,UAEFovB,EAAyBpvB,EAASW,EAAMkuB,EAAiBC,EAAoBzE,EAEtF,KAAK,UACH,MAAgB,UAAZrqB,EACK,UACyB,aAAvBC,EAAA6B,UAAU9B,IACnB/K,EAAIgB,KAAKhB,EAAI1L,QAAQ8lC,4BAA4BrvB,EAAS,YACnD,WAEFovB,EAAyBpvB,EAASW,EAAMkuB,EAAiBC,EAAoBzE,EAEtF,KAAK,WACH,MAAgB,UAAZrqB,EAGK,aACyB,aAAvBC,EAAA6B,UAAU9B,IACnB/K,EAAIgB,KAAKhB,EAAI1L,QAAQ8lC,4BAA4BrvB,EAAS,aAEnD,WAELuJ,EAAA+lB,oBAAoBvsB,EAASQ,UACxB6rB,EAAyBpvB,EAASW,EAAMkuB,EAAiBC,EAAoBzE,GAE/E,MAET,KAAK,eACH,MAAgB,UAAZrqB,EACE+C,EAASzI,IACJ,cAIF,aACyB,aAAvB2F,EAAA6B,UAAU9B,IACnB/K,EAAIgB,KAAKhB,EAAI1L,QAAQ8lC,4BAA4BrvB,EAAS,iBAEnD,WAGL+C,EAASzI,IACJ,aAEF,SAIX,KAAM,IAAI1U,OAAMqP,EAAI1L,QAAQgmC,iBAAiBxsB,EAAS7R,OAOxD,QAAAk+B,GACIpvB,EAAkBW,EAAYkuB,EAC9BC,EAA4BzE,GAE9B,GAAIvF,EAAKpjB,UAAU,IAAK,KAAM1B,GAAU,CACtC,GAAa,SAATW,EAEF,MAAO,MAET,IAAa,QAATA,EAGF,MAAI6uB,GAAcX,EAAiBC,EAAoBzE,GAC9C,QAEF,OAIX,MAAO,QAGT,QAAAmF,GAAuBX,EAA0BC,EAA4BzE,GAC3E,OAAIwE,QAIuBpnC,KAAvBqnC,EAC4B,OAAvBA,IAEAzE,EAAY1L,WAGvB,QAAAsQ,GAAuCL,EAA0B7rB,GAC/D,GAAM7R,GAAa6R,EAAS7R,IAC5B,OAAIqO,GAAAmC,UAAUwB,EAAAusB,KAAK3rB,QAASZ,EAAAusB,KAAK5rB,SAAU3S,OAChBzJ,KAAlBmnC,GAA+Bc,EAAAppB,kBAAkBsoB,GAC/C19B,IAASgS,EAAAusB,KAAKtsB,SAClBJ,EAASQ,SAGLhE,EAAAmC,UAAUM,EAAAwU,UAAUmR,KAAM3lB,EAAAwU,UAAUoR,QAAKngC,IAAYmnC,IAAkBc,EAAAppB,kBAAkBsoB,GAFzFrvB,EAAAmC,UAAUM,EAAAwU,UAAUmR,KAAM3lB,EAAAwU,UAAUoR,QAAKngC,IAAYmnC,GAIrD19B,IAASgS,EAAAusB,KAAKrmB,eACnBrG,EAASzI,IACJs0B,IAAkB5sB,EAAAwU,UAAUmZ,YAAcf,IAAkB5sB,EAAAwU,UAAUoZ,YAExErwB,EAAAmC,UAAUM,EAAAwU,UAAUC,IAAKzU,EAAAwU,UAAUqZ,IAAK7tB,EAAAwU,UAAUsZ,KAAM9tB,EAAAwU,UAAUuZ,SAAU/tB,EAAAwU,UAAUwZ,SAAUhuB,EAAAwU,UAAUyZ,WAAQxoC,IAAYmnC,oDArKzI,IAAA35B,GAAAvP,EAAA,aAEAua,EAAAva,EAAA,iBAEAsc,EAAAtc,EAAA,eACA6jB,EAAA7jB,EAAA,kBAGAgqC,EAAAhqC,EAAA,eACAwd,EAAAxd,EAAA,cACAo/B,EAAAp/B,EAAA,cACA6Z,EAAA7Z,EAAA,aASAlB,GAAAqnC,QAAA36B,EAmIA1M,EAAAyqC,uBAAAA,6ICjBA,SAAAiB,GAA4BC,GAC1B,GAAI7nC,GAAqB,KAAM8nC,EAAY,KACvCvgC,EAAqB,KAAMwgC,EAAa,IAU5C,OATAF,GAAQG,QAAQ/4B,QAAQ,SAAS7J,EAAG/H,GAC9B+H,EAAEirB,WAAa1Y,EAAAY,GACjBvY,EAAKoF,EACL0iC,EAAKzqC,GACI+H,EAAEirB,WAAa1Y,EAAAa,IACxBjR,EAAInC,EACJ2iC,EAAK1qC,MAGD2C,EAACA,EAAE8nC,GAAEA,EAAEvgC,EAACA,EAAEwgC,GAAEA,GAGtB,QAAAE,GAAuB3tB,EAAkButB,EAA6BnwB,GACpE,GAAM1W,GAAQ8zB,EAAAoT,kBAAkBL,EAASnwB,GACrC/I,EAAQ2L,EAAM+K,iBAAiB3N,IAAYC,EAAAY,EAAI,QAAU,UAAUuC,OACnEqtB,EAAWzwB,EAAO,SAClB0wB,EAAStT,EAAAsT,OAASC,KAAK,KAAM/tB,EAAOutB,EAASnwB,EAEjD,QACE1W,KAAMA,EACNzC,SACA+pC,GAAIC,EAAAhF,QAAOpjC,IAAI0nC,MAAgBW,EAAOX,EAAS,SAASS,EAAWG,GAWjE,MAVAH,GAAG/oC,MACDipC,OAAQC,EAAIt+B,QAAQ,GACpBkT,OAAQ+qB,EAAO,IAAID,EAAK,KAAKA,EAAK,OAGpCG,EAAG/oC,MACDipC,OAAQC,EACRprB,OAAQ,IAAIrc,EAAI,QAAUonC,EAAO,SAASD,EAAK,QAAQx5B,EAAI,KAAO,MAG7D25B,KAKb,QAAAE,GAAgBX,EAA6Ba,GAC3C,MAAOb,GAAQW,OAAO3sB,OAAO,SAASysB,EAAWG,GAC/C,MAAKA,GAAIt+B,QAIFu+B,EAAGJ,EAAIG,IAHZE,EAAAh7B,KAAQ86B,EAAG,2DACJH,0EAlLb3wB,EAAAva,EAAA,iBACAurC,EAAAvrC,EAAA,aACA6Z,EAAA7Z,EAAA,cAEA03B,EAAA13B,EAAA,eACAmrC,EAAAnrC,EAAA,sBAEalB,GAAA0sC,MAAQ,SACnB1sC,EAAA4b,KAAO,OAET,IAAM+wB,IACJvL,UAAW,aAEX9a,QAAS,SAASlI,EAAOutB,GACvB,GAAMrlB,MACFsmB,KACA9nC,EAAO6mC,EAAQ7mC,KACf2N,EAAO3N,EAAO9E,EAAA4b,IA2ClB,OAzCI+vB,GAAQkB,YAAeR,EAAAhF,QAAOpjC,IAAI0nC,IACpCW,EAAOX,EAAS,SAASvgC,EAAUmhC,IACjBA,EAAIt+B,QAAQ,GAAGE,SAAWo+B,EAAIt+B,QAAQ,GAAGE,YACjD9K,KAAK,0DACiB0X,EAAAzF,YAAYxQ,EAAO9E,EAAA0sC,OAAM,OAI3Df,EAAQG,QAAQ/4B,QAAQ,SAAS7J,GAC/B,GAAIA,EAAEirB,WAAa1Y,EAAAY,GAAKnT,EAAEirB,WAAa1Y,EAAAa,EAErC,WADAmwB,GAAAh7B,KAAK,8DAIP,IAAMq7B,GAAKf,EAAc3tB,EAAOutB,EAASziC,EAAEirB,SAC3C7N,GAAQjjB,KAAKypC,GACbF,EAAUvpC,KAAK,WAAW0X,EAAAzF,YAAYpM,EAAE8H,OAAM,aAAa87B,EAAGhoC,KAAI,OAGpEwhB,EAAQjjB,MACNyB,KAAM2N,EACNpQ,SACA+pC,GAAIE,EAAOX,EAAS,SAASS,EAAWG,GAYtC,MAXAH,GAAG/oC,MACDipC,OAAQC,EAAIt+B,QAAQ,GACpBkT,OAAQ,kDAGVirB,EAAG/oC,MACDipC,OAAQC,EACRprB,OAAQ,OAAO1O,EAAI,UAAUA,EAAI,4BACRA,EAAI,8BAA8BA,EAAI,SAG1D25B,MAGTtnC,KAAMA,EACNqc,OAAQ,IAAIyrB,EAAU3qC,KAAK,MAAK,MAG3BqkB,GAGTymB,UAAW,SAAS3uB,EAAOutB,GACzB,MAAO,cAAcA,EAAQ7mC,MAG/BkoC,WAAY,SAAS5uB,EAAOutB,GAC1B,GAAMsB,GAAMtB,EAAQ7mC,KAAO8zB,EAAAsU,KAC3B,OAAOD,GAAM,MACU,WAApBtB,EAAQjhC,QAAuB,OAAS,UAAUuiC,EAAG,WAG1D/9B,MAAO,SAASkP,EAAOutB,EAASz8B,GAC9B,GAAMpK,GAAO6mC,EAAQ7mC,KACjB6hB,EAAA+kB,EAAAC,GAACC,EAAAjlB,EAAAilB,GAAIC,EAAAllB,EAAAklB,GACLoB,EAAMnoC,EAAO8zB,EAAAsU,MACbC,EAAQ,QAAQpyB,EAAAzF,YAAYq2B,EAAQ7mC,KAAO8zB,EAAAwU,OAAM,GAGrD,IAAIf,EAAAhF,QAAOpjC,IAAI0nC,GACb,MAAOz8B,EAGT,IAAMiS,IACJrd,EAAGiX,EAAA3I,UAAkB,OAAPw5B,GACXjrB,MAAOvC,EAAMwC,UAAUnF,EAAAY,GAAIuC,OAAW9Z,EAAI,IAAI8mC,EAAE,gBAChDvpC,MAAO,IAEVq8B,GAAI3jB,EAAA3I,UAAkB,OAAPw5B,GACZjrB,MAAOvC,EAAMwC,UAAUnF,EAAAY,GAAIuC,OAAW9Z,EAAI,IAAI8mC,EAAE,gBAChD56B,OAAQxB,MAAO,WAElBnE,EAAG0P,EAAA3I,UAAkB,OAAPy5B,GACXlrB,MAAOvC,EAAMwC,UAAUnF,EAAAa,GAAIsC,OAAW9Z,EAAI,IAAI+mC,EAAE,gBAChDxpC,MAAO,IAEVm8B,GAAIzjB,EAAA3I,UAAkB,OAAPy5B,GACZlrB,MAAOvC,EAAMwC,UAAUnF,EAAAa,GAAIsC,OAAW9Z,EAAI,IAAI+mC,EAAE,gBAChD76B,OAAQxB,MAAO,YAgBpB,OATwB,WAApBm8B,EAAQjhC,SACVqQ,EAAAvX,KAAK2d,GAAQpO,QAAQ,SAAS3Q,GAC5B+e,EAAO/e,IAAO0jB,EAAApe,UACZjB,KAAS0mC,EAAK,cAAcF,EAAG,OAAOA,EAAG,aAAaE,EAAK,YACxDhsB,EAAO/e,KACRC,MAAO,QAKbyC,SAAM7B,GACNyJ,KAAM,OACNwU,QACEmsB,OAAQ5T,MAAOp3B,MAAO,SACtB8e,OAAQA,KAETnV,OAAOkD,GACRpK,KAAMA,EAAO9E,EAAA0sC,MACbhgC,KAAM,OACNwU,QACEmsB,OAAQ5T,MAAOp3B,MAAO,gBACtB8e,OAAQA,MAKInhB,GAAAqnC,QAAAsF,EAEpB3sC,EAAA0rC,YAAAA,2LCtIA,IAAA3wB,GAAA7Z,EAAA,cACA03B,EAAA13B,EAAA,eAEMosC,GACJlM,UAAW,UAEX9a,QAAS,SAASlI,EAAOutB,GACvB,GAAM4B,GAAO5B,EAAQG,QAEjBz7B,EAASk9B,EAAKv/B,IAAI,SAAC9E,GAAM,MAAA6R,GAAAzF,YAAYpM,EAAE8H,SAAQ/O,KAAK,MACpDyf,EAAS6rB,EAAKv/B,IAAI,SAAC9E,GAAM,MAAGskC,4CAASzyB,EAAAzF,YAAYpM,EAAE8H,OAAM,MAAK/O,KAAK,KACvE,SACE6C,KAAM6mC,EAAQ7mC,KACdzC,SACA+pC,KACEE,OAAQX,EAAQW,OAChBnrB,OAAQ,aAAa9Q,EAAM,eAAeqR,EAAM,UAKtDqrB,UAAW,SAAS3uB,EAAOutB,GACzB,GAAM7mC,GAAO6mC,EAAQ7mC,IACrB,OAAO,WAAWA,EAAI,oBAAoBA,EAAI,WAGhDkoC,WAAY,SAAS5uB,EAAOutB,GAC1B,GAAMsB,GAAMtB,EAAQ7mC,KAAO8zB,EAAAsU,KAC3B,OAAOD,GAAM,MACU,WAApBtB,EAAQjhC,QAAuB,OAAS,UAAUuiC,EAAG,WAI3CjtC,GAAAqnC,QAAAiG,uECkBjB,SAAAG,GAAmCrvB,EAAkBsvB,GACnD,GAAMC,MACFC,EAAkBxvB,EAAMK,OAAOqJ,SAEnC,KAAK,GAAM4d,KAAQgI,aAARhI,GACT,IAAKgI,EAAQvpC,eAAeuhC,mBAI5B,IAAMmI,GAASH,EAAQhI,GACnB1K,EAAM4S,EAAgBC,EAAOnhC,KAMjC,KAAK,GAAMtK,KAAO44B,GAGH,cAAR54B,GAAuByrC,EAAOx9B,QAAoB,WAARjO,GAAoByrC,EAAOC,eAItD7qC,KAAhB4qC,EAAOzrC,KAAsC,IAAhByrC,EAAOzrC,KACtCyrC,EAAOzrC,GAAO44B,EAAI54B,IAAQyrC,EAAOzrC,GAIrC,IAAMupC,GAAUgC,EAASjI,GAAQ3qB,EAAA3I,UAAWy7B,GAC1C/oC,KAAM4gC,EACN4G,OAAQvxB,EAAAvK,SAASq9B,EAAOzB,IAAM2B,EAAA9+B,SAAc4+B,EAAOzB,GAAI,SAAWyB,EAAOzB,GACzE9qB,OAAQ,QAGVoM,GAAAsgB,iBAAiBrC,EAAS,SAAAsC,GACpBA,EAAW7pC,OACb6pC,EAAW7pC,MAAMga,EAAOyvB,EAAQlC,MAhC3BjG,EAqCX,OAAOiI,GAGT,QAAAO,GAA6C9vB,EAAkBkI,GAgC7D,MA/BA6nB,GAAiB/vB,EAAO,SAACutB,EAASyC,GAChC,GAAMtpC,GAAO6mC,EAAQ7mC,KACjBioC,EAAYqB,EAAYrB,UAAU3uB,EAAOutB,GACzCqB,EAAaoB,EAAYpB,WAAW5uB,EAAOutB,EAE/CrlB,GAAQjjB,KAAK8D,MAAMmf,EAAS8nB,EAAY9nB,QAAQlI,EAAOutB,IAEvDje,EAAAsgB,iBAAiBrC,EAAS,SAAAsC,GACpBA,EAAW3nB,UACbA,EAAU2nB,EAAW3nB,QAAQlI,EAAOutB,EAASrlB,IAE3C2nB,EAAWjB,aACbA,EAAaiB,EAAWjB,WAAW5uB,EAAOutB,EAASqB,MAIvD1mB,EAAQjjB,MACNyB,KAAMA,EAAO9E,EAAAktC,MACbd,KACEE,QAAS1tB,OAAQ9Z,GACjBqc,OAAQ,wCAAwC4rB,EAAS,QAG3DjoC,KAAMA,EAAO9E,EAAAquC,OACbjC,KACEE,QAAS1tB,OAAQ9Z,GACjBqc,OAAQ,UAAUpG,EAAAzF,YAAYq2B,EAAQ7mC,KAAO9E,EAAAotC,OAAM,KAAKJ,EAAU,UAKjE1mB,EAGT,QAAAgoB,GAAwClwB,EAAkBkI,GAsBxD,MArBgBA,GAAQnY,OAAO,SAACrN,GAAM,MAAW,SAAXA,EAAEgE,OACpB,QAClBwhB,EAAQjjB,MACNyB,KAAM,OACNzC,SACA+pC,KAAME,OAAQ,YAAanrB,OAAQ,mCAIvCgtB,EAAiB/vB,EAAO,SAACutB,EAASyC,GAC5BA,EAAYG,iBACdjoB,EAAQjjB,KAAK8D,MAAMmf,EAAS8nB,EAAYG,gBAAgBnwB,EAAOutB,IAGjEje,EAAAsgB,iBAAiBrC,EAAS,SAAAsC,GACpBA,EAAWM,kBACbjoB,EAAU2nB,EAAWM,gBAAgBnwB,EAAOutB,EAASrlB,QAKpDA,EAGT,QAAAkoB,GAA0CpwB,EAAkBpH,GAQ1D,MAPAm3B,GAAiB/vB,EAAO,SAAAutB,GACL30B,EAAK7I,OAAO,SAAClF,GAAM,MAAAA,GAAEnE,OAAS6mC,EAAQ7mC,KAAO9E,EAAAotC,QAChD5rC,QACZwV,EAAK3T,MAAMyB,KAAM6mC,EAAQ7mC,KAAO9E,EAAAotC,UAI7Bp2B,EAGT,QAAAy3B,GAA2CrwB,EAAkBlP,GAC3D,GAAIw/B,IAAY,EACZC,EAAWz/B,CAcf,OAbAi/B,GAAiB/vB,EAAO,SAACutB,EAASyC,GAChCO,EAAWP,EAAYl/B,MAAQk/B,EAAYl/B,MAAMkP,EAAOutB,EAASgD,GAAYA,EAC7EjhB,EAAAsgB,iBAAiBrC,EAAS,SAACsC,GACzBS,EAAYA,GAAaT,EAAWS,UAChCT,EAAW/+B,QACby/B,EAAWV,EAAW/+B,MAAMkP,EAAOutB,EAASz8B,EAAOy/B,QAQrDvwB,EAAMxb,QAAUwb,EAAMxb,iBAAkBygB,GAAAC,YAClCqrB,EAAUC,GAEXF,EAAYE,EAAUD,GAAYA,EAI7C,QAAAvV,GAA4Chb,EAAmBlP,GAC7D,GAAIw/B,IAAY,CAMhB,OALAtwB,GAAMqJ,SAAS1U,QAAQ,SAAAE,GACrB,GAAM47B,GAAOJ,EAA2Bx7B,EAAO/D,EAC/CA,GAAQ2/B,EAAK,GACbH,EAAYA,GAAaG,EAAK,KAEzBH,EAAYE,EAAU1/B,GAASA,EAYxC,QAAAkyB,GAA0BuK,EAA6B6B,GACrD,GAAML,GAAQpyB,EAAAzF,YAAYq2B,EAAQ7mC,KAAO9E,EAAAotC,OACnCjiC,EAAK2jC,EAAenD,EAAQjhC,QAElC,OADA8iC,GAAQA,GAAS,QACVuB,EAASpD,GAASvK,UAAY,IAAI+L,EAAK,iBAAiBK,EAAK,KAAKriC,EAAE,IAK7E,QAAAgjC,GAA0B/vB,EAAcouB,GACtC,GAAMwC,GAAa5wB,EAAMwJ,UAAUE,SACnC,KAAK,GAAMmnB,KAAQD,GACjB,GAAIA,EAAW7qC,eAAe8qC,GAAO,CACnC,GAAMC,GAAMF,EAAWC,EACvBzC,GAAG0C,EAAKH,EAASG,KAKvB,QAAAH,GAAkBpD,GAChB,OAAQA,EAAQj/B,MACd,IAAK,SACH,MAAOyiC,GAAA9H,OACT,KAAK,QACH,MAAO+H,GAAA/H,OACT,KAAK,WACH,MAAOgI,GAAAhI,QAEX,MAAO,MAGT,QAAA6E,GAAuB9tB,EAAkButB,EAA6BnwB,EAAkBgJ,GACtF,GAAM7D,GAAQ5F,EAAAzF,YAAY8I,EAAMwC,UAAUpF,GAC1C,OAA0B,SAAnBmwB,EAAQrqB,OAAoB,UAAUX,EAAK,KAAK6D,EAAI,IAAMA,EAGnE,QAAAwnB,GAAkCL,EAA6BnwB,GAC7D,MAAOmwB,GAAQ7mC,KAAO,IAAM6mC,EAAQt7B,OAAOmL,GAG7C,QAAAozB,GAAmB1/B,GACjB,MAAOA,GAAMlB,IAAI,SAACnJ,GAAM,MAACA,GAAEyqC,MAAO,EAAMzqC,oDAzP1C,IAAAkpC,GAAA7sC,EAAA,uBAGA6Z,EAAA7Z,EAAA,cAEAmiB,EAAAniB,EAAA,YAGAmuC,EAAAnuC,EAAA,cACAkuC,EAAAluC,EAAA,WAEAiuC,EAAAjuC,EAAA,YACAwsB,EAAAxsB,EAAA,0BAEalB,GAAAotC,MAAQ,SACRptC,EAAAktC,MAAS,SACTltC,EAAAquC,OAAS,UAmCtBruC,EAAAytC,mBAAAA,EA4CAztC,EAAAkuC,6BAAAA,EAmCAluC,EAAAsuC,wBAAAA,EAyBAtuC,EAAAwuC,0BAAAA,EAWAxuC,EAAAyuC,2BAAAA,EAuBAzuC,EAAAo5B,4BAAAA,CAUA,IAAM0V,IACJxuC,OAAU,iBACVivC,YAAe,sBACfC,MAAS,iBACTC,aAAgB,oBAChBC,UAAa,qBACbC,iBAAoB,wBAGtB3vC,GAAAohC,UAAAA,EA+BAphC,EAAAksC,OAAAA,EAKAlsC,EAAAgsC,kBAAAA,qNCpPA,IAAAjxB,GAAA7Z,EAAA,cACAkuC,EAAAluC,EAAA,WACA03B,EAAA13B,EAAA,eAEM0uC,GACJxO,UAAWgO,EAAA/H,QAAMjG,UAEjB9a,QAAS8oB,EAAA/H,QAAM/gB,QAEfioB,gBAAiB,SAASnwB,EAAOutB,GAC/B,QACE7mC,KAAM6mC,EAAQ7mC,KACdqc,OAAQ,QAAQpG,EAAAzF,YAAYq2B,EAAQ7mC,KAAO8zB,EAAAwU,OAAM,UAIrDL,UAAW,SAAS3uB,EAAOutB,GACzB,GAAM7mC,GAAO6mC,EAAQ7mC,KAAM4c,EAAY5c,EAAI,SAC3C,OAAO,WAAWA,EAAI,oBAAoB4c,EAAM,KAC9CiqB,EAAQG,QAAQ99B,IAAI,SAAS9E,EAAG/H,GAC9B,MAAU+H,GAAE8H,MAAK,KAAK0Q,EAAM,IAAIvgB,EAAC,MAChCc,KAAK,OAGZ+qC,WAAY,SAAS5uB,EAAOutB,GAC1B,GAAMsB,GAAMtB,EAAQ7mC,KAAO8zB,EAAAsU,KAC3B,OAAOD,GAAM,MACU,WAApBtB,EAAQjhC,QAAuB,OAAS,UAAUuiC,EAAG,WAI1CjtC,GAAAqnC,QAAAuI,oFCelB,SAAAjnC,GAAY7B,GACV,MAAO,IAAMA,EAAIJ,QAAQ,MAAO,qDA/ClC,IAAAqU,GAAA7Z,EAAA,iBAGM2uC,GACJ5rC,IAAK,SAAS0nC,GACZ,MAAwB,WAAjBA,EAAQj/B,MAAyC,WAApBi/B,EAAQjhC,SAC1CihC,EAAQQ,MAAyB,WAAjBR,EAAQQ,MAG5BoC,gBAAiB,SAASnwB,EAAOutB,EAASrlB,GACxC,GAAMxhB,GAAO6mC,EAAQ7mC,KACjByoC,EAAO5B,EAAQG,QACfK,EAAOR,EAAQQ,IAenB,OAZAoB,GAAKx6B,QAAQ,SAAS7J,GACpBod,EAAQwpB,SACNhrC,KAAMA,EAAO6D,EAAGO,EAAE8H,OAClB3O,MAAO,GACP+pC,KACEE,OAAQX,EAAQW,OAChBnrB,OAAWqsB,4CAASzyB,EAAAzF,YAAYpM,EAAE8H,OAAM,MAE1Cm7B,KAAMA,EAAKjjC,EAAE8H,QAAUm7B,EAAKjjC,EAAEirB,WAAagY,MAIxC7lB,GAGTA,QAAS,SAASlI,EAAOutB,EAASrlB,GAChC,GAAMxhB,GAAO6mC,EAAQ7mC,KAAMyoC,EAAO5B,EAAQG,QACtCltB,EAAS0H,EAAQnY,OAAO,SAACrN,GAAM,MAAAA,GAAEgE,OAASA,IAAM,GAChDuL,EAASk9B,EAAKv/B,IAAI,SAAC9E,GAAM,MAAA6R,GAAAzF,YAAYpM,EAAE8H,SAAQ/O,KAAK,MACpDyf,EAAS6rB,EAAKv/B,IAAI,SAAC9E,GAAM,MAAApE,GAAO6D,EAAGO,EAAE8H,SAAQ/O,KAAK,KAMtD,OAJA2c,GAAOuC,OAAS,aAAa9Q,EAAM,eAAeqR,EAAM,WACjD9C,GAAOvc,YACPuc,GAAOwtB,GAEP9lB,GAIctmB,GAAAqnC,QAAAwI,0GC1CzB,IAEME,IACJ9rC,IAAK,SAAS0nC,GACZ,WAA2B1oC,KAApB0oC,EAAQoE,UAA6C,IAApBpE,EAAQoE,SAGlD7gC,MAAO,SAASkP,EAAOutB,EAASz8B,EAAOy/B,GACrC,GAAMxyB,GAAOjN,EAAM,GACf8gC,EAAQrB,EAASrrC,QAAQ6Y,GACzB8zB,EAAc9zB,EAAKrX,OAASsZ,EAAMmI,QAAQ,aAC1C2pB,EAAS,SAAErrC,GAAW,MAAAA,GAAEC,MAAQD,EAAEC,KAAKxB,QAX/B,YAWmD,GAC3D6sC,GACErrC,KAAMsZ,EAAMmI,QAbN,WAcN7Z,KAAM,OACN+qB,MAAOzgB,KAAMoH,EAAMmI,QAAQ,UAC3BrF,QACEmsB,OACE5T,MAAOp3B,MAAO,eACd64B,aAAc74B,MAAO,KACrBi5B,QAASj5B,MAAO,eAChB+tC,WAAY/tC,OAAO,KAGvBkrB,YACE7gB,KAAM,UACN5I,EAAG,UACHuH,EAAG,UACHoH,MAAO2L,EAAM+K,iBAAiB,SAAU/K,EAAM+K,iBAAiB,aAWvE,OAPI8mB,KAAgB9zB,EAAKjN,MAAMf,OAAO+hC,GAAQ1uC,QAC5C2a,EAAKjN,MAAM7L,KAAK8sC,GAChBxB,EAAS/qC,OAAOosC,EAAO,EAAG7zB,IAChB8zB,GAAgBtB,EAASxgC,OAAO+hC,GAAQ1uC,QAClDmtC,EAAS/qC,OAAOosC,EAAQ,EAAG,EAAGG,GAGzBxB,GAIQ3uC,GAAAqnC,QAAA0I,wFCzCnB,IAAMjE,IACJ7nC,IAAK,SAAS4pC,GACZ,WAAyB5qC,KAAlB4qC,EAAOx9B,YAA6CpN,KAArB4qC,EAAOC,WAG/C1pC,MAAO,SAASga,EAAOyvB,EAAQlC,GAC7B,GAAIt7B,OAEHw9B,EAAOx9B,YAAc0C,QAAQ,SAAChT,GAAM,MAAAsQ,GAAOtQ,GAAK,QAChD8tC,EAAOC,eAAiB/6B,QAAQ,SAAC9N,GAAe,MAAAoL,GAAO+N,EAAMG,SAAStZ,GAAG+L,OAAS/L,GAEnF,IAAMorC,GAAa1E,EAAQG,UAAYH,EAAQG,WAC/C,KAAK,GAAM96B,KAASX,GACdA,EAAOlM,eAAe6M,IACxBq/B,EAAWhtC,MAAM2N,MAAOA,EAAOmjB,SAAU9jB,EAAOW,IAIpDX,GAASs7B,EAAQt7B,SAAWs7B,EAAQt7B,WACpCggC,EAAWliC,OAAO,SAACjF,GAAM,MAAAA,GAAEirB,WAAUphB,QAAQ,SAAC7J,GAAM,MAAAmH,GAAOnH,EAAEirB,UAAYjrB,EAAE8H,SAI5DhR,GAAAqnC,QAAAyE,uCCqCnB,SAAAxqB,GAAuBlD,EAAkB5C,GAEvC,MAAO,UADOT,EAAAzF,YAAY8I,EAAMwC,UAAUpF,IACpB,oDAjExB,IAAAixB,GAAAvrC,EAAA,gBACAsc,EAAAtc,EAAA,kBACA6Z,EAAA7Z,EAAA,iBAEAmuC,EAAAnuC,EAAA,eACA03B,EAAA13B,EAAA,gBAGMovC,GACJ5B,WAAW,EAEXzqC,IAAK,SAAS0nC,GACZ,MAAwB,aAAjBA,EAAQj/B,MAA2C,WAApBi/B,EAAQjhC,SAC5CihC,EAAQQ,MAAyB,WAAjBR,EAAQQ,MAG5B/nC,MAAO,SAASga,EAAOyvB,EAAQlC,GAC7B,GAAM4E,GAAkB5E,EAAQ1jB,SAEhC0jB,GAAQG,QAAQ/4B,QAAQ,SAAS7J,GAC/B,GAAMsS,GAAUtS,EAAEirB,SACZxT,EAAQvC,EAAMijB,aAAa,SAAU7lB,EAE3C,KAAKmF,IAAUnD,EAAAgzB,oBAAoB7vB,EAAMjU,MAEvC,WADA+/B,GAAAh7B,KAAK,kFAIPkP,GAAM8vB,WAAa7xB,OAAQga,EAAAoT,kBAAkBL,EAASnwB,IACtD+0B,EAAMltC,KAAKmY,MAIf+yB,gBAAiB,SAASnwB,EAAOutB,EAASrlB,GACxC,GAAMwL,GAAW6Z,EAAQ1jB,OAAO9Z,OAAO,SAACqN,GACtC,OAAS8K,EAAQnY,OAAO,SAACrN,GAAM,MAAAA,GAAEgE,OAAS8zB,EAAAoT,kBAAkBL,EAASnwB,KAAgB,QAGvF,OAAO8K,GAAQta,OAAO8lB,EAAS9jB,IAAI,SAACwN,GAClC,OAAQ1W,KAAM8zB,EAAAoT,kBAAkBL,EAASnwB,QAI7C8K,QAAS,SAASlI,EAAOutB,EAASrlB,GAChC,GAAMxhB,GAAO6mC,EAAQ7mC,IAarB,OAZAwhB,GAAUA,EAAQnY,OAAO,SAASrN,GAChC,MAAOA,GAAEgE,OAASA,EAAOuqC,EAAAzzB,MACvB9a,EAAEgE,OAASA,EAAO8zB,EAAAsU,OAASpsC,EAAEgE,OAAS8zB,EAAAyV,SAG1C1C,EAAQ1jB,OAAOlV,QAAQ,SAASyI,GAC9B,GAAMoD,GAAS0H,EAAQnY,OAAO,SAACrN,GAAM,MAAAA,GAAEgE,OAAS8zB,EAAAoT,kBAAkBL,EAASnwB,KAAU,EACrFoD,GAAOvb,KAAO,cACPub,GAAOvc,YACPuc,GAAOuC,SAGTmF,GAIctmB,GAAAqnC,QAAAiJ,EAEzBtwC,EAAAshB,OAAAA,mLChEA,IAAAsX,GAAA13B,EAAA,gBAKMwvC,GACJzsC,IAAK,SAAS0nC,GACZ,WAA0B1oC,KAAnB0oC,EAAQ+E,SAA2C,IAAnB/E,EAAQ+E,QAGjDpqB,QAAS,SAASlI,EAAOutB,EAASrlB,GAChC,MAAOA,GAAQta,QACblH,KAAM6mC,EAAQ7mC,KATL,UAUTzC,OAAO,EACP+pC,KAAME,OAAQX,EAAQW,OAAQnrB,OAAQwqB,EAAQ+E,YAIlD1D,WAAY,SAAS5uB,EAAOutB,EAASnnB,GACnC,GAAMyoB,GAAMtB,EAAQ7mC,KAAO8zB,EAAAsU,MACvBtuB,EAAS+sB,EAAQ7mC,KAjBV,SAmBX,OAAU8Z,GAAM,aAAaquB,EAAG,MACT,WAApBtB,EAAQjhC,QACJkU,EAAM,mBACNA,EAAM,oBAAoBquB,EAAG,YAC/BruB,EAAM,MAAMquB,EAAG,WAINjtC,GAAAqnC,QAAAqJ,wDCHlB,SAAA1C,GAAiCrC,EAA6Ba,GAC5D,IAAK,GAAM7rC,KAAKgwC,GACVA,EAAUhwC,GAAGsD,IAAI0nC,IACnBa,EAAGmE,EAAUhwC,oDAbnB,IAAAiwC,GAAA1vC,EAAA,YACA2vC,EAAA3vC,EAAA,aACA4vC,EAAA5vC,EAAA,aACAmrC,EAAAnrC,EAAA,YACA6vC,EAAA7vC,EAAA,YACA8vC,EAAA9vC,EAAA,eACA+vC,EAAA/vC,EAAA,UACMyvC,GAAsC7E,QAAOgF,EAAAzJ,QAAEqJ,OAAMK,EAAA1J,QAAEpf,OAAMokB,EAAAhF,QACjEwF,UAASmE,EAAA3J,QAAE6J,KAAID,EAAA5J,QAAE8J,OAAMP,EAAAvJ,QAAE0I,QAAOc,EAAAxJ,QAElCrnC,GAAAguC,iBAAAA,2ICuCA,SAAAoD,GAAiBzF,EAA6BnwB,GAC5C,GAAI1a,GAAI0a,IAAYC,EAAAY,EAAI,IAAM,GAI9B,OAHIgwB,GAAAhF,QAAepjC,IAAI0nC,KACrB7qC,EAAU,MAANA,EAAY,IAAM,KAEjBA,EAGT,QAAAuwC,GAAiBjzB,EAAkButB,EAA6BnwB,EAAkB/I,EAA0B6T,GAC1G,GAAMxhB,GAAO6mC,EAAQ7mC,KACjB8Z,EAAa0H,EAAQnY,OAAO,SAACrN,GAAU,MAAAA,GAAEgE,OAAS8zB,EAAAoT,kBAAkBL,EAASnwB,KAAU,GACvF81B,EAASxsC,EAAOysC,EAChBC,EAAS1sC,EAAO2sC,EAChB9wB,EAAS5F,EAAAzF,YAAY8I,EAAMwC,UAAUpF,IACrCkU,EAAS,WAAWlU,EACpBk2B,EAAON,EAAQzF,EAASnwB,GACxBuN,EAAY2oB,EAAI,aAAaJ,EAAS5hB,EAAM,QACvC8hB,EAAK,IAAIh2B,EAAO,MAAM81B,EAAM,IAAI7+B,EACrC8e,EAAQ,IAAI+f,EAAS5hB,EAAM,OAAO3G,EAAM,KACnCuoB,EAAS5hB,EAAM,OAAO3G,EAAM,IACjC4oB,EAAK,UAAUhxB,GAAWnF,IAAYC,EAAAY,EAAI,MAAQ,UAAU5J,GAAU,IACtEm/B,EAAK,UAAUjxB,GAAWnF,IAAYC,EAAAY,EAAI,UAAU5J,EAAS,OAAS,GAE1EmM,GAAOwtB,GAAG/oC,MACRipC,QAAS1tB,OAAQ4yB,GACjBrwB,OAAQkrB,EAAAhF,QAAepjC,IAAI0nC,GAAWpa,EAAQ,cAAcA,EAAK,KAAKogB,EAAE,KAAKC,EAAE,sDA3FnF,IAAA7D,GAAA7sC,EAAA,uBACAua,EAAAva,EAAA,oBACA6Z,EAAA7Z,EAAA,iBACAmuC,EAAAnuC,EAAA,eACA03B,EAAA13B,EAAA,gBAEAmrC,EAAAnrC,EAAA,YAGMqwC,EAAS,oBACTE,EAAS,mBAET5E,GACJ5oC,IAAK,SAAS0nC,GACZ,MAAwB,aAAjBA,EAAQj/B,UAA6CzJ,KAAtB0oC,EAAQkB,YAAiD,IAAtBlB,EAAQkB,WAGnFvmB,QAAS,SAASlI,EAAOutB,EAASrlB,GAC1B,GAAAxhB,GAAO6mC,EAAQ7mC,KACjBmjB,EAASokB,EAAAhF,QAAepjC,IAAI0nC,GAC5Bl5B,EAAOwV,EAAS,OAASnjB,EAAOuqC,EAAAzzB,KAChC01B,EAASxsC,EAAOysC,EAChB5qB,EAAA0oB,EAAA3D,YAAAC,GAAC7nC,EAAA6iB,EAAA7iB,EAAGuH,EAAAsb,EAAAtb,EACJihC,EAASyB,EAAA9+B,SAAc08B,EAAQkB,UAAW,QAqC9C,OAnCK5kB,KACHqkB,EAASA,EAAOt+B,IAAI,SAACtN,GAAM,MAACA,GAAEuN,QAAQ,GAAGK,SAAWxJ,EAAOuqC,EAAA3C,MAAgBhsC,KAG7E4lB,EAAQjjB,MACNyB,KAAMwsC,EACNjvC,SACA+pC,KACEE,OAAQA,EAAOt+B,IAAI,SAACtN,GAAM,MAAAA,GAAEuN,QAAQ,KACpCkT,OAAQ,mCACI1O,EAAI,mBAAmBA,EAAI,aAE9B,OAAN3O,EAAa,cAAgBmkB,EAASokB,EAAA/qB,OAAOlD,EAAO3C,EAAAY,GACjD,SAASvX,EAAI,IAAIhB,EAAEkN,MAAK,KAAO,KAAO,KAEnC,OAAN3F,EAAa,cAAgB4c,EAASokB,EAAA/qB,OAAOlD,EAAO3C,EAAAa,GACjD,SAASxX,EAAI,IAAIuG,EAAE2F,MAAK,KAAO,KAAO,IAAM,QAGpDlM,KAAMA,EAAO2sC,EACbpvC,SACA+pC,KACEE,OAAQA,EACRnrB,OAAQ,iBAAiBmwB,EAAM,oBAAoBA,EAAM,UAInD,OAANxtC,GACFutC,EAAQjzB,EAAOutB,EAASlwB,EAAAY,EAAG,QAASiK,GAG5B,OAANjb,GACFgmC,EAAQjzB,EAAOutB,EAASlwB,EAAAa,EAAG,SAAUgK,GAGhCA,GAIUtmB,GAAAqnC,QAAAwF,wJCMrB,SAAAwE,GAAiBjzB,EAAkButB,EAA6BnwB,EAAkB/I,EAA0B6T,GAC1G,GAAMxhB,GAAO6mC,EAAQ7mC,KACjB8Z,EAAa0H,EAAQnY,OAAO,SAACrN,GAAU,MAAAA,GAAEgE,OAAS8zB,EAAAoT,kBAAkBL,EAASnwB,KAAU,GACvFyM,EAASokB,EAAAhF,QAAepjC,IAAI0nC,GAC5BkG,EAAO5pB,EAASokB,EAAA/qB,OAAOlD,EAAO5C,GAAWoD,EAAO9Z,KAChDwsC,EAAS,GAAGxsC,EAAOysC,EAAM,IAAI/1B,EAC7Bg2B,EAAS1sC,EAAO2sC,EAChB9wB,EAAS5F,EAAAzF,YAAY8I,EAAMwC,UAAUpF,IACrC+V,EAAS,IAAI+f,EAAM,OAAOO,EAAI,SAASP,EAAM,OAAOE,EAAK,KACpDF,EAAM,OAAOO,EAAI,SAASP,EAAM,OAAOE,EAAK,IACjDG,EAAK,UAAUhxB,GAAWnF,IAAYC,EAAAY,EAAI,MAAQ,UAAU5J,GAAU,IACtEm/B,EAAK,UAAUjxB,GAAWnF,IAAYC,EAAAY,EAAI,UAAU5J,EAAS,OAAS,GAE1EmM,GAAOwtB,GAAG/oC,MACRipC,QAAS1tB,OAAQ4yB,GACjBrwB,OAAQ8G,EAASsJ,EAAQ,cAAcA,EAAK,KAAKogB,EAAE,KAAKC,EAAE,sDArF9D,IAAA7D,GAAA7sC,EAAA,uBACAua,EAAAva,EAAA,oBACA6Z,EAAA7Z,EAAA,iBACAmuC,EAAAnuC,EAAA,eACA03B,EAAA13B,EAAA,gBAEAmrC,EAAAnrC,EAAA,YAGMqwC,EAAS,eACTE,EAAS,cAETP,GACJjtC,IAAK,SAAS0nC,GACZ,MAAwB,aAAjBA,EAAQj/B,UAAwCzJ,KAAjB0oC,EAAQuF,OAAuC,IAAjBvF,EAAQuF,MAG9E5qB,QAAS,SAASlI,EAAOutB,EAASrlB,GAChC,GAAMxhB,GAAO6mC,EAAQ7mC,KACjB0sC,EAAQ1sC,EAAO2sC,EACf9qB,EAAA0oB,EAAA3D,YAAAC,GAAC7nC,EAAA6iB,EAAA7iB,EAAGuH,EAAAsb,EAAAtb,EACJymC,EAAK/2B,EAAAzF,YAAY8I,EAAMwC,UAAUnF,EAAAY,IACjC01B,EAAKh3B,EAAAzF,YAAY8I,EAAMwC,UAAUnF,EAAAa,IAEjCgwB,EAASyB,EAAA9+B,SAAc08B,EAAQuF,KAAM,QAEpC7E,GAAAhF,QAAepjC,IAAI0nC,KACtBW,EAASA,EAAOt+B,IAAI,SAACtN,GAAM,MAACA,GAAE4N,SAAWxJ,EAAOuqC,EAAA3C,MAAgBhsC,KAGlE4lB,EAAQjjB,MACNyB,KAAMA,EAAOysC,EACbnF,KACEE,OAAQA,EACRnrB,OAAQ,cAAc2wB,EAAE,yBAAyBC,EAAE,kBAGrDjtC,KAAM0sC,EACNpF,KACEE,OAAQA,EACR0F,OAAO,EACP7wB,OAAQ,0DAIF,OAANrd,GACFutC,EAAQjzB,EAAOutB,EAAS,IAAK,QAASrlB,GAG9B,OAANjb,GACFgmC,EAAQjzB,EAAOutB,EAAS,IAAK,SAAUrlB,EAGzC,IAAM7T,GAAO6T,EAAQnY,OAAO,SAACrN;4BAAU,MAAAA,GAAEgE,OAASA,EAAOuqC,EAAAzzB,MACzD,IAAInJ,EAAKjR,OAAQ,CACf,GAAMywC,GAAQx/B,EAAK,GAAG3N,IACtB2N,GAAK,GAAG25B,GAAG/oC,MACTipC,QAAS1tB,OAAQ4yB,GACjBrwB,OAAQ,OAAO8wB,EAAK,UAAUA,EAAK,cACvBA,EAAK,YAAYT,EAAK,cACrBS,EAAK,aAAaT,EAAK,MAIxC,MAAOlrB,IAIKtmB,GAAAqnC,QAAA6J,2NCnEhBz1B,EAAAva,EAAA,cAEA8yB,EAAA9yB,EAAA,eACAgxC,EAAAhxC,EAAA,eACAghB,EAAAhhB,EAAA,eAEAu1B,EAAAv1B,EAAA,WACAsc,EAAAtc,EAAA,YAIA+qB,EAAA/qB,EAAA,YACA6Z,EAAA7Z,EAAA,WAEAmmB,EAAAnmB,EAAA,gBACA2d,EAAA3d,EAAA,YACAkmB,EAAAlmB,EAAA,mBACAixC,EAAAjxC,EAAA,gBACAgiB,EAAAhiB,EAAA,WACAmiB,EAAAniB,EAAA,WACAw3B,EAAAx3B,EAAA,kBACAkxC,EAAAlxC,EAAA,kBACAmxC,EAAAnxC,EAAA,eACAoxC,EAAApxC,EAAA,eACAomB,EAAApmB,EAAA,WACAyiB,EAAAziB,EAAA,YACAqxC,EAAArxC,EAAA,gBACAsxC,EAAAtxC,EAAA,iBACA03B,EAAA13B,EAAA,yBAKAuiB,EAAA,SAAA8D,GA6BE,QAAA9D,GAAYZ,EAAgBjgB,EAAekgB,EAAyBC,EAAyBtE,GAA7F,GAAA+I,GACED,EAAAhmB,KAAAf,KAAMqiB,EAAMjgB,EAAQkgB,EAAiBrE,IAAOje,IAZpCgnB,GAAAS,UAIAT,EAAA3H,QAEA2H,EAAAc,WAESd,EAAAM,aACZN,EAAAC,YAMLD,EAAKirB,qBAKL,IAAMC,OAA+BzvC,KAAf4f,EAAKoE,MAAsBpE,EAAKoE,MACpDrkB,EAASA,EAAc,UAAIK,GACvB0vC,MAAiC1vC,KAAhB4f,EAAKqE,OAAuBrE,EAAKqE,OACtDtkB,EAASA,EAAe,WAAIK,GAExBkZ,EAAOsa,EAAAoH,UAAUhb,EAAK1G,MAAQ0G,EAAK1G,KAAKzP,KAAOmW,EAAK1G,KACpDgY,EAAW3M,EAAK2M,SAAWH,EAAA4e,kBAAkBjvB,EAAAshB,0BAA0BpiB,EAAKsR,aAAgBpR,GAAW5G,EAG7GqL,GAAKmM,MAAQ1H,EAAA0H,MAAMxX,EAAMgY,EAAU3M,EAAK/I,OAAOkV,OAC/CnM,EAAKS,OAAST,EAAKqrB,WAAW12B,EAAMgY,EAAUue,EAAeC,GAE7DnrB,EAAK6M,QAAUge,EAAAzU,YAAY/a,EAAK1G,KAAMgY,EAAU3M,EAAKS,OAAQT,EAAK/I,QAClE+I,EAAK2M,SAAWke,EAAArU,aAAa7hB,EAAMgY,EAAU3M,EAAKmM,MAAOnM,EAAK/I,QAE9D+I,EAAK3H,KAAO2H,EAAKsrB,SAAS3e,GAC1B3M,EAAKc,QAAUd,EAAKurB,WAAW5e,GAG/B3M,EAAKM,UAAYjF,EAAKiF,SAGhB,IAAAnB,GAAAa,EAAAwrB,SAAA72B,EAAAqL,EAAAS,OAAAyqB,EAAAC,GAAC1R,EAAAta,EAAAM,MAAAA,MAAA,KAAAga,EAAAzZ,EAAAP,MAAAga,EAAoBiD,EAAAvd,EAAAO,OAAAA,MAAA,KAAAgd,EAAA1c,EAAAN,OAAAgd,QAI3B1c,GAAKP,MAAQA,EACbO,EAAKN,OAASA,IA6QlB,MA9U+BpB,GAAAre,UAAAgc,EAAA8D,GAoEtB9D,EAAAvf,UAAAyc,MAAP,SAAanF,GACX,MAAOhb,MAAKynB,OAAOzM,IAGdiI,EAAAvf,UAAA4d,kBAAP,SAAyBtG,GACvB,GAAMmF,GAAQngB,KAAKmgB,MAAMnF,EACzB,OAAOmF,IAASnD,EAAAsE,kBAAkBnB,EAAMjU,OAInC+W,EAAAvf,UAAAR,KAAP,SAAY8X,GACV,OAAQhb,KAAKi4B,aAAajd,QAAgB9X,MAGrC+f,EAAAvf,UAAAsa,KAAP,SAAYhD,GACV,MAAOhb,MAAKqf,KAAKrE,IAGZiI,EAAAvf,UAAA4qB,OAAP,SAActT,GACZ,MAAOhb,MAAK8nB,QAAQ9M,IAEdiI,EAAAvf,UAAAuuC,oBAAR,WAIE,IAHA,GAAMh0B,GAASje,KAAKie,OAChBw0B,EAAWzyC,KAAKoC,OAChBswC,GAAmB,EACH,OAAbD,GAAmB,CACxB,GAAIA,YAAoB/vB,GAAAC,WAAY,CAClC+vB,GAAmB,CACnB,OAEFD,EAAWA,EAASrwC,OAGlBswC,IACFz0B,EAAO+X,KAAOzb,EAAA3I,UAAWqM,EAAO+X,KAAM/X,EAAO+M,MAAMgL,QAI/C/S,EAAAvf,UAAA2uC,WAAR,SAAmB12B,EAAYgY,EAA4Bgf,EAAsBC,GAAjF,GAAA5rB,GAAAhnB,KACQ2mC,IAEN,OAAO1rB,GAAAkC,oBAAoBgC,OAAO,SAACsI,EAAQzM,GACzC,GAAI02B,EAAWhe,gBAAgBC,EAAU3Y,IACpCA,IAAYC,EAAAY,GAAK61B,EAAWhe,gBAAgBC,EAAU1Y,EAAAqB,KACtDtB,IAAYC,EAAAa,GAAK41B,EAAWhe,gBAAgBC,EAAU1Y,EAAAsB,IACvD,CACF,GAAM4D,GAAQsH,EAAOzM,GAAW+2B,EAAAlL,QAC9B7rB,EAAS2Y,EAAS3Y,GAAUgM,EAAK/I,OAAQtC,EACzCX,IAAYC,EAAAY,EAAI82B,EAAgB33B,IAAYC,EAAAa,EAAI82B,MAAiBnwC,GACjEkkC,EAGE3rB,KAAYC,EAAAY,GAAKb,IAAYC,EAAAa,GAC3BqE,EAAMwZ,WACRgN,EAAa9jC,KAAKsd,EAAMwZ,WAI9B,MAAOlS,SAOHxE,EAAAvf,UAAA8uC,SAAR,SAAiB72B,EAAYwE,EAAoBsG,EAAeC,GAC9D,GAAMmsB,GAAa7yC,KAAKie,OAAO+X,KACzBqP,EAAcrlC,KAAKie,OAAOkC,KAEhC,QAAc1d,KAAVgkB,EACF,GAAItG,EAAMlF,EAAAY,GACHmB,EAAAsE,kBAAkBnB,EAAMlF,EAAAY,GAAG3P,OAAUiU,EAAMlF,EAAAY,GAAG8d,YACjDlT,EAAQosB,EAAWpsB,WAGrB,IAAI9K,IAASsa,EAAAzZ,KAEXiK,EAAQ4e,EAAY1D,mBACf,CACL,GAAqC,gBAA1B0D,GAAY1L,UACrB,KAAM,IAAI/4B,OAAM,8CAElB6lB,GAAQ4e,EAAY1L,UAK1B,OAAel3B,KAAXikB,EACF,GAAIvG,EAAMlF,EAAAa,GACHkB,EAAAsE,kBAAkBnB,EAAMlF,EAAAa,GAAG5P,OAAUiU,EAAMlF,EAAAa,GAAG6d,YACjDjT,EAASmsB,EAAWnsB,YAEjB,CACL,GAAqC,gBAA1B2e,GAAY1L,UACrB,KAAM,IAAI/4B,OAAM,8CAElB8lB,GAAS2e,EAAY1L,UAIzB,OAAQlT,MAAKA,EAAEC,OAAMA,IAGfzD,EAAAvf,UAAA4uC,SAAR,SAAiB3e,GACf,OAAQ1Y,EAAAY,EAAGZ,EAAAa,GAAGqD,OAAO,SAAS2zB,EAAO93B,GAGnC,GAAMmlB,GAAaxM,EAAS3Y,EAC5B,IAAI0G,EAAAya,WAAWgE,IACVnlB,IAAYC,EAAAY,GAAK6F,EAAAya,WAAWxI,EAASuK,KACrCljB,IAAYC,EAAAa,GAAK4F,EAAAya,WAAWxI,EAASqK,IAAM,CAE9C,GAAM+U,GAAWrxB,EAAAya,WAAWgE,GAAcA,EAAWniB,KAAO,IAG3C,QAAb+0B,IAAkC,IAAbA,IACvBD,EAAM93B,GAAQsK,EAAApe,YACT6rC,IAIT,MAAOD,SAIH7vB,EAAAvf,UAAA6uC,WAAR,SAAmB5e,GACjB,MAAO1Y,GAAAqC,0BAA0B6B,OAAO,SAAS6zB,EAASh4B,GACxD,GAAMmlB,GAAaxM,EAAS3Y,EAC5B,IAAI0G,EAAAya,WAAWgE,GAAa,CAC1B,GAAM8S,GAAa9S,EAAW7R,MACX,QAAf2kB,IAAsC,IAAfA,IACzBD,EAAQh4B,GAAQsK,EAAApe,YAAO+rC,IAG3B,MAAOD,SAIJ/vB,EAAAvf,UAAAyjB,UAAP,WACEnnB,KAAKonB,UAAU5Q,KAAOm7B,EAAAxqB,UAAUnnB,OAG3BijB,EAAAvf,UAAA2jB,eAAP,WACErnB,KAAKonB,UAAUE,UAAY8Q,EAAA6U,mBAAmBjtC,KAAMA,KAAKsnB,YAGpDrE,EAAAvf,UAAA8jB,WAAP,WACExnB,KAAKonB,UAAUK,OAASuqB,EAAAnL,QAAoB7mC,OAGvCijB,EAAAvf,UAAAgkB,UAAP,WACE1nB,KAAKonB,UAAUzL,KAAOm2B,EAAApqB,UAAU1nB,OAG3BijB,EAAAvf,UAAAikB,mBAAP,WACE3nB,KAAKonB,UAAU/H,KAAOwH,EAAA5H,mBAAmBjf,MAAOib,EAAAY,EAAGZ,EAAAa,KAG9CmH,EAAAvf,UAAAmkB,YAAP,WACE7nB,KAAKonB,UAAUU,QAAU8pB,EAAA5W,qBAAqBh7B,OAGzCijB,EAAAvf,UAAAkiB,aAAP,WACG,MAAK5lB,MAAKoC,UAEFwkB,EAAAhB,aAAarL,EAAAsH,KAAK7hB,KAAKonB,UAAU5Q,KAAKuR,WAK1C9E,EAAAvf,UAAAuiB,iCAAP,SAAwCH,GACtC,MAAOsS,GAAA0V,wBAAwB9tC,KAAM8lB,IAGhC7C,EAAAvf,UAAAukB,yBAAP,WACE,MAAOmQ,GAAAsV,6BAA6B1tC,UAG/BijB,EAAAvf,UAAAmiB,sBAAP,SAA6BrP,GAC3B,MAAO4hB,GAAA4V,0BAA0BhuC,KAAMwW,IAGlCyM,EAAAvf,UAAA6iB,eAAP,WACE,MAAO,OAGFtD,EAAAvf,UAAAsiB,sBAAP,WACE,MAAOkS,GAAAuB,0BAA0Bz5B,OAG5BijB,EAAAvf,UAAAglB,cAAP,WACE,GAAIha,GAAQ1O,KAAKonB,UAAUzL,QAS3B,OAJK3b,MAAKoC,QAAYpC,KAAKoC,iBAAkBygB,GAAAC,aAC3CpU,EAAQ0pB,EAAA6V,2BAA2BjuC,KAAM0O,IAGpCA,EAAMlB,IAAIxN,KAAKg4B,mBAGjB/U,EAAAvf,UAAAijB,8BAAP,WACE,MAAOtI,GAAAoF,eAAgBzjB,KAAKie,OAAO+X,KAAMC,EAAAC,mBAAmB1qB,QAAQ,WAG/DyX,EAAAvf,UAAA4tB,SAAP,WACE,MAAOrW,GAAAiC,eAGC+F,EAAAvf,UAAAu0B,WAAV,WACE,MAAOj4B,MAAK2zB,UAGP1Q,EAAAvf,UAAAwvC,OAAP,SAAcC,EAAqBC,GACjC,GACI/wB,GADEsR,EAAWpZ,EAAAiP,UAAUxpB,KAAK2zB,SAiBhC,OAdAtR,IACE1G,KAAM3b,KAAK6zB,QACXF,SAAUA,GAGPwf,IACH9wB,EAAKpE,OAAS1D,EAAAiP,UAAUxpB,KAAKie,SAG1Bm1B,IACH/wB,EAAK7L,KAAO+D,EAAAiP,UAAUxpB,KAAKwW,OAItB6L,GAGFY,EAAAvf,UAAAiY,KAAP,WACE,MAAO3b,MAAK6zB,QAAQ3nB,MAGf+W,EAAAvf,UAAAgwB,gBAAP,SAAuB1Y,GACrB,MAAO02B,GAAWhe,gBAAgB1zB,KAAK2zB,SAAU3Y,IAG5CiI,EAAAvf,UAAAqa,SAAP,SAAgB/C,GAGd,MAAOhb,MAAK2zB,SAAS3Y,QAIhBiI,EAAAvf,UAAA8M,MAAP,SAAawK,EAAkBilB,OAAA,KAAAA,IAAAA,KAC7B,IAAMliB,GAAW/d,KAAK+d,SAAS/C,EAQ/B,OANI+C,GAASzI,MACX2qB,EAAM1lB,EAAA3I,QACJsS,UAAWlH,EAAAsE,kBAAkBthB,KAAKmgB,MAAMnF,GAAS9O,MAAQ,QAAU,SAClE+zB,IAGEve,EAAAlR,MAAMuN,EAAUkiB,IAGlBhd,EAAAvf,UAAA2vC,OAAP,WACE,OAAO,GAEXpwB,GA9U+B6D,EAAAoK,eAAlB1xB,GAAAyjB,UAAAA,4ZClBb,SAAAqwB,GAAiCjxB,EAAiDpE,GACzE,GAMHs1B,GAAsBC,EACtBC,EAAcC,EAPD/f,GAAVtR,EAAA1G,KAAU0G,EAAAsR,UAAoBggB,EAAAruB,EAAAne,OAAAkb,GAAA,OAAA,aAChBuxB,GAAdjgB,EAAArwB,EAAOqwB,EAAA9oB,EAAOya,EAAAne,OAAAwsB,GAAA,IAAA,OACd1hB,EAAA2hC,EAAA3hC,KAAY4hC,EAAAvuB,EAAAne,OAAAysC,GAAA,SACGE,GAAfD,EAAAjZ,MAAetV,EAAAne,OAAA0sC,GAAA,WAChBE,EAA8B9hC,GAAQA,KAAMA,IAASA,MAAOpQ,MAAOoc,EAAO+1B,IAAI/hC,MAKpF,IAAI0hB,EAASrwB,GAAKqwB,EAAS9oB,EAEzB,GAAI6W,EAAAuyB,WAAWtgB,EAASrwB,IAAMoe,EAAA4c,aAAa3K,EAAS9oB,GAElD4oC,EAAe,IACfC,EAAiB,IACjBF,EAA2B7f,EAAS9oB,EAEpC0oC,EAAuB5f,EAASrwB,MAC3B,CAAA,IAAIoe,EAAAuyB,WAAWtgB,EAAS9oB,KAAM6W,EAAA4c,aAAa3K,EAASrwB,GAQzD,KAAM,IAAI1C,OAAM,4DANhB6yC,GAAe,IACfC,EAAiB,IACjBF,EAA2B7f,EAASrwB,EAEpCiwC,EAAuB5f,EAAS9oB,MAI7B,IAAI8oB,EAASrwB,GAAKoe,EAAA4c,aAAa3K,EAASrwB,QAAqBb,KAAfkxB,EAAS9oB,EAE5D6oC,EAAiB,IACjBF,EAA2B7f,EAASrwB,MAC/B,CAAA,OAAmBb,KAAfkxB,EAASrwB,IAAmBqwB,EAAS9oB,IAAK6W,EAAA4c,aAAa3K,EAAS9oB,GAKzE,KAAM,IAAIjK,OAAM,yCAHhB8yC,GAAiB,IACjBF,EAA2B7f,EAAS9oB,EAKtC,OAA2CpI,KAAvC+wC,EAAyBnvB,WAA2BmvB,EAAyBnvB,YAAc7kB,EAAA00C,QAC7F,KAAM,IAAItzC,OAAM,2CAGlB,IAAMuzC,IACF3jC,MAAOgjC,EAAyBhjC,MAChCtE,KAAMsnC,EAAyBtnC,MAG7BkoC,EAAW9uB,EAAApe,UACfmd,UAAW,OACR8vB,GAECE,EAAmB/uB,EAAApe,UACvB8W,KAAMw1B,EAAyBx1B,MAC5Bo2B,GAECE,EAAUhvB,EAAApe,UACdmd,UAAW,MACR8vB,GAECI,EAAcjvB,EAAApe,UAClBmd,UAAW,UACR8vB,GAECK,EAAUlvB,EAAApe,UACdmd,UAAW,MACR8vB,GAECM,EAAWnvB,EAAApe,UACfmd,UAAW,OACR8vB,GAGCO,MAAqDjyC,KAAzB8wC,GAAkCptB,KAAIA,EAACstB,GAAeF,EAAoBptB,KAE5G,OAAMb,GAAApe,YACDysC,GACHtb,QAEI1c,MACEzP,KAAM,OACN8sB,KAAM,cAERrF,SAAQrO,EAAApe,YACHwtC,GAAyBjU,KAAAA,EAC3BiT,GAAiBW,EAAmB5T,EACpCiT,EAAiB,KAAMY,EAAU7T,GAC/BqT,KAGLn4B,MACEzP,KAAM,OACN8sB,KAAM,cAERrF,SAAQrO,EAAApe,YACHwtC,GAAyBhR,KAAAA,EAC3BgQ,GAAiBc,EAAU9Q,EAC3BgQ,EAAiB,KAAMe,EAAW/Q,GAChCoQ,KAGLn4B,MACEzP,KAAM,MACN8sB,KAAM,OAERrF,SAAQrO,EAAApe,YACHwtC,GAAyB/Q,KAAAA,EAC3B+P,GAAiBY,EAAU3Q,EAC3B+P,EAAiB,KAAMc,EAAU7Q,GAC/BkQ,EACAE,KAGLp4B,MACEzP,KAAM,OACN8sB,KAAM,UAERrF,SAAQrO,EAAApe,YACHwtC,GAAyBC,KAAAA,EAC3BjB,GAAiBa,EAAcI,GAC7Bf,EACAG,GACHnZ,OAAU/4B,MAAU,+FAzI9B6f,EAAAhhB,EAAA,gBAIalB,GAAA00C,QAAsB,WASnC10C,EAAA8zC,iBAAAA,iECTA,SAAAsB,GAAkCvyB,GACzB,GAAUsR,IAAVtR,EAAA1G,KAAU0G,EAAAsR,UAAoBggB,EAAAruB,EAAAne,OAAAkb,GAAA,OAAA,aACpBwyB,GAAVlhB,EAAA1hB,KAAUqT,EAAAne,OAAAwsB,GAAA,UACQmhB,GAAlBnhB,EAAAuK,GAASvK,EAAAqK,GAAS1Y,EAAAne,OAAAwsB,GAAA,KAAA,QACJohB,GAAdD,EAAAxxC,EAAOwxC,EAAAjqC,EAAOya,EAAAne,OAAA2tC,GAAA,IAAA,MAErB,KAAKnhB,EAASuK,KAAOvK,EAASqK,GAC5B,KAAM,IAAIp9B,OAAM,4BAGlB,OAAM0kB,GAAApe,YACDysC,GACHtb,QAEI1c,KAAM,OACNgY,SAAUkhB,IAEVl5B,KAAM,OACNgY,SAAUmhB,IAEVn5B,KAAM,OACNgY,SAAUA,EAASuK,GAAE5Y,EAAApe,UACnB5D,EAAGqwB,EAASuK,GACZrzB,EAAG8oB,EAAS9oB,GACTkqC,GAAwBzvB,EAAApe,UAE3B5D,EAAGqwB,EAASrwB,EACZuH,EAAG8oB,EAASqK,IACT+W,wEA/BAv1C,GAAAw1C,SAAwB,YAGrCx1C,EAAAo1C,kBAAAA,8CCOA,SAAAK,GAAoBt5B,EAAcu5B,GAChCC,EAAmBx5B,GAAQu5B,EAG7B,QAAAlrB,GAAuBrO,SACdw5B,GAAmBx5B,GAY5B,QAAAsJ,GAEI5C,EACApE,GAGF,GAAMtC,GAAOsa,EAAAoH,UAAUhb,EAAK1G,MAAQ0G,EAAK1G,KAAKzP,KAAOmW,EAAK1G,KACpDu5B,EAAaC,EAAmBx5B,EACtC,IAAIu5B,EACF,MAAOA,GAAW7yB,EAAMpE,EAG1B,MAAM,IAAIrd,OAAM,+BAA+B+a,mDA1CjD,IAAAsa,GAAAv1B,EAAA,aAEA00C,EAAA10C,EAAA,aACA20C,EAAA30C,EAAA,cAQMy0C,IAEN31C,GAAAy1C,IAAAA,EAIAz1C,EAAAwqB,OAAAA,EAOAirB,EAAIG,EAAAlB,QAASkB,EAAA9B,kBACb2B,EAAII,EAAAL,SAAUK,EAAAT,mBAKdp1C,EAAAylB,UAAAA,oFC8SA,SAAAD,GAA2B/G,GACzB,MAAO1D,GAAA+6B,UAAU/6B,EAAAiP,UAAUhqB,EAAA+1C,eAAgBt3B,mDA5U7C,IAAAkd,GAAAz6B,EAAA,YAEAib,EAAAjb,EAAA,UACAsc,EAAAtc,EAAA,WACA03B,EAAA13B,EAAA,eAGA6Z,EAAA7Z,EAAA,SAmFalB,GAAAg2C,mBACX/uB,MAAO,IACPC,OAAQ,IACRuS,KAAM,eAGKz5B,EAAAi2C,wBACX3a,OAAQ,OACRJ,YAAa,GASFl7B,EAAAk2C,oBACX1f,KAAMx2B,EAAAi2C,wBAmBKj2C,EAAAm2C,sBACXzmC,MAAM,GAkKK1P,EAAA+1C,eACXntB,QAAS,EACThH,aAAc,IACd1C,WAAY,YACZk3B,WAAY,oBAEZ5f,KAAMx2B,EAAAg2C,kBAEN75B,KAAMA,EAAKk6B,kBACX9mC,QACAsN,IAAKV,EAAKm6B,iBACV35B,UACAjN,QACA+M,SACA7M,QACAC,QACA+M,UACArY,KAAM4X,EAAKo6B,kBACX75B,KAAMP,EAAKq6B,kBAEXhC,KAAM/hC,KAAM,IACZgkC,cACAC,UAEAC,QAAS32C,EAAAm2C,qBACTx1B,MAAOnD,EAAAo5B,mBACPp4B,QACAq4B,SACAC,SACAC,YACAC,aACAC,WACAC,cACAC,YACAroB,OAAQ6M,EAAAyb,oBAER5rB,MAAOxrB,EAAAk2C,mBAEPpuB,UAAW8Q,EAAAmd,eAGb/1C,EAAAwlB,WAAAA,0GC5PA,SAAAiP,GAA0Bzd,GACxB,QAASA,EAAU,IAGrB,QAAAud,GAA6Bvd,GAC3B,QAASA,EAAa,OAGxB,QAAAge,GAA4Bhe,GAC1B,QAASA,EAAW,sDATtBhX,EAAAy0B,UAAAA,EAIAz0B,EAAAu0B,aAAAA,EAIAv0B,EAAAg1B,YAAAA,EAMah1B,EAAA0sB,KAAe,OACf1sB,EAAAwzB,IAAa,2CCgB1B,SAAAjR,GAA2BxhB,GACzB,SAASA,IAAQA,EAAEs2C,MAAUt2C,EAAEu2C,SAAav2C,EAAEw2C,OAAWx2C,EAAEy2C,MAAUz2C,EAAE02C,KACnE12C,EAAE22C,OAAW32C,EAAE42C,SAAa52C,EAAE62C,SAAa72C,EAAE82C,eASnD,QAAAC,GAA0B7rC,GACxB,GAAI8O,EAAA1H,SAASpH,GAKX,MAJIA,GAAI,GACNwE,EAAIgB,KAAKhB,EAAI1L,QAAQgzC,gBAAgB,UAAW9rC,IAG1CA,EAAI,EAAK,EAGjB,MAAM,IAAI7K,OAAMqP,EAAI1L,QAAQgzC,gBAAgB,UAAW9rC,IAI3D,QAAA+rC,GAAwBnzC,GACtB,GAAIkW,EAAA1H,SAASxO,GAEX,MAAQA,GAAI,EAAK,EAEjB,IAAMozC,GAASpzC,EAAEqzC,cACXC,EAAan4C,EAAAo4C,OAAO90C,QAAQ20C,EAClC,KAAoB,IAAhBE,EACF,MAAOA,GAAa,EAEtB,IAAME,GAASJ,EAAO7gB,OAAO,EAAG,GAC1BkhB,EAAkBt4C,EAAAu4C,aAAaj1C,QAAQ+0C,EAC7C,KAAyB,IAArBC,EACF,MAAOA,GAAkB,EAG3B,MAAM,IAAIl3C,OAAMqP,EAAI1L,QAAQgzC,gBAAgB,QAASlzC,IAIzD,QAAA2zC,GAAsBvvC,GACpB,GAAI8R,EAAA1H,SAASpK,GAGX,MAAQA,GAAI,EAAK,EAEjB,IAAMwvC,GAASxvC,EAAEivC,cACXQ,EAAW14C,EAAA24C,KAAKr1C,QAAQm1C,EAC9B,KAAkB,IAAdC,EACF,MAAOA,GAAW,EAEpB,IAAME,GAASH,EAAOrhB,OAAO,EAAG,GAC1ByhB,EAAgB74C,EAAA84C,WAAWx1C,QAAQs1C,EACzC,KAAuB,IAAnBC,EACF,MAAOA,GAAgB,EAGzB,MAAM,IAAIz3C,OAAMqP,EAAI1L,QAAQgzC,gBAAgB,MAAO9uC,IAIvD,QAAAwZ,GAA0BxZ,EAAawc,GACrC,GAAM+xB,GAAO,GAAI9iC,MAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAIxC,QAAczR,KAAVgG,EAAEwuC,IACJ,GAAI18B,EAAAvX,KAAKyF,GAAGzH,OAAS,EACnBiP,EAAIgB,KAAKhB,EAAI1L,QAAQg0C,WAAW9vC,IAChCA,EAAI8R,EAAAiP,UAAU/gB,SACPA,GAAEwuC,QACJ,CAELD,EAAKwB,YAAYC,EAEjB,IAAMxB,GAAMhyB,EAAY+yB,EAAavvC,EAAEwuC,KAAOxuC,EAAEwuC,GAChDD,GAAK0B,SAASzB,EAAM,GAQxB,OAJex0C,KAAXgG,EAAEouC,MACJG,EAAKwB,YAAY/vC,EAAEouC,UAGHp0C,KAAdgG,EAAEquC,QAAuB,CAC3B,GAAMA,GAAU7xB,EAAYqyB,EAAiB7uC,EAAEquC,SAAWruC,EAAEquC,OAC5DE,GAAK2B,SAAoB,GAAV7B,GAGjB,OAAgBr0C,KAAZgG,EAAEsuC,MAAqB,CACzB,GAAMA,GAAQ9xB,EAAYuyB,EAAe/uC,EAAEsuC,OAAStuC,EAAEsuC,KACtDC,GAAK2B,UAAU5B,GAuBjB,WApBet0C,KAAXgG,EAAEuuC,MACJA,EAAK0B,QAAQjwC,EAAEuuC,UAGDv0C,KAAZgG,EAAEyuC,OACJF,EAAK4B,SAASnwC,EAAEyuC,WAGAz0C,KAAdgG,EAAE0uC,SACJH,EAAK6B,WAAWpwC,EAAE0uC,aAGF10C,KAAdgG,EAAE2uC,SACJJ,EAAK8B,WAAWrwC,EAAE2uC,aAGG30C,KAAnBgG,EAAE4uC,cACJL,EAAK+B,gBAAgBtwC,EAAE4uC,cAGlBL,EAAKgC,UAQd,QAAAC,GAA6BxwC,EAA4Bwc,OAAA,KAAAA,IAAAA,GAAA,EACvD,IAAMi0B,KAmBN,IAjBIj0B,OAAuBxiB,KAAVgG,EAAEwuC,KACb18B,EAAAvX,KAAKyF,GAAGzH,OAAS,IACnBiP,EAAIgB,KAAKhB,EAAI1L,QAAQg0C,WAAW9vC,IAChCA,EAAI8R,EAAAiP,UAAU/gB,SACPA,GAAEwuC,SAIEx0C,KAAXgG,EAAEouC,KACJqC,EAAMr2C,KAAK4F,EAAEouC,UACMp0C,KAAVgG,EAAEwuC,IAEXiC,EAAMr2C,KAAK41C,GAEXS,EAAMr2C,KAAK,OAGGJ,KAAZgG,EAAEsuC,MAAqB,CACzB,GAAMA,GAAQ9xB,EAAYuyB,EAAe/uC,EAAEsuC,OAAStuC,EAAEsuC,KACtDmC,GAAMr2C,KAAKk0C,OACN,QAAkBt0C,KAAdgG,EAAEquC,QAAuB,CAClC,GAAMA,GAAU7xB,EAAYqyB,EAAiB7uC,EAAEquC,SAAWruC,EAAEquC,OAC5DoC,GAAMr2C,KAAKi0C,EAAU,UAErBoC,GAAMr2C,KAAK,EAGb,QAAeJ,KAAXgG,EAAEuuC,KACJkC,EAAMr2C,KAAK4F,EAAEuuC,UACR,QAAcv0C,KAAVgG,EAAEwuC,IAAmB,CAG9B,GAAMA,GAAMhyB,EAAY+yB,EAAavvC,EAAEwuC,KAAOxuC,EAAEwuC,GAChDiC,GAAMr2C,KAAKo0C,EAAM,UAEjBiC,GAAMr2C,KAAK,EAKb,KAAuB,GAAA0kB,GAAA,EAAApB,GAAC,QAAS,UAAW,UAAW,gBAAhCoB,EAAApB,EAAAnlB,OAAAumB,IAA+C,CAAjE,GAAMhJ,GAAQ4H,EAAAoB,OACG9kB,KAAhBgG,EAAE8V,GACJ26B,EAAMr2C,KAAK4F,EAAE8V,IAEb26B,EAAMr2C,KAAK,GAIf,MAAO,YAAcq2C,EAAMz3C,KAAK,MAAQ,oDA/R1C,IAAAwO,GAAAvP,EAAA,SACA6Z,EAAA7Z,EAAA,UAKM+3C,EAAc,IAwGpBj5C,GAAAuiB,WAAAA,EAKaviB,EAAAo4C,QAAU,UAAW,WAAY,QAAS,QAAS,MAAO,OAAQ,OAAQ,SAAU,YAAa,UAAW,WAAY,YACxHp4C,EAAAu4C,aAAev4C,EAAAo4C,OAAOpqC,IAAI,SAACnJ,GAAM,MAAAA,GAAEuyB,OAAO,EAAG,KAE7Cp3B,EAAA24C,MAAQ,SAAU,SAAU,UAAW,YAAa,WAAY,SAAU,YAC1E34C,EAAA84C,WAAa94C,EAAA24C,KAAK3qC,IAAI,SAAC/E,GAAM,MAAAA,GAAEmuB,OAAO,EAAE,KAwDrDp3B,EAAAyiB,UAAAA,EA6DAziB,EAAAy5C,aAAAA,6DC1IA,SAAAvlB,GAAgCC,EAAoC3Y,GAClE,GAAMmlB,GAAaxM,GAAYA,EAAS3Y,EACxC,SAAImlB,IACE5lB,EAAA7X,QAAQy9B,GACH5lB,EAAAqF,KAAKugB,EAAY,SAACpiB,GAAa,QAAEA,EAASvN,QAE1CkR,EAAAya,WAAWgE,IAMxB,QAAAzW,GAA4BiK,GAC1B,MAAOpZ,GAAAqF,KAAK3E,EAAAgC,SAAU,SAACjC,GACrB,GAAI0Y,EAAgBC,EAAU3Y,GAAU,CACtC,GAAMmlB,GAAaxM,EAAS3Y,EAC5B,OAAIT,GAAA7X,QAAQy9B,GACH5lB,EAAAqF,KAAKugB,EAAY,SAACpiB,GAAa,QAAEA,EAASsG,YAE1C3C,EAAAya,WAAWgE,MAAiBA,EAAW9b,UAGlD,OAAO,IAIX,QAAA+tB,GAAkCze,EAA4BhY,GAC5D,MAAOnY,QAAOR,KAAK2wB,GAAUxU,OAAO,SAACg6B,EAAsCn+B,GACzE,IAAKC,EAAAS,YAAYV,EAASW,GAIxB,MADA1L,GAAIgB,KAAKhB,EAAI1L,QAAQkyB,oBAAoBzb,EAASW,IAC3Cw9B,CAIT,IAAgB,SAAZn+B,GAA+B,SAATW,EAAiB,CACzC,GAAMwkB,GAAaxM,EAAS3Y,EAC5B,IAAI0G,EAAAya,WAAWgE,IAAeA,EAAW9b,UAEvC,MADApU,GAAIgB,KAAKhB,EAAI1L,QAAQkyB,oBAAoBzb,EAASW,EAAM,kCACjDw9B,EAIX,GAAI5+B,EAAA7X,QAAQixB,EAAS3Y,IAEnBm+B,EAAmBn+B,GAAW2Y,EAAS3Y,GAASmE,OAAO,SAACi6B,EAAmCjZ,GAMzF,MALKze,GAAAya,WAAWgE,IAAgBze,EAAAmZ,WAAWsF,GAGzCiZ,EAAYv2C,KAAK6e,EAAAuD,UAAUkb,EAAYnlB,IAFvC/K,EAAIgB,KAAKhB,EAAI1L,QAAQiyB,cAAc2J,EAAYnlB,IAI1Co+B,WAEJ,CACL,GAAMjZ,GAAaxM,EAAS3Y,EAC5B,KAAK0G,EAAAya,WAAWgE,KAAgBze,EAAAmZ,WAAWsF,GAEzC,MADAlwB,GAAIgB,KAAKhB,EAAI1L,QAAQiyB,cAAc2J,EAAYnlB,IACxCm+B,CAETA,GAAmBn+B,GAAW0G,EAAAuD,UAAUkb,EAAYnlB,GAEtD,MAAOm+B,QAKX,QAAAE,GAAyB1lB,GACvB,MAAOA,OAAgBA,EAASrwB,KAAOqwB,EAASuK,MAAUvK,EAAS9oB,KAAO8oB,EAASqK,IAGrF,QAAAsb,GAA0B3lB,GACxB,GAAM4lB,KASN,OARAt+B,GAAAgC,SAAS1K,QAAQ,SAASyI,GACxB,GAAI0Y,EAAgBC,EAAU3Y,GAAU,CACtC,GAAMmlB,GAAaxM,EAAS3Y,IAC3BT,EAAA7X,QAAQy9B,GAAcA,GAAcA,IAAa5tB,QAAQ,SAACwL,GACzDw7B,EAAI12C,KAAKkb,QAIRw7B,EAGT,QAAAhnC,GAAwBsyB,EACpBtlC,EACAsK,GACGg7B,GAILrhC,OAAOR,KAAK6hC,GAAStyB,QAAQ,SAAC9N,GAC5B,GAAMuW,GAAmBvW,CACrB8V,GAAA7X,QAAQmiC,EAAQ7pB,IAClB6pB,EAAQ7pB,GAASzI,QAAQ,SAAS4tB,GAChC5gC,EAAEwB,KAAK8I,EAASs2B,EAAYnlB,KAG9Bzb,EAAEwB,KAAK8I,EAASg7B,EAAQ7pB,GAAUA,KAKxC,QAAAmE,GAA6B0lB,EACzBtlC,EACA8kC,EAASx6B,GACX,MAAKg7B,GAIErhC,OAAOR,KAAK6hC,GAAS1lB,OAAO,SAAC9e,EAAMoE,GACxC,GAAMuW,GAAmBvW,CACzB,OAAI8V,GAAA7X,QAAQmiC,EAAQ7pB,IACX6pB,EAAQ7pB,GAASmE,OAAO,SAASq6B,EAAOrZ,GAC7C,MAAO5gC,GAAEwB,KAAK8I,EAAS2vC,EAAIrZ,EAAYnlB,IACtC3a,GAEId,EAAEwB,KAAK8I,EAASxJ,EAAGwkC,EAAQ7pB,GAAUA,IAE7CqpB,GAZMA,kDA7MX,IAAAppB,GAAAva,EAAA,aAGAghB,EAAAhhB,EAAA,cAcAuP,EAAAvP,EAAA,SAEA6Z,EAAA7Z,EAAA,SA+EAlB,GAAAk0B,gBAAAA,EAYAl0B,EAAAkqB,YAAAA,EAcAlqB,EAAA4yC,kBAAAA,EAyCA5yC,EAAA65C,SAAAA,EAIA75C,EAAA85C,UAAAA,EAaA95C,EAAA+S,QAAAA,EAmBA/S,EAAA2f,OAAAA,mLClKA,SAAAwlB,GAA4Bn0B,GAC1B,MAAOA,KAAU+J,EAAAvK,SAASQ,IAAU,UAAYA,GAiHlD,QAAA2rB,GAA2BgE,GACzB,SAASA,IAAiBA,EAAkB,OAAiC,UAA5BA,EAAsB,WAGzE,QAAAtF,GAA2BsF,GACzB,MAAOA,IAAc,SAAWA,QAAsC19B,KAAxB09B,EAAkB,MAkBlE,QAAA3vB,GAAsBuN,EAA4BkiB,OAAA,KAAAA,IAAAA,KAChD,IAAIzvB,GAAQuN,EAASvN,MACfunB,EAASkI,EAAIlI,OACfmK,EAASjC,EAAIiC,MAEjB,IAAI/Q,EAAQpT,GACVvN,EAAQ,cACH,CACL,GAAId,OAAajN,EAEZw9B,GAAIwZ,OACH17B,EAASzI,KACX5F,EAAK2d,EAAAvS,YAAYiD,EAASzI,KAC1B4sB,EAASjC,EAAI/b,WACJnG,EAASsG,UAClB3U,EAAKzK,OAAOg7B,EAAI5b,WAAatG,EAASsG,WAC7BtG,EAASQ,WAClB7O,EAAKzK,OAAO8Y,EAASQ,YAIrB7O,IACFc,EAAWd,EAAE,IAAIc,GAgBrB,MAZI0xB,KACF1xB,EAAWA,EAAK,IAAI0xB,GAGlBnK,IACFvnB,EAAWunB,EAAM,IAAIvnB,GAGnByvB,EAAIjc,OACNxT,EAAWyvB,EAAIjc,KAAI,KAAKxT,EAAK,MAGxBA,EAGT,QAAAyjC,GAA2Bl2B,GACzB,OAAQA,EAAS7R,MACf,IAAK,UACL,IAAK,UACH,OAAO,CACT,KAAK,eACH,QAAS6R,EAASzI,GACpB,KAAK,WAEH,MAAOiP,GAAA+lB,oBAAoBvsB,EAASQ,UAExC,KAAM,IAAI3d,OAAMqP,EAAI1L,QAAQgmC,iBAAiBxsB,EAAS7R,OAGxD,QAAAoyB,GAA6BvgB,GAC3B,OAAQk2B,EAAWl2B,GAGrB,QAAAoT,GAAwBpT,GACtB,MAA8B,UAAvBA,EAASsG,UAGlB,QAAApD,GAAsBlD,EAA4BE,GAChD,GAAuB,KAAnBF,EAASkD,MAAb,CAIA,OAAuBxe,KAAnBsb,EAASkD,MACX,MAAOlD,GAASkD,KAElB,IAAIkQ,EAAQpT,GACV,MAAOE,GAAO23B,UAEhB,IAAMlmC,GAAKqO,EAASsG,WAAatG,EAASQ,UAAaR,EAASzI,KAAO,KACvE,OAAI5F,GACKA,EAAGgqC,cAAgB,IAAM37B,EAASvN,MAAQ,IAE1CuN,EAASvN,OAIpB,QAAAw5B,GAA4BjsB,EAA2B/C,GACrD,GAAI+C,EAASQ,SACX,MAAO,UAET,IAAIR,EAASzI,IACX,MAAO,cAET,QAAQ2F,EAAA6B,UAAU9B,IAChB,IAAK,aACH,MAAO,cACT,KAAK,WAEL,IAAK,WACH,MAAO,SACT,SACE,MAAO,gBAOb,QAAAiK,GAA0Bkb,EAAgCnlB,GAExD,GAAImhB,EAAWgE,GAAa,CAC1B,GAAIpiB,GAA4BoiB,CAGhC,IAAIpiB,EAASsG,YAAcmH,EAAA/Q,mBAAmBsD,EAASsG,WAAY,CAC1D,GAAWs1B,IAAX57B,EAAAsG,UAAWiB,EAAAne,OAAA4W,GAAA,cAClB9N,GAAIgB,KAAKhB,EAAI1L,QAAQq1C,iBAAiB77B,EAASsG,YAC/CtG,EAAW47B,EAIb,GAAI57B,EAASzI,IAAK,CAChB,GAAMA,GAAMyI,EAASzI,GACjBiF,GAAA5H,UAAU2C,GACZyI,EAAQuH,EAAApe,YACH6W,GACHzI,KAAMukC,QAASxsB,EAAAtS,YAAYC,MAEnB1F,EAAIukC,SAAYvkC,EAAIjL,OAC9B0T,EAAQuH,EAAApe,YACH6W,GACHzI,IAAGgQ,EAAApe,YACEoO,GACHukC,QAASxsB,EAAAtS,YAAYC,QAO7B,GAAI+C,EAAS7R,KAAM,CACjB,GAAM4tC,GAAW57B,EAAA67B,YAAYh8B,EAAS7R,KAClC6R,GAAS7R,OAAS4tC,IAEpB/7B,EAAQuH,EAAApe,YACH6W,GACH7R,KAAM4tC,SAGL,CAEL,GAAME,GAAUhQ,EAAYjsB,EAAU/C,EACtC/K,GAAIgB,KAAKhB,EAAI1L,QAAQ01C,wBAAwBl8B,EAAS7R,KAAM8O,EAASg/B,IACrEj8B,EAAQuH,EAAApe,YACD6W,GACL7R,KAAM8tC,IAIJ,GAAA7zB,GAAA+zB,EAAAn8B,EAAA/C,GAACm/B,EAAAh0B,EAAAg0B,WAAYC,EAAAj0B,EAAAi0B,OAInB,OAHKD,IACHlqC,EAAIgB,KAAKmpC,GAEJr8B,EAET,MAAOoiB,GAIT,QAAA+Z,GAAqCn8B,EAA2B/C,GAC9D,OAAQA,GACN,IAAK,MACL,IAAK,SACH,MAAIsjB,GAAavgB,KAAcA,EAASQ,UAIpC47B,YAAY,EACZC,QAASnqC,EAAI1L,QAAQ81C,6BAA6Br/B,IAG/Cs/B,CAET,KAAK,IACL,IAAK,IACL,IAAK,QACL,IAAK,OACL,IAAK,SACH,MAAOA,EAET,KAAK,UACL,IAAK,OACL,IAAK,KACL,IAAK,KACH,MAAIrG,GAAWl2B,KAAcA,EAASzI,KAElC6kC,YAAY,EACZC,QAAS,WAAWp/B,EAAO,4CAGxBs/B,CAET,KAAK,QACH,MAAsB,YAAlBv8B,EAAS7R,MAETiuC,YAAY,EACZC,QAAS,uDAGNE,CAET,KAAK,QACH,MAAsB,YAAlBv8B,EAAS7R,MAETiuC,YAAY,EACZC,QAAS,kFAGNE,EAEX,KAAM,IAAI15C,OAAM,oDAAsDoa,qEAxYxEwQ,EAAA9qB,EAAA,eAEA2sB,EAAA3sB,EAAA,SACAua,EAAAva,EAAA,aAKAuP,EAAAvP,EAAA,SAIA6jB,EAAA7jB,EAAA,cACAwd,EAAAxd,EAAA,UACA6Z,EAAA7Z,EAAA,SAyBAlB,GAAAmlC,YAAAA,EAkHAnlC,EAAA28B,WAAAA,EAIA38B,EAAAq7B,WAAAA,EAmBAr7B,EAAAgR,MAAAA,EAyCAhR,EAAAy0C,WAAAA,EAcAz0C,EAAA8+B,aAAAA,EAIA9+B,EAAA2xB,QAAAA,EAIA3xB,EAAAyhB,MAAAA,EAmBAzhB,EAAAwqC,YAAAA,EAsBAxqC,EAAAylB,UAAAA,CA4DA,IAAMq1B,IAAcH,YAAY,EAChC36C,GAAA06C,qBAAAA,2IC3TA,SAAAtpB,GAA8BjjB,GAC5B,MAAOA,MAAYA,EAAO6C,WAAwB/N,KAAfkL,EAAOkjB,MA0B5C,QAAAC,GAA8BnjB,GAC5B,SAAIA,GAAUA,EAAO6C,OACf+J,EAAA7X,QAAQiL,EAAOojB,QAAkC,IAAxBpjB,EAAOojB,MAAM/vB,QA4B9C,QAAAgwB,GAA8BrjB,GAC5B,MAAOA,MAAYA,EAAO6C,QACxB+J,EAAA7X,QAAQiL,EAAOsjB,QACf1W,EAAA7X,QAAQiL,EAAO4sC,KAOnB,QAAA9kB,GAA2B9nB,GACzB,GAAI4M,EAAA7X,QAAQiL,GACV,MAAO,IACLA,EAAOH,IAAI,SAACjO,GAAM,MAAAk2B,GAAWl2B,KAC1BoO,OAAO,SAACpO,GAAM,WAAKkD,KAALlD,IACdkC,KAAK,UACR,GACG,IAAI8Y,EAAAvK,SAASrC,GAClB,MAAOA,EAEP,IAAM4nB,GAAY5nB,EAAO4Q,SAItB,QAAUgG,EAAAgR,UAAkB5nB,EAAO4Q,SAAU5Q,EAAO6C,OAAS,IAC9DkR,EAAAlR,MAAM7C,GAASqW,KAAM,SAEvB,IAAI4M,EAAcjjB,GAChB,MAAO4nB,GAAY,MAAQilB,EAAU7sC,EAAOkjB,MAAOljB,EAAO4Q,SACrD,IAAIyS,EAAcrjB,GAAS,CAGhC,MAAO,aADsBA,EAAOsjB,OAAStjB,EAAW,IAEhDH,IAAI,SAAC3H,GAAM,MAAA20C,GAAU30C,EAAG8H,EAAO4Q,YAAW9c,KAAK,KACrD,MAAQ8zB,EAAY,WACjB,GAAIzE,EAAcnjB,GAAS,CAChC,GAAM8sC,GAAQ9sC,EAAOojB,MAAM,GACrB2pB,EAAQ/sC,EAAOojB,MAAM,EAE3B,IAAc,OAAV0pB,GAA6B,OAAVC,EACrB,MAAO,WAAanlB,EAAY,KAC9BilB,EAAUC,EAAO9sC,EAAO4Q,UAAY,KACpCi8B,EAAUE,EAAO/sC,EAAO4Q,UAAY,GACjC,IAAc,OAAVk8B,EACT,MAAOllB,GAAY,OAASklB,CACvB,IAAc,OAAVC,EACT,MAAOnlB,GAAY,OAASmlB,GAOpC,QAAAF,GAAmB30C,EAAQ0Y,GACzB,GAAIuD,EAAAC,WAAWlc,GAAI,CACjB,GAAMme,GAAOlC,EAAAm3B,aAAapzC,GAAG,EAC7B,OAAO,QAAUme,EAAO,IAE1B,GAAIO,EAAAo2B,iBAAiBp8B,GAAW,CAC9B,GAAMq8B,KACNA,GAASr8B,GAAY1Y,CACrB,IAAMme,GAAOlC,EAAAm3B,aAAa2B,GAAU,EACpC,OAAO,QAAU52B,EAAO,IAE1B,MAAO7iB,MAAKgB,UAAU0D,mDArJxB,IAAAic,GAAAphB,EAAA,cACAghB,EAAAhhB,EAAA,cACA6jB,EAAA7jB,EAAA,cACA6Z,EAAA7Z,EAAA,SAyBAlB,GAAAoxB,cAAAA,EA2BApxB,EAAAsxB,cAAAA,EA8BAtxB,EAAAwxB,cAAAA,EAUAxxB,EAAAi2B,WAAAA,oJC/Baj2B,EAAAo3C,qBACX73B,WAAQtc,IAGGjD,EAAA47B,mBAAsC,eAAgB,SAAU,SAAU,SAAU,YAAa,QAAS,OAAQ,SAAU,+CCfzI,SAAAyf,GAA+Bt7C,GAE7BA,EADoBu7C,EAAU,GAAIC,IAElC31B,IAGF,QAAA41B,GAAqBz7C,GACnB,MAAO,YACL,GAAMyR,GAAS8pC,EAAU,GAAIC,EAC7Bx7C,GAAEyR,GACFoU,KAOJ,QAAAjT,GAAoBnB,GAElB,MADA8pC,GAAU9pC,EAOZ,QAAAoU,KAEE,MADA01B,GAAU1lC,EAIZ,QAAAnE,SAAqB,GAAArG,MAAA2c,EAAA,EAAAA,EAAAxe,UAAA/H,OAAAumB,IAAA3c,EAAA2c,GAAAxe,UAAAwe,EACnBuzB,GAAQ7pC,KAAKtK,MAAMm0C,EAAS/xC,WAG9B,QAAAmI,SAAqB,GAAAtG,MAAA2c,EAAA,EAAAA,EAAAxe,UAAA/H,OAAAumB,IAAA3c,EAAA2c,GAAAxe,UAAAwe,EACnBuzB,GAAQ5pC,KAAKvK,MAAMm0C,EAAS/xC,WAG9B,QAAAoI,SAAsB,GAAAvG,MAAA2c,EAAA,EAAAA,EAAAxe,UAAA/H,OAAAumB,IAAA3c,EAAA2c,GAAAxe,UAAAwe,EACpBuzB,GAAQ3pC,MAAMxK,MAAMm0C,EAAS/xC,2DAtF/B,IAAA+rB,GAAAp0B,EAAA,aAgBM0U,EAAO0f,EAAA9jB,OAAO8jB,EAAAngB,MAChBmmC,EAA2B1lC,EAK/B2lC,EAAA,WAAA,QAAAA,KACS/6C,KAAAi7C,SACAj7C,KAAAk7C,SACAl7C,KAAAm7C,UAoBT,MAlBSJ,GAAAr3C,UAAArB,MAAP,WACE,MAAOrC,OAGF+6C,EAAAr3C,UAAAuN,KAAP,eAAY,GAAAb,MAAAmX,EAAA,EAAAA,EAAAxe,UAAA/H,OAAAumB,IAAAnX,EAAAmX,GAAAxe,UAAAwe,EAEV,QADApB,EAAAnmB,KAAKi7C,OAAMp4C,KAAI8D,MAAAwf,EAAI/V,GACZpQ,YAGF+6C,EAAAr3C,UAAAwN,KAAP,eAAY,GAAAd,MAAAmX,EAAA,EAAAA,EAAAxe,UAAA/H,OAAAumB,IAAAnX,EAAAmX,GAAAxe,UAAAwe,EAEV,QADApB,EAAAnmB,KAAKk7C,OAAMr4C,KAAI8D,MAAAwf,EAAI/V,GACZpQ,YAGF+6C,EAAAr3C,UAAAyN,MAAP,eAAa,GAAAf,MAAAmX,EAAA,EAAAA,EAAAxe,UAAA/H,OAAAumB,IAAAnX,EAAAmX,GAAAxe,UAAAwe,EAEX,QADApB,EAAAnmB,KAAKm7C,QAAOt4C,KAAI8D,MAAAwf,EAAI/V,GACbpQ,YAEX+6C,IAvBav7C,GAAAu7C,YAAAA,EAyBbv7C,EAAAq7C,eAAAA,EAMAr7C,EAAAw7C,KAAAA,EAWAx7C,EAAA2S,IAAAA,EAQA3S,EAAA4lB,MAAAA,EAKA5lB,EAAAyR,KAAAA,EAIAzR,EAAA0R,KAAAA,EAIA1R,EAAA2R,MAAAA,GAOA,SAAiB5M,GAIf,QAAAqgC,GAAoCp0B,GAClC,MAAO,2BAA2BA,EAAK,KAIzC,QAAA0f,GAAkCxnB,GAChC,MAAO,sBAAsBA,EAAC,IAIhC,QAAA8sB,GAAwCzI,GACtC,MAAO,kCAAkC5rB,KAAKgB,UAAU4qB,GAAU,IAIpE,QAAAwd,GAAiCr+B,GAC/B,MAAO,uBAAuBA,EAAI,IAEpC,QAAA0tC,GAAiCv1B,GAC/B,MAAO,iCAAiCA,EAAS,IAGnD,QAAA41B,GAAwC/tC,EAAqB8O,EAAkBg/B,GAC7E,MAAO,uBAAuB9tC,EAAI,iBAAiB8O,EAAO,WAAWg/B,EAAO,YAG9E,QAAAxjB,GAA8BzY,EAA4B/C,GACxD,MAAO,YAAY7Z,KAAKgB,UAAU4b,GAAS,iBAAiB/C,EAAO,kDAGrE,QAAAyb,GAAoCzb,EAAkBogC,EAA6BC,GACjF,MAAUrgC,GAAO,uCAAuCogC,GAAcC,EAAO,SAASA,EAAS,IAAE,IAGnG,QAAAhB,GAA6Cr/B,GAC3C,MAAUA,GAAO,6DAGnB,QAAAqvB,GAA4CrvB,EAAkB9O,GAC5D,MAAO,0BAA0B8O,EAAO,cAAc9O,EAAI,mDAA2D,YAATA,EAAqB,QAAU,aAAW,IAMxJ,QAAAwyB,GAAwC/iB,GACtC,MAAO,4CAA4CA,EAAI,gGAGzD,QAAAgjB,GAA6ChjB,GAC3C,MAAO,4CAA4CA,EAAI,+DAGzD,QAAA4hB,GAAiC+d,EAAkBC,GACjD,MAAO,oBAAoBD,EAAQ,oBAAoBC,EAMzD,QAAAC,GAAmD33B,GACjD,MAAO,cAAcA,EAAI,2BAG3B,QAAAkiB,GAAwDhoB,GACtD,MAAO,2DAA2D5c,KAAKgB,UAAU4b,GAAS,KAG5F,QAAA+nB,GAAuDzhB,GACrD,MAAO,0CAA0CA,EAAS,0EAG5D,QAAAwhB,GAA+C9nB,GAC7C,MAAO,+DAA+D5c,KAAKgB,UAAU4b,GAAS,KAQhG,QAAA09B,GAAgDC,GAC9C,MAAO,qBAAqBA,EAAQ,6EAGtC,QAAAnT,GAAiCvtB,GAC/B,MAAO,iBAAiBA,EAAO,6BACjB,MAAZA,EAAkB,QAAU,UAAQ,gBAGxC,QAAAmvB,GAA4CnvB,EAAkB4B,EAAsBmtB,GAClF,MAAO,WAAW/uB,EAAO,uBAAuB4B,EAAS,wBAAwBmtB,EAAgB,kBAGnG,QAAAG,GAA6CttB,EAAsBmtB,GACjE,MAAO,+BAA+BntB,EAAS,wBAAwBmtB,EAAgB,kBAGzF,QAAA3C,GAAkDxqB,EAAsB8+B,EAAkB1gC,GACxF,MAAUA,GAAO,cAAa0gC,EAAQ,yCAAyC9+B,EAAS,UAG1F,QAAA2kB,GAAyC5lB,EAAYiB,GACnD,MAAO,eAAeA,EAAS,6BAA6BjB,EAAI,IAWlE,QAAAggC,GAAsC3gC,GACpC,MAAO,gBAAgBA,EAAO,wBAAwBA,EAAO,IAG/D,QAAA4gC,GAA0Ch/B,GACxC,MAAO,kCAAkCA,EAAS,IAGpD,QAAAi/B,GAAiDx3B,GAC/C,MAAO,8DAA8DA,EAAS,IAIhF,QAAAkzB,GAAgCuE,EAAkBj6C,GAChD,MAAO,WAAWi6C,EAAQ,KAAKj6C,EAGjC,QAAAk6C,GAAoCC,GAClC,MAAO,cAAcA,EAAY,gDAC/BA,EAAa91C,QAAQ,MAAO,QAAO,IAGvC,QAAAqyC,GAA2B9vC,GACzB,MAAO,8BAA8BtH,KAAKgB,UAAUsG,GAAE,+CA5I3ClE,EAAAif,aAAe,eAGZjf,EAAAqgC,oBAAmBA,EAKnBrgC,EAAA2rB,kBAAiBA,EAKjB3rB,EAAAixB,wBAAuBA,EAKvBjxB,EAAAgmC,iBAAgBA,EAGhBhmC,EAAAq1C,iBAAgBA,EAIhBr1C,EAAA01C,wBAAuBA,EAIvB11C,EAAAiyB,cAAaA,EAIbjyB,EAAAkyB,oBAAmBA,EAInBlyB,EAAA81C,6BAA4BA,EAI5B91C,EAAA8lC,4BAA2BA,EAK9B9lC,EAAA44B,wCAA0C,sGAEvC54B,EAAAm6B,wBAAuBA,EAIvBn6B,EAAAo6B,6BAA4BA,EAI5Bp6B,EAAAg5B,iBAAgBA,EAKnBh5B,EAAA03C,6CAA+C,wEAE5C13C,EAAAi3C,mCAAkCA,EAIlCj3C,EAAAwhC,wCAAuCA,EAIvCxhC,EAAAuhC,uCAAsCA,EAItCvhC,EAAAshC,+BAA8BA,EAIjCthC,EAAA23C,+BACX,+GAEW33C,EAAA43C,8BAAgC,sEAE7B53C,EAAAk3C,gCAA+BA,EAI/Bl3C,EAAAgkC,iBAAgBA,EAKhBhkC,EAAA4lC,4BAA2BA,EAI3B5lC,EAAA2lC,6BAA4BA,EAI5B3lC,EAAA6iC,kCAAiCA,EAIjC7iC,EAAAg9B,yBAAwBA,EAI3Bh9B,EAAA0hC,cAAgB,uBAEhB1hC,EAAA6hC,wBAA0B,0BAG1B7hC,EAAAid,yBAA2B,4BAGxBjd,EAAAo3C,sBAAqBA,EAIrBp3C,EAAAq3C,0BAAyBA,EAIzBr3C,EAAAs3C,iCAAgCA,EAKhCt3C,EAAAgzC,gBAAeA,EAIfhzC,EAAAw3C,oBAAmBA,EAKnBx3C,EAAAg0C,WAAUA,GA5IX/4C,EAAA+E,UAAA/E,EAAA+E,+DCAjB,SAAA84B,GAA0B1hB,GACxB,MAAOA,GAAW,KAKpB,QAAAygC,GAAgCzgC,GAE9B,OADiB0hB,EAAU1hB,GAAQA,EAAKzP,KAAOyP,IAC5B0gC,mDA1GrB,IAIiBC,GAJjB/hC,EAAA7Z,EAAA,WAIA,SAAiB47C,GACFA,EAAA/hB,KAAe,OACf+hB,EAAAriB,IAAa,MACbqiB,EAAAhiB,KAAe,OACfgiB,EAAAjiB,MAAiB,QACjBiiB,EAAAxe,KAAe,OACfwe,EAAAze,KAAe,OACfye,EAAA9/B,KAAe,OACf8/B,EAAApiB,KAAe,OACfoiB,EAAAniB,OAAmB,SACnBmiB,EAAAliB,OAAmB,UAVjBkiB,EAAA98C,EAAA88C,OAAA98C,EAAA88C,UAmBJ98C,EAAA+6B,KAAO+hB,EAAK/hB,KACZ/6B,EAAAy6B,IAAMqiB,EAAKriB,IACXz6B,EAAA86B,KAAOgiB,EAAKhiB,KACZ96B,EAAA66B,MAAQiiB,EAAKjiB,MACb76B,EAAAgd,KAAO8/B,EAAK9/B,KACZhd,EAAA06B,KAAOoiB,EAAKpiB,KACZ16B,EAAAs+B,KAAOwe,EAAKxe,KACZt+B,EAAAq+B,KAAOye,EAAKze,KAEZr+B,EAAA26B,OAASmiB,EAAKniB,OACd36B,EAAA46B,OAASkiB,EAAKliB,OAEd56B,EAAA+8C,iBAAmB/8C,EAAA+6B,KAAM/6B,EAAAy6B,IAAKz6B,EAAA86B,KAAM96B,EAAA66B,MAAO76B,EAAAgd,KAAMhd,EAAA06B,KAAM16B,EAAAs+B,KAAMt+B,EAAAq+B,KAAMr+B,EAAA26B,OAAQ36B,EAAA46B,QA+DxF56B,EAAA69B,UAAAA,CAIA,IAAMgf,GAAuB9hC,EAAAnG,MAAM5U,EAAA+8C,gBAEnC/8C,GAAA48C,gBAAAA,EAKa58C,EAAAg9C,eAAiB,SAAU,cACtC,aAAc,mBAAoB,iBAEvBh9C,EAAAi9C,aAAe,OAAQ,eAEvBj9C,EAAA02B,sBAAwB1qB,OAAOhM,EAAAg9C,cAAeh9C,EAAAi9C,aAwB9Cj9C,EAAAq2C,mBACXjb,MAAO,WA6BIp7B,EAAAs2C,kBACXzZ,WAAY,EACZa,mBAAoB,GAUT19B,EAAAu2C,mBACX/2B,SAAU,UAqBCxf,EAAAw2C,mBACX/T,UAAW,mDC/Ib,SAAA3gB,GAAkCpV,GAChC,MAAOA,KAAQwwC,GAGjB,QAAAphB,GAA2BpvB,GACzB,MAAOA,KAAQywC,GAGjB,QAAA3M,GAAoC9jC,GAGlC,MAAOA,KAAQ0wC,GAGjB,QAAAC,GAAyC3wC,GACvC,MAAOA,KAAQ4wC,GAsNjB,QAAA7U,GAAiCD,GAC/B,MAAOA,MAAYA,EAAa,KA0HlC,QAAAf,GAAyCrqB,EAAsB8+B,GAC7D,OAAQA,GACN,IAAK,OACL,IAAK,SACL,IAAK,QACL,IAAK,SACH,OAAO,CACT,KAAK,cACH,MAAOnhC,GAAAmC,UAAU,SAAU,aAAc,MAAO,MAAO,OAAQ,MAAO,QAASE,EACjF,KAAK,QACH,MAAOigC,GAAyBjgC,IAA4B,SAAdA,GAAsC,UAAdA,CACxE,KAAK,YACL,IAAK,UACL,IAAK,eACH,MAAOrC,GAAAmC,UAAU,QAAS,QAASE,EACrC,KAAK,eACH,MAAqB,SAAdA,CACT,KAAK,QACH,MAAOigC,GAAyBjgC,IAA4B,eAAdA,CAChD,KAAK,OACH,MAAOigC,GAAyBjgC,IAA4B,eAAdA,GAAmD,aAArBA,CAC9E,KAAK,WACH,MAAqB,QAAdA,GAAqC,QAAdA,CAChC,KAAK,OAEH,MAAqB,gBAAdA,IAAiC0E,EAAkB1E,KAAerC,EAAAmC,UAAU,MAAO,OAAQ,MAAO,cAAeE,GAG5H,KAAM,IAAIhc,OAAM,0BAA0B86C,EAAQ,KAMpD,QAAAvU,GAAoDnsB,EAAkB0gC,GACpE,OAAQA,GACN,IAAK,QAEH,GAAgB,MAAZ1gC,GAA+B,MAAZA,EACrB,MAAO/K,GAAI1L,QAAQ23C,8BAErB,IAAgB,QAAZlhC,GAAiC,WAAZA,EACvB,MAAO/K,GAAI1L,QAAQk3C,gCAAgC,QAErD,OAEF,KAAK,YACH,GAAgB,QAAZzgC,GAAiC,WAAZA,EACvB,MAAO/K,GAAI1L,QAAQk3C,gCAAgC,YAErD,OACF,KAAK,UACL,IAAK,eACL,IAAK,eACH,GAAgB,QAAZzgC,GAAiC,WAAZA,EAMvB,MAAO/K,GAAI1L,QAAQ43C,6BAErB,OACF,KAAK,cACL,IAAK,SACH,GAAgB,UAAZnhC,EACF,MAAO/K,GAAI1L,QAAQi3C,mCAAmCxgC,EAExD,OACF,KAAK,OACL,IAAK,SACL,IAAK,QACL,IAAK,QACL,IAAK,WACL,IAAK,OACL,IAAK,OAEH,OAGJ,KAAM,IAAIpa,OAAM,yFA1elB,IAAAqP,GAAAvP,EAAA,SACA6Z,EAAA7Z,EAAA,WAEA,SAAiB8wB,GAEFA,EAAAyZ,OAAmB,SACnBzZ,EAAAmZ,WAA2B,aAC3BnZ,EAAAC,IAAa,MACbD,EAAAqZ,IAAa,MACbrZ,EAAAsZ,KAAe,OAEftZ,EAAAmR,KAAe,OACfnR,EAAAoR,IAAc,MAEdpR,EAAAurB,WAA2B,aAG3BvrB,EAAAuZ,SAAuB,WACvBvZ,EAAAwZ,SAAuB,WACvBxZ,EAAAwrB,UAAyB,YAEzBxrB,EAAA1S,QAAqB,UACrB0S,EAAAoZ,YAA6B,cAC7BpZ,EAAA6I,MAAiB,QACjB7I,EAAA8K,KAAe,QArBb98B,EAAAgyB,YAAAhyB,EAAAgyB,eA+BJhyB,EAAAke,aAEX,SAAU,aAAc,MAAO,MAAO,OAEtC,OAAQ,MAER,aAEA,UAAW,cAAe,QAAS,QAGxBle,EAAAy9C,iCAAgD,SAAU,aAAc,MAAO,MAAO,OAAQ,OAAQ,MACnH,IAAMH,GAAiCviC,EAAAnG,MAAM5U,EAAAy9C,gCAEhCz9C,GAAA09C,yBAAwC19C,EAAAy9C,gCAAgCzxC,QAAQ,cAC7F,IAAMoxC,GAA0BriC,EAAAnG,MAAM5U,EAAA09C,yBAEzB19C,GAAA29C,wBAAuC,UAAW,cAAe,QAAS,OACvF,IAAMT,GAAwBniC,EAAAnG,MAAM5U,EAAA29C,wBAE9BR,EAAmBpiC,EAAAnG,OAAO,aAAc,eAEjC5U,GAAA49C,kBAAiC,OAAQ,OAEtD59C,EAAA8hB,kBAAAA,EAIA9hB,EAAA87B,WAAAA,EAIA97B,EAAAwwC,oBAAAA,EAMAxwC,EAAAq9C,yBAAAA,EA8Kar9C,EAAA42C,oBACX3O,OAAO,EACP9F,eAAgB,GAChBhI,UAAW,GACX8P,aAAc,GACdC,iBAAkB,GAClB2T,aAAc,GAEdtU,YAAa,EACbK,YAAa,GAEbT,WAAY,GACZC,WAAY,GAGZI,QAAS,EAETF,eAAgB,EAChBK,eAAgB,EAEhBmU,QAAS,SAAU,SAAU,QAAS,UAAW,cAAe,kBAqBlE99C,EAAAyoC,iBAAAA,EAsHazoC,EAAA+9C,kBACX,OAAQ,SAAU,QAAS,QAAS,YAAa,SAAU,UAAW,eAAgB,eAAgB,QAAS,OAC/G,WAAY,OAAQ,eAGtB/9C,EAAAynC,yBAAAA,EAkCAznC,EAAA2nC,oCAAAA,+GC7Za3nC,EAAA+1C,eACXnG,QAASxD,GAAI,QAAS/7B,QAAS,OAAQ3F,QAAS,UAChD4iC,OAAQlB,GAAI,QAAS/7B,QAAS,OAAQqgC,OAAQ,iBAAkBhmC,QAAS,UACzEiiC,UACEP,GAAI,kDACJ0B,WAAY,IAAK,KACjBjB,UAAW,kDACXqE,KAAM,QACNxmC,QAAS,gDCxBb,SAAA4pB,GAA4B5wB,GAC1B,QAASA,KAAUA,EAAY,SAAOA,EAAS,oDADjD1D,EAAAs0B,YAAAA,uCC+HA,SAAArR,GAA4BJ,GAC1B,WAAyB5f,KAAlB4f,EAAY,MAGrB,QAAAU,GAA2BV,GACzB,QAASA,EAAW,KAGtB,QAAAO,GAA4BP,GAC1B,WAAyB5f,KAAlB4f,EAAY,MAGrB,QAAAa,GAA6Bb,GAC3B,WAA0B5f,KAAnB4f,EAAa,OAGtB,QAAAgB,GAA6BhB,GAC3B,WAA2B5f,KAApB4f,EAAc,QAOvB,QAAA4C,GAA0B5C,EAA4BpE,GACpD,GAAIwE,EAAYJ,GACd,MAAOm7B,GAAen7B,EAAMpE,EAE9B,IAAI2E,EAAYP,GACd,MAAOo7B,GAAep7B,EAAMpE,EAE9B,IAAIiF,EAAab,GACf,MAAOq7B,GAAgBr7B,EAAMA,EAAKpE,OAEpC,IAAIoF,EAAahB,GACf,MAAOs7B,GAAgBt7B,EAAMA,EAAKpE,OAEpC,IAAI8E,EAAWV,GAAO,CACpB,GAAMu7B,GAASpqB,EAAAE,gBAAgBrR,EAAKsR,SAAU1Y,EAAAC,KACxC2iC,EAAYrqB,EAAAE,gBAAgBrR,EAAKsR,SAAU1Y,EAAAE,OAEjD,OAAIyiC,IAAUC,EACLC,EAAqBz7B,EAAMpE,GAE7B8/B,EAAsB17B,EAAMpE,GAErC,KAAM,IAAIrd,OAAMqP,EAAI1L,QAAQif,cAG9B,QAAAw6B,GAA2B37B,EAA+DpE,GACxF,MAAI2E,GAAYP,GACPo7B,EAAep7B,EAAMpE,GAEvB8/B,EAAsB17B,EAAMpE,GAIrC,QAAAggC,GAAqC57B,EAAsGpE,GACzI,MAAI2E,GAAYP,GACPo7B,EAAep7B,EAAMpE,GAE1BiF,EAAab,GACRq7B,EAAgBr7B,EAAMpE,GAExB8/B,EAAsB17B,EAAMpE,GAIrC,QAAAu/B,GAAwBn7B,EAA2CpE,GAC1D,GAAAigC,GAAA77B,EAAAA,KAAe87B,EAAA74B,EAAAne,OAAAkb,GAAA,QACtB,OAAMiD,GAAApe,YACDi3C,GACH97B,KAAM27B,EAAkBE,EAASjgC,KAIrC,QAAAw/B,GAAwBp7B,EAA2CpE,GAC1D,GAAAoa,GAAAhW,EAAAgW,MAAc8lB,EAAA74B,EAAAne,OAAAkb,GAAA,SACrB,OAAMiD,GAAApe,YACDi3C,GACH9lB,MAAOA,EAAM7qB,IAAI,SAAC0wC,GAAY,MAAAF,GAAkBE,EAASjgC,OAI7D,QAAAy/B,GAAyBr7B,EAA4CpE,GAC5D,GAAAigC,GAAA77B,EAAAA,KAAe87B,EAAA74B,EAAAne,OAAAkb,GAAA,QACtB,OAAMiD,GAAApe,YACDi3C,GACH97B,KAAM47B,EAA4BC,EAASjgC,KAI/C,QAAA0/B,GAAyBt7B,EAA4CpE,GAC5D,GAAAiJ,GAAA7E,EAAA6E,QAAkBi3B,EAAA74B,EAAAne,OAAAkb,GAAA,WACzB,OAAMiD,GAAApe,YACDi3C,GACHj3B,QAASA,EAAQ1Z,IAAI,SAAC0wC,GAAY,MAAAF,GAAkBE,EAASjgC,OAIjE,QAAA6/B,GAA8Bz7B,EAAgCpE,GAG5D,GAAMkI,GAAA9D,EAAAsR,SAACtL,EAAAlC,EAAAkC,IAAUC,EAAAnC,EAAAmC,OAAgBqL,EAAArO,EAAAne,OAAAgf,GAAA,MAAA,WAG1BxK,EAAA0G,EAAA1G,KAAY2L,EAAAjF,EAAAiF,UAAmCqsB,GAAbtxB,EAAAsR,SAAarO,EAAAne,OAAAkb,GAAA,OAAA,YAAA,aAEtD,OAAMiD,GAAApe,YACDysC,GACH3oB,MAAK1F,EAAApe,YACCmhB,GAAOA,IAAGA,MACVC,GAAUA,OAAMA,OAEtBjG,KAAM07B,EAAqBz4B,EAAApe,UACzByU,KAAIA,EACJgY,SAAQA,GACJrM,GAAaA,UAASA,OACzBrJ,KAIP,QAAAmgC,GAA6C/7B,GAEzC,MAAO4T,GAAAmmB,gBAAgB/5B,EAAK1G,MAGhC,QAAAoiC,GAA+B17B,EAA0DpE,GACvF,GAAImgC,EAAoC/7B,GAAO,CAE7C,GAAImR,EAAA6lB,SAASh3B,EAAKsR,UAChB,MAAO0qB,GAAoBh8B,EAG7B,IAAMi8B,GAAgBrgC,GAAUA,EAAOk4B,QACjCoI,EAAkBD,GAAkBj8B,EAAK1G,OAASsa,EAAAsE,MACtDhgB,EAAAmC,UAAU,YAAa,QAAS4hC,EAAcvvC,MAC1CyvC,EAAmBF,IACtBA,EAAcpvC,MAAQmT,EAAK1G,OAASsa,EAAAqE,MACb,cAAvBgkB,EAAcvvC,MAAwBsT,EAAK1G,OAASsa,EAAAsE,KAGvD,OAAIikB,IAAoBD,EACfE,EAAiBp8B,EAAMm8B,EAAkBD,EAAiBtgC,GAG5DoE,EAEP,MAAOq8B,GAAcz5B,UAAU5C,EAAMpE,GAIzC,QAAAogC,GAA6Bh8B,GAC3B,GAAMs8B,GAAOnrB,EAAAE,gBAAgBrR,EAAKsR,SAAU1Y,EAAAY,GACtC+iC,EAAOprB,EAAAE,gBAAgBrR,EAAKsR,SAAU1Y,EAAAa,GACtC+iC,EAAQrrB,EAAAE,gBAAgBrR,EAAKsR,SAAU1Y,EAAAqB,IACvCwiC,EAAQtrB,EAAAE,gBAAgBrR,EAAKsR,SAAU1Y,EAAAsB,GAC7C,IAAKsiC,IAAUF,GAAUG,IAAUF,EAAO,CACxC,GAAMG,GAAiBxkC,EAAAiP,UAAUnH,EAUjC,OATIw8B,KAAUF,IACZI,EAAeprB,SAASrwB,EAAIy7C,EAAeprB,SAASuK,SAC7C6gB,GAAeprB,SAASuK,IAE7B4gB,IAAUF,IACZG,EAAeprB,SAAS9oB,EAAIk0C,EAAeprB,SAASqK,SAC7C+gB,GAAeprB,SAASqK,IAG1B+gB,EAET,MAAO18B,GAKT,QAAAo8B,GAA0Bp8B,EAAgBm8B,EAA2BD,EAA0BtgC,GACtF,GAAAtC,GAAA0G,EAAA1G,KAAMgY,EAAAtR,EAAAsR,SAAUggB,EAAAruB,EAAAne,OAAAkb,GAAA,OAAA,aACjBgW,IAAU1c,KAAIA,EAAEgY,SAAQA,IAGxBqrB,EAAavzB,EAAA0H,MAAMxX,EAAMgY,EAAU1V,EAASA,EAAOkV,UAAQ1wB,IAE7Dw8C,EAAkBtrB,CACtB,IAAIqrB,EAAY,CACP,GAAAE,GAAAF,EAAA7pB,aAAiC5M,EAAAy2B,EAAAz2B,MACxC02B,GAAe35B,EAAApe,YACVysB,GAAQxN,KAAAA,EACV+4B,GAAiB55B,EAAApe,YACbysB,EAASurB,GACR32B,GAAU4K,MAAO5K,OAAapC,IAyBxC,MApBIo4B,IACFlmB,EAAMx1B,MACJ8Y,MACEzP,KAAM,OACN8sB,KAAM,eAERrF,SAAUsrB,IAGVT,GACFnmB,EAAMx1B,MACJ8Y,MACEzP,KAAM,QACNuuB,QAAQ,EACRzB,KAAM,gBAERrF,SAAUsrB,IAIR35B,EAAApe,YACDysC,GACHtb,MAAKA,UAOT,QAAA8mB,GAAoBC,EAAW9F,GAY7B,MAXAA,GAAU/mC,QAAQ,SAASwL,GAEzB,GAAMshC,IAAgB,QAAS,OAAQ,QAAS,WAAY,MAAO,aAAalgC,OAAO,SAAC5f,EAAGqC,GAIzF,WAHsBa,KAAlBsb,EAASnc,KACXrC,EAAEqC,GAAOmc,EAASnc,IAEbrC,OAEHqC,EAAM2Y,EAAA2X,KAAKmtB,EACjBD,GAAKx9C,GAAOw9C,EAAKx9C,IAAQmc,IAEpBqhC,EAIT,QAAAE,GAAuBj9B,EAA8C+8B,GA2BnE,WA3BmE,KAAAA,IAAAA,MAE/Dx8B,EAAYP,GACdA,EAAKgW,MAAM9lB,QAAQ,SAAA8lB,GACbtV,EAAWsV,GACb8mB,EAAWC,EAAM1N,EAAW4H,UAAUjhB,EAAM1E,WAE5C2rB,EAAcjnB,EAAO+mB,KAGhB38B,EAAYJ,IACrB88B,EAAWC,EAAM1N,EAAW4H,UAAUj3B,EAAK2I,QAC3Cs0B,EAAcj9B,EAAKA,KAAM+8B,IAChBl8B,EAAab,IACtB88B,EAAWC,EAAM1N,EAAW4H,UAAUj3B,EAAKA,OAC3Ci9B,EAAcj9B,EAAKA,KAAM+8B,IAChB/7B,EAAahB,GACtBA,EAAK6E,QAAQ3U,QAAQ,SAAAE,GACfsQ,EAAWtQ,GACb0sC,EAAWC,EAAM1N,EAAW4H,UAAU7mC,EAAMkhB,WAE5C2rB,EAAc7sC,EAAO2sC,KAIzBD,EAAWC,EAAM1N,EAAW4H,UAAUj3B,EAAKsR,WAEtCyrB,EAIT,QAAA9F,GAA0Bj3B,GACxB,MAAO9H,GAAAsH,KAAKy9B,EAAcj9B,IAG5B,QAAAk9B,GAA0Bl9B,EAA0CpE,GAElE,MADAA,GAASA,GAAUoE,EAAKpE,SACpBgY,EAAAmmB,gBAAgB/5B,EAAK1G,OAGX,OAFL8P,EAAA0H,MAAM9Q,EAAK1G,KAAM0G,EAAKsR,SACrB1V,EAASA,EAAOkV,UAAQ1wB;kEAtapCwY,EAAAva,EAAA,aACAg+C,EAAAh+C,EAAA,mBAIA8yB,EAAA9yB,EAAA,cACAgxC,EAAAhxC,EAAA,cAGAuP,EAAAvP,EAAA,SACAu1B,EAAAv1B,EAAA,UAGA+qB,EAAA/qB,EAAA,WAGA6Z,EAAA7Z,EAAA,SAgIAlB,GAAAijB,YAAAA,EAIAjjB,EAAAujB,WAAAA,EAIAvjB,EAAAojB,YAAAA,EAIApjB,EAAA0jB,aAAAA,EAIA1jB,EAAA6jB,aAAAA,EAQA7jB,EAAAylB,UAAAA,EAsPAzlB,EAAA85C,UAAAA,EAIA95C,EAAA+/C,UAAAA,kJCvXA,SAAApsB,GAAsB9uB,EAAmBsvB,EAA2B6rB,GAClE,GAAM7jC,GAAOsa,EAAAoH,UAAUh5B,GAAKA,EAAE6H,KAAO7H,CAErC,KAAKkW,EAAAmC,SAASld,EAAAigD,gBAAiB9jC,GAC7B,MAAO,KAIT,KAAK6X,EAAA9J,YAAYiK,GACf,MAAO,KAIT,IAAMgB,GAAU1Z,EAAAwC,qBAAqB0B,OAAO,SAACugC,EAAI1kC,GAC/C,GAAIwY,EAAAE,gBAAgBC,EAAU3Y,GAAU,CACtC,GAAMmlB,GAAaxM,EAAS3Y,IAC3BT,EAAA7X,QAAQy9B,GAAcA,GAAcA,IAAa5tB,QAAQ,SAACwL,GACrD2D,EAAAya,WAAWpe,KAAcA,EAASsG,WACpCq7B,EAAG78C,MACDmY,QAASA,EACT+C,SAAUA,MAKlB,MAAO2hC,OAGT,IAAuB,IAAnB/qB,EAAQ3zB,OACV,MAAO,KAIT,IAAM2+C,GAAYj+B,EAAAya,WAAWxI,EAASrwB,GAChCs8C,EAAYl+B,EAAAya,WAAWxI,EAAS9oB,GAChCg1C,EAAen+B,EAAAya,WAAWxI,EAASrwB,MAAQqwB,EAASrwB,EAAE+gB,SAG5D,IAAIw7B,KAFiBn+B,EAAAya,WAAWxI,EAAS9oB,MAAQ8oB,EAAS9oB,EAAEwZ,WAEzB,CACjC,GAAM8Q,GAAe0qB,EAAe5kC,EAAAY,EAAIZ,EAAAa,EAClCiC,EAAW4V,EAASwB,GACpB2qB,EAAwB/hC,EAASsG,UACjC07B,EAAoBhiC,EAASoC,MAE/B6/B,EAA2B,IAU/B,OAREA,OADqBv9C,KAAnBsb,EAASoV,MACGpV,EAASoV,MACd5Y,EAAAmC,SAASld,EAAAygD,uBAAwBtkC,QAEZlZ,KAAhB+8C,EAA4B,OAE5BA,EAGXQ,GAA+B,SAAhBA,EAKhBD,GAAqBA,EAAkB7zC,MAAQ6zC,EAAkB7zC,OAAS8Q,EAAAwU,UAAUyZ,QACtFh7B,EAAIgB,KAAKhB,EAAI1L,QAAQq3C,0BAA0BmE,EAAkB7zC,OAC1D,MAGLsnB,EAAAE,gBAAgBC,EAAUwB,IAAiBla,EAAAY,EAAIZ,EAAAqB,GAAKrB,EAAAsB,KACtDtM,EAAIgB,KAAKhB,EAAI1L,QAAQo3C,sBAAsBxmB,IACpC,MAGJ5a,EAAAmC,SAAS8O,EAAA9Q,QAASolC,IAMrB7qB,eAAgB4qB,EAAgBD,EAAY3kC,EAAAa,EAAI,KAAS6jC,EAAY1kC,EAAAY,EAAI,KACzEsZ,aAAcA,EACdR,QAASA,EACTpM,OAAQy3B,IARR/vC,EAAIgB,KAAKhB,EAAI1L,QAAQs3C,iCAAiCiE,IAC/C,MAhBA,KA0BX,MAAO,sDA5HT,IAAA7vC,GAAAvP,EAAA,SAEA8qB,EAAA9qB,EAAA,eACAua,EAAAva,EAAA,aACA8yB,EAAA9yB,EAAA,cACAghB,EAAAhhB,EAAA,cACAu1B,EAAAv1B,EAAA,UACAsc,EAAAtc,EAAA,WACA6Z,EAAA7Z,EAAA,SA6BalB,GAAAigD,iBAAmBxpB,EAAAgE,IAAKhE,EAAAsE,KAAMtE,EAAA4H,KAAM5H,EAAAoE,MAAOpE,EAAAkE,OAAQlE,EAAAmE,OAAQnE,EAAAqE,KAAMrE,EAAAzZ,KAAMyZ,EAAAiE,MACvE16B,EAAAygD,wBAA0BhqB,EAAAgE,IAAKhE,EAAAsE,MAK5C/6B,EAAA2zB,MAAAA,qJCaA,SAAAwnB,GAAiCp8B,GAC/B,QAAS2hC,EAAsB3hC,GAQjC,QAAA4hC,GAAwB9R,EAAgB2I,GACtC,GAAMvxC,GAAe,GAAIyO,MAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAmChD,OAlCA1U,GAAA4gD,iBAAiB7tC,QAAQ,SAAS8tC,GAChC,GAAIC,EAAiBjS,EAAMgS,GACzB,OAAQA,GACN,IAAKE,GAASC,IACZ,KAAM,IAAI5/C,OAAM,+CAClB,KAAK2/C,GAASE,KACZh7C,EAAO+yC,YAAYxB,EAAK0J,cACxB,MACF,KAAKH,GAASI,QAEZl7C,EAAOkzC,SAA6C,EAAnC/kC,KAAKgtC,MAAM5J,EAAK6J,WAAa,GAC9C,MACF,KAAKN,GAASO,MACZr7C,EAAOkzC,SAAS3B,EAAK6J,WACrB,MACF,KAAKN,GAASQ,KACZt7C,EAAOizC,QAAQ1B,EAAKgK,UACpB,MACF,KAAKT,GAASU,MACZx7C,EAAOmzC,SAAS5B,EAAKkK,WACrB,MACF,KAAKX,GAASY,QACZ17C,EAAOozC,WAAW7B,EAAKoK,aACvB,MACF,KAAKb,GAASc,QACZ57C,EAAOqzC,WAAW9B,EAAKsK,aACvB,MACF,KAAKf,GAASgB,aACZ97C,EAAOszC,gBAAgB/B,EAAKwK,sBAM7B/7C,EAuBT,QAAAg8C,GAAgCljC,GAC9B,QAASmjC,EAAqBnjC,GA4BhC,QAAA+hC,GAAiCtE,EAAwBz9B,GACvD,GAAMixB,GAAQwM,EAAal5C,QAAQyb,EACnC,OAAOixB,IAAS,IAEZjxB,IAAagiC,EAASc,SACZ,IAAV7R,GACiC,MAAjCwM,EAAat3C,OAAO8qC,EAAM,IAOhC,QAAAja,GAA0BymB,EAAwBxrC,GAGhD,QAAAmxC,GAAcpjC,GACZ,MAAIA,KAAagiC,EAASI,QAEjB,YAAYtpB,EAAQ,OAEjB9Y,EAAQ,IAAI8Y,EAAQ,IAPlC,GAAMA,GAAY,UAAU7mB,EAAK,KAW3B/H,EAAIjJ,EAAA4gD,iBAAiBjhC,OAAO,SAACwkB,EAAkB7Q,GAInD,MAHIwtB,GAAiBtE,EAAclpB,KACjC6Q,EAAG7Q,GAAM6uB,EAAK7uB,IAET6Q,MAST,OANIl7B,GAAEwuC,KAAO18B,EAAAvX,KAAKyF,GAAGzH,OAAS,IAC5BiP,EAAIgB,KAAKhB,EAAI1L,QAAQw3C,oBAAoBC,UAClCvzC,GAAEwuC,IACTxuC,EAAEuuC,KAAO2K,EAAKpB,EAASQ,OAGlBj/B,EAAAm3B,aAAaxwC,GAItB,QAAA+gC,GAA6BjrB,GAC3B,GAAKA,EAIL,MAAI+hC,GAAiB/hC,EAAUgiC,EAASc,SAC/B,SAGLf,EAAiB/hC,EAAUgiC,EAASY,SAC/B,SAGLb,EAAiB/hC,EAAUgiC,EAASU,OAC/B,OAGLX,EAAiB/hC,EAAUgiC,EAASC,MACpCF,EAAiB/hC,EAAUgiC,EAASQ,MAC/B,MAGLT,EAAiB/hC,EAAUgiC,EAASO,OAC/B,QAGLR,EAAiB/hC,EAAUgiC,EAASE,MAC/B,WADT,GAOF,QAAAj8B,GAAiCjG,EAAoB/N,EAAeiO,GAClE,GAAKF,EAAL,CAIA,GAAMqjC,MACFnsB,EAAa,GACXosB,EAAUvB,EAAiB/hC,EAAUgiC,EAASE,KAEhDH,GAAiB/hC,EAAUgiC,EAASI,WAEtClrB,EAAa,iBAAiBjlB,EAAK,KAGjC8vC,EAAiB/hC,EAAUgiC,EAASO,QAEtCc,EAAe/+C,MAAyB,IAApB4b,EAA4B,KAAO,MAGrD6hC,EAAiB/hC,EAAUgiC,EAASC,KACtCoB,EAAe/+C,KAAK4b,EAAkB,KAAO,MACpC6hC,EAAiB/hC,EAAUgiC,EAASQ,OAC7Ca,EAAe/+C,KAAK,MAAQg/C,EAAU,IAAM,KAG1CA,GACFD,EAAe/+C,KAAK4b,EAAkB,KAAO,KAG/C,IAAMqjC,KAEFxB,GAAiB/hC,EAAUgiC,EAASU,QACtCa,EAAej/C,KAAK,MAElBy9C,EAAiB/hC,EAAUgiC,EAASY,UACtCW,EAAej/C,KAAK,MAElBy9C,EAAiB/hC,EAAUgiC,EAASc,UACtCS,EAAej/C,KAAK,MAElBy9C,EAAiB/hC,EAAUgiC,EAASgB,eACtCO,EAAej/C,KAAK,KAGtB,IAAMk/C,KAiBN,OAhBIH,GAAe5gD,OAAS,GAC1B+gD,EAAmBl/C,KAAK++C,EAAengD,KAAK,MAE1CqgD,EAAe9gD,OAAS,GAC1B+gD,EAAmBl/C,KAAKi/C,EAAergD,KAAK,MAG1CsgD,EAAmB/gD,OAAS,IAC1By0B,IAEFA,GAAc,aAEhBA,GAAc,cAAcjlB,EAAK,MAAMuxC,EAAmBtgD,KAAK,KAAI,MAI9Dg0B,OAAchzB,IAGvB,QAAA6nC,GAAoC/rB,GAClC,OAAQA,GAEN,IAAK,QACL,IAAK,MACL,IAAK,QACL,IAAK,UACH,OAAO,EAEX,OAAO,kDA7ST,IAIiBgiC,GAJjBz+B,EAAAphB,EAAA,cACAuP,EAAAvP,EAAA,SACA6Z,EAAA7Z,EAAA,WAEA,SAAiB6/C,GACFA,EAAAE,KAAe,OACfF,EAAAO,MAAiB,QACjBP,EAAAC,IAAa,MACbD,EAAAQ,KAAe,OACfR,EAAAU,MAAiB,QACjBV,EAAAY,QAAqB,UACrBZ,EAAAc,QAAqB,UACrBd,EAAAgB,aAA+B,eAC/BhB,EAAAyB,UAAyB,YACzBzB,EAAA0B,cAAiC,gBACjC1B,EAAA2B,mBAA2C,qBAC3C3B,EAAA4B,0BAAyD,4BACzD5B,EAAA6B,iCAAuE,mCAGvE7B,EAAA8B,UAAyB,YACzB9B,EAAA+B,aAA+B,eAC/B/B,EAAAgC,oBAA6C,sBAC7ChC,EAAAiC,eAAmC,iBACnCjC,EAAAkC,oBAA6C,sBAC7ClC,EAAAI,QAAqB,UACrBJ,EAAAmC,YAA6B,cAC7BnC,EAAAoC,aAA+B,eAC/BpC,EAAAqC,iBAAuC,oBAxBrCrC,EAAA/gD,EAAA+gD,WAAA/gD,EAAA+gD,cAmCJ/gD,EAAA4gD,kBACXG,EAASE,KACTF,EAASI,QACTJ,EAASO,MACTP,EAASC,IACTD,EAASQ,KACTR,EAASU,MACTV,EAASY,QACTZ,EAASc,QACTd,EAASgB,aAGX,IAAMrB,GAAuC1gD,EAAA4gD,iBAAiBjhC,OAAO,SAAC1W,EAAG8V,GAEvE,MADA9V,GAAE8V,IAAY,EACP9V,MAGTjJ,GAAAm7C,iBAAAA,EASAn7C,EAAA2gD,QAAAA,EAuCa3gD,EAAAqjD,iBACXtC,EAASmC,YACTnC,EAASqC,iBACTrC,EAASyB,UACTzB,EAAS0B,cACT1B,EAAS2B,mBACT3B,EAAS4B,0BACT5B,EAAS6B,iCACT7B,EAASoC,aACTpC,EAAS+B,aACT/B,EAASgC,oBACThC,EAASiC,eACTjC,EAASkC,oBAGX,IAAMf,GAAsCliD,EAAAqjD,gBAAgB1jC,OAAO,SAAC1W,EAAG8V,GAErE,MADA9V,GAAE8V,IAAY,EACP9V,MAGTjJ,GAAAiiD,gBAAAA,EAIajiD,EAAAsjD,WACXvC,EAASE,KACTF,EAASI,QACTJ,EAASO,MACTP,EAASC,IACTD,EAASQ,KACTR,EAASU,MACTV,EAASY,QACTZ,EAASc,QACTd,EAASgB,aACThB,EAASmC,YACTnC,EAASqC,iBACTrC,EAASyB,UACTzB,EAAS0B,cACT1B,EAAS2B,mBACT3B,EAAS4B,0BACT5B,EAAS6B,iCACT7B,EAASoC,aACTpC,EAAS+B,aACT/B,EAASgC,oBACThC,EAASiC,eACTjC,EAASkC,qBAIXjjD,EAAA8gD,iBAAAA,EAaA9gD,EAAA+1B,UAAAA,EA6BA/1B,EAAAgqC,aAAAA,EAiCAhqC,EAAAglB,iBAAAA,EAgEAhlB,EAAA8qC,oBAAAA,6ECzQA,SAAA9kB,GAAwErlB,GACtE,MAAO4iD,GAAqB5jC,OAAO,SAAC5e,EAAGmI,GAIrC,MAHIvI,QAAcsC,KAATtC,EAAEuI,KACTnI,EAAEmI,GAAKvI,EAAEuI,IAEJnI,uDATX,IAAMwiD,IACJ,aAAc,UAGhBvjD,GAAAgmB,0BAAAA,uCClBA,SAAAkL,GAAyBvwB,GACvB,WAAuBsC,KAAhBtC,EAAU,OAcnB,QAAAqwB,GAA4BrwB,GAC1B,WAA0BsC,KAAnBtC,EAAa,2DAhBtBX,EAAAkxB,SAAAA,EAeAlxB,EAAAgxB,YAAAA,uCCHA,SAAAupB,GAA4B7tC,GAC1B,GAAIA,EAEF,OADAA,EAAOA,EAAKwrC,eAEV,IAAK,IACL,IAAKl4C,GAAA4kB,aACH,MAAO,cACT,KAAK,IACL,IAAK5kB,GAAA2e,SACH,MAAO,UACT,KAAK,IACL,IAAK3e,GAAAsf,QACH,MAAO,SACT,KAAK,IACL,IAAKtf,GAAAqf,QACH,MAAO,2DAjCf,IAAiB4rB,IAAjB,SAAiBA,GACFA,EAAArmB,aAA+B,eAC/BqmB,EAAA3rB,QAAqB,UACrB2rB,EAAAtsB,SAAuB,WACvBssB,EAAA5rB,QAAqB,WAJnB4rB,EAAAjrC,EAAAirC,OAAAjrC,EAAAirC,UAQJjrC,EAAA4kB,aAAeqmB,EAAKrmB,aACpB5kB,EAAAsf,QAAU2rB,EAAK3rB,QACftf,EAAA2e,SAAWssB,EAAKtsB,SAChB3e,EAAAqf,QAAU4rB,EAAK5rB,QAO5Brf,EAAAu6C,YAAAA,uCCPA,SAAAiJ,GAAqB5hD,EAAU2+B,GAC7B,GAAMhU,KAMN,OALAgU,GAAMxtB,QAAQ,SAACsR,GACTziB,EAAIuC,eAAekgB,KACrBkI,EAAKlI,GAAQziB,EAAIyiB,MAGdkI,EAOT,QAAAk3B,GAAqB7hD,EAAU2+B,GAC7B,GAAMhU,GAAOvC,EAAUpoB,EAIvB,OAHA2+B,GAAMxtB,QAAQ,SAACsR,SACNkI,GAAKlI,KAEPkI,EAGT,QAAAmG,GAAqBzxB,GACnB,MAAIyiD,GAAAlzC,SAASvP,IAAMyiD,EAAArwC,SAASpS,IAAMkS,EAAUlS,GACnCwE,OAAOxE,GAET0B,EAAU1B,GAGnB,QAAAic,GAA4BrX,EAAYzC,GACtC,MAAOyC,GAAMvC,QAAQF,IAAS,EAIhC,QAAA4a,GAA2BnY,EAAY89C,GACrC,MAAO99C,GAAMsI,OAAO,SAAA/K,GAAQ,OAAC8Z,EAASymC,EAAevgD,KAGvD,QAAAosC,GAAyB3pC,EAAYykB,GACnC,MAAOzkB,GAAMmG,OAAOgS,EAAQsM,EAAOzkB,IAMrC,QAAAua,GAAwB25B,EAAUh6C,GAEhC,IAAK,GADDoB,GAAI,EACCiF,EAAI,EAAGA,EAAE2zC,EAAIv4C,OAAQ4E,IAC5B,GAAIrG,EAAEg6C,EAAI3zC,GAAIA,EAAGjF,KACf,OAAO,CAGX,QAAO,EAMR,QAAA8pB,GAAyB8uB,EAAUh6C,GAElC,IAAK,GADDoB,GAAI,EACCiF,EAAI,EAAGA,EAAE2zC,EAAIv4C,OAAQ4E,IAC5B,IAAKrG,EAAEg6C,EAAI3zC,GAAIA,EAAGjF,KAChB,OAAO,CAGX,QAAO,EAGT,QAAA4qB,GAAwB63B,GACtB,SAAU53C,OAAO7E,SAAUy8C,GAM7B,QAAA9N,GAA0B+N,OAAW,GAAAC,MAAA/7B,EAAA,EAAAA,EAAAxe,UAAA/H,OAAAumB,IAAA+7B,EAAA/7B,EAAA,GAAAxe,UAAAwe,EACnC,KAAgB,GAAApB,GAAA,EAAAo9B,EAAAD,EAAAn9B,EAAAo9B,EAAAviD,OAAAmlB,IAAG,CACjBk9B,EAAOG,EAAWH,EADRE,EAAAp9B,IAGZ,MAAOk9B,GAIT,QAAAG,GAAoBH,EAAWC,GAC7B,GAAmB,gBAARA,IAA4B,OAARA,EAC7B,MAAOD,EAGT,KAAK,GAAM36C,KAAK46C,GACTA,EAAI3/C,eAAe+E,QAGTjG,KAAX6gD,EAAI56C,KAGc,gBAAX46C,GAAI56C,IAAmBw6C,EAAAxgD,QAAQ4gD,EAAI56C,KAAkB,OAAX46C,EAAI56C,GACvD26C,EAAK36C,GAAK46C,EAAI56C,GACc,gBAAZ26C,GAAK36C,IAA+B,OAAZ26C,EAAK36C,GAC7C26C,EAAK36C,GAAK4sC,EAAUgO,EAAI56C,GAAGE,cAAgBpH,YAAiB8hD,EAAI56C,IAEhE4sC,EAAU+N,EAAK36C,GAAI46C,EAAI56C,IAG3B,OAAO26C,GAGT,QAAA7c,GAA0BtlB,EAAa3hB,GAIrC,IAAkB,GADdsG,GAFE49C,KACAjjD,KAEY+mB,EAAA,EAAAm8B,EAAAxiC,EAAAqG,EAAAm8B,EAAA1iD,OAAAumB,IAAM,CAAnB,GAAMoJ,GAAG+yB,EAAAn8B,EACZ1hB,GAAItG,EAAEoxB,GACF9qB,IAAKrF,KAGTA,EAAEqF,GAAK,EACP49C,EAAQ5gD,KAAK8tB,IAEf,MAAO8yB,GAYT,QAAA15B,GAA0Bq1B,EAAet1B,GACvC,IAAK,GAAMloB,KAAOw9C,GAChB,GAAIA,EAAKz7C,eAAe/B,IAClBkoB,EAAMloB,IAAQw9C,EAAKx9C,IAAQkoB,EAAMloB,KAASw9C,EAAKx9C,GACjD,OAAO,CAIb,QAAO,EAGT,QAAA+hD,GAAgCljD,EAAcsB,GAC5C,IAAK,GAAMH,KAAOnB,GAChB,GAAImB,IAAOG,GACT,OAAO,CAGX,QAAO,EAGT,QAAAowB,GAA+B9sB,EAAYykB,GACzC,GAAIzkB,EAAMrE,SAAW8oB,EAAM9oB,OACzB,OAAO,CAGTqE,GAAMnC,OACN4mB,EAAM5mB,MAEN,KAAK,GAAIvC,GAAI,EAAGA,EAAI0E,EAAMrE,OAAQL,IAChC,GAAImpB,EAAMnpB,KAAO0E,EAAM1E,GACrB,OAAO,CAIX,QAAO,EAKT,QAAAkhB,GAAwBve,GACtB,GAAMsgD,KACN,KAAK,GAAMh+C,KAAKtC,GACVA,EAAEK,eAAeiC,IACnBg+C,EAAM/gD,KAAKS,EAAEsC,GAGjB,OAAOg+C,GAGT,QAAAp6B,GAA6BpoB,GAC3B,MAAOD,MAAKyC,MAAMzC,KAAKgB,UAAUf,IAGnC,QAAAuR,GAA0B5Q,GACxB,OAAa,IAANA,IAAoB,IAANA,EAMvB,QAAAgiC,GAAwBzjC,GAEtB,GAAMujD,GAAgBvjD,EAAE4F,QAAQ,MAAO,IAGvC,QAAQ5F,EAAEwjD,MAAM,QAAU,IAAM,IAAMD,kDAjNxC,IAAA1hD,GAAAzB,EAAA,yBACAo0B,EAAAp0B,EAAA,YAAQlB,GAAAoS,OAAAkjB,EAAAljB,OAAQpS,EAAAkD,QAAAoyB,EAAApyB,QAASlD,EAAAuQ,SAAA+kB,EAAA/kB,SAAUvQ,EAAAqT,SAAAiiB,EAAAjiB,SAAUrT,EAAAwQ,SAAA8kB,EAAA9kB,SAAUxQ,EAAA6U,SAAAygB,EAAAzgB,SAAU7U,EAAA4U,MAAA0gB,EAAA1gB,MAAO5U,EAAAsV,YAAAggB,EAAAhgB,WACxE,IAAAouC,GAAAxiD,EAAA,YAYAlB,GAAAwjD,KAAAA,EAcAxjD,EAAAyjD,KAAAA,EAQAzjD,EAAA0yB,KAAAA,EAOA1yB,EAAAkd,SAAAA,EAKAld,EAAAge,QAAAA,EAIAhe,EAAAwvC,MAAAA,EAOAxvC,EAAAogB,KAAAA,EAaCpgB,EAAAirB,MAAAA,EAUDjrB,EAAA+rB,QAAAA,EAOA/rB,EAAA81C,UAAAA,EA+BA91C,EAAAgnC,OAAAA,EAwBAhnC,EAAAuqB,OAAAA,EAWAvqB,EAAAmkD,gBAAAA,EASAnkD,EAAA2yB,YAAAA,EAiBa3yB,EAAAwD,KAAOQ,OAAOR,KAE3BxD,EAAAqiB,KAAAA,EAUAriB,EAAAgqB,UAAAA,EAIAhqB,EAAAmT,UAAAA,EAOAnT,EAAAukC,QAAAA,8EClJA,SAAAggB,GAAwC1hC,EACtC2hC,EACAC,OADA,KAAAD,IAAAA,EAAAxkD,EAAA0kD,kCACA,KAAAD,IAAAA,EAAAzkD,EAAA2kD,+BAEA,IAAMxoC,GAAOsa,EAAAoH,UAAUhb,EAAK1G,MAAQ0G,EAAK1G,KAAKzP,KAAOmW,EAAK1G,KACpDgY,EAAWtR,EAAKsR,SAChBywB,EAAmBJ,EAAmBroC,GACtC0oC,EAAoBJ,EAAoBtoC,EAE9C,KAAK,GAAMhb,KAAKyjD,GACd,KAAMA,EAAiBzjD,IAAMgzB,IAC3B,MAAO,6BAAgCywB,EAAiBzjD,GACtD,eAAmBgb,EAAO,GAIhC,KAAK,GAAMX,KAAW2Y,GACpB,IAAK0wB,EAAkBrpC,GACrB,MAAO,qBAAwBA,EAC7B,oCAAwCW,EAAO,GAIrD,OAAIA,KAASm2B,EAAA7X,KAAQtG,EAASrwB,GAAMqwB,EAAS9oB,EAItC,KAHE,+EAlFX,IAAAorB,GAAAv1B,EAAA,UAKAoxC,EAAApxC,EAAA,UACA6Z,EAAA7Z,EAAA,SAUalB,GAAA0kD,8BACXngD,MAAO,QACPmL,MAAO,IAAK,KACZH,MAAO,IAAK,MAYDvP,EAAA2kD,gCACX9nC,IAAK9B,EAAAnG,OAAO,MAAO,SAAU,IAAK,IAAK,OAAQ,QAAS,WACxDlF,KAAMqL,EAAAnG,OAAO,MAAO,SAAU,IAAK,IAAK,QAAS,WACjDrF,KAAMwL,EAAAnG,OAAO,MAAO,SAAU,IAAK,IAAK,QAAS,WACjD8H,KAAM3B,EAAAnG,OAAO,MAAO,SAAU,IAAK,IAAK,QAAS,WACjD+H,OAAQ5B,EAAAnG,OAAO,MAAO,SAAU,IAAK,IAAK,QAAS,OAAQ,WAC3DgI,OAAQ7B,EAAAnG,OAAO,MAAO,SAAU,IAAK,IAAK,QAAS,OAAQ,WAC3D6H,MAAO1B,EAAAnG,OAAO,MAAO,SAAU,IAAK,IAAK,QAAS,OAAQ,SAAU,UACpErQ,KAAMwW,EAAAnG,OAAO,MAAO,SAAU,OAAQ,QAAS,UAmBjD5U,EAAAukD,wBAAAA,8DC0DA,SAAA/sB,GAAuClW,GACrC,OAAKvG,EAAA7X,QAAQoe,KACJ,UAAYA,MAAY,QAAUA,KAK7C,QAAAiW,GAAsCjW,GACpC,OAAKvG,EAAA7X,QAAQoe,KACJ,UAAYA,IAAU,QAAUA,IAK3C,QAAAgW,GAAgChW,GAC9B,OAAKvG,EAAA7X,QAAQoe,KACH,SAAWA,IAAU,QAAUA,IAK3C,QAAA0X,GAAkC1X,GAChC,OAAKvG,EAAA7X,QAAQoe,IACJ,UAAYA,mDAxIvB,IAAAvG,GAAA7Z,EAAA,SAiHAlB,GAAAw3B,uBAAAA,EAOAx3B,EAAAu3B,sBAAAA,EAOAv3B,EAAAs3B,gBAAAA,EAOAt3B,EAAAg5B,kBAAAA,qGCzIAh5B,EAAAwe,KAAAtd,EAAA,UACAlB,EAAA6kB,UAAA3jB,EAAA,eACAlB,EAAA8V,IAAA5U,EAAA,SACAlB,EAAAwb,QAAAta,EAAA,aACAlB,EAAAk/C,cAAAh+C,EAAA,kBACA,IAAA4jD,GAAA5jD,EAAA,oBAAQlB,GAAAqlB,QAAAy/B,EAAAz/B,QACRrlB,EAAAye,OAAAvd,EAAA,YACAlB,EAAAgX,KAAA9V,EAAA,UACAlB,EAAAo7C,SAAAl6C,EAAA,cACAlB,EAAAm0B,SAAAjzB,EAAA,cACAlB,EAAAwrB,MAAAtqB,EAAA,WACAlB,EAAAue,SAAArd,EAAA,cACAlB,EAAA8uB,OAAA5tB,EAAA,YACAlB,EAAAmc,KAAAjb,EAAA,UACAlB,EAAA2gB,MAAAzf,EAAA,WACAlB,EAAA0D,KAAAxC,EAAA,UACAlB,EAAA6iB,KAAA3hB,EAAA,UACAlB,EAAA2zB,MAAAzyB,EAAA,WACAlB,EAAA+e,SAAA7d,EAAA,cACAlB,EAAAutB,UAAArsB,EAAA,eACAlB,EAAA0M,KAAAxL,EAAA,UACAlB,EAAAsgC,KAAAp/B,EAAA,UACAlB,EAAA+kD,SAAA7jD,EAAA,cAEalB,EAAAwV,QAAkBtU,EAAQ,mBAAmBsU","sourceRoot":"","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');\n\nmodule.exports = function (obj, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var space = opts.space || '';\n    if (typeof space === 'number') space = Array(space+1).join(' ');\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n    var replacer = opts.replacer || function(key, value) { return value; };\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (parent, key, node, level) {\n        var indent = space ? ('\\n' + new Array(level + 1).join(space)) : '';\n        var colonSeparator = space ? ': ' : ':';\n\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        node = replacer.call(parent, key, node);\n\n        if (node === undefined) {\n            return;\n        }\n        if (typeof node !== 'object' || node === null) {\n            return json.stringify(node);\n        }\n        if (isArray(node)) {\n            var out = [];\n            for (var i = 0; i < node.length; i++) {\n                var item = stringify(node, i, node[i], level+1) || json.stringify(null);\n                out.push(indent + space + item);\n            }\n            return '[' + out.join(',') + indent + ']';\n        }\n        else {\n            if (seen.indexOf(node) !== -1) {\n                if (cycles) return json.stringify('__cycle__');\n                throw new TypeError('Converting circular structure to JSON');\n            }\n            else seen.push(node);\n\n            var keys = objectKeys(node).sort(cmp && cmp(node));\n            var out = [];\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var value = stringify(node, key, node[key], level+1);\n\n                if(!value) continue;\n\n                var keyValue = json.stringify(key)\n                    + colonSeparator\n                    + value;\n                ;\n                out.push(indent + space + keyValue);\n            }\n            seen.splice(seen.indexOf(node), 1);\n            return '{' + out.join(',') + indent + '}';\n        }\n    })({ '': obj }, '', obj, 0);\n};\n\nvar isArray = Array.isArray || function (x) {\n    return {}.toString.call(x) === '[object Array]';\n};\n\nvar objectKeys = Object.keys || function (obj) {\n    var has = Object.prototype.hasOwnProperty || function () { return true };\n    var keys = [];\n    for (var key in obj) {\n        if (has.call(obj, key)) keys.push(key);\n    }\n    return keys;\n};\n","exports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n","var at, // The index of the current character\n    ch, // The current character\n    escapee = {\n        '\"':  '\"',\n        '\\\\': '\\\\',\n        '/':  '/',\n        b:    '\\b',\n        f:    '\\f',\n        n:    '\\n',\n        r:    '\\r',\n        t:    '\\t'\n    },\n    text,\n\n    error = function (m) {\n        // Call error when something is wrong.\n        throw {\n            name:    'SyntaxError',\n            message: m,\n            at:      at,\n            text:    text\n        };\n    },\n    \n    next = function (c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        \n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    },\n    \n    number = function () {\n        // Parse a number value.\n        var number,\n            string = '';\n        \n        if (ch === '-') {\n            string = '-';\n            next('-');\n        }\n        while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n        }\n        if (ch === '.') {\n            string += '.';\n            while (next() && ch >= '0' && ch <= '9') {\n                string += ch;\n            }\n        }\n        if (ch === 'e' || ch === 'E') {\n            string += ch;\n            next();\n            if (ch === '-' || ch === '+') {\n                string += ch;\n                next();\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    },\n    \n    string = function () {\n        // Parse a string value.\n        var hex,\n            i,\n            string = '',\n            uffff;\n        \n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while (next()) {\n                if (ch === '\"') {\n                    next();\n                    return string;\n                } else if (ch === '\\\\') {\n                    next();\n                    if (ch === 'u') {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === 'string') {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    },\n\n    white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= ' ') {\n            next();\n        }\n    },\n\n    word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case 't':\n            next('t');\n            next('r');\n            next('u');\n            next('e');\n            return true;\n        case 'f':\n            next('f');\n            next('a');\n            next('l');\n            next('s');\n            next('e');\n            return false;\n        case 'n':\n            next('n');\n            next('u');\n            next('l');\n            next('l');\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    },\n\n    value,  // Place holder for the value function.\n\n    array = function () {\n\n// Parse an array value.\n\n        var array = [];\n\n        if (ch === '[') {\n            next('[');\n            white();\n            if (ch === ']') {\n                next(']');\n                return array;   // empty array\n            }\n            while (ch) {\n                array.push(value());\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad array\");\n    },\n\n    object = function () {\n\n// Parse an object value.\n\n        var key,\n            object = {};\n\n        if (ch === '{') {\n            next('{');\n            white();\n            if (ch === '}') {\n                next('}');\n                return object;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(':');\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\nvalue = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n    white();\n    switch (ch) {\n    case '{':\n        return object();\n    case '[':\n        return array();\n    case '\"':\n        return string();\n    case '-':\n        return number();\n    default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n};\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\nmodule.exports = function (source, reviver) {\n    var result;\n    \n    text = source;\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n    if (ch) {\n        error(\"Syntax error\");\n    }\n\n    // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n    return typeof reviver === 'function' ? (function walk(holder, key) {\n        var k, v, value = holder[key];\n        if (value && typeof value === 'object') {\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = walk(value, k);\n                    if (v !== undefined) {\n                        value[k] = v;\n                    } else {\n                        delete value[k];\n                    }\n                }\n            }\n        }\n        return reviver.call(holder, key, value);\n    }({'': result}, '')) : result;\n};\n","var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    gap,\n    indent,\n    meta = {    // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    \n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n        var c = meta[a];\n        return typeof c === 'string' ? c :\n            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n    // Produce a string from holder[key].\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n    \n    // If the value has a toJSON method, call it to obtain a replacement value.\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n    \n    // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n    \n    // What happens next depends on the value's type.\n    switch (typeof value) {\n        case 'string':\n            return quote(value);\n        \n        case 'number':\n            // JSON numbers must be finite. Encode non-finite numbers as null.\n            return isFinite(value) ? String(value) : 'null';\n        \n        case 'boolean':\n        case 'null':\n            // If the value is a boolean or null, convert it to a string. Note:\n            // typeof null does not produce 'null'. The case is included here in\n            // the remote chance that this gets fixed someday.\n            return String(value);\n            \n        case 'object':\n            if (!value) return 'null';\n            gap += indent;\n            partial = [];\n            \n            // Array.isArray\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n                \n                // Join all of the elements together, separated with commas, and\n                // wrap them in brackets.\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n            \n            // If the replacer is an array, use it to select the members to be\n            // stringified.\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            else {\n                // Otherwise, iterate through all of the keys in the object.\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            \n        // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        v = partial.length === 0 ? '{}' : gap ?\n            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n            '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\nmodule.exports = function (value, replacer, space) {\n    var i;\n    gap = '';\n    indent = '';\n    \n    // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n            indent += ' ';\n        }\n    }\n    // If the space parameter is a string, it will be used as the indent string.\n    else if (typeof space === 'string') {\n        indent = space;\n    }\n\n    // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n    rep = replacer;\n    if (replacer && typeof replacer !== 'function'\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n        throw new Error('JSON.stringify');\n    }\n    \n    // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n    return str('', {'': value});\n};\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global global, define, System, Reflect, Promise */\r\nvar __extends;\r\nvar __assign;\r\nvar __rest;\r\nvar __decorate;\r\nvar __param;\r\nvar __metadata;\r\nvar __awaiter;\r\nvar __generator;\r\nvar __exportStar;\r\nvar __values;\r\nvar __read;\r\nvar __spread;\r\nvar __asyncGenerator;\r\nvar __asyncDelegator;\r\nvar __asyncValues;\r\n(function (factory) {\r\n    var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define(\"tslib\", [\"exports\"], function (exports) { factory(createExporter(root, createExporter(exports))); });\r\n    }\r\n    else if (typeof module === \"object\" && typeof module.exports === \"object\") {\r\n        factory(createExporter(root, createExporter(module.exports)));\r\n    }\r\n    else {\r\n        factory(createExporter(root));\r\n    }\r\n    function createExporter(exports, previous) {\r\n        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };\r\n    }\r\n})\r\n(function (exporter) {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\n    __extends = function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n\r\n    __assign = Object.assign || function (t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n\r\n    __rest = function (s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n                t[p[i]] = s[p[i]];\r\n        return t;\r\n    };\r\n\r\n    __decorate = function (decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    };\r\n\r\n    __param = function (paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); }\r\n    };\r\n\r\n    __metadata = function (metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    };\r\n\r\n    __awaiter = function (thisArg, _arguments, P, generator) {\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    };\r\n\r\n    __generator = function (thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [0, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    };\r\n\r\n    __exportStar = function (m, exports) {\r\n        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    };\r\n\r\n    __values = function (o) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n        if (m) return m.call(o);\r\n        return {\r\n            next: function () {\r\n                if (o && i >= o.length) o = void 0;\r\n                return { value: o && o[i++], done: !o };\r\n            }\r\n        };\r\n    };\r\n\r\n    __read = function (o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    };\r\n\r\n    __spread = function () {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    };\r\n\r\n    __asyncGenerator = function (thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), q = [], c, i;\r\n        return i = { next: verb(\"next\"), \"throw\": verb(\"throw\"), \"return\": verb(\"return\") }, i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) { return function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]), next(); }); }; }\r\n        function next() { if (!c && q.length) resume((c = q.shift())[0], c[1]); }\r\n        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(c[3], e); } }\r\n        function step(r) { r.done ? settle(c[2], r) : Promise.resolve(r.value[1]).then(r.value[0] === \"yield\" ? send : fulfill, reject); }\r\n        function send(value) { settle(c[2], { value: value, done: false }); }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) { c = void 0, f(v), next(); }\r\n    };\r\n\r\n    __asyncDelegator = function (o) {\r\n        var i = { next: verb(\"next\"), \"throw\": verb(\"throw\", function (e) { throw e; }), \"return\": verb(\"return\", function (v) { return { value: v, done: true }; }) }, p;\r\n        return o = __asyncValues(o), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { return function (v) { return v = p && n === \"throw\" ? f(v) : p && v.done ? v : { value: p ? [\"yield\", v.value] : [\"await\", (o[n] || f).call(o, v)], done: false }, p = !p, v; }; }\r\n    };\r\n\r\n    __asyncValues = function (o) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator];\r\n        return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n    };\r\n\r\n    exporter(\"__extends\", __extends);\r\n    exporter(\"__assign\", __assign);\r\n    exporter(\"__rest\", __rest);\r\n    exporter(\"__decorate\", __decorate);\r\n    exporter(\"__param\", __param);\r\n    exporter(\"__metadata\", __metadata);\r\n    exporter(\"__awaiter\", __awaiter);\r\n    exporter(\"__generator\", __generator);\r\n    exporter(\"__exportStar\", __exportStar);\r\n    exporter(\"__values\", __values);\r\n    exporter(\"__read\", __read);\r\n    exporter(\"__spread\", __spread);\r\n    exporter(\"__asyncGenerator\", __asyncGenerator);\r\n    exporter(\"__asyncDelegator\", __asyncDelegator);\r\n    exporter(\"__asyncValues\", __asyncValues);\r\n});","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.vega = global.vega || {})));\n}(this, (function (exports) { 'use strict';\n\n/**\n * Parse an event selector string.\n * Returns an array of event stream definitions.\n */\nvar eventSelector = function(selector, source, marks) {\n  DEFAULT_SOURCE = source || VIEW;\n  MARKS = marks || DEFAULT_MARKS;\n  return parseMerge(selector.trim()).map(parseSelector);\n};\n\nvar VIEW    = 'view';\nvar LBRACK  = '[';\nvar RBRACK  = ']';\nvar LBRACE  = '{';\nvar RBRACE  = '}';\nvar COLON   = ':';\nvar COMMA   = ',';\nvar NAME    = '@';\nvar GT      = '>';\nvar ILLEGAL = /[\\[\\]\\{\\}]/;\nvar DEFAULT_SOURCE;\nvar MARKS;\nvar DEFAULT_MARKS = {\n      '*': 1,\n      arc: 1,\n      area: 1,\n      group: 1,\n      image: 1,\n      line: 1,\n      path: 1,\n      rect: 1,\n      rule: 1,\n      shape: 1,\n      symbol: 1,\n      text: 1,\n      trail: 1\n    };\n\nfunction isMarkType(type) {\n  return MARKS.hasOwnProperty(type);\n}\n\nfunction find(s, i, endChar, pushChar, popChar) {\n  var count = 0,\n      n = s.length,\n      c;\n  for (; i<n; ++i) {\n    c = s[i];\n    if (!count && c === endChar) return i;\n    else if (popChar && popChar.indexOf(c) >= 0) --count;\n    else if (pushChar && pushChar.indexOf(c) >= 0) ++count;\n  }\n  return i;\n}\n\nfunction parseMerge(s) {\n  var output = [],\n      start = 0,\n      n = s.length,\n      i = 0;\n\n  while (i < n) {\n    i = find(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);\n    output.push(s.substring(start, i).trim());\n    start = ++i;\n  }\n\n  if (output.length === 0) {\n    throw 'Empty event selector: ' + s;\n  }\n  return output;\n}\n\nfunction parseSelector(s) {\n  return s[0] === '['\n    ? parseBetween(s)\n    : parseStream(s);\n}\n\nfunction parseBetween(s) {\n  var n = s.length,\n      i = 1,\n      b, stream;\n\n  i = find(s, i, RBRACK, LBRACK, RBRACK);\n  if (i === n) {\n    throw 'Empty between selector: ' + s;\n  }\n\n  b = parseMerge(s.substring(1, i));\n  if (b.length !== 2) {\n    throw 'Between selector must have two elements: ' + s;\n  }\n\n  s = s.slice(i + 1).trim();\n  if (s[0] !== GT) {\n    throw 'Expected \\'>\\' after between selector: ' + s;\n  }\n\n  b = b.map(parseSelector);\n\n  stream = parseSelector(s.slice(1).trim());\n  if (stream.between) {\n    return {\n      between: b,\n      stream: stream\n    };\n  } else {\n    stream.between = b;\n  }\n\n  return stream;\n}\n\nfunction parseStream(s) {\n  var stream = {source: DEFAULT_SOURCE},\n      source = [],\n      throttle = [0, 0],\n      markname = 0,\n      start = 0,\n      n = s.length,\n      i = 0, j,\n      filter;\n\n  // extract throttle from end\n  if (s[n-1] === RBRACE) {\n    i = s.lastIndexOf(LBRACE);\n    if (i >= 0) {\n      try {\n        throttle = parseThrottle(s.substring(i+1, n-1));\n      } catch (e) {\n        throw 'Invalid throttle specification: ' + s;\n      }\n      s = s.slice(0, i).trim();\n      n = s.length;\n    } else throw 'Unmatched right brace: ' + s;\n    i = 0;\n  }\n\n  if (!n) throw s;\n\n  // set name flag based on first char\n  if (s[0] === NAME) markname = ++i;\n\n  // extract first part of multi-part stream selector\n  j = find(s, i, COLON);\n  if (j < n) {\n    source.push(s.substring(start, j).trim());\n    start = i = ++j;\n  }\n\n  // extract remaining part of stream selector\n  i = find(s, i, LBRACK);\n  if (i === n) {\n    source.push(s.substring(start, n).trim());\n  } else {\n    source.push(s.substring(start, i).trim());\n    filter = [];\n    start = ++i;\n    if (start === n) throw 'Unmatched left bracket: ' + s;\n  }\n\n  // extract filters\n  while (i < n) {\n    i = find(s, i, RBRACK);\n    if (i === n) throw 'Unmatched left bracket: ' + s;\n    filter.push(s.substring(start, i).trim());\n    if (i < n-1 && s[++i] !== LBRACK) throw 'Expected left bracket: ' + s;\n    start = ++i;\n  }\n\n  // marshall event stream specification\n  if (!(n = source.length) || ILLEGAL.test(source[n-1])) {\n    throw 'Invalid event selector: ' + s;\n  }\n\n  if (n > 1) {\n    stream.type = source[1];\n    if (markname) {\n      stream.markname = source[0].slice(1);\n    } else if (isMarkType(source[0])) {\n      stream.marktype = source[0];\n    } else {\n      stream.source = source[0];\n    }\n  } else {\n    stream.type = source[0];\n  }\n  if (stream.type.slice(-1) === '!') {\n    stream.consume = true;\n    stream.type = stream.type.slice(0, -1);\n  }\n  if (filter != null) stream.filter = filter;\n  if (throttle[0]) stream.throttle = throttle[0];\n  if (throttle[1]) stream.debounce = throttle[1];\n\n  return stream;\n}\n\nfunction parseThrottle(s) {\n  var a = s.split(COMMA);\n  if (!s.length || a.length > 2) throw s;\n  return a.map(function(_) {\n    var x = +_;\n    if (x !== x) throw s;\n    return x;\n  });\n}\n\nexports.selector = eventSelector;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.vega = global.vega || {})));\n}(this, (function (exports) { 'use strict';\n\nvar accessor = function(fn, fields, name) {\n  return (\n    fn.fields = fields || [],\n    fn.fname = name,\n    fn\n  );\n}\n\nfunction accessorName(fn) {\n  return fn == null ? null : fn.fname;\n}\n\nfunction accessorFields(fn) {\n  return fn == null ? null : fn.fields;\n}\n\nvar error = function(message) {\n  throw Error(message);\n}\n\nvar splitAccessPath = function(p) {\n  var path = [],\n      q = null,\n      b = 0,\n      n = p.length,\n      s = '',\n      i, j, c;\n\n  p = p + '';\n\n  function push() {\n    path.push(s + p.substring(i, j));\n    s = '';\n    i = j + 1;\n  }\n\n  for (i=j=0; j<n; ++j) {\n    c = p[j];\n    if (c === '\\\\') s += p.substring(i, j), i = ++j;\n    else if (c === q) push(), q = null, b = -1;\n    else if (q) continue;\n    else if (i === b && c === '\"') i = j + 1, q = c;\n    else if (i === b && c === \"'\") i = j + 1, q = c;\n    else if (c === '.' && !b) (j > i) ? push() : (i = j + 1);\n    else if (c === '[') {\n      if (j > i) push();\n      b = i = j + 1;\n    }\n    else if (c === ']') {\n      if (!b) error('Access path missing open bracket: ' + p);\n      if (b > 0) push();\n      b = 0;\n      i = j + 1;\n    }\n  }\n\n  if (b) error('Access path missing closing bracket: ' + p);\n  if (q) error('Access path missing closing quote: ' + p);\n  if (j > i) ++j, push();\n  return path;\n}\n\nvar isArray = Array.isArray;\n\nvar isObject = function(_) {\n  return _ === Object(_);\n}\n\nvar isString = function(_) {\n  return typeof _ === 'string';\n}\n\nfunction $(x) {\n  return isArray(x) ? '[' + x.map($) + ']'\n    : isObject(x) || isString(x) ?\n      // Output valid JSON and JS source strings.\n      // See http://timelessrepo.com/json-isnt-a-javascript-subset\n      JSON.stringify(x).replace('\\u2028','\\\\u2028').replace('\\u2029', '\\\\u2029')\n    : x;\n}\n\nvar field = function(field, name) {\n  var path = splitAccessPath(field),\n      code = 'return _[' + path.map($).join('][') + '];';\n\n  return accessor(\n    Function('_', code),\n    [(field = path.length===1 ? path[0] : field)],\n    name || field\n  );\n}\n\nvar empty = [];\n\nvar id = field('id');\n\nvar identity = accessor(function(_) { return _; }, empty, 'identity');\n\nvar zero = accessor(function() { return 0; }, empty, 'zero');\n\nvar one = accessor(function() { return 1; }, empty, 'one');\n\nvar truthy = accessor(function() { return true; }, empty, 'true');\n\nvar falsy = accessor(function() { return false; }, empty, 'false');\n\nfunction log(method, level, input) {\n  var args = [level].concat([].slice.call(input));\n  console[method].apply(console, args); // eslint-disable-line no-console\n}\n\nvar None  = 0;\nvar Warn  = 1;\nvar Info  = 2;\nvar Debug = 3;\n\nvar logger = function(_) {\n  var level = _ || None;\n  return {\n    level: function(_) {\n      return arguments.length ? (level = +_, this) : level;\n    },\n    warn: function() {\n      if (level >= Warn) log('warn', 'WARN', arguments);\n      return this;\n    },\n    info: function() {\n      if (level >= Info) log('log', 'INFO', arguments);\n      return this;\n    },\n    debug: function() {\n      if (level >= Debug) log('log', 'DEBUG', arguments);\n      return this;\n    }\n  }\n}\n\nvar array = function(_) {\n  return _ != null ? (isArray(_) ? _ : [_]) : [];\n}\n\nvar compare = function(fields, orders) {\n  var idx = [],\n      cmp = (fields = array(fields)).map(function(f, i) {\n        return f == null ? null\n          : (idx.push(i), splitAccessPath(f).map($).join(']['));\n      }),\n      n = idx.length - 1,\n      ord = array(orders),\n      code = 'var u,v;return ',\n      i, j, f, u, v, d, lt, gt;\n\n  if (n < 0) return null;\n\n  for (j=0; j<=n; ++j) {\n    i = idx[j];\n    f = cmp[i];\n    u = '(u=a['+f+'])';\n    v = '(v=b['+f+'])';\n    d = '((v=v instanceof Date?+v:v),(u=u instanceof Date?+u:u))';\n    lt = ord[i] !== 'descending' ? (gt=1, -1) : (gt=-1, 1);\n    code += '(' + u+'<'+v+'||u==null)&&v!=null?' + lt\n      + ':(u>v||v==null)&&u!=null?' + gt\n      + ':'+d+'!==u&&v===v?' + lt\n      + ':v!==v&&u===u?' + gt\n      + (i < n ? ':' : ':0');\n  }\n\n  return accessor(\n    Function('a', 'b', code + ';'),\n    fields.filter(function(_) { return _ != null; })\n  );\n}\n\nvar isFunction = function(_) {\n  return typeof _ === 'function';\n}\n\nvar constant = function(_) {\n  return isFunction(_) ? _ : function() { return _; };\n}\n\nvar extend = function(_) {\n  for (var x, k, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (k in x) { _[k] = x[k]; }\n  }\n  return _;\n}\n\nvar extentIndex = function(array, f) {\n  var i = -1,\n      n = array.length,\n      a, b, c, u, v;\n\n  if (f == null) {\n    while (++i < n) if ((b = array[i]) != null && b >= b) { a = c = b; break; }\n    u = v = i;\n    while (++i < n) if ((b = array[i]) != null) {\n      if (a > b) a = b, u = i;\n      if (c < b) c = b, v = i;\n    }\n  } else {\n    while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = c = b; break; }\n    u = v = i;\n    while (++i < n) if ((b = f(array[i], i, array)) != null) {\n      if (a > b) a = b, u = i;\n      if (c < b) c = b, v = i;\n    }\n  }\n\n  return [u, v];\n}\n\nvar NULL = {};\n\nvar fastmap = function(input) {\n  var obj = {},\n      map,\n      test;\n\n  function has(key) {\n    return obj.hasOwnProperty(key) && obj[key] !== NULL;\n  }\n\n  map = {\n    size: 0,\n    empty: 0,\n    object: obj,\n    has: has,\n    get: function(key) {\n      return has(key) ? obj[key] : undefined;\n    },\n    set: function(key, value) {\n      if (!has(key)) {\n        ++map.size;\n        if (obj[key] === NULL) --map.empty;\n      }\n      obj[key] = value;\n      return this;\n    },\n    delete: function(key) {\n      if (has(key)) {\n        --map.size;\n        ++map.empty;\n        obj[key] = NULL;\n      }\n      return this;\n    },\n    clear: function() {\n      map.size = map.empty = 0;\n      map.object = obj = {};\n    },\n    test: function(_) {\n      return arguments.length ? (test = _, map) : test;\n    },\n    clean: function() {\n      var next = {},\n          size = 0,\n          key, value;\n      for (key in obj) {\n        value = obj[key];\n        if (value !== NULL && (!test || !test(value))) {\n          next[key] = value;\n          ++size;\n        }\n      }\n      map.size = size;\n      map.empty = 0;\n      map.object = (obj = next);\n    }\n  };\n\n  if (input) Object.keys(input).forEach(function(key) {\n    map.set(key, input[key]);\n  });\n\n  return map;\n}\n\nvar inherits = function(child, parent) {\n  var proto = (child.prototype = Object.create(parent.prototype));\n  proto.constructor = child;\n  return proto;\n}\n\nvar isBoolean = function(_) {\n  return typeof _ === 'boolean';\n}\n\nvar isDate = function(_) {\n  return Object.prototype.toString.call(_) === '[object Date]';\n}\n\nvar isNumber = function(_) {\n  return typeof _ === 'number';\n}\n\nvar isRegExp = function(_) {\n  return Object.prototype.toString.call(_) === '[object RegExp]';\n}\n\nvar key = function(fields) {\n  fields = fields ? array(fields) : fields;\n  var fn = !(fields && fields.length)\n    ? function() { return ''; }\n    : Function('_', 'return \\'\\'+' +\n        fields.map(function(f) {\n          return '_[' + splitAccessPath(f).map($).join('][') + ']';\n        }).join('+\\'|\\'+') + ';');\n  return accessor(fn, fields, 'key');\n}\n\nvar merge = function(compare, array0, array1, output) {\n  var n0 = array0.length,\n      n1 = array1.length;\n\n  if (!n1) return array0;\n  if (!n0) return array1;\n\n  var merged = output || new array0.constructor(n0 + n1),\n      i0 = 0, i1 = 0, i = 0;\n\n  for (; i0<n0 && i1<n1; ++i) {\n    merged[i] = compare(array0[i0], array1[i1]) > 0\n       ? array1[i1++]\n       : array0[i0++];\n  }\n\n  for (; i0<n0; ++i0, ++i) {\n    merged[i] = array0[i0];\n  }\n\n  for (; i1<n1; ++i1, ++i) {\n    merged[i] = array1[i1];\n  }\n\n  return merged;\n}\n\nvar repeat = function(str, reps) {\n  var s = '';\n  while (--reps >= 0) s += str;\n  return s;\n}\n\nvar pad = function(str, length, padchar, align) {\n  var c = padchar || ' ',\n      s = str + '',\n      n = length - s.length;\n\n  return n <= 0 ? s\n    : align === 'left' ? repeat(c, n) + s\n    : align === 'center' ? repeat(c, ~~(n/2)) + s + repeat(c, Math.ceil(n/2))\n    : s + repeat(c, n);\n}\n\nvar peek = function(array) {\n  return array[array.length - 1];\n}\n\nvar toBoolean = function(_) {\n  return _ == null || _ === '' ? null : !_ || _ === 'false' ? false : !!_;\n}\n\nvar toDate = function(_, parser) {\n  return _ == null || _ === '' ? null : (parser ? parser(_) : Date.parse(_));\n}\n\nvar toNumber = function(_) {\n  return _ == null || _ === '' ? null : +_;\n}\n\nvar toString = function(_) {\n  return _ == null || _ === '' ? null : _ + '';\n}\n\nvar toSet = function(_) {\n  for (var s={}, i=0, n=_.length; i<n; ++i) s[_[i]] = 1;\n  return s;\n}\n\nvar truncate = function(str, length, align, ellipsis) {\n  var e = ellipsis != null ? ellipsis : '\\u2026',\n      s = str + '',\n      n = s.length,\n      l = Math.max(0, length - e.length);\n\n  return n <= length ? s\n    : align === 'left' ? e + s.slice(n - l)\n    : align === 'center' ? s.slice(0, Math.ceil(l/2)) + e + s.slice(n - ~~(l/2))\n    : s.slice(0, l) + e;\n}\n\nvar visitArray = function(array, filter, visitor) {\n  if (array) {\n    var i = 0, n = array.length, t;\n    if (filter) {\n      for (; i<n; ++i) {\n        if (t = filter(array[i])) visitor(t, i, array);\n      }\n    } else {\n      array.forEach(visitor);\n    }\n  }\n}\n\nexports.accessor = accessor;\nexports.accessorName = accessorName;\nexports.accessorFields = accessorFields;\nexports.id = id;\nexports.identity = identity;\nexports.zero = zero;\nexports.one = one;\nexports.truthy = truthy;\nexports.falsy = falsy;\nexports.logger = logger;\nexports.None = None;\nexports.Warn = Warn;\nexports.Info = Info;\nexports.Debug = Debug;\nexports.array = array;\nexports.compare = compare;\nexports.constant = constant;\nexports.error = error;\nexports.extend = extend;\nexports.extentIndex = extentIndex;\nexports.fastmap = fastmap;\nexports.field = field;\nexports.inherits = inherits;\nexports.isArray = isArray;\nexports.isBoolean = isBoolean;\nexports.isDate = isDate;\nexports.isFunction = isFunction;\nexports.isNumber = isNumber;\nexports.isObject = isObject;\nexports.isRegExp = isRegExp;\nexports.isString = isString;\nexports.key = key;\nexports.merge = merge;\nexports.pad = pad;\nexports.peek = peek;\nexports.repeat = repeat;\nexports.splitAccessPath = splitAccessPath;\nexports.stringValue = $;\nexports.toBoolean = toBoolean;\nexports.toDate = toDate;\nexports.toNumber = toNumber;\nexports.toString = toString;\nexports.toSet = toSet;\nexports.truncate = truncate;\nexports.visitArray = visitArray;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","module.exports={\n  \"name\": \"vega-lite\",\n  \"author\": \"Jeffrey Heer, Dominik Moritz, Kanit \\\"Ham\\\" Wongsuphasawat\",\n  \"version\": \"2.0.0-alpha.9\",\n  \"collaborators\": [\n    \"Kanit Wongsuphasawat <kanitw@gmail.com> (http://kanitw.yellowpigz.com)\",\n    \"Dominik Moritz <domoritz@cs.washington.edu> (https://www.domoritz.de)\",\n    \"Jeffrey Heer <jheer@uw.edu> (http://jheer.org)\"\n  ],\n  \"homepage\": \"https://vega.github.io/vega-lite/\",\n  \"description\": \"Vega-lite provides a higher-level grammar for visual analysis, comparable to ggplot or Tableau, that generates complete Vega specifications.\",\n  \"main\": \"build/src/vl.js\",\n  \"types\": \"build/src/vl.d.ts\",\n  \"bin\": {\n    \"vl2png\": \"./bin/vl2png\",\n    \"vl2svg\": \"./bin/vl2svg\",\n    \"vl2vg\": \"./bin/vl2vg\"\n  },\n  \"directories\": {\n    \"test\": \"test\"\n  },\n  \"scripts\": {\n    \"tsc\": \"rm -rf build/*/** && tsc\",\n    \"prebuild\": \"mkdir -p build/site build/examples/images build/test-gallery\",\n    \"build\": \"npm run tsc && cp package.json build && browserify src/vl.ts -p tsify -d -s vl | exorcist build/vega-lite.js.map > build/vega-lite.js\",\n    \"postbuild\": \"uglifyjs build/vega-lite.js -cm --in-source-map build/vega-lite.js.map --source-map build/vega-lite.min.js.map > build/vega-lite.min.js && npm run schema\",\n    \"build:examples\": \"./scripts/build-examples.sh\",\n    \"build:images\": \"npm run data && scripts/generate-images.sh\",\n    \"build:toc\": \"bundle exec jekyll build -q && scripts/generate-toc\",\n    \"build:site\": \"npm run link && browserify site/static/main.ts -p [tsify -p site] -d | exorcist build/site/main.js.map > build/site/main.js\",\n    \"build:versions\": \"scripts/update-version.sh\",\n    \"build:test-gallery\": \"browserify test-gallery/main.ts -p [tsify -p test-gallery] -d > build/test-gallery/main.js\",\n    \"check:examples\": \"scripts/check-examples.sh\",\n    \"check:schema\": \"scripts/check-schema.sh\",\n    \"clean\": \"rm -rf build && rm -f vega-lite.* & find -E src test site examples -regex '.*\\\\.(js|js.map|d.ts|vg.json)' -delete & rm -rf data\",\n    \"data\": \"rsync -r node_modules/vega-datasets/data/* data\",\n    \"link\": \"npm link && npm link vega-lite\",\n\n    \"deploy\": \"scripts/deploy.sh\",\n    \"deploy:gh\": \"scripts/deploy-gh.sh\",\n    \"deploy:schema\": \"scripts/deploy-schema.sh\",\n\n    \"prestart\": \"npm run data && npm run build && scripts/index-examples\",\n    \"start\": \"nodemon -x 'npm run build:test-gallery' & browser-sync start --server --files 'build/test-gallery/main.js' --index 'test-gallery/index.html'\",\n    \"poststart\": \"rm examples/all-examples.json\",\n\n    \"preschema\": \"npm run prebuild\",\n    \"schema\": \"typescript-json-schema --required true --noExtraProps true src/spec.ts TopLevelExtendedSpec > build/vega-lite-schema.json && rm -f _data/vega-lite-schema.json && npm run replaceschema && cp build/vega-lite-schema.json _data/\",\n    \"replaceschema\": \"sed -i -e 's/GenericLayerSpec<.*..\\\\./LayerSpec/g' build/vega-lite-schema.json && sed -i -e 's/GenericRepeatSpec<.*..\\\\./RepeatSpec/g' build/vega-lite-schema.json && sed -i -e 's/GenericUnitSpec<.*..\\\\./UnitSpec/g' build/vega-lite-schema.json\",\n    \"presite\": \"npm run build && npm run data && npm run build:site && npm run build:toc && npm run build:versions\",\n    \"site\": \"bundle exec jekyll serve\",\n\n    \"lint\": \"tslint --project tsconfig.json -c tslint.json --type-check\",\n    \"test\": \"npm run tsc && npm run test:only && npm run lint\",\n    \"posttest\": \"npm run schema && npm run data && npm run mocha:examples\",\n    \"test:nocompile\": \"npm run test:only && npm run lint && npm run mocha:examples\",\n    \"test:only\": \"nyc --reporter=html --reporter=text-summary npm run mocha:test\",\n    \"test:debug\": \"npm run pretest && mocha --recursive --debug-brk build/test build/examples\",\n    \"mocha:test\": \"mocha --require source-map-support/register --reporter dot --recursive build/test\",\n    \"mocha:examples\": \"mocha --require source-map-support/register --reporter dot --recursive build/examples\",\n\n    \"codecov\": \"nyc report --reporter=json && codecov -f coverage/*.json\",\n    \"watch:build\": \"watchify src/vl.ts -p tsify -v -d -s vl -o 'exorcist build/vega-lite.js.map > build/vega-lite.js'\",\n    \"watch:test\": \"nodemon -x 'npm test'\",\n    \"watch\": \"nodemon -x 'npm run build && npm run test:nocompile' # already ran schema in build\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/vega/vega-lite.git\"\n  },\n  \"license\": \"BSD-3-Clause\",\n  \"bugs\": {\n    \"url\": \"https://github.com/vega/vega-lite/issues\"\n  },\n  \"devDependencies\": {\n    \"@types/chai\": \"^3.5.1\",\n    \"@types/d3\": \"^4.7.0\",\n    \"@types/highlight.js\": \"^9.1.9\",\n    \"@types/json-stable-stringify\": \"^1.0.31\",\n    \"@types/mocha\": \"^2.2.41\",\n    \"@types/node\": \"^7.0.13\",\n    \"ajv\": \"5.0.1-beta.1\",\n    \"browser-sync\": \"~2.18.8\",\n    \"browserify\": \"~14.3.0\",\n    \"browserify-shim\": \"^3.8.14\",\n    \"chai\": \"~3.5.0\",\n    \"cheerio\": \"~0.22.0\",\n    \"codecov\": \"~2.1.0\",\n    \"d3\": \"^4.8.0\",\n    \"exorcist\": \"~0.4.0\",\n    \"highlight.js\": \"^9.11.0\",\n    \"mocha\": \"~3.2.0\",\n    \"nodemon\": \"~1.11.0\",\n    \"nyc\": \"~10.2.0\",\n    \"source-map-support\": \"~0.4.14\",\n    \"tsify\": \"~3.0.1\",\n    \"tslint\": \"~5.1.0\",\n    \"tslint-eslint-rules\": \"^4.0.0\",\n    \"typescript\": \"^2.2.2\",\n    \"typescript-json-schema\": \"^0.11.0\",\n    \"uglify-js\": \"~2.8.22\",\n    \"vega\": \"3.0.0-beta.29\",\n    \"vega-datasets\": \"vega/vega-datasets#gh-pages\",\n    \"vega-embed\": \"3.0.0-beta.10\",\n    \"watchify\": \"~3.9.0\",\n    \"yaml-front-matter\": \"~3.4.0\"\n  },\n  \"dependencies\": {\n    \"json-stable-stringify\": \"~1.0.1\",\n    \"tslib\": \"^1.6.1\",\n    \"vega-event-selector\": \"^2.0.0-beta\",\n    \"vega-util\": \"~1.2.0\",\n    \"yargs\": \"~7.1.0\"\n  }\n}\n","import {toSet} from './util';\nexport type AggregateOp = 'argmax' | 'argmin' | 'average' | 'count'\n  | 'distinct' | 'max' | 'mean' | 'median' | 'min' | 'missing' | 'modeskew'\n  | 'q1' | 'q3' | 'ci0' | 'ci1' | 'stdev' | 'stdevp' | 'sum' | 'valid' | 'values' | 'variance'\n  | 'variancep';\n\nexport const AGGREGATE_OPS: AggregateOp[] = [\n    'values',\n    'count',\n    'valid',\n    'missing',\n    'distinct',\n    'sum',\n    'mean',\n    'average',\n    'variance',\n    'variancep',\n    'stdev',\n    'stdevp',\n    'median',\n    'q1',\n    'q3',\n    'ci0',\n    'ci1',\n    'modeskew',\n    'min',\n    'max',\n    'argmin',\n    'argmax',\n];\n\nexport const AGGREGATE_OP_INDEX = toSet(AGGREGATE_OPS);\n\n/** Additive-based aggregation operations.  These can be applied to stack. */\nexport const SUM_OPS: AggregateOp[] = [\n    'count',\n    'sum',\n    'distinct',\n    'valid',\n    'missing'\n];\n\n/**\n * Aggregation operators that always produce values within the range [domainMin, domainMax].\n */\nexport const SHARED_DOMAIN_OPS: AggregateOp[] = [\n    'mean',\n    'average',\n    'median',\n    'q1',\n    'q3',\n    'min',\n    'max',\n];\n\nexport const SHARED_DOMAIN_OP_INDEX = toSet(SHARED_DOMAIN_OPS);\n","import {DateTime} from './datetime';\nimport {VgAxisBase, VgAxisConfig, VgAxisEncode} from './vega.schema';\n\nexport type AxisOrient = 'top' | 'right' | 'left' | 'bottom';\n\nexport interface AxisConfig extends VgAxisConfig {\n  /**\n   * Whether month names and weekday names should be abbreviated.\n   *\n   * __Default value:__  `false`\n   */\n  shortTimeLabels?: boolean;\n}\n\nexport interface Axis extends VgAxisBase {\n  /**\n   * The padding, in pixels, between axis and text labels.\n   */\n  labelPadding?: number;\n\n  /**\n   * The formatting pattern for axis labels. This is D3's [number format pattern](https://github.com/mbostock/d3/wiki/Formatting) for quantitative axis and D3's [time format pattern](https://github.com/mbostock/d3/wiki/Time-Formatting) for time axis.\n   *\n   * __Default value:__  derived from [numberFormat](config.html#format) config for quantitative axis and from [timeFormat](config.html#format) config for time axis.\n   */\n  format?: string; // default value determined by config.format anyway\n\n  /**\n   * The orientation of the axis. One of top, bottom, left or right. The orientation can be used to further specialize the axis type (e.g., a y axis oriented for the right edge of the chart).\n   *\n   * __Default value:__ `\"x\"` axis is placed on the bottom, `\"y\"` axis is placed on the left, `\"column\"`\"s x-axis is placed on the top, `\"row\"`s y-axis is placed on the right.\n   */\n  orient?: AxisOrient;\n\n  /**\n   * The offset, in pixels, by which to displace the axis from the edge of the enclosing group or data rectangle.\n   *\n   * __Default value:__ derived from  [axis config](config.html#facet-scale-config)'s `offset` (`0` by default)\n   */\n  offset?: number;\n\n  /**\n   * The anchor position of the axis in pixels. For x-axis with top or bottom orientation, this sets the axis group x coordinate. For y-axis with left or right orientation, this sets the axis group y coordinate.\n   *\n   * __Default value__: `0`\n   */\n  position?: number;\n\n  /**\n   * A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale's range.\n   * @minimum 0\n   * @TJS-type integer\n   */\n  tickCount?: number;\n\n  /**\n   * A title for the axis. Shows field name and its function by default.\n   *\n   * __Default value:__  derived from the field's name and transformation function applied e.g, \"field_name\", \"SUM(field_name)\", \"BIN(field_name)\", \"YEAR(field_name)\".\n   */\n  title?: string;\n\n  /**\n   * Explicitly set the visible axis tick values.\n   */\n  values?: number[] | DateTime[];\n\n  /**\n   * A non-positive integer indicating z-index of the axis.\n   * If zindex is 0, axes should be drawn behind all chart elements.\n   * To put them in front, use `\"zindex = 1\"`.\n   *\n   * __Default value:__ `0` (Behind the marks.)\n   *\n   * @TJS-type integer\n   * @minimum 0\n   */\n  zindex?: number;\n\n  /**\n   * Optional mark definitions for custom axis encoding.\n   */\n  encode?: VgAxisEncode;\n}\n\nexport const AXIS_PROPERTIES:(keyof Axis)[] = [\n  'domain', 'format', 'grid', 'labelPadding', 'labels', 'maxExtent', 'minExtent', 'offset', 'orient', 'position', 'tickCount', 'ticks', 'tickSize', 'title', 'titlePadding', 'values', 'zindex'\n];\n","import {Channel, COLOR, COLUMN, OPACITY, ROW, SHAPE, SIZE} from './channel';\nimport {isBoolean} from './util';\n\nexport interface BaseBin {\n  /**\n   * The number base to use for automatic bin determination (default is base 10).\n   *\n   * __Default value:__ `10`\n   *\n   */\n  base?: number;\n  /**\n   * An exact step size to use between bins.\n   *\n   * __Note:__ If provided, options such as maxbins will be ignored.\n   */\n  step?: number;\n  /**\n   * An array of allowable step sizes to choose from.\n   * @minItems 1\n   */\n  steps?: number[];\n  /**\n   * A minimum allowable step size (particularly useful for integer values).\n   */\n  minstep?: number;\n  /**\n   * Scale factors indicating allowable subdivisions. The default value is [5, 2], which indicates that for base 10 numbers (the default base), the method may consider dividing bin sizes by 5 and/or 2. For example, for an initial step size of 10, the method can check if bin sizes of 2 (= 10/5), 5 (= 10/2), or 1 (= 10/(5*2)) might also satisfy the given constraints.\n   *\n   * __Default value:__ `[5, 2]`\n   *\n   * @minItems 1\n   */\n  divide?: number[];\n  /**\n   * Maximum number of bins.\n   *\n   * __Default value:__ `6` for `row`, `column` and `shape` channels; `10` for other channels\n   *\n   * @minimum 2\n   */\n  maxbins?: number;\n  /**\n   * If true (the default), attempts to make the bin boundaries use human-friendly boundaries, such as multiples of ten.\n   */\n  nice?: boolean;\n}\n\n/**\n * Binning properties or boolean flag for determining whether to bin data or not.\n */\nexport interface Bin extends BaseBin {\n  /**\n   * A two-element (`[min, max]`) array indicating the range of desired bin values.\n   * @minItems 2\n   * @maxItems 2\n   */\n  extent?: number[];  // VgBinTransform uses a different extent so we need to pull this out.\n}\n\nexport function binToString(bin: Bin | boolean) {\n  if (isBoolean(bin)) {\n    return 'bin';\n  }\n  return 'bin' + Object.keys(bin).map(p => `_${p}_${bin[p]}`).join('');\n}\n\nexport function autoMaxBins(channel: Channel): number {\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n    case SIZE:\n    case COLOR:\n    case OPACITY:\n      // Facets and Size shouldn't have too many bins\n      // We choose 6 like shape to simplify the rule\n    case SHAPE:\n      return 6; // Vega's \"shape\" has 6 distinct values\n    default:\n      return 10;\n  }\n}\n","/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\n\nimport {RangeType} from './compile/scale/type';\nimport {Encoding} from './encoding';\nimport {Facet} from './facet';\nimport {Mark} from './mark';\nimport {SCALE_TYPES, ScaleType} from './scale';\nimport {contains, toSet, without} from './util';\n\nexport namespace Channel {\n  // Facet\n  export const ROW: 'row' = 'row';\n  export const COLUMN: 'column' = 'column';\n\n  // Position\n  export const X: 'x' = 'x';\n  export const Y: 'y' = 'y';\n  export const X2: 'x2' = 'x2';\n  export const Y2: 'y2' = 'y2';\n\n  // Mark property with scale\n  export const COLOR: 'color' = 'color';\n  export const SHAPE: 'shape' = 'shape';\n  export const SIZE: 'size' = 'size';\n  export const OPACITY: 'opacity' = 'opacity';\n\n  // Non-scale channel\n  export const TEXT: 'text' = 'text';\n  export const ORDER: 'order' = 'order';\n  export const DETAIL: 'detail' = 'detail';\n}\n\nexport type Channel = keyof Encoding<any> | keyof Facet<any>;\n\nexport const X = Channel.X;\nexport const Y = Channel.Y;\nexport const X2 = Channel.X2;\nexport const Y2 = Channel.Y2;\nexport const ROW = Channel.ROW;\nexport const COLUMN = Channel.COLUMN;\nexport const SHAPE = Channel.SHAPE;\nexport const SIZE = Channel.SIZE;\nexport const COLOR = Channel.COLOR;\nexport const TEXT = Channel.TEXT;\nexport const DETAIL = Channel.DETAIL;\nexport const ORDER = Channel.ORDER;\nexport const OPACITY = Channel.OPACITY;\n\n\nexport const CHANNELS = [X, Y, X2, Y2, ROW, COLUMN, SIZE, SHAPE, COLOR, ORDER, OPACITY, TEXT, DETAIL];\nconst CHANNEL_INDEX = toSet(CHANNELS);\n\nexport function isChannel(str: string): str is Channel {\n  return !!CHANNEL_INDEX[str];\n}\n\n// CHANNELS without COLUMN, ROW\nexport const UNIT_CHANNELS = [X, Y, X2, Y2, SIZE, SHAPE, COLOR, ORDER, OPACITY, TEXT, DETAIL];\n\n// UNIT_CHANNELS without X2, Y2, ORDER, DETAIL, TEXT\nexport const UNIT_SCALE_CHANNELS = [X, Y, SIZE, SHAPE, COLOR, OPACITY];\n\n// UNIT_SCALE_CHANNELS with ROW, COLUMN\nexport const SCALE_CHANNELS = [X, Y, SIZE, SHAPE, COLOR, OPACITY, ROW, COLUMN];\n\n// UNIT_CHANNELS without X, Y, X2, Y2;\nexport const NONSPATIAL_CHANNELS = [SIZE, SHAPE, COLOR, ORDER, OPACITY, TEXT, DETAIL];\n\n// UNIT_SCALE_CHANNELS without X, Y;\nexport const NONSPATIAL_SCALE_CHANNELS = [SIZE, SHAPE, COLOR, OPACITY];\n\nexport const LEVEL_OF_DETAIL_CHANNELS = without(NONSPATIAL_CHANNELS, ['order'] as Channel[]);\n\n/** Channels that can serve as groupings for stacked charts. */\nexport const STACK_GROUP_CHANNELS = [COLOR, DETAIL, ORDER, OPACITY, SIZE];\n\nexport interface SupportedMark {\n  point?: boolean;\n  tick?: boolean;\n  rule?: boolean;\n  circle?: boolean;\n  square?: boolean;\n  bar?: boolean;\n  rect?: boolean;\n  line?: boolean;\n  area?: boolean;\n  text?: boolean;\n}\n\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\nexport function supportMark(channel: Channel, mark: Mark) {\n  return mark in getSupportedMark(channel);\n}\n\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to boolean values.\n */\nexport function getSupportedMark(channel: Channel): SupportedMark {\n  switch (channel) {\n    case X:\n    case Y:\n    case COLOR:\n    case DETAIL:\n    case ORDER:    // TODO: revise (order might not support rect, which is not stackable?)\n    case OPACITY:\n    case ROW:\n    case COLUMN:\n      return { // all marks\n        point: true, tick: true, rule: true, circle: true, square: true,\n        bar: true, rect: true, line: true, area: true, text: true\n      };\n    case X2:\n    case Y2:\n      return {\n        rule: true, bar: true, rect: true, area: true\n      };\n    case SIZE:\n      return {\n        point: true, tick: true, rule: true, circle: true, square: true,\n        bar: true, text: true, line: true\n      };\n    case SHAPE:\n      return {point: true};\n    case TEXT:\n      return {text: true};\n  }\n  return {};\n}\n\nexport function hasScale(channel: Channel) {\n  return !contains([DETAIL, TEXT, ORDER], channel);\n}\n\n// Position does not work with ordinal (lookup) scale and sequential (which is only for color)\nconst POSITION_SCALE_TYPE_INDEX = toSet(without(SCALE_TYPES, ['ordinal', 'sequential'] as ScaleType[]));\n\nexport function supportScaleType(channel: Channel, scaleType: ScaleType): boolean {\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n      return scaleType === 'band'; // row / column currently supports band only\n    case X:\n    case Y:\n    case SIZE: // TODO: size and opacity can support ordinal with more modification\n    case OPACITY:\n      // Although it generally doesn't make sense to use band with size and opacity,\n      // it can also work since we use band: 0.5 to get midpoint.\n      return scaleType in POSITION_SCALE_TYPE_INDEX;\n    case COLOR:\n      return scaleType !== 'band';    // band does not make sense with color\n    case SHAPE:\n      return scaleType === 'ordinal'; // shape = lookup only\n  }\n  /* istanbul ignore next: it should never reach here */\n  return false;\n}\n\nexport function rangeType(channel: Channel): RangeType {\n  switch (channel) {\n    case X:\n    case Y:\n    case SIZE:\n    case OPACITY:\n      return 'continuous';\n\n    case ROW:\n    case COLUMN:\n    case SHAPE:\n      return 'discrete';\n\n    // Color can be either continuous or discrete, depending on scale type.\n    case COLOR:\n      return 'flexible';\n\n    // No scale, no range type.\n    case X2:\n    case Y2:\n    case DETAIL:\n    case TEXT:\n    case ORDER:\n      return undefined;\n  }\n  /* istanbul ignore next: should never reach here. */\n  throw new Error('getSupportedRole not implemented for ' + channel);\n}\n","import {Channel, X} from '../../channel';\nimport {NOMINAL, ORDINAL, TEMPORAL} from '../../type';\nimport {contains, extend, keys} from '../../util';\nimport {VgAxis} from '../../vega.schema';\n\nimport {timeFormatExpression} from '../common';\nimport {UnitModel} from '../unit';\n\nexport function labels(model: UnitModel, channel: Channel, labelsSpec: any, def: VgAxis) {\n  const fieldDef = model.fieldDef(channel);\n  const axis = model.axis(channel);\n  const config = model.config;\n\n  // Text\n  if (fieldDef.type === TEMPORAL) {\n    labelsSpec = extend({\n      text: {\n        signal: timeFormatExpression('datum.value', fieldDef.timeUnit, axis.format, config.axis.shortTimeLabels, config.timeFormat)\n      }\n    }, labelsSpec);\n  }\n\n  // Label Angle\n  if (axis.labelAngle !== undefined) {\n    labelsSpec.angle = {value: axis.labelAngle};\n  } else {\n    // auto rotate for X\n    if (channel === X && (contains([NOMINAL, ORDINAL], fieldDef.type) || !!fieldDef.bin || fieldDef.type === TEMPORAL)) {\n      labelsSpec.angle = {value: 270};\n    }\n  }\n\n  // Auto set align if rotated\n  // TODO: consider other value besides 270, 90\n  if (labelsSpec.angle) {\n    if (labelsSpec.angle.value === 270) {\n      labelsSpec.align = {\n        value: def.orient === 'top' ? 'left':\n                (channel === X) ? 'right' :\n                'center'\n      };\n    } else if (labelsSpec.angle.value === 90) {\n      labelsSpec.align = {value: 'center'};\n    }\n  }\n\n  if (labelsSpec.angle) {\n    // Auto set baseline if rotated\n    // TODO: consider other value besides 270, 90\n    if (labelsSpec.angle.value === 270) {\n      labelsSpec.baseline = {value: (channel === X) ? 'middle' : 'bottom'};\n    } else if (labelsSpec.angle.value === 90) {\n      labelsSpec.baseline = {value: 'bottom'};\n    }\n  }\n\n  return keys(labelsSpec).length === 0 ? undefined : labelsSpec;\n}\n","import {Axis, AXIS_PROPERTIES} from '../../axis';\nimport {Channel} from '../../channel';\nimport {VgAxis} from '../../vega.schema';\n\nimport * as encode from './encode';\nimport * as rules from './rules';\n\nimport {Dict, keys, some} from '../../util';\nimport {UnitModel} from '../unit';\nimport {AxesComponent, AxisComponent} from './index';\n\ntype AxisPart = 'domain' | 'grid' | 'labels' | 'ticks' | 'title';\nconst AXIS_PARTS: AxisPart[] = ['domain', 'grid', 'labels', 'ticks', 'title'];\n\nexport function parseAxisComponent(model: UnitModel, axisChannels: Channel[]): AxesComponent {\n  return axisChannels.reduce(function(axis, channel) {\n    const axisComponent: AxisComponent = {axes:[], gridAxes: []};\n    if (model.axis(channel)) {\n      // TODO: support multiple axis\n      const main = parseMainAxis(channel, model);\n      if (main && isVisibleAxis(main)) {\n        axisComponent.axes.push(main);\n      }\n\n      const grid = parseGridAxis(channel, model);\n      if (grid && isVisibleAxis(grid)) {\n        axisComponent.gridAxes.push(grid);\n      }\n\n      axis[channel] = axisComponent;\n    }\n    return axis;\n  }, {});\n}\n\nfunction isFalseOrNull(v: boolean | null) {\n  return v === false || v === null;\n}\n\n/**\n * Return if an axis is visible (shows at least one part of the axis).\n */\nfunction isVisibleAxis(axis: VgAxis) {\n  return some(AXIS_PARTS, (part) => hasAxisPart(axis, part));\n}\n\nfunction hasAxisPart(axis: VgAxis, part: AxisPart) {\n  // FIXME this method can be wrong if users use a Vega theme.\n  // (Not sure how to correctly handle that yet.).\n\n  if (part === 'grid' || part === 'title') {\n    return !!axis[part];\n  }\n  // Other parts are enabled by default, so they should not be false or null.\n  return !isFalseOrNull(axis[part]);\n}\n\n/**\n * Make an inner axis for showing grid for shared axis.\n */\nexport function parseGridAxis(channel: Channel, model: UnitModel): VgAxis {\n  // FIXME: support adding ticks for grid axis that are inner axes of faceted plots.\n  return parseAxis(channel, model, true);\n}\n\nexport function parseMainAxis(channel: Channel, model: UnitModel) {\n  return parseAxis(channel, model, false);\n}\n\nfunction parseAxis(channel: Channel, model: UnitModel, isGridAxis: boolean): VgAxis {\n  const axis = model.axis(channel);\n\n  const vgAxis: VgAxis = {\n    scale: model.scaleName(channel)\n  };\n\n  // 1.2. Add properties\n  AXIS_PROPERTIES.forEach(function(property) {\n    const value = getSpecifiedOrDefaultValue(property, axis, channel, model, isGridAxis);\n    if (value !== undefined) {\n      vgAxis[property] = value;\n    }\n  });\n\n  // Special case for gridScale since gridScale is not a Vega-Lite Axis property.\n  const gridScale = getSpecifiedOrDefaultValue('gridScale', axis, channel, model, isGridAxis);\n  if (gridScale !== undefined) {\n      vgAxis.gridScale = gridScale;\n  }\n\n  // 2) Add guide encode definition groups\n\n  const encodeSpec = axis.encode || {};\n  AXIS_PARTS.forEach(function(part) {\n    if (!hasAxisPart(vgAxis, part)) {\n      // No need to create encode for a disabled part.\n      return;\n    }\n    // TODO(@yuhanlu): instead of calling encode[part], break this line based on part type\n    // as different require different parameters.\n    let value;\n    if (part === 'labels') {\n        value = encode.labels(model, channel, encodeSpec.labels || {}, vgAxis);\n    } else {\n        value = encodeSpec[part] || {};\n    }\n\n    if (value !== undefined && keys(value).length > 0) {\n      vgAxis.encode = vgAxis.encode || {};\n      vgAxis.encode[part] = {update: value};\n    }\n  });\n\n  return vgAxis;\n}\n\nfunction getSpecifiedOrDefaultValue(property: keyof VgAxis, specifiedAxis: Axis, channel: Channel, model: UnitModel, isGridAxis: boolean) {\n  const fieldDef = model.fieldDef(channel);\n\n  switch (property) {\n    case 'labels':\n      return isGridAxis ? false : specifiedAxis[property];\n    case 'domain':\n      return rules.domain(property, specifiedAxis, isGridAxis, channel);\n    case 'ticks':\n      return rules.ticks(property, specifiedAxis, isGridAxis, channel);\n    case 'format':\n      return rules.format(specifiedAxis, channel, fieldDef, model.config);\n    case 'grid':\n      return rules.grid(model, channel, isGridAxis); // FIXME: refactor this\n    case 'gridScale':\n      return rules.gridScale(model, channel, isGridAxis);\n    case 'orient':\n      return rules.orient(specifiedAxis, channel);\n    case 'tickCount':\n      return rules.tickCount(specifiedAxis, channel, fieldDef); // TODO: scaleType\n    case 'title':\n      return rules.title(specifiedAxis, fieldDef, model.config, isGridAxis);\n    case 'values':\n      return rules.values(specifiedAxis);\n    case 'zindex':\n      return rules.zindex(specifiedAxis, isGridAxis);\n  }\n  // Otherwise, return specified property.\n  return specifiedAxis[property];\n}\n","import * as log from '../../log';\n\nimport {Axis} from '../../axis';\nimport {Channel, COLUMN, ROW, X, Y} from '../../channel';\nimport {Config} from '../../config';\nimport {DateTime, isDateTime, timestamp} from '../../datetime';\nimport {FieldDef, title as fieldDefTitle} from '../../fielddef';\nimport {truncate} from '../../util';\nimport {VgAxis} from '../../vega.schema';\n\nimport {numberFormat} from '../common';\nimport {UnitModel} from '../unit';\n\nexport function format(specifiedAxis: Axis, channel: Channel, fieldDef: FieldDef<string>, config: Config) {\n  return numberFormat(fieldDef, specifiedAxis.format, config, channel);\n}\n\n// TODO: we need to refactor this method after we take care of config refactoring\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\nexport function gridShow(model: UnitModel, channel: Channel) {\n  const grid = model.axis(channel).grid;\n  if (grid !== undefined) {\n    return grid;\n  }\n\n  return !model.hasDiscreteDomain(channel) && !model.fieldDef(channel).bin;\n}\n\nexport function grid(model: UnitModel, channel: Channel, isGridAxis: boolean) {\n  if (channel === ROW || channel === COLUMN) {\n    // never apply grid for ROW and COLUMN since we manually create rule-group for them\n    return false;\n  }\n\n  if (!isGridAxis) {\n    return undefined;\n  }\n\n  return gridShow(model, channel);\n}\n\nexport function gridScale(model: UnitModel, channel: Channel, isGridAxis: boolean) {\n  if (isGridAxis) {\n    const gridChannel: Channel = channel === 'x' ? 'y' : 'x';\n    if (model.scale(gridChannel)) {\n      return model.scaleName(gridChannel);\n    }\n  }\n  return undefined;\n}\n\nexport function orient(specifiedAxis: Axis, channel: Channel) {\n  const orient = specifiedAxis.orient;\n  if (orient) {\n    return orient;\n  }\n\n  switch (channel) {\n    case COLUMN:\n      // FIXME test and decide\n      return 'top';\n    case X:\n      return 'bottom';\n    case ROW:\n    case Y:\n      return 'left';\n  }\n  /* istanbul ignore next: This should never happen. */\n  throw new Error(log.message.INVALID_CHANNEL_FOR_AXIS);\n}\n\nexport function tickCount(specifiedAxis: Axis, channel: Channel, fieldDef: FieldDef<string>) {\n  const count = specifiedAxis.tickCount;\n  if (count !== undefined) {\n    return count;\n  }\n\n  // FIXME depends on scale type too\n  if (channel === X && !fieldDef.bin) {\n    // Vega's default tickCount often lead to a lot of label occlusion on X without 90 degree rotation\n    return 5;\n  }\n\n  return undefined;\n}\n\nexport function title(specifiedAxis: Axis, fieldDef: FieldDef<string>, config: Config, isGridAxis: boolean) {\n  if (isGridAxis) {\n    return undefined;\n  }\n\n  if (specifiedAxis.title === '') {\n    return undefined;\n  }\n\n  if (specifiedAxis.title !== undefined) {\n    return specifiedAxis.title;\n  }\n\n  // if not defined, automatically determine axis title from field def\n  const fieldTitle = fieldDefTitle(fieldDef, config);\n\n  const maxLength: number = specifiedAxis.titleMaxLength;\n  return maxLength ? truncate(fieldTitle, maxLength) : fieldTitle;\n}\n\nexport function values(specifiedAxis: Axis) {\n  const vals = specifiedAxis.values;\n  if (specifiedAxis.values && isDateTime(vals[0])) {\n    return (vals as DateTime[]).map((dt) => {\n      // normalize = true as end user won't put 0 = January\n      return timestamp(dt, true);\n    });\n  }\n  return vals;\n}\n\nexport function zindex(specifiedAxis: Axis, isGridAxis: boolean) {\n  const z = specifiedAxis.zindex;\n  if (z !== undefined) {\n    return z;\n  }\n  if (isGridAxis) {\n    // if grid is true, need to put layer on the back so that grid is behind marks\n    return 0;\n  }\n  return 1; // otherwise return undefined and use Vega's default.\n}\n\nexport function domainAndTicks(property: keyof VgAxis, specifiedAxis: Axis, isGridAxis: boolean, channel: Channel) {\n  if (isGridAxis || channel === ROW || channel === COLUMN) {\n    return false;\n  }\n  return specifiedAxis[property];\n}\n\nexport const domain = domainAndTicks;\nexport const ticks = domainAndTicks;\n","import * as log from '../log';\n\nimport {Channel, TEXT} from '../channel';\nimport {CellConfig, Config} from '../config';\nimport {field, FieldDef, OrderFieldDef} from '../fielddef';\nimport {Mark, MarkConfig, TextConfig} from '../mark';\nimport {isConcatSpec, isFacetSpec, isLayerSpec, isRepeatSpec, isUnitSpec, Spec} from '../spec';\nimport {TimeUnit} from '../timeunit';\nimport {formatExpression} from '../timeunit';\nimport {QUANTITATIVE} from '../type';\nimport {isArray} from '../util';\nimport {VgEncodeEntry, VgSort} from '../vega.schema';\nimport {ConcatModel} from './concat';\nimport {FacetModel} from './facet';\nimport {LayerModel} from './layer';\nimport {Model} from './model';\nimport {RepeaterValue, RepeatModel} from './repeat';\nimport {UnitModel} from './unit';\n\n\nexport function buildModel(spec: Spec, parent: Model, parentGivenName: string, repeater: RepeaterValue, config: Config): Model {\n  if (isFacetSpec(spec)) {\n    return new FacetModel(spec, parent, parentGivenName, repeater, config);\n  }\n\n  if (isLayerSpec(spec)) {\n    return new LayerModel(spec, parent, parentGivenName, repeater, config);\n  }\n\n  if (isUnitSpec(spec)) {\n    return new UnitModel(spec, parent, parentGivenName, repeater, config);\n  }\n\n  if (isRepeatSpec(spec)) {\n    return new RepeatModel(spec, parent, parentGivenName, repeater, config);\n  }\n\n  if (isConcatSpec(spec)) {\n    return new ConcatModel(spec, parent, parentGivenName, repeater, config);\n  }\n\n  throw new Error(log.message.INVALID_SPEC);\n}\n\nexport function applyConfig(e: VgEncodeEntry,\n    config: CellConfig | MarkConfig | TextConfig, // TODO(#1842): consolidate MarkConfig | TextConfig?\n    propsList: string[]) {\n  propsList.forEach((property) => {\n    const value = config[property];\n    if (value !== undefined) {\n      e[property] = {value: value};\n    }\n  });\n  return e;\n}\n\nexport function applyMarkConfig(e: VgEncodeEntry, model: UnitModel, propsList: (keyof MarkConfig)[]) {\n  propsList.forEach((property) => {\n    const value = getMarkConfig(property, model.mark(), model.config);\n    if (value !== undefined) {\n      e[property] = {value: value};\n    }\n  });\n  return e;\n}\n\n/**\n * Return value mark specific config property if exists.\n * Otherwise, return general mark specific config.\n */\nexport function getMarkConfig<P extends keyof MarkConfig>(prop: P, mark: Mark, config: Config): MarkConfig[P] {\n  const markSpecificConfig = config[mark];\n  if (markSpecificConfig[prop] !== undefined) {\n    return markSpecificConfig[prop];\n  }\n  return config.mark[prop];\n}\n\nexport function formatSignalRef(fieldDef: FieldDef<string>, expr: 'datum' | 'parent', config: Config, useBinRange?: boolean) {\n  if (fieldDef.type === 'quantitative') {\n    const format = numberFormat(fieldDef, fieldDef.format, config, 'text');\n    if (fieldDef.bin) {\n      if (useBinRange) {\n        // For bin range, no need to apply format as the formula that creates range already include format\n        return {signal: field(fieldDef, {expr, binSuffix: 'range'})};\n      } else {\n        return {\n          signal: `format(${field(fieldDef, {expr, binSuffix: 'start'})}, '${format}')` + `+'-'+` +\n            `format(${field(fieldDef, {expr, binSuffix: 'end'})}, '${format}')`\n        };\n      }\n    } else {\n      return {\n        signal: `format(${field(fieldDef, {expr})}, '${format}')`\n      };\n    }\n  } else if (fieldDef.type === 'temporal') {\n    return {\n      signal: timeFormatExpression(field(fieldDef, {expr}), fieldDef.timeUnit, fieldDef.format, config.text.shortTimeLabels, config.timeFormat)\n    };\n  } else {\n    return {signal: field(fieldDef, {expr})};\n  }\n}\n\n/**\n * Returns number format for a fieldDef\n *\n * @param format explicitly specified format\n */\nexport function numberFormat(fieldDef: FieldDef<string>, specifiedFormat: string, config: Config, channel: Channel) {\n  // Specified format in axis/legend has higher precedence than fieldDef.format\n  const format = specifiedFormat || fieldDef.format;\n  if (fieldDef.type === QUANTITATIVE) {\n    // add number format for quantitative type only\n\n    if (format) {\n      return format;\n    } else if (fieldDef.aggregate === 'count' && channel === TEXT) {\n      // FIXME: need a more holistic way to deal with this.\n      return 'd';\n    }\n    // TODO: need to make this work correctly for numeric ordinal / nominal type\n    return config.numberFormat;\n  }\n  return undefined;\n}\n\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\nexport function timeFormatExpression(field: string, timeUnit: TimeUnit, format: string, shortTimeLabels: boolean, timeFormatConfig: string): string {\n  if (!timeUnit || format) {\n    // If there is not time unit, or if user explicitly specify format for axis/legend/text.\n    const _format = format || timeFormatConfig; // only use config.timeFormat if there is no timeUnit.\n    return `timeFormat(${field}, '${_format}')`;\n  } else {\n    return formatExpression(timeUnit, field, shortTimeLabels);\n  }\n}\n\n/**\n * Return Vega sort parameters (tuple of field and order).\n */\nexport function sortParams(orderDef: OrderFieldDef<string> | OrderFieldDef<string>[]): VgSort {\n  return (isArray(orderDef) ? orderDef : [orderDef]).reduce((s, orderChannelDef) => {\n    s.field.push(field(orderChannelDef, {binSuffix: 'start'}));\n    s.order.push(orderChannelDef.sort || 'ascending');\n    return s;\n  }, {field:[], order: []});\n}\n","/**\n * Module for compiling Vega-lite spec into Vega spec.\n */\nimport {Config, initConfig} from '../config';\nimport * as log from '../log';\nimport {normalize, TopLevel, TopLevelExtendedSpec} from '../spec';\nimport {extractTopLevelProperties, TopLevelProperties} from '../toplevelprops';\nimport {extend, keys} from '../util';\nimport {buildModel} from './common';\nimport {Model} from './model';\n\nexport function compile(inputSpec: TopLevelExtendedSpec, logger?: log.LoggerInterface) {\n  if (logger) {\n    // set the singleton logger to the provided logger\n    log.set(logger);\n  }\n\n  try {\n    // 1. initialize config\n    const config = initConfig(inputSpec.config);\n\n    // 2. Convert input spec into a normal form\n    // (Decompose all extended unit specs into composition of unit spec.)\n    const spec = normalize(inputSpec, config);\n\n    // 3. Instantiate the model with default config\n    const model = buildModel(spec, null, '', null, config);\n\n    // 4. Parse each part of the model to produce components that will be assembled later\n    // We traverse the whole tree to parse once for each type of components\n    // (e.g., data, layout, mark, scale).\n    // Please see inside model.parse() for order for compilation.\n    model.parse();\n\n    // 5. Assemble a Vega Spec from the parsed components in 3.\n    return assemble(model, getTopLevelProperties(inputSpec, config));\n  } finally {\n    // Reset the singleton logger if a logger is provided\n    if (logger) {\n      log.reset();\n    }\n  }\n}\n\n\nfunction getTopLevelProperties(topLevelSpec: TopLevel<any>, config: Config) {\n  return {\n    ...extractTopLevelProperties(config),\n    ...extractTopLevelProperties(topLevelSpec),\n  };\n}\n\nfunction assemble(model: Model, topLevelProperties: TopLevelProperties) {\n  // TODO: change type to become VgSpec\n\n  const output = {\n    $schema: 'http://vega.github.io/schema/vega/v3.0.json',\n    ...(model.description ? {description: model.description} : {}),\n    autosize: 'pad', // By using Vega layout, we don't support custom autosize\n    ...topLevelProperties,\n    data: [].concat(\n      model.assembleData(),\n      model.assembleSelectionData([])\n    ),\n    signals: (\n      [].concat(\n        // TODO(https://github.com/vega/vega-lite/issues/2198):\n        // Merge the top-level's width/height signal with the top-level model\n        // so we can remove this special casing based on model.name\n        (\n          model.name ? [\n            // If model has name, its calculated width and height will not be named width and height, need to map it to the global width and height signals.\n            {name: 'width', update: model.getName('width')},\n            {name: 'height', update: model.getName('height')}\n          ] : []\n        ),\n        model.assembleLayoutSignals(),\n        model.assembleSelectionTopLevelSignals([])\n      )\n    ),\n\n    // FIXME: get rid of the top-level `nested-main-group`\n    // HACK: this is a hack to temporarily make selections works as\n    // 1) Currently, some selection's signals rely on the main group's scope to shadow duplicate names.\n    // 2) Selection predicate depends on parent reference which may not exist for top-level mark.\n    ...assembleNestedMainGroup(model)\n  };\n\n  return {\n    spec: output\n    // TODO: add warning / errors here\n  };\n}\n\nexport function assembleNestedMainGroup(model: Model) {\n  const {layout, signals, ...group} =  model.assembleGroup([]);\n  const marks = group.marks;\n\n  const hasLayout = !!model.assembleLayout();\n  const parentEncodeEntry = {\n    ...(!hasLayout ? {\n      width: {signal: 'width'},\n      height: {signal: 'height'},\n    } : {}),\n    ...model.assembleParentGroupProperties()\n  };\n\n\n  return {\n    ...group,\n    marks: [{\n      name: model.getName('nested_main_group'),\n      type: 'group',\n      layout,\n      signals,\n      ...(keys(parentEncodeEntry).length > 0 ? {\n        encode: {\n          update: parentEncodeEntry\n        }\n      } : {}),\n      marks\n    }],\n  };\n}\n","import {CellConfig, Config} from '../config';\nimport {Repeat} from '../repeat';\nimport {ConcatSpec, RepeatSpec} from '../spec';\nimport {Dict, keys, vals} from '../util';\nimport {VgData, VgLayout, VgScale, VgSignal} from '../vega.schema';\nimport {buildModel} from './common';\nimport {assembleData} from './data/assemble';\nimport {parseData} from './data/parse';\nimport {Model} from './model';\nimport {RepeaterValue} from './repeat';\n\n\nexport class ConcatModel extends Model {\n\n  public readonly children: Model[];\n\n  constructor(spec: ConcatSpec, parent: Model, parentGivenName: string, repeater: RepeaterValue, config: Config) {\n    super(spec, parent, parentGivenName, config);\n\n    this.children = spec.vconcat.map((child, i) => {\n      return buildModel(child, this, this.getName('concat_' + i), repeater, config);\n    });\n  }\n\n  public parseData() {\n    this.component.data = parseData(this);\n    this.children.forEach((child) => {\n      child.parseData();\n    });\n  }\n\n  public parseSelection() {\n    // Merge selections up the hierarchy so that they may be referenced\n    // across unit specs. Persist their definitions within each child\n    // to assemble signals which remain within output Vega unit groups.\n    this.component.selection = {};\n    for (const child of this.children) {\n      child.parseSelection();\n      keys(child.component.selection).forEach((key) => {\n        this.component.selection[key] = child.component.selection[key];\n      });\n    }\n  }\n\n  public parseScale() {\n    const model = this;\n\n    const scaleComponent: Dict<VgScale> = this.component.scales = {};\n\n    this.children.forEach(function(child) {\n      child.parseScale();\n    });\n  }\n\n  public parseMark() {\n    for (const child of this.children) {\n      child.parseMark();\n    }\n  }\n\n  public parseAxisAndHeader() {\n    for (const child of this.children) {\n      child.parseAxisAndHeader();\n    }\n  }\n\n  public parseAxisGroup(): void {\n    return null;\n  }\n\n  public parseLegend() {\n    const legendComponent = this.component.legends = {};\n\n    for (const child of this.children) {\n      child.parseLegend();\n    }\n  }\n\n  public assembleData(): VgData[] {\n     if (!this.parent) {\n      // only assemble data in the root\n      return assembleData(vals(this.component.data.sources));\n    }\n\n    return [];\n  }\n\n  public assembleParentGroupProperties(): any {\n    return null;\n  }\n\n  public assembleSelectionTopLevelSignals(signals: any[]): VgSignal[] {\n    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);\n  }\n\n  public assembleSelectionSignals(): VgSignal[] {\n    this.children.forEach((child) => child.assembleSelectionSignals());\n    return [];\n  }\n\n  public assembleLayoutSignals(): VgSignal[] {\n    return this.children.reduce((signals, child) => {\n      return signals.concat(child.assembleLayoutSignals());\n    }, []);\n  }\n  public assembleSelectionData(data: VgData[]): VgData[] {\n    return this.children.reduce((db, child) => child.assembleSelectionData(db), []);\n  }\n\n  public assembleScales(): VgScale[] {\n    // combine with scales from children\n    return this.children.reduce((scales, c) => {\n      return scales.concat(c.assembleScales());\n    }, super.assembleScales());\n  }\n\n  public assembleLayout(): VgLayout {\n    // TODO: allow customization\n    return {\n      padding: {row: 10, column: 10},\n      offset: 10,\n      columns: 1,\n      bounds: 'full',\n      align: 'all'\n    };\n  }\n\n  public assembleMarks(): any[] {\n    // only children have marks\n    return this.children.map(child => ({\n      type: 'group',\n      name: child.getName('group'),\n      encode: {\n        update: {\n          width: child.getSizeSignalRef('width'),\n          height: child.getSizeSignalRef('height'),\n          ...child.assembleParentGroupProperties()\n        }\n      },\n      ...child.assembleGroup()\n    }));\n  }\n}\n","import {isAggregate} from '../../encoding';\nimport {field, FieldDef} from '../../fielddef';\nimport * as log from '../../log';\nimport {ORDINAL} from '../../type';\nimport {Dict, differ, duplicate, extend, keys, StringSet} from '../../util';\nimport {VgAggregateTransform} from '../../vega.schema';\nimport {UnitModel} from './../unit';\n\nimport {DataFlowNode} from './dataflow';\n\nfunction addDimension(dims: {[field: string]: boolean}, fieldDef: FieldDef<string>) {\n  if (fieldDef.bin) {\n    dims[field(fieldDef, {binSuffix: 'start'})] = true;\n    dims[field(fieldDef, {binSuffix: 'end'})] = true;\n\n    // We need the range only when the user explicitly forces a binned field to be ordinal (range used in axis and legend labels).\n    // We could check whether the axis or legend exists but that seems overkill. In axes and legends, we check hasDiscreteDomain(scaleType).\n    if (fieldDef.type === ORDINAL) {\n      dims[field(fieldDef, {binSuffix: 'range'})] = true;\n    }\n  } else {\n    dims[field(fieldDef)] = true;\n  }\n  return dims;\n}\n\nfunction mergeMeasures(parentMeasures: Dict<Dict<boolean>>, childMeasures: Dict<Dict<boolean>>) {\n  for (const field in childMeasures) {\n    if (childMeasures.hasOwnProperty(field)) {\n      // when we merge a measure, we either have to add an aggregation operator or even a new field\n      const ops = childMeasures[field];\n      for (const op in ops) {\n        if (ops.hasOwnProperty(op)) {\n          if (field in parentMeasures) {\n            // add operator to existing measure field\n            parentMeasures[field][op] = true;\n          } else {\n            parentMeasures[field] = {op: true};\n          }\n        }\n      }\n    }\n  }\n}\n\nexport class AggregateNode extends DataFlowNode {\n  public clone() {\n    return new AggregateNode(extend({}, this.dimensions), duplicate(this.measures));\n  }\n\n  /**\n   * @param dimensions string set for dimensions\n   * @param measures dictionary mapping field name => dict set of aggregation functions\n   */\n  constructor(private dimensions: StringSet, private measures: Dict<StringSet>) {\n    super();\n  }\n\n  public static make(model: UnitModel): AggregateNode {\n    let isAggregate = false;\n    model.forEachFieldDef(fd => {\n      if (fd.aggregate) {\n        isAggregate = true;\n      }\n    });\n\n    const meas = {};\n    const dims = {};\n\n    if (!isAggregate) {\n      // no need to create this node if the model has no aggregation\n      return null;\n    }\n\n    model.forEachFieldDef((fieldDef, channel) => {\n      if (fieldDef.aggregate) {\n        if (fieldDef.aggregate === 'count') {\n          meas['*'] = meas['*'] || {};\n          /* tslint:disable:no-string-literal */\n          meas['*']['count'] = true;\n          /* tslint:enable:no-string-literal */\n        } else {\n          meas[fieldDef.field] = meas[fieldDef.field] || {};\n          meas[fieldDef.field][fieldDef.aggregate] = true;\n\n          // add min/max so we can use their union as unaggregated domain\n          const scale = model.scale(channel);\n          if (scale && scale.domain === 'unaggregated') {\n            meas[fieldDef.field]['min'] = true;\n            meas[fieldDef.field]['max'] = true;\n          }\n        }\n      } else {\n        addDimension(dims, fieldDef);\n      }\n    });\n\n    if ((Object.keys(dims).length + Object.keys(meas).length) === 0) {\n      return null;\n    }\n\n    return new AggregateNode(dims, meas);\n  }\n\n  public merge(other: AggregateNode) {\n    if (!differ(this.dimensions, other.dimensions)) {\n      mergeMeasures(this.measures, other.measures);\n      other.remove();\n    } else {\n      log.debug('different dimensions, cannot merge');\n    }\n  }\n\n  public addDimensions(fields: string[]) {\n    fields.forEach(f => this.dimensions[f] = true);\n  }\n\n  public dependentFields() {\n    const out = {};\n\n    keys(this.dimensions).forEach(f => out[f] = true);\n    keys(this.measures).forEach(m => out[m] = true);\n\n    return out;\n  }\n\n  public producedFields() {\n    const out = {};\n\n    keys(this.measures).forEach(field => {\n      keys(this.measures[field]).forEach(op => {\n        out[`${op}_${field}`] = true;\n      });\n    });\n\n    return out;\n  }\n\n  public assemble(): VgAggregateTransform {\n    const ops: string[] = [];\n    const fields: string[] = [];\n    keys(this.measures).forEach(field => {\n      keys(this.measures[field]).forEach(op => {\n        ops.push(op);\n        fields.push(field);\n      });\n    });\n\n    return {\n      type: 'aggregate',\n      groupby: keys(this.dimensions),\n      ops,\n      fields\n    };\n  }\n}\n","import {MAIN} from '../../data';\nimport {field} from '../../fielddef';\nimport {every, flatten, vals} from '../../util';\nimport {VgData} from '../../vega.schema';\nimport {Model} from '../model';\nimport {AggregateNode} from './aggregate';\nimport {BinNode} from './bin';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {FacetNode} from './facet';\nimport {ParseNode} from './formatparse';\nimport {NonPositiveFilterNode} from './nonpositivefilter';\nimport {NullFilterNode} from './nullfilter';\nimport {iterateFromLeaves} from './optimizers';\nimport * as optimizers from './optimizers';\nimport {OrderNode} from './pathorder';\nimport {SourceNode} from './source';\nimport {StackNode} from './stack';\nimport {TimeUnitNode} from './timeunit';\nimport {CalculateNode, FilterNode} from './transforms';\n\n\nexport const FACET_SCALE_PREFIX = 'scale_';\n\n/**\n * Start optimization path from the root. Useful for removing nodes.\n */\nfunction removeUnnecessaryNodes(node: DataFlowNode) {\n  // remove empty non positive filter\n  if (node instanceof NonPositiveFilterNode && every(vals(node.filter), b => b === false)) {\n    node.remove();\n  }\n\n  // remove empty null filter nodes\n  if (node instanceof NullFilterNode && every(vals(node.filteredFields), f => f === null)) {\n    node.remove();\n  }\n\n  // remove output nodes that are not required\n  if (node instanceof OutputNode && !node.required) {\n    node.remove();\n  }\n\n  node.children.forEach(removeUnnecessaryNodes);\n}\n\n/**\n * Clones the subtree and ignores output nodes except for the leafs, which are renamed.\n */\nfunction cloneSubtree(facet: FacetNode) {\n  function clone(node: DataFlowNode): DataFlowNode[] {\n    if (!(node instanceof OrderNode)) {  // we can ignore order ndoes beacuse they don't change the scale domain\n      const copy = node.clone();\n\n      if (copy instanceof OutputNode) {\n        const newName = FACET_SCALE_PREFIX + facet.model.getName(copy.source);\n        copy.source = newName;\n\n        facet.model.component.data.outputNodes[newName] = copy;\n\n        flatten(node.children.map(clone)).forEach((n: DataFlowNode) => n.parent = copy);\n      } else if (copy instanceof AggregateNode || copy instanceof StackNode) {\n        copy.addDimensions(facet.fields);\n\n        flatten(node.children.map(clone)).forEach((n: DataFlowNode) => n.parent = copy);\n      } else {\n        flatten(node.children.map(clone)).forEach((n: DataFlowNode) => n.parent = copy);\n      }\n\n      return [copy];\n    }\n\n    return flatten(node.children.map(clone));\n  }\n  return clone;\n}\n\n/**\n * Move facet nodes down to the next fork or output node. Also pull the main output with the facet node.\n * After moving down the facet node, make a copy of the subtree and make it a child of the main output.\n */\nfunction moveFacetDown(node: DataFlowNode) {\n  if (node instanceof FacetNode) {\n    if (node.numChildren() === 1 && !(node.children[0] instanceof OutputNode)) {\n      // move down until we hit a fork or output node\n\n      const child = node.children[0];\n\n      if (child instanceof AggregateNode || child instanceof StackNode) {\n        child.addDimensions(node.fields);\n      }\n\n      child.swapWithParent();\n      moveFacetDown(node);\n    } else {\n      // move main to facet\n      moveMainDownToFacet(node.model.component.data.main);\n\n      // replicate the subtree and place it before the facet's main node\n      const copy: DataFlowNode[] = flatten(node.children.map(cloneSubtree(node)));\n      copy.forEach(c => c.parent = node.model.component.data.main);\n    }\n  } else {\n    node.children.forEach(moveFacetDown);\n  }\n}\n\nfunction moveMainDownToFacet(node: DataFlowNode) {\n  if (node instanceof OutputNode && node.type === MAIN) {\n    if (node.numChildren() === 1) {\n      const child = node.children[0];\n\n      if (!(child instanceof FacetNode)) {\n        child.swapWithParent();\n        moveMainDownToFacet(node);\n      }\n    }\n  }\n}\n\n\n/**\n * Return all leaf nodes.\n */\nfunction getLeaves(roots: DataFlowNode[]) {\n  const leaves: DataFlowNode[] = [];\n  function append(node: DataFlowNode) {\n    if (node.numChildren() === 0) {\n      leaves.push(node);\n    } else {\n      node.children.forEach(append);\n    }\n  }\n\n  roots.forEach(append);\n  return leaves;\n}\n\n/**\n * Print debug information for dataflow tree.\n */\nfunction debug(node: DataFlowNode) {\n  console.log(`${(node.constructor as any).name}${node.debugName ? ` (${node.debugName})` : ''} -> ${\n    (node.children.map(c => {\n      return `${(c.constructor as any).name}${c.debugName ? ` (${c.debugName})` : ''}`;\n    }))\n  }`);\n  console.log(node);\n  node.children.forEach(debug);\n}\n\nfunction makeWalkTree(data: VgData[]) {\n  // to name datasources\n  let datasetIndex = 0;\n\n  /**\n   * Recursively walk down the tree.\n   */\n  function walkTree(node: DataFlowNode, dataSource: VgData) {\n    if (node instanceof ParseNode) {\n      if (node.parent instanceof SourceNode && !dataSource.source)  {\n        // If node's parent is a root source and the data source does not refer to another data source, use normal format parse\n        dataSource.format = {\n          ...dataSource.format || {},\n          parse: node.assembleFormatParse()\n        };\n      } else {\n        // Otherwise use Vega expression to parse\n        dataSource.transform = dataSource.transform.concat(node.assembleTransforms());\n      }\n    }\n\n    if (node instanceof FacetNode) {\n      if (!dataSource.name) {\n        dataSource.name = `data_${datasetIndex++}`;\n      }\n\n      if (!dataSource.source || dataSource.transform.length > 0) {\n        data.push(dataSource);\n        node.data = dataSource.name;\n      } else {\n        node.data = dataSource.source;\n      }\n\n      node.assemble().forEach(d => data.push(d));\n\n      // break here because the rest of the tree has to be taken care of by the facet.\n      return;\n    }\n\n    if (node instanceof FilterNode ||\n      node instanceof NullFilterNode ||\n      node instanceof CalculateNode ||\n      node instanceof AggregateNode ||\n      node instanceof OrderNode) {\n      dataSource.transform.push(node.assemble());\n    }\n\n    if (node instanceof NonPositiveFilterNode ||\n      node instanceof BinNode ||\n      node instanceof TimeUnitNode ||\n      node instanceof StackNode) {\n      dataSource.transform = dataSource.transform.concat(node.assemble());\n    }\n\n    if (node instanceof OutputNode) {\n      if (dataSource.source && dataSource.transform.length === 0) {\n        node.source = dataSource.source;\n      } else if (node.parent instanceof OutputNode) {\n        // Note that an output node may be required but we still do not assemble a\n        // separate data source for it.\n        node.source = dataSource.name;\n      } else {\n        if (!dataSource.name) {\n          dataSource.name = `data_${datasetIndex++}`;\n        }\n\n        // Here we set the name of the datasource we generated. From now on\n        // other assemblers can use it.\n        node.source = dataSource.name;\n\n        // if this node has more than one child, we will add a datasource automatically\n        if (node.numChildren() === 1 && dataSource.transform.length > 0) {\n          data.push(dataSource);\n          const newData: VgData = {\n            name: null,\n            source: dataSource.name,\n            transform: []\n          };\n          dataSource = newData;\n        }\n      }\n    }\n\n    switch (node.numChildren()) {\n      case 0:\n        // done\n        if (node instanceof OutputNode && (!dataSource.source || dataSource.transform.length > 0)) {\n          // do not push empty datasources that are simply references\n          data.push(dataSource);\n        }\n        break;\n      case 1:\n        walkTree(node.children[0], dataSource);\n        break;\n      default:\n        let source = dataSource.name;\n        if (!dataSource.source || dataSource.transform.length > 0) {\n          data.push(dataSource);\n        } else {\n          source = dataSource.source;\n        }\n\n        node.children.forEach(child => {\n          const newData: VgData = {\n            name: null,\n            source: source,\n            transform: []\n          };\n          walkTree(child, newData);\n        });\n        break;\n    }\n  }\n\n  return walkTree;\n}\n\n/**\n * Assemble data sources that are derived from faceted data.\n */\nexport function assembleFacetData(root: FacetNode): VgData[] {\n  const data: VgData[] = [];\n  const walkTree = makeWalkTree(data);\n\n  root.children.forEach(child => walkTree(child, {\n    source: root.name,\n    name: null,\n    transform: []\n  }));\n\n  return data;\n}\n\n/**\n * Create Vega Data array from a given compiled model and append all of them to the given array\n *\n * @param  model\n * @param  data array\n * @return modified data array\n */\nexport function assembleData(roots: SourceNode[]): VgData[] {\n  const data: VgData[] = [];\n\n  roots.forEach(removeUnnecessaryNodes);\n\n  // remove source nodes that don't have any children because they also don't have output nodes\n  roots = roots.filter(r => r.numChildren() > 0);\n  getLeaves(roots).forEach(iterateFromLeaves(optimizers.removeUnusedSubtrees));\n  roots = roots.filter(r => r.numChildren() > 0);\n\n  getLeaves(roots).forEach(iterateFromLeaves(optimizers.moveParseUp));\n\n  roots.forEach(moveFacetDown);\n\n  // roots.forEach(debug);\n\n  const walkTree = makeWalkTree(data);\n\n  let sourceIndex = 0;\n\n  roots.forEach(root => {\n    // assign a name if the source does not have a name yet\n    if (!root.hasName()) {\n      root.dataName = `source_${sourceIndex++}`;\n    }\n\n    const newData: VgData = root.assemble();\n\n    walkTree(root, newData);\n  });\n\n  // remove empty transform arrays for cleaner output\n  data.forEach(d => {\n    if (d.transform.length === 0) {\n      delete d.transform;\n    }\n  });\n\n  return data;\n}\n","import {autoMaxBins, Bin, binToString} from '../../bin';\nimport {Channel} from '../../channel';\nimport {Config} from '../../config';\nimport {field, FieldDef} from '../../fielddef';\nimport {hasDiscreteDomain} from '../../scale';\nimport {Dict, duplicate, extend, flatten, hash, isBoolean, StringSet, vals} from '../../util';\nimport {VgBinTransform, VgTransform} from '../../vega.schema';\nimport {numberFormat} from '../common';\nimport {ModelWithField} from '../model';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\n\n\nfunction numberFormatExpr(expr: string, format: string) {\n  return `format(${expr}, '${format}')`;\n}\n\nfunction rangeFormula(model: ModelWithField, fieldDef: FieldDef<string>, channel: Channel, config: Config) {\n    const discreteDomain = model.hasDiscreteDomain(channel);\n\n    if (discreteDomain) {\n      // read format from axis or legend, if there is no format then use config.numberFormat\n\n      const guide = (model instanceof UnitModel) ? (model.axis(channel) || model.legend(channel) || {}) : {};\n      const format = numberFormat(fieldDef, guide.format, config, channel);\n\n      const startField = field(fieldDef, {expr: 'datum', binSuffix: 'start'});\n      const endField = field(fieldDef, {expr: 'datum', binSuffix: 'end'});\n\n      return {\n        formulaAs: field(fieldDef, {binSuffix: 'range'}),\n        formula: `${numberFormatExpr(startField, format)} + ' - ' + ${numberFormatExpr(endField, format)}`\n      };\n    }\n    return {};\n}\n\nexport interface BinComponent {\n  bin: Bin;\n  field: string;\n  extentSignal: string;\n  signal: string;\n  as: string[];\n\n  // Range Formula\n\n  formula?: string;\n  formulaAs?: string;\n}\n\nexport class BinNode extends DataFlowNode {\n  public clone() {\n    return new BinNode(duplicate(this.bins));\n  }\n\n  constructor(private bins: Dict<BinComponent>) {\n    super();\n  }\n\n  public static make(model: ModelWithField) {\n    const bins = model.reduceFieldDef((binComponent: Dict<BinComponent>, fieldDef, channel) => {\n      const fieldDefBin = model.fieldDef(channel).bin;\n      if (fieldDefBin) {\n        const bin: Bin = isBoolean(fieldDefBin) ? {} : fieldDefBin;\n        const key = `${binToString(fieldDef.bin)}_${fieldDef.field}`;\n\n        if (!(key in binComponent)) {\n          binComponent[key] = {\n            bin: bin,\n            field: fieldDef.field,\n            as: [field(fieldDef, {binSuffix: 'start'}), field(fieldDef, {binSuffix: 'end'})],\n            signal: model.getName(`${key}_bins`),\n            extentSignal: model.getName(key + '_extent')\n          };\n        }\n\n        binComponent[key] = {\n          ...binComponent[key],\n          ...rangeFormula(model, fieldDef, channel, model.config)\n        };\n      }\n      return binComponent;\n    }, {});\n\n    if (Object.keys(bins).length === 0) {\n      return null;\n    }\n\n    return new BinNode(bins);\n  }\n\n  public merge(other: BinNode) {\n    this.bins = extend(other.bins);\n    other.remove();\n  }\n\n  public producedFields() {\n    const out = {};\n\n    vals(this.bins).forEach(c => {\n      c.as.forEach(f => out[f] = true);\n    });\n\n    return out;\n  }\n\n  public dependentFields() {\n    const out = {};\n\n    vals(this.bins).forEach(c => {\n      out[c.field] = true;\n    });\n\n    return out;\n  }\n\n  public assemble(): VgTransform[] {\n    return flatten(vals(this.bins).map(bin => {\n      const transform: VgTransform[] = [];\n\n      const binTrans: VgBinTransform = {\n          type: 'bin',\n          field: bin.field,\n          as: bin.as,\n          signal: bin.signal,\n          ...bin.bin\n      };\n\n      if (!bin.bin.extent) {\n        transform.push({\n          type: 'extent',\n          field: bin.field,\n          signal: bin.extentSignal\n        });\n        binTrans.extent = {signal: bin.extentSignal};\n      }\n\n      transform.push(binTrans);\n\n      if (bin.formula) {\n        transform.push({\n          type: 'formula',\n          expr: bin.formula,\n          as: bin.formulaAs\n        });\n      }\n\n      return transform;\n    }));\n  }\n}\n","import {isFunction} from 'util';\nimport {DataSourceType} from '../../data';\nimport {StringSet} from '../../util';\n\n\n/**\n * A node in the dataflow tree.\n */\nexport class DataFlowNode {\n  private _children: DataFlowNode[] = [];\n\n  private _parent: DataFlowNode = null;\n\n  constructor(public readonly debugName?: string) { }\n\n  /**\n   * Clone this node with a deep copy but don't clone links to children or parents.\n   */\n  public clone(): DataFlowNode {\n    throw new Error('Cannot clone node');\n  }\n\n  /**\n   * Set of fields that are being created by this node.\n   */\n  public producedFields(): StringSet {\n    return {};\n  }\n\n  public dependentFields(): StringSet {\n    return {};\n  }\n\n  get parent() {\n    return this._parent;\n  }\n\n  /**\n   * Set the parent of the node and also add this not to the parent's children.\n   */\n  set parent(parent: DataFlowNode) {\n    this._parent = parent;\n    parent.addChild(this);\n  }\n\n  get children() {\n    return this._children;\n  }\n\n  public numChildren() {\n    return this._children.length;\n  }\n\n  public addChild(child: DataFlowNode) {\n    this._children.push(child);\n  }\n\n  public removeChild(oldChild: DataFlowNode) {\n    this._children.splice(this._children.indexOf(oldChild), 1);\n  }\n\n  /**\n   * Remove node from the dataflow.\n   */\n  public remove() {\n    this._children.forEach(child => child.parent = this._parent);\n    this._parent.removeChild(this);\n  }\n\n  public swapWithParent() {\n    const parent = this._parent;\n    const newParent = parent.parent;\n\n    // reconnect the children\n    this._children.forEach(c => c.parent = parent);\n\n    // remove old links\n    this._children = [];  // equivalent to removing every child link one by one\n    parent.removeChild(this);\n    parent.parent.removeChild(parent);\n\n\n    // swap two nodes\n    this.parent = newParent;\n    parent.parent = this;\n  }\n}\n\nexport class OutputNode extends DataFlowNode {\n\n  private _source: string;\n\n  private _refcount = 0;\n\n  public clone(): this {\n    const cloneObj = new (<any>this.constructor);\n    cloneObj._source = this._source;\n    cloneObj.debugName = 'clone_' + this.debugName;\n    cloneObj._refcount = this._refcount;\n    return cloneObj;\n  }\n\n  constructor(source: string, public readonly type: DataSourceType) {\n    super(source);\n\n    this._source = source;\n  }\n\n  /**\n   * Request the datasource name.\n   *\n   * During the parsing phase, this will return the simple name such as 'main' or 'raw'.\n   * It is crucial to request the name from an output node to mark it as a required node.\n   * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.\n   *\n   * In the assemble phase, this will return the correct name.\n   */\n  get source() {\n    this._refcount++;\n    return this._source;\n  }\n\n  set source(source: string) {\n    this._source = source;\n  }\n\n  get required() {\n    return this._refcount > 0;\n  }\n}\n","import {COLUMN, ROW} from '../../channel';\nimport {VgData, VgTransform} from '../../vega.schema';\nimport {FacetModel} from '../facet';\nimport {DataFlowNode, OutputNode} from './dataflow';\n\n/**\n * A node that helps us track what fields we are faceting by.\n */\nexport class FacetNode extends DataFlowNode {\n  private readonly columnField: string;\n  private readonly columnName: string;\n\n  private readonly rowField: string;\n  private readonly rowName: string;\n\n  /**\n   * @param model The facet model.\n   * @param name The name that this facet source will have.\n   * @param data The source data for this facet data.\n   */\n  public constructor(public readonly model: FacetModel, public readonly name: string, public data: string) {\n    super();\n\n    if (model.facet.column) {\n      this.columnField = model.field(COLUMN);\n      this.columnName = model.getName('column');\n    }\n\n    if (model.facet.row) {\n      this.rowField = model.field(ROW);\n      this.rowName = model.getName('row');\n    }\n  }\n\n  get fields() {\n    const fields: string[] = [];\n    if (this.columnField) {\n      fields.push(this.columnField);\n    }\n    if (this.rowField) {\n      fields.push(this.rowField);\n    }\n    return fields;\n  }\n\n  /**\n   * The name to reference this source is its name\n   */\n  get source() {\n    return this.name;\n  }\n\n  public assemble() {\n    const data: VgData[] = [];\n\n    if (this.columnName) {\n      data.push({\n        name: this.columnName,\n        source: this.data,\n        transform: [{\n          type: 'aggregate',\n          groupby: [this.columnField]\n        }]\n      });\n\n      // Column needs another data source to calculate cardinality as input to layout\n      data.push({\n        name: this.columnName + '_layout',\n        source: this.columnName,\n        transform: [{\n          type: 'aggregate',\n          ops: ['distinct'],\n          fields: [this.columnField]\n        }]\n      });\n    }\n\n    if (this.rowName) {\n      data.push({\n        name: this.rowName,\n        source: this.data,\n        transform: [{\n          type: 'aggregate',\n          groupby: [this.rowField]\n        }]\n      });\n    }\n\n    return data;\n  }\n}\n\n","import {DateTime, isDateTime} from '../../datetime';\nimport {FieldDef, isCount} from '../../fielddef';\nimport {isEqualFilter, isOneOfFilter, isRangeFilter} from '../../filter';\nimport * as log from '../../log';\nimport {CalculateTransform, FilterTransform, isCalculate, isFilter} from '../../transform';\nimport {QUANTITATIVE, TEMPORAL} from '../../type';\nimport {Dict, duplicate, extend, isArray, isNumber, isString, keys} from '../../util';\nimport {VgFormulaTransform} from '../../vega.schema';\nimport {Model, ModelWithField} from '../model';\nimport {DataFlowNode} from './dataflow';\n\n\nfunction parseExpression(field: string, parse: string): string {\n  const f = `datum[\"${field}\"]`;\n  if (parse === 'number') {\n    return `toNumber(${f})`;\n  } else if (parse === 'boolean') {\n    return `toBoolean(${f})`;\n  } else if (parse === 'string') {\n    return `toString(${f})`;\n  } else if (parse === 'date') {\n    return `toDate(${f})`;\n  } else if (parse.indexOf('date:') === 0) {\n    const specifier = parse.slice(6, parse.length - 1);  // specifier is in \"\" or ''\n    return `timeParse(${f},\"${specifier}\")`;\n  } else {\n    log.warn(log.message.unrecognizedParse(parse));\n    return null;\n  }\n}\n\nexport class ParseNode extends DataFlowNode {\n  private _parse: Dict<string> = {};\n\n  public clone() {\n    return new ParseNode(duplicate(this.parse));\n  }\n\n  constructor(parse: Dict<string>) {\n    super();\n\n    this._parse = parse;\n  }\n\n  public static make(model: Model) {\n    const parse = {};\n\n    const calcFieldMap = model.transforms.filter(isCalculate).reduce((fieldMap, formula: CalculateTransform) => {\n      fieldMap[formula.as] = true;\n      return fieldMap;\n    }, {});\n\n    // Parse filter fields\n    model.transforms.filter(isFilter).forEach((transform: FilterTransform) => {\n      let filter = transform.filter;\n      if (!isArray(filter)) {\n        filter = [filter];\n      }\n      filter.forEach(f => {\n        let val: string | number | boolean | DateTime = null;\n        // For EqualFilter, just use the equal property.\n        // For RangeFilter and OneOfFilter, all array members should have\n        // the same type, so we only use the first one.\n        if (isEqualFilter(f)) {\n          val = f.equal;\n        } else if (isRangeFilter(f)) {\n          val = f.range[0];\n        } else if (isOneOfFilter(f)) {\n          val = (f.oneOf || f['in'])[0];\n        } // else -- for filter expression, we can't infer anything\n\n        if (val) {\n          if (isDateTime(val)) {\n            parse[f['field']] = 'date';\n          } else if (isNumber(val)) {\n            parse[f['field']] = 'number';\n          } else if (isString(val)) {\n            parse[f['field']] = 'string';\n          }\n        }\n      });\n    });\n\n    if (model instanceof ModelWithField) {\n      // Parse encoded fields\n      model.forEachFieldDef(fieldDef => {\n        if (fieldDef.type === TEMPORAL) {\n          parse[fieldDef.field] = 'date';\n        } else if (fieldDef.type === QUANTITATIVE) {\n          if (isCount(fieldDef) || calcFieldMap[fieldDef.field]) {\n            return;\n          }\n          parse[fieldDef.field] = 'number';\n        }\n      });\n    }\n\n    // Custom parse should override inferred parse\n    const data = model.data;\n    if (data && data.format && data.format.parse) {\n      const p = data.format.parse;\n      keys(p).forEach((field) => {\n        parse[field] = p[field];\n      });\n    }\n\n    if (keys(parse).length === 0) {\n      return null;\n    }\n\n    return new ParseNode(parse);\n  }\n\n  public get parse() {\n    return this._parse;\n  }\n\n\n  public merge(other: ParseNode) {\n    this._parse = extend(this._parse, other.parse);\n    other.remove();\n  }\n\n  public assembleFormatParse() {\n    return this._parse;\n  }\n\n  public assembleTransforms(): VgFormulaTransform[] {\n    return Object.keys(this._parse).map(field => {\n      const expr = parseExpression(field, this._parse[field]);\n      if (!expr) {\n        return null;\n      }\n\n      const formula: VgFormulaTransform = {\n        type: 'formula',\n        expr,\n        as: field\n      };\n      return formula;\n    }).filter(t => t !== null);\n  }\n}\n","import {ScaleType} from '../../scale';\nimport {Dict, duplicate, extend, keys} from '../../util';\nimport {VgFilterTransform, VgTransform} from '../../vega.schema';\nimport {UnitModel} from './../unit';\nimport {DataFlowNode} from './dataflow';\n\nexport class NonPositiveFilterNode extends DataFlowNode {\n  private _filter: Dict<boolean>;\n\n  public clone() {\n    return new NonPositiveFilterNode(extend({}, this._filter));\n  }\n\n  constructor(filter: Dict<boolean>) {\n    super();\n\n    this._filter = filter;\n  }\n\n  public static make(model: UnitModel) {\n    const filter = model.channels().reduce(function(nonPositiveComponent, channel) {\n      const scale = model.scale(channel);\n      if (!scale || !model.field(channel)) {\n        // don't set anything\n        return nonPositiveComponent;\n      }\n      nonPositiveComponent[model.field(channel)] = scale.type === ScaleType.LOG;\n      return nonPositiveComponent;\n    }, {});\n\n    if (!Object.keys(filter).length) {\n      return null;\n    }\n\n    return new NonPositiveFilterNode(filter);\n  }\n\n  get filter() {\n    return this._filter;\n  }\n\n  public assemble(): VgTransform[] {\n    return keys(this._filter).filter((field) => {\n      // Only filter fields (keys) with value = true\n      return this._filter[field];\n    }).map(function(field) {\n      return {\n        type: 'filter',\n        expr: 'datum[\"' + field + '\"] > 0'\n      } as VgFilterTransform;\n    });\n  }\n}\n","import {FieldDef} from '../../fielddef';\nimport {QUANTITATIVE, TEMPORAL} from '../../type';\nimport {contains, Dict, differ, differArray, duplicate, extend, hash, keys} from '../../util';\nimport {VgFilterTransform} from '../../vega.schema';\nimport {ModelWithField} from '../model';\nimport {Model} from './../model';\nimport {DataFlowNode} from './dataflow';\n\n\nconst DEFAULT_NULL_FILTERS = {\n  nominal: false,\n  ordinal: false,\n  quantitative: true,\n  temporal: true\n};\n\nexport class NullFilterNode extends DataFlowNode {\n  private _filteredFields: Dict<FieldDef<string>>;\n\n  public clone() {\n    return new NullFilterNode(duplicate(this._filteredFields));\n  }\n\n  constructor(fields: Dict<FieldDef<string>>) {\n    super();\n\n    this._filteredFields = fields;\n  }\n\n  public static make(model: ModelWithField) {\n    const fields = model.reduceFieldDef((aggregator: Dict<FieldDef<string>>, fieldDef) => {\n      if (fieldDef.aggregate !== 'count') { // Ignore * for count(*) fields.\n        if (model.config.filterInvalid ||\n          (model.config.filterInvalid === undefined && (fieldDef.field && DEFAULT_NULL_FILTERS[fieldDef.type]))) {\n          aggregator[fieldDef.field] = fieldDef;\n        } else {\n          // define this so we know that we don't filter nulls for this field\n          // this makes it easier to merge into parents\n          aggregator[fieldDef.field] = null;\n        }\n      }\n      return aggregator;\n    }, {} as Dict<FieldDef<string>>);\n\n    if (Object.keys(fields).length === 0) {\n      return null;\n    }\n\n    return new NullFilterNode(fields);\n  }\n\n  get filteredFields() {\n      return this._filteredFields;\n  }\n\n  public merge(other: NullFilterNode) {\n    const t = Object.keys(this._filteredFields).map(k => k + ' ' + hash(this._filteredFields[k]));\n    const o = Object.keys(other.filteredFields).map(k => k + ' ' + hash(other.filteredFields[k]));\n\n    if (!differArray(t, o)) {\n      this._filteredFields = extend(this._filteredFields, other._filteredFields);\n      other.remove();\n    }\n  }\n\n  public assemble(): VgFilterTransform {\n    const filters = keys(this._filteredFields).reduce((_filters, field) => {\n      const fieldDef = this._filteredFields[field];\n      if (fieldDef !== null) {\n        _filters.push('datum[\"' + fieldDef.field + '\"] !== null');\n        if (contains([QUANTITATIVE, TEMPORAL], fieldDef.type)) {\n          // TODO(https://github.com/vega/vega-lite/issues/1436):\n          // We can be even smarter and add NaN filter for N,O that are numbers\n          // based on the `parse` property once we have it.\n          _filters.push('!isNaN(datum[\"'+ fieldDef.field + '\"])');\n        }\n      }\n      return _filters;\n    }, []);\n\n    return filters.length > 0 ?\n      {\n        type: 'filter',\n        expr: filters.join(' && ')\n      } : null;\n  }\n}\n","import {hasIntersection} from '../../util';\nimport {AggregateNode} from './aggregate';\nimport {BinNode} from './bin';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {FacetNode} from './facet';\nimport {ParseNode} from './formatparse';\nimport {NullFilterNode} from './nullfilter';\nimport {SourceNode} from './source';\nimport {StackNode} from './stack';\nimport {TimeUnitNode} from './timeunit';\nimport {CalculateNode, FilterNode} from './transforms';\n\n/**\n * Start optimization path at the leaves. Useful for merging up or removing things.\n *\n * If the callback returns true, the recursion continues.\n */\nexport function iterateFromLeaves(f: (node: DataFlowNode) => boolean) {\n  function optimizeNextFromLeaves(node: DataFlowNode) {\n    if (node instanceof SourceNode) {\n      return;\n    }\n\n    const next = node.parent;\n    if (f(node)) {\n      optimizeNextFromLeaves(next);\n    }\n  }\n\n  return optimizeNextFromLeaves;\n}\n\n/**\n * Move parse nodes up to forks.\n */\nexport function moveParseUp(node: DataFlowNode) {\n  const parent = node.parent;\n\n  // move parse up by merging or swapping\n  if (node instanceof ParseNode) {\n    if (parent instanceof SourceNode) {\n      return false;\n    }\n\n    if (parent.numChildren() > 1) {\n      return true;\n    }\n\n    if (parent instanceof ParseNode) {\n      parent.merge(node);\n    } else {\n      node.swapWithParent();\n    }\n  }\n\n  return true;\n}\n\n/**\n * Repeatedly remove leaf nodes that are not output nodes.\n * The reason is that we don't need subtrees that don't have any output nodes.\n */\nexport function removeUnusedSubtrees(node: DataFlowNode) {\n  const parent = node.parent;\n\n  if (node instanceof OutputNode || node.numChildren() > 0) {\n    // no need to continue with parent because it is output node or will have children (there was a fork)\n    return false;\n  } else {\n    node.remove();\n  }\n  return true;\n}\n","import {MAIN, RAW} from '../../data';\nimport {Dict} from '../../util';\nimport {FacetModel} from '../facet';\nimport {Model, ModelWithField} from '../model';\nimport {UnitModel} from '../unit';\nimport {AggregateNode} from './aggregate';\nimport {BinNode} from './bin';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {FacetNode} from './facet';\nimport {ParseNode} from './formatparse';\nimport {DataComponent} from './index';\nimport {NonPositiveFilterNode} from './nonpositivefilter';\nimport {NullFilterNode} from './nullfilter';\nimport {OrderNode} from './pathorder';\nimport {SourceNode} from './source';\nimport {StackNode} from './stack';\nimport {TimeUnitNode} from './timeunit';\nimport {parseTransformArray} from './transforms';\n\nfunction parseRoot(model: Model, sources: Dict<SourceNode>): DataFlowNode {\n  if (model.data || !model.parent) {\n    // if the model defines a data source or is the root, create a source node\n    const source = new SourceNode(model);\n    const hash = source.hash();\n    if (hash in sources) {\n      // use a reference if we already have a source\n      return sources[hash];\n    } else {\n      // otherwise add a new one\n      sources[hash] = source;\n      return source;\n    }\n  } else {\n    // If we don't have a source defined (overriding parent's data), use the parent's facet root or main.\n    return model.parent.component.data.facetRoot ? model.parent.component.data.facetRoot : model.parent.component.data.main;\n  }\n}\n\n/*\nDescription of the dataflow (http://asciiflow.com/):\n\n     +--------+\n     | Source |\n     +---+----+\n         |\n         v\n       Parse\n         |\n         v\n     Transforms\n(Filter, Compute, ...)\n         |\n         v\n     Null Filter\n         |\n         v\n      Binning\n         |\n         v\n     Timeunit\n         |\n         v\n      +--+--+\n      | Raw |\n      +-----+\n         |\n         v\n     Aggregate\n         |\n         v\n       Stack\n         |\n         v\n      >0 Filter\n         |\n         v\n     Path Order\n         |\n         v\n   +----------+\n   |   Main   |\n   +----------+\n         |\n         v\n     +-------+\n     | Facet |----> \"column\", \"column-layout\", and \"row\"\n     +-------+\n         |\n         v\n  ...Child data...\n\n*/\n\nexport function parseData(model: Model): DataComponent {\n  const root = parseRoot(model, model.component.data.sources);\n\n  const outputNodes = model.component.data.outputNodes;\n\n  // the current head of the tree that we are appending to\n  let head = root;\n\n  const parse = ParseNode.make(model);\n  if (parse) {\n    parse.parent = root;\n    head = parse;\n  }\n\n  if (model.transforms.length > 0) {\n    const {first, last} = parseTransformArray(model);\n    first.parent = head;\n    head = last;\n  }\n\n  if (model instanceof ModelWithField) {\n    const nullFilter = NullFilterNode.make(model);\n    if (nullFilter) {\n      nullFilter.parent = head;\n      head = nullFilter;\n    }\n\n    const bin = BinNode.make(model);\n    if (bin) {\n      bin.parent = head;\n      head = bin;\n    }\n\n    const tu = TimeUnitNode.make(model);\n    if (tu) {\n      tu.parent = head;\n      head = tu;\n    }\n  }\n\n  // add an output node pre aggregation\n  const rawName = model.getName(RAW);\n  const raw = new OutputNode(rawName, RAW);\n  outputNodes[rawName] = raw;\n  raw.parent = head;\n  head = raw;\n\n  if (model instanceof UnitModel) {\n    const agg = AggregateNode.make(model);\n    if (agg) {\n      agg.parent = head;\n      head = agg;\n    }\n\n    const stack = StackNode.make(model);\n    if (stack) {\n      stack.parent = head;\n      head = stack;\n    }\n\n    const nonPosFilter = NonPositiveFilterNode.make(model);\n    if (nonPosFilter) {\n      nonPosFilter.parent = head;\n      head = nonPosFilter;\n    }\n  }\n\n  if (model instanceof UnitModel) {\n    const order = OrderNode.make(model);\n    if (order) {\n      order.parent = head;\n      head = order;\n    }\n  }\n\n  // output node for marks\n  const mainName = model.getName(MAIN);\n  const main = new OutputNode(mainName, MAIN);\n  outputNodes[mainName] = main;\n  main.parent = head;\n  head = main;\n\n  // add facet marker\n  let facetRoot = null;\n  if (model instanceof FacetModel) {\n    const facetName = model.getName('facet');\n    facetRoot = new FacetNode(model, facetName, main.source);\n    outputNodes[facetName] = facetRoot;\n    facetRoot.parent = head;\n    head = facetRoot;\n  }\n\n  return {\n    sources: model.component.data.sources,\n    outputNodes,\n    main,\n    facetRoot\n  };\n}\n","import {isAggregate} from '../../encoding';\nimport {field} from '../../fielddef';\nimport {isSortField} from '../../sort';\nimport {contains, duplicate} from '../../util';\n\n import {VgCollectTransform, VgSort} from '../../vega.schema';\nimport {sortParams} from '../common';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\n\nexport class OrderNode extends DataFlowNode {\n  public clone() {\n    return new OrderNode(duplicate(this.sort));\n  }\n\n  constructor(private sort: VgSort) {\n    super();\n  }\n\n  public static make(model: UnitModel) {\n    let sort: VgSort = null;\n\n    if (contains(['line', 'area'], model.mark())) {\n      if (model.mark() === 'line' && model.channelHasField('order')) {\n        // For only line, sort by the order field if it is specified.\n        sort = sortParams(model.encoding.order);\n      } else {\n        // For both line and area, we sort values based on dimension by default\n        const dimensionChannel: 'x' | 'y' = model.markDef.orient === 'horizontal' ? 'y' : 'x';\n        const s = model.sort(dimensionChannel);\n        const sortField = isSortField(s) ?\n          field({\n            // FIXME: this op might not already exist?\n            // FIXME: what if dimensionChannel (x or y) contains custom domain?\n            aggregate: isAggregate(model.encoding) ? s.op : undefined,\n            field: s.field\n          }) :\n          model.field(dimensionChannel, {binSuffix: 'start'});\n\n        sort = {\n          field: sortField,\n          order: 'descending'\n        };\n      }\n    } else {\n      return null;\n    }\n\n    return new OrderNode(sort);\n  }\n\n  public assemble(): VgCollectTransform {\n    return {\n      type: 'collect',\n      sort: this.sort\n    };\n  }\n}\n","import {DataFormat, isInlineData, isNamedData, isUrlData} from '../../data';\nimport {contains, hash} from '../../util';\nimport {VgData} from '../../vega.schema';\nimport {Model} from './../model';\nimport {DataFlowNode} from './dataflow';\n\nexport class SourceNode extends DataFlowNode {\n  private _data: Partial<VgData>;\n\n  private _name: string;\n\n  constructor(model: Model) {\n    super();\n\n    const data = model.data || {name: 'source'};\n\n    if (isInlineData(data)) {\n      this._data = {\n        values: data.values,\n        format: {type: 'json'}\n      };\n    } else if (isUrlData(data)) {\n      // Extract extension from URL using snippet from\n      // http://stackoverflow.com/questions/680929/how-to-extract-extension-from-filename-string-in-javascript\n      let defaultExtension = /(?:\\.([^.]+))?$/.exec(data.url)[1];\n      if (!contains(['json', 'csv', 'tsv', 'topojson'], defaultExtension)) {\n        defaultExtension = 'json';\n      }\n      const dataFormat = data.format || {};\n\n      // For backward compatibility for former `data.formatType` property\n      const formatType: DataFormat = dataFormat.type || data['formatType'];\n      const {property, feature, mesh} = dataFormat;\n\n      const format = {\n        type: formatType ? formatType : defaultExtension,\n        ...(property ? {property} : {}),\n        ...(feature ? {feature} : {}),\n        ...(mesh ? {mesh} : {}),\n      };\n\n      this._data = {\n        url: data.url,\n        format\n      };\n    } else if (isNamedData(data)) {\n      this._name = data.name;\n      this._data = {};\n    }\n  }\n\n  get data() {\n    return this._data;\n  }\n\n  public hasName(): boolean {\n    return !!this._name;\n  }\n\n  get dataName() {\n    return this._name;\n  }\n\n  set dataName(name: string) {\n    this._name = name;\n  }\n\n  set parent(parent: DataFlowNode) {\n    throw new Error('Source nodes have to be roots.');\n  }\n\n  public remove() {\n    throw new Error('Source nodes are roots and cannot be removed.');\n  }\n\n  /**\n   * Return a unique identifir for this data source.\n   */\n  public hash() {\n    if (isInlineData(this._data)) {\n      return hash(this._data);\n    } else if (isUrlData(this._data)) {\n      return `${this._data.url} ${hash(this._data.format)}`;\n    } else {\n      return this._name;\n    }\n  }\n\n  public assemble(): VgData {\n    return {\n      name: this._name,\n      ...this._data,\n      transform: []\n    };\n  }\n}\n","import {isArray} from 'vega-util';\nimport {field} from '../../fielddef';\nimport {hasDiscreteDomain} from '../../scale';\nimport {StackOffset} from '../../stack';\nimport {contains, duplicate} from '../../util';\nimport {VgSort, VgTransform} from '../../vega.schema';\nimport {sortParams} from '../common';\nimport {UnitModel} from './../unit';\nimport {DataFlowNode} from './dataflow';\n\nfunction getStackByFields(model: UnitModel): string[] {\n  return model.stack.stackBy.reduce((fields, by) => {\n    const channel = by.channel;\n    const fieldDef = by.fieldDef;\n\n    const scale = model.scale(channel);\n    const _field = field(fieldDef, {\n      binSuffix: scale && hasDiscreteDomain(scale.type) ? 'range' : 'start'\n    });\n    if (_field) {\n      fields.push(_field);\n    }\n    return fields;\n  }, [] as string[]);\n}\n\nexport interface StackComponent {\n  /**\n   * Grouping fields for stacked charts.  This includes one of x- or 'y-field and may include faceted field.\n   */\n  groupby: string[];\n\n  /**\n   * Stack measure's field\n   */\n  field: string;\n\n  /**\n   * Level of detail fields for each level in the stacked charts such as color or detail.\n   */\n  stackby: string[];\n\n  /**\n   * Field that determines order of levels in the stacked charts.\n   */\n  sort: VgSort;\n\n  /** Mode for stacking marks. */\n  offset: StackOffset;\n\n  /**\n   * Whether to impute the data before stacking.\n   */\n  impute: boolean;\n}\n\nexport class StackNode extends DataFlowNode {\n  private _stack: StackComponent;\n\n  public clone() {\n    return new StackNode(duplicate(this._stack));\n  }\n\n  constructor(stack: StackComponent) {\n    super();\n\n    this._stack = stack;\n  }\n\n  public static make(model: UnitModel) {\n\n    const stackProperties = model.stack;\n\n    if (!stackProperties) {\n      return null;\n    }\n\n    const groupby = [];\n    if (stackProperties.groupbyChannel) {\n      const groupbyFieldDef = model.fieldDef(stackProperties.groupbyChannel);\n      if (groupbyFieldDef.bin) {\n        // For Bin, we need to add both start and end to ensure that both get imputed\n        // and included in the stack output (https://github.com/vega/vega-lite/issues/1805).\n        groupby.push(model.field(stackProperties.groupbyChannel, {binSuffix: 'start'}));\n        groupby.push(model.field(stackProperties.groupbyChannel, {binSuffix: 'end'}));\n      } else {\n        groupby.push(model.field(stackProperties.groupbyChannel));\n      }\n    }\n\n    const stackby = getStackByFields(model);\n    const orderDef = model.encoding.order;\n\n    let sort: VgSort;\n    if (orderDef) {\n      sort = sortParams(orderDef);\n    } else {\n      // default = descending by stackFields\n      // FIXME is the default here correct for binned fields?\n      sort = stackby.reduce((s, field) => {\n        s.field.push(field);\n        s.order.push('descending');\n        return s;\n      }, {field:[], order: []});\n    }\n\n    return new StackNode({\n      groupby,\n      field: model.field(stackProperties.fieldChannel),\n      stackby,\n      sort,\n      offset: stackProperties.offset,\n      impute: contains(['area', 'line'], model.mark()),\n    });\n  }\n\n  get stack(): StackComponent {\n    return this._stack;\n  }\n\n  public addDimensions(fields: string[]) {\n    this._stack.groupby = this._stack.groupby.concat(fields);\n  }\n\n  public dependentFields() {\n    const out = {};\n\n    out[this._stack.field] = true;\n    this._stack.groupby.forEach(f => out[f] = true);\n    const field = this._stack.sort.field;\n    isArray(field) ? field.forEach(f => out[f] = true) : out[field] = true;\n\n    return out;\n  }\n\n  public producedFields() {\n    const out = {};\n\n    out[this._stack.field + '_start'] = true;\n    out[this._stack.field + '_end'] = true;\n\n    return out;\n  }\n\n  public assemble(): VgTransform[] {\n    const transform: VgTransform[] = [];\n\n    const stack = this._stack;\n\n    // Impute\n    if (stack.impute) {\n      transform.push({\n        type: 'impute',\n        field: stack.field,\n        groupby: stack.stackby,\n        orderby: stack.groupby,\n        method: 'value',\n        value: 0\n      });\n    }\n\n    // Stack\n    transform.push({\n      type: 'stack',\n      groupby: stack.groupby,\n      field: stack.field,\n      sort: stack.sort,\n      as: [\n        stack.field + '_start',\n        stack.field + '_end'\n      ],\n      offset: stack.offset\n    });\n\n    return transform;\n  }\n}\n","import {SpawnSyncOptionsWithStringEncoding} from 'child_process';\nimport {field, FieldDef} from '../../fielddef';\nimport {fieldExpr, TimeUnit} from '../../timeunit';\nimport {TEMPORAL} from '../../type';\nimport {Dict, duplicate, extend, StringSet, vals} from '../../util';\nimport {VgFormulaTransform, VgTransform} from '../../vega.schema';\nimport {format} from '../axis/rules';\nimport {ModelWithField} from '../model';\nimport {DataFlowNode} from './dataflow';\n\n\nexport interface TimeUnitComponent {\n  as: string;\n  timeUnit: TimeUnit;\n  field: string;\n}\n\nexport class TimeUnitNode extends DataFlowNode {\n  public clone() {\n    return new TimeUnitNode(duplicate(this.formula));\n  }\n\n  constructor(private formula: Dict<TimeUnitComponent>) {\n    super();\n  }\n\n  public static make(model: ModelWithField) {\n    const formula = model.reduceFieldDef((timeUnitComponent: TimeUnitComponent, fieldDef) => {\n      if (fieldDef.type === TEMPORAL && fieldDef.timeUnit) {\n        const f = field(fieldDef);\n        timeUnitComponent[f] = {\n          as: f,\n          timeUnit: fieldDef.timeUnit,\n          field: fieldDef.field\n        };\n      }\n      return timeUnitComponent;\n    }, {} as Dict<TimeUnitComponent>);\n\n    if (Object.keys(formula).length === 0) {\n      return null;\n    }\n\n    return new TimeUnitNode(formula);\n  }\n\n  public merge(other: TimeUnitNode) {\n    this.formula = extend(this.formula, other.formula);\n    other.remove();\n  }\n\n  public producedFields() {\n    const out = {};\n\n    vals(this.formula).forEach(f => {\n      out[f.as] = true;\n    });\n\n    return out;\n  }\n\n  public dependentFields() {\n    const out = {};\n\n    vals(this.formula).forEach(f => {\n      out[f.field] = true;\n    });\n\n    return out;\n  }\n\n  public assemble() {\n    return vals(this.formula).map(c => {\n      return {\n        type: 'formula',\n        as: c.as,\n        expr: fieldExpr(c.timeUnit, c.field)\n      } as VgFormulaTransform;\n    });\n  }\n}\n","import {isArray} from 'vega-util';\nimport {expression, Filter} from '../../filter';\nimport * as log from '../../log';\nimport {CalculateTransform, FilterTransform, isCalculate, isFilter} from '../../transform';\nimport {duplicate} from '../../util';\nimport {VgFilterTransform, VgFormulaTransform} from '../../vega.schema';\nimport {Model} from '../model';\nimport {DataFlowNode} from './dataflow';\n\n\nexport class FilterNode extends DataFlowNode {\n  public clone() {\n    return new FilterNode(duplicate(this.filter));\n  }\n\n  constructor(private filter: Filter | Filter[]) {\n    super();\n  }\n\n  public merge(other: FilterNode) {\n    this.filter = (isArray(this.filter) ? this.filter : [this.filter]).concat(\n      isArray(other.filter) ? other.filter : [other.filter]);\n\n    this.remove();\n  }\n\n  public assemble(): VgFilterTransform {\n    return {\n      type: 'filter',\n      expr: expression(this.filter)\n    };\n  }\n}\n\n/**\n * We don't know what a calculate node depends on so we should never move it beyond anything that produces fields.\n */\nexport class CalculateNode extends DataFlowNode {\n  public clone() {\n    return new CalculateNode(duplicate(this.transform));\n  }\n\n  constructor(private transform: CalculateTransform) {\n    super();\n  }\n\n  public producedFields() {\n    const out = {};\n    out[this.transform.as] = true;\n    return out;\n  }\n\n  public assemble(): VgFormulaTransform {\n    return {\n      type: 'formula',\n      expr: this.transform.calculate,\n      as: this.transform.as\n    };\n  }\n}\n\n/**\n * Parses a transforms array into a chain of connected dataflow nodes.\n */\nexport function parseTransformArray(model: Model) {\n  let first: DataFlowNode;\n  let last: DataFlowNode;\n  let node: DataFlowNode;\n  let previous: DataFlowNode;\n\n  model.transforms.forEach((t, i) => {\n    if (isCalculate(t)) {\n      node = new CalculateNode(t);\n    } else if (isFilter(t)) {\n      node = new FilterNode(t.filter);\n    } else {\n      log.warn(log.message.invalidTransformIgnored(t));\n      return;\n    }\n\n    if (i === 0) {\n      first = node;\n    } else {\n      node.parent = previous;\n    }\n    previous = node;\n  });\n\n  last = node;\n\n  return {first, last};\n}\n","import {Channel, COLUMN, ROW, X, Y} from '../channel';\nimport {Config} from '../config';\nimport {MAIN} from '../data';\nimport {reduce} from '../encoding';\nimport {Facet} from '../facet';\nimport {FieldDef, normalize, title as fieldDefTitle} from '../fielddef';\nimport * as log from '../log';\nimport {FILL_STROKE_CONFIG} from '../mark';\nimport {FacetSpec} from '../spec';\nimport {StackProperties} from '../stack';\nimport {contains, Dict, extend, flatten, keys, vals} from '../util';\nimport {FontWeight, VgSignal} from '../vega.schema';\nimport {\n  isDataRefDomain,\n  isDataRefUnionedDomain,\n  isFieldRefUnionDomain,\n  VgData,\n  VgDataRef,\n  VgEncodeEntry,\n  VgLayout\n} from '../vega.schema';\nimport {parseGridAxis, parseMainAxis} from './axis/parse';\nimport {gridShow} from './axis/rules';\nimport {applyConfig, buildModel, formatSignalRef} from './common';\nimport {assembleData, assembleFacetData, FACET_SCALE_PREFIX} from './data/assemble';\nimport {parseData} from './data/parse';\nimport {getHeaderType, HeaderChannel, HeaderComponent, LayoutHeaderComponent} from './layout/header';\nimport {labels} from './legend/encode';\nimport {Model, ModelWithField} from './model';\nimport {RepeaterValue, replaceRepeaterInFacet} from './repeat';\nimport parseScaleComponent from './scale/parse';\nimport {UnitModel} from './unit';\n\nexport class FacetModel extends ModelWithField {\n  public readonly facet: Facet<string>;\n\n  public readonly child: Model;\n\n  public readonly children: Model[];\n\n  constructor(spec: FacetSpec, parent: Model, parentGivenName: string, repeater: RepeaterValue, config: Config) {\n    super(spec, parent, parentGivenName, config);\n\n    this.child = buildModel(spec.spec, this, this.getName('child'), repeater, config);\n    this.children = [this.child];\n\n    const facet: Facet<string> = replaceRepeaterInFacet(spec.facet, repeater);\n\n    this.facet = this.initFacet(facet);\n  }\n\n  private initFacet(facet: Facet<string>): Facet<string> {\n    // clone to prevent side effect to the original spec\n    return reduce(facet, function(normalizedFacet, fieldDef: FieldDef<string>, channel: Channel) {\n      if (!contains([ROW, COLUMN], channel)) {\n        // Drop unsupported channel\n        log.warn(log.message.incompatibleChannel(channel, 'facet'));\n        return normalizedFacet;\n      }\n\n      if (fieldDef.field === undefined) {\n        log.warn(log.message.emptyFieldDef(fieldDef, channel));\n        return normalizedFacet;\n      }\n\n      // Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.\n      normalizedFacet[channel] = normalize(fieldDef, channel);\n      return normalizedFacet;\n    }, {});\n  }\n\n  public channelHasField(channel: Channel): boolean {\n    return !!this.facet[channel];\n  }\n\n  public hasDiscreteDomain(channel: Channel) {\n    return true;\n  }\n\n  public fieldDef(channel: Channel): FieldDef<string> {\n    return this.facet[channel];\n  }\n\n  public parseData() {\n    this.component.data = parseData(this);\n    this.child.parseData();\n  }\n\n  public parseSelection() {\n    // As a facet has a single child, the selection components are the same.\n    // The child maintains its selections to assemble signals, which remain\n    // within its unit.\n    this.child.parseSelection();\n    this.component.selection = this.child.component.selection;\n  }\n\n  public parseScale() {\n    const child = this.child;\n    const model = this;\n\n    child.parseScale();\n\n    const scaleComponent = this.component.scales = {};\n\n    // Then, move shared/union from its child spec.\n    keys(child.component.scales).forEach(channel => {\n      // TODO: correctly implement independent scale\n      if (true) { // if shared/union scale\n        const scale = scaleComponent[channel] = child.component.scales[channel];\n\n        const scaleNameWithoutPrefix = scale.name.substr(child.getName('').length);\n        const newName = model.scaleName(scaleNameWithoutPrefix, true);\n        child.renameScale(scale.name, newName);\n        scale.name = newName;\n\n        // Replace the scale domain with data output from a cloned subtree after the facet.\n        const domain = scale.domain;\n\n        if (isDataRefDomain(domain) || isFieldRefUnionDomain(domain)) {\n          domain.data = FACET_SCALE_PREFIX + this.getName(domain.data);\n        } else if (isDataRefUnionedDomain(domain)) {\n          domain.fields = domain.fields.map((f: VgDataRef) => {\n            return {\n              ...f,\n              data: FACET_SCALE_PREFIX + this.getName(f.data)\n            };\n          });\n        }\n\n        // Once put in parent, just remove the child's scale.\n        delete child.component.scales[channel];\n      }\n    });\n  }\n\n  public parseMark() {\n    this.child.parseMark();\n\n    this.component.mark = [{\n      name: this.getName('cell'),\n      type: 'group',\n      from: {\n        facet: {\n          name: this.component.data.facetRoot.name,\n          data: this.component.data.facetRoot.data,\n          groupby: [].concat(\n            this.channelHasField(ROW) ? [this.field(ROW)] : [],\n            this.channelHasField(COLUMN) ? [this.field(COLUMN)] : []\n          )\n        }\n      },\n      encode: {\n        update: getFacetGroupProperties(this)\n      }\n    }];\n  }\n\n  public parseAxisAndHeader() {\n    this.child.parseAxisAndHeader();\n\n    this.parseHeader('column');\n    this.parseHeader('row');\n\n    this.mergeChildAxis('x');\n    this.mergeChildAxis('y');\n  }\n\n  private parseHeader(channel: HeaderChannel) {\n\n    if (this.channelHasField(channel)) {\n      const fieldDef = this.facet[channel];\n      let title = fieldDefTitle(fieldDef, this.config);\n\n      if (this.child.component.layoutHeaders[channel].title) {\n        // merge title with child to produce \"Title / Subtitle / Sub-subtitle\"\n        title += ' / ' + this.child.component.layoutHeaders[channel].title;\n        this.child.component.layoutHeaders[channel].title = null;\n      }\n\n      this.component.layoutHeaders[channel] = {\n        title,\n        fieldRef: formatSignalRef(fieldDef, 'parent', this.config, true),\n        // TODO: support adding label to footer as well\n        header: [this.makeHeaderComponent(channel, true)]\n      };\n    }\n  }\n\n  private makeHeaderComponent(channel: HeaderChannel, labels: boolean): HeaderComponent {\n    const sizeChannel = channel === 'row' ? 'height' : 'width';\n\n    return {\n      labels,\n      sizeSignal: this.child.getSizeSignalRef(sizeChannel),\n      axes: []\n    };\n  }\n\n  private mergeChildAxis(channel: 'x' | 'y') {\n    const {child} = this;\n    if (child.component.axes[channel]) {\n      // TODO: read these from the resolve syntax\n      const scaleResolve = 'shared';\n      const axisResolve = 'shared';\n\n      if (scaleResolve === 'shared' && axisResolve === 'shared') {\n        // For shared axis, move the axes to facet's header or footer\n        const headerChannel = channel === 'x' ? 'column' : 'row';\n\n        const layoutHeader = this.component.layoutHeaders[headerChannel];\n        for (const axis of child.component.axes[channel].axes) {\n          const headerType = getHeaderType(axis.orient);\n          layoutHeader[headerType] = layoutHeader[headerType] ||\n            [this.makeHeaderComponent(headerChannel, false)];\n          layoutHeader[headerType][0].axes.push(axis);\n        }\n        child.component.axes[channel].axes = [];\n      } else {\n        // Otherwise do nothing for independent axes\n      }\n    }\n  }\n\n  public parseLegend() {\n    this.child.parseLegend();\n\n    // TODO: support legend for independent non-position scale across facets\n    // TODO: support legend for field reference of parent data (e.g., for SPLOM)\n\n    // For now, assuming that non-positional scales are always shared across facets\n    // Thus, just move all legends from its child\n    this.component.legends = this.child.component.legends;\n    this.child.component.legends = {};\n  }\n\n  public assembleData(): VgData[] {\n    if (!this.parent) {\n      // only assemble data in the root\n      return assembleData(vals(this.component.data.sources));\n    }\n\n    return [];\n  }\n\n  public assembleParentGroupProperties(): any {\n    return null;\n  }\n\n  public assembleSelectionTopLevelSignals(signals: any[]): VgSignal[] {\n    return this.child.assembleSelectionTopLevelSignals(signals);\n  }\n\n  public assembleSelectionSignals(): VgSignal[] {\n    return this.child.assembleSelectionSignals();\n  }\n\n  public assembleSelectionData(data: VgData[]): VgData[] {\n    return this.child.assembleSelectionData(data);\n  }\n\n  public assembleLayout(): VgLayout {\n    const columns = this.channelHasField('column') ? {\n      signal: this.columnDistinctSignal()\n    } : 1;\n\n    // TODO: determine default align based on shared / independent scales\n\n    return {\n      padding: {row: 10, column: 10},\n\n      // TODO: support offset for rowHeader/rowFooter/rowTitle/columnHeader/columnFooter/columnTitle\n      offset: 10,\n      columns,\n      bounds: 'full'\n    };\n  }\n\n  public assembleLayoutSignals(): VgSignal[] {\n    // FIXME(https://github.com/vega/vega-lite/issues/1193): this can be incorrect if we have independent scales.\n    return this.child.assembleLayoutSignals();\n  }\n\n  private columnDistinctSignal() {\n    // In facetNode.assemble(), the name is always this.getName('column') + '_layout'.\n    const facetLayoutDataName = this.getName('column') + '_layout';\n    const columnDistinct = this.field('column',  {prefix: 'distinct'});\n    return `data('${facetLayoutDataName}')[0].${columnDistinct}`;\n  }\n\n  public assembleMarks(): VgEncodeEntry[] {\n    const facetRoot = this.component.data.facetRoot;\n    const data = assembleFacetData(facetRoot);\n\n    const mark = this.component.mark[0];\n\n    // correct the name of the faceted data source\n    mark.from.facet = {\n      ...mark.from.facet,\n      name: facetRoot.name,\n      data: facetRoot.data\n    };\n\n    const marks = [{\n      ...(data.length > 0 ? {data: data} : {}),\n      ...mark,\n      ...this.child.assembleGroup()\n    }];\n\n    return marks.map(this.correctDataNames);\n  }\n\n  public channels() {\n    return [ROW, COLUMN];\n  }\n\n  protected getMapping() {\n    return this.facet;\n  }\n}\n\nexport function hasSubPlotWithXy(model: FacetModel) {\n  return model.hasDescendantWithFieldOnChannel('x') ||\n    model.hasDescendantWithFieldOnChannel('y');\n}\n\nfunction childSizeEncodeEntryMixins(model: FacetModel, sizeType: 'width' | 'height') {\n  return {[sizeType]: model.child.getSizeSignalRef(sizeType)};\n}\n\n// FIXME(https://github.com/vega/vega-lite/issues/2041): revise this.\nfunction getFacetGroupProperties(model: FacetModel) {\n  const child = model.child;\n\n  return {\n    ...childSizeEncodeEntryMixins(model, 'width'),\n    ...childSizeEncodeEntryMixins(model, 'height'),\n\n    // FIXME revise if we really need hasSubPlotWithXy()\n    ...(hasSubPlotWithXy(model) ? child.assembleParentGroupProperties() : {}),\n\n    ...applyConfig({}, model.config.facet.cell, FILL_STROKE_CONFIG.concat(['clip']))\n  };\n}\n","import {Axis} from '../axis';\nimport {Channel} from '../channel';\nimport {CellConfig, Config} from '../config';\nimport {FieldDef} from '../fielddef';\nimport {Legend} from '../legend';\nimport {FILL_STROKE_CONFIG} from '../mark';\nimport {Scale} from '../scale';\nimport {LayerSpec} from '../spec';\nimport {StackProperties} from '../stack';\nimport {Dict, flatten, keys, vals} from '../util';\nimport {isSignalRefDomain, VgData, VgEncodeEntry, VgLayout, VgScale, VgSignal} from '../vega.schema';\n\nimport {applyConfig, buildModel} from './common';\nimport {assembleData} from './data/assemble';\nimport {parseData} from './data/parse';\nimport {assembleLayoutLayerSignals} from './layout/index';\nimport {Model} from './model';\nimport {RepeaterValue} from './repeat';\nimport {unionDomains} from './scale/domain';\nimport {assembleLayerSelectionMarks} from './selection/selection';\nimport {UnitModel} from './unit';\n\n\nexport class LayerModel extends Model {\n  public readonly children: UnitModel[];\n\n  /**\n   * Fixed width for the unit visualization.\n   * If undefined (e.g., for ordinal scale), the width of the\n   * visualization will be calculated dynamically.\n   */\n  public readonly width: number;\n\n  /**\n   * Fixed height for the unit visualization.\n   * If undefined (e.g., for ordinal scale), the height of the\n   * visualization will be calculated dynamically.\n   */\n  public readonly height: number;\n\n  constructor(spec: LayerSpec, parent: Model, parentGivenName: string, repeater: RepeaterValue, config: Config) {\n\n    super(spec, parent, parentGivenName, config);\n\n    this.width = spec.width;\n    this.height = spec.height;\n\n    this.children = spec.layer.map((layer, i) => {\n      // FIXME: this is not always the case\n      // we know that the model has to be a unit model because we pass in a unit spec\n      return buildModel(layer, this, this.getName('layer_' + i), repeater, config) as UnitModel;\n    });\n  }\n\n  public parseData() {\n    this.component.data = parseData(this);\n    for (const child of this.children) {\n      child.parseData();\n    }\n  }\n\n  public parseSelection() {\n    // Merge selections up the hierarchy so that they may be referenced\n    // across unit specs. Persist their definitions within each child\n    // to assemble signals which remain within output Vega unit groups.\n    this.component.selection = {};\n    for (const child of this.children) {\n      child.parseSelection();\n      keys(child.component.selection).forEach((key) => {\n        this.component.selection[key] = child.component.selection[key];\n      });\n    }\n  }\n\n  public parseScale(this: LayerModel) {\n    const model = this;\n\n    const scaleComponent: Dict<VgScale> = this.component.scales = {};\n\n    for (const child of this.children) {\n      child.parseScale();\n\n      // FIXME(#1602): correctly implement independent scale\n      // Also need to check whether the scales are actually compatible, e.g. use the same sort or throw error\n      if (true) { // if shared/union scale\n        keys(child.component.scales).forEach(function(channel) {\n          const childScale = child.component.scales[channel];\n          const modelScale = scaleComponent[channel];\n\n          if (!childScale || isSignalRefDomain(childScale.domain) || (modelScale && isSignalRefDomain(modelScale.domain))) {\n            // TODO: merge signal ref domains\n            return;\n          }\n\n          if (modelScale) {\n            modelScale.domain = unionDomains(modelScale.domain, childScale.domain);\n          } else {\n            scaleComponent[channel] = childScale;\n          }\n\n          // rename child scale to parent scales\n          const scaleNameWithoutPrefix = childScale.name.substr(child.getName('').length);\n          const newName = model.scaleName(scaleNameWithoutPrefix, true);\n          child.renameScale(childScale.name, newName);\n          childScale.name = newName;\n\n          // remove merged scales from children\n          delete child.component.scales[channel];\n        });\n      }\n    }\n  }\n\n  public parseMark() {\n    for (const child of this.children) {\n      child.parseMark();\n    }\n  }\n\n  public parseAxisAndHeader() {\n    const axisComponent = this.component.axes = {};\n\n    for (const child of this.children) {\n      child.parseAxisAndHeader();\n      keys(child.component.axes).forEach(channel => {\n        // TODO: read these from the resolve syntax\n        const axisResolve = 'shared';\n        const scaleResolve = 'shared';\n\n        if (scaleResolve === 'shared' && axisResolve === 'shared') {\n          // If shared/union axis (only possible if the scale is shared in the first place)\n\n          // Just use the first axes definition for each channel\n          // TODO: what if the axes from different children are not compatible\n          if (!axisComponent[channel]) {\n            axisComponent[channel] = child.component.axes[channel];\n            delete child.component.axes[channel];\n          }\n        } else {\n          // Otherwise do nothing for independent axes\n        }\n      });\n    }\n  }\n\n  public parseLegend() {\n    const legendComponent = this.component.legends = {};\n\n    for (const child of this.children) {\n      child.parseLegend();\n\n      // TODO: correctly implement independent axes\n      if (true) { // if shared/union scale\n        keys(child.component.legends).forEach(channel => {\n          // just use the first legend definition for each channel\n          if (!legendComponent[channel]) {\n            legendComponent[channel] = child.component.legends[channel];\n          }\n        });\n      }\n    }\n  }\n\n  public assembleParentGroupProperties(): VgEncodeEntry {\n    return applyConfig({}, this.config.cell, FILL_STROKE_CONFIG.concat(['clip']));\n  }\n\n  public assembleSelectionTopLevelSignals(signals: any[]): VgSignal[] {\n    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);\n  }\n\n  // TODO: Support same named selections across children.\n  public assembleSelectionSignals(): VgSignal[] {\n    return this.children.reduce((signals, child) => {\n      return signals.concat(child.assembleSelectionSignals());\n    }, []);\n  }\n\n\n  public assembleLayoutSignals(): VgSignal[] {\n    return this.children.reduce((signals, child) => {\n      return signals.concat(child.assembleLayoutSignals());\n    }, assembleLayoutLayerSignals(this));\n  }\n\n  public assembleSelectionData(data: VgData[]): VgData[] {\n    return this.children.reduce((db, child) => child.assembleSelectionData(db), []);\n  }\n\n  public assembleData(): VgData[] {\n     if (!this.parent) {\n      // only assemble data in the root\n      return assembleData(vals(this.component.data.sources));\n    }\n    return [];\n  }\n\n  public assembleScales(): VgScale[] {\n    // combine with scales from children\n    return this.children.reduce((scales, c) => {\n      return scales.concat(c.assembleScales());\n    }, super.assembleScales());\n  }\n\n  public assembleLayout(): VgLayout {\n    return null;\n  }\n\n  public assembleMarks(): any[] {\n    return assembleLayerSelectionMarks(this, flatten(this.children.map((child) => {\n      return child.assembleMarks();\n    })));\n  }\n}\n","/**\n * Utility for generating row / column headers\n */\nimport {AxisOrient} from '../../axis';\nimport {contains} from '../../util';\nimport {Orient, VgAxis, VgEncodeEntry, VgMarkGroup, VgValueRef} from '../../vega.schema';\nimport {FacetModel} from '../facet';\nimport {Model} from '../model';\n\n\nexport type HeaderChannel = 'row' | 'column';\nexport const HEADER_CHANNELS: HeaderChannel[] = ['row', 'column'];\n\nexport type HeaderType = 'header' | 'footer';\nexport const HEADER_TYPES: HeaderType[] = ['header', 'footer'];\n\n/**\n * A component that represents all header, footers and title of a Vega group with layout directive.\n */\nexport interface LayoutHeaderComponent {\n  title?: string;\n\n  /**\n   * Field that is used to drive a header group (for facet only).\n   */\n  fieldRef?: {signal: string};\n\n  // TODO: repeat and concat can have multiple header / footer.\n  // Need to redesign this part a bit.\n\n  /**\n   * An array of header components for headers.\n   * For facet, there should be only one header component, which is data-driven.\n   * For repeat and concat, there can be multiple header components that explicitly list different axes.\n   */\n  header?: HeaderComponent[];\n\n  /**\n   * An array of header components for footers.\n   * For facet, there should be only one header component, which is data-driven.\n   * For repeat and concat, there can be multiple header components that explicitly list different axes.\n   */\n  footer?: HeaderComponent[];\n}\n\n/**\n * A component that represents one group of row/column-header/footer.\n */\nexport interface HeaderComponent {\n\n  labels: boolean;\n\n  sizeSignal: {signal: string};\n\n  axes: VgAxis[];\n}\n\nexport function getHeaderType(orient: AxisOrient) {\n  if (orient === 'top' || orient === 'left') {\n    return 'header';\n  }\n  return 'footer';\n}\n\nexport function getTitleGroup(model: Model, channel: HeaderChannel) {\n  const sizeChannel = channel === 'row' ? 'height' : 'width';\n  const title = model.component.layoutHeaders[channel].title;\n  const positionChannel = channel === 'row' ? 'y' : 'x';\n  const align = channel === 'row' ? 'right' : 'center';\n  const textOrient = channel === 'row' ? 'vertical' : undefined;\n\n  return {\n    name:  model.getName(`${channel}_title`),\n    role: `${channel}-title`,\n    type: 'group',\n    marks: [{\n      type: 'text',\n      role: `${channel}-title-text`,\n      encode: {\n        update: {\n          // TODO: add title align\n          [positionChannel]: {signal: `0.5 * ${sizeChannel}`},\n          align: {value: align},\n          text: {value: title},\n          fill: {value: 'black'},\n          fontWeight: {value: 'bold'},\n          ...(textOrient === 'vertical' ? {angle: {value: 270}} : {}),\n        }\n      }\n    }]\n  };\n}\n\nexport function getHeaderGroup(model: Model, channel: HeaderChannel, headerType: HeaderType, layoutHeader: LayoutHeaderComponent, header: HeaderComponent) {\n  if (header) {\n    let title = null;\n    if (layoutHeader.fieldRef && header.labels) {\n      title = {\n        text: layoutHeader.fieldRef,\n        offset: 10,\n        orient: channel === 'row' ? 'left' : 'top',\n        encode: {\n          update: {\n            fontWeight: {value: 'normal'},\n            angle: {value: 0},\n            fontSize: {value: 10}, // default label font size\n            ... (channel === 'row' ? {\n              align: {value: 'right'},\n              baseline: {value: 'middle'}\n            } : {})\n          }\n        }\n      };\n    }\n\n    const axes = header.axes;\n\n    const hasAxes = axes && axes.length > 0;\n    if (title || hasAxes) {\n      const sizeChannel = channel === 'row' ? 'height' : 'width';\n\n      return {\n        name: model.getName(`${channel}_${headerType}`),\n        type: 'group',\n        role: `${channel}-${headerType}`,\n        ...(layoutHeader.fieldRef ? {from: {data: model.getName(channel)}} : {}),\n        ...(title ? {title} : {}),\n        encode: {\n          update: {\n            [sizeChannel]: header.sizeSignal\n          }\n        },\n        ...(hasAxes ? {axes} : {})\n      };\n    }\n  }\n  return null;\n}\n","\nimport {Channel, COLUMN, ROW, X, Y} from '../../channel';\nimport {MAIN} from '../../data';\nimport {hasDiscreteDomain} from '../../scale';\nimport {extend, isArray, keys, StringSet} from '../../util';\nimport {VgData, VgFormulaTransform, VgSignal, VgTransform} from '../../vega.schema';\n\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {Model, ModelWithField} from '../model';\nimport {UnitModel} from '../unit';\n\n\n// TODO: rewrite this such that we merge redundant signals\nexport function assembleLayoutLayerSignals(model: LayerModel): VgSignal[] {\n  return [\n    {name: model.getName('width'), update: layerSizeExpr(model, 'width')},\n    {name: model.getName('height'), update: layerSizeExpr(model, 'height')}\n  ];\n}\n\nexport function layerSizeExpr(model: LayerModel, sizeType: 'width' | 'height'): string {\n  const childrenSizeSignals = model.children.map(child => child.getName(sizeType)).join(', ');\n  return `max(${childrenSizeSignals})`;\n}\n\nexport function assembleLayoutUnitSignals(model: UnitModel): VgSignal[] {\n  return [\n    {name: model.getName('width'), update: unitSizeExpr(model, 'width')},\n    {name: model.getName('height'), update: unitSizeExpr(model, 'height')}\n  ];\n}\n\nexport function unitSizeExpr(model: UnitModel, sizeType: 'width' | 'height'): string {\n  const channel = sizeType==='width' ? 'x' : 'y';\n  const scale = model.scale(channel);\n  if (scale) {\n    if (hasDiscreteDomain(scale.type) && scale.rangeStep) {\n      const scaleName = model.scaleName(channel);\n\n      const cardinality = `domain('${scaleName}').length`;\n      const paddingOuter = scale.paddingOuter !== undefined ? scale.paddingOuter : scale.padding;\n      const paddingInner = scale.type === 'band' ?\n        // only band has real paddingInner\n        (scale.paddingInner !== undefined ? scale.paddingInner : scale.padding) :\n        // For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,\n        // it's equivalent to have paddingInner = 1 since there is only n-1 steps between n points.\n        1;\n\n      return `bandspace(${cardinality}, ${paddingInner}, ${paddingOuter}) * ${scale.rangeStep}`;\n    }\n  }\n  return `${model[sizeType]}`;\n}\n\n","import {Channel, COLOR, SHAPE} from '../../channel';\nimport {FieldDef, isValueDef} from '../../fielddef';\nimport {AREA, BAR, CIRCLE, FILL_STROKE_CONFIG, LINE, POINT, SQUARE, TEXT, TICK} from '../../mark';\nimport {TEMPORAL} from '../../type';\nimport {extend, keys, without} from '../../util';\n\nimport {VgValueRef} from '../../vega.schema';\n\nimport {applyMarkConfig, timeFormatExpression} from '../common';\nimport {UnitModel} from '../unit';\n\nexport function symbols(fieldDef: FieldDef<string>, symbolsSpec: any, model: UnitModel, channel: Channel) {\n  let symbols:any = {};\n  const mark = model.mark();\n\n  switch (mark) {\n    case BAR:\n    case TICK:\n    case TEXT:\n      symbols.shape = {value: 'square'};\n      break;\n    case CIRCLE:\n    case SQUARE:\n      symbols.shape = {value: mark};\n      break;\n    case POINT:\n    case LINE:\n    case AREA:\n      // use default circle\n      break;\n  }\n\n  const cfg = model.config;\n  const filled = model.markDef.filled;\n\n  let config = channel === COLOR ?\n      /* For color's legend, do not set fill (when filled) or stroke (when unfilled) property from config because the legend's `fill` or `stroke` scale should have precedence */\n      without(FILL_STROKE_CONFIG, [ filled ? 'fill' : 'stroke', 'strokeDash', 'strokeDashOffset']) :\n      /* For other legend, no need to omit. */\n      FILL_STROKE_CONFIG;\n\n  config = without(config, ['strokeDash', 'strokeDashOffset']);\n\n  applyMarkConfig(symbols, model, config);\n\n  if (filled) {\n    symbols.strokeWidth = {value: 0};\n  }\n\n  let value: VgValueRef;\n  const colorDef = model.encoding.color;\n  if (isValueDef(colorDef)) {\n    value = {value: colorDef.value};\n  }\n\n  if (value !== undefined) {\n    // apply the value\n    if (filled) {\n      symbols.fill = value;\n    } else {\n      symbols.stroke = value;\n    }\n  } else if (channel !== COLOR) {\n    // For non-color legend, apply color config if there is no fill / stroke config.\n    // (For color, do not override scale specified!)\n    symbols[filled ? 'fill' : 'stroke'] = symbols[filled ? 'fill' : 'stroke'] ||\n      {value: cfg.mark.color};\n  }\n\n  if (symbols.fill === undefined) {\n    // fall back to mark config colors for legend fill\n    if (cfg.mark.fill !== undefined) {\n      symbols.fill = {value: cfg.mark.fill};\n    } else if (cfg.mark.stroke !== undefined) {\n      symbols.stroke = {value: cfg.mark.stroke};\n    }\n  }\n\n  const shapeDef = model.encoding.shape;\n  if (channel !== SHAPE) {\n    if (isValueDef(shapeDef)) {\n      symbols.shape = {value: shapeDef.value};\n    }\n  }\n\n  symbols = extend(symbols, symbolsSpec || {});\n\n  return keys(symbols).length > 0 ? symbols : undefined;\n}\n\nexport function labels(fieldDef: FieldDef<string>, labelsSpec: any, model: UnitModel, channel: Channel) {\n  const legend = model.legend(channel);\n  const config = model.config;\n\n  let labels:any = {};\n\n  if (fieldDef.type === TEMPORAL) {\n    labelsSpec = extend({\n      text: {\n        signal: timeFormatExpression('datum.value', fieldDef.timeUnit, legend.format, config.legend.shortTimeLabels, config.timeFormat)\n      }\n    }, labelsSpec || {});\n  }\n\n  labels = extend(labels, labelsSpec || {});\n\n  return keys(labels).length > 0 ? labels : undefined;\n}\n\n","import {Channel, COLOR, OPACITY, SHAPE, SIZE} from '../../channel';\nimport {Legend, LEGEND_PROPERTIES} from '../../legend';\nimport {Dict, keys} from '../../util';\nimport {VgLegend} from '../../vega.schema';\n\nimport {numberFormat} from '../common';\nimport {UnitModel} from '../unit';\n\nimport * as encode from './encode';\nimport * as rules from './rules';\n\nexport function parseLegendComponent(model: UnitModel): Dict<VgLegend> {\n  return [COLOR, SIZE, SHAPE, OPACITY].reduce(function(legendComponent, channel) {\n    if (model.legend(channel)) {\n      legendComponent[channel] = parseLegend(model, channel);\n    }\n    return legendComponent;\n  }, {});\n}\n\nfunction getLegendDefWithScale(model: UnitModel, channel: Channel): VgLegend {\n  // For binned field with continuous scale, use a special scale so we can overrride the mark props and labels\n  switch (channel) {\n    case COLOR:\n      const scale = model.scaleName(COLOR);\n      return model.markDef.filled ? {fill: scale} : {stroke: scale};\n    case SIZE:\n      return {size: model.scaleName(SIZE)};\n    case SHAPE:\n      return {shape: model.scaleName(SHAPE)};\n    case OPACITY:\n      return {opacity: model.scaleName(OPACITY)};\n  }\n  return null;\n}\n\nexport function parseLegend(model: UnitModel, channel: Channel): VgLegend {\n  const fieldDef = model.fieldDef(channel);\n  const legend = model.legend(channel);\n\n  const def: VgLegend = getLegendDefWithScale(model, channel);\n\n  LEGEND_PROPERTIES.forEach(function(property) {\n    const value = getSpecifiedOrDefaultValue(property, legend, channel, model);\n    if (value !== undefined) {\n      def[property] = value;\n    }\n  });\n\n  // 2) Add mark property definition groups\n  const encodeSpec = legend.encode || {};\n  ['labels', 'legend', 'title', 'symbols'].forEach(function(part) {\n    const value = encode[part] ?\n      encode[part](fieldDef, encodeSpec[part], model, channel) : // apply rule\n      encodeSpec[part]; // no rule -- just default values\n    if (value !== undefined && keys(value).length > 0) {\n      def.encode = def.encode || {};\n      def.encode[part] = {update: value};\n    }\n  });\n\n  return def;\n}\n\nfunction getSpecifiedOrDefaultValue(property: keyof VgLegend, specifiedLegend: Legend, channel: Channel, model: UnitModel) {\n  const fieldDef = model.fieldDef(channel);\n\n  switch (property) {\n    case 'format':\n      return numberFormat(fieldDef, specifiedLegend.format, model.config, channel);\n    case 'title':\n      return rules.title(specifiedLegend, fieldDef, model.config);\n    case 'values':\n      return rules.values(specifiedLegend);\n    case 'type':\n      return rules.type(specifiedLegend, fieldDef.type, channel, model.scale(channel).type);\n  }\n\n  // Otherwise, return specified property.\n  return specifiedLegend[property];\n}\n\n","import {Channel, COLOR} from '../../channel';\nimport {Config} from '../../config';\nimport {DateTime, isDateTime, timestamp} from '../../datetime';\nimport {FieldDef} from '../../fielddef';\nimport {title as fieldTitle} from '../../fielddef';\nimport {Legend} from '../../legend';\nimport {isBinScale, ScaleType} from '../../scale';\nimport {Type} from '../../type';\nimport {contains} from '../../util';\n\nexport function title(legend: Legend, fieldDef: FieldDef<string>, config: Config) {\n  if (legend.title !== undefined) {\n    return legend.title;\n  }\n\n  return fieldTitle(fieldDef, config);\n}\n\nexport function values(legend: Legend) {\n  const vals = legend.values;\n  if (vals && isDateTime(vals[0])) {\n    return (vals as DateTime[]).map((dt) => {\n      // normalize = true as end user won't put 0 = January\n      return timestamp(dt, true);\n    });\n  }\n  return vals;\n}\n\nexport function type(legend: Legend, type: Type, channel: Channel, scaleType: ScaleType) {\n  if (legend.type) {\n    return legend.type;\n  }\n  if (channel === COLOR && ((type === 'quantitative' && !isBinScale(scaleType)) || (type === 'temporal' && contains<ScaleType>(['time', 'utc'], scaleType)))) {\n    return 'gradient';\n  }\n  return undefined;\n}\n","import {UnitModel} from '../unit';\nimport * as mixins from './mixins';\n\nimport {MarkCompiler} from './base';\n\nexport const area: MarkCompiler = {\n  vgMark: 'area',\n  defaultRole: undefined,\n  encodeEntry: (model: UnitModel) => {\n    return {\n      ...mixins.pointPosition('x', model, 'zeroOrMin'),\n      ...mixins.pointPosition('y', model, 'zeroOrMin'),\n      ...mixins.pointPosition2(model, 'zeroOrMin'),\n\n      ...mixins.color(model),\n      ...mixins.nonPosition('opacity', model),\n      ...mixins.markDefProperties(model.markDef, ['orient', 'interpolate', 'tension']),\n    };\n  }\n};\n","import {X, Y} from '../../channel';\nimport {Config} from '../../config';\nimport {isFieldDef} from '../../fielddef';\nimport * as log from '../../log';\nimport {isBinScale, Scale, ScaleType} from '../../scale';\nimport {StackProperties} from '../../stack';\nimport {VgEncodeEntry} from '../../vega.schema';\n\nimport {VgValueRef} from '../../vega.schema';\nimport {UnitModel} from '../unit';\nimport * as mixins from './mixins';\n\nimport {MarkCompiler} from './base';\nimport * as ref from './valueref';\n\nexport const bar: MarkCompiler = {\n  vgMark: 'rect',\n  defaultRole: 'bar',\n  encodeEntry: (model: UnitModel) => {\n    const stack = model.stack;\n    return {\n      ...x(model, stack),\n      ...y(model, stack),\n      ...mixins.color(model),\n      ...mixins.nonPosition('opacity', model)\n    };\n  }\n};\n\nfunction x(model: UnitModel, stack: StackProperties): VgEncodeEntry {\n  const {config, width} = model;\n  const orient = model.markDef.orient;\n  const sizeDef = model.encoding.size;\n\n  const xDef = model.encoding.x;\n  const xScaleName = model.scaleName(X);\n  const xScale = model.scale(X);\n  // x, x2, and width -- we must specify two of these in all conditions\n  if (orient === 'horizontal') {\n    return {\n      ...mixins.pointPosition('x', model, 'zeroOrMin'),\n      ...mixins.pointPosition2(model, 'zeroOrMin'),\n    };\n  } else { // vertical\n    if (isFieldDef(xDef)) {\n      if (!sizeDef && isBinScale(xScale.type)) {\n        return mixins.binnedPosition('x', model, config.bar.binSpacing);\n      } else if (xScale.type === ScaleType.BAND) {\n        return mixins.bandPosition('x', model);\n      }\n    }\n    // sized bin, normal point-ordinal axis, quantitative x-axis, or no x\n\n    return mixins.centeredBandPosition('x', model,\n      {...ref.midX(width, config)},\n      defaultSizeRef(xScaleName, model.scale(X), config)\n    );\n  }\n}\n\nfunction y(model: UnitModel, stack: StackProperties) {\n  const {config, encoding, height} = model;\n  const orient = model.markDef.orient;\n  const sizeDef = encoding.size;\n\n  const yDef = encoding.y;\n  const yScaleName = model.scaleName(Y);\n  const yScale = model.scale(Y);\n  // y, y2 & height -- we must specify two of these in all conditions\n  if (orient === 'vertical') {\n    return {\n      ...mixins.pointPosition('y', model, 'zeroOrMin'),\n      ...mixins.pointPosition2(model, 'zeroOrMin'),\n    };\n  } else {\n    if (isFieldDef(yDef)) {\n      if (yDef.bin && !sizeDef) {\n        return mixins.binnedPosition('y', model, config.bar.binSpacing);\n      } else if (yScale.type === ScaleType.BAND) {\n        return mixins.bandPosition('y', model);\n      }\n    }\n    return mixins.centeredBandPosition('y', model, ref.midY(height, config), defaultSizeRef(yScaleName, model.scale(Y), config));\n  }\n}\n\nfunction defaultSizeRef(scaleName: string, scale: Scale, config: Config): VgValueRef {\n  if (config.bar.discreteBandSize) {\n    return {value: config.bar.discreteBandSize};\n  }\n\n  if (scale) {\n    if (scale.type === ScaleType.POINT) {\n      if (scale.rangeStep !== null) {\n        return {value: scale.rangeStep - 1};\n      }\n      log.warn(log.message.BAR_WITH_POINT_SCALE_AND_RANGESTEP_NULL);\n    } else if (scale.type === ScaleType.BAND) {\n      return ref.band(scaleName);\n    } else { // non-ordinal scale\n      return {value: config.bar.continuousBandSize};\n    }\n  }\n  if (config.scale.rangeStep && config.scale.rangeStep !== null) {\n    return {value: config.scale.rangeStep - 1};\n  }\n  // TODO: this should depends on cell's width / height?\n  return {value: 20};\n}\n\n","import {Config} from '../../config';\nimport {Encoding, isAggregate} from '../../encoding';\nimport {FieldDef, isContinuous, isFieldDef} from '../../fielddef';\nimport * as log from '../../log';\nimport {AREA, BAR, CIRCLE, isMarkDef, LINE, Mark, MarkDef, Orient, POINT, RECT, RULE, SQUARE, TEXT, TICK} from '../../mark';\nimport {hasDiscreteDomain, Scale} from '../../scale';\nimport {StackProperties} from '../../stack';\nimport {TEMPORAL} from '../../type';\nimport {contains, Dict} from '../../util';\nimport {getMarkConfig} from '../common';\n\nexport function initMarkDef(mark: Mark | MarkDef, encoding: Encoding<string>, scale: Dict<Scale>, config: Config): MarkDef {\n  const markDef = isMarkDef(mark) ? {...mark} : {type: mark};\n\n  const specifiedOrient = markDef.orient || getMarkConfig('orient', markDef.type, config);\n  markDef.orient = orient(markDef.type, encoding, scale, specifiedOrient);\n  if (specifiedOrient !== undefined && specifiedOrient !== markDef.orient) {\n    log.warn(log.message.orientOverridden(markDef.orient,specifiedOrient));\n  }\n\n  const specifiedFilled = markDef.filled;\n  if (specifiedFilled === undefined) {\n    markDef.filled = filled(markDef.type, config);\n  }\n\n  return markDef;\n}\n\n/**\n * Initialize encoding's value with some special default values\n */\nexport function initEncoding(mark: Mark, encoding: Encoding<string>, stacked: StackProperties, config: Config): Encoding<string> {\n  const opacityConfig = getMarkConfig('opacity', mark, config);\n  if (!encoding.opacity && opacityConfig === undefined) {\n    const opacity = defaultOpacity(mark, encoding, stacked);\n    if (opacity !== undefined) {\n      encoding.opacity = {value: opacity};\n    }\n  }\n  return encoding;\n}\n\n\nfunction defaultOpacity(mark: Mark, encoding: Encoding<string>, stacked: StackProperties) {\n  if (contains([POINT, TICK, CIRCLE, SQUARE], mark)) {\n    // point-based marks\n    if (!isAggregate(encoding)) {\n      return 0.7;\n    }\n  }\n  return undefined;\n}\n\nfunction filled(mark: Mark, config: Config) {\n  const filledConfig = getMarkConfig('filled', mark, config);\n  return filledConfig !== undefined ? filledConfig : mark !== POINT && mark !== LINE && mark !== RULE;\n}\n\nfunction orient(mark: Mark, encoding: Encoding<string>, scale: Dict<Scale>, specifiedOrient: Orient): Orient {\n  switch (mark) {\n    case POINT:\n    case CIRCLE:\n    case SQUARE:\n    case TEXT:\n    case RECT:\n      // orient is meaningless for these marks.\n      return undefined;\n  }\n\n  const yIsRange = encoding.y && encoding.y2;\n  const xIsRange = encoding.x && encoding.x2;\n\n  switch (mark) {\n    case TICK:\n      const xScaleType = scale['x'] ? scale['x'].type : null;\n      const yScaleType = scale['y'] ? scale['y'].type : null;\n\n      // Tick is opposite to bar, line, area and never have ranged mark.\n      if (!hasDiscreteDomain(xScaleType) && (\n            !encoding.y ||\n            hasDiscreteDomain(yScaleType) ||\n            (isFieldDef(encoding.y) && encoding.y.bin)\n        )) {\n        return 'vertical';\n      }\n      // y:Q or Ambiguous case, return horizontal\n      return 'horizontal';\n\n    case RULE:\n    case BAR:\n    case AREA:\n      // If there are range for both x and y, y (vertical) has higher precedence.\n      if (yIsRange) {\n        return 'vertical';\n      } else if (xIsRange) {\n        return 'horizontal';\n      } else if (mark === RULE) {\n        if (encoding.x && !encoding.y) {\n          return 'vertical';\n        } else if (encoding.y && !encoding.x) {\n          return 'horizontal';\n        }\n      }\n\n      /* tslint:disable */\n    case LINE: // intentional fall through\n      /* tslint:enable */\n      const xIsContinuous = isFieldDef(encoding.x) && isContinuous(encoding.x);\n      const yIsContinuous = isFieldDef(encoding.y) && isContinuous(encoding.y);\n      if (xIsContinuous && !yIsContinuous) {\n        return 'horizontal';\n      } else if (!xIsContinuous && yIsContinuous) {\n        return 'vertical';\n      } else if (xIsContinuous && yIsContinuous) {\n        const xDef = encoding.x as FieldDef<string>; // we can cast here since they are surely fieldDef\n        const yDef = encoding.y as FieldDef<string>;\n\n        const xIsTemporal = xDef.type === TEMPORAL;\n        const yIsTemporal = yDef.type === TEMPORAL;\n\n        // temporal without timeUnit is considered continuous, but better serves as dimension\n        if (xIsTemporal && !yIsTemporal) {\n          return 'vertical';\n        } else if (!xIsTemporal && yIsTemporal) {\n          return 'horizontal';\n        }\n\n        if (!xDef.aggregate && yDef.aggregate) {\n          return 'vertical';\n        } else if (xDef.aggregate && !yDef.aggregate) {\n          return 'horizontal';\n        }\n\n        if (specifiedOrient) {\n          // When ambiguous, use user specified one.\n          return specifiedOrient;\n        }\n\n        if (!(mark === LINE && encoding.order)) {\n          // Except for connected scatterplot, we should log warning for unclear orientation of QxQ plots.\n          log.warn(log.message.unclearOrientContinuous(mark));\n        }\n        return 'vertical';\n      } else {\n        // For Discrete x Discrete case, return undefined.\n        log.warn(log.message.unclearOrientDiscreteOrEmpty(mark));\n        return undefined;\n      }\n  }\n  return 'vertical';\n}\n","import {UnitModel} from '../unit';\nimport * as mixins from './mixins';\n\nimport {MarkCompiler} from './base';\n\nexport const line: MarkCompiler = {\n  vgMark: 'line',\n  defaultRole: undefined,\n  encodeEntry: (model: UnitModel) => {\n    return {\n      ...mixins.pointPosition('x', model, 'zeroOrMin'),\n      ...mixins.pointPosition('y', model, 'zeroOrMin'),\n      ...mixins.color(model),\n      ...mixins.nonPosition('opacity', model),\n      ...mixins.nonPosition('size', model, {\n        vgChannel: 'strokeWidth'  // VL's line size is strokeWidth\n      }),\n      ...mixins.markDefProperties(model.markDef, ['interpolate', 'tension'])\n    };\n  }\n};\n","import {LEVEL_OF_DETAIL_CHANNELS} from '../../channel';\nimport {AREA, LINE} from '../../mark';\nimport {contains} from '../../util';\n\nimport {area} from './area';\nimport {bar} from './bar';\nimport {MarkCompiler} from './base';\nimport {line} from './line';\nimport {circle, point, square} from './point';\nimport {rect} from './rect';\nimport {rule} from './rule';\nimport {text} from './text';\nimport {tick} from './tick';\n\nimport {MAIN} from '../../data';\nimport {FacetModel} from '../facet';\nimport {UnitModel} from '../unit';\n\nconst markCompiler: {[type: string]: MarkCompiler} = {\n  area: area,\n  bar: bar,\n  line: line,\n  point: point,\n  text: text,\n  tick: tick,\n  rect: rect,\n  rule: rule,\n  circle: circle,\n  square: square\n};\n\nexport function parseMark(model: UnitModel): any[] {\n  if (contains([LINE, AREA], model.mark())) {\n    return parsePathMark(model);\n  } else {\n    return parseNonPathMark(model);\n  }\n}\n\nconst FACETED_PATH_PREFIX = 'faceted_path_';\n\nfunction parsePathMark(model: UnitModel) {\n  const mark = model.mark();\n  // FIXME: replace this with more general case for composition\n  const details = detailFields(model);\n\n  const pathMarks: any = [\n    {\n      name: model.getName('marks'),\n      type: markCompiler[mark].vgMark,\n      // If has subfacet for line/area group, need to use faceted data from below.\n      // FIXME: support sorting path order (in connected scatterplot)\n      from: {data: (details.length > 0 ? FACETED_PATH_PREFIX : '') + model.requestDataName(MAIN)},\n      encode: {update: markCompiler[mark].encodeEntry(model)}\n    }\n  ];\n\n  if (details.length > 0) { // have level of details - need to facet line into subgroups\n    // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n\n    return [{\n      name: model.getName('pathgroup'),\n      type: 'group',\n      from: {\n        facet: {\n          name: FACETED_PATH_PREFIX + model.requestDataName(MAIN),\n          data: model.requestDataName(MAIN),\n          groupby: details,\n        }\n      },\n      encode: {\n        update: {\n          width: {field: {group: 'width'}},\n          height: {field: {group: 'height'}}\n        }\n      },\n      marks: pathMarks\n    }];\n  } else {\n    return pathMarks;\n  }\n}\n\nfunction parseNonPathMark(model: UnitModel) {\n  const mark = model.mark();\n\n  const role = model.markDef.role || markCompiler[mark].defaultRole;\n\n  const marks: any[] = []; // TODO: vgMarks\n\n  // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n\n  marks.push({\n    name: model.getName('marks'),\n    type: markCompiler[mark].vgMark,\n    ...(role? {role} : {}),\n    from: {data: model.requestDataName(MAIN)},\n    encode: {update: markCompiler[mark].encodeEntry(model)}\n  });\n\n  return marks;\n}\n\n\n\n/**\n * Returns list of detail (group-by) fields\n * that the model's spec contains.\n */\nfunction detailFields(model: UnitModel): string[] {\n  return LEVEL_OF_DETAIL_CHANNELS.reduce(function(details, channel) {\n    if (model.channelHasField(channel) && !model.fieldDef(channel).aggregate) {\n      details.push(model.field(channel));\n    }\n    return details;\n  }, []);\n}\n","import {MarkDef} from '../../mark';\nimport * as util from '../../util';\nimport {VgEncodeEntry, VgValueRef} from '../../vega.schema';\nimport {getMarkConfig} from '../common';\nimport {UnitModel} from '../unit';\n\nimport * as ref from './valueref';\n\nimport {NONSPATIAL_SCALE_CHANNELS} from '../../channel';\nimport {Condition} from '../../fielddef';\nimport {predicate} from '../selection/selection';\n\nexport function color(model: UnitModel) {\n  const config = model.config;\n  const filled = model.markDef.filled;\n\n  const e = nonPosition('color', model, {\n    vgChannel: filled ? 'fill' : 'stroke',\n    defaultValue: getMarkConfig('color', model.mark(), config) as string\n  });\n\n  // If there is no fill, always fill symbols\n  // with transparent fills https://github.com/vega/vega-lite/issues/1316\n  if (!e.fill && util.contains(['bar', 'point', 'circle', 'square'], model.mark())) {\n    e.fill = {value: 'transparent'};\n  }\n  return e;\n}\n\nexport function markDefProperties(mark: MarkDef, props: (keyof MarkDef)[]) {\n  return props.reduce((m, prop) => {\n    if (mark[prop]) {\n      m[prop] = {value: mark[prop]};\n    }\n    return m;\n  }, {});\n}\n\nexport function valueIfDefined(prop: string, value: VgValueRef): VgEncodeEntry {\n  if (value !== undefined) {\n    return {[prop]: {value: value}};\n  }\n  return undefined;\n}\n\n/**\n * Return mixins for non-positional channels with scales.  (Text doesn't have scale.)\n */\nexport function nonPosition(channel: typeof NONSPATIAL_SCALE_CHANNELS[0], model: UnitModel, opt: {defaultValue?: number | string | boolean, vgChannel?: string, defaultRef?: VgValueRef} = {}): VgEncodeEntry {\n  // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613\n\n  const {defaultValue, vgChannel} = opt;\n  const defaultRef = opt.defaultRef || (defaultValue !== undefined ? {value: defaultValue} : undefined);\n\n  const channelDef = model.encoding[channel];\n  const valueRef = ref.midPoint(channel, channelDef, model.scaleName(channel), model.scale(channel), defaultRef);\n\n  return wrapCondition(model, channelDef && channelDef.condition, vgChannel || channel, valueRef);\n}\n\n/**\n * Return a mixin that include a Vega production rule for a Vega-Lite conditional channel definition.\n * or a simple mixin if channel def has no condition.\n */\nfunction wrapCondition(model: UnitModel, condition: Condition<any>, vgChannel: string, valueRef: VgValueRef): VgEncodeEntry {\n  if (condition) {\n    const {selection, value} = condition;\n    return {\n      [vgChannel]: [\n        {test: selectionTest(model, selection), value},\n        ...(valueRef !== undefined ? [valueRef] : [])\n      ]\n    };\n  } else {\n    return valueRef !== undefined ? {[vgChannel]: valueRef} : {};\n  }\n}\n\nfunction selectionTest(model: UnitModel, selectionName: string) {\n  const negate = selectionName.charAt(0) === '!',\n    name = negate ? selectionName.slice(1) : selectionName;\n  return (negate ? '!' : '') + predicate(model.getComponent('selection', name));\n}\n\nexport function text(model: UnitModel) {\n  const channelDef = model.encoding.text;\n  return wrapCondition(model, channelDef && channelDef.condition, 'text', ref.text(channelDef, model.config));\n}\n\nexport function bandPosition(channel: 'x'|'y', model: UnitModel) {\n  // TODO: band scale doesn't support size yet\n  const fieldDef = model.encoding[channel];\n  const scaleName = model.scaleName(channel);\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n  return {\n    [channel]: ref.fieldRef(fieldDef, scaleName, {}),\n    [sizeChannel]: ref.band(scaleName)\n  };\n}\n\nexport function centeredBandPosition(channel: 'x' | 'y', model: UnitModel, defaultPosRef: VgValueRef, defaultSizeRef: VgValueRef) {\n  const centerChannel: 'xc' | 'yc' = channel === 'x' ? 'xc' : 'yc';\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n  return {\n    ...pointPosition(channel, model, defaultPosRef, centerChannel),\n    ...nonPosition('size', model, {defaultRef: defaultSizeRef, vgChannel: sizeChannel})\n  };\n}\n\nexport function binnedPosition(channel: 'x'|'y', model: UnitModel, spacing: number) {\n  const fieldDef = model.encoding[channel];\n  const scaleName = model.scaleName(channel);\n  if (channel === 'x') {\n    return {\n      x2: ref.bin(fieldDef, scaleName, 'start', spacing),\n      x: ref.bin(fieldDef, scaleName, 'end')\n    };\n  } else {\n    return {\n      y2: ref.bin(fieldDef, scaleName, 'start'),\n      y: ref.bin(fieldDef, scaleName, 'end', spacing)\n    };\n  }\n}\n\n/**\n * Return mixins for point (non-band) position channels.\n */\nexport function pointPosition(channel: 'x'|'y', model: UnitModel, defaultRef: VgValueRef | 'zeroOrMin' | 'zeroOrMax', vgChannel?: 'x'|'y'|'xc'|'yc') {\n  // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613\n\n  const {encoding, stack} = model;\n  const valueRef = ref.stackable(channel, encoding[channel], model.scaleName(channel), model.scale(channel), stack, defaultRef);\n\n  return {\n    [vgChannel || channel]: valueRef\n  };\n}\n\n/**\n * Return mixins for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\nexport function pointPosition2(model: UnitModel, defaultRef: 'zeroOrMin' | 'zeroOrMax', channel?: 'x2' | 'y2') {\n  const {encoding, markDef, stack} = model;\n  channel = channel || (markDef.orient === 'horizontal' ? 'x2' : 'y2');\n  const baseChannel = channel === 'x2' ? 'x' : 'y';\n\n  const valueRef = ref.stackable2(channel, encoding[baseChannel], encoding[channel], model.scaleName(baseChannel), model.scale(baseChannel), stack, defaultRef);\n  return {[channel]: valueRef};\n}\n","\n\nimport {UnitModel} from '../unit';\nimport * as mixins from './mixins';\n\nimport {Config} from '../../config';\nimport {getMarkConfig} from '../common';\nimport {MarkCompiler} from './base';\nimport * as ref from './valueref';\n\nfunction encodeEntry(model: UnitModel, fixedShape?: 'circle' | 'square') {\n  const {config, width, height} = model;\n\n  return {\n    ...mixins.pointPosition('x', model, ref.midX(width, config)),\n    ...mixins.pointPosition('y', model, ref.midY(height, config)),\n\n    ...mixins.color(model),\n    ...mixins.nonPosition('size', model),\n    ...shapeMixins(model, config, fixedShape),\n    ...mixins.nonPosition('opacity', model)\n  };\n}\n\nexport function shapeMixins(model: UnitModel, config: Config, fixedShape?: 'circle' | 'square') {\n  if (fixedShape) {\n    return {shape: {value: fixedShape}};\n  }\n  return mixins.nonPosition('shape', model, {defaultValue: getMarkConfig('shape', 'point', config) as string});\n}\n\nexport const point: MarkCompiler = {\n  vgMark: 'symbol',\n  defaultRole: 'point',\n  encodeEntry: (model: UnitModel) => {\n    return encodeEntry(model);\n  }\n};\n\nexport const circle: MarkCompiler = {\n  vgMark: 'symbol',\n  defaultRole: 'circle',\n  encodeEntry: (model: UnitModel) => {\n    return encodeEntry(model, 'circle');\n  }\n};\n\nexport const square: MarkCompiler = {\n  vgMark: 'symbol',\n  defaultRole: 'square',\n  encodeEntry: (model: UnitModel) => {\n    return encodeEntry(model, 'square');\n  }\n};\n","import {X, Y} from '../../channel';\nimport {isFieldDef} from '../../fielddef';\nimport * as log from '../../log';\nimport {RECT} from '../../mark';\nimport {hasDiscreteDomain, ScaleType} from '../../scale';\n\nimport {UnitModel} from '../unit';\nimport * as mixins from './mixins';\n\nimport {MarkCompiler} from './base';\n\nexport const rect: MarkCompiler = {\n  vgMark: 'rect',\n  defaultRole: undefined,\n  encodeEntry: (model: UnitModel) => {\n    return {\n      ...x(model),\n      ...y(model),\n      ...mixins.color(model),\n      ...mixins.nonPosition('opacity', model),\n    };\n  }\n};\n\nfunction x(model: UnitModel) {\n  const xDef = model.encoding.x;\n  const x2Def = model.encoding.x2;\n  const xScale = model.scale(X);\n\n  if (isFieldDef(xDef) && xDef.bin && !x2Def) {\n    return mixins.binnedPosition('x', model, 0);\n  } else if (xScale && hasDiscreteDomain(xScale.type)) {\n    /* istanbul ignore else */\n    if (xScale.type === ScaleType.BAND) {\n      return mixins.bandPosition('x', model);\n    } else {\n      // We don't support rect mark with point/ordinal scale\n      throw new Error(log.message.scaleTypeNotWorkWithMark(RECT, xScale.type));\n    }\n  } else { // continuous scale or no scale\n    return {\n      ...mixins.pointPosition('x', model, 'zeroOrMax'),\n      ...mixins.pointPosition2(model, 'zeroOrMin', 'x2')\n    };\n  }\n}\n\nfunction y(model: UnitModel) {\n  const yDef = model.encoding.y;\n  const y2Def = model.encoding.y2;\n  const yScale = model.scale(Y);\n\n  if (isFieldDef(yDef) && yDef.bin && !y2Def) {\n    return mixins.binnedPosition('y', model, 0);\n  } else if (yScale && hasDiscreteDomain(yScale.type)) {\n    /* istanbul ignore else */\n    if (yScale.type === ScaleType.BAND) {\n      return mixins.bandPosition('y', model);\n    } else {\n      // We don't support rect mark with point/ordinal scale\n      throw new Error(log.message.scaleTypeNotWorkWithMark(RECT, yScale.type));\n    }\n  } else { // continuous scale or no scale\n    return {\n      ...mixins.pointPosition('y', model, 'zeroOrMax'),\n      ...mixins.pointPosition2(model, 'zeroOrMin', 'y2')\n    };\n  }\n}\n","import {UnitModel} from '../unit';\nimport {MarkCompiler} from './base';\nimport * as mixins from './mixins';\nimport * as ref from './valueref';\n\nexport const rule: MarkCompiler = {\n  vgMark: 'rule',\n  defaultRole: undefined,\n  encodeEntry: (model: UnitModel) => {\n    const {config, markDef, width, height} = model;\n    const orient = markDef.orient;\n\n    return {\n      ...mixins.pointPosition('x', model, orient === 'horizontal' ? 'zeroOrMin' : ref.midX(width, config)),\n      ...mixins.pointPosition('y', model, orient === 'vertical' ? 'zeroOrMin' : ref.midY(height, config)),\n      ...mixins.pointPosition2(model, 'zeroOrMax'),\n\n      ...mixins.color(model),\n      ...mixins.nonPosition('opacity', model),\n      ...mixins.nonPosition('size', model, {\n        vgChannel: 'strokeWidth'  // VL's rule size is strokeWidth\n      })\n    };\n  }\n};\n","import {X} from '../../channel';\nimport {getMarkConfig} from '../common';\n\nimport {Config} from '../../config';\nimport {ChannelDef, isFieldDef} from '../../fielddef';\nimport {QUANTITATIVE} from '../../type';\nimport {VgValueRef} from '../../vega.schema';\nimport {UnitModel} from '../unit';\nimport * as mixins from './mixins';\n\nimport {channelHasField, Encoding} from '../../encoding';\nimport {MarkCompiler} from './base';\nimport * as ref from './valueref';\n\nexport const text: MarkCompiler = {\n  vgMark: 'text',\n  defaultRole: undefined,\n\n  encodeEntry: (model: UnitModel) => {\n    const {config, encoding, height} = model;\n    const textDef = encoding.text;\n\n    return {\n      ...mixins.pointPosition('x', model, xDefault(config, textDef)),\n      ...mixins.pointPosition('y', model, ref.midY(height, config)),\n      ...mixins.text(model),\n      ...mixins.color(model),\n      ...mixins.nonPosition('opacity', model),\n      ...mixins.nonPosition('size', model, {\n        vgChannel: 'fontSize'  // VL's text size is fontSize\n      }),\n      ...mixins.valueIfDefined('align', align(encoding, config))\n    };\n  }\n};\n\nfunction xDefault(config: Config, textDef: ChannelDef<string>): VgValueRef {\n  if (isFieldDef(textDef) && textDef.type === QUANTITATIVE) {\n    return {field: {group: 'width'}, offset: -5};\n  }\n  // TODO: allow this to fit (Be consistent with ref.midX())\n  return {value: config.scale.textXRangeStep / 2};\n}\n\nfunction align(encoding: Encoding<string>, config: Config) {\n  const alignConfig = getMarkConfig('align', 'text', config);\n  if (alignConfig === undefined) {\n    return channelHasField(encoding, X) ? 'center' : 'right';\n  }\n  // If there is a config, Vega-parser will process this already.\n  return undefined;\n}\n","\n\nimport {UnitModel} from '../unit';\nimport * as mixins from './mixins';\n\nimport {MarkCompiler} from './base';\nimport * as ref from './valueref';\n\nexport const tick: MarkCompiler = {\n  vgMark: 'rect',\n  defaultRole: 'tick',\n\n  encodeEntry: (model: UnitModel) => {\n    const {config, markDef, width, height} = model;\n    const orient = markDef.orient;\n\n    const vgSizeChannel = orient === 'horizontal' ? 'width' : 'height';\n    const vgThicknessChannel = orient === 'horizontal' ? 'height' : 'width';\n\n    return {\n      ...mixins.pointPosition('x', model, ref.midX(width, config), 'xc'),\n      ...mixins.pointPosition('y', model, ref.midY(height, config), 'yc'),\n\n      // size / thickness => width / height\n      ...mixins.nonPosition('size', model, {\n        defaultValue: defaultSize(model),\n        vgChannel: vgSizeChannel\n      }),\n      [vgThicknessChannel]: {value: config.tick.thickness},\n\n      ...mixins.color(model),\n      ...mixins.nonPosition('opacity', model),\n    };\n  }\n};\n\nfunction defaultSize(model: UnitModel): number {\n  const {config} = model;\n  const orient = model.markDef.orient;\n\n  const scaleRangeStep: number | null = (model.scale(orient === 'horizontal' ? 'x' : 'y') || {}).rangeStep;\n\n  if (config.tick.bandSize !== undefined) {\n    return config.tick.bandSize;\n  } else {\n    const rangeStep = scaleRangeStep !== undefined ?\n      scaleRangeStep :\n      config.scale.rangeStep;\n    if (typeof rangeStep !== 'number') {\n      // FIXME consolidate this log\n      throw new Error('Function does not handle non-numeric rangeStep');\n    }\n    return rangeStep / 1.5;\n  }\n}\n","/**\n * Utility files for producing Vega ValueRef for marks\n */\n\nimport {Channel, X, X2, Y, Y2} from '../../channel';\nimport {Config} from '../../config';\nimport {ChannelDef, field, FieldDef, FieldRefOption, isFieldDef, TextFieldDef, ValueDef} from '../../fielddef';\nimport {hasDiscreteDomain, isBinScale, Scale, ScaleType} from '../../scale';\nimport {StackProperties} from '../../stack';\nimport {contains} from '../../util';\nimport {VgValueRef} from '../../vega.schema';\nimport {formatSignalRef, numberFormat, timeFormatExpression} from '../common';\n\n// TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated.  For now, this is a huge step moving forward.\n\n/**\n * @return Vega ValueRef for stackable x or y\n */\nexport function stackable(channel: 'x' | 'y', channelDef: ChannelDef<string>, scaleName: string, scale: Scale,\n    stack: StackProperties, defaultRef: VgValueRef): VgValueRef {\n  if (channelDef && stack && channel === stack.fieldChannel) {\n    // x or y use stack_end so that stacked line's point mark use stack_end too.\n    return fieldRef(channelDef, scaleName, {suffix: 'end'});\n  }\n  return midPoint(channel, channelDef, scaleName, scale, defaultRef);\n}\n\n/**\n * @return Vega ValueRef for stackable x2 or y2\n */\nexport function stackable2(channel: 'x2' | 'y2', aFieldDef: FieldDef<string>, a2fieldDef: FieldDef<string>, scaleName: string, scale: Scale,\n    stack: StackProperties, defaultRef: VgValueRef): VgValueRef {\n  if (aFieldDef && stack &&\n      // If fieldChannel is X and channel is X2 (or Y and Y2)\n      channel.charAt(0) === stack.fieldChannel.charAt(0)\n      ) {\n    return fieldRef(aFieldDef, scaleName, {suffix: 'start'});\n  }\n  return midPoint(channel, a2fieldDef, scaleName, scale, defaultRef);\n}\n\n/**\n * Value Ref for binned fields\n */\nexport function bin(fieldDef: FieldDef<string>, scaleName: string, side: 'start' | 'end',  offset?: number) {\n  return fieldRef(fieldDef, scaleName, {binSuffix: side}, offset);\n}\n\nexport function fieldRef(fieldDef: FieldDef<string>, scaleName: string, opt: FieldRefOption, offset?: number | VgValueRef): VgValueRef {\n  const ref: VgValueRef = {\n    scale: scaleName,\n    field: field(fieldDef, opt),\n  };\n  if (offset) {\n    ref.offset = offset;\n  }\n  return ref;\n}\n\nexport function band(scaleName: string, band: number|boolean = true): VgValueRef {\n  return {\n    scale: scaleName,\n    band: band\n  };\n}\n\n/**\n * Signal that returns the middle of a bin. Should only be used with x and y.\n */\nfunction binMidSignal(fieldDef: FieldDef<string>, scaleName: string) {\n  return {\n    signal: `(` +\n      `scale(\"${scaleName}\", ${field(fieldDef, {binSuffix: 'start', expr: 'datum'})})` +\n      ` + ` +\n      `scale(\"${scaleName}\", ${field(fieldDef, {binSuffix: 'end', expr: 'datum'})})`+\n    `)/2`\n  };\n}\n\n/**\n * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.\n */\nexport function midPoint(channel: Channel, channelDef: ChannelDef<string>, scaleName: string, scale: Scale,\n  defaultRef: VgValueRef | 'zeroOrMin' | 'zeroOrMax'): VgValueRef {\n  // TODO: datum support\n\n  if (channelDef) {\n    /* istanbul ignore else */\n    if (isFieldDef(channelDef)) {\n      if (isBinScale(scale.type)) {\n        // Use middle only for x an y to place marks in the center between start and end of the bin range.\n        // We do not use the mid point for other channels (e.g. size) so that properties of legends and marks match.\n        if (contains(['x', 'y'], channel)) {\n          return binMidSignal(channelDef, scaleName);\n        }\n        return fieldRef(channelDef, scaleName, {binSuffix: 'start'});\n      }\n\n      if (hasDiscreteDomain(scale.type)) {\n        if (scale.type === 'band') {\n          // For band, to get mid point, need to offset by half of the band\n          return fieldRef(channelDef, scaleName, {binSuffix: 'range'}, band(scaleName, 0.5));\n        }\n        return fieldRef(channelDef, scaleName, {binSuffix: 'range'});\n      } else {\n        return fieldRef(channelDef, scaleName, {}); // no need for bin suffix\n      }\n    } else if (channelDef.value !== undefined) {\n      return {value: channelDef.value};\n    } else {\n      throw new Error('FieldDef without field or value.'); // FIXME add this to log.message\n    }\n  }\n\n  if (defaultRef === 'zeroOrMin') {\n    /* istanbul ignore else */\n    if (channel === X || channel === X2) {\n      return zeroOrMinX(scaleName, scale);\n    } else if (channel === Y || channel === Y2) {\n      return zeroOrMinY(scaleName, scale);\n    } else {\n      throw new Error(`Unsupported channel ${channel} for base function`); // FIXME add this to log.message\n    }\n  } else if (defaultRef === 'zeroOrMax') {\n    /* istanbul ignore else */\n    if (channel === X || channel === X2) {\n      return zeroOrMaxX(scaleName, scale);\n    } else if (channel === Y || channel === Y2) {\n      return zeroOrMaxY(scaleName, scale);\n    } else {\n      throw new Error(`Unsupported channel ${channel} for base function`); // FIXME add this to log.message\n    }\n  }\n  return defaultRef;\n}\n\nexport function text(textDef: TextFieldDef<string> | ValueDef<any>, config: Config): VgValueRef {\n  // text\n  if (textDef) {\n    if (isFieldDef(textDef)) {\n      return formatSignalRef(textDef, 'datum', config);\n    } else if (textDef.value) {\n      return {value: textDef.value};\n    }\n  }\n  return {value: config.text.text};\n}\n\nexport function midX(width: number, config: Config): VgValueRef {\n  if (width) {\n    return {value: width / 2};\n  }\n\n  if (typeof config.scale.rangeStep === 'string') {\n    // TODO: For fit-mode, use middle of the width\n    throw new Error('midX can not handle string rangeSteps');\n  }\n  return {value: config.scale.rangeStep / 2};\n}\n\nexport function midY(height: number, config: Config): VgValueRef {\n  if (height) {\n    return {value: height / 2};\n  }\n\n  if (typeof config.scale.rangeStep === 'string') {\n    // TODO: For fit-mode, use middle of the width\n    throw new Error('midX can not handle string rangeSteps');\n  }\n  return {value: config.scale.rangeStep / 2};\n}\n\nfunction zeroOrMinX(scaleName: string, scale: Scale): VgValueRef {\n  if (scaleName) {\n    // Log / Time / UTC scale do not support zero\n    if (!contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scale.type) &&\n      scale.zero !== false) {\n\n      return {\n        scale: scaleName,\n        value: 0\n      };\n    }\n  }\n  // Put the mark on the x-axis\n  return {value: 0};\n}\n\n/**\n * @returns {VgValueRef} base value if scale exists and return max value if scale does not exist\n */\nfunction zeroOrMaxX(scaleName: string, scale: Scale): VgValueRef {\n  if (scaleName) {\n    // Log / Time / UTC scale do not support zero\n    if (!contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scale.type) &&\n      scale.zero !== false) {\n\n      return {\n        scale: scaleName,\n        value: 0\n      };\n    }\n  }\n  return {field: {group: 'width'}};\n}\n\nfunction zeroOrMinY(scaleName: string, scale: Scale): VgValueRef {\n  if (scaleName) {\n    // Log / Time / UTC scale do not support zero\n    if (!contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scale.type) &&\n      scale.zero !== false) {\n\n      return {\n        scale: scaleName,\n        value: 0\n      };\n    }\n  }\n  // Put the mark on the y-axis\n  return {field: {group: 'height'}};\n}\n\n/**\n * @returns {VgValueRef} base value if scale exists and return max value if scale does not exist\n */\nfunction zeroOrMaxY(scaleName: string, scale: Scale): VgValueRef {\n  if (scaleName) {\n    // Log / Time / UTC scale do not support zero\n    if (!contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scale.type) &&\n      scale.zero !== false) {\n\n      return {\n        scale: scaleName,\n        value: 0\n      };\n    }\n  }\n  // Put the mark on the y-axis\n  return {value: 0};\n}\n","import {Axis} from '../axis';\nimport {Channel, COLUMN, isChannel, X} from '../channel';\nimport {CellConfig, Config} from '../config';\nimport {Data, DataSourceType, MAIN, RAW} from '../data';\nimport {forEach, reduce} from '../encoding';\nimport {ChannelDef, field, FieldDef, FieldRefOption, isFieldDef, isRepeatRef} from '../fielddef';\nimport {Legend} from '../legend';\nimport {hasDiscreteDomain, Scale} from '../scale';\nimport {SortField, SortOrder} from '../sort';\nimport {BaseSpec} from '../spec';\nimport {StackProperties} from '../stack';\nimport {Transform} from '../transform';\nimport {Dict, extend, vals, varName} from '../util';\nimport {VgAxis, VgData, VgEncodeEntry, VgLayout, VgLegend, VgMarkGroup, VgScale, VgSignal, VgSignalRef, VgValueRef} from '../vega.schema';\n\nimport {AxesComponent, AxisComponent} from './axis/index';\nimport {DataComponent} from './data/index';\nimport {getHeaderGroup, getTitleGroup, HEADER_CHANNELS, HEADER_TYPES, LayoutHeaderComponent} from './layout/header';\nimport {RepeaterValue} from './repeat';\nimport {assembleScale} from './scale/assemble';\nimport {SelectionComponent} from './selection/selection';\nimport {UnitModel} from './unit';\n\n/**\n * Composable Components that are intermediate results of the parsing phase of the\n * compilations.  These composable components will be assembled in the last\n * compilation step.\n */\nexport interface Component {\n  data: DataComponent;\n  scales: Dict<VgScale>;\n  selection: Dict<SelectionComponent>;\n\n  /** Dictionary mapping channel to VgAxis definition */\n  axes: AxesComponent;\n\n  /** Dictionary mapping channel to VgLegend definition */\n  legends: Dict<VgLegend>;\n\n  layoutHeaders: {\n    row?: LayoutHeaderComponent,\n    column?: LayoutHeaderComponent\n  };\n\n  mark: VgEncodeEntry[];\n}\n\nexport interface NameMapInterface {\n  rename(oldname: string, newName: string): void;\n  has(name: string): boolean;\n  get(name: string): string;\n}\n\nexport class NameMap implements NameMapInterface {\n  private nameMap: Dict<string>;\n\n  constructor() {\n    this.nameMap = {};\n  }\n\n  public rename(oldName: string, newName: string) {\n    this.nameMap[oldName] = newName;\n  }\n\n\n  public has(name: string): boolean {\n    return this.nameMap[name] !== undefined;\n  }\n\n  public get(name: string): string {\n    // If the name appears in the _nameMap, we need to read its new name.\n    // We have to loop over the dict just in case the new name also gets renamed.\n    while (this.nameMap[name]) {\n      name = this.nameMap[name];\n    }\n\n    return name;\n  }\n}\n\nexport abstract class Model {\n  public readonly parent: Model;\n  public readonly name: string;\n  public readonly description: string;\n\n  public readonly data: Data;\n  public readonly transforms: Transform[];\n\n  /** Name map for scales, which can be renamed by a model's parent. */\n  protected scaleNameMap: NameMapInterface;\n\n  /** Name map for size, which can be renamed by a model's parent. */\n  protected sizeNameMap: NameMapInterface;\n\n  public readonly config: Config;\n\n  public component: Component;\n\n  public abstract readonly children: Model[] = [];\n\n  constructor(spec: BaseSpec, parent: Model, parentGivenName: string, config: Config) {\n    this.parent = parent;\n    this.config = config;\n\n    // If name is not provided, always use parent's givenName to avoid name conflicts.\n    this.name = spec.name || parentGivenName;\n\n    // Shared name maps\n    this.scaleNameMap = parent ? parent.scaleNameMap : new NameMap();\n    this.sizeNameMap = parent ? parent.sizeNameMap : new NameMap();\n\n    this.data = spec.data;\n\n    this.description = spec.description;\n    this.transforms = spec.transform || [];\n\n    this.component = {\n      data: {\n        sources: parent ? parent.component.data.sources : {},\n        outputNodes: parent ? parent.component.data.outputNodes : {}\n      },\n      mark: null, scales: null, axes: {x: null, y: null},\n      layoutHeaders:{row: {}, column: {}}, legends: null, selection: null\n    };\n  }\n\n  public parse() {\n    this.parseData();\n    this.parseScale(); // depends on data name\n    this.parseSelection();\n    this.parseAxisAndHeader(); // depends on scale name\n    this.parseLegend(); // depends on scale name\n    this.parseMark(); // depends on data name and scale name, axisGroup, and children's scale, axis, legend and mark.\n  }\n\n  public abstract parseData(): void;\n\n  public abstract parseSelection(): void;\n\n\n  public abstract parseScale(): void;\n\n  public abstract parseMark(): void;\n\n  public abstract parseAxisAndHeader(): void;\n\n  public abstract parseLegend(): void;\n\n  public abstract assembleSelectionTopLevelSignals(signals: any[]): any[];\n  public abstract assembleSelectionSignals(): any[];\n\n  public abstract assembleSelectionData(data: VgData[]): VgData[];\n  public abstract assembleData(): VgData[];\n\n  public abstract assembleLayout(): VgLayout;\n\n  public abstract assembleLayoutSignals(): VgSignal[];\n\n  public assembleScales(): VgScale[] {\n    return assembleScale(this);\n  }\n\n  public assembleHeaderMarks(): VgMarkGroup[] {\n    const {layoutHeaders} = this.component;\n    const headerMarks = [];\n\n    for (const channel of HEADER_CHANNELS) {\n      if (layoutHeaders[channel].title) {\n        headerMarks.push(getTitleGroup(this, channel));\n      }\n    }\n\n    for (const channel of HEADER_CHANNELS) {\n      const layoutHeader = layoutHeaders[channel];\n      for (const headerType of HEADER_TYPES) {\n        if (layoutHeader[headerType]) {\n          for (const header of layoutHeader[headerType]) {\n            const headerGroup = getHeaderGroup(this, channel, headerType, layoutHeader, header);\n            if (headerGroup)  {\n              headerMarks.push(headerGroup);\n            }\n          }\n        }\n      }\n    }\n    return headerMarks;\n  }\n\n  public abstract assembleMarks(): VgMarkGroup[]; // TODO: VgMarkGroup[]\n\n  public assembleAxes(): VgAxis[] {\n    const {x, y} = this.component.axes;\n\n    return [\n      ...(x ? x.axes.concat(x.gridAxes) : []),\n      ...(y ? y.axes.concat(y.gridAxes) : []),\n    ];\n  }\n\n  public assembleLegends(): VgLegend[] {\n    return vals(this.component.legends);\n  }\n\n  public assembleGroup(signals: VgSignal[] = []) {\n    const group: VgEncodeEntry = {};\n\n    signals = signals.concat(this.assembleSelectionSignals());\n    if (signals.length > 0) {\n      group.signals = signals;\n    }\n\n    const layout = this.assembleLayout();\n    if (layout) {\n      group.layout = layout;\n    }\n\n    group.marks = [].concat(\n      this.assembleHeaderMarks(),\n      this.assembleMarks()\n    );\n    const scales = this.assembleScales();\n    if (scales.length > 0) {\n      group.scales = scales;\n    }\n\n    const axes = this.assembleAxes();\n    if (axes.length > 0) {\n      group.axes = axes;\n    }\n\n    const legends = this.assembleLegends();\n    if (legends.length > 0) {\n      group.legends = legends;\n    }\n\n    return group;\n  }\n\n  public abstract assembleParentGroupProperties(): VgEncodeEntry;\n\n  public hasDescendantWithFieldOnChannel(channel: Channel) {\n    for (const child of this.children) {\n      if (child instanceof UnitModel) {\n        if (child.channelHasField(channel)) {\n          return true;\n        }\n      } else {\n        if (child.hasDescendantWithFieldOnChannel(channel)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  public getName(text: string) {\n    return varName((this.name ? this.name + '_' : '') + text);\n  }\n\n  /**\n   * Request a data source name for the given data source type and mark that data source as required. This method should be called in parse, so that all used data source can be correctly instantiated in assembleData().\n   */\n  public requestDataName(name: DataSourceType) {\n    const fullName = this.getName(name);\n\n    return this.lookupDataSource(fullName);\n  }\n\n  public getSizeSignalRef(sizeType: 'width' | 'height'): {signal: string} {\n    // TODO: this could change in the future once we have sizeSignal merging\n    return {\n      signal: this.getName(sizeType)\n    };\n  }\n\n  /**\n   * Lookup the name of the datasource for an output node. You probably want to call this in assemble.\n   */\n  public lookupDataSource(name: string) {\n    const node = this.component.data.outputNodes[name];\n\n    if (!node) {\n      // name not found in map so let's just return what we got\n      return name;\n    }\n\n    return node.source;\n  }\n\n  public renameSize(oldName: string, newName: string) {\n    this.sizeNameMap.rename(oldName, newName);\n  }\n\n  public channelSizeName(channel: Channel): string {\n    return this.sizeName(channel === X || channel === COLUMN ? 'width' : 'height');\n  }\n\n  public sizeName(size: string): string {\n     return this.sizeNameMap.get(this.getName(size));\n  }\n\n  public renameScale(oldName: string, newName: string) {\n    this.scaleNameMap.rename(oldName, newName);\n  }\n\n  // FIXME: remove this, but currently the scaleName() method below depends on this.\n  public scale(channel: Channel): Scale {\n    return null;\n  }\n\n  /**\n   * @return scale name for a given channel after the scale has been parsed and named.\n   */\n  public scaleName(this: Model, originalScaleName: Channel | string, parse?: boolean): string {\n    if (parse) {\n      // During the parse phase always return a value\n      // No need to refer to rename map because a scale can't be renamed\n      // before it has the original name.\n      return this.getName(originalScaleName);\n    }\n\n    // If there is a scale for the channel, it should either\n    // be in the _scale mapping or exist in the name map\n    if (\n        // in the scale map (the scale is not merged by its parent)\n        (this.scale && isChannel(originalScaleName) && this.scale(originalScaleName)) ||\n        // in the scale name map (the the scale get merged by its parent)\n        this.scaleNameMap.has(this.getName(originalScaleName))\n      ) {\n      return this.scaleNameMap.get(this.getName(originalScaleName));\n    }\n    return undefined;\n  }\n\n  /**\n   * Corrects the data references in marks after assemble.\n   */\n  public correctDataNames = (mark: VgEncodeEntry) => {\n    // TODO: make this correct\n\n    // for normal data references\n    if (mark.from && mark.from.data) {\n      mark.from.data = this.lookupDataSource(mark.from.data);\n    }\n\n    // for access to facet data\n    if (mark.from && mark.from.facet && mark.from.facet.data) {\n      mark.from.facet.data = this.lookupDataSource(mark.from.facet.data);\n    }\n\n    return mark;\n  }\n\n  /**\n   * Traverse a model's hierarchy to get the specified component.\n   * @param type Scales or Selection\n   * @param name Name of the component\n   */\n  public getComponent(type: 'scales' | 'selection', name: string): any {\n    return this.component[type][name] || this.parent.getComponent(type, name);\n  }\n}\n\n/** Abstract class for UnitModel and FacetModel.  Both of which can contain fieldDefs as a part of its own specification. */\nexport abstract class ModelWithField extends Model {\n  public abstract fieldDef(channel: Channel): FieldDef<string>;\n\n  /** Get \"field\" reference for vega */\n  public field(channel: Channel, opt: FieldRefOption = {}) {\n    const fieldDef = this.fieldDef(channel);\n\n    if (fieldDef.bin) { // bin has default suffix that depends on scaleType\n      opt = extend({\n        binSuffix: this.hasDiscreteDomain(channel) ? 'range' : 'start'\n      }, opt);\n    }\n\n    return field(fieldDef, opt);\n  }\n\n  public abstract hasDiscreteDomain(channel: Channel): boolean;\n\n\n  public abstract channels(): Channel[];\n\n  protected abstract getMapping(): {[key: string]: any};\n\n  public reduceFieldDef<T, U>(f: (acc: U, fd: FieldDef<string>, c: Channel) => U, init: T, t?: any) {\n    return reduce(this.getMapping(), (acc:U , cd: ChannelDef<string>, c: Channel) => {\n      return isFieldDef(cd) ? f(acc, cd, c) : acc;\n    }, init, t);\n  }\n\n  public forEachFieldDef(f: (fd: FieldDef<string>, c: Channel) => void, t?: any) {\n    forEach(this.getMapping(), (cd: ChannelDef<string>, c: Channel) => {\n      if (isFieldDef(cd)) {\n        f(cd, c);\n      }\n    }, t);\n  }\n  public abstract channelHasField(channel: Channel): boolean;\n}\n","import {isArray} from 'vega-util';\nimport {NONSPATIAL_SCALE_CHANNELS} from '../channel';\nimport {CellConfig, Config} from '../config';\nimport {Encoding} from '../encoding';\nimport {Facet} from '../facet';\nimport {Field, FieldDef, isRepeatRef} from '../fielddef';\nimport * as log from '../log';\nimport {Repeat} from '../repeat';\nimport {RepeatSpec} from '../spec';\nimport {contains, Dict, keys, vals} from '../util';\nimport {isSignalRefDomain, VgData, VgLayout, VgScale, VgSignal} from '../vega.schema';\nimport {buildModel} from './common';\nimport {assembleData} from './data/assemble';\nimport {parseData} from './data/parse';\nimport {assembleLayoutLayerSignals} from './layout/index';\nimport {Model} from './model';\nimport {unionDomains} from './scale/domain';\n\n\nexport type RepeaterValue = {\n  row?: string,\n  column?: string\n};\n\nexport function replaceRepeaterInFacet(facet: Facet<Field>, repeater: RepeaterValue): Facet<string> {\n  return replaceRepeater(facet, repeater);\n}\n\nexport function replaceRepeaterInEncoding(encoding: Encoding<Field>, repeater: RepeaterValue): Encoding<string> {\n  return replaceRepeater(encoding, repeater);\n}\n\ntype EncodingOrFacet<F> = Encoding<F> | Facet<F>;\n\n/**\n * Replace repeater values in a field def with the concrete field name.\n */\nfunction replaceRepeaterInFieldDef(fieldDef: FieldDef<Field>, repeater: RepeaterValue): FieldDef<string> | null {\n  const field = fieldDef.field;\n  if (isRepeatRef(field)) {\n    if (field.repeat in repeater) {\n      return {\n        ...fieldDef,\n        field: repeater[field.repeat]\n      };\n    } else {\n      log.warn(log.message.noSuchRepeatedValue(field.repeat));\n      return null;\n    }\n  } else {\n    // field is not a repeat ref so we can just return the field def\n    return fieldDef as FieldDef<string>;\n  }\n}\n\nfunction replaceRepeater(mapping: EncodingOrFacet<Field>, repeater: RepeaterValue): EncodingOrFacet<string> {\n  const out: EncodingOrFacet<string> = {};\n  for (const channel in mapping) {\n    if (mapping.hasOwnProperty(channel)) {\n      const fieldDef: FieldDef<Field> | FieldDef<Field>[] = mapping[channel];\n\n      if (isArray(fieldDef)) {\n        out[channel] = fieldDef.map(fd => replaceRepeaterInFieldDef(fd, repeater))\n          .filter((fd: FieldDef<string> | null) => fd !== null);\n      } else {\n        const fd = replaceRepeaterInFieldDef(fieldDef, repeater);\n        if (fd !== null) {\n          out[channel] = fd;\n        }\n      }\n    }\n  }\n  return out;\n}\n\nexport class RepeatModel extends Model {\n  public readonly repeat: Repeat;\n\n  public readonly children: Model[];\n\n  constructor(spec: RepeatSpec, parent: Model, parentGivenName: string, repeatValues: RepeaterValue, config: Config) {\n    super(spec, parent, parentGivenName, config);\n\n    this.repeat = spec.repeat;\n    this.children = this._initChildren(spec, this.repeat, repeatValues, config);\n  }\n\n  private _initChildren(spec: RepeatSpec, repeat: Repeat, repeater: RepeaterValue, config: Config): Model[] {\n    const children: Model[] = [];\n    const row = repeat.row || [repeater ? repeater.row : null];\n    const column = repeat.column || [repeater ? repeater.column : null];\n\n    // cross product\n    for (const rowField of row) {\n      for (const columnField of column) {\n        const name = (rowField ? '_' + rowField : '') + (columnField ? '_' + columnField : '');\n\n        const childRepeat = {\n          row: rowField,\n          column: columnField\n        };\n\n        children.push(buildModel(spec.spec, this, this.getName('child' + name), childRepeat, config));\n      }\n    }\n\n    return children;\n  }\n\n  public parseData() {\n    this.component.data = parseData(this);\n    this.children.forEach((child) => {\n      child.parseData();\n    });\n  }\n\n  public parseSelection() {\n    // Merge selections up the hierarchy so that they may be referenced\n    // across unit specs. Persist their definitions within each child\n    // to assemble signals which remain within output Vega unit groups.\n    this.component.selection = {};\n    for (const child of this.children) {\n      child.parseSelection();\n      keys(child.component.selection).forEach((key) => {\n        this.component.selection[key] = child.component.selection[key];\n      });\n    }\n  }\n\n  public parseScale(this: RepeatModel) {\n    const model = this;\n\n    const scaleComponent: Dict<VgScale> = this.component.scales = {};\n\n    this.children.forEach(function(child) {\n      child.parseScale();\n\n      // FIXME(#1602): correctly implement independent scale\n      // Also need to check whether the scales are actually compatible, e.g. use the same sort or throw error\n      if (true) { // if shared/union scale\n        keys(child.component.scales).forEach(function(channel) {\n          if (contains(NONSPATIAL_SCALE_CHANNELS, channel)) {\n            const childScale = child.component.scales[channel];\n            const modelScale = scaleComponent[channel];\n\n            if (!childScale || isSignalRefDomain(childScale.domain) || (modelScale && isSignalRefDomain(modelScale.domain))) {\n              // TODO: merge signal ref domains\n              return;\n            }\n\n            if (modelScale) {\n              modelScale.domain = unionDomains(modelScale.domain, childScale.domain);\n            } else {\n              scaleComponent[channel] = childScale;\n            }\n\n            // rename child scale to parent scales\n            const scaleNameWithoutPrefix = childScale.name.substr(child.getName('').length);\n            const newName = model.scaleName(scaleNameWithoutPrefix, true);\n            child.renameScale(childScale.name, newName);\n            childScale.name = newName;\n\n            // remove merged scales from children\n            delete child.component.scales[channel];\n          }\n        });\n      }\n    });\n  }\n\n  public parseMark() {\n    for (const child of this.children) {\n      child.parseMark();\n    }\n  }\n\n  public parseAxisAndHeader() {\n    for (const child of this.children) {\n      child.parseAxisAndHeader();\n    }\n  }\n\n  public parseAxisGroup(): void {\n    return null;\n  }\n\n  public parseLegend() {\n    const legendComponent = this.component.legends = {};\n\n    for (const child of this.children) {\n      child.parseLegend();\n\n      // TODO: correctly implement independent legends\n      if (true) { // if shared/union scale\n        keys(child.component.legends).forEach(function(channel) {\n          // just use the first legend definition for each channel\n          if (!legendComponent[channel]) {\n            legendComponent[channel] = child.component.legends[channel];\n          }\n          delete child.component.legends[channel];\n        });\n      }\n    }\n  }\n\n  public assembleData(): VgData[] {\n     if (!this.parent) {\n      // only assemble data in the root\n      return assembleData(vals(this.component.data.sources));\n    }\n\n    return [];\n  }\n\n  public assembleParentGroupProperties(): any {\n    return null;\n  }\n\n  public assembleSelectionTopLevelSignals(signals: any[]): VgSignal[] {\n    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);\n  }\n\n  public assembleSelectionSignals(): VgSignal[] {\n    this.children.forEach((child) => child.assembleSelectionSignals());\n    return [];\n  }\n\n  public assembleLayoutSignals(): VgSignal[] {\n    return this.children.reduce((signals, child) => {\n      return signals.concat(child.assembleLayoutSignals());\n    }, []);\n  }\n\n  public assembleSelectionData(data: VgData[]): VgData[] {\n    return this.children.reduce((db, child) => child.assembleSelectionData(db), []);\n  }\n\n  public assembleScales(): VgScale[] {\n    // combine with scales from children\n    return this.children.reduce((scales, c) => {\n      return scales.concat(c.assembleScales());\n    }, super.assembleScales());\n  }\n\n  public assembleLayout(): VgLayout {\n    // TODO: allow customization\n    return {\n      padding: {row: 10, column: 10},\n      offset: 10,\n      columns: this.repeat && this.repeat.column ? this.repeat.column.length : 1,\n      bounds: 'full',\n      align: 'all'\n    };\n  }\n\n  public assembleMarks(): any[] {\n    // only children have marks\n    return this.children.map(child => ({\n      type: 'group',\n      name: child.getName('group'),\n      encode: {\n        update: {\n          width: child.getSizeSignalRef('width'),\n          height: child.getSizeSignalRef('height'),\n          ...child.assembleParentGroupProperties()\n        }\n      },\n      ...child.assembleGroup()\n    }));\n  }\n}\n","import {isArray} from 'vega-util';\nimport {vals} from '../../util';\nimport {isDataRefDomain, isDataRefUnionedDomain, isFieldRefUnionDomain, isSignalRefDomain, VgDataRef} from '../../vega.schema';\nimport {Model} from '../model';\n\nexport function assembleScale(model: Model) {\n    return vals(model.component.scales).map(scale => {\n      // correct references to data\n      const domain = scale.domain;\n      if (isDataRefDomain(domain) || isFieldRefUnionDomain(domain)) {\n        domain.data = model.lookupDataSource(domain.data);\n        return scale;\n      } else if (isDataRefUnionedDomain(domain)) {\n        domain.fields = domain.fields.map((f: VgDataRef) => {\n          return {\n            ...f,\n            data: model.lookupDataSource(f.data)\n          };\n        });\n        return scale;\n      } else if (isSignalRefDomain(domain) || isArray(domain)) {\n        return scale;\n      } else {\n        throw new Error('invalid scale domain');\n      }\n    });\n}\n","import * as log from '../../log';\n\nimport {SHARED_DOMAIN_OP_INDEX} from '../../aggregate';\nimport {binToString} from '../../bin';\nimport {Channel} from '../../channel';\nimport {DateTime, isDateTime, timestamp} from '../../datetime';\nimport {FieldDef} from '../../fielddef';\nimport {Domain, hasDiscreteDomain, isBinScale, Scale, ScaleConfig, ScaleType} from '../../scale';\nimport {isSortField} from '../../sort';\nimport * as util from '../../util';\nimport {\n  DataRefUnionDomain,\n  FieldRefUnionDomain,\n  isDataRefDomain,\n  isDataRefUnionedDomain,\n  isFieldRefUnionDomain,\n  isSignalRefDomain,\n  VgDataRef,\n  VgDomain,\n  VgSortField\n} from '../../vega.schema';\n\nimport {MAIN, RAW} from '../../data';\nimport {UnitModel} from '../unit';\n\nexport function initDomain(domain: Domain, fieldDef: FieldDef<string>, scale: ScaleType, scaleConfig: ScaleConfig) {\n  if (domain === 'unaggregated') {\n    const {valid, reason} = canUseUnaggregatedDomain(fieldDef, scale);\n    if(!valid) {\n      log.warn(reason);\n      return undefined;\n    }\n  } else if (domain === undefined && scaleConfig.useUnaggregatedDomain) {\n    // Apply config if domain is not specified.\n    const {valid} = canUseUnaggregatedDomain(fieldDef, scale);\n    if (valid) {\n      return 'unaggregated';\n    }\n  }\n\n  return domain;\n}\n\n\nexport function parseDomain(model: UnitModel, channel: Channel): VgDomain {\n  const scale = model.scale(channel);\n\n  // If channel is either X or Y then union them with X2 & Y2 if they exist\n  if (channel === 'x' && model.channelHasField('x2')) {\n    if (model.channelHasField('x')) {\n      return unionDomains(parseSingleChannelDomain(scale, model, 'x'), parseSingleChannelDomain(scale, model, 'x2'));\n    } else {\n      return parseSingleChannelDomain(scale, model, 'x2');\n    }\n  } else if (channel === 'y' && model.channelHasField('y2')) {\n    if (model.channelHasField('y')) {\n      return unionDomains(parseSingleChannelDomain(scale, model, 'y'), parseSingleChannelDomain(scale, model, 'y2'));\n    } else {\n      return parseSingleChannelDomain(scale, model, 'y2');\n    }\n  }\n  return parseSingleChannelDomain(scale, model, channel);\n}\n\nfunction parseSingleChannelDomain(scale: Scale, model: UnitModel, channel:Channel): VgDomain {\n  const fieldDef = model.fieldDef(channel);\n\n  if (scale.domain && scale.domain !== 'unaggregated') { // explicit value\n    if (isDateTime(scale.domain[0])) {\n      return (scale.domain as DateTime[]).map((dt) => {\n        return timestamp(dt, true);\n      });\n    }\n    return scale.domain;\n  }\n\n  const stack = model.stack;\n  if (stack && channel === stack.fieldChannel) {\n    if(stack.offset === 'normalize') {\n      return [0, 1];\n    }\n    return {\n      data: model.requestDataName(MAIN),\n      fields: [\n        model.field(channel, {suffix: 'start'}),\n        model.field(channel, {suffix: 'end'})\n      ]\n    };\n  }\n\n  const sort = domainSort(model, channel, scale.type);\n\n  if (scale.domain === 'unaggregated') {\n    return {\n      data: model.requestDataName(MAIN),\n      fields: [\n        model.field(channel, {aggregate: 'min'}),\n        model.field(channel, {aggregate: 'max'})\n      ]\n    };\n  } else if (fieldDef.bin) { // bin\n    if (isBinScale(scale.type)) {\n      const signal = model.getName(`${binToString(fieldDef.bin)}_${fieldDef.field}_bins`);\n      return {signal: `sequence(${signal}.start, ${signal}.stop + ${signal}.step, ${signal}.step)`};\n    }\n\n    if (hasDiscreteDomain(scale.type)) {\n      // ordinal bin scale takes domain from bin_range, ordered by bin_start\n      // This is useful for both axis-based scale (x, y, column, and row) and legend-based scale (other channels).\n      return {\n        data: model.requestDataName(MAIN),\n        field: model.field(channel, {binSuffix: 'range'}),\n        sort: {\n          field: model.field(channel, {binSuffix: 'start'}),\n          op: 'min' // min or max doesn't matter since same _range would have the same _start\n        }\n      };\n    } else { // continuous scales\n      if (channel === 'x' || channel === 'y') {\n        // X/Y position have to include start and end for non-ordinal scale\n        return {\n          data: model.requestDataName(MAIN),\n          fields: [\n            model.field(channel, {binSuffix: 'start'}),\n            model.field(channel, {binSuffix: 'end'})\n          ]\n        };\n      } else {\n        // TODO: use bin_mid\n        return {\n          data: model.requestDataName(MAIN),\n          field: model.field(channel, {binSuffix: 'start'})\n        };\n      }\n    }\n  } else if (sort) { // have sort -- only for ordinal\n\n    return {\n      // If sort by aggregation of a specified sort field, we need to use RAW table,\n      // so we can aggregate values for the scale independently from the main aggregation.\n      data: util.isBoolean(sort) ? model.requestDataName(MAIN) : model.requestDataName(RAW),\n      field: model.field(channel),\n      sort: sort\n    };\n  } else {\n    return {\n      data: model.requestDataName(MAIN),\n      field: model.field(channel),\n    };\n  }\n}\n\n\nexport function domainSort(model: UnitModel, channel: Channel, scaleType: ScaleType): VgSortField {\n  if (!hasDiscreteDomain(scaleType)) {\n    return undefined;\n  }\n\n  const sort = model.sort(channel);\n\n  // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n  if (isSortField(sort)) {\n    return {\n      op: sort.op,\n      field: sort.field\n    };\n  }\n\n  if (util.contains(['ascending', 'descending', undefined /* default =ascending*/], sort)) {\n    return true;\n  }\n\n  // sort === 'none'\n  return undefined;\n}\n\n\n\n/**\n * Determine if a scale can use unaggregated domain.\n * @return {Boolean} Returns true if all of the following conditons applies:\n * 1. `scale.domain` is `unaggregated`\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\nexport function canUseUnaggregatedDomain(fieldDef: FieldDef<string>, scaleType: ScaleType): {valid: boolean, reason?: string} {\n  if (!fieldDef.aggregate) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainHasNoEffectForRawField(fieldDef)\n    };\n  }\n\n  if (!SHARED_DOMAIN_OP_INDEX[fieldDef.aggregate]) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainWithNonSharedDomainOp(fieldDef.aggregate)\n    };\n  }\n\n  if (fieldDef.type === 'quantitative') {\n    if (scaleType === 'log') {\n      return {\n        valid: false,\n        reason: log.message.unaggregatedDomainWithLogScale(fieldDef)\n      };\n    }\n  }\n\n  return {valid: true};\n}\n\n/**\n * Scale domains that we can union. We cannot union signal domains we use for\n * binned data because they have to be exactly the same. Otherwise it doesn't\n * make any sense to union.\n */\ntype UnionableDomain = any[] | VgDataRef | DataRefUnionDomain | FieldRefUnionDomain;\n\n/**\n * Convert the domain to an array of data refs or an array of values. Also, throw\n * away sorting information since we always sort the domain when we union two domains.\n */\nfunction normalizeDomain(domain: UnionableDomain): (any[] | VgDataRef)[] {\n  if (util.isArray(domain)) {\n    return [domain];\n  } else if (isDataRefDomain(domain)) {\n    delete domain.sort;\n    return [domain];\n  } else if(isFieldRefUnionDomain(domain)) {\n    return domain.fields.map(d => {\n      return {\n        data: domain.data,\n        field: d\n      };\n    });\n  } else if (isDataRefUnionedDomain(domain)) {\n    return domain.fields.map(d => {\n      if (util.isArray(d)) {\n        return d;\n      }\n      return {\n        data: d.data,\n        field: d.field\n      };\n    });\n  }\n  /* istanbul ignore next: This should never happen. */\n  throw new Error(log.message.INVAID_DOMAIN);\n}\n\n/**\n * Union two data domains. A unioned domain is always sorted.\n */\nexport function unionDomains(domain1: VgDomain, domain2: VgDomain): VgDomain {\n  if (isSignalRefDomain(domain1) || isSignalRefDomain(domain2)) {\n    if (!isSignalRefDomain(domain1) || !isSignalRefDomain(domain2) || domain1.signal !== domain2.signal) {\n      throw new Error(log.message.UNABLE_TO_MERGE_DOMAINS);\n    }\n    return domain1;\n  }\n\n  const normalizedDomain1 = normalizeDomain(domain1);\n  const normalizedDomain2 = normalizeDomain(domain2);\n\n  let domains = normalizedDomain1.concat(normalizedDomain2);\n  domains = util.unique(domains, util.hash);\n\n  if (domains.length > 1) {\n    const allData = domains.map(d => {\n      if (isDataRefDomain(d)) {\n        return d.data;\n      }\n      return null;\n    });\n\n    if (util.unique(allData, x => x).length === 1 && allData[0] !== null) {\n      return {\n        data: allData[0],\n        fields: domains.map(d => (d as VgDataRef).field)\n      };\n    }\n\n    return {fields: domains, sort: true};\n  } else {\n    return domains[0];\n  }\n}\n","import * as log from '../../log';\n\nimport {Channel} from '../../channel';\nimport {Config} from '../../config';\nimport {FieldDef, ScaleFieldDef} from '../../fielddef';\nimport {Mark} from '../../mark';\nimport {channelScalePropertyIncompatability, Scale, ScaleConfig, scaleTypeSupportProperty} from '../../scale';\nimport * as util from '../../util';\n\nimport {initDomain} from './domain';\nimport rangeMixins from './range';\nimport * as rules from './rules';\nimport scaleType from './type';\n\n/**\n * All scale properties except type and all range properties.\n */\nexport const NON_TYPE_RANGE_SCALE_PROPERTIES: (keyof Scale)[] = [\n  // general properties\n  'domain', // For domain, we only copy specified value here.  Default value is determined during parsing phase.\n  'round',\n  // quantitative / time\n  'clamp', 'nice',\n  // quantitative\n  'exponent', 'zero', // zero depends on domain\n  'interpolate',\n  // ordinal\n  'padding', 'paddingInner', 'paddingOuter' // padding\n];\n\n/**\n * Initialize Vega-Lite Scale's properties\n *\n * Note that we have to apply these rules here because:\n * - many other scale and non-scale properties (including layout, mark) depend on scale type\n * - layout depends on padding\n * - range depends on zero and size (width and height) depends on range\n */\nexport default function init(\n    channel: Channel, fieldDef: ScaleFieldDef<string>, config: Config,\n    mark: Mark | undefined, topLevelSize: number | undefined, xyRangeSteps: number[]): Scale {\n  const specifiedScale = (fieldDef || {}).scale || {};\n\n  const scale: Scale = {\n    type: scaleType(\n      specifiedScale.type, channel, fieldDef, mark, topLevelSize !== undefined,\n      specifiedScale.rangeStep, config.scale\n    )\n  };\n\n  // Use specified value if compatible or determine default values for each property\n  NON_TYPE_RANGE_SCALE_PROPERTIES.forEach(function(property) {\n    const specifiedValue = specifiedScale[property];\n\n    const supportedByScaleType = scaleTypeSupportProperty(scale.type, property);\n    const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n\n    if (specifiedValue !== undefined) {\n      // If there is a specified value, check if it is compatible with scale type and channel\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scale.type, property, channel));\n      } else if (channelIncompatability) { // channel\n        log.warn(channelIncompatability);\n      }\n    }\n    if (supportedByScaleType && channelIncompatability === undefined) {\n      const value = getValue(specifiedValue, property, scale, channel, fieldDef, config.scale);\n      if (value !== undefined) { // use the default value\n        scale[property] = value;\n      }\n    }\n  });\n\n  return util.extend(\n    scale,\n    rangeMixins(\n      channel, scale.type, fieldDef.type, specifiedScale, config,\n      scale.zero, mark, topLevelSize, xyRangeSteps\n    )\n  );\n}\n\nfunction getValue(specifiedValue: any, property: keyof Scale, scale: Scale, channel: Channel, fieldDef: FieldDef<string>, scaleConfig: ScaleConfig) {\n  // For domain, we might override specified value\n  if (property === 'domain') {\n    return initDomain(specifiedValue, fieldDef, scale.type, scaleConfig);\n  }\n\n  // Other properties, no overriding default values\n  if (specifiedValue !== undefined) {\n    return specifiedValue;\n  }\n  return getDefaultValue(property, scale, channel, fieldDef, scaleConfig);\n}\n\nfunction getDefaultValue(property: keyof Scale, scale: Scale, channel: Channel, fieldDef: FieldDef<string>, scaleConfig: ScaleConfig) {\n\n  // If we have default rule-base, determine default value first\n  switch (property) {\n    case 'nice':\n      return rules.nice(scale.type, channel, fieldDef);\n    case 'padding':\n      return rules.padding(channel, scale.type, scaleConfig);\n    case 'paddingInner':\n      return rules.paddingInner(scale.padding, channel, scaleConfig);\n    case 'paddingOuter':\n      return rules.paddingOuter(scale.padding, channel, scale.type, scale.paddingInner, scaleConfig);\n    case 'round':\n      return rules.round(channel, scaleConfig);\n    case 'zero':\n      return rules.zero(scale, channel, fieldDef);\n  }\n  // Otherwise, use scale config\n  return scaleConfig[property];\n}\n","import {Channel} from '../../channel';\nimport {Scale} from '../../scale';\nimport {isSortField} from '../../sort';\nimport {Dict} from '../../util';\nimport {VgScale} from '../../vega.schema';\n\nimport {UnitModel} from '../unit';\n\nimport {parseDomain} from './domain';\nimport {parseRange} from './range';\n\n/**\n * Parse scales for all channels of a model.\n */\nexport default function parseScaleComponent(model: UnitModel): Dict<VgScale> {\n  // TODO: should model.channels() inlcude X2/Y2?\n  return model.channels().reduce(function(scaleComponentsIndex: Dict<VgScale>, channel: Channel) {\n    const scaleComponents = parseScale(model, channel);\n    if (scaleComponents) {\n      scaleComponentsIndex[channel] = scaleComponents;\n    }\n    return scaleComponentsIndex;\n  }, {});\n}\n\nexport const NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES: (keyof Scale)[] = [\n  'round',\n  // quantitative / time\n  'clamp', 'nice',\n  // quantitative\n  'exponent', 'interpolate', 'zero', // zero depends on domain\n  // ordinal\n  'padding', 'paddingInner', 'paddingOuter', // padding\n];\n\n/**\n * Parse scales for a single channel of a model.\n */\nexport function parseScale(model: UnitModel, channel: Channel) {\n  if (!model.scale(channel)) {\n    return null;\n  }\n\n  const scale = model.scale(channel);\n  const sort = model.sort(channel);\n\n  const scaleComponent: VgScale = {\n    name: model.scaleName(channel + '', true),\n    type: scale.type,\n    domain: parseDomain(model, channel),\n    range: parseRange(scale)\n  };\n\n  NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES.forEach((property) => {\n    scaleComponent[property] = scale[property];\n  });\n\n  if (sort && (isSortField(sort) ? sort.order : sort) === 'descending') {\n    scaleComponent.reverse = true;\n  }\n  return scaleComponent;\n}\n","import * as log from '../../log';\n\nimport {Channel, COLOR, COLUMN, OPACITY, ROW, SHAPE, SIZE, X, Y} from '../../channel';\nimport {Config} from '../../config';\nimport {Mark} from '../../mark';\nimport {channelScalePropertyIncompatability, isExtendedScheme, Range, Scale, ScaleConfig, ScaleType, scaleTypeSupportProperty, Scheme} from '../../scale';\nimport {Type} from '../../type';\nimport * as util from '../../util';\nimport {VgRange, VgRangeScheme} from '../../vega.schema';\n\nexport type RangeMixins = {range: Range} | {rangeStep: number} | {scheme: Scheme};\n\nexport function parseRange(scale: Scale): VgRange {\n  if (scale.rangeStep) {\n    return {step: scale.rangeStep};\n  } else if (scale.scheme) {\n    const scheme = scale.scheme;\n    if (isExtendedScheme(scheme)) {\n      const r: VgRangeScheme = {scheme: scheme.name};\n      if (scheme.count) {\n        r.count = scheme.count;\n      }\n      if (scheme.extent) {\n        r.extent = scheme.extent;\n      }\n      return r;\n    } else {\n      return {scheme};\n    }\n  }\n  return scale.range;\n}\n\nexport const RANGE_PROPERTIES: (keyof Scale)[] = ['range', 'rangeStep', 'scheme'];\n\n/**\n * Return mixins that includes one of the range properties (range, rangeStep, scheme).\n */\nexport default function rangeMixins(\n  channel: Channel, scaleType: ScaleType, type: Type, specifiedScale: Scale, config: Config,\n  zero: boolean, mark: Mark, topLevelSize: number | undefined, xyRangeSteps: number[]): RangeMixins {\n\n  let specifiedRangeStepIsNull = false;\n\n  // Check if any of the range properties is specified.\n  // If so, check if it is compatible and make sure that we only output one of the properties\n  for (const property of RANGE_PROPERTIES) {\n    if (specifiedScale[property] !== undefined) {\n      const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n      const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) { // channel\n        log.warn(channelIncompatability);\n      } else {\n        switch (property) {\n          case 'range':\n            return {range: specifiedScale[property]};\n          case 'scheme':\n            return {scheme: specifiedScale[property]};\n          case 'rangeStep':\n            if (topLevelSize === undefined) {\n              const stepSize = specifiedScale[property];\n              if (stepSize !== null) {\n                return {rangeStep: stepSize};\n              } else {\n                specifiedRangeStepIsNull = true;\n              }\n            } else {\n              // If top-level size is specified, we ignore specified rangeStep.\n              log.warn(log.message.rangeStepDropped(channel));\n            }\n        }\n      }\n    }\n  }\n\n  switch (channel) {\n    // TODO: revise row/column when facetSpec has top-level width/height\n    case ROW:\n      return {range: 'height'};\n    case COLUMN:\n      return {range: 'width'};\n    case X:\n    case Y:\n      if (topLevelSize === undefined) {\n        if (util.contains(['point', 'band'], scaleType) && !specifiedRangeStepIsNull) { // FIXME isDiscrete blah blah\n          if (channel === X && mark === 'text') {\n            if (config.scale.textXRangeStep) {\n              return {rangeStep: config.scale.textXRangeStep};\n            }\n          } else {\n            if (config.scale.rangeStep) {\n              return {rangeStep: config.scale.rangeStep};\n            }\n          }\n        }\n        // If specified range step is null or the range step config is null.\n        // Use default topLevelSize rule/config\n        topLevelSize = channel === X ? config.cell.width : config.cell.height;\n      }\n      return {range: channel === X ? [0, topLevelSize] : [topLevelSize, 0]};\n\n    case SIZE:\n      // TODO: support custom rangeMin, rangeMax\n      const rangeMin = sizeRangeMin(mark, zero, config);\n      const rangeMax = sizeRangeMax(mark, xyRangeSteps, config);\n      return {range: [rangeMin, rangeMax]};\n    case SHAPE:\n    case COLOR:\n      return {range: defaultRange(channel, scaleType, type, mark)};\n\n\n    case OPACITY:\n      // TODO: support custom rangeMin, rangeMax\n      return {range: [config.scale.minOpacity, config.scale.maxOpacity]};\n  }\n  /* istanbul ignore next: should never reach here */\n  throw new Error(`Scale range undefined for channel ${channel}`);\n}\n\nfunction defaultRange(channel: 'shape' | 'color', scaleType: ScaleType, type: Type, mark: Mark) {\n  switch (channel) {\n    case SHAPE:\n      return 'symbol';\n    case COLOR:\n      if (scaleType === 'ordinal') {\n        // Only nominal data uses ordinal scale by default\n        return type === 'nominal' ? 'category' : 'ordinal';\n      }\n      return mark === 'rect' ? 'heatmap' : 'ramp';\n  }\n}\n\nfunction sizeRangeMin(mark: Mark, zero: boolean, config: Config) {\n  if (zero) {\n    return 0;\n  }\n  switch (mark) {\n    case 'bar':\n      return config.scale.minBandSize !== undefined ? config.scale.minBandSize : config.bar.continuousBandSize;\n    case 'tick':\n      return config.scale.minBandSize;\n    case 'line':\n    case 'rule':\n      return config.scale.minStrokeWidth;\n    case 'text':\n      return config.scale.minFontSize;\n    case 'point':\n    case 'square':\n    case 'circle':\n      if (config.scale.minSize) {\n        return config.scale.minSize;\n      }\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMin not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\nfunction sizeRangeMax(mark: Mark, xyRangeSteps: number[], config: Config) {\n  const scaleConfig = config.scale;\n  // TODO(#1168): make max size scale based on rangeStep / overall plot size\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      if (config.scale.maxBandSize !== undefined) {\n        return config.scale.maxBandSize;\n      }\n      return minXYRangeStep(xyRangeSteps, config.scale) - 1;\n    case 'line':\n    case 'rule':\n      return config.scale.maxStrokeWidth;\n    case 'text':\n      return config.scale.maxFontSize;\n    case 'point':\n    case 'square':\n    case 'circle':\n      if (config.scale.maxSize) {\n        return config.scale.maxSize;\n      }\n\n      // FIXME this case totally should be refactored\n      const pointStep = minXYRangeStep(xyRangeSteps, scaleConfig);\n      return (pointStep - 2) * (pointStep - 2);\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMax not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\n/**\n * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.\n */\nfunction minXYRangeStep(xyRangeSteps: number[], scaleConfig: ScaleConfig): number {\n  if (xyRangeSteps.length > 0) {\n    return Math.min.apply(null, xyRangeSteps);\n  }\n  if (scaleConfig.rangeStep) {\n    return scaleConfig.rangeStep;\n  }\n  return 21; // FIXME: re-evaluate the default value here.\n}\n","\nimport {Channel, X, Y} from '../../channel';\nimport {FieldDef} from '../../fielddef';\nimport {NiceTime, Scale, ScaleConfig, ScaleType} from '../../scale';\nimport {smallestUnit} from '../../timeunit';\nimport * as util from '../../util';\n\nexport function nice(scaleType: ScaleType, channel: Channel, fieldDef: FieldDef<string>): boolean | NiceTime {\n  if (util.contains([ScaleType.TIME, ScaleType.UTC], scaleType)) {\n    return smallestUnit(fieldDef.timeUnit) as any;\n  }\n  return util.contains([X, Y], channel); // return true for quantitative X/Y\n}\n\nexport function padding(channel: Channel, scaleType: ScaleType, scaleConfig: ScaleConfig) {\n  if (util.contains([X, Y], channel)) {\n    if (scaleType === ScaleType.POINT) {\n      return scaleConfig.pointPadding;\n    }\n  }\n  return undefined;\n}\n\nexport function paddingInner(padding: number, channel: Channel,  scaleConfig: ScaleConfig) {\n  if (padding !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingInner.\n    return undefined;\n  }\n\n  if (util.contains([X, Y], channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n\n    // paddingOuter would only be called if it's a band scale, just return the default for bandScale.\n    return scaleConfig.bandPaddingInner;\n  }\n  return undefined;\n}\n\nexport function paddingOuter(padding: number, channel: Channel, scaleType: ScaleType, paddingInner: number, scaleConfig: ScaleConfig) {\n  if (padding !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingOuter.\n    return undefined;\n  }\n\n  if (util.contains([X, Y], channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    if (scaleType === ScaleType.BAND) {\n      if (scaleConfig.bandPaddingOuter !== undefined) {\n        return scaleConfig.bandPaddingOuter;\n      }\n      /* By default, paddingOuter is paddingInner / 2. The reason is that\n          size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).\n          and we want the width/height to be integer by default.\n          Note that step (by default) and cardinality are integers.) */\n      return paddingInner / 2;\n    }\n  }\n  return undefined;\n}\n\nexport function round(channel: Channel, scaleConfig: ScaleConfig) {\n  if (util.contains(['x', 'y', 'row', 'column'], channel)) {\n    return scaleConfig.round;\n  }\n  return undefined;\n}\n\nexport function zero(specifiedScale: Scale, channel: Channel, fieldDef: FieldDef<string>) {\n  // By default, return true only for the following cases:\n\n  // 1) using quantitative field with size\n  // While this can be either ratio or interval fields, our assumption is that\n  // ratio are more common.\n  if (channel === 'size' && fieldDef.type === 'quantitative') {\n    return true;\n  }\n\n  // 2) non-binned, quantitative x-scale or y-scale if no custom domain is provided.\n  // (For binning, we should not include zero by default because binning are calculated without zero.\n  // Similar, if users explicitly provide a domain range, we should not augment zero as that will be unexpected.)\n  if (!specifiedScale.domain && !fieldDef.bin && util.contains([X, Y], channel)) {\n    return true;\n  }\n  return false;\n}\n","import * as log from '../../log';\n\nimport {Channel, hasScale, rangeType, supportScaleType} from '../../channel';\nimport {Mark} from '../../mark';\nimport {ScaleConfig, ScaleType} from '../../scale';\nimport {isDiscreteByDefault} from '../../timeunit';\n\nimport {FieldDef} from '../../fielddef';\nimport {hasDiscreteDomain} from '../../scale';\nimport {Type} from '../../type';\nimport * as util from '../../util';\nimport {contains} from '../../util';\n\nexport type RangeType = 'continuous' | 'discrete' | 'flexible' | undefined;\n\n/**\n * Determine if there is a specified scale type and if it is appropriate,\n * or determine default type if type is unspecified or inappropriate.\n */\n// NOTE: CompassQL uses this method.\nexport default function type(\n  specifiedType: ScaleType, channel: Channel, fieldDef: FieldDef<string>, mark: Mark,\n  hasTopLevelSize: boolean, specifiedRangeStep: number, scaleConfig: ScaleConfig): ScaleType {\n\n  const defaultScaleType = defaultType(channel, fieldDef, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig);\n\n  if (!hasScale(channel)) {\n    // There is no scale for these channels\n    return null;\n  }\n  if (specifiedType !== undefined) {\n    // Check if explicitly specified scale type is supported by the channel\n    if (!supportScaleType(channel, specifiedType)) {\n      log.warn(log.message.scaleTypeNotWorkWithChannel(channel, specifiedType, defaultScaleType));\n      return defaultScaleType;\n    }\n\n    // Check if explicitly specified scale type is supported by the data type\n    if (!fieldDefMatchScaleType(specifiedType, fieldDef)) {\n      log.warn(log.message.scaleTypeNotWorkWithFieldDef(specifiedType, defaultScaleType));\n      return defaultScaleType;\n    }\n\n    return specifiedType;\n  }\n\n  return defaultScaleType;\n}\n\n/**\n * Determine appropriate default scale type.\n */\nfunction defaultType(channel: Channel, fieldDef: FieldDef<string>, mark: Mark,\n  hasTopLevelSize: boolean, specifiedRangeStep: number, scaleConfig: ScaleConfig): ScaleType {\n\n  if (util.contains(['row', 'column'], channel)) {\n    return 'band';\n  }\n\n  switch (fieldDef.type) {\n    case 'nominal':\n      if (channel === 'color' || rangeType(channel) === 'discrete') {\n        return 'ordinal';\n      }\n      return discreteToContinuousType(channel, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig);\n\n    case 'ordinal':\n      if (channel === 'color') {\n        return 'ordinal';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'ordinal'));\n        return 'ordinal';\n      }\n      return discreteToContinuousType(channel, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig);\n\n    case 'temporal':\n      if (channel === 'color') {\n        // Always use `sequential` as the default color scale for continuous data\n        // since it supports both array range and scheme range.\n        return 'sequential';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'temporal'));\n        // TODO: consider using quantize (equivalent to binning) once we have it\n        return 'ordinal';\n      }\n      if (isDiscreteByDefault(fieldDef.timeUnit)) {\n        return discreteToContinuousType(channel, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig);\n      }\n      return 'time';\n\n    case 'quantitative':\n      if (channel === 'color') {\n        if (fieldDef.bin) {\n          return 'bin-ordinal';\n        }\n        // Use `sequential` as the default color scale for continuous data\n        // since it supports both array range and scheme range.\n        return 'sequential';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'quantitative'));\n        // TODO: consider using quantize (equivalent to binning) once we have it\n        return 'ordinal';\n      }\n\n      if (fieldDef.bin) {\n        return 'bin-linear';\n      }\n      return 'linear';\n  }\n\n  /* istanbul ignore next: should never reach this */\n  throw new Error(log.message.invalidFieldType(fieldDef.type));\n}\n\n/**\n * Determines default scale type for nominal/ordinal field.\n * @returns BAND or POINT scale based on channel, mark, and rangeStep\n */\nfunction discreteToContinuousType(\n    channel: Channel, mark: Mark, hasTopLevelSize: boolean,\n    specifiedRangeStep: number, scaleConfig: ScaleConfig): ScaleType {\n\n  if (util.contains(['x', 'y'], channel)) {\n    if (mark === 'rect') {\n      // The rect mark should fit into a band.\n      return 'band';\n    }\n    if (mark === 'bar') {\n      // For bar, use band only if there is no rangeStep since we need to use band for fit mode.\n      // However, for non-fit mode, point scale provides better center position.\n      if (haveRangeStep(hasTopLevelSize, specifiedRangeStep, scaleConfig)) {\n        return 'point';\n      }\n      return 'band';\n    }\n  }\n  // Otherwise, use ordinal point scale so we can easily get center positions of the marks.\n  return 'point';\n}\n\nfunction haveRangeStep(hasTopLevelSize: boolean, specifiedRangeStep: number, scaleConfig: ScaleConfig) {\n  if (hasTopLevelSize) {\n    // if topLevelSize is provided, rangeStep will be dropped.\n    return false;\n  }\n  if (specifiedRangeStep !== undefined) {\n    return specifiedRangeStep !== null;\n  }\n  return !!scaleConfig.rangeStep;\n}\n\nexport function fieldDefMatchScaleType(specifiedType: ScaleType, fieldDef: FieldDef<string>):boolean {\n  const type: Type = fieldDef.type;\n  if (contains([Type.ORDINAL, Type.NOMINAL], type)) {\n    return specifiedType === undefined || hasDiscreteDomain(specifiedType);\n  } else if (type === Type.TEMPORAL) {\n    if (!fieldDef.timeUnit) {\n      return contains([ScaleType.TIME, ScaleType.UTC, undefined], specifiedType);\n    } else {\n      return contains([ScaleType.TIME, ScaleType.UTC, undefined], specifiedType) || hasDiscreteDomain(specifiedType);\n    }\n  } else if (type === Type.QUANTITATIVE) {\n    if (fieldDef.bin) {\n      return specifiedType === ScaleType.BIN_LINEAR || specifiedType === ScaleType.BIN_ORDINAL;\n    }\n    return contains([ScaleType.LOG, ScaleType.POW, ScaleType.SQRT, ScaleType.QUANTILE, ScaleType.QUANTIZE, ScaleType.LINEAR, undefined], specifiedType);\n  }\n\n  return true;\n}\n","import {Channel, X, Y} from '../../channel';\nimport {warn} from '../../log';\nimport {extend, keys, stringValue} from '../../util';\nimport {UnitModel} from '../unit';\nimport {channelSignalName, invert as invertFn, ProjectComponent, SelectionCompiler, SelectionComponent, STORE, TUPLE} from './selection';\nimport scales from './transforms/scales';\n\nexport const BRUSH = '_brush',\n  SIZE = '_size';\n\nconst interval:SelectionCompiler = {\n  predicate: 'vlInterval',\n\n  signals: function(model, selCmpt) {\n    const signals: any[] = [],\n        intervals:any[] = [],\n        name = selCmpt.name,\n        size = name + SIZE;\n\n    if (selCmpt.translate && !(scales.has(selCmpt))) {\n      events(selCmpt, function(_: any[], evt: any) {\n        const filters = evt.between[0].filter || (evt.between[0].filter = []);\n        filters.push('!event.item || (event.item && ' +\n          `event.item.mark.name !== ${stringValue(name + BRUSH)})`);\n      });\n    }\n\n    selCmpt.project.forEach(function(p) {\n      if (p.encoding !== X && p.encoding !== Y) {\n        warn('Interval selections only support x and y encoding channels.');\n        return;\n      }\n\n      const cs = channelSignal(model, selCmpt, p.encoding);\n      signals.push(cs);\n      intervals.push(`{field: ${stringValue(p.field)}, extent: ${cs.name}}`);\n    });\n\n    signals.push({\n      name: size,\n      value: [],\n      on: events(selCmpt, function(on: any[], evt: any) {\n        on.push({\n          events: evt.between[0],\n          update: '{x: x(unit), y: y(unit), width: 0, height: 0}'\n        });\n\n        on.push({\n          events: evt,\n          update: `{x: ${size}.x, y: ${size}.y, ` +\n           `width: abs(x(unit) - ${size}.x), height: abs(y(unit) - ${size}.y)}`\n        });\n\n        return on;\n      })\n    }, {\n      name: name,\n      update: `[${intervals.join(', ')}]`\n    });\n\n    return signals;\n  },\n\n  tupleExpr: function(model, selCmpt) {\n    return `intervals: ${selCmpt.name}`;\n  },\n\n  modifyExpr: function(model, selCmpt) {\n    const tpl = selCmpt.name + TUPLE;\n    return tpl + ', ' +\n      (selCmpt.resolve === 'global' ? 'true' : `{unit: ${tpl}.unit}`);\n  },\n\n  marks: function(model, selCmpt, marks) {\n    const name = selCmpt.name,\n        {xi, yi} = projections(selCmpt),\n        tpl = name + TUPLE,\n        store = `data(${stringValue(selCmpt.name + STORE)})`;\n\n    // Do not add a brush if we're binding to scales.\n    if (scales.has(selCmpt)) {\n      return marks;\n    }\n\n    const update = {\n      x: extend({}, xi !== null ?\n        {scale: model.scaleName(X), signal: `${name}[${xi}].extent[0]`} :\n        {value: 0}),\n\n      x2: extend({}, xi !== null ?\n        {scale: model.scaleName(X), signal: `${name}[${xi}].extent[1]`} :\n        {field: {group: 'width'}}),\n\n      y: extend({}, yi !== null ?\n        {scale: model.scaleName(Y), signal: `${name}[${yi}].extent[0]`} :\n        {value: 0}),\n\n      y2: extend({}, yi !== null ?\n        {scale: model.scaleName(Y), signal: `${name}[${yi}].extent[1]`} :\n        {field: {group: 'height'}})\n    };\n\n    // If the selection is resolved to global, only a single interval is in\n    // the store. Wrap brush mark's encodings with a production rule to test\n    // this based on the `unit` property. Hide the brush mark if it corresponds\n    // to a unit different from the one in the store.\n    if (selCmpt.resolve === 'global') {\n      keys(update).forEach(function(key) {\n        update[key] = [{\n          test: `${store}.length && ${tpl} && ${tpl}.unit === ${store}[0].unit`,\n          ...update[key]\n        }, {value: 0}];\n      });\n    }\n\n    return [{\n      name: undefined,\n      type: 'rect',\n      encode: {\n        enter: {fill: {value: '#eee'}},\n        update: update\n      }\n    }].concat(marks, {\n      name: name + BRUSH,\n      type: 'rect',\n      encode: {\n        enter: {fill: {value: 'transparent'}},\n        update: update\n      }\n    });\n  }\n};\nexport {interval as default};\n\nexport function projections(selCmpt: SelectionComponent) {\n  let x:ProjectComponent = null, xi:number = null,\n      y:ProjectComponent = null, yi: number = null;\n  selCmpt.project.forEach(function(p, i) {\n    if (p.encoding === X) {\n      x  = p;\n      xi = i;\n    } else if (p.encoding === Y) {\n      y = p;\n      yi = i;\n    }\n  });\n  return {x, xi, y, yi};\n}\n\nfunction channelSignal(model: UnitModel, selCmpt: SelectionComponent, channel: Channel): any {\n  const name  = channelSignalName(selCmpt, channel),\n      size  = model.getSizeSignalRef(channel === X ? 'width' : 'height').signal,\n      coord = `${channel}(unit)`,\n      invert = invertFn.bind(null, model, selCmpt, channel);\n\n  return {\n    name: name,\n    value: [],\n    on: scales.has(selCmpt) ? [] : events(selCmpt, function(on: any[], evt: any) {\n      on.push({\n        events: evt.between[0],\n        update: invert(`[${coord}, ${coord}]`)\n      });\n\n      on.push({\n        events: evt,\n        update: `[${name}[0], ` + invert(`clamp(${coord}, 0, ${size})`) + ']'\n      });\n\n      return on;\n    })\n  };\n}\n\nfunction events(selCmpt: SelectionComponent, cb: Function) {\n  return selCmpt.events.reduce(function(on: any[], evt: any) {\n    if (!evt.between) {\n      warn(`${evt} is not an ordered event stream for interval selections`);\n      return on;\n    }\n    return cb(on, evt);\n  }, []);\n}\n","import {stringValue} from '../../util';\nimport {SelectionCompiler, TUPLE} from './selection';\n\nconst multi:SelectionCompiler = {\n  predicate: 'vlPoint',\n\n  signals: function(model, selCmpt) {\n    const proj = selCmpt.project,\n        datum  = '(item().isVoronoi ? datum.datum : datum)',\n        fields = proj.map((p) => stringValue(p.field)).join(', '),\n        values = proj.map((p) => `${datum}[${stringValue(p.field)}]`).join(', ');\n    return [{\n      name: selCmpt.name,\n      value: {},\n      on: [{\n        events: selCmpt.events,\n        update: `{fields: [${fields}], values: [${values}]}`\n      }]\n    }];\n  },\n\n  tupleExpr: function(model, selCmpt) {\n    const name = selCmpt.name;\n    return `fields: ${name}.fields, values: ${name}.values`;\n  },\n\n  modifyExpr: function(model, selCmpt) {\n    const tpl = selCmpt.name + TUPLE;\n    return tpl + ', ' +\n      (selCmpt.resolve === 'global' ? 'null' : `{unit: ${tpl}.unit}`);\n  }\n};\n\nexport {multi as default};\n","import {selector as parseSelector} from 'vega-event-selector';\nimport {Channel} from '../../channel';\nimport {SelectionDef, SelectionDomain, SelectionResolutions, SelectionTypes} from '../../selection';\nimport {Dict, extend, isString, stringValue} from '../../util';\nimport {VgBinding, VgData} from '../../vega.schema';\nimport {LayerModel} from '../layer';\nimport {Model} from '../model';\nimport {UnitModel} from '../unit';\nimport intervalCompiler from './interval';\nimport multiCompiler from './multi';\nimport {SelectionComponent} from './selection';\nimport singleCompiler from './single';\nimport {forEachTransform} from './transforms/transforms';\n\nexport const STORE = '_store';\nexport const TUPLE  = '_tuple';\nexport const MODIFY = '_modify';\n\nexport interface SelectionComponent {\n  name: string;\n  type: SelectionTypes;\n  domain: SelectionDomain;\n  events: any;\n  // predicate?: string;\n  bind?: 'scales' | VgBinding | {[key: string]: VgBinding};\n  resolve: SelectionResolutions;\n\n  // Transforms\n  project?: ProjectComponent[];\n  fields?: any;\n  scales?: Channel[];\n  toggle?: any;\n  translate?: any;\n  zoom?: any;\n  nearest?: any;\n}\n\nexport interface ProjectComponent {\n  field?: string;\n  encoding?: Channel;\n}\n\nexport interface SelectionCompiler {\n  signals: (model: UnitModel, selCmpt: SelectionComponent) => any[];\n  topLevelSignals?: (model: Model, selCmpt: SelectionComponent) => any[];\n  tupleExpr: (model: UnitModel, selCmpt: SelectionComponent) => string;\n  modifyExpr: (model: UnitModel, selCmpt: SelectionComponent) => string;\n  marks?: (model: UnitModel, selCmpt:SelectionComponent, marks: any[]) => any[];\n  predicate: string;  // Vega expr string to determine inclusion in selection.\n}\n\nexport function parseUnitSelection(model: UnitModel, selDefs: Dict<SelectionDef>) {\n  const selCmpts: Dict<SelectionComponent> = {},\n      selectionConfig = model.config.selection;\n\n  for (const name in selDefs) {\n    if (!selDefs.hasOwnProperty(name)) {\n      continue;\n    }\n\n    const selDef = selDefs[name],\n        cfg = selectionConfig[selDef.type];\n\n    // Set default values from config if a property hasn't been specified,\n    // or if it is true. E.g., \"translate\": true should use the default\n    // event handlers for translate. However, true may be a valid value for\n    // a property (e.g., \"nearest\": true).\n    for (const key in cfg) {\n      // A selection should contain either `encodings` or `fields`, only use\n      // default values for these two values if neither of them is specified.\n      if ((key === 'encodings' && selDef.fields) || (key === 'fields' && selDef.encodings)) {\n        continue;\n      }\n\n      if (selDef[key] === undefined || selDef[key] === true) {\n        selDef[key] = cfg[key] || selDef[key];\n      }\n    }\n\n    const selCmpt = selCmpts[name] = extend({}, selDef, {\n      name: name,\n      events: isString(selDef.on) ? parseSelector(selDef.on, 'scope') : selDef.on,\n      domain: 'data' as SelectionDomain, // TODO: Support def.domain\n    }) as SelectionComponent;\n\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.parse) {\n        txCompiler.parse(model, selDef, selCmpt);\n      }\n    });\n  }\n\n  return selCmpts;\n}\n\nexport function assembleUnitSelectionSignals(model: UnitModel, signals: any[]) {\n  forEachSelection(model, (selCmpt, selCompiler) => {\n    const name = selCmpt.name,\n        tupleExpr = selCompiler.tupleExpr(model, selCmpt);\n    let modifyExpr = selCompiler.modifyExpr(model, selCmpt);\n\n    signals.push.apply(signals, selCompiler.signals(model, selCmpt));\n\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.signals) {\n        signals = txCompiler.signals(model, selCmpt, signals);\n      }\n      if (txCompiler.modifyExpr) {\n        modifyExpr = txCompiler.modifyExpr(model, selCmpt, modifyExpr);\n      }\n    });\n\n    signals.push({\n      name: name + TUPLE,\n      on: [{\n        events: {signal: name},\n        update: `{unit: unit.datum && unit.datum._id, ${tupleExpr}}`\n      }]\n    }, {\n      name: name + MODIFY,\n      on: [{\n        events: {signal: name},\n        update: `modify(${stringValue(selCmpt.name + STORE)}, ${modifyExpr})`\n      }]\n    });\n  });\n\n  return signals;\n}\n\nexport function assembleTopLevelSignals(model: UnitModel, signals: any[]) {\n  const hasUnit = signals.filter((s) => s.name === 'unit');\n  if (!(hasUnit.length)) {\n    signals.push({\n      name: 'unit',\n      value: {},\n      on: [{events: 'mousemove', update: 'group()._id ? group() : unit'}]\n    });\n  }\n\n  forEachSelection(model, (selCmpt, selCompiler) => {\n    if (selCompiler.topLevelSignals) {\n      signals.push.apply(signals, selCompiler.topLevelSignals(model, selCmpt));\n    }\n\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.topLevelSignals) {\n        signals = txCompiler.topLevelSignals(model, selCmpt, signals);\n      }\n    });\n  });\n\n  return signals;\n}\n\nexport function assembleUnitSelectionData(model: UnitModel, data: VgData[]): VgData[] {\n  forEachSelection(model, selCmpt => {\n    const contains = data.filter((d) => d.name === selCmpt.name + STORE);\n    if (!contains.length) {\n      data.push({name: selCmpt.name + STORE});\n    }\n  });\n\n  return data;\n}\n\nexport function assembleUnitSelectionMarks(model: UnitModel, marks: any[]): any[] {\n  let clipGroup = false,\n      selMarks = marks;\n  forEachSelection(model, (selCmpt, selCompiler) => {\n    selMarks = selCompiler.marks ? selCompiler.marks(model, selCmpt, selMarks) : selMarks;\n    forEachTransform(selCmpt, (txCompiler) => {\n      clipGroup = clipGroup || txCompiler.clipGroup;\n      if (txCompiler.marks) {\n        selMarks = txCompiler.marks(model, selCmpt, marks, selMarks);\n      }\n    });\n  });\n\n  // In a layered spec, we want to clip all layers together rather than\n  // only the layer within which the selection is defined. Propagate\n  // our assembled state up and let the LayerModel make the right call.\n  if (model.parent && model.parent instanceof LayerModel) {\n    return [selMarks, clipMarks];\n  } else {\n    return clipGroup ? clipMarks(selMarks) : selMarks;\n  }\n}\n\nexport function assembleLayerSelectionMarks(model: LayerModel, marks: any[]): any[] {\n  let clipGroup = false;\n  model.children.forEach(child => {\n    const unit = assembleUnitSelectionMarks(child, marks);\n    marks = unit[0];\n    clipGroup = clipGroup || unit[1];\n  });\n  return clipGroup ? clipMarks(marks) : marks;\n}\n\nconst PREDICATES_OPS = {\n  'global': '\"union\", \"all\"',\n  'independent': '\"intersect\", \"unit\"',\n  'union': '\"union\", \"all\"',\n  'union_others': '\"union\", \"others\"',\n  'intersect': '\"intersect\", \"all\"',\n  'intersect_others': '\"intersect\", \"others\"'\n};\n\nexport function predicate(selCmpt: SelectionComponent, datum?: string): string {\n  const store = stringValue(selCmpt.name + STORE),\n        op = PREDICATES_OPS[selCmpt.resolve];\n  datum = datum || 'datum';\n  return compiler(selCmpt).predicate + `(${store}, parent._id, ${datum}, ${op})`;\n}\n\n// Utility functions\n\nfunction forEachSelection(model: Model, cb: (selCmpt: SelectionComponent, selCompiler: SelectionCompiler) => void) {\n  const selections = model.component.selection;\n  for (const name in selections) {\n    if (selections.hasOwnProperty(name)) {\n      const sel = selections[name];\n      cb(sel, compiler(sel));\n    }\n  }\n}\n\nfunction compiler(selCmpt: SelectionComponent): SelectionCompiler {\n  switch (selCmpt.type) {\n    case 'single':\n      return singleCompiler;\n    case 'multi':\n      return multiCompiler;\n    case 'interval':\n      return intervalCompiler;\n  }\n  return null;\n}\n\nexport function invert(model: UnitModel, selCmpt: SelectionComponent, channel: Channel, expr: string) {\n  const scale = stringValue(model.scaleName(channel));\n  return selCmpt.domain === 'data' ? `invert(${scale}, ${expr})` : expr;\n}\n\nexport function channelSignalName(selCmpt: SelectionComponent, channel: Channel) {\n  return selCmpt.name + '_' + selCmpt.fields[channel];\n}\n\nfunction clipMarks(marks: any[]): any[] {\n  return marks.map((m) => (m.clip = true, m));\n}\n","import {stringValue} from '../../util';\nimport multi from './multi';\nimport {SelectionCompiler, STORE, TUPLE} from './selection';\n\nconst single:SelectionCompiler = {\n  predicate: multi.predicate,\n\n  signals: multi.signals,\n\n  topLevelSignals: function(model, selCmpt) {\n    return [{\n      name: selCmpt.name,\n      update: `data(${stringValue(selCmpt.name + STORE)})[0]`\n    }];\n  },\n\n  tupleExpr: function(model, selCmpt) {\n    const name = selCmpt.name, values = `${name}.values`;\n    return `fields: ${name}.fields, values: ${values}, ` +\n      selCmpt.project.map(function(p, i) {\n        return `${p.field}: ${values}[${i}]`;\n      }).join(', ');\n  },\n\n  modifyExpr: function(model, selCmpt) {\n    const tpl = selCmpt.name + TUPLE;\n    return tpl + ', ' +\n      (selCmpt.resolve === 'global' ? 'true' : `{unit: ${tpl}.unit}`);\n  }\n};\n\nexport {single as default};\n","import {stringValue} from '../../../util';\nimport {TransformCompiler} from './transforms';\n\nconst inputBindings:TransformCompiler = {\n  has: function(selCmpt) {\n    return selCmpt.type === 'single' && selCmpt.resolve === 'global' &&\n      selCmpt.bind && selCmpt.bind !== 'scales';\n  },\n\n  topLevelSignals: function(model, selCmpt, signals) {\n    const name = selCmpt.name,\n        proj = selCmpt.project,\n        bind = selCmpt.bind,\n        datum = '(item().isVoronoi ? datum.datum : datum)';\n\n    proj.forEach(function(p) {\n      signals.unshift({\n        name: name + id(p.field),\n        value: '',\n        on: [{\n          events: selCmpt.events,\n          update: `${datum}[${stringValue(p.field)}]`\n        }],\n        bind: bind[p.field] || bind[p.encoding] || bind\n      });\n    });\n\n    return signals;\n  },\n\n  signals: function(model, selCmpt, signals) {\n    const name = selCmpt.name, proj = selCmpt.project,\n        signal = signals.filter((s) => s.name === name)[0],\n        fields = proj.map((p) => stringValue(p.field)).join(', '),\n        values = proj.map((p) => name + id(p.field)).join(', ');\n\n    signal.update = `{fields: [${fields}], values: [${values}]}`;\n    delete signal.value;\n    delete signal.on;\n\n    return signals;\n  }\n};\n\nexport {inputBindings as default};\n\nfunction id(str: string) {\n  return '_' + str.replace(/\\W/g, '_');\n}\n","import {TransformCompiler} from './transforms';\n\nconst VORONOI = 'voronoi';\n\nconst nearest:TransformCompiler = {\n  has: function(selCmpt) {\n    return selCmpt.nearest !== undefined && selCmpt.nearest !== false;\n  },\n\n  marks: function(model, selCmpt, marks, selMarks) {\n    const mark = marks[0],\n        index = selMarks.indexOf(mark),\n        isPathgroup = mark.name === model.getName('pathgroup'),\n        exists = ((m: any) => m.name && m.name.indexOf(VORONOI) >= 0),\n        cellDef = {\n          name: model.getName(VORONOI),\n          type: 'path',\n          from: {data: model.getName('marks')},\n          encode: {\n            enter: {\n              fill: {value: 'transparent'},\n              strokeWidth: {value: 0.35},\n              stroke: {value: 'transparent'},\n              isVoronoi: {value: true}\n            }\n          },\n          transform: [{\n            type: 'voronoi',\n            x: 'datum.x',\n            y: 'datum.y',\n            size: [model.getSizeSignalRef('width'), model.getSizeSignalRef('height')]\n          }]\n        };\n\n    if (isPathgroup && !mark.marks.filter(exists).length) {\n      mark.marks.push(cellDef);\n      selMarks.splice(index, 1, mark);\n    } else if (!isPathgroup && !selMarks.filter(exists).length) {\n      selMarks.splice(index + 1, 0, cellDef);\n    }\n\n    return selMarks;\n  }\n};\n\nexport {nearest as default};\n","import {Channel} from '../../../channel';\nimport {SelectionDef} from '../../../selection';\nimport {TransformCompiler} from './transforms';\n\nconst project:TransformCompiler = {\n  has: function(selDef: SelectionDef) {\n    return selDef.fields !== undefined || selDef.encodings !== undefined;\n  },\n\n  parse: function(model, selDef, selCmpt) {\n    let fields = {};\n    // TODO: find a possible channel mapping for these fields.\n    (selDef.fields || []).forEach((f) => fields[f] = null);\n    (selDef.encodings || []).forEach((c: Channel) => fields[model.fieldDef(c).field] = c);\n\n    const projection = selCmpt.project || (selCmpt.project = []);\n    for (const field in fields) {\n      if (fields.hasOwnProperty(field)) {\n        projection.push({field: field, encoding: fields[field]});\n      }\n    }\n\n    fields = selCmpt.fields || (selCmpt.fields = {});\n    projection.filter((p) => p.encoding).forEach((p) => fields[p.encoding] = p.field);\n  }\n};\n\nexport {project as default};\n","import {Channel} from '../../../channel';\nimport {warn} from '../../../log';\nimport {hasContinuousDomain} from '../../../scale';\nimport {stringValue} from '../../../util';\nimport {UnitModel} from '../../unit';\nimport {SIZE as INTERVAL_SIZE} from '../interval';\nimport {channelSignalName, MODIFY, TUPLE} from '../selection';\nimport {TransformCompiler} from './transforms';\n\nconst scaleBindings:TransformCompiler = {\n  clipGroup: true,\n\n  has: function(selCmpt) {\n    return selCmpt.type === 'interval' && selCmpt.resolve === 'global' &&\n      selCmpt.bind && selCmpt.bind === 'scales';\n  },\n\n  parse: function(model, selDef, selCmpt) {\n    const bound:Channel[] = selCmpt.scales = [];\n\n    selCmpt.project.forEach(function(p) {\n      const channel = p.encoding;\n      const scale = model.getComponent('scales', channel);\n\n      if (!scale || !hasContinuousDomain(scale.type)) {\n        warn('Scale bindings are currently only supported for scales with continuous domains.');\n        return;\n      }\n\n      scale.domainRaw = {signal: channelSignalName(selCmpt, channel)};\n      bound.push(channel);\n    });\n  },\n\n  topLevelSignals: function(model, selCmpt, signals) {\n    const channels = selCmpt.scales.filter((channel) => {\n      return !(signals.filter((s) => s.name === channelSignalName(selCmpt, channel)).length);\n    });\n\n    return signals.concat(channels.map((channel) => {\n      return {name: channelSignalName(selCmpt, channel)};\n    }));\n  },\n\n  signals: function(model, selCmpt, signals) {\n    const name = selCmpt.name;\n    signals = signals.filter(function(s) {\n      return s.name !== name + INTERVAL_SIZE &&\n        s.name !== name + TUPLE && s.name !== MODIFY;\n    });\n\n    selCmpt.scales.forEach(function(channel) {\n      const signal = signals.filter((s) => s.name === channelSignalName(selCmpt, channel))[0];\n      signal.push = 'outer';\n      delete signal.value;\n      delete signal.update;\n    });\n\n    return signals;\n  }\n};\n\nexport {scaleBindings as default};\n\nexport function domain(model: UnitModel, channel: Channel) {\n  const scale = stringValue(model.scaleName(channel));\n  return `domain(${scale})`;\n}\n","import {TUPLE} from '../selection';\nimport {TransformCompiler} from './transforms';\n\nconst TOGGLE = '_toggle';\n\nconst toggle:TransformCompiler = {\n  has: function(selCmpt) {\n    return selCmpt.toggle !== undefined && selCmpt.toggle !== false;\n  },\n\n  signals: function(model, selCmpt, signals) {\n    return signals.concat({\n      name: selCmpt.name + TOGGLE,\n      value: false,\n      on: [{events: selCmpt.events, update: selCmpt.toggle}]\n    });\n  },\n\n  modifyExpr: function(model, selCmpt, expr) {\n    const tpl = selCmpt.name + TUPLE,\n        signal = selCmpt.name + TOGGLE;\n\n    return `${signal} ? null : ${tpl}, ` +\n      (selCmpt.resolve === 'global' ?\n        `${signal} ? null : true, ` :\n        `${signal} ? null : {unit: ${tpl}.unit}, `) +\n      `${signal} ? ${tpl} : null`;\n  }\n};\n\nexport {toggle as default};\n","import {SelectionDef} from '../../../selection';\nimport {Dict} from '../../../util';\nimport {Model} from '../../model';\nimport {UnitModel} from '../../unit';\nimport {SelectionComponent} from '../selection';\n\nexport interface TransformCompiler {\n  has: (selCmpt: SelectionComponent | SelectionDef) => boolean;\n  parse?: (model: UnitModel, def: SelectionDef, selCmpt: SelectionComponent) => void;\n  signals?: (model: UnitModel, selCmpt: SelectionComponent, signals: any[]) => any[];\n  topLevelSignals?: (model: Model, selCmpt: SelectionComponent, signals: any[]) => any[];\n  // tupleExpr?: (model: UnitModel, selCmpt: SelectionComponent, expr: string) => string;\n  modifyExpr?: (model: UnitModel, selCmpt: SelectionComponent, expr: string) => string;\n  marks?: (model: UnitModel, selCmpt:SelectionComponent, marks: any[], selMarks: any[]) => any[];\n  clipGroup?: boolean;\n}\n\nimport inputs from './inputs';\nimport nearest from './nearest';\nimport project from './project';\nimport scales from './scales';\nimport toggle from './toggle';\nimport translate from './translate';\nimport zoom from './zoom';\nconst compilers: Dict<TransformCompiler> = {project, toggle, scales,\n  translate, zoom, inputs, nearest};\n\nexport function forEachTransform(selCmpt: SelectionComponent, cb: (tx: TransformCompiler) => void) {\n  for (const t in compilers) {\n    if (compilers[t].has(selCmpt)) {\n      cb(compilers[t]);\n    }\n  }\n}\n","import {selector as parseSelector} from 'vega-event-selector';\nimport {Channel, X, Y} from '../../../channel';\nimport {stringValue} from '../../../util';\nimport {BRUSH as INTERVAL_BRUSH, projections as intervalProjections, SIZE as INTERVAL_SIZE} from '../interval';\nimport {channelSignalName, SelectionComponent} from '../selection';\nimport {UnitModel} from './../../unit';\nimport {default as scalesCompiler, domain} from './scales';\nimport {TransformCompiler} from './transforms';\n\nconst ANCHOR = '_translate_anchor',\n      DELTA  = '_translate_delta';\n\nconst translate:TransformCompiler = {\n  has: function(selCmpt) {\n    return selCmpt.type === 'interval' && selCmpt.translate !== undefined && selCmpt.translate !== false;\n  },\n\n  signals: function(model, selCmpt, signals) {\n    const name = selCmpt.name,\n        scales = scalesCompiler.has(selCmpt),\n        size = scales ? 'unit' : name + INTERVAL_SIZE,\n        anchor = name + ANCHOR,\n        {x, y} = intervalProjections(selCmpt);\n    let events = parseSelector(selCmpt.translate, 'scope');\n\n    if (!scales) {\n      events = events.map((e) => (e.between[0].markname = name + INTERVAL_BRUSH, e));\n    }\n\n    signals.push({\n      name: anchor,\n      value: {},\n      on: [{\n        events: events.map((e) => e.between[0]),\n        update: '{x: x(unit), y: y(unit), ' +\n          `width: ${size}.width, height: ${size}.height, ` +\n\n          (x !== null ? 'extent_x: ' + (scales ? domain(model, X) :\n              `slice(${name}_${x.field})`) + ', ' : '') +\n\n          (y !== null ? 'extent_y: ' + (scales ? domain(model, Y) :\n              `slice(${name}_${y.field})`) + ', ' : '') + '}'\n      }]\n    }, {\n      name: name + DELTA,\n      value: {},\n      on: [{\n        events: events,\n        update: `{x: x(unit) - ${anchor}.x, y: y(unit) - ${anchor}.y}`\n      }]\n    });\n\n    if (x !== null) {\n      onDelta(model, selCmpt, X, 'width', signals);\n    }\n\n    if (y !== null) {\n      onDelta(model, selCmpt, Y, 'height', signals);\n    }\n\n    return signals;\n  }\n};\n\nexport {translate as default};\n\nfunction getSign(selCmpt: SelectionComponent, channel: Channel) {\n  let s = channel === X ? '+' : '-';\n  if (scalesCompiler.has(selCmpt)) {\n    s = s === '+' ? '-' : '+';\n  }\n  return s;\n}\n\nfunction onDelta(model: UnitModel, selCmpt: SelectionComponent, channel: Channel, size: 'width' | 'height', signals: any[]) {\n  const name = selCmpt.name,\n      signal:any = signals.filter((s:any) => s.name === channelSignalName(selCmpt, channel))[0],\n      anchor = name + ANCHOR,\n      delta  = name + DELTA,\n      scale  = stringValue(model.scaleName(channel)),\n      extent = `.extent_${channel}`,\n      sign = getSign(selCmpt, channel),\n      offset = `${sign} abs(span(${anchor}${extent})) * ` +\n        `${delta}.${channel} / ${anchor}.${size}`,\n      range = `[${anchor}${extent}[0] ${offset}, ` +\n        `${anchor}${extent}[1] ${offset}]`,\n      lo = `invert(${scale}` + (channel === X ? ', 0' : `, unit.${size}`) + ')',\n      hi = `invert(${scale}` + (channel === X ? `, unit.${size}` : ', 0') + ')';\n\n  signal.on.push({\n    events: {signal: delta},\n    update: scalesCompiler.has(selCmpt) ? range : `clampRange(${range}, ${lo}, ${hi})`\n  });\n}\n","import {selector as parseSelector} from 'vega-event-selector';\nimport {Channel, X, Y} from '../../../channel';\nimport {stringValue} from '../../../util';\nimport {BRUSH as INTERVAL_BRUSH, projections as intervalProjections, SIZE as INTERVAL_SIZE} from '../interval';\nimport {channelSignalName, SelectionComponent} from '../selection';\nimport {UnitModel} from './../../unit';\nimport {default as scalesCompiler, domain} from './scales';\nimport {TransformCompiler} from './transforms';\n\nconst ANCHOR = '_zoom_anchor',\n      DELTA  = '_zoom_delta';\n\nconst zoom:TransformCompiler = {\n  has: function(selCmpt) {\n    return selCmpt.type === 'interval' && selCmpt.zoom !== undefined && selCmpt.zoom !== false;\n  },\n\n  signals: function(model, selCmpt, signals) {\n    const name = selCmpt.name,\n        delta = name + DELTA,\n        {x, y} = intervalProjections(selCmpt),\n        sx = stringValue(model.scaleName(X)),\n        sy = stringValue(model.scaleName(Y));\n\n    let events = parseSelector(selCmpt.zoom, 'scope');\n\n    if (!scalesCompiler.has(selCmpt)) {\n      events = events.map((e) => (e.markname = name + INTERVAL_BRUSH, e));\n    }\n\n    signals.push({\n      name: name + ANCHOR,\n      on: [{\n        events: events,\n        update: `{x: invert(${sx}, x(unit)), y: invert(${sy}, y(unit))}`\n      }]\n    }, {\n      name: delta,\n      on: [{\n        events: events,\n        force: true,\n        update: 'pow(1.001, event.deltaY * pow(16, event.deltaMode))'\n      }]\n    });\n\n    if (x !== null) {\n      onDelta(model, selCmpt, 'x', 'width', signals);\n    }\n\n    if (y !== null) {\n      onDelta(model, selCmpt, 'y', 'height', signals);\n    }\n\n    const size = signals.filter((s:any) => s.name === name + INTERVAL_SIZE);\n    if (size.length) {\n      const sname = size[0].name;\n      size[0].on.push({\n        events: {signal: delta},\n        update: `{x: ${sname}.x, y: ${sname}.y, ` +\n          `width: ${sname}.width * ${delta} , ` +\n          `height: ${sname}.height * ${delta}}`\n      });\n    }\n\n    return signals;\n  }\n};\n\nexport {zoom as default};\n\nfunction onDelta(model: UnitModel, selCmpt: SelectionComponent, channel: Channel, size: 'width' | 'height', signals: any[]) {\n  const name = selCmpt.name,\n      signal:any = signals.filter((s:any) => s.name === channelSignalName(selCmpt, channel))[0],\n      scales = scalesCompiler.has(selCmpt),\n      base = scales ? domain(model, channel) : signal.name,\n      anchor = `${name}${ANCHOR}.${channel}`,\n      delta  = name + DELTA,\n      scale  = stringValue(model.scaleName(channel)),\n      range  = `[${anchor} + (${base}[0] - ${anchor}) * ${delta}, ` +\n        `${anchor} + (${base}[1] - ${anchor}) * ${delta}]`,\n      lo = `invert(${scale}` + (channel === X ? ', 0' : `, unit.${size}`) + ')',\n      hi = `invert(${scale}` + (channel === X ? `, unit.${size}` : ', 0') + ')';\n\n  signal.on.push({\n    events: {signal: delta},\n    update: scales ? range : `clampRange(${range}, ${lo}, ${hi})`\n  });\n}\n","import {Axis} from '../axis';\nimport {Channel, NONSPATIAL_SCALE_CHANNELS, UNIT_CHANNELS, UNIT_SCALE_CHANNELS, X, X2, Y, Y2} from '../channel';\nimport {CellConfig, Config} from '../config';\nimport {Encoding, normalizeEncoding} from '../encoding';\nimport * as vlEncoding from '../encoding'; // TODO: remove\nimport {field, FieldDef, FieldRefOption, isFieldDef} from '../fielddef';\nimport {Legend} from '../legend';\nimport {FILL_STROKE_CONFIG, isMarkDef, Mark, MarkDef, TEXT as TEXT_MARK} from '../mark';\nimport {hasDiscreteDomain, Scale} from '../scale';\nimport {SelectionDef} from '../selection';\nimport {SortField, SortOrder} from '../sort';\nimport {UnitSpec} from '../spec';\nimport {stack, StackProperties} from '../stack';\nimport {Dict, duplicate, extend, vals} from '../util';\nimport {VgData, VgLayout, VgSignal} from '../vega.schema';\nimport {parseAxisComponent} from './axis/parse';\nimport {applyConfig} from './common';\nimport {assembleData} from './data/assemble';\nimport {parseData} from './data/parse';\nimport {FacetModel} from './facet';\nimport {LayerModel} from './layer';\nimport {assembleLayoutUnitSignals} from './layout/index';\nimport {parseLegendComponent} from './legend/parse';\nimport {initEncoding, initMarkDef} from './mark/init';\nimport {parseMark} from './mark/mark';\nimport {Model, ModelWithField} from './model';\nimport {RepeaterValue, replaceRepeaterInEncoding} from './repeat';\nimport initScale from './scale/init';\nimport parseScaleComponent from './scale/parse';\nimport {assembleTopLevelSignals, assembleUnitSelectionData, assembleUnitSelectionMarks, assembleUnitSelectionSignals, parseUnitSelection} from './selection/selection';\n\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\nexport class UnitModel extends ModelWithField {\n  /**\n   * Fixed width for the unit visualization.\n   * If undefined (e.g., for ordinal scale), the width of the\n   * visualization will be calculated dynamically.\n   */\n  public readonly width: number;\n\n  /**\n   * Fixed height for the unit visualization.\n   * If undefined (e.g., for ordinal scale), the height of the\n   * visualization will be calculated dynamically.\n   */\n  public readonly height: number;\n\n  public readonly markDef: MarkDef;\n  public readonly encoding: Encoding<string>;\n\n  protected scales: Dict<Scale> = {};\n\n  public readonly stack: StackProperties;\n\n  protected axes: Dict<Axis> = {};\n\n  protected legends: Dict<Legend> = {};\n\n  protected readonly selection: Dict<SelectionDef> = {};\n  public children: Model[] = [];\n\n  constructor(spec: UnitSpec, parent: Model, parentGivenName: string, repeater: RepeaterValue, config: Config) {\n    super(spec, parent, parentGivenName, config);\n\n    // FIXME(#2041): copy config.facet.cell to config.cell -- this seems incorrect and should be rewritten\n    this.initFacetCellConfig();\n\n    // use top-level width / height or parent's top-level width / height\n\n    // FIXME: once facet supports width/height, this is no longer correct!\n    const providedWidth = spec.width !== undefined ? spec.width :\n      parent ? parent['width'] : undefined; // only exists if parent is layer\n    const providedHeight = spec.height !== undefined ? spec.height :\n      parent ? parent['height'] : undefined; // only exists if parent is layer\n\n    const mark = isMarkDef(spec.mark) ? spec.mark.type : spec.mark;\n    const encoding = this.encoding = normalizeEncoding(replaceRepeaterInEncoding(spec.encoding || {}, repeater), mark);\n\n    // calculate stack properties\n    this.stack = stack(mark, encoding, this.config.stack);\n    this.scales = this.initScales(mark, encoding, providedWidth, providedHeight);\n\n    this.markDef = initMarkDef(spec.mark, encoding, this.scales, this.config);\n    this.encoding = initEncoding(mark, encoding, this.stack, this.config);\n\n    this.axes = this.initAxes(encoding);\n    this.legends = this.initLegend(encoding);\n\n    // Selections will be initialized upon parse.\n    this.selection = spec.selection;\n\n    // width / height\n    const {width = this.width, height = this.height} = this.initSize(mark, this.scales,\n      providedWidth,\n      providedHeight\n    );\n    this.width = width;\n    this.height = height;\n  }\n\n  public scale(channel: Channel) {\n    return this.scales[channel];\n  }\n\n  public hasDiscreteDomain(channel: Channel) {\n    const scale = this.scale(channel);\n    return scale && hasDiscreteDomain(scale.type);\n  }\n\n\n  public sort(channel: Channel): SortField | SortOrder {\n    return (this.getMapping()[channel] || {}).sort;\n  }\n\n  public axis(channel: Channel): Axis {\n    return this.axes[channel];\n  }\n\n  public legend(channel: Channel): Legend {\n    return this.legends[channel];\n  }\n  private initFacetCellConfig() {\n    const config = this.config;\n    let ancestor = this.parent;\n    let hasFacetAncestor = false;\n    while (ancestor !== null) {\n      if (ancestor instanceof FacetModel) {\n        hasFacetAncestor = true;\n        break;\n      }\n      ancestor = ancestor.parent;\n    }\n\n    if (hasFacetAncestor) {\n      config.cell = extend({}, config.cell, config.facet.cell);\n    }\n  }\n\n  private initScales(mark: Mark, encoding: Encoding<string>, topLevelWidth:number, topLevelHeight: number): Dict<Scale> {\n    const xyRangeSteps: number[] = [];\n\n    return UNIT_SCALE_CHANNELS.reduce((scales, channel) => {\n      if (vlEncoding.channelHasField(encoding, channel) ||\n          (channel === X && vlEncoding.channelHasField(encoding, X2)) ||\n          (channel === Y && vlEncoding.channelHasField(encoding, Y2))\n        ) {\n        const scale = scales[channel] = initScale(\n          channel, encoding[channel], this.config, mark,\n          channel === X ? topLevelWidth : channel === Y ? topLevelHeight : undefined,\n          xyRangeSteps // for determine point / bar size\n        );\n\n        if (channel === X || channel === Y) {\n          if (scale.rangeStep) {\n            xyRangeSteps.push(scale.rangeStep);\n          }\n        }\n      }\n      return scales;\n    }, {});\n  }\n\n  // TODO: consolidate this with scale?  Current scale range is in parseScale (later),\n  // but not in initScale because scale range depends on size,\n  // but size depends on scale type and rangeStep\n  private initSize(mark: Mark, scale: Dict<Scale>, width: number, height: number) {\n    const cellConfig = this.config.cell;\n    const scaleConfig = this.config.scale;\n\n    if (width === undefined) {\n      if (scale[X]) {\n        if (!hasDiscreteDomain(scale[X].type) || !scale[X].rangeStep) {\n          width = cellConfig.width;\n        } // else: Do nothing, use dynamic width.\n      } else { // No scale X\n        if (mark === TEXT_MARK) {\n          // for text table without x/y scale we need wider rangeStep\n          width = scaleConfig.textXRangeStep;\n        } else {\n          if (typeof scaleConfig.rangeStep === 'string') {\n            throw new Error('_initSize does not handle string rangeSteps');\n          }\n          width = scaleConfig.rangeStep;\n        }\n      }\n    }\n\n    if (height === undefined) {\n      if (scale[Y]) {\n        if (!hasDiscreteDomain(scale[Y].type) || !scale[Y].rangeStep) {\n          height = cellConfig.height;\n        } // else: Do nothing, use dynamic height .\n      } else {\n        if (typeof scaleConfig.rangeStep === 'string') {\n          throw new Error('_initSize does not handle string rangeSteps');\n        }\n        height = scaleConfig.rangeStep;\n      }\n    }\n\n    return {width, height};\n  }\n\n  private initAxes(encoding: Encoding<string>): Dict<Axis> {\n    return [X, Y].reduce(function(_axis, channel) {\n      // Position Axis\n\n      const channelDef = encoding[channel];\n      if (isFieldDef(channelDef) ||\n          (channel === X && isFieldDef(encoding.x2)) ||\n          (channel === Y && isFieldDef(encoding.y2))) {\n\n        const axisSpec = isFieldDef(channelDef) ? channelDef.axis : null;\n\n        // We no longer support false in the schema, but we keep false here for backward compatability.\n        if (axisSpec !== null && axisSpec !== false) {\n          _axis[channel] = {\n            ...axisSpec\n          };\n        }\n      }\n      return _axis;\n    }, {});\n  }\n\n  private initLegend(encoding: Encoding<string>): Dict<Legend> {\n    return NONSPATIAL_SCALE_CHANNELS.reduce(function(_legend, channel) {\n      const channelDef = encoding[channel];\n      if (isFieldDef(channelDef)) {\n        const legendSpec = channelDef.legend;\n        if (legendSpec !== null && legendSpec !== false) {\n          _legend[channel] = {...legendSpec};\n        }\n      }\n      return _legend;\n    }, {});\n  }\n\n  public parseData() {\n    this.component.data = parseData(this);\n  }\n\n  public parseSelection() {\n    this.component.selection = parseUnitSelection(this, this.selection);\n  }\n\n  public parseScale() {\n    this.component.scales = parseScaleComponent(this);\n  }\n\n  public parseMark() {\n    this.component.mark = parseMark(this);\n  }\n\n  public parseAxisAndHeader() {\n    this.component.axes = parseAxisComponent(this, [X, Y]);\n  }\n\n  public parseLegend() {\n    this.component.legends = parseLegendComponent(this);\n  }\n\n  public assembleData(): VgData[] {\n     if (!this.parent) {\n      // only assemble data in the root\n      return assembleData(vals(this.component.data.sources));\n    }\n    return [];\n  }\n\n  public assembleSelectionTopLevelSignals(signals: any[]): VgSignal[] {\n    return assembleTopLevelSignals(this, signals);\n  }\n\n  public assembleSelectionSignals(): VgSignal[] {\n    return assembleUnitSelectionSignals(this, []);\n  }\n\n  public assembleSelectionData(data: VgData[]): VgData[] {\n    return assembleUnitSelectionData(this, data);\n  }\n\n  public assembleLayout(): VgLayout {\n    return null;\n  }\n\n  public assembleLayoutSignals(): VgSignal[] {\n    return assembleLayoutUnitSignals(this);\n  }\n\n  public assembleMarks() {\n    let marks = this.component.mark || [];\n\n    // If this unit is part of a layer, selections should augment\n    // all in concert rather than each unit individually. This\n    // ensures correct interleaving of clipping and brushed marks.\n    if (!this.parent || !(this.parent instanceof LayerModel)) {\n      marks = assembleUnitSelectionMarks(this, marks);\n    }\n\n    return marks.map(this.correctDataNames);\n  }\n\n  public assembleParentGroupProperties() {\n    return applyConfig({}, this.config.cell, FILL_STROKE_CONFIG.concat(['clip']));\n  }\n\n  public channels() {\n    return UNIT_CHANNELS;\n  }\n\n  protected getMapping() {\n    return this.encoding;\n  }\n\n  public toSpec(excludeConfig?: any, excludeData?: any) {\n    const encoding = duplicate(this.encoding);\n    let spec: any;\n\n    spec = {\n      mark: this.markDef,\n      encoding: encoding\n    };\n\n    if (!excludeConfig) {\n      spec.config = duplicate(this.config);\n    }\n\n    if (!excludeData) {\n      spec.data = duplicate(this.data);\n    }\n\n    // remove defaults\n    return spec;\n  }\n\n  public mark(): Mark {\n    return this.markDef.type;\n  }\n\n  public channelHasField(channel: Channel) {\n    return vlEncoding.channelHasField(this.encoding, channel);\n  }\n\n  public fieldDef(channel: Channel): FieldDef<string> {\n    // TODO: remove this || {}\n    // Currently we have it to prevent null pointer exception.\n    return this.encoding[channel] || {};\n  }\n\n  /** Get \"field\" reference for vega */\n  public field(channel: Channel, opt: FieldRefOption = {}) {\n    const fieldDef = this.fieldDef(channel);\n\n    if (fieldDef.bin) { // bin has default suffix that depends on scaleType\n      opt = extend({\n        binSuffix: hasDiscreteDomain(this.scale(channel).type) ? 'range' : 'start'\n      }, opt);\n    }\n\n    return field(fieldDef, opt);\n  }\n\n  public isUnit() {\n    return true;\n  }\n}\n","import {Config} from '../config';\nimport {Field} from '../fielddef';\nimport {Encoding} from './../encoding';\nimport {isContinuous, isDiscrete, PositionFieldDef} from './../fielddef';\nimport {MarkConfig} from './../mark';\nimport {GenericUnitSpec, LayerSpec} from './../spec';\n\nexport const BOXPLOT: 'box-plot' = 'box-plot';\nexport type BOXPLOT = typeof BOXPLOT;\n\n\nexport interface BoxPlotConfig extends MarkConfig {\n  /** Size of the box and mid tick of a box plot */\n  size?: number;\n}\n\nexport function normalizeBoxPlot(spec: GenericUnitSpec<BOXPLOT, Encoding<Field>>, config: Config): LayerSpec {\n  const {mark: _m, encoding: encoding, ...outerSpec} = spec;\n  const {x: _x, y: _y, ...nonPositionEncoding} = encoding;\n  const {size: size, ...nonPositionEncodingWithoutSize} = nonPositionEncoding;\n  const {color: _color, ...nonPositionEncodingWithoutColorSize} = nonPositionEncodingWithoutSize;\n  const midTickAndBarSizeChannelDef = size ? {size: size} : {size: {value: config.box.size}};\n\n  let discreteAxisFieldDef, continuousAxisChannelDef: PositionFieldDef<Field>;\n  let discreteAxis, continuousAxis;\n\n  if (encoding.x && encoding.y) {\n    // 2D\n    if (isDiscrete(encoding.x) && isContinuous(encoding.y)) {\n      // vertical\n      discreteAxis = 'x';\n      continuousAxis = 'y';\n      continuousAxisChannelDef = encoding.y;\n\n      discreteAxisFieldDef = encoding.x;\n    } else if (isDiscrete(encoding.y) && isContinuous(encoding.x)) {\n      // horizontal\n      discreteAxis = 'y';\n      continuousAxis = 'x';\n      continuousAxisChannelDef = encoding.x;\n\n      discreteAxisFieldDef = encoding.y;\n    } else {\n      throw new Error('Need one continuous and one discrete axis for 2D boxplots');\n    }\n  } else if (encoding.x && isContinuous(encoding.x) && encoding.y === undefined) {\n    // 1D horizontal\n    continuousAxis = 'x';\n    continuousAxisChannelDef = encoding.x;\n  } else if (encoding.x === undefined && encoding.y && isContinuous(encoding.y)) {\n    // 1D vertical\n    continuousAxis = 'y';\n    continuousAxisChannelDef = encoding.y;\n  } else {\n    throw new Error('Need a continuous axis for 1D boxplots');\n  }\n\n  if (continuousAxisChannelDef.aggregate !== undefined && continuousAxisChannelDef.aggregate !== BOXPLOT) {\n    throw new Error('Continuous axis should not be aggregated');\n  }\n\n  const baseContinuousFieldDef = {\n      field: continuousAxisChannelDef.field,\n      type: continuousAxisChannelDef.type\n  };\n\n  const minFieldDef = {\n    aggregate: 'min',\n    ...baseContinuousFieldDef\n  };\n  const minWithAxisFieldDef = {\n    axis: continuousAxisChannelDef.axis,\n    ...minFieldDef\n  };\n  const q1FieldDef = {\n    aggregate: 'q1',\n    ...baseContinuousFieldDef\n  };\n  const medianFieldDef = {\n    aggregate: 'median',\n    ...baseContinuousFieldDef\n  };\n  const q3FieldDef = {\n    aggregate: 'q3',\n    ...baseContinuousFieldDef\n  };\n  const maxFieldDef = {\n    aggregate: 'max',\n    ...baseContinuousFieldDef\n  };\n\n  const discreteAxisEncodingMixin = discreteAxisFieldDef !== undefined ? {[discreteAxis]: discreteAxisFieldDef} : {};\n\n  return {\n    ...outerSpec,\n    layer: [\n      { // lower whisker\n        mark: {\n          type: 'rule',\n          role: 'boxWhisker'\n        },\n        encoding: {\n          ...discreteAxisEncodingMixin,\n          [continuousAxis]: minWithAxisFieldDef,\n          [continuousAxis + '2']: q1FieldDef,\n          ...nonPositionEncodingWithoutColorSize\n        }\n      }, { // upper whisker\n        mark: {\n          type: 'rule',\n          role: 'boxWhisker'\n        },\n        encoding: {\n          ...discreteAxisEncodingMixin,\n          [continuousAxis]: q3FieldDef,\n          [continuousAxis + '2']: maxFieldDef,\n          ...nonPositionEncodingWithoutColorSize\n        }\n      }, { // box (q1 to q3)\n        mark: {\n          type: 'bar',\n          role: 'box'\n        },\n        encoding: {\n          ...discreteAxisEncodingMixin,\n          [continuousAxis]: q1FieldDef,\n          [continuousAxis + '2']: q3FieldDef,\n          ...nonPositionEncodingWithoutSize,\n          ...midTickAndBarSizeChannelDef\n        }\n      }, { // mid tick\n        mark: {\n          type: 'tick',\n          role: 'boxMid'\n        },\n        encoding: {\n          ...discreteAxisEncodingMixin,\n          [continuousAxis]: medianFieldDef,\n          ...nonPositionEncoding,\n          ...midTickAndBarSizeChannelDef,\n          'color': {'value' : 'white'}\n        }\n      }\n    ]\n  };\n}\n\n","import {Field} from '../fielddef';\nimport {Encoding} from './../encoding';\nimport {GenericUnitSpec, LayerSpec} from './../spec';\n\nexport const ERRORBAR: 'error-bar' = 'error-bar';\nexport type ERRORBAR = typeof ERRORBAR;\n\nexport function normalizeErrorBar(spec: GenericUnitSpec<ERRORBAR, Encoding<Field>>): LayerSpec {\n  const {mark: _m, encoding: encoding, ...outerSpec} = spec;\n  const {size: _s, ...encodingWithoutSize} = encoding;\n  const {x2: _x2, y2: _y2, ...encodingWithoutX2Y2} = encoding;\n  const {x: _x, y: _y, ...encodingWithoutX_X2_Y_Y2} = encodingWithoutX2Y2;\n\n  if (!encoding.x2 && !encoding.y2) {\n    throw new Error('Neither x2 or y2 provided');\n  }\n\n  return {\n    ...outerSpec,\n    layer: [\n      {\n        mark: 'rule',\n        encoding: encodingWithoutSize\n      },{ // Lower tick\n        mark: 'tick',\n        encoding: encodingWithoutX2Y2\n      }, { // Upper tick\n        mark: 'tick',\n        encoding: encoding.x2 ? {\n          x: encoding.x2,\n          y: encoding.y,\n          ...encodingWithoutX_X2_Y_Y2\n        } : {\n          x: encoding.x,\n          y: encoding.y2,\n          ...encodingWithoutX_X2_Y_Y2\n        }\n      }\n    ]\n  };\n}\n","import {Config} from './../config';\nimport {isMarkDef, MarkDef} from './../mark';\nimport {GenericUnitSpec, LayerSpec} from './../spec';\nimport {BOXPLOT, normalizeBoxPlot} from './boxplot';\nimport {ERRORBAR, normalizeErrorBar} from './errorbar';\n\nexport {BoxPlotConfig} from './boxplot';\nexport type UnitNormalizer = (spec: GenericUnitSpec<any, any>, config: Config)=> LayerSpec;\n\n/**\n * Registry index for all composite mark's normalizer\n */\nconst normalizerRegistry: {[mark: string]: UnitNormalizer} = {};\n\nexport function add(mark: string, normalizer: UnitNormalizer) {\n  normalizerRegistry[mark] = normalizer;\n}\n\nexport function remove(mark: string) {\n  delete normalizerRegistry[mark];\n}\n\nexport type CompositeMark = BOXPLOT | ERRORBAR;\nexport type CompositeAggregate = BOXPLOT;\n\nadd(BOXPLOT, normalizeBoxPlot);\nadd(ERRORBAR, normalizeErrorBar);\n\n/**\n * Transform a unit spec with composite mark into a normal layer spec.\n */\nexport function normalize(\n    // This GenericUnitSpec has any as Encoding because unit specs with composite mark can have additional encoding channels.\n    spec: GenericUnitSpec<string | MarkDef, any>,\n    config: Config\n  ): LayerSpec {\n\n  const mark = isMarkDef(spec.mark) ? spec.mark.type : spec.mark;\n  const normalizer = normalizerRegistry[mark];\n  if (normalizer) {\n    return normalizer(spec, config);\n  }\n\n  throw new Error(`Unregistered composite mark ${mark}`);\n}\n","import {AxisConfig} from './axis';\nimport {BoxPlotConfig} from './compositemark';\nimport {defaultLegendConfig, LegendConfig} from './legend';\nimport {BarConfig, MarkConfig, TextConfig, TickConfig} from './mark';\nimport * as mark from './mark';\nimport {defaultScaleConfig, ScaleConfig} from './scale';\nimport {defaultConfig as defaultSelectionConfig, SelectionConfig} from './selection';\nimport {StackOffset} from './stack';\nimport {TopLevelProperties} from './toplevelprops';\nimport {duplicate, mergeDeep} from './util';\nimport {VgRangeScheme} from './vega.schema';\n\nexport interface CellConfig {\n  /**\n   * The default width of the single plot or each plot in a trellis plot when the visualization has a continuous (non-ordinal) x-scale or ordinal x-scale with `rangeStep` = `null`.\n   *\n   * __Default value:__ `200`\n   *\n   */\n  width?: number;\n\n  /**\n   * The default height of the single plot or each plot in a trellis plot when the visualization has a continuous (non-ordinal) y-scale with `rangeStep` = `null`.\n   *\n   * __Default value:__ `200`\n   *\n   */\n  height?: number;\n\n  /**\n   * Whether the view should be clipped.\n   */\n  clip?: boolean;\n\n  // FILL_STROKE_CONFIG\n  /**\n   * The fill color.\n   *\n   * __Default value:__ (none)\n   *\n   */\n  fill?: string;\n\n  /**\n   * The fill opacity (value between [0,1]).\n   *\n   * __Default value:__ (none)\n   *\n   */\n  fillOpacity?: number;\n\n  /**\n   * The stroke color.\n   *\n   * __Default value:__ (none)\n   *\n   */\n  stroke?: string;\n\n  /**\n   * The stroke opacity (value between [0,1]).\n   *\n   * __Default value:__ (none)\n   *\n   */\n  strokeOpacity?: number;\n\n  /**\n   * The stroke width, in pixels.\n   *\n   * __Default value:__ (none)\n   *\n   */\n  strokeWidth?: number;\n\n  /**\n   * An array of alternating stroke, space lengths for creating dashed or dotted lines.\n   *\n   * __Default value:__ (none)\n   *\n   */\n  strokeDash?: number[];\n\n  /**\n   * The offset (in pixels) into which to begin drawing with the stroke dash array.\n   *\n   * __Default value:__ (none)\n   *\n   */\n  strokeDashOffset?: number;\n}\n\nexport const defaultCellConfig: CellConfig = {\n  width: 200,\n  height: 200,\n  fill: 'transparent'\n};\n\nexport const defaultFacetCellConfig: CellConfig = {\n  stroke: '#ccc',\n  strokeWidth: 1\n};\n\nexport interface FacetConfig {\n  /** Facet Cell Config */\n  cell?: CellConfig;\n}\n\n\nexport const defaultFacetConfig: FacetConfig = {\n  cell: defaultFacetCellConfig\n};\n\nexport type AreaOverlay = 'line' | 'linepoint' | 'none';\n\nexport interface OverlayConfig {\n  /**\n   * Whether to overlay line with point.\n   *\n   * __Default value:__ `false`\n   */\n  line?: boolean;\n\n  /**\n   * Type of overlay for area mark (line or linepoint)\n   */\n  area?: AreaOverlay;\n}\n\nexport const defaultOverlayConfig: OverlayConfig = {\n  line: false\n};\n\nexport type RangeConfig = (number|string)[] | VgRangeScheme | {step: number};\n\nexport interface Config  extends TopLevelProperties {\n  // TODO: add this back once we have top-down layout approach\n  // width?: number;\n  // height?: number;\n\n  /**\n   * D3 Number format for axis labels and text tables. For example \"s\" for SI units.(in the form of [D3 number format pattern](https://github.com/mbostock/d3/wiki/Formatting)).\n   *\n   * __Default value:__ `\"s\"` (except for text marks that encode a count field, the default value is `\"d\"`).\n   *\n   */\n  numberFormat?: string;\n\n  /**\n   * Default datetime format for axis and legend labels. The format can be set directly on each axis and legend. [D3 time format pattern](https://github.com/mbostock/d3/wiki/Time-Formatting)).\n   *\n   * __Default value:__ `'%b %d, %Y'`.\n   *\n   */\n  timeFormat?: string;\n\n  /**\n   * Default axis and legend title for count fields.\n   *\n   * __Default value:__ `'Number of Records'`.\n   *\n   * @type {string}\n   */\n  countTitle?: string;\n\n  /** Cell Config */\n  cell?: CellConfig;\n\n  /** Default stack offset for stackable mark. */\n  stack?: StackOffset;\n\n  /** Mark Config */\n  mark?: MarkConfig;\n\n  // MARK-SPECIFIC CONFIGS\n  /** Area-Specific Config */\n  area?: MarkConfig;\n\n  /** Bar-Specific Config */\n  bar?: BarConfig;\n\n  /** Circle-Specific Config */\n  circle?: MarkConfig;\n\n  /** Line-Specific Config */\n  line?: MarkConfig;\n\n  /** Point-Specific Config */\n  point?: MarkConfig;\n\n  /** Rect-Specific Config */\n  rect?: MarkConfig;\n\n  /** Rule-Specific Config */\n  rule?: MarkConfig;\n\n  /** Square-Specific Config */\n  square?: MarkConfig;\n\n  /** Text-Specific Config */\n  text?: TextConfig;\n\n  /** Tick-Specific Config */\n  tick?: TickConfig;\n\n  /** Box Config */\n  box?: BoxPlotConfig;\n\n  boxWhisker?: MarkConfig;\n\n  boxMid?: MarkConfig;\n\n  // OTHER CONFIG\n\n  // FIXME: move this to line/area\n  /** Mark Overlay Config */\n  overlay?: OverlayConfig;\n\n  /** Scale Config */\n  scale?: ScaleConfig;\n\n  /**\n   * Scale range config, or properties defining named range arrays\n   * that can be used within scale range definitions\n   * (such as `{\"type\": \"ordinal\", \"range\": \"category\"}`).\n   * For default range that Vega-Lite adopts from Vega, see https://github.com/vega/vega-parser#scale-range-properties.\n   */\n  range?: {[name: string]: RangeConfig};\n\n  /** Generic axis config. */\n  axis?: AxisConfig;\n\n  /**\n   * X-axis specific config.\n   */\n  axisX?: AxisConfig;\n\n  /**\n   * Y-axis specific config.\n   */\n  axisY?: AxisConfig;\n\n  /**\n   * Specific axis config for y-axis along the left edge of the chart.\n   */\n  axisLeft?: AxisConfig;\n\n  /**\n   * Specific axis config for y-axis along the right edge of the chart.\n   */\n  axisRight?: AxisConfig;\n\n  /**\n   * Specific axis config for x-axis along the top edge of the chart.\n   */\n  axisTop?: AxisConfig;\n\n  /**\n   * Specific axis config for x-axis along the bottom edge of the chart.\n   */\n  axixBottom?: AxisConfig;\n\n  /**\n   * Specific axis config for axes with \"band\" scales.\n   */\n  axisBand?: AxisConfig;\n\n  /** Legend Config */\n  legend?: LegendConfig;\n\n  /** Facet Config */\n  facet?: FacetConfig;\n\n  /** Selection Config */\n  selection?: SelectionConfig;\n\n  /**\n   * Whether to filter invalid values (`null` and `NaN`) from the data.\n   * - By default (`undefined`), only quantitative and temporal fields are filtered.\n   * - If set to `true`, all data items with null values are filtered.\n   * - If `false`, all data items are included. In this case, null values will be interpreted as zeroes.\n   */\n  filterInvalid?: boolean;\n\n  // Support arbitrary key for role config\n  // Note: Technically, the type for role config should be `MarkConfig`.\n  // However, Typescript requires that the index type must be compatible with all other properties.\n  // Basically, it will complain that `legend: LegendConfig` is not an instance of `MarkConfig`\n  // Thus, we have to use `any` here.\n  [role: string]: any;\n}\n\nexport const defaultConfig: Config = {\n  padding: 5,\n  numberFormat: 's',\n  timeFormat: '%b %d, %Y',\n  countTitle: 'Number of Records',\n\n  cell: defaultCellConfig,\n\n  mark: mark.defaultMarkConfig,\n  area: {},\n  bar: mark.defaultBarConfig,\n  circle: {},\n  line: {},\n  point: {},\n  rect: {},\n  rule: {},\n  square: {},\n  text: mark.defaultTextConfig,\n  tick: mark.defaultTickConfig,\n\n  box: {size: 14},\n  boxWhisker: {},\n  boxMid: {},\n\n  overlay: defaultOverlayConfig,\n  scale: defaultScaleConfig,\n  axis: {},\n  axisX: {},\n  axisY: {},\n  axisLeft: {},\n  axisRight: {},\n  axisTop: {},\n  axisBottom: {},\n  axisBand: {},\n  legend: defaultLegendConfig,\n\n  facet: defaultFacetConfig,\n\n  selection: defaultSelectionConfig,\n};\n\nexport function initConfig(config: Config) {\n  return mergeDeep(duplicate(defaultConfig), config);\n}\n","/*\n * Constants and utilities for data.\n */\n\nexport interface DataFormat {\n  /**\n   * A collection of parsing instructions can be used to define the data types of string-valued attributes in the JSON file. Each instruction is a name-value pair, where the name is the name of the attribute, and the value is the desired data type (one of `\"number\"`, `\"boolean\"` or `\"date\"`). For example, `\"parse\": {\"modified_on\":\"date\"}` ensures that the `modified_on` value in each row of the input data is parsed as a Date value. (See Datalib's [`dl.read.types` method](https://github.com/vega/datalib/wiki/Import#dl_read_types) for more information.)\n   */\n  parse?: any;\n\n  /**\n   * (JSON only) The JSON property containing the desired data.\n   * This parameter can be used when the loaded JSON file may have surrounding structure or meta-data.\n   * For example `\"property\": \"values.features\"` is equivalent to retrieving `json.values.features`\n   * from the loaded JSON object.\n   */\n  property?: string;\n\n  /**\n   * The name of the TopoJSON object set to convert to a GeoJSON feature collection.\n   * For example, in a map of the world, there may be an object set named `\"countries\"`.\n   * Using the feature property, we can extract this set and generate a GeoJSON feature object for each country.\n   */\n  feature?: string;\n  /**\n   * The name of the TopoJSON object set to convert to mesh.\n   * Similar to the `feature` option, `mesh` extracts a named TopoJSON object set.\n   *  Unlike the `feature` option, the corresponding geo data is returned as a single, unified mesh instance, not as individual GeoJSON features.\n   * Extracting a mesh is useful for more efficiently drawing borders or other geographic elements that you do not need to associate with specific regions such as individual countries, states or counties.\n   */\n  mesh?: string;\n}\n\nexport interface DataUrlFormat extends DataFormat {\n  /**\n   * Type of input data: `\"json\"`, `\"csv\"`, `\"tsv\"`.\n   * The default format type is determined by the extension of the file URL.\n   * If no extension is detected, `\"json\"` will be used by default.\n   */\n  type?: DataFormatType;\n}\n\nexport type DataFormatType = 'json' | 'csv' | 'tsv' | 'topojson';\n\nexport type Data = UrlData | InlineData | NamedData;\n\nexport interface UrlData {\n  /**\n   * Type of input data: `\"json\"`, `\"csv\"`, `\"tsv\"`. The default format type is determined by the extension of the file URL. If no extension is detected, `\"json\"` will be used by default.\n   */\n  format?: DataUrlFormat;\n\n  /**\n   * An URL from which to load the data set. Use the `format.type` property\n   * to ensure the loaded data is correctly parsed.\n   */\n  url: string;\n}\n\nexport interface InlineData {\n  /**\n   * Parsing properties.\n   */\n  format?: DataFormat;\n  /**\n   * Pass array of objects instead of a url to a file.\n   */\n  values: any[];\n}\n\nexport interface NamedData {\n  /**\n   * Parsing properties.\n   */\n  format?: DataFormat;\n  /**\n   * Provide a placeholder name and bind data at runtime.\n   */\n  name: string;\n}\n\nexport function isUrlData(data: Partial<Data>): data is UrlData {\n  return !!data['url'];\n}\n\nexport function isInlineData(data: Partial<Data>): data is InlineData {\n  return !!data['values'];\n}\n\nexport function isNamedData(data: Partial<Data>): data is NamedData {\n  return !!data['name'];\n}\n\nexport type DataSourceType = 'raw' | 'main' | 'row' | 'column';\n\nexport const MAIN: 'main' = 'main';\nexport const RAW: 'raw' = 'raw';\n","// DateTime definition object\n\nimport * as log from './log';\nimport {duplicate, isNumber, keys} from './util';\n\n/*\n * A designated year that starts on Sunday.\n */\nconst SUNDAY_YEAR = 2006;\n\n/**\n * @minimum 1\n * @maximum 12\n * @TJS-type integer\n */\nexport type Month = number;\n\n/**\n * @minimum 1\n * @maximum 7\n */\nexport type Day = number;\n\n/**\n * Object for defining datetime in Vega-Lite Filter.\n * If both month and quarter are provided, month has higher precedence.\n * `day` cannot be combined with other date.\n * We accept string for month and day names.\n */\nexport interface DateTime {\n  /**\n   * Integer value representing the year.\n   * @TJS-type integer\n   */\n  year?: number;\n\n  /**\n   * Integer value representing the quarter of the year (from 1-4).\n   * @minimum 1\n   * @maximum 4\n   * @TJS-type integer\n   */\n  quarter?: number;\n\n  /** One of: (1) integer value representing the month from `1`-`12`. `1` represents January;  (2) case-insensitive month name (e.g., `\"January\"`);  (3) case-insensitive, 3-character short month name (e.g., `\"Jan\"`). */\n  month?: Month | string;\n\n  /**\n   * Integer value representing the date from 1-31.\n   * @minimum 1\n   * @maximum 31\n   * @TJS-type integer\n   */\n  date?: number;\n\n  /**\n   * Value representing the day of a week.  This can be one of: (1) integer value -- `1` represents Monday; (2) case-insensitive day name (e.g., `\"Monday\"`);  (3) case-insensitive, 3-character short day name (e.g., `\"Mon\"`).   <br/> **Warning:** A DateTime definition object with `day`** should not be combined with `year`, `quarter`, `month`, or `date`.\n   */\n  day?: Day | string;\n\n  /**\n   * Integer value representing the hour of a day from 0-23.\n   * @minimum 0\n   * @maximum 23\n   * @TJS-type integer\n   */\n  hours?: number;\n\n  /**\n   * Integer value representing the minute segment of time from 0-59.\n   * @minimum 0\n   * @maximum 59\n   * @TJS-type integer\n   */\n  minutes?: number;\n\n  /**\n   * Integer value representing the second segment (0-59) of a time value\n   * @minimum 0\n   * @maximum 59\n   * @TJS-type integer\n   */\n  seconds?: number;\n\n  /**\n   * Integer value representing the millisecond segment of time.\n   * @minimum 0\n   * @maximum 999\n   * @TJS-type integer\n   */\n  milliseconds?: number;\n}\n\n\n/**\n * Internal Object for defining datetime expressions.\n * This is an expression version of DateTime.\n * If both month and quarter are provided, month has higher precedence.\n * `day` cannot be combined with other date.\n */\nexport interface DateTimeExpr {\n  year?: string;\n  quarter?: string;\n  month?: string;\n  date?: string;\n  day?: string;\n  hours?: string;\n  minutes?: string;\n  seconds?: string;\n  milliseconds?: string;\n}\n\nexport function isDateTime(o: any): o is DateTime {\n  return !!o && (!!o.year || !!o.quarter || !!o.month || !!o.date || !!o.day ||\n    !!o.hours || !!o.minutes || !!o.seconds || !!o.milliseconds);\n}\n\nexport const MONTHS = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];\nexport const SHORT_MONTHS = MONTHS.map((m) => m.substr(0, 3));\n\nexport const DAYS = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\nexport const SHORT_DAYS = DAYS.map((d) => d.substr(0,3));\n\nfunction normalizeQuarter(q: number | string) {\n  if (isNumber(q)) {\n    if (q > 4) {\n      log.warn(log.message.invalidTimeUnit('quarter', q));\n    }\n    // We accept 1-based quarter, so need to readjust to 0-based quarter\n    return (q - 1) + '';\n  } else {\n    // Invalid quarter\n    throw new Error(log.message.invalidTimeUnit('quarter', q));\n  }\n}\n\nfunction normalizeMonth(m: string | number) {\n  if (isNumber(m)) {\n    // We accept 1-based month, so need to readjust to 0-based month\n    return (m - 1) + '';\n  } else {\n    const lowerM = m.toLowerCase();\n    const monthIndex = MONTHS.indexOf(lowerM);\n    if (monthIndex !== -1) {\n      return monthIndex + ''; // 0 for january, ...\n    }\n    const shortM = lowerM.substr(0, 3);\n    const shortMonthIndex = SHORT_MONTHS.indexOf(shortM);\n    if (shortMonthIndex !== -1) {\n      return shortMonthIndex + '';\n    }\n    // Invalid month\n    throw new Error(log.message.invalidTimeUnit('month', m));\n  }\n}\n\nfunction normalizeDay(d: string | number) {\n  if (isNumber(d)) {\n    // mod so that this can be both 0-based where 0 = sunday\n    // and 1-based where 7=sunday\n    return (d % 7) + '';\n  } else {\n    const lowerD = d.toLowerCase();\n    const dayIndex = DAYS.indexOf(lowerD);\n    if (dayIndex !== -1) {\n      return dayIndex + ''; // 0 for january, ...\n    }\n    const shortD = lowerD.substr(0, 3);\n    const shortDayIndex = SHORT_DAYS.indexOf(shortD);\n    if (shortDayIndex !== -1) {\n      return shortDayIndex + '';\n    }\n    // Invalid day\n    throw new Error(log.message.invalidTimeUnit('day', d));\n  }\n}\n\nexport function timestamp(d: DateTime, normalize: boolean) {\n  const date = new Date(0, 0, 1, 0, 0, 0, 0); // start with uniform date\n\n  // FIXME support UTC\n\n  if (d.day !== undefined) {\n    if (keys(d).length > 1) {\n      log.warn(log.message.droppedDay(d));\n      d = duplicate(d);\n      delete d.day;\n    } else {\n      // Use a year that has 1/1 as Sunday so we can setDate below\n      date.setFullYear(SUNDAY_YEAR);\n\n      const day = normalize ? normalizeDay(d.day) : d.day;\n      date.setDate(+day + 1); // +1 since date start at 1 in JS\n    }\n  }\n\n  if (d.year !== undefined) {\n    date.setFullYear(d.year);\n  }\n\n  if (d.quarter !== undefined) {\n    const quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;\n    date.setMonth(+quarter * 3);\n  }\n\n  if (d.month !== undefined) {\n    const month = normalize ? normalizeMonth(d.month) : d.month;\n    date.setMonth(+month);\n  }\n\n  if (d.date !== undefined) {\n    date.setDate(d.date);\n  }\n\n  if (d.hours !== undefined) {\n    date.setHours(d.hours);\n  }\n\n  if (d.minutes !== undefined) {\n    date.setMinutes(d.minutes);\n  }\n\n  if (d.seconds !== undefined) {\n    date.setSeconds(d.seconds);\n  }\n\n  if (d.milliseconds !== undefined) {\n    date.setMilliseconds(d.milliseconds);\n  }\n\n  return date.getTime();\n}\n\n/**\n * Return Vega Expression for a particular date time.\n * @param d\n * @param normalize whether to normalize quarter, month, day.\n */\nexport function dateTimeExpr(d: DateTime | DateTimeExpr, normalize = false) {\n  const units: (string | number)[] = [];\n\n  if (normalize && d.day !== undefined) {\n    if (keys(d).length > 1) {\n      log.warn(log.message.droppedDay(d));\n      d = duplicate(d);\n      delete d.day;\n    }\n  }\n\n  if (d.year !== undefined) {\n    units.push(d.year);\n  } else if (d.day !== undefined) {\n    // Set year to 2006 for working with day since January 1 2006 is a Sunday\n    units.push(SUNDAY_YEAR);\n  } else {\n    units.push(0);\n  }\n\n  if (d.month !== undefined) {\n    const month = normalize ? normalizeMonth(d.month) : d.month;\n    units.push(month);\n  } else if (d.quarter !== undefined) {\n    const quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;\n    units.push(quarter + '*3');\n  } else {\n    units.push(0); // months start at zero in JS\n  }\n\n  if (d.date !== undefined) {\n    units.push(d.date);\n  } else if (d.day !== undefined) {\n    // HACK: Day only works as a standalone unit\n    // This is only correct because we always set year to 2006 for day\n    const day = normalize ? normalizeDay(d.day) : d.day;\n    units.push(day + '+1');\n  } else {\n    units.push(1); // Date starts at 1 in JS\n  }\n\n  // Note: can't use TimeUnit enum here as importing it will create\n  // circular dependency problem!\n  for (const timeUnit of ['hours', 'minutes', 'seconds', 'milliseconds']) {\n    if (d[timeUnit] !== undefined) {\n      units.push(d[timeUnit]);\n    } else {\n      units.push(0);\n    }\n  }\n\n  return 'datetime(' + units.join(', ') + ')';\n}\n","// utility for encoding mapping\nimport {AggregateOp} from './aggregate';\nimport {Channel, CHANNELS, supportMark} from './channel';\nimport {CompositeAggregate} from './compositemark';\nimport {Facet} from './facet';\nimport {\n  ChannelDef,\n  ConditionalValueDef,\n  Field,\n  FieldDef,\n  isFieldDef,\n  isValueDef,\n  LegendFieldDef,\n  normalize,\n  OrderFieldDef,\n  PositionFieldDef,\n  TextFieldDef,\n  ValueDef\n} from './fielddef';\nimport * as log from './log';\nimport {Mark} from './mark';\nimport {isArray, some} from './util';\n\n// utility for encoding mapping\n\nexport interface Encoding<F> {\n  /**\n   * X coordinates for `point`, `circle`, `square`,\n   * `line`, `rule`, `text`, and `tick`\n   * (or to width and height for `bar` and `area` marks).\n   */\n  x?: PositionFieldDef<F> | ValueDef<number>;\n\n  /**\n   * Y coordinates for `point`, `circle`, `square`,\n   * `line`, `rule`, `text`, and `tick`\n   * (or to width and height for `bar` and `area` marks).\n   */\n  y?: PositionFieldDef<F> | ValueDef<number>;\n\n  /**\n   * X2 coordinates for ranged `bar`, `rule`, `area`.\n   */\n  // TODO: Ham need to add default behavior\n  x2?: FieldDef<F> | ValueDef<number>;\n\n  /**\n   * Y2 coordinates for ranged `bar`, `rule`, `area`.\n   */\n  // TODO: Ham need to add default behavior\n  y2?: FieldDef<F> | ValueDef<number>;\n\n  /**\n   * Color of the marks  either fill or stroke color based on mark type.\n   * (By default, fill color for `area`, `bar`, `tick`, `text`, `circle`, and `square` /\n   * stroke color for `line` and `point`.)\n   */\n  color?: LegendFieldDef<F, string> | ConditionalValueDef<string>;\n\n  /**\n   * Opacity of the marks  either can be a value or a range.\n   */\n  opacity?: LegendFieldDef<F, number> | ConditionalValueDef<number>;\n\n  /**\n   * Size of the mark.\n   * - For `point`, `square` and `circle`\n   *  the symbol size, or pixel area of the mark.\n   * - For `bar` and `tick`  the bar and tick's size.\n   * - For `text`  the text's font size.\n   * - Size is currently unsupported for `line` and `area`.\n   */\n  size?: LegendFieldDef<F, number> | ConditionalValueDef<number>;\n\n  /**\n   * The symbol's shape (only for `point` marks). The supported values are\n   * `\"circle\"` (default), `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`,\n   * or `\"triangle-down\"`, or else a custom SVG path string.\n   */\n  shape?: LegendFieldDef<F, string> | ConditionalValueDef<string>; // TODO: maybe distinguish ordinal-only\n\n  /**\n   * Additional levels of detail for grouping data in aggregate views and\n   * in line and area marks without mapping data to a specific visual channel.\n   */\n  detail?: FieldDef<F> | FieldDef<F>[];\n\n  /**\n   * Text of the `text` mark.\n   */\n  text?: TextFieldDef<F> | ConditionalValueDef<string|number|boolean>;\n\n  /**\n   * stack order for stacked marks or order of data points in line marks.\n   */\n  order?: OrderFieldDef<F> | OrderFieldDef<F>[];\n}\n\nexport interface EncodingWithFacet<F> extends Encoding<F>, Facet<F> {}\n\nexport function channelHasField(encoding: EncodingWithFacet<Field>, channel: Channel): boolean {\n  const channelDef = encoding && encoding[channel];\n  if (channelDef) {\n    if (isArray(channelDef)) {\n      return some(channelDef, (fieldDef) => !!fieldDef.field);\n    } else {\n      return isFieldDef(channelDef);\n    }\n  }\n  return false;\n}\n\nexport function isAggregate(encoding: EncodingWithFacet<Field>) {\n  return some(CHANNELS, (channel) => {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      if (isArray(channelDef)) {\n        return some(channelDef, (fieldDef) => !!fieldDef.aggregate);\n      } else {\n        return isFieldDef(channelDef) && !!channelDef.aggregate;\n      }\n    }\n    return false;\n  });\n}\n\nexport function normalizeEncoding(encoding: Encoding<string>, mark: Mark): Encoding<string> {\n  return Object.keys(encoding).reduce((normalizedEncoding: Encoding<string>, channel: Channel) => {\n    if (!supportMark(channel, mark)) {\n      // Drop unsupported channel\n\n      log.warn(log.message.incompatibleChannel(channel, mark));\n      return normalizedEncoding;\n    }\n\n    // Drop line's size if the field is aggregated.\n    if (channel === 'size' && mark === 'line') {\n      const channelDef = encoding[channel];\n      if (isFieldDef(channelDef) && channelDef.aggregate) {\n        log.warn(log.message.incompatibleChannel(channel, mark, 'when the field is aggregated.'));\n        return normalizedEncoding;\n      }\n    }\n\n    if (isArray(encoding[channel])) {\n      // Array of fieldDefs for detail channel (or production rule)\n      normalizedEncoding[channel] = encoding[channel].reduce((channelDefs: ChannelDef<string>[], channelDef: ChannelDef<string>) => {\n        if (!isFieldDef(channelDef) && !isValueDef(channelDef)) { // TODO: datum\n          log.warn(log.message.emptyFieldDef(channelDef, channel));\n        } else {\n          channelDefs.push(normalize(channelDef, channel));\n        }\n        return channelDefs;\n      }, []);\n    } else {\n      const channelDef = encoding[channel];\n      if (!isFieldDef(channelDef) && !isValueDef(channelDef)) { // TODO: datum\n        log.warn(log.message.emptyFieldDef(channelDef, channel));\n        return normalizedEncoding;\n      }\n      normalizedEncoding[channel] = normalize(channelDef, channel);\n    }\n    return normalizedEncoding;\n  }, {});\n}\n\n\nexport function isRanged(encoding: EncodingWithFacet<any>) {\n  return encoding && ((!!encoding.x && !!encoding.x2) || (!!encoding.y && !!encoding.y2));\n}\n\nexport function fieldDefs(encoding: EncodingWithFacet<Field>): FieldDef<Field>[] {\n  const arr: FieldDef<Field>[] = [];\n  CHANNELS.forEach(function(channel) {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      (isArray(channelDef) ? channelDef : [channelDef]).forEach((fieldDef) => {\n        arr.push(fieldDef);\n      });\n    }\n  });\n  return arr;\n}\n\nexport function forEach(mapping: any,\n    f: (fd: FieldDef<string>, c: Channel) => void,\n    thisArg?: any) {\n  if (!mapping) {\n    return;\n  }\n\n  Object.keys(mapping).forEach((c: any) => {\n    const channel: Channel = c;\n    if (isArray(mapping[channel])) {\n      mapping[channel].forEach(function(channelDef: ChannelDef<string>) {\n        f.call(thisArg, channelDef, channel);\n      });\n    } else {\n      f.call(thisArg, mapping[channel], channel);\n    }\n  });\n}\n\nexport function reduce<T, U>(mapping: U,\n    f: (acc: any, fd: FieldDef<string>, c: Channel) => U,\n    init: T, thisArg?: any) {\n  if (!mapping) {\n    return init;\n  }\n\n  return Object.keys(mapping).reduce((r: T, c: any) => {\n    const channel: Channel = c;\n    if (isArray(mapping[channel])) {\n      return mapping[channel].reduce(function(r1: T, channelDef: ChannelDef<string>) {\n        return f.call(thisArg, r1, channelDef, channel);\n      }, r);\n    } else {\n      return f.call(thisArg, r, mapping[channel], channel);\n    }\n  }, init);\n}\n","// utility for a field definition object\n\nimport {AGGREGATE_OP_INDEX, AggregateOp} from './aggregate';\nimport {Axis} from './axis';\nimport {autoMaxBins, Bin, binToString} from './bin';\nimport {Channel, rangeType} from './channel';\nimport {CompositeAggregate} from './compositemark';\nimport {Config} from './config';\nimport {Field} from './fielddef';\nimport {Legend} from './legend';\nimport * as log from './log';\nimport {Scale} from './scale';\nimport {SortField, SortOrder} from './sort';\nimport {StackOffset} from './stack';\nimport {isDiscreteByDefault, TimeUnit} from './timeunit';\nimport {getFullName, Type} from './type';\nimport {isBoolean, isString} from './util';\n\n/**\n * Definition object for a constant value of an encoding channel.\n */\nexport interface ValueDef<T> {\n  /**\n   * A constant value in visual domain.\n   */\n  value?: T;\n}\n\nexport interface ConditionalValueDef<T> extends ValueDef<T> {\n  condition?: Condition<T>;\n}\n\n/**\n * Reference to a repeated value.\n */\nexport type RepeatRef = {\n  repeat: 'row' | 'column'\n};\n\nexport type Field = string | RepeatRef;\n\nexport function isRepeatRef(field: Field): field is RepeatRef {\n  return field && !isString(field) && 'repeat' in field;\n}\n\n/**\n *  Definition object for a data field, its type and transformation of an encoding channel.\n */\nexport interface FieldDef<F> {\n  /**\n   * __Required.__ Name of the field from which to pull a data value.\n   *\n   * __Note:__ `field` is not required if `aggregate` is `count`.\n   */\n  field?: F;\n\n  /**\n   * The encoded field's type of measurement. This can be either a full type\n   * name (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`,  and `\"nominal\"`)\n   * or an initial character of the type name (`\"Q\"`, `\"T\"`, `\"O\"`, `\"N\"`).\n   * This property is case-insensitive.\n   */\n  type?: Type;\n\n\n  // function\n\n  /**\n   * Time unit for a `temporal` field  (e.g., `year`, `yearmonth`, `month`, `hour`).\n   *\n   * __Default value:__ `undefined` (None)\n   *\n   */\n  timeUnit?: TimeUnit;\n\n  /**\n   * Flag for binning a `quantitative` field, or a bin property object\n   * for binning parameters.\n   */\n  bin?: boolean | Bin;\n\n  /**\n   * Aggregation function for the field\n   * (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).\n   *\n   * __Default value:__ `undefined` (None)\n   *\n   */\n  aggregate?: AggregateOp | CompositeAggregate;\n\n  /**\n   * Title for axis or legend.\n   */\n  title?: string;\n\n  /**\n   * The formatting pattern for text value. If not defined, this will be determined automatically.\n   */\n  format?: string;\n}\n\nexport interface Condition<T> {\n  selection: string;\n  value: T;\n}\n\nexport interface ScaleFieldDef<F> extends FieldDef<F> {\n  scale?: Scale;\n  /**\n   * Sort order for a particular field.\n   * For quantitative or temporal fields, this can be either `\"ascending\"` or `\"descending\"`\n   * For quantitative or temporal fields, this can be `\"ascending\"`, `\"descending\"`, `\"none\"`, or a [sort field definition object](sort.html#sort-field) for sorting by an aggregate calculation of a specified sort field.\n   *\n   * __Default value:__ `\"ascending\"`\n   *\n   */\n  sort?: SortField | SortOrder;\n}\n\nexport interface PositionFieldDef<F> extends ScaleFieldDef<F> {\n  /**\n   * @nullable\n   */\n  axis?: Axis;\n\n  /**\n   * Type of stacking offset if the field should be stacked.\n   * \"none\" or null, if the field should not be stacked.\n   */\n  stack?: StackOffset;\n}\nexport interface LegendFieldDef<F, T> extends ScaleFieldDef<F> {\n   /**\n    * @nullable\n    */\n  legend?: Legend;\n\n  condition?: Condition<T>;\n}\n\n// Detail\n\n// Order Path have no scale\n\nexport interface OrderFieldDef<F> extends FieldDef<F> {\n  sort?: SortOrder;\n}\n\nexport interface TextFieldDef<F> extends FieldDef<F> {\n  // FIXME: add more reference to Vega's format pattern or d3's format pattern.\n  condition?: Condition<string|number>;\n}\n\nexport type ChannelDef<F> = FieldDef<F> | ValueDef<any>;\n\nexport function isFieldDef(channelDef: ChannelDef<any>): channelDef is FieldDef<any> | PositionFieldDef<any> | LegendFieldDef<any, any> | OrderFieldDef<any> | TextFieldDef<any> {\n  return !!channelDef && (!!channelDef['field'] || channelDef['aggregate'] === 'count');\n}\n\nexport function isValueDef(channelDef: ChannelDef<any>): channelDef is ValueDef<any> {\n  return channelDef && 'value' in channelDef && channelDef['value'] !== undefined;\n}\n\nexport interface FieldRefOption {\n  /** exclude bin, aggregate, timeUnit */\n  nofn?: boolean;\n  /** Wrap the field with datum or parent (e.g., datum['...'] for Vega Expression */\n  expr?: 'datum' | 'parent';\n  /** prepend fn with custom function prefix */\n  prefix?: string;\n  /** append suffix to the field ref for bin (default='start') */\n  binSuffix?: 'start' | 'end' | 'range';\n  /** append suffix to the field ref (general) */\n  suffix?: string;\n  /** Overrride which aggregate to use. Needed for unaggregated domain. */\n  aggregate?: AggregateOp;\n}\n\nexport function field(fieldDef: FieldDef<string>, opt: FieldRefOption = {}): string {\n  let field = fieldDef.field;\n  const prefix = opt.prefix;\n  let suffix = opt.suffix;\n\n  if (isCount(fieldDef)) {\n    field = 'count_*';\n  } else {\n    let fn: string = undefined;\n\n    if (!opt.nofn) {\n      if (fieldDef.bin) {\n        fn = binToString(fieldDef.bin);\n        suffix = opt.binSuffix;\n      } else if (fieldDef.aggregate) {\n        fn = String(opt.aggregate || fieldDef.aggregate);\n      } else if (fieldDef.timeUnit) {\n        fn = String(fieldDef.timeUnit);\n      }\n    }\n\n    if (fn) {\n      field = `${fn}_${field}`;\n    }\n  }\n\n  if (suffix) {\n    field = `${field}_${suffix}`;\n  }\n\n  if (prefix) {\n    field = `${prefix}_${field}`;\n  }\n\n  if (opt.expr) {\n    field = `${opt.expr}[\"${field}\"]`;\n  }\n\n  return field;\n}\n\nexport function isDiscrete(fieldDef: FieldDef<Field>) {\n  switch (fieldDef.type) {\n    case 'nominal':\n    case 'ordinal':\n      return true;\n    case 'quantitative':\n      return !!fieldDef.bin;\n    case 'temporal':\n      // TODO: deal with custom scale type case.\n      return isDiscreteByDefault(fieldDef.timeUnit);\n  }\n  throw new Error(log.message.invalidFieldType(fieldDef.type));\n}\n\nexport function isContinuous(fieldDef: FieldDef<Field>) {\n  return !isDiscrete(fieldDef);\n}\n\nexport function isCount(fieldDef: FieldDef<Field>) {\n  return fieldDef.aggregate === 'count';\n}\n\nexport function title(fieldDef: FieldDef<string>, config: Config) {\n  if (fieldDef.title === '') {\n    // an empty title should not take up space\n    return undefined;\n  }\n  if (fieldDef.title !== undefined) {\n    return fieldDef.title;\n  }\n  if (isCount(fieldDef)) {\n    return config.countTitle;\n  }\n  const fn = fieldDef.aggregate || fieldDef.timeUnit || (fieldDef.bin && 'bin');\n  if (fn) {\n    return fn.toUpperCase() + '(' + fieldDef.field + ')';\n  } else {\n    return fieldDef.field;\n  }\n}\n\nexport function defaultType(fieldDef: FieldDef<Field>, channel: Channel): Type {\n  if (fieldDef.timeUnit) {\n    return 'temporal';\n  }\n  if (fieldDef.bin) {\n    return 'quantitative';\n  }\n  switch (rangeType(channel)) {\n    case 'continuous':\n      return 'quantitative';\n    case 'discrete':\n      return 'nominal';\n    case 'flexible': // color\n      return 'nominal';\n    default:\n      return 'quantitative';\n  }\n}\n\n/**\n * Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.\n */\nexport function normalize(channelDef: ChannelDef<string>, channel: Channel) {\n  // If a fieldDef contains a field, we need type.\n  if (isFieldDef(channelDef)) { // TODO: or datum\n    let fieldDef: FieldDef<Field> = channelDef;\n\n    // Drop invalid aggregate\n    if (fieldDef.aggregate && !AGGREGATE_OP_INDEX[fieldDef.aggregate]) {\n      const {aggregate, ...fieldDefWithoutAggregate} = fieldDef;\n      log.warn(log.message.invalidAggregate(fieldDef.aggregate));\n      fieldDef = fieldDefWithoutAggregate;\n    }\n\n    // Normalize bin\n    if (fieldDef.bin) {\n      const bin = fieldDef.bin;\n      if (isBoolean(bin)) {\n        fieldDef = {\n          ...fieldDef,\n          bin: {maxbins: autoMaxBins(channel)}\n        };\n      } else if (!bin.maxbins && !bin.step) {\n        fieldDef = {\n          ...fieldDef,\n          bin: {\n            ...bin,\n            maxbins: autoMaxBins(channel)\n          }\n        };\n      }\n    }\n\n    // Normalize Type\n    if (fieldDef.type) {\n      const fullType = getFullName(fieldDef.type);\n      if (fieldDef.type !== fullType) {\n        // convert short type to full type\n        fieldDef = {\n          ...fieldDef,\n          type: fullType\n        };\n      }\n    } else {\n      // If type is empty / invalid, then augment with default type\n      const newType = defaultType(fieldDef, channel);\n      log.warn(log.message.emptyOrInvalidFieldType(fieldDef.type, channel, newType));\n      fieldDef = {\n          ...fieldDef,\n        type: newType\n      };\n    }\n\n    const {compatible, warning} = channelCompatibility(fieldDef, channel);\n    if (!compatible) {\n      log.warn(warning);\n    }\n    return fieldDef;\n  }\n  return channelDef;\n}\n\nconst COMPATIBLE = {compatible: true};\nexport function channelCompatibility(fieldDef: FieldDef<Field>, channel: Channel): {compatible: boolean; warning?: string;} {\n  switch (channel) {\n    case 'row':\n    case 'column':\n      if (isContinuous(fieldDef) && !fieldDef.timeUnit) {\n        // TODO:(https://github.com/vega/vega-lite/issues/2011):\n        // with timeUnit it's not always strictly continuous\n        return {\n          compatible: false,\n          warning: log.message.facetChannelShouldBeDiscrete(channel)\n        };\n      }\n      return COMPATIBLE;\n\n    case 'x':\n    case 'y':\n    case 'color':\n    case 'text':\n    case 'detail':\n      return COMPATIBLE;\n\n    case 'opacity':\n    case 'size':\n    case 'x2':\n    case 'y2':\n      if (isDiscrete(fieldDef) && !fieldDef.bin) {\n        return {\n          compatible: false,\n          warning: `Channel ${channel} should not be used with discrete field.`\n        };\n      }\n      return COMPATIBLE;\n\n    case 'shape':\n      if (fieldDef.type !== 'nominal') {\n        return {\n          compatible: false,\n          warning: 'Shape channel should be used with nominal data only'\n        };\n      }\n      return COMPATIBLE;\n\n    case 'order':\n      if (fieldDef.type === 'nominal') {\n        return {\n          compatible: false,\n          warning: `Channel order is inappropriate for nominal field, which has no inherent order.`\n        };\n      }\n      return COMPATIBLE;\n  }\n  throw new Error('channelCompatability not implemented for channel ' + channel);\n}\n","import {DateTime, dateTimeExpr, isDateTime} from './datetime';\nimport {field} from './fielddef';\nimport {fieldExpr as timeUnitFieldExpr, isSingleTimeUnit, TimeUnit} from './timeunit';\nimport {isArray, isString} from './util';\n\nexport type Filter = EqualFilter | RangeFilter | OneOfFilter | string;\n\n\nexport interface EqualFilter {\n  // TODO: support aggregate\n\n  /**\n   * Time unit for the field to be filtered.\n   */\n  timeUnit?: TimeUnit;\n\n  /**\n   * Field to be filtered.\n   */\n  field: string;\n\n  /**\n   * The value that the field should be equal to.\n   */\n  equal: string | number | boolean | DateTime;\n\n}\n\nexport function isEqualFilter(filter: any): filter is EqualFilter {\n  return filter && !!filter.field && filter.equal!==undefined;\n}\n\nexport interface RangeFilter {\n  // TODO: support aggregate\n\n  /**\n   * time unit for the field to be filtered.\n   */\n  timeUnit?: TimeUnit;\n\n  /**\n   * Field to be filtered\n   */\n  field: string;\n\n  /**\n   * An array of inclusive minimum and maximum values\n   * for a field value of a data item to be included in the filtered data.\n   * @maxItems 2\n   * @minItems 2\n   */\n  range: (number|DateTime)[];\n\n}\n\nexport function isRangeFilter(filter: any): filter is RangeFilter {\n  if (filter && filter.field) {\n    if (isArray(filter.range) && filter.range.length === 2) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport interface OneOfFilter {\n  // TODO: support aggregate\n\n  /**\n   * time unit for the field to be filtered.\n   */\n  timeUnit?: TimeUnit;\n\n  /**\n   * Field to be filtered\n   */\n  field: string;\n\n  /**\n   * A set of values that the `field`'s value should be a member of,\n   * for a data item included in the filtered data.\n   */\n  oneOf: string[] | number[] | boolean[] | DateTime[];\n\n}\n\nexport function isOneOfFilter(filter: any): filter is OneOfFilter {\n  return filter && !!filter.field && (\n    isArray(filter.oneOf) ||\n    isArray(filter.in) // backward compatibility\n  );\n}\n\n/**\n * Converts a filter into an expression.\n */\nexport function expression(filter: Filter | Filter[]): string {\n  if (isArray(filter)) {\n    return '(' +\n      filter.map((f) => expression(f))\n        .filter((f) => f !==undefined)\n        .join(') && (') +\n      ')';\n  } else if (isString(filter)) {\n    return filter;\n  } else { // Filter Object\n    const fieldExpr = filter.timeUnit ?\n      // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.\n        // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline\n        // TODO: support utc\n      ('time(' + timeUnitFieldExpr(filter.timeUnit, filter.field) + ')') :\n      field(filter, {expr: 'datum'});\n\n    if (isEqualFilter(filter)) {\n      return fieldExpr + '===' + valueExpr(filter.equal, filter.timeUnit);\n    } else if (isOneOfFilter(filter)) {\n      // \"oneOf\" was formerly \"in\" -- so we need to add backward compatibility\n      const oneOf: OneOfFilter[] = filter.oneOf || filter['in'];\n      return 'indexof([' +\n        oneOf.map((v) => valueExpr(v, filter.timeUnit)).join(',') +\n        '], ' + fieldExpr + ') !== -1';\n    } else if (isRangeFilter(filter)) {\n      const lower = filter.range[0];\n      const upper = filter.range[1];\n\n      if (lower !== null &&  upper !== null) {\n        return 'inrange(' + fieldExpr + ', ' +\n          valueExpr(lower, filter.timeUnit) + ', ' +\n          valueExpr(upper, filter.timeUnit) + ')';\n      } else if (lower !== null) {\n        return fieldExpr + ' >= ' + lower;\n      } else if (upper !== null) {\n        return fieldExpr + ' <= ' + upper;\n      }\n    }\n  }\n  return undefined;\n}\n\nfunction valueExpr(v: any, timeUnit: TimeUnit) {\n  if (isDateTime(v)) {\n    const expr = dateTimeExpr(v, true);\n    return 'time(' + expr + ')';\n  }\n  if (isSingleTimeUnit(timeUnit)) {\n    const datetime: DateTime = {};\n    datetime[timeUnit] = v;\n    const expr = dateTimeExpr(datetime, true);\n    return 'time(' + expr + ')';\n  }\n  return JSON.stringify(v);\n}\n","import {DateTime} from './datetime';\nimport {VgLegendBase, VgLegendConfig, VgLegendEncode} from './vega.schema';\n\nexport interface LegendConfig extends VgLegendConfig {\n  /**\n   * Whether month names and weekday names should be abbreviated.\n   *\n   * __Default value:__  `false`\n   */\n  shortTimeLabels?: boolean;\n}\n\n/**\n * Properties of a legend or boolean flag for determining whether to show it.\n */\nexport interface Legend extends VgLegendBase {\n  /**\n   * Optional mark definitions for custom legend encoding.\n   */\n  encode?: VgLegendEncode;\n\n  /**\n   * An optional formatting pattern for legend labels. Vega uses D3\\'s format pattern.\n   *\n   * __Default value:__  derived from [`numberFormat`](config.html#format) config for quantitative axis and from [`timeFormat`](config.html#format) config for time axis.\n   */\n  format?: string;\n\n  /**\n   * The desired number of tick values for quantitative legends.\n   */\n  tickCount?: number;\n\n  /**\n   * A title for the legend. (Shows field name and its function by default.)\n   *\n   * __Default value:__  derived from the field's name and transformation function applied e.g, \"field_name\", \"SUM(field_name)\", \"BIN(field_name)\", \"YEAR(field_name)\".\n   */\n  title?: string;\n  /**\n   * Explicitly set the visible legend values.\n   */\n  values?: number[] | string[] | DateTime[];\n\n  /**\n   * The name of a scale that maps to a shape value.\n   */\n  shape?: string;\n\n  /**\n   * The type of the legend. Use `symbol` to create a discrete legend and `gradient` for a continuous color gradient.\n   */\n  type?: 'symbol' | 'gradient';\n\n  /**\n   * A non-positive integer indicating z-index of the legend.\n   * If zindex is 0, legend should be drawn behind all chart elements.\n   * To put them in front, use zindex = 1.\n   * @TJS-type integer\n   * @minimum 0\n   */\n  zindex?: number;\n}\n\nexport const defaultLegendConfig: LegendConfig = {\n  orient: undefined, // implicitly \"right\"\n};\n\nexport const LEGEND_PROPERTIES:(keyof Legend)[] = ['entryPadding', 'format', 'offset', 'orient', 'tickCount', 'title', 'type', 'values' ,'zindex'];\n","///<reference path=\"../typings/vega-util.d.ts\" />\n\n/**\n * Vega-Lite's singleton logger utility.\n */\n\nimport {logger, LoggerInterface, Warn} from 'vega-util';\n\nimport {AggregateOp} from './aggregate';\nimport {Channel} from './channel';\nimport {DateTime, DateTimeExpr} from './datetime';\nimport {FieldDef} from './fielddef';\nimport {Mark} from './mark';\nimport {ScaleType} from './scale';\nimport {TimeUnit} from './timeunit';\nimport {Type} from './type';\n\nexport {LoggerInterface} from 'vega-util';\n\n/**\n * Main (default) Vega Logger instance for Vega-Lite\n */\nconst main = logger(Warn);\nlet current: LoggerInterface = main;\n\n/**\n * Logger tool for checking if the code throws correct warning\n */\nexport class LocalLogger implements LoggerInterface {\n  public warns: any[] = [];\n  public infos: any[] = [];\n  public debugs: any[] = [];\n\n  public level() {\n    return this;\n  }\n\n  public warn(...args: any[]) {\n    this.warns.push(...args);\n    return this;\n  }\n\n  public info(...args: any[]) {\n    this.infos.push(...args);\n    return this;\n  }\n\n  public debug(...args: any[]) {\n    this.debugs.push(...args);\n    return this;\n  }\n}\n\nexport function runLocalLogger(f: (localLogger: LocalLogger) => void) {\n  const localLogger = current = new LocalLogger();\n  f(localLogger);\n  reset();\n}\n\nexport function wrap(f: (logger: LocalLogger) => void) {\n  return () => {\n    const logger = current = new LocalLogger();\n    f(logger);\n    reset();\n  };\n}\n\n/**\n * Set the singleton logger to be a custom logger\n */\nexport function set(logger: LoggerInterface) {\n  current = logger;\n  return current;\n}\n\n/**\n * Reset the main logger to use the default Vega Logger\n */\nexport function reset() {\n  current = main;\n  return current;\n}\n\nexport function warn(..._: any[]) {\n  current.warn.apply(current, arguments);\n}\n\nexport function info(..._: any[]) {\n  current.info.apply(current, arguments);\n}\n\nexport function debug(..._: any[]) {\n  current.debug.apply(current, arguments);\n}\n\n/**\n * Collection of all Vega-Lite Error Messages\n */\nexport namespace message {\n  export const INVALID_SPEC = 'Invalid spec';\n\n  // REPEAT\n  export function noSuchRepeatedValue(field: string) {\n    return `Unknown repeated value \"${field}\".`;\n  }\n\n  // DATA\n  export function unrecognizedParse(p: string) {\n    return `Unrecognized parse ${p}.`;\n  }\n\n  // TRANSFORMS\n  export function invalidTransformIgnored(transform: any) {\n    return `Ignoring an invalid transform: ${JSON.stringify(transform)}.`;\n  }\n\n  // ENCODING & FACET\n  export function invalidFieldType(type: Type) {\n    return `Invalid field type \"${type}\"`;\n  }\n  export function invalidAggregate(aggregate: AggregateOp | string) {\n    return `Invalid aggregation operator \"${aggregate}\"`;\n  }\n\n  export function emptyOrInvalidFieldType(type: Type | string, channel: Channel, newType: Type) {\n    return `Invalid field type (${type}) for channel ${channel}, using ${newType} instead.`;\n  }\n\n  export function emptyFieldDef(fieldDef: FieldDef<string>, channel: Channel) {\n    return `Dropping ${JSON.stringify(fieldDef)} from channel ${channel} since it does not contain data field or value.`;\n  }\n\n  export function incompatibleChannel(channel: Channel, markOrFacet: Mark | 'facet', when?: string) {\n    return `${channel} dropped as it is incompatible with ${markOrFacet}${when ? ` when ${when}` : ''}.`;\n  }\n\n  export function facetChannelShouldBeDiscrete(channel: string) {\n    return `${channel} encoding should be discrete (ordinal / nominal / binned).`;\n  }\n\n  export function discreteChannelCannotEncode(channel: Channel, type: Type) {\n    return `Using discrete channel ${channel} to encode ${type} field can be misleading as it does not encode ${type === 'ordinal' ? 'order' : 'magnitude'}.`;\n  }\n\n  // Mark\n  export const BAR_WITH_POINT_SCALE_AND_RANGESTEP_NULL = 'Bar mark should not be used with point scale when rangeStep is null. Please use band scale instead.';\n\n  export function unclearOrientContinuous(mark: Mark) {\n    return `Cannot clearly determine orientation for ${mark} since both x and y channel encode continous fields. In this case, we use vertical by default`;\n  }\n\n  export function unclearOrientDiscreteOrEmpty(mark: Mark) {\n    return `Cannot clearly determine orientation for ${mark} since both x and y channel encode discrete or empty fields.`;\n  }\n\n  export function orientOverridden(original: string, actual: string) {\n    return `Specified orient ${original} overridden with ${actual}`;\n  }\n\n  // SCALE\n  export const CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN = 'custom domain scale cannot be unioned with default field-based domain';\n\n  export function cannotUseScalePropertyWithNonColor(prop: string) {\n    return `Cannot use ${prop} with non-color channel.`;\n  }\n\n  export function unaggregateDomainHasNoEffectForRawField(fieldDef: FieldDef<string>) {\n    return `Using unaggregated domain with raw field has no effect (${JSON.stringify(fieldDef)}).`;\n  }\n\n  export function unaggregateDomainWithNonSharedDomainOp(aggregate: string) {\n    return `Unaggregated domain not applicable for ${aggregate} since it produces values outside the origin domain of the source data.`;\n  }\n\n  export function unaggregatedDomainWithLogScale(fieldDef: FieldDef<string>) {\n    return `Unaggregated domain is currently unsupported for log scale (${JSON.stringify(fieldDef)}).`;\n  }\n\n  export const CANNOT_USE_RANGE_WITH_POSITION =\n    'Cannot use custom range with x or y channel.  Please customize width, height, padding, or rangeStep instead.';\n\n  export const CANNOT_USE_PADDING_WITH_FACET = 'Cannot use padding with facet\\'s scale.  Please use spacing instead.';\n\n  export function cannotUseRangePropertyWithFacet(propName: string) {\n    return `Cannot use custom ${propName} with row or column channel. Please use width, height, or spacing instead.`;\n  }\n\n  export function rangeStepDropped(channel: Channel) {\n    return `rangeStep for ${channel} is dropped as top-level ${\n      channel === 'x' ? 'width' : 'height'} is provided.`;\n  }\n\n  export function scaleTypeNotWorkWithChannel(channel: Channel, scaleType: ScaleType, defaultScaleType: ScaleType) {\n    return `Channel ${channel} does not work with ${scaleType} scale. We are using ${defaultScaleType} scale instead.`;\n  }\n\n  export function scaleTypeNotWorkWithFieldDef(scaleType: ScaleType, defaultScaleType: ScaleType) {\n    return `FieldDef does not work with ${scaleType} scale. We are using ${defaultScaleType} scale instead.`;\n  }\n\n  export function scalePropertyNotWorkWithScaleType(scaleType: ScaleType, propName: string, channel: Channel) {\n    return `${channel}-scale's \"${propName}\" is dropped as it does not work with ${scaleType} scale.`;\n  }\n\n  export function scaleTypeNotWorkWithMark(mark: Mark, scaleType: ScaleType) {\n    return `Scale type \"${scaleType}\" does not work with mark ${mark}.`;\n  }\n\n  export const INVAID_DOMAIN = 'Invalid scale domain';\n\n  export const UNABLE_TO_MERGE_DOMAINS = 'Unable to merge domains';\n\n  // AXIS\n  export const INVALID_CHANNEL_FOR_AXIS = 'Invalid channel for axis.';\n\n  // STACK\n  export function cannotStackRangedMark(channel: Channel) {\n    return `Cannot stack ${channel} if there is already ${channel}2`;\n  }\n\n  export function cannotStackNonLinearScale(scaleType: ScaleType) {\n    return `Cannot stack non-linear scale (${scaleType})`;\n  }\n\n  export function cannotStackNonSummativeAggregate(aggregate: string) {\n    return `Cannot stack when the aggregate function is non-summative (${aggregate})`;\n  }\n\n  // TIMEUNIT\n  export function invalidTimeUnit(unitName: string, value: string | number) {\n    return `Invalid ${unitName}: ${value}`;\n  }\n\n  export function dayReplacedWithDate(fullTimeUnit: TimeUnit) {\n    return `Time unit \"${fullTimeUnit}\" is not supported. We are replacing it with ${\n      fullTimeUnit.replace('day', 'date')}.`;\n  }\n\n  export function droppedDay(d: DateTime | DateTimeExpr) {\n    return `Dropping day from datetime ${JSON.stringify(d)} as day cannot be combined with other units.`;\n  }\n}\n\n","import {toSet} from './util';\nimport {Interpolate, Orient, VgMarkConfig} from './vega.schema';\nexport {Orient} from './vega.schema';\n\nexport namespace Mark {\n  export const AREA: 'area' = 'area';\n  export const BAR: 'bar' = 'bar';\n  export const LINE: 'line' = 'line';\n  export const POINT: 'point' = 'point';\n  export const RECT: 'rect' = 'rect';\n  export const RULE: 'rule' = 'rule';\n  export const TEXT: 'text' = 'text';\n  export const TICK: 'tick' = 'tick';\n  export const CIRCLE: 'circle' = 'circle';\n  export const SQUARE: 'square' = 'square';\n}\n\n/**\n * All types of primitive marks.\n */\nexport type Mark = typeof Mark.AREA | typeof Mark.BAR | typeof Mark.LINE | typeof Mark.POINT | typeof Mark.TEXT | typeof Mark.TICK | typeof Mark.RECT | typeof Mark.RULE | typeof Mark.CIRCLE | typeof Mark.SQUARE;\n\n\nexport const AREA = Mark.AREA;\nexport const BAR = Mark.BAR;\nexport const LINE = Mark.LINE;\nexport const POINT = Mark.POINT;\nexport const TEXT = Mark.TEXT;\nexport const TICK = Mark.TICK;\nexport const RECT = Mark.RECT;\nexport const RULE = Mark.RULE;\n\nexport const CIRCLE = Mark.CIRCLE;\nexport const SQUARE = Mark.SQUARE;\n\nexport const PRIMITIVE_MARKS = [AREA, BAR, LINE, POINT, TEXT, TICK, RECT, RULE, CIRCLE, SQUARE];\n\nexport interface MarkDef {\n  /**\n   * The mark type.\n   * One of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`,\n   * `\"area\"`, `\"point\"`, `\"rule\"`, and `\"text\"`.\n   */\n  type: Mark;\n\n  /**\n   * A metadata string indicating the role of the mark.\n   * This allows users to use `config.<role-name>.*` to customize properties of marks with specific roles.\n   * In addition, SVG renderers will add this role value (prepended with the prefix role-) as a CSS class name on the enclosing SVG group (g) element containing the mark instances.\n   */\n  role?: string;\n\n  /**\n   * Whether the mark's color should be used as fill color instead of stroke color.\n   * All marks except \"point\", \"line\", and \"rule\" are filled by default.\n   */\n  filled?: boolean;\n\n  /**\n   * The orientation of a non-stacked bar, tick, area, and line charts.\n   * The value is either horizontal (default) or vertical.\n   * - For bar, rule and tick, this determines whether the size of the bar and tick\n   * should be applied to x or y dimension.\n   * - For area, this property determines the orient property of the Vega output.\n   * - For line, this property determines the sort order of the points in the line\n   * if `config.sortLineBy` is not specified.\n   * For stacked charts, this is always determined by the orientation of the stack;\n   * therefore explicitly specified value will be ignored.\n   */\n  orient?: Orient;\n\n  /**\n   * The line interpolation method to use for line and area marks. One of the following:\n   * - `\"linear\"`: piecewise linear segments, as in a polyline.\n   * - `\"linear-closed\"`: close the linear segments to form a polygon.\n   * - `\"step\"`: alternate between horizontal and vertical segments, as in a step function.\n   * - `\"step-before\"`: alternate between vertical and horizontal segments, as in a step function.\n   * - `\"step-after\"`: alternate between horizontal and vertical segments, as in a step function.\n   * - `\"basis\"`: a B-spline, with control point duplication on the ends.\n   * - `\"basis-open\"`: an open B-spline; may not intersect the start or end.\n   * - `\"basis-closed\"`: a closed B-spline, as in a loop.\n   * - `\"cardinal\"`: a Cardinal spline, with control point duplication on the ends.\n   * - `\"cardinal-open\"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.\n   * - `\"cardinal-closed\"`: a closed Cardinal spline, as in a loop.\n   * - `\"bundle\"`: equivalent to basis, except the tension parameter is used to straighten the spline.\n   * - `\"monotone\"`: cubic interpolation that preserves monotonicity in y.\n   * For more information about each interpolation method, please see [D3's line interpolation](https://github.com/mbostock/d3/wiki/SVG-Shapes#line_interpolate).\n   */\n  interpolate?: Interpolate;\n\n  /**\n   * Depending on the interpolation type, sets the tension parameter (for line and area marks).(See [D3's line interpolation](https://github.com/mbostock/d3/wiki/SVG-Shapes#line_interpolate).)\n   * @minimum 0\n   * @maximum 1\n   */\n  tension?: number;\n}\n\nexport function isMarkDef(mark: string | MarkDef): mark is MarkDef {\n  return mark['type'];\n}\n\nconst PRIMITIVE_MARK_INDEX = toSet(PRIMITIVE_MARKS);\n\nexport function isPrimitiveMark(mark: string | MarkDef): mark is Mark {\n  const markType = isMarkDef(mark) ? mark.type : mark;\n  return markType in PRIMITIVE_MARK_INDEX;\n}\n\nexport const STROKE_CONFIG = ['stroke', 'strokeWidth',\n  'strokeDash', 'strokeDashOffset', 'strokeOpacity'];\n\nexport const FILL_CONFIG = ['fill', 'fillOpacity'];\n\nexport const FILL_STROKE_CONFIG = [].concat(STROKE_CONFIG, FILL_CONFIG);\n\nexport interface MarkConfig extends VgMarkConfig {\n\n  // ---------- Color ----------\n  /**\n   * Whether the mark's color should be used as fill color instead of stroke color.\n   *\n   * __Default value:__ `true` for all marks except `point` and `false` for `point`.\n   *\n   * __Applicable for:__ `bar`, `point`, `circle`, `square`, and `area` marks.\n   *\n   */\n  filled?: boolean;\n\n  // TODO: remove this once we correctly integrate theme\n  /**\n   * Default color.\n   *\n   * __Default value:__ <span style=\"color: #4682b4;\">&#9632;</span> `\"#4682b4\"`\n   */\n  color?: string;\n}\n\nexport const defaultMarkConfig: MarkConfig = {\n  color: '#4c78a8',\n};\n\nexport interface BarConfig extends MarkConfig {\n  /**\n   * Offset between bar for binned field.  Ideal value for this is either 0 (Preferred by statisticians) or 1 (Vega-Lite Default, D3 example style).\n   *\n   * __Default value:__ `1`\n   *\n   * @minimum 0\n   */\n  binSpacing?: number;\n  /**\n   * The default size of the bars on continuous scales.\n   *\n   * __Default value:__ `2`\n   *\n   * @minimum 0\n   */\n  continuousBandSize?: number;\n\n  /**\n   * The size of the bars.  If unspecified, the default size is  `bandSize-1`,\n   * which provides 1 pixel offset between bars.\n   * @minimum 0\n   */\n  discreteBandSize?: number;\n}\n\nexport const defaultBarConfig: BarConfig = {\n  binSpacing: 1,\n  continuousBandSize: 2\n};\n\nexport interface TextConfig extends MarkConfig {\n  /**\n   * Whether month names and weekday names should be abbreviated.\n   */\n  shortTimeLabels?: boolean;\n}\n\nexport const defaultTextConfig: TextConfig = {\n  baseline: 'middle',\n};\n\nexport interface TickConfig extends MarkConfig {\n  /**\n   * The width of the ticks.\n   * If this value is undefined (by default,), we use 2/3 of rangeStep by default.\n   * @minimum 0\n   */\n  bandSize?: number;\n\n  /**\n   * Thickness of the tick mark.\n   *\n   * __Default value:__  `1`\n   *\n   * @minimum 0\n   */\n  thickness?: number;\n}\n\nexport const defaultTickConfig: TickConfig = {\n  thickness: 1\n};\n","import {Channel} from './channel';\nimport {DateTime} from './datetime';\nimport * as log from './log';\nimport {contains, toSet} from './util';\n\nexport namespace ScaleType {\n  // Continuous - Quantitative\n  export const LINEAR: 'linear' = 'linear';\n  export const BIN_LINEAR: 'bin-linear' = 'bin-linear';\n  export const LOG: 'log' = 'log';\n  export const POW: 'pow' = 'pow';\n  export const SQRT: 'sqrt' = 'sqrt';\n  // Continuous - Time\n  export const TIME: 'time' = 'time';\n  export const UTC: 'utc'  = 'utc';\n  // sequential\n  export const SEQUENTIAL: 'sequential' = 'sequential';\n\n  // Quantile, Quantize, threshold\n  export const QUANTILE: 'quantile' = 'quantile';\n  export const QUANTIZE: 'quantize' = 'quantize';\n  export const THRESHOLD: 'threshold' = 'threshold';\n\n  export const ORDINAL: 'ordinal' = 'ordinal';\n  export const BIN_ORDINAL: 'bin-ordinal' = 'bin-ordinal';\n  export const POINT: 'point' = 'point';\n  export const BAND: 'band' = 'band';\n}\n\nexport type ScaleType = typeof ScaleType.LINEAR | typeof ScaleType.BIN_LINEAR |\n  typeof ScaleType.LOG | typeof ScaleType.POW | typeof ScaleType.SQRT |\n  typeof ScaleType.TIME | typeof ScaleType.UTC |\n  // TODO: add 'quantize', 'quantile', 'threshold' back when we really support them\n  typeof ScaleType.SEQUENTIAL | // typeof ScaleType.QUANTILE | typeof ScaleType.QUANTIZE | typeof ScaleType.THRESHOLD |\n  typeof ScaleType.ORDINAL | typeof ScaleType.BIN_ORDINAL | typeof ScaleType.POINT | typeof ScaleType.BAND;\n\nexport const SCALE_TYPES: ScaleType[] = [\n  // Continuous - Quantitative\n  'linear', 'bin-linear', 'log', 'pow', 'sqrt',\n  // Continuous - Time\n  'time', 'utc',\n  // Sequential\n  'sequential', // TODO: add 'quantile', 'quantize' when we really support them\n  // Discrete\n  'ordinal', 'bin-ordinal', 'point', 'band',\n];\n\nexport const CONTINUOUS_TO_CONTINUOUS_SCALES: ScaleType[] = ['linear', 'bin-linear', 'log', 'pow', 'sqrt', 'time', 'utc'];\nconst CONTINUOUS_TO_CONTINUOUS_INDEX = toSet(CONTINUOUS_TO_CONTINUOUS_SCALES);\n\nexport const CONTINUOUS_DOMAIN_SCALES: ScaleType[] = CONTINUOUS_TO_CONTINUOUS_SCALES.concat(['sequential' /* TODO add 'quantile', 'quantize', 'threshold'*/]);\nconst CONTINUOUS_DOMAIN_INDEX = toSet(CONTINUOUS_DOMAIN_SCALES);\n\nexport const DISCRETE_DOMAIN_SCALES: ScaleType[] = ['ordinal', 'bin-ordinal', 'point', 'band'];\nconst DISCRETE_DOMAIN_INDEX = toSet(DISCRETE_DOMAIN_SCALES);\n\nconst BIN_SCALES_INDEX = toSet(['bin-linear', 'bin-ordinal']);\n\nexport const TIME_SCALE_TYPES: ScaleType[] = ['time', 'utc'];\n\nexport function hasDiscreteDomain(type: ScaleType): type is 'ordinal' | 'bin-ordinal' | 'point' | 'band' {\n  return type in DISCRETE_DOMAIN_INDEX;\n}\n\nexport function isBinScale(type: ScaleType): type is 'bin-linear' | 'bin-ordinal' {\n  return type in BIN_SCALES_INDEX;\n}\n\nexport function hasContinuousDomain(type: ScaleType):\n  type is 'linear' | 'log' | 'pow' | 'sqrt' |  'time' | 'utc'|\n          'sequential' /* TODO add | 'quantile' | 'quantize' | 'threshold' */ {\n  return type in CONTINUOUS_DOMAIN_INDEX;\n}\n\nexport function isContinuousToContinuous(type: ScaleType): type is 'linear' | 'bin-linear' | 'log' | 'pow' | 'sqrt' |  'time' | 'utc' {\n  return type in CONTINUOUS_TO_CONTINUOUS_INDEX;\n}\n\nexport type NiceTime = 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year';\n\nexport interface ScaleConfig {\n  /**\n   * If true, rounds numeric output values to integers.\n   * This can be helpful for snapping to the pixel grid.\n   * (Only available for `x`, `y`, `size`, `row`, and `column` scales.)\n   */\n  round?: boolean;\n\n  /**\n   * If true, values that exceed the data domain are clamped to either the minimum or maximum range value\n   */\n  clamp?: boolean;\n  /**\n   *  Default range step for `x` ordinal scale when is mark is `text`.\n   *\n   * __Default value:__ `90`\n   *\n   *  @minimum 0\n   */\n  textXRangeStep?: number; // FIXME: consider if we will rename this \"tableColumnWidth\"\n  /**\n   * Default range step for (1) `y` ordinal scale,\n   * and (2) `x` ordinal scale when the mark is not `text`.\n   *\n   * __Default value:__ `21`\n   *\n   * @minimum 0\n   * @nullable\n   */\n  rangeStep?: number | null;\n\n  /**\n   * Default inner padding for `x` and `y` band-ordinal scales.\n   *\n   * __Default value:__ `0.1`\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  bandPaddingInner?: number;\n\n  /**\n   * Default outer padding for `x` and `y` band-ordinal scales.\n   * If not specified, by default, band scale's paddingOuter is paddingInner/2.\n   * @minimum 0\n   * @maximum 1\n   */\n  bandPaddingOuter?: number;\n\n  /**\n   * Default outer padding for `x` and `y` point-ordinal scales.\n   *\n   * __Default value:__ `0.5`\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  pointPadding?: number;\n\n  /**\n   * Use the source data range before aggregation as scale domain instead of aggregated data for aggregate axis.\n   * This property only works with aggregate functions that produce values within the raw data domain (`\"mean\"`, `\"average\"`, `\"median\"`, `\"q1\"`, `\"q3\"`, `\"min\"`, `\"max\"`). For other aggregations that produce values outside of the raw data domain (e.g. `\"count\"`, `\"sum\"`), this property is ignored.\n   */\n  useUnaggregatedDomain?: boolean;\n\n  // nice should depends on type (quantitative or temporal), so\n  // let's not make a config.\n\n  // Configs for Range\n\n\n  /**\n   * The default max value for mapping quantitative fields to bar's size/bandSize.\n   * If undefined (default), we will use bandSize - 1.\n   * @minimum 0\n   */\n  maxBandSize?: number;\n\n  /**\n   * The default min value for mapping quantitative fields to bar and tick's size/bandSize scale with zero=false\n   * If undefined (default), we will use the `continuousBandSize` value for bar and 3 for ticks.\n   * @minimum 0\n   */\n  minBandSize?: number;\n\n  /**\n   * The default max value for mapping quantitative fields to text's size/fontSize.\n   * If undefined (default), we will use bandSize - 1.\n   *\n   * __Default value:__ `40`\n   *\n   * @minimum 0\n   */\n  maxFontSize?: number;\n\n  /**\n   * The default min value for mapping quantitative fields to tick's size/fontSize scale with zero=false\n   *\n   * __Default value:__ `8`\n   *\n   * @minimum 0\n   */\n  minFontSize?: number;\n\n  /**\n   * Default minimum opacity for mapping a field to opacity.\n   *\n   * __Default value:__ `0.3`\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  minOpacity?: number;\n\n  /**\n   * Default max opacity for mapping a field to opacity.\n   *\n   * __Default value:__ `0.8`\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  maxOpacity?: number;\n\n\n  /**\n   * Default minimum value for point size scale with zero=false.\n   *\n   * __Default value:__ `9`\n   *\n   * @minimum 0\n   */\n  minSize?: number;\n\n  /**\n   * Default max value for point size scale.\n   * @minimum 0\n   */\n  maxSize?: number;\n\n  /**\n   * Default minimum strokeWidth for strokeWidth (or rule/line's size) scale with zero=false.\n   *\n   * __Default value:__ `1`\n   *\n   * @minimum 0\n   */\n  minStrokeWidth?: number;\n\n  /**\n   * Default max strokeWidth for strokeWidth  (or rule/line's size) scale.\n   *\n   * __Default value:__ `4`\n   *\n   * @minimum 0\n   */\n  maxStrokeWidth?: number;\n\n  /**\n   * The default collection of symbol shapes for mapping nominal fields to shapes of point marks (i.e., range of a `shape` scale).\n   * Each value should be one of: `\"circle\"`, `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`, or `\"triangle-down\"`, or a custom SVG path.\n   *\n   * __Default value:__ `[\"circle\", \"square\", \"cross\", \"diamond\", \"triangle-up\", \"triangle-down\"]`\n   *\n   */\n  shapes?: string[];\n}\n\nexport const defaultScaleConfig = {\n  round: true,\n  textXRangeStep: 90,\n  rangeStep: 21,\n  pointPadding: 0.5,\n  bandPaddingInner: 0.1,\n  facetSpacing: 16,\n\n  minFontSize: 8,\n  maxFontSize: 40,\n\n  minOpacity: 0.3,\n  maxOpacity: 0.8,\n\n  // FIXME: revise if these *can* become ratios of rangeStep\n  minSize: 9, // Point size is area. For square point, 9 = 3 pixel ^ 2, not too small!\n\n  minStrokeWidth: 1,\n  maxStrokeWidth: 4,\n\n  shapes: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down']\n};\n\nexport interface ExtendedScheme {\n  /**\n   * Color scheme that determines output color of an ordinal/sequential color scale.\n   */\n  name: string;\n\n  // TODO: add docs\n  extent?: number[];\n\n  // TODO: add docs\n  count?: number;\n}\n\nexport type Domain = number[] | string[] | DateTime[] | 'unaggregated';\nexport type Scheme = string | ExtendedScheme;\n\nexport type Range = number[] | string[] | string;\n\nexport function isExtendedScheme(scheme: string | ExtendedScheme): scheme is ExtendedScheme {\n  return scheme && !!scheme['name'];\n}\n\nexport interface Scale {\n  /**\n   * The type of scale.\n   * - For a _quantitative_ field, supported quantitative scale types  are `\"linear\"` (default), `\"log\"`, `\"pow\"`, `\"sqrt\"`, `\"quantile\"`, `\"quantize\"`, and `\"threshold\"`.\n   * - For a _temporal_ field without `timeUnit`, the scale type should be `\"time\"` (default) or `\"ordinal\"`.\n   * - For _ordinal_ and _nominal_ fields, the type is always `\"ordinal\"`.\n   * Unsupported values will be ignored.\n   */\n  type?: ScaleType;\n  /**\n   * The domain of the scale, representing the set of data values. For quantitative data, this can take the form of a two-element array with minimum and maximum values. For ordinal/categorical data, this may be an array of valid input values.\n   *\n   * If the domain is `\"unaggregated\"`, we use the source data range before aggregation as scale domain instead of aggregated data for an aggregate axis.\n   * This property only works with aggregate functions that produce values within the raw data domain (`\"mean\"`, `\"average\"`, `\"median\"`, `\"q1\"`, `\"q3\"`, `\"min\"`, `\"max\"`). For other aggregations that produce values outside of the raw data domain (e.g. `\"count\"`, `\"sum\"`), this property is ignored.\n   */\n  domain?: Domain;\n\n  /**\n   * The range of the scale, representing the set of visual values. For numeric values, the range can take the form of a two-element array with minimum and maximum values. For ordinal or quantized data, the range may by an array of desired output values, which are mapped to elements in the specified domain.\n   */\n  range?: Range;\n\n  /**\n   * If `true`, rounds numeric output values to integers. This can be helpful for snapping to the pixel grid.\n   *\n   * __Default Rule:__ `true` for `\"x\"`, `\"y\"`, `\"row\"`, `\"column\"` channels if scale config's `round` is `true`; `false` otherwise.\n   */\n  round?: boolean;\n\n  // ordinal\n  /**\n   * The distance between the starts of adjacent bands or points in band or point scales.\n   * If this value is `null`, this will be determined to fit width (for x) or height (for y) of the plot.\n   * If both width and x-scale's rangeStep is provided, rangeStep will be dropped.  (The same rule is applied for height and y-scale's rangeStep.)\n   *\n   * __Default Rule:__ for `x` ordinal scale of a `text` mark, derived from [scale config](config.html#scale-config)'s `textXRangeStep`. Otherwise, derived from [scale config](config.html#scale-config)'s `rangeStep`.\n   * __Warning:__ If the cardinality of the scale domain is too high, the rangeStep might become less than one pixel and the mark might not appear correctly.\n   * @minimum 0\n   * @nullable\n   */\n  rangeStep?: number | null;\n\n  /**\n   * Range scheme (e.g., color schemes such as `\"category10\"` or `\"viridis\"`).\n   *\n   * __Default value:__ [scale config](config.html#scale-config)'s `\"nominalColorScheme\"` for nominal field and `\"sequentialColorScheme\"` for other types of fields.\n   *\n   */\n  scheme?: Scheme;\n\n\n  /**\n   * Applies spacing among ordinal elements in the scale range. The actual effect depends on how the scale is configured. If the __points__ parameter is `true`, the padding value is interpreted as a multiple of the spacing between points. A reasonable value is 1.0, such that the first and last point will be offset from the minimum and maximum value by half the distance between points. Otherwise, padding is typically in the range [0, 1] and corresponds to the fraction of space in the range interval to allocate to padding. A value of 0.5 means that the band size will be equal to the padding width. For more, see the [D3 ordinal scale documentation](https://github.com/mbostock/d3/wiki/Ordinal-Scales).\n   * A convenience property for setting the inner and outer padding to the same value.\n   *\n   * __Default value:__ `x` and `y` channels are derived from [scale config](config.html#scale-config)'s `pointPadding` for `point` scale and `bandPadding` for `band` scale.  Other channels have `0` padding by default.\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  padding?: number;\n\n  /**\n   * The inner padding of a band scale determines the ratio of the range that is reserved for blank space between bands. (For point scale, this property is ignored.)\n   * @minimum 0\n   * @maximum 1\n   */\n  paddingInner?: number;\n\n  /**\n   * The outer padding determines the ratio of the range that is reserved for blank space before the first and after the last bands/points.\n   * @minimum 0\n   * @maximum 1\n   */\n  paddingOuter?: number;\n\n  // typical\n  /**\n   * If `true`, values that exceed the data domain are clamped to either the minimum or maximum range value\n   *\n   * __Default value:__ derived from [scale config](config.html#scale-config) (`true` by default)\n   *\n   * __Supported types:__ only `linear`, `pow`, `sqrt`, and `log` (Not applicable for `quantile`, `quantize`, and `threshold` scales as they output discrete ranges.)\n   *\n   */\n  clamp?: boolean;\n  /**\n   * As quantitative scale property, if specified, modifies the scale domain to use a more human-friendly value range. If specified as a `true` boolean, modifies the scale domain to use a more human-friendly number range (e.g., 7 instead of 6.96). If specified as a string, modifies the scale domain to use a more human-friendly value range. For time and utc scale types only, the nice value should be a string indicating the desired time interval.\n   * As time scale properties, if `true`, values that exceed the data domain are clamped to either the minimum or maximum range value. (Not applicable for `quantile`, `quantize`, and `threshold` scales as they output discrete ranges.)\n   *\n   * __Default value:__ `true` only for quantitative x and y scales and `false` otherwise.\n   *\n   */\n  nice?: boolean | string;\n  /**\n   * Sets the exponent of the scale transformation. For `pow` scale types only, otherwise ignored.\n   */\n  exponent?: number;\n  /**\n   * If `true`, ensures that a zero baseline value is included in the scale domain.\n   * Default value: `true` for `x` and `y` channel if the quantitative field is not binned\n   * and no custom `domain` is provided; `false` otherwise.\n   *\n   * __Default value:__ `true` for `x` and `y` channel if the quantitative field is not binned and no custom `domain` is provided; `false` otherwise.\n   *\n   * __Note:__  This property is always `false` for log scale.\n   *\n   */\n  zero?: boolean;\n\n  // FIXME: Add description\n  interpolate?: 'rgb'| 'lab' | 'hcl' | 'hsl' | 'hsl-long' | 'hcl-long' | 'cubehelix' | 'cubehelix-long';\n}\n\nexport const SCALE_PROPERTIES:(keyof Scale)[]= [\n  'type', 'domain', 'range', 'round', 'rangeStep', 'scheme', 'padding', 'paddingInner', 'paddingOuter', 'clamp', 'nice',\n  'exponent', 'zero', 'interpolate'\n];\n\nexport function scaleTypeSupportProperty(scaleType: ScaleType, propName: keyof Scale) {\n  switch (propName) {\n    case 'type':\n    case 'domain':\n    case 'range':\n    case 'scheme':\n      return true;\n    case 'interpolate':\n      return contains(['linear', 'bin-linear', 'pow', 'log', 'sqrt', 'utc', 'time'], scaleType);\n    case 'round':\n      return isContinuousToContinuous(scaleType) || scaleType === 'band' || scaleType === 'point';\n    case 'rangeStep':\n    case 'padding':\n    case 'paddingOuter':\n      return contains(['point', 'band'], scaleType);\n    case 'paddingInner':\n      return scaleType === 'band';\n    case 'clamp':\n      return isContinuousToContinuous(scaleType) || scaleType === 'sequential';\n    case 'nice':\n      return isContinuousToContinuous(scaleType) || scaleType === 'sequential' || scaleType as any === 'quantize';\n    case 'exponent':\n      return scaleType === 'pow' || scaleType === 'log';\n    case 'zero':\n      // TODO: what about quantize, threshold?\n      return scaleType === 'bin-ordinal' || (!hasDiscreteDomain(scaleType) && !contains(['log', 'time', 'utc', 'bin-linear'], scaleType));\n  }\n  /* istanbul ignore next: should never reach here*/\n  throw new Error(`Invalid scale property ${propName}.`);\n}\n\n/**\n * Returns undefined if the input channel supports the input scale property name\n */\nexport function channelScalePropertyIncompatability(channel: Channel, propName: keyof Scale): string {\n  switch (propName) {\n    case 'range':\n      // User should not customize range for position and facet channel directly.\n      if (channel === 'x' || channel === 'y') {\n        return log.message.CANNOT_USE_RANGE_WITH_POSITION;\n      }\n      if (channel === 'row' || channel === 'column') {\n        return log.message.cannotUseRangePropertyWithFacet('range');\n      }\n      return undefined; // GOOD!\n    // band / point\n    case 'rangeStep':\n      if (channel === 'row' || channel === 'column') {\n        return log.message.cannotUseRangePropertyWithFacet('rangeStep');\n      }\n      return undefined; // GOOD!\n    case 'padding':\n    case 'paddingInner':\n    case 'paddingOuter':\n      if (channel === 'row' || channel === 'column') {\n        /*\n         * We do not use d3 scale's padding for row/column because padding there\n         * is a ratio ([0, 1]) and it causes the padding to be decimals.\n         * Therefore, we manually calculate \"spacing\" in the layout by ourselves.\n         */\n        return log.message.CANNOT_USE_PADDING_WITH_FACET;\n      }\n      return undefined; // GOOD!\n    case 'interpolate':\n    case 'scheme':\n      if (channel !== 'color') {\n        return log.message.cannotUseScalePropertyWithNonColor(channel);\n      }\n      return undefined;\n    case 'type':\n    case 'domain':\n    case 'round':\n    case 'clamp':\n    case 'exponent':\n    case 'nice':\n    case 'zero':\n      // These channel do not have strict requirement\n      return undefined; // GOOD!\n  }\n  /* istanbul ignore next: it should never reach here */\n  throw new Error('Invalid scale property \"${propName}\".');\n}\n","import {VgBinding} from './vega.schema';\n\nexport type SelectionTypes = 'single' | 'multi' | 'interval';\nexport type SelectionDomain = 'data' | 'visual';\nexport type SelectionResolutions = 'global' | 'independent' | 'union' |\n  'union_others' | 'intersect' | 'intersect_others';\n\nexport interface BaseSelectionDef {\n  // domain?: SelectionDomain;\n  resolve?: SelectionResolutions;\n  on?: any;\n  // predicate?: string;\n  bind?: 'scales' | VgBinding | {[key: string]: VgBinding};\n\n  // Transforms\n  fields?: string[];\n  encodings?: string[];\n  toggle?: string | boolean;\n  translate?: string | boolean;\n  zoom?: string | boolean;\n  nearest?: boolean;\n}\n\nexport interface SelectionDef extends BaseSelectionDef {\n  type: SelectionTypes;\n}\n\nexport interface SelectionConfig {\n  single: BaseSelectionDef;\n  multi: BaseSelectionDef;\n  interval: BaseSelectionDef;\n}\n\nexport const defaultConfig:SelectionConfig = {\n  single: {on: 'click', fields: ['_id'], resolve: 'global'},\n  multi: {on: 'click', fields: ['_id'], toggle: 'event.shiftKey', resolve: 'global'},\n  interval: {\n    on: '[mousedown, window:mouseup] > window:mousemove!',\n    encodings: ['x', 'y'],\n    translate: '[mousedown, window:mouseup] > window:mousemove!',\n    zoom: 'wheel',\n    resolve: 'global'\n  }\n};\n","import {AggregateOp} from './aggregate';\n\nexport type SortOrder = 'ascending' | 'descending' | null;\n\nexport interface SortField {\n  /**\n   * The field name to aggregate over.\n   */\n  field: string;\n  /**\n   * The sort aggregation operator\n   */\n  op: AggregateOp;\n\n  order?: SortOrder;\n}\n\nexport function isSortField(sort: SortOrder | SortField): sort is SortField {\n  return !!sort && !!sort['field'] && !!sort['op'];\n}\n","import {COLUMN, ROW, X, X2, Y, Y2} from './channel';\nimport * as compositeMark from './compositemark';\nimport {CompositeMark} from './compositemark';\nimport {Config} from './config';\nimport {Data} from './data';\nimport {channelHasField, Encoding, EncodingWithFacet, isRanged} from './encoding';\nimport * as vlEncoding from './encoding';\nimport {Facet} from './facet';\nimport {Field, FieldDef} from './fielddef';\nimport * as log from './log';\nimport {AREA, isPrimitiveMark, LINE, Mark, MarkDef} from './mark';\nimport {Repeat} from './repeat';\nimport {SelectionDef} from './selection';\nimport {stack} from './stack';\nimport {TopLevelProperties} from './toplevelprops';\nimport {Transform} from './transform';\nimport {contains, duplicate, hash, vals} from './util';\n\n\nexport type TopLevel<S extends BaseSpec> = S & TopLevelProperties & {\n  /**\n   * URL to JSON schema for this Vega-Lite specification.\n   * @format uri\n   */\n  $schema?: string;\n\n  /**\n   * Configuration object\n   */\n  config?: Config;\n};\n\n\nexport interface BaseSpec {\n\n  /**\n   * Name of the visualization for later reference.\n   */\n  name?: string;\n\n  /**\n   * An optional description of this mark for commenting purpose.\n   * This property has no effect on the output visualization.\n   */\n  description?: string;\n\n  /**\n   * An object describing the data source\n   */\n  data?: Data;\n\n  /**\n   * An object describing filter and new field calculation.\n   */\n  transform?: Transform[];\n}\n\nexport interface GenericUnitSpec<M, E extends Encoding<any>> extends BaseSpec {\n  // FIXME description for top-level width\n  width?: number;\n\n  // FIXME description for top-level width\n  height?: number;\n\n  /**\n   * The mark type.\n   * One of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`,\n   * `\"area\"`, `\"point\"`, `\"rule\"`, and `\"text\"`.\n   */\n  mark: M;\n\n  /**\n   * A key-value mapping between encoding channels and definition of fields.\n   */\n  encoding: E;\n\n  /**\n   * A key-value mapping between selection names and definitions.\n   */\n  selection?: {[name: string]: SelectionDef};\n}\n\nexport type UnitSpec = GenericUnitSpec<Mark | MarkDef, Encoding<Field>>;\n\n/**\n * Unit spec that can contain composite mark\n */\nexport type CompositeUnitSpec = GenericUnitSpec<CompositeMark | Mark | MarkDef, Encoding<Field>>;\n\n/**\n * Unit spec that can contain composite mark and row or column channels.\n */\nexport type FacetedCompositeUnitSpec = GenericUnitSpec<CompositeMark | Mark | MarkDef, EncodingWithFacet<Field>>;\n\nexport interface GenericLayerSpec<U extends GenericUnitSpec<any, any>> extends BaseSpec {\n  // FIXME description for top-level width\n  width?: number;\n\n  // FIXME description for top-level width\n  height?: number;\n\n  /**\n   * Unit specs that will be layered.\n   */\n  layer: (GenericLayerSpec<U> | U)[];\n}\n\nexport type LayerSpec = GenericLayerSpec<UnitSpec>;\n\nexport interface GenericFacetSpec<U extends GenericUnitSpec<any, any>> extends BaseSpec {\n  facet: Facet<Field>;\n\n  // TODO: support facet of facet\n  spec: GenericLayerSpec<U> | U;\n}\n\nexport type FacetSpec = GenericFacetSpec<UnitSpec>;\n\nexport interface GenericRepeatSpec<U extends GenericUnitSpec<any, any>> extends BaseSpec {\n  repeat: Repeat;\n\n  // TODO: add GenericFacetSpec<U>\n  spec: GenericRepeatSpec<U> | GenericLayerSpec<U> | U;\n}\n\nexport type RepeatSpec = GenericRepeatSpec<UnitSpec>;\n\nexport interface GenericConcatSpec<U extends GenericUnitSpec<any, any>> extends BaseSpec {\n  // TODO: add GenericFacetSpec<U> | GenericRepeatSpec<U> | GenericfacetSpec<U>\n  // TODO: hconcat\n  vconcat: (GenericLayerSpec<U> | U)[];\n}\n\nexport type ConcatSpec = GenericConcatSpec<UnitSpec>;\n\nexport type GenericSpec<U extends GenericUnitSpec<any, any>> = U | GenericLayerSpec<U> | GenericFacetSpec<U> | GenericRepeatSpec<U> | GenericConcatSpec<U>;\n\nexport type Spec = GenericSpec<UnitSpec>;\n\nexport type TopLevelExtendedSpec = TopLevel<FacetedCompositeUnitSpec> | TopLevel<GenericLayerSpec<CompositeUnitSpec>> | TopLevel<GenericFacetSpec<CompositeUnitSpec>> | TopLevel<GenericRepeatSpec<CompositeUnitSpec>> | TopLevel<GenericConcatSpec<CompositeUnitSpec>>;\n\n/* Custom type guards */\n\n\nexport function isFacetSpec(spec: GenericSpec<GenericUnitSpec<any, any>>): spec is GenericFacetSpec<GenericUnitSpec<any, any>> {\n  return spec['facet'] !== undefined;\n}\n\nexport function isUnitSpec(spec: GenericSpec<GenericUnitSpec<any, any>>): spec is FacetedCompositeUnitSpec | UnitSpec {\n  return !!spec['mark'];\n}\n\nexport function isLayerSpec(spec: GenericSpec<GenericUnitSpec<any, any>>): spec is GenericLayerSpec<GenericUnitSpec<any, any>> {\n  return spec['layer'] !== undefined;\n}\n\nexport function isRepeatSpec(spec: GenericSpec<GenericUnitSpec<any, any>>): spec is GenericRepeatSpec<GenericUnitSpec<any, any>> {\n  return spec['repeat'] !== undefined;\n}\n\nexport function isConcatSpec(spec: GenericSpec<GenericUnitSpec<any, any>>): spec is GenericConcatSpec<GenericUnitSpec<any, any>> {\n  return spec['vconcat'] !== undefined;\n}\n\n/**\n * Decompose extended unit specs into composition of pure unit specs.\n */\n// TODO: consider moving this to another file.  Maybe vl.spec.normalize or vl.normalize\nexport function normalize(spec: TopLevelExtendedSpec, config: Config): Spec {\n  if (isFacetSpec(spec)) {\n    return normalizeFacet(spec, config);\n  }\n  if (isLayerSpec(spec)) {\n    return normalizeLayer(spec, config);\n  }\n  if (isRepeatSpec(spec)) {\n    return normalizeRepeat(spec, spec.config);\n  }\n  if (isConcatSpec(spec)) {\n    return normalizeConcat(spec, spec.config);\n  }\n  if (isUnitSpec(spec)) {\n    const hasRow = channelHasField(spec.encoding, ROW);\n    const hasColumn = channelHasField(spec.encoding, COLUMN);\n\n    if (hasRow || hasColumn) {\n      return normalizeFacetedUnit(spec, config);\n    }\n    return normalizeNonFacetUnit(spec, config);\n  }\n  throw new Error(log.message.INVALID_SPEC);\n}\n\nfunction normalizeNonFacet(spec: GenericLayerSpec<CompositeUnitSpec> | CompositeUnitSpec, config: Config) {\n  if (isLayerSpec(spec)) {\n    return normalizeLayer(spec, config);\n  }\n  return normalizeNonFacetUnit(spec, config);\n}\n\n\nfunction normalizeNonFacetWithRepeat(spec: GenericLayerSpec<CompositeUnitSpec> | GenericRepeatSpec<CompositeUnitSpec> | CompositeUnitSpec, config: Config) {\n  if (isLayerSpec(spec)) {\n    return normalizeLayer(spec, config);\n  }\n  if (isRepeatSpec(spec)) {\n    return normalizeRepeat(spec, config);\n  }\n  return normalizeNonFacetUnit(spec, config);\n}\n\n\nfunction normalizeFacet(spec: GenericFacetSpec<CompositeUnitSpec>, config: Config): FacetSpec {\n  const {spec: subspec, ...rest} = spec;\n  return {\n    ...rest,\n    spec: normalizeNonFacet(subspec, config)\n  };\n}\n\nfunction normalizeLayer(spec: GenericLayerSpec<CompositeUnitSpec>, config: Config): LayerSpec {\n  const {layer: layer, ...rest} = spec;\n  return {\n    ...rest,\n    layer: layer.map((subspec) => normalizeNonFacet(subspec, config))\n  };\n}\n\nfunction normalizeRepeat(spec: GenericRepeatSpec<CompositeUnitSpec>, config: Config): RepeatSpec {\n  const {spec: subspec, ...rest} = spec;\n  return {\n    ...rest,\n    spec: normalizeNonFacetWithRepeat(subspec, config)\n  };\n}\n\nfunction normalizeConcat(spec: GenericConcatSpec<CompositeUnitSpec>, config: Config): ConcatSpec {\n  const {vconcat: vconcat, ...rest} = spec;\n  return {\n    ...rest,\n    vconcat: vconcat.map((subspec) => normalizeNonFacet(subspec, config))\n  };\n}\n\nfunction normalizeFacetedUnit(spec: FacetedCompositeUnitSpec, config: Config): FacetSpec {\n  // New encoding in the inside spec should not contain row / column\n  // as row/column should be moved to facet\n  const {row: row, column: column, ...encoding} = spec.encoding;\n\n  // Mark and encoding should be moved into the inner spec\n  const {mark: mark, selection: selection, encoding: _, ...outerSpec} = spec;\n\n  return {\n    ...outerSpec,\n    facet: {\n      ...(row ? {row} : {}),\n      ...(column ? {column}: {}),\n    },\n    spec: normalizeNonFacetUnit({\n      mark,\n      encoding,\n      ...(selection ? {selection} : {})\n    }, config)\n  };\n}\n\nfunction isNonFacetUnitSpecWithPrimitiveMark(spec: GenericUnitSpec<string | MarkDef, Encoding<Field>>):\n  spec is GenericUnitSpec<Mark, Encoding<Field>> {\n    return isPrimitiveMark(spec.mark);\n}\n\nfunction normalizeNonFacetUnit(spec: GenericUnitSpec<string | MarkDef, Encoding<Field>>, config: Config) {\n  if (isNonFacetUnitSpecWithPrimitiveMark(spec)) {\n    // TODO: thoroughly test\n    if (isRanged(spec.encoding)) {\n      return normalizeRangedUnit(spec);\n    }\n\n    const overlayConfig = config && config.overlay;\n    const overlayWithLine = overlayConfig  && spec.mark === AREA &&\n      contains(['linepoint', 'line'], overlayConfig.area);\n    const overlayWithPoint = overlayConfig && (\n      (overlayConfig.line && spec.mark === LINE) ||\n      (overlayConfig.area === 'linepoint' && spec.mark === AREA)\n    );\n    // TODO: consider moving this to become another case of compositeMark\n    if (overlayWithPoint || overlayWithLine) {\n      return normalizeOverlay(spec, overlayWithPoint, overlayWithLine, config);\n    }\n\n    return spec; // Nothing to normalize\n  } else {\n    return compositeMark.normalize(spec, config);\n  }\n}\n\nfunction normalizeRangedUnit(spec: UnitSpec) {\n  const hasX = channelHasField(spec.encoding, X);\n  const hasY = channelHasField(spec.encoding, Y);\n  const hasX2 = channelHasField(spec.encoding, X2);\n  const hasY2 = channelHasField(spec.encoding, Y2);\n  if ((hasX2 && !hasX) || (hasY2 && !hasY)) {\n    const normalizedSpec = duplicate(spec);\n    if (hasX2 && !hasX) {\n      normalizedSpec.encoding.x = normalizedSpec.encoding.x2;\n      delete normalizedSpec.encoding.x2;\n    }\n    if (hasY2 && !hasY) {\n      normalizedSpec.encoding.y = normalizedSpec.encoding.y2;\n      delete normalizedSpec.encoding.y2;\n    }\n\n    return normalizedSpec;\n  }\n  return spec;\n}\n\n\n// FIXME(#1804): re-design this\nfunction normalizeOverlay(spec: UnitSpec, overlayWithPoint: boolean, overlayWithLine: boolean, config: Config): LayerSpec {\n  const {mark, encoding, ...outerSpec} = spec;\n  const layer = [{mark, encoding}];\n\n  // Need to copy stack config to overlayed layer\n  const stackProps = stack(mark, encoding, config ? config.stack : undefined);\n\n  let overlayEncoding = encoding;\n  if (stackProps) {\n    const {fieldChannel: stackFieldChannel, offset} = stackProps;\n    overlayEncoding = {\n      ...encoding,\n      [stackFieldChannel]: {\n        ...encoding[stackFieldChannel],\n        ...(offset ? {stack: offset} : {})\n      }\n    };\n  }\n\n  if (overlayWithLine) {\n    layer.push({\n      mark: {\n        type: 'line',\n        role: 'lineOverlay'\n      },\n      encoding: overlayEncoding\n    });\n  }\n  if (overlayWithPoint) {\n    layer.push({\n      mark: {\n        type: 'point',\n        filled: true,\n        role: 'pointOverlay'\n      },\n      encoding: overlayEncoding\n    });\n  }\n\n  return {\n    ...outerSpec,\n    layer\n  };\n}\n\n// TODO: add vl.spec.validate & move stuff from vl.validate to here\n\n/* Accumulate non-duplicate fieldDefs in a dictionary */\nfunction accumulate(dict: any, fieldDefs: FieldDef<Field>[]): any {\n  fieldDefs.forEach(function(fieldDef) {\n    // Consider only pure fieldDef properties (ignoring scale, axis, legend)\n    const pureFieldDef = ['field', 'type', 'value', 'timeUnit', 'bin', 'aggregate'].reduce((f, key) => {\n      if (fieldDef[key] !== undefined) {\n        f[key] = fieldDef[key];\n      }\n      return f;\n    }, {});\n    const key = hash(pureFieldDef);\n    dict[key] = dict[key] || fieldDef;\n  });\n  return dict;\n}\n\n/* Recursively get fieldDefs from a spec, returns a dictionary of fieldDefs */\nfunction fieldDefIndex(spec: GenericSpec<GenericUnitSpec<any, any>>, dict: any = {}): any {\n  // TODO: Support repeat and concat\n  if (isLayerSpec(spec)) {\n    spec.layer.forEach(layer => {\n      if (isUnitSpec(layer)) {\n        accumulate(dict, vlEncoding.fieldDefs(layer.encoding));\n      } else {\n        fieldDefIndex(layer, dict);\n      }\n    });\n  } else if (isFacetSpec(spec)) {\n    accumulate(dict, vlEncoding.fieldDefs(spec.facet));\n    fieldDefIndex(spec.spec, dict);\n  } else if (isRepeatSpec(spec)) {\n    accumulate(dict, vlEncoding.fieldDefs(spec.spec));\n    fieldDefIndex(spec.spec, dict);\n  } else if (isConcatSpec(spec)) {\n    spec.vconcat.forEach(child => {\n      if (isUnitSpec(child)) {\n        accumulate(dict, vlEncoding.fieldDefs(child.encoding));\n      } else {\n        fieldDefIndex(child, dict);\n      }\n    });\n  } else { // Unit Spec\n    accumulate(dict, vlEncoding.fieldDefs(spec.encoding));\n  }\n  return dict;\n}\n\n/* Returns all non-duplicate fieldDefs in a spec in a flat array */\nexport function fieldDefs(spec: GenericSpec<GenericUnitSpec<any, any>>): FieldDef<Field>[] {\n  return vals(fieldDefIndex(spec));\n}\n\nexport function isStacked(spec: TopLevel<FacetedCompositeUnitSpec>, config?: Config): boolean {\n  config = config || spec.config;\n  if (isPrimitiveMark(spec.mark)) {\n    return stack(spec.mark, spec.encoding,\n            config ? config.stack : undefined\n          ) !== null;\n  }\n  return false;\n}\n","import * as log from './log';\n\nimport {SUM_OPS} from './aggregate';\nimport {Channel, STACK_GROUP_CHANNELS, X, X2, Y, Y2} from './channel';\nimport {channelHasField, Encoding, isAggregate} from './encoding';\nimport {Field, FieldDef, isFieldDef, PositionFieldDef} from './fielddef';\nimport {AREA, BAR, CIRCLE, isMarkDef, LINE, Mark, MarkDef, POINT, RULE, SQUARE, TEXT, TICK} from './mark';\nimport {ScaleType} from './scale';\nimport {contains, isArray} from './util';\n\nexport type StackOffset = 'zero' | 'center' | 'normalize' | 'none';\n\nexport interface StackProperties {\n  /** Dimension axis of the stack. */\n  groupbyChannel: 'x' | 'y';\n\n  /** Measure axis of the stack. */\n  fieldChannel: 'x' | 'y';\n\n  /** Stack-by fields e.g., color, detail */\n  stackBy: {\n    fieldDef: FieldDef<string>,\n    channel: Channel\n  }[];\n\n  /**\n   * Modes for stacking marks:\n   * - `zero`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](mark.html#stacked-bar-chart) and [area](mark.html#stacked-area-chart) chart).\n   * - `normalize` - stacking with normalized domain (for creating normalized stacked [bar](mark.html#normalized-stacked-bar-chart) and [area](mark.html#normalized-stacked-area-chart) chart). <br/>\n   * -`center` - stacking with center baseline (for [streamgraph](mark.html#streamgraph)).\n   * - `none` - No-stacking. This will produce layered [bar](mark.html#layered-bar-chart) and area chart.\n   *\n   * __Default value:__ `zero` for plots with all of the following conditions: (1) `bar` or `area` marks (2) `color`, `opacity`, `size`, or `detail` channel mapped to a group-by field (3) One ordinal or nominal axis, and (4) one quantitative axis with linear scale and summative aggregation function (e.g., `sum`, `count`).\n   */\n  offset: StackOffset;\n}\n\nexport const STACKABLE_MARKS = [BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK];\nexport const STACK_BY_DEFAULT_MARKS = [BAR, AREA];\n\n// Note: CompassQL uses this method and only pass in required properties of each argument object.\n// If required properties change, make sure to update CompassQL.\n\nexport function stack(m: Mark | MarkDef, encoding: Encoding<Field>, stackConfig: StackOffset): StackProperties {\n  const mark = isMarkDef(m) ? m.type : m;\n  // Should have stackable mark\n  if (!contains(STACKABLE_MARKS, mark)) {\n    return null;\n  }\n\n  // Should be aggregate plot\n  if (!isAggregate(encoding)) {\n    return null;\n  }\n\n  // Should have grouping level of detail\n  const stackBy = STACK_GROUP_CHANNELS.reduce((sc, channel) => {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      (isArray(channelDef) ? channelDef : [channelDef]).forEach((fieldDef) => {\n        if (isFieldDef(fieldDef) && !fieldDef.aggregate) {\n          sc.push({\n            channel: channel,\n            fieldDef: fieldDef\n          });\n        }\n      });\n    }\n    return sc;\n  }, []);\n\n  if (stackBy.length === 0) {\n    return null;\n  }\n\n  // Has only one aggregate axis\n  const hasXField = isFieldDef(encoding.x);\n  const hasYField = isFieldDef(encoding.y);\n  const xIsAggregate = isFieldDef(encoding.x) && !!encoding.x.aggregate;\n  const yIsAggregate = isFieldDef(encoding.y) && !!encoding.y.aggregate;\n\n  if (xIsAggregate !== yIsAggregate) {\n    const fieldChannel = xIsAggregate ? X : Y;\n    const fieldDef = encoding[fieldChannel] as PositionFieldDef<string>;\n    const fieldChannelAggregate = fieldDef.aggregate;\n    const fieldChannelScale = fieldDef.scale;\n\n    let stackOffset: StackOffset = null;\n    if (fieldDef.stack !== undefined) {\n      stackOffset = fieldDef.stack;\n    } else if (contains(STACK_BY_DEFAULT_MARKS, mark)) {\n      // Bar and Area with sum ops are automatically stacked by default\n      stackOffset = stackConfig === undefined ? 'zero' : stackConfig;\n    } else {\n      stackOffset = stackConfig;\n    }\n\n    if (!stackOffset || stackOffset === 'none') {\n      return null;\n    }\n\n    // If stacked, check if it qualifies for stacking (and log warning if not qualified.)\n    if (fieldChannelScale && fieldChannelScale.type && fieldChannelScale.type !== ScaleType.LINEAR) {\n      log.warn(log.message.cannotStackNonLinearScale(fieldChannelScale.type));\n      return null;\n    }\n\n    if (channelHasField(encoding, fieldChannel === X ? X2 : Y2)) {\n      log.warn(log.message.cannotStackRangedMark(fieldChannel));\n      return null;\n    }\n\n    if (!contains(SUM_OPS, fieldChannelAggregate)) {\n      log.warn(log.message.cannotStackNonSummativeAggregate(fieldChannelAggregate));\n      return null;\n    }\n\n    return {\n      groupbyChannel: xIsAggregate ? (hasYField ? Y : null) : (hasXField ? X : null),\n      fieldChannel: fieldChannel,\n      stackBy: stackBy,\n      offset: stackOffset\n    };\n  }\n  return null;\n}\n","import {DateTimeExpr, dateTimeExpr} from './datetime';\nimport * as log from './log';\nimport {Dict, keys} from './util';\n\nexport namespace TimeUnit {\n  export const YEAR: 'year' = 'year';\n  export const MONTH: 'month' = 'month';\n  export const DAY: 'day' = 'day';\n  export const DATE: 'date' = 'date';\n  export const HOURS: 'hours' = 'hours';\n  export const MINUTES: 'minutes' = 'minutes';\n  export const SECONDS: 'seconds' = 'seconds';\n  export const MILLISECONDS: 'milliseconds' = 'milliseconds';\n  export const YEARMONTH: 'yearmonth' = 'yearmonth';\n  export const YEARMONTHDATE: 'yearmonthdate' = 'yearmonthdate';\n  export const YEARMONTHDATEHOURS: 'yearmonthdatehours' = 'yearmonthdatehours';\n  export const YEARMONTHDATEHOURSMINUTES: 'yearmonthdatehoursminutes' = 'yearmonthdatehoursminutes';\n  export const YEARMONTHDATEHOURSMINUTESSECONDS: 'yearmonthdatehoursminutesseconds' = 'yearmonthdatehoursminutesseconds';\n\n  // MONTHDATE always include 29 February since we use year 0th (which is a leap year);\n  export const MONTHDATE: 'monthdate' = 'monthdate';\n  export const HOURSMINUTES: 'hoursminutes' = 'hoursminutes';\n  export const HOURSMINUTESSECONDS: 'hoursminutesseconds' = 'hoursminutesseconds';\n  export const MINUTESSECONDS: 'minutesseconds' = 'minutesseconds';\n  export const SECONDSMILLISECONDS: 'secondsmilliseconds' = 'secondsmilliseconds';\n  export const QUARTER: 'quarter' = 'quarter';\n  export const YEARQUARTER: 'yearquarter' = 'yearquarter';\n  export const QUARTERMONTH: 'quartermonth' = 'quartermonth';\n  export const YEARQUARTERMONTH: 'yearquartermonth' = 'yearquartermonth';\n}\n\nexport type TimeUnit = typeof TimeUnit.YEAR | typeof TimeUnit.MONTH | typeof TimeUnit.DAY | typeof TimeUnit.DATE | typeof TimeUnit.HOURS\n  | typeof TimeUnit.MINUTES | typeof TimeUnit.SECONDS | typeof TimeUnit.MILLISECONDS | typeof TimeUnit.YEARMONTH\n  | typeof TimeUnit.YEARMONTHDATE | typeof TimeUnit.YEARMONTHDATEHOURS | typeof TimeUnit.YEARMONTHDATEHOURSMINUTES\n  | typeof TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS | typeof TimeUnit.MONTHDATE | typeof TimeUnit.HOURSMINUTES\n  | typeof TimeUnit.HOURSMINUTESSECONDS | typeof TimeUnit.MINUTESSECONDS | typeof TimeUnit.SECONDSMILLISECONDS\n  | typeof TimeUnit.QUARTER | typeof TimeUnit.YEARQUARTER | typeof TimeUnit.QUARTERMONTH | typeof TimeUnit.YEARQUARTERMONTH;\n\n/** Time Unit that only corresponds to only one part of Date objects. */\nexport const SINGLE_TIMEUNITS = [\n  TimeUnit.YEAR,\n  TimeUnit.QUARTER,\n  TimeUnit.MONTH,\n  TimeUnit.DAY,\n  TimeUnit.DATE,\n  TimeUnit.HOURS,\n  TimeUnit.MINUTES,\n  TimeUnit.SECONDS,\n  TimeUnit.MILLISECONDS,\n];\n\nconst SINGLE_TIMEUNIT_INDEX: Dict<boolean> = SINGLE_TIMEUNITS.reduce((d, timeUnit) => {\n  d[timeUnit] = true;\n  return d;\n}, {});\n\nexport function isSingleTimeUnit(timeUnit: TimeUnit) {\n  return !!SINGLE_TIMEUNIT_INDEX[timeUnit];\n}\n\n/**\n * Converts a date to only have the measurements relevant to the specified unit\n * i.e. ('yearmonth', '2000-12-04 07:58:14') -> '2000-12-01 00:00:00'\n * Note: the base date is Jan 01 1900 00:00:00\n */\nexport function convert(unit: TimeUnit, date: Date): Date {\n  const result: Date = new Date(0, 0, 1, 0, 0, 0, 0); // start with uniform date\n  SINGLE_TIMEUNITS.forEach(function(singleUnit) {\n    if (containsTimeUnit(unit, singleUnit)) {\n      switch (singleUnit) {\n        case TimeUnit.DAY:\n          throw new Error('Cannot convert to TimeUnits containing \\'day\\'');\n        case TimeUnit.YEAR:\n          result.setFullYear(date.getFullYear());\n          break;\n        case TimeUnit.QUARTER:\n          // indicate quarter by setting month to be the first of the quarter i.e. may (4) -> april (3)\n          result.setMonth((Math.floor(date.getMonth() / 3)) * 3);\n          break;\n        case TimeUnit.MONTH:\n          result.setMonth(date.getMonth());\n          break;\n        case TimeUnit.DATE:\n          result.setDate(date.getDate());\n          break;\n        case TimeUnit.HOURS:\n          result.setHours(date.getHours());\n          break;\n        case TimeUnit.MINUTES:\n          result.setMinutes(date.getMinutes());\n          break;\n        case TimeUnit.SECONDS:\n          result.setSeconds(date.getSeconds());\n          break;\n        case TimeUnit.MILLISECONDS:\n          result.setMilliseconds(date.getMilliseconds());\n          break;\n      }\n    }\n  });\n\n  return result;\n}\n\nexport const MULTI_TIMEUNITS = [\n  TimeUnit.YEARQUARTER,\n  TimeUnit.YEARQUARTERMONTH,\n  TimeUnit.YEARMONTH,\n  TimeUnit.YEARMONTHDATE,\n  TimeUnit.YEARMONTHDATEHOURS,\n  TimeUnit.YEARMONTHDATEHOURSMINUTES,\n  TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS,\n  TimeUnit.QUARTERMONTH,\n  TimeUnit.HOURSMINUTES,\n  TimeUnit.HOURSMINUTESSECONDS,\n  TimeUnit.MINUTESSECONDS,\n  TimeUnit.SECONDSMILLISECONDS,\n];\n\nconst MULTI_TIMEUNIT_INDEX: Dict<boolean> = MULTI_TIMEUNITS.reduce((d, timeUnit) => {\n  d[timeUnit] = true;\n  return d;\n}, {});\n\nexport function isMultiTimeUnit(timeUnit: TimeUnit) {\n  return !!MULTI_TIMEUNIT_INDEX[timeUnit];\n}\n\nexport const TIMEUNITS = [\n  TimeUnit.YEAR,\n  TimeUnit.QUARTER,\n  TimeUnit.MONTH,\n  TimeUnit.DAY,\n  TimeUnit.DATE,\n  TimeUnit.HOURS,\n  TimeUnit.MINUTES,\n  TimeUnit.SECONDS,\n  TimeUnit.MILLISECONDS,\n  TimeUnit.YEARQUARTER,\n  TimeUnit.YEARQUARTERMONTH,\n  TimeUnit.YEARMONTH,\n  TimeUnit.YEARMONTHDATE,\n  TimeUnit.YEARMONTHDATEHOURS,\n  TimeUnit.YEARMONTHDATEHOURSMINUTES,\n  TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS,\n  TimeUnit.QUARTERMONTH,\n  TimeUnit.HOURSMINUTES,\n  TimeUnit.HOURSMINUTESSECONDS,\n  TimeUnit.MINUTESSECONDS,\n  TimeUnit.SECONDSMILLISECONDS\n];\n\n/** Returns true if fullTimeUnit contains the timeUnit, false otherwise. */\nexport function containsTimeUnit(fullTimeUnit: TimeUnit, timeUnit: TimeUnit) {\n  const index = fullTimeUnit.indexOf(timeUnit);\n  return index > -1 &&\n    (\n      timeUnit !== TimeUnit.SECONDS ||\n      index === 0 ||\n      fullTimeUnit.charAt(index-1) !== 'i' // exclude milliseconds\n    );\n}\n\n/**\n * Returns Vega expresssion for a given timeUnit and fieldRef\n */\nexport function fieldExpr(fullTimeUnit: TimeUnit, field: string): string {\n  const fieldRef =  `datum[\"${field}\"]`;\n\n  function func(timeUnit: TimeUnit) {\n    if (timeUnit === TimeUnit.QUARTER) {\n      // quarter starting at 0 (0,3,6,9).\n      return `(quarter(${fieldRef})-1)`;\n    } else {\n      return `${timeUnit}(${fieldRef})`;\n    }\n  }\n\n  const d = SINGLE_TIMEUNITS.reduce((_d: DateTimeExpr, tu: TimeUnit) => {\n    if (containsTimeUnit(fullTimeUnit, tu)) {\n      _d[tu] = func(tu);\n    }\n    return _d;\n  }, {});\n\n  if (d.day && keys(d).length > 1) {\n    log.warn(log.message.dayReplacedWithDate(fullTimeUnit));\n    delete d.day;\n    d.date = func(TimeUnit.DATE);\n  }\n\n  return dateTimeExpr(d);\n}\n\n/** returns the smallest nice unit for scale.nice */\nexport function smallestUnit(timeUnit: TimeUnit): string {\n  if (!timeUnit) {\n    return undefined;\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {\n    return 'second';\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {\n    return 'minute';\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {\n    return 'hour';\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.DAY) ||\n      containsTimeUnit(timeUnit, TimeUnit.DATE)) {\n    return 'day';\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {\n    return 'month';\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.YEAR)) {\n    return 'year';\n  }\n  return undefined;\n}\n\n/** returns the signal expression used for axis labels for a time unit */\nexport function formatExpression(timeUnit: TimeUnit, field: string, shortTimeLabels: boolean): string {\n  if (!timeUnit) {\n    return undefined;\n  }\n\n  const dateComponents: string[] = [];\n  let expression = '';\n  const hasYear = containsTimeUnit(timeUnit, TimeUnit.YEAR);\n\n  if (containsTimeUnit(timeUnit, TimeUnit.QUARTER)) {\n   // special expression for quarter as prefix\n    expression = `'Q' + quarter(${field})`;\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {\n    // By default use short month name\n    dateComponents.push(shortTimeLabels !== false ? '%b' : '%B');\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.DAY)) {\n    dateComponents.push(shortTimeLabels ? '%a' : '%A');\n  } else if (containsTimeUnit(timeUnit, TimeUnit.DATE)) {\n    dateComponents.push('%d' + (hasYear ? ',' : '')); // add comma if there is year\n  }\n\n  if (hasYear) {\n    dateComponents.push(shortTimeLabels ? '%y' : '%Y');\n  }\n\n  const timeComponents: string[] = [];\n\n  if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {\n    timeComponents.push('%H');\n  }\n  if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {\n    timeComponents.push('%M');\n  }\n  if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {\n    timeComponents.push('%S');\n  }\n  if (containsTimeUnit(timeUnit, TimeUnit.MILLISECONDS)) {\n    timeComponents.push('%L');\n  }\n\n  const dateTimeComponents: string[] = [];\n  if (dateComponents.length > 0) {\n    dateTimeComponents.push(dateComponents.join(' '));\n  }\n  if (timeComponents.length > 0) {\n    dateTimeComponents.push(timeComponents.join(':'));\n  }\n\n  if (dateTimeComponents.length > 0) {\n    if (expression) {\n      // Add space between quarter and main time format\n      expression += ` + ' ' + `;\n    }\n    expression += `timeFormat(${field}, '${dateTimeComponents.join(' ')}')`;\n  }\n\n  // If expression is still an empty string, return undefined instead.\n  return expression || undefined;\n}\n\nexport function isDiscreteByDefault(timeUnit: TimeUnit) {\n  switch (timeUnit) {\n    // These time unit use discrete scale by default\n    case 'hours':\n    case 'day':\n    case 'month':\n    case 'quarter':\n      return true;\n  }\n  return false;\n}\n","\nexport type Padding = number | {top?: number, bottom?: number, left?: number, right?: number};\nexport interface TopLevelProperties {\n  // Current we don't support autosize yet.  Once we do, we have to modify compile.ts to fix this.\n  // autosize?: ...;\n\n  /**\n   * CSS color property to use as the background of visualization.\n   *\n   * __Default value:__ none (transparent)\n   */\n  background?: string;\n\n  /**\n   * The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle. This can be a single number or an object with `\"top\"`, `\"left\"`, `\"right\"`, `\"bottom\"` properties.\n   *\n   * __Default value__: `5`\n   *\n   * @minimum 0\n   */\n  padding?: Padding;\n}\n\nconst TOP_LEVEL_PROPERTIES: (keyof TopLevelProperties)[] = [\n  'background', 'padding'\n];\n\nexport function extractTopLevelProperties<T extends TopLevelProperties>(t: T) {\n  return TOP_LEVEL_PROPERTIES.reduce((o, p) => {\n    if (t && t[p] !== undefined) {\n      o[p] = t[p];\n    }\n    return o;\n  }, {});\n}\n","import {Filter} from './filter';\n\nexport interface FilterTransform {\n  /**\n   * A string containing the filter Vega expression. Use `datum` to refer to the current data object.\n   */\n  filter: Filter | Filter[];\n}\n\nexport function isFilter(t: Transform): t is FilterTransform {\n  return t['filter'] !== undefined;\n}\n\nexport interface CalculateTransform {\n  /**\n   * A string containing a Vega Expression. Use the variable `datum` to refer to the current data object.\n   */\n  calculate: string;\n  /**\n   * The field for storing the computed formula value.\n   */\n  as: string;\n}\n\nexport function isCalculate(t: Transform): t is CalculateTransform {\n  return t['calculate'] !== undefined;\n}\n\nexport type Transform = FilterTransform | CalculateTransform;\n","/** Constants and utilities for data type */\n/** Data type based on level of measurement */\n\nexport namespace Type {\n  export const QUANTITATIVE: 'quantitative' = 'quantitative';\n  export const ORDINAL: 'ordinal' = 'ordinal';\n  export const TEMPORAL: 'temporal' = 'temporal';\n  export const NOMINAL: 'nominal' = 'nominal';\n}\nexport type Type = typeof Type.QUANTITATIVE | typeof Type.ORDINAL | typeof Type.TEMPORAL | typeof Type.NOMINAL;\n\nexport const QUANTITATIVE = Type.QUANTITATIVE;\nexport const ORDINAL = Type.ORDINAL;\nexport const TEMPORAL = Type.TEMPORAL;\nexport const NOMINAL = Type.NOMINAL;\n\n/**\n * Get full, lowercase type name for a given type.\n * @param  type\n * @return Full type name.\n */\nexport function getFullName(type: Type|string): Type {\n  if (type) {\n    type = type.toLowerCase();\n    switch (type) {\n      case 'q':\n      case QUANTITATIVE:\n        return 'quantitative';\n      case 't':\n      case TEMPORAL:\n        return 'temporal';\n      case 'o':\n      case ORDINAL:\n        return 'ordinal';\n      case 'n':\n      case NOMINAL:\n        return 'nominal';\n    }\n  }\n  // If we get invalid input, return undefined type.\n  return undefined;\n}\n","import * as stringify from 'json-stable-stringify';\nexport {extend, isArray, isObject, isNumber, isString, truncate, toSet, stringValue} from 'vega-util';\nimport {isArray, isNumber, isString} from 'vega-util';\n\n/**\n * Creates an object composed of the picked object properties.\n *\n * Example:  (from lodash)\n *\n * var object = {'a': 1, 'b': '2', 'c': 3};\n * pick(object, ['a', 'c']);\n * //  {'a': 1, 'c': 3}\n *\n */\nexport function pick(obj: any, props: string[]) {\n  const copy = {};\n  props.forEach((prop) => {\n    if (obj.hasOwnProperty(prop)) {\n      copy[prop] = obj[prop];\n    }\n  });\n  return copy;\n}\n\n/**\n * The opposite of _.pick; this method creates an object composed of the own\n * and inherited enumerable string keyed properties of object that are not omitted.\n */\nexport function omit(obj: any, props: string[]) {\n  const copy = duplicate(obj);\n  props.forEach((prop) => {\n    delete copy[prop];\n  });\n  return copy;\n}\n\nexport function hash(a: any) {\n  if (isString(a) || isNumber(a) || isBoolean(a)) {\n    return String(a);\n  }\n  return stringify(a);\n}\n\nexport function contains<T>(array: T[], item: T) {\n  return array.indexOf(item) > -1;\n}\n\n/** Returns the array without the elements in item */\nexport function without<T>(array: T[], excludedItems: T[]) {\n  return array.filter(item => !contains(excludedItems, item));\n}\n\nexport function union<T>(array: T[], other: T[]) {\n  return array.concat(without(other, array));\n}\n\n/**\n * Returns true if any item returns true.\n */\nexport function some<T>(arr: T[], f: (d: T, k?: any, i?: any) => boolean) {\n  let i = 0;\n  for (let k = 0; k<arr.length; k++) {\n    if (f(arr[k], k, i++)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Returns true if all items return true.\n */\n export function every<T>(arr: T[], f: (d: T, k?: any, i?: any) => boolean) {\n  let i = 0;\n  for (let k = 0; k<arr.length; k++) {\n    if (!f(arr[k], k, i++)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function flatten(arrays: any[]) {\n  return [].concat.apply([], arrays);\n}\n\n/**\n * recursively merges src into dest\n */\nexport function mergeDeep(dest: any, ...src: any[]) {\n  for (const s of src) {\n    dest = deepMerge_(dest, s);\n  }\n  return dest;\n}\n\n// recursively merges src into dest\nfunction deepMerge_(dest: any, src: any) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (const p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || isArray(src[p]) || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = mergeDeep(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      mergeDeep(dest[p], src[p]);\n    }\n  }\n  return dest;\n}\n\nexport function unique<T>(values: T[], f: (item: T) => string): T[] {\n  const results: any[] = [];\n  const u = {};\n  let v: string;\n  for (const val of values) {\n    v = f(val);\n    if (v in u) {\n      continue;\n    }\n    u[v] = 1;\n    results.push(val);\n  }\n  return results;\n}\n\nexport interface Dict<T> {\n  [key: string]: T;\n}\n\nexport type StringSet = Dict<boolean>;\n\n/**\n * Returns true if the two dictionaries disagree. Applies only to defined values.\n */\nexport function differ<T>(dict: Dict<T>, other: Dict<T>) {\n  for (const key in dict) {\n    if (dict.hasOwnProperty(key)) {\n      if (other[key] && dict[key] && other[key] !== dict[key]) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport function hasIntersection(a: StringSet, b: StringSet) {\n  for (const key in a) {\n    if (key in b) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function differArray<T>(array: T[], other: T[]) {\n  if (array.length !== other.length) {\n    return true;\n  }\n\n  array.sort();\n  other.sort();\n\n  for (let i = 0; i < array.length; i++) {\n    if (other[i] !== array[i]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport const keys = Object.keys;\n\nexport function vals<T>(x: {[key: string]: T}): T[] {\n  const _vals: T[] = [];\n  for (const k in x) {\n    if (x.hasOwnProperty(k)) {\n      _vals.push(x[k]);\n    }\n  }\n  return _vals;\n}\n\nexport function duplicate<T>(obj: T): T {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nexport function isBoolean(b: any): b is boolean {\n  return b === true || b === false;\n}\n\n/**\n * Convert a string into a valid variable name\n */\nexport function varName(s: string): string {\n  // Replace non-alphanumeric characters (anything besides a-zA-Z0-9_) with _\n  const alphanumericS = s.replace(/\\W/g, '_');\n\n  // Add _ if the string has leading numbers.\n  return (s.match(/^\\d+/) ? '_' : '') + alphanumericS;\n}\n","import {isMarkDef} from './mark';\nimport {FacetedCompositeUnitSpec} from './spec';\n\n// TODO: move to vl.spec.validator?\n\nimport {BAR} from './mark';\nimport {toSet} from './util';\n\nexport interface RequiredChannelMap {\n  [mark: string]: Array<string>;\n}\n\n/**\n * Required Encoding Channels for each mark type\n * @type {Object}\n */\nexport const DEFAULT_REQUIRED_CHANNEL_MAP: RequiredChannelMap = {\n  text: ['text'],\n  line: ['x', 'y'],\n  area: ['x', 'y']\n};\n\nexport interface SupportedChannelMap {\n  [mark: string]: {\n    [channel: string]: number\n  };\n}\n\n/**\n * Supported Encoding Channel for each mark type\n */\nexport const DEFAULT_SUPPORTED_CHANNEL_TYPE: SupportedChannelMap = {\n  bar: toSet(['row', 'column', 'x', 'y', 'size', 'color', 'detail']),\n  line: toSet(['row', 'column', 'x', 'y', 'color', 'detail']), // TODO: add size when Vega supports\n  area: toSet(['row', 'column', 'x', 'y', 'color', 'detail']),\n  tick: toSet(['row', 'column', 'x', 'y', 'color', 'detail']),\n  circle: toSet(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),\n  square: toSet(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),\n  point: toSet(['row', 'column', 'x', 'y', 'color', 'size', 'detail', 'shape']),\n  text: toSet(['row', 'column', 'size', 'color', 'text']) // TODO(#724) revise\n};\n\n// TODO: consider if we should add validate method and\n// requires ZSchema in the main vega-lite repo\n\n/**\n * Further check if encoding mapping of a spec is invalid and\n * return error if it is invalid.\n *\n * This checks if\n * (1) all the required encoding channels for the mark type are specified\n * (2) all the specified encoding channels are supported by the mark type\n * @param  {[type]} spec [description]\n * @param  {RequiredChannelMap  = DefaultRequiredChannelMap}  requiredChannelMap\n * @param  {SupportedChannelMap = DefaultSupportedChannelMap} supportedChannelMap\n * @return {String} Return one reason why the encoding is invalid,\n *                  or null if the encoding is valid.\n */\nexport function getEncodingMappingError(spec: FacetedCompositeUnitSpec,\n  requiredChannelMap: RequiredChannelMap = DEFAULT_REQUIRED_CHANNEL_MAP,\n  supportedChannelMap: SupportedChannelMap = DEFAULT_SUPPORTED_CHANNEL_TYPE\n  ) {\n  const mark = isMarkDef(spec.mark) ? spec.mark.type : spec.mark;\n  const encoding = spec.encoding;\n  const requiredChannels = requiredChannelMap[mark];\n  const supportedChannels = supportedChannelMap[mark];\n\n  for (const i in requiredChannels) { // all required channels are in encoding`\n    if (!(requiredChannels[i] in encoding)) {\n      return 'Missing encoding channel \\\"' + requiredChannels[i] +\n        '\\\" for mark \\\"' + mark + '\\\"';\n    }\n  }\n\n  for (const channel in encoding) { // all channels in encoding are supported\n    if (!supportedChannels[channel]) {\n      return 'Encoding channel \\\"' + channel +\n        '\\\" is not supported by mark type \\\"' + mark + '\\\"';\n    }\n  }\n\n  if (mark === BAR && !encoding.x && !encoding.y) {\n    return 'Missing both x and y for bar';\n  }\n\n  return null;\n}\n","import {BaseBin} from './bin';\nimport {NiceTime, ScaleType} from './scale';\nimport {StackOffset} from './stack';\nimport {isArray} from './util';\n\nexport interface VgData {\n  name: string;\n  source?: string;\n  values?: any;\n  format?: any;\n  url?: any;\n  transform?: VgTransform[];\n}\n\n\nexport type VgParentRef = {\n  parent: string\n};\n\nexport type VgFieldRef = string | VgParentRef | VgParentRef[];\n\nexport type VgSortField = boolean | {\n  field: VgFieldRef,\n  op: string\n};\n\nexport type VgDataRef = {\n  data: string,\n  field: VgFieldRef,\n  sort?: VgSortField\n};\n\nexport type VgSignalRef = {\n  signal: string\n};\n\n// TODO: add type of value (Make it VgValueRef<T> {value?:T ...})\nexport type VgValueRef = {\n  value?: number | string | boolean,\n  field?: string | {\n    datum?: string,\n    group?: string,\n    parent?: string\n  },\n  signal?: string;\n  scale?: string, // TODO: object\n  mult?: number,\n  offset?: number | VgValueRef,\n  band?: boolean | number\n};\n\n// TODO: add vg prefix\nexport type DataRefUnionDomain = {\n  fields: (any[] | VgDataRef)[],\n  sort?: boolean | {\n    op: 'count'\n  }\n};\n\n// TODO: add vg prefix\nexport type FieldRefUnionDomain = {\n  data: string,\n  fields: VgFieldRef[],\n  sort?: boolean | {\n    op: 'count'\n  }\n};\n\nexport type VgRangeScheme = {scheme: string, extent?: number[], count?: number};\nexport type VgRange = string | VgDataRef | (number|string|VgDataRef)[] | VgRangeScheme | {step: number};\n\nexport type VgDomain = any[] | VgDataRef | DataRefUnionDomain | FieldRefUnionDomain | VgSignalRef;\n\nexport type VgMarkGroup = any;\n\nexport type VgScale = {\n  name: string,\n  type: ScaleType,\n  domain: VgDomain,\n  domainRaw?: VgSignalRef,\n  range: VgRange,\n\n  clamp?: boolean,\n  exponent?: number,\n  nice?: boolean | NiceTime,\n  padding?: number,\n  paddingInner?: number,\n  paddingOuter?: number,\n  reverse?: boolean,\n  round?: boolean,\n  zero?: boolean\n};\n\nexport type VgLayoutAlign = 'none' | 'each' | 'all';\n\nexport type VgLayout = {\n  padding: number | {\n    row?: number,\n    column?: number\n  },\n  offset: number | {\n    rowHeader: number,\n    rowFooter: number,\n    rowTitle: number,\n    columnHeader: number,\n    columnFooter: number,\n    columnTitle: number\n  },\n  bounds: 'full' | 'flush',\n  columns: number | {signal: string},\n  align?: VgLayoutAlign | {\n    row: VgLayoutAlign,\n    column: VgLayoutAlign\n  };\n};\n\nexport function isDataRefUnionedDomain(domain: VgDomain): domain is DataRefUnionDomain {\n  if (!isArray(domain)) {\n    return 'fields' in domain && !('data' in domain);\n  }\n  return false;\n}\n\nexport function isFieldRefUnionDomain(domain: VgDomain): domain is FieldRefUnionDomain {\n  if (!isArray(domain)) {\n    return 'fields' in domain && 'data' in domain;\n  }\n  return false;\n}\n\nexport function isDataRefDomain(domain: VgDomain): domain is VgDataRef {\n  if (!isArray(domain)) {\n     return 'field' in domain && 'data' in domain;\n  }\n  return false;\n}\n\nexport function isSignalRefDomain(domain: VgDomain): domain is VgSignalRef {\n  if (!isArray(domain)) {\n    return 'signal' in domain;\n  }\n  return false;\n}\n\nexport type VgSignal = {\n  name: string,\n  update: string\n};\n\nexport type VgEncodeEntry = any;\n// TODO: make export interface VgEncodeEntry {\n//   x?: VgValueRef<number>\n//   y?: VgValueRef<number>\n//  ...\n//   color?: VgValueRef<string>\n//  ...\n// }\n\nexport type VgAxis = any;\nexport type VgLegend = any;\n\nexport interface VgBinTransform extends BaseBin {\n  type: 'bin';\n  extent?: number[] | {signal: string};\n  field: string;\n  as: string[];\n  signal?: string;\n}\n\nexport interface VgExtentTransform {\n  type: 'extent';\n  field: string;\n  signal: string;\n}\n\nexport interface VgFormulaTransform {\n  type: 'formula';\n  as: string;\n  expr: string;\n}\n\nexport interface VgFilterTransform {\n  type: 'filter';\n  expr: string;\n}\n\nexport interface VgAggregateTransform {\n  type: 'aggregate';\n  groupby?: VgFieldRef[];\n  fields?: VgFieldRef[];\n  ops?: string[];\n  as?: string[];\n  drop?: boolean;\n}\n\nexport interface VgCollectTransform {\n  type: 'collect';\n  sort: VgSort;\n}\n\n\nexport interface VgAxisEncode {\n  ticks?: VgGuideEncode;\n  labels?: VgGuideEncode;\n  title?: VgGuideEncode;\n  grid?: VgGuideEncode;\n  domain?: VgGuideEncode;\n}\n\nexport interface VgLegendEncode {\n  title?: VgGuideEncode;\n  labels?: VgGuideEncode;\n  legend?: VgGuideEncode;\n  symbols?: VgGuideEncode;\n  gradient?: VgGuideEncode;\n}\n\nexport type VgGuideEncode = any; // TODO: replace this (See guideEncode in Vega Schema)\n\nexport type VgTransform = VgBinTransform | VgExtentTransform | VgFormulaTransform | VgAggregateTransform | VgFilterTransform | VgImputeTransform | VgStackTransform | VgCollectTransform;\n\nexport interface VgStackTransform {\n  type: 'stack';\n  offset?: StackOffset;\n  groupby: string[];\n  field: string;\n  sort: VgSort;\n  as: string[];\n}\n\nexport type VgSort = {\n  field: string;\n  order: 'ascending' | 'descending';\n} | {\n  field: string[];\n  order: ('ascending' | 'descending')[];\n};\n\nexport interface VgImputeTransform {\n  type: 'impute';\n  groupby?: string[];\n  field: string;\n  orderby?: string[];\n  method?: 'value' | 'median' | 'max' | 'min' | 'mean';\n  value?: any;\n}\n\nexport type VgCheckboxBinding = {\n  input: 'checkbox';\n  element?: string;\n};\n\nexport type VgRadioBinding = {\n  input: 'radio';\n  options: string[];\n  element?: string;\n};\n\nexport type VgSelectBinding = {\n  input: 'select';\n  options: string[];\n  element?: string;\n};\n\nexport type VgRangeBinding = {\n  input: 'range';\n  min?: number;\n  max?: number;\n  step?: number;\n  element?: string;\n};\n\nexport type VgGenericBinding = {\n  input: string;\n  element?: string;\n};\n\nexport type VgBinding = VgCheckboxBinding | VgRadioBinding |\n  VgSelectBinding | VgRangeBinding | VgGenericBinding;\n\n\n/**\n * Base object for Vega's Axis and Axis Config.\n * All of these properties are both properties of Vega's Axis and Axis Config.\n */\nexport interface VgAxisBase {\n  /**\n   * A boolean flag indicating if the domain (the axis baseline) should be included as part of the axis (default true).\n   */\n  domain?: boolean;\n\n  /**\n   * A boolean flag indicating if grid lines should be included as part of the axis\n   *\n   * __Default value:__ `true` for (1) quantitative fields that are not binned and (2) time fields;  otherwise, `\"false\"`.\n   */\n  grid?: boolean;\n\n  /**\n   * A boolean flag indicating if labels should be included as part of the axis (default true).\n   *\n   * __Default value:__  derived from [axis config](config.html#axis-config)'s `labels` (`true` by default).\n   */\n  labels?: boolean;\n\n  /**\n   * The rotation angle of the axis labels.\n   *\n   * __Default value:__ `-45` for time or ordinal axis and `0` otherwise.\n   * @minimum 0\n   * @maximum 360\n   */\n  labelAngle?: number;\n\n  /**\n   * Boolean value that determines whether the axis should include ticks.\n   */\n  ticks?: boolean;\n\n  /**\n   * The size, in pixels, of major, minor and end ticks.\n   *\n   * __Default value:__  derived from [axis config](config.html#axis-config)'s `tickSize` (`6` by default).\n   *\n   * @minimum 0\n   */\n  tickSize?: number;\n\n  /**\n   * Max length for axis title if the title is automatically generated from the field's description. By default, this is automatically based on cell size and characterWidth property.\n   *\n   * __Default value:__  automatically determined based on the cell size (`config.cell.width`, `config.cell.height`)\n   *\n   * @minimum 0\n   * @TJS-type integer\n   */\n  titleMaxLength?: number;\n\n  /**\n   * The padding, in pixels, between title and axis.\n   */\n  titlePadding?: number;\n\n  /**\n   * The minimum extent in pixels that axis ticks and labels should use. This determines a minimum offset value for axis titles.\n   */\n  minExtent?: number;\n\n  /**\n   * The maximum extent in pixels that axis ticks and labels should use. This determines a maximum offset value for axis titles.\n   */\n  maxExtent?: number;\n}\n\nexport interface VgAxisConfig extends VgAxisBase {\n // ---------- Axis ----------\n  /**\n   * Stroke width of axis domain line\n   *\n   * __Default value:__  (none, using Vega default).\n   */\n  domainWidth?: number;\n\n  /**\n   * Color of axis domain line.\n   *\n   * __Default value:__  (none, using Vega default).\n   */\n  domainColor?: string;\n\n  // ---------- Grid ----------\n  /**\n   * Color of gridlines.\n   */\n  gridColor?: string;\n\n  /**\n   * The offset (in pixels) into which to begin drawing with the grid dash array.\n   * @minimum 0\n   */\n  gridDash?: number[];\n\n  /**\n   * The stroke opacity of grid (value between [0,1])\n   *\n   * __Default value:__ (`1` by default)\n   * @minimum 0\n   * @maximum 1\n   */\n  gridOpacity?: number;\n\n  /**\n   * The grid width, in pixels.\n   * @minimum 0\n   */\n  gridWidth?: number;\n\n  // ---------- Ticks ----------\n  /**\n   * The color of the axis's tick.\n   */\n  tickColor?: string;\n\n  /**\n   * The color of the tick label, can be in hex color code or regular color name.\n   */\n  labelColor?: string;\n\n  /**\n   * The font of the tick label.\n   */\n  labelFont?: string;\n\n  /**\n   * The font size of the label, in pixels.\n   *\n   * __Default value:__ `10`.\n   *\n   * @minimum 0\n   */\n  labelFontSize?: number;\n\n  /**\n   * Maximum allowed pixel width of axis tick labels.\n   */\n  labelLimit?: number;\n\n  /**\n   * Maximum allowed pixel width of axis titles.\n   */\n  titleLimit?: number;\n\n  /**\n   * The width, in pixels, of ticks.\n   * @minimum 0\n   */\n  tickWidth?: number;\n\n  // ---------- Title ----------\n  /**\n   * Color of the title, can be in hex color code or regular color name.\n   */\n  titleColor?: string;\n\n  /**\n   * Font of the title. (e.g., `\"Helvetica Neue\"`).\n   */\n  titleFont?: string;\n\n  /**\n   * Font size of the title.\n   *\n   * __Default value:__ `10`.\n   *\n   * @minimum 0\n   */\n  titleFontSize?: number;\n\n  /**\n   * Font weight of the title. (e.g., `\"bold\"`).\n   */\n  titleFontWeight?: string | number;\n}\n\nexport interface VgLegendBase {\n  /**\n   * Padding (in pixels) between legend entries in a symbol legend.\n   */\n  entryPadding?: number;\n\n  /**\n   * The orientation of the legend. One of `\"left\"` or `\"right\"`. This determines how the legend is positioned within the scene. The default is `\"right\"`.\n   *\n   * __Default value:__  `\"right\"`\n   */\n  orient?: string;\n\n  /**\n   * The offset, in pixels, by which to displace the legend from the edge of the enclosing group or data rectangle.\n   *\n   * __Default value:__  `0`\n   */\n  offset?: number;\n\n  /**\n   * The padding, in pixels, between the legend and axis.\n   */\n  padding?: number;\n}\n\nexport interface VgLegendConfig extends VgLegendBase {\n  // ---------- Gradient ----------\n  /**\n   * The color of the gradient stroke, can be in hex color code or regular color name.\n   */\n  gradientStrokeColor?: string;\n\n  /**\n   * The width of the gradient stroke, in pixels.\n   * @minimum 0\n   */\n  gradientStrokeWidth?: number;\n\n  /**\n   * The height of the gradient, in pixels.\n   * @minimum 0\n   */\n  gradientHeight?: number;\n\n  /**\n   * The width of the gradient, in pixels.\n   * @minimum 0\n   */\n  gradientWidth?: number;\n\n  // ---------- Label ----------\n  /**\n   * The alignment of the legend label, can be left, middle or right.\n   */\n  labelAlign?: string;\n\n  /**\n   * The position of the baseline of legend label, can be top, middle or bottom.\n   */\n  labelBaseline?: string;\n\n  /**\n   * The color of the legend label, can be in hex color code or regular color name.\n   */\n  labelColor?: string;\n\n  /**\n   * The font of the legend label.\n   */\n  labelFont?: string;\n\n  /**\n   * The font size of legend label.\n   *\n   * __Default value:__ `10`.\n   *\n   * @minimum 0\n   */\n  labelFontSize?: number;\n\n  /**\n   * Maximum allowed pixel width of axis tick labels.\n   */\n  labelLimit?: number;\n\n  /**\n   * The offset of the legend label.\n   * @minimum 0\n   */\n  labelOffset?: number;\n\n  // ---------- Symbols ----------\n  /**\n   * The color of the legend symbol,\n   */\n  symbolColor?: string;\n\n  /**\n   * Default shape type (such as \"circle\") for legend symbols.\n   */\n  symbolType?: string;\n\n  /**\n   * The size of the legend symbol, in pixels.\n   * @minimum 0\n   */\n  symbolSize?: number;\n\n  /**\n   * The width of the symbol's stroke.\n   * @minimum 0\n   */\n  symbolStrokeWidth?: number;\n\n  // ---------- Title ----------\n  /**\n   * Optional mark property definitions for custom legend styling.\n   */\n  /**\n   * The color of the legend title, can be in hex color code or regular color name.\n   */\n  titleColor?: string;\n\n  /**\n   * The font of the legend title.\n   */\n  titleFont?: string;\n\n  /**\n   * The font size of the legend title.\n   */\n  titleFontSize?: number;\n\n  /**\n   * The font weight of the legend title.\n   */\n  titleFontWeight?: string | number;\n\n  /**\n   * Maximum allowed pixel width of axis titles.\n   */\n  titleLimit?: number;\n\n  /**\n   * The padding, in pixels, between title and legend.\n   */\n  titlePadding?: number;\n}\n\nexport type FontStyle = 'normal' | 'italic';\nexport type FontWeight = 'normal' | 'bold';\n/**\n * @TJS-type integer\n * @minimum 100\n * @maximum 900\n */\nexport type FontWeightNumber = number;\nexport type HorizontalAlign = 'left' | 'right' | 'center';\nexport type Interpolate = 'linear' | 'linear-closed' |\n  'step' | 'step-before' | 'step-after' |\n  'basis' | 'basis-open' | 'basis-closed' |\n  'cardinal' | 'cardinal-open' | 'cardinal-closed' |\n  'bundle' | 'monotone';\nexport type Orient = 'horizontal' | 'vertical';\nexport type VerticalAlign = 'top' | 'middle' | 'bottom';\n\nexport interface VgMarkConfig {\n\n  /**\n   * Default Fill Color.  This has higher precedence than config.color\n   *\n   * __Default value:__ (None)\n   *\n   */\n  fill?: string;\n\n  /**\n   * Default Stroke Color.  This has higher precedence than config.color\n   *\n   * __Default value:__ (None)\n   *\n   */\n  stroke?: string;\n\n  // ---------- Opacity ----------\n  /**\n   * The overall opacity (value between [0,1]).\n   *\n   * __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  opacity?: number;\n\n\n  /**\n   * The fill opacity (value between [0,1]).\n   *\n   * __Default value:__ `1`\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  fillOpacity?: number;\n\n  /**\n   * The stroke opacity (value between [0,1]).\n   *\n   * __Default value:__ `1`\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  strokeOpacity?: number;\n\n  // ---------- Stroke Style ----------\n  /**\n   * The stroke width, in pixels.\n   *\n   * @minimum 0\n   */\n  strokeWidth?: number;\n\n  /**\n   * An array of alternating stroke, space lengths for creating dashed or dotted lines.\n   */\n  strokeDash?: number[];\n\n  /**\n   * The offset (in pixels) into which to begin drawing with the stroke dash array.\n   */\n  strokeDashOffset?: number;\n\n  // ---------- Orientation: Bar, Tick, Line, Area ----------\n  /**\n   * The orientation of a non-stacked bar, tick, area, and line charts.\n   * The value is either horizontal (default) or vertical.\n   * - For bar, rule and tick, this determines whether the size of the bar and tick\n   * should be applied to x or y dimension.\n   * - For area, this property determines the orient property of the Vega output.\n   * - For line, this property determines the sort order of the points in the line\n   * if `config.sortLineBy` is not specified.\n   * For stacked charts, this is always determined by the orientation of the stack;\n   * therefore explicitly specified value will be ignored.\n   */\n  orient?: Orient;\n\n  // ---------- Interpolation: Line / area ----------\n  /**\n   * The line interpolation method to use for line and area marks. One of the following:\n   * - `\"linear\"`: piecewise linear segments, as in a polyline.\n   * - `\"linear-closed\"`: close the linear segments to form a polygon.\n   * - `\"step\"`: alternate between horizontal and vertical segments, as in a step function.\n   * - `\"step-before\"`: alternate between vertical and horizontal segments, as in a step function.\n   * - `\"step-after\"`: alternate between horizontal and vertical segments, as in a step function.\n   * - `\"basis\"`: a B-spline, with control point duplication on the ends.\n   * - `\"basis-open\"`: an open B-spline; may not intersect the start or end.\n   * - `\"basis-closed\"`: a closed B-spline, as in a loop.\n   * - `\"cardinal\"`: a Cardinal spline, with control point duplication on the ends.\n   * - `\"cardinal-open\"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.\n   * - `\"cardinal-closed\"`: a closed Cardinal spline, as in a loop.\n   * - `\"bundle\"`: equivalent to basis, except the tension parameter is used to straighten the spline.\n   * - `\"monotone\"`: cubic interpolation that preserves monotonicity in y.\n   */\n  interpolate?: Interpolate;\n  /**\n   * Depending on the interpolation type, sets the tension parameter (for line and area marks).\n   * @minimum 0\n   * @maximum 1\n   */\n  tension?: number;\n\n  /**\n   * The default symbol shape to use. One of: `\"circle\"` (default), `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`, or `\"triangle-down\"`, or a custom SVG path.\n   *\n   * __Default value:__ `\"circle\"`\n   *\n   */\n  shape?: string;\n\n  /**\n   * The pixel area each the point/circle/square.\n   * For example: in the case of circles, the radius is determined in part by the square root of the size value.\n   *\n   * __Default value:__ `30`\n   *\n   * @minimum 0\n   */\n  size?: number;\n\n  // Text / Label Mark Config\n\n  /**\n   * The horizontal alignment of the text. One of `\"left\"`, `\"right\"`, `\"center\"`.\n   */\n  align?: HorizontalAlign;\n\n  /**\n   * The rotation angle of the text, in degrees.\n   * @minimum 0\n   * @maximum 360\n   */\n  angle?: number;\n\n  /**\n   * The vertical alignment of the text. One of `\"top\"`, `\"middle\"`, `\"bottom\"`.\n   *\n   * __Default value:__ `\"middle\"`\n   *\n   */\n  baseline?: VerticalAlign;\n\n  /**\n   * The horizontal offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.\n   */\n  dx?: number;\n\n  /**\n   * The vertical offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.\n   */\n  dy?: number;\n\n  /**\n   * Polar coordinate radial offset, in pixels, of the text label from the origin determined by the `x` and `y` properties.\n   * @minimum 0\n   */\n  radius?: number;\n\n  /**\n   * Polar coordinate angle, in radians, of the text label from the origin determined by the `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark `startAngle` and `endAngle` properties: angles are measured in radians, with `0` indicating \"north\".\n   */\n  theta?: number;\n\n  /**\n   * The typeface to set the text in (e.g., `\"Helvetica Neue\"`).\n   * @minimum 0\n   */\n  font?: string;\n\n  /**\n   * The font size, in pixels.\n   * @minimum 0\n   */\n  fontSize?: number;\n\n  /**\n   * The font style (e.g., `\"italic\"`).\n   */\n  fontStyle?: FontStyle;\n  /**\n   * The font weight (e.g., `\"bold\"`).\n   */\n  fontWeight?: FontWeight | FontWeightNumber;\n\n  /**\n   * Placeholder text if the `text` channel is not specified\n   */\n  text?: string;\n}\n","export import axis = require('./axis');\nexport import aggregate = require('./aggregate');\nexport import bin = require('./bin');\nexport import channel = require('./channel');\nexport import compositeMark = require('./compositemark');\nexport {compile}  from './compile/compile';\nexport import config = require('./config');\nexport import data = require('./data');\nexport import datetime = require('./datetime');\nexport import encoding = require('./encoding');\nexport import facet = require('./facet');\nexport import fieldDef = require('./fielddef');\nexport import legend = require('./legend');\nexport import mark = require('./mark');\nexport import scale = require('./scale');\nexport import sort = require('./sort');\nexport import spec = require('./spec');\nexport import stack = require('./stack');\nexport import timeUnit = require('./timeunit');\nexport import transform = require('./transform');\nexport import type = require('./type');\nexport import util = require('./util');\nexport import validate = require('./validate');\n\nexport const version: string = require('../package.json').version;\n"]}