{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/vl","vega-lite.js","node_modules/browserify/node_modules/process/browser.js","node_modules/datalib/src/bin.js","node_modules/datalib/src/date-units.js","node_modules/datalib/src/generate.js","node_modules/datalib/src/stats.js","node_modules/datalib/src/summary.js","node_modules/datalib/src/util.js","src/Encoding.js","src/compile/aggregate.js","src/compile/axis.js","src/compile/bin.js","src/compile/compile.js","src/compile/facet.js","src/compile/filter.js","src/compile/group.js","src/compile/layout.js","src/compile/legend.js","src/compile/marks.js","src/compile/scale.js","src/compile/sort.js","src/compile/stack.js","src/compile/style.js","src/compile/subfacet.js","src/compile/template.js","src/compile/time.js","src/consts.js","src/data.js","src/enc.js","src/field.js","src/globals.js","src/schema/schema.js","src/schema/schemautil.js","src/util.js"],"names":["e","exports","module","define","amd","f","window","global","self","vl","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"util","consts","extend","Encoding","compile","data","field","enc","schema","toShorthand","shorthand","./Encoding","./compile/compile","./consts","./data","./enc","./field","./globals","./schema/schema","./util",2,3,"drainQueue","draining","currentQueue","len","queue","noop","process","nextTick","fun","push","setTimeout","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","name","cwd","chdir","dir","umask",4,"bin","opt","step","logb","level","minstep","precision","v","eps","maxb","maxbins","base","Math","log","div","min","max","span","steps","bisect","ceil","pow","round","floor","start","stop","unit","value","index","x","lo","hi","mid","cmp","this","EPSILON","date_value","date","date_index","units","dmin","dmax","minb","minbins","find","bins","raw","./date-units",5,"STEPS","entries","type","format","d","Date","UTC","isNumber","getUTCFullYear","getUTCMonth","minuteOfHour","getUTCMinutes","hourOfDay","getUTCHours","dayOfWeek","getUTCDay","dayOfMonth","getUTCDate","monthOfYear","second","minute","hour","day","month","year","timesteps",6,"gen","repeat","val","Array","zeros","range","arguments","Infinity","j","random","uniform","undefined","samples","map","integer","b","normal","mean","stdev","next","rds","c","y","sqrt",7,"stats","unique","values","results","isArray","counts","count","distinct","nulls","median","filter","isNotNull","sort","half","quantile","p","identity","H","h","delta","isNaN","variance","M2","modeskew","avg","med","std","extent","dot","sum","rank","mu","idx","comparator","tie","cor","fn","mua","mub","sda","sdb","ra","rb","dist","aa","bb","ab","X","Y","A","mat","B","exp","isFunction","abs","m","R","M","entropy","N","LN2","normalized","mutual","z","px","py","I","profile","sd","vals","iqr","./generate",8,"printSummary","profiles","str","forEach","printCategoricalProfile","printQuantitativeProfile","join","list","top","keys","slice","concat","fields","accessor","toString","./stats",9,"util_escape_str","replace","escape_str_re","truncateOnWord","rev","cnt","tok","split","truncate_word_re","reverse","w","trim","Buffer","isNode","stderr","Object","prototype","isObject","obj","isString","parseFloat","isFinite","isBoolean","isDate","isBuffer","number","parse","array","JSON","stringify","duplicate","equal","k","toMap","reduce","keystr","shift","apply","mutator","sign","NaN","numcmp","stablesort","sortBy","keyFn","indices","sa","sb","startsWith","String","string","searchString","lastIndexOf","truncate","pos","word","ellipsis","l1","l2","_process","buffer",10,"vlfield","vlenc","marktype","config","theme","defaults","instantiate","spec","dataTypes","specExtended","merge","_data","_marktype","_enc","_config","_filter","proto","is","has","encType","et","filterNull","fieldList","fieldName","Q","containsType","T","O","operands","operator","nodata","nofn","isCount","aggr","fieldTitle","displayName","toUpperCase","scale","axis","band","bandSize","useSmallBand","ROW","COL","size","MAXBINS_DEFAULT","legend","isType","byCode","toggleSort","support","qField","init","role","text","prop","TEXT","font","fieldDef","isOrdinalScale","encoding","isDimension","isMeasure","isAggregate","alwaysNoOcclusion","isStack","color","cardinality","isRaw","hasValues","toSpec","excludeConfig","excludeData","dataTypeNames","subtract","assign","delim","fromShorthand","specFromShorthand","fromSpec","transpose","oldenc","row","col","direction","useTypeCode","mode","get","toggleFilterNullO",11,"aggregates","dims","meas","detail","facets","op","transform","groupby","details","aggregated","../globals","../util",12,"axis_title","def","layout","maxlength","cellWidth","cellHeight","setter","angle","align","baseline","dy","height","titleOffset","axisTitleOffset","axis_labels","time","hasScale","textTemplatePath","maxLabelLength","getter","names","props","defs","isCol","isRow","rowOffset","cellPadding","grid","layer","offset","stroke","opacity","x2","group","mult","orient","ticks","./time",13,"binning","output",14,"summary","marks","aggregate","facet","stack","style","subfacet","template","mark","mdefs","mdef","addFilters","sorting","hasRow","hasCol","lineType","line","aggResult","hasDetails","from","by","legends","scales","properties","update","axes","filterLessThanZero","../Encoding","./aggregate","./axis","./bin","./facet","./filter","./group","./layout","./legend","./marks","./scale","./sort","./stack","./style","./subfacet","./template","datalib/src/summary",15,"faceting","axesGrp","enter","facetKeys","cellAxes","fill","error","unshift","groupdef","width","trans",16,"BINARY",">",">=","=","!=","<","<=","filters","condition","op1","op2","console","warn","test",17,"_name",18,"vllayout","box","hasX","hasY","xCardinality","yCardinality","padding","colCardinality","rowCardinality","getMaxLength","maxLength",19,"COLOR","SIZE","SHAPE","shape","labels",20,"bar_props","xc","y2","yc","ALPHA","point_props","strokeWidth","line_props","area_props","tick_props","filled_point_props","text_props","fontSize","fontWeight","fontStyle","bg","TABLE","bar","requiredEncoding","supportedEncoding","alpha","area","tick","circle","square","point",21,"scale_domain","domain","getbins","STACKED","getDataset","scale_range","bandWidth","zero","nice","colorRange","outerPadding","points",22,"addSortTransforms","datasetMapping","counter","byClause","dataName","transforms","source","RAW",23,"stacking","dim","isXMeasure","isYMeasure","stacked","y1","y0",24,"estimateOpacity","numPoints","numMultiples","../field",25,"subfaceting","g",26,"table","dataUrl","dataType","url",27,"timeFields","timeFn","tf","fieldFn","func","stat","yearstat","formula","expr","labelLength","substr","isOrdinalFn","isColor",28,"encodingTypes","DETAIL",29,"vldata","types","boolean",30,"encTypes","countRetinal","arr","indexOf","convertType","enctype",31,"getIsType","byName","shorthands","timefns","typeOrder","G","order","typeThenName","toLowerCase","original","typeThenCardinality","./compile/time",32,"INDEX",33,"enum","supportedEnums","supportedTypes","minimum","default","getSupportedRole","supportedRole","defaultTimeFn","scale_type","clone","typicalField","description","onlyOrdinalField","dimension","axisMixin","supportedMarktypes","sortMixin","items","required","bandMixin","legendMixin","textMixin","margin","weight","family","sizeMixin","colorMixin","alphaMixin","maximum","shapeMixin","detailMixin","rowMixin","colMixin","facetMixin","requiredNameType","multiRoleField","measure","quantitativeField","onlyQuantitativeField","formatType","additionalProperties","viewport","gridColor","gridOpacity","singleHeight","singleWidth","largeBandSize","smallBandSize","largeBandMaxCardinality","cellGridColor","cellGridOpacity","cellBackgroundColor","textCellWidth","timeScaleLabelLength","characterWidth","$schema","./schemautil",34,"dest","src","hasOwnProperty","constructor","schemautil","isEmpty","instance","changes","ins",35,"isin","item","thisArg","any","all","noaugment","msg","datalib/src/bin","datalib/src/generate","datalib/src/util"],"mappings":"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","file":"vega-lite.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nrequire('./globals');\n\nvar util = require('./util'),\n    consts = require('./consts');\n\nvar vl = {};\n\nutil.extend(vl, consts, util);\n\nvl.Encoding = require('./Encoding');\nvl.compile = require('./compile/compile');\nvl.data = require('./data');\nvl.field = require('./field');\nvl.enc = require('./enc');\nvl.schema = require('./schema/schema');\nvl.toShorthand = vl.Encoding.shorthand;\n\nmodule.exports = vl;","!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.vl=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar util = require('./util'),\n    consts = require('./consts');\n\nvar vl = {};\n\nutil.extend(vl, consts, util);\n\nvl.Encoding = require('./Encoding');\nvl.compile = require('./compile/compile');\nvl.data = require('./data');\nvl.field = require('./field');\nvl.enc = require('./enc');\nvl.schema = require('./schema/schema');\nvl.toShorthand = vl.Encoding.shorthand;\n\nmodule.exports = vl;\n},{\"./Encoding\":10,\"./compile/compile\":14,\"./consts\":28,\"./data\":29,\"./enc\":30,\"./field\":31,\"./globals\":32,\"./schema/schema\":33,\"./util\":35}],2:[function(require,module,exports){\n\n},{}],3:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],4:[function(require,module,exports){\nvar util = require('./util');\nvar units = require('./date-units');\nvar EPSILON = 1e-15;\n\nfunction bin(opt) {\n  opt = opt || {};\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, logb, level, minstep, precision, v, i, eps;\n\n  if (opt.step != null) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n};\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n};\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbin.date = function(opt) {\n  opt = opt || {};\n\n  // find time step, then bin\n  var dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin);\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      bins = bin({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  bins.unit = unit;\n  bins.index = date_index;\n  if (!opt.raw) bins.value = date_value;\n  return bins;\n};\n\nmodule.exports = bin;\n\n},{\"./date-units\":5,\"./util\":9}],5:[function(require,module,exports){\nvar util = require('./util');\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nvar entries = [\n  {\n    type: \"second\",\n    minstep: 1,\n    format: \"%Y %b %-d %H:%M:%S.%L\",\n    date: function(d) {\n      return new Date(d * 1e3);\n    },\n    unit: function(d) {\n      return (+d / 1e3);\n    }\n  },\n  {\n    type: \"minute\",\n    minstep: 1,\n    format: \"%Y %b %-d %H:%M\",\n    date: function(d) {\n      return new Date(d * 6e4);\n    },\n    unit: function(d) {\n      return ~~(+d / 6e4);\n    }\n  },\n  {\n    type: \"hour\",\n    minstep: 1,\n    format: \"%Y %b %-d %H:00\",\n    date: function(d) {\n      return new Date(d * 36e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 36e5);\n    }\n  },\n  {\n    type: \"day\",\n    minstep: 1,\n    step: [1, 7],\n    format: \"%Y %b %-d\",\n    date: function(d) {\n      return new Date(d * 864e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 864e5);\n    }\n  },\n  {\n    type: \"month\",\n    minstep: 1,\n    step: [1, 3, 6],\n    format: \"%b %Y\",\n    date: function(d) {\n      return new Date(Date.UTC(~~(d / 12), d % 12, 1));\n    },\n    unit: function(d) {\n      if (util.isNumber(d)) d = new Date(d);\n      return 12 * d.getUTCFullYear() + d.getUTCMonth();\n    }\n  },\n  {\n    type: \"year\",\n    minstep: 1,\n    format: \"%Y\",\n    date: function(d) {\n      return new Date(Date.UTC(d, 0, 1));\n    },\n    unit: function(d) {\n      return (util.isNumber(d) ? new Date(d) : d).getUTCFullYear();\n    }\n  }\n];\n\nvar minuteOfHour = {\n  type: \"minuteOfHour\",\n  min: 0,\n  max: 59,\n  minstep: 1,\n  format: \"%M\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, 0, d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCMinutes();\n  }\n};\n\nvar hourOfDay = {\n  type: \"hourOfDay\",\n  min: 0,\n  max: 23,\n  minstep: 1,\n  format: \"%H\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCHours();\n  }\n};\n\nvar dayOfWeek = {\n  type: \"dayOfWeek\",\n  min: 0,\n  max: 6,\n  step: [1],\n  format: \"%a\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 4 + d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCDay();\n  }\n};\n\nvar dayOfMonth = {\n  type: \"dayOfMonth\",\n  min: 1,\n  max: 31,\n  step: [1],\n  format: \"%-d\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCDate();\n  }\n};\n\nvar monthOfYear = {\n  type: \"monthOfYear\",\n  min: 0,\n  max: 11,\n  step: [1],\n  format: \"%b\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, d % 12, 1));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCMonth();\n  }\n};\n\nvar units = {\n  \"second\":       entries[0],\n  \"minute\":       entries[1],\n  \"hour\":         entries[2],\n  \"day\":          entries[3],\n  \"month\":        entries[4],\n  \"year\":         entries[5],\n  \"minuteOfHour\": minuteOfHour,\n  \"hourOfDay\":    hourOfDay,\n  \"dayOfWeek\":    dayOfWeek,\n  \"dayOfMonth\":   dayOfMonth,\n  \"monthOfYear\":  monthOfYear,\n  \"timesteps\":    entries\n};\n\nunits.find = function(span, minb, maxb) {\n  var i, len, bins, step = STEPS[0];\n\n  for (i = 1, len = STEPS.length; i < len; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return entries[STEPS[i - 1][1]];\n      }\n      if (bins >= minb) {\n        return entries[step[1]];\n      }\n    }\n  }\n  return entries[STEPS[STEPS.length - 1][1]];\n};\n\nmodule.exports = units;\n\n},{\"./util\":9}],6:[function(require,module,exports){\nvar gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n\t\tmax = min;\n\t\tmin = 0;\n\t}\n\tvar d = max - min;\n\tvar f = function() {\n\t\treturn min + d * Math.random();\n\t};\n\tf.samples = function(n) { return gen.zeros(n).map(f); };\n\treturn f;\n};\n\ngen.random.integer = function(a, b) {\n\tif (b === undefined) {\n\t\tb = a;\n\t\ta = 0;\n\t}\n  var d = b - a;\n\tvar f = function() {\n\t\treturn a + Math.floor(d * Math.random());\n\t};\n\tf.samples = function(n) { return gen.zeros(n).map(f); };\n\treturn f;\n};\n\ngen.random.normal = function(mean, stdev) {\n\tmean = mean || 0;\n\tstdev = stdev || 1;\n\tvar next = undefined;\n\tvar f = function() {\n\t\tvar x = 0, y = 0, rds, c;\n\t\tif (next !== undefined) {\n\t\t\tx = next;\n\t\t\tnext = undefined;\n\t\t\treturn x;\n\t\t}\n\t\tdo {\n\t\t\tx = Math.random()*2-1;\n\t\t\ty = Math.random()*2-1;\n\t\t\trds = x*x + y*y;\n\t\t} while (rds == 0 || rds > 1);\n\t\tc = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n\t\tnext = mean + y*c*stdev;\n\t\treturn mean + x*c*stdev;\n\t};\n\tf.samples = function(n) { return gen.zeros(n).map(f); };\n\treturn f;\n};\n},{}],7:[function(require,module,exports){\nvar util = require('./util');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values and associated counts.\n// Output: an array of unique values, in observed order\n// The array includes an additional 'counts' property,\n// which is a hash from unique values to occurrence counts.\nstats.unique = function(values, f, results) {\n  if (!util.isArray(values) || values.length===0) return [];\n  results = results || [];\n  var u = {}, v, i;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) {\n      u[v] += 1;\n    } else {\n      u[v] = 1;\n      results.push(v);\n    }\n  }\n  results.counts = u;\n  return results;\n};\n\n// Count the number of non-null values.\nstats.count = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\nstats.count.distinct = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var u = {}, v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Count the number of null or undefined values.\nstats.count.nulls = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  if (f) values = values.map(f);\n  values = values.filter(util.isNotNull).sort(util.cmp);\n  var half = Math.floor(values.length/2);\n  if (values.length % 2) {\n    return values[half];\n  } else {\n    return (values[half-1] + values[half]) / 2.0;\n  }\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null && !isNaN(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null && !isNaN(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isNotNull(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isNotNull(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  var a, b, x, y, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isNotNull(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isNotNull(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error(\"Array lengths must match.\");\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (!isNaN(v)) sum += v;\n    }\n  } else {  \n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (!isNaN(v)) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  var a = values.map(function(v, i) {\n      return {\n        idx: i,\n        val: (f ? f(v) : v)\n      };\n    })\n    .sort(util.comparator(\"val\"));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(b) : a,\n  a = fn ? values.map(a) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, a) : stats.rank(values),\n      rb = b ? stats.rank(values, b) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(a) : values,\n      Y = b ? values.map(b) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      n = values.length, s = 0, d, i;\n\n  if (e === 2 || e === undefined) {\n    for (i=0; i<n; ++i) {\n      d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n      s += d*d;\n    }\n    return Math.sqrt(s); \n  } else {\n    for (i=0; i<n; ++i) {\n      d = Math.abs(f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]));\n      s += Math.pow(d, e);\n    }\n    return Math.pow(s, 1/e);\n  }\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  var i, p, s = 0, H = 0, N = counts.length;\n  for (i=0; i<N; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<N; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p > 0) H += p * Math.log(p) / Math.LN2;\n  }\n  return -H;\n};\n\n// Compute the normalized Shannon entropy (log base 2) of an array of counts.\nstats.entropy.normalized = function(counts, f) {\n  var H = stats.entropy(counts, f);\n  return H===0 ? 0 : H * Math.LN2 / Math.log(counts.length);\n};\n\n// Compute the mutual information between two discrete variables.\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.entropy.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(a) : values,\n      y = counts ? values.map(b) : a,\n      z = counts ? values.map(counts) : b;\n\n  var px = {},\n\t    py = {},\n\t    i, xx, yy, zz, s = 0, t, N = z.length, p, I = 0;\n\n\tfor (i=0; i<N; ++i) {\n\t  px[x[i]] = 0;\n\t  py[y[i]] = 0;\n  }\n\n\tfor (i=0; i<N; ++i) {\n\t\tpx[x[i]] += z[i];\n\t\tpy[y[i]] += z[i];\n\t\ts += z[i];\n\t}\n\n\tt = 1 / (s * Math.LN2);\n\tfor (i=0; i<N; ++i) {\n\t\tif (z[i] === 0) continue;\n\t\tp = (s * z[i]) / (px[x[i]] * py[y[i]]);\n\t\tI += z[i] * t * Math.log(p);\n\t}\n\n\treturn I;\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var p = {},\n      mean = 0,\n      count = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x, half, h, h2;\n\n  // compute summary stats\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (util.isNotNull(v)) {\n      // update min/max\n      if (min===null || v < min) min = v;\n      if (max===null || v > max) max = v;\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      delta = x - mean;\n      mean = mean + delta / (++count);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (count - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    unique:   u,\n    count:    count,\n    nulls:    values.length - count,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd,\n    iqr:      [stats.quantile(vals, 0.25), stats.quantile(vals, 0.75)]\n  };\n};\n\nmodule.exports = stats;\n},{\"./generate\":6,\"./util\":9}],8:[function(require,module,exports){\nvar util = require('./util');\nvar stats = require('./stats');\n\n// Compute profiles for all variables in a data set.\nmodule.exports = function(data, fields) {\n  if (data == null || data.length === 0) return null;\n  fields = fields || util.keys(data[0]);\n\n  var profiles = fields.map(function(f) {\n    var p = stats.profile(data, util.accessor(f));\n    return (p.field = f, p);\n  });\n  \n  profiles.toString = printSummary;\n  return profiles;\n};\n\nfunction printSummary() {\n  var profiles = this;\n  var str = [];\n  profiles.forEach(function(p) {\n    str.push(\"----- Field: '\" + p.field + \"' -----\");\n    if (typeof p.min === 'string' || p.distinct < 10) {\n      str.push(printCategoricalProfile(p));\n    } else {\n      str.push(printQuantitativeProfile(p));\n    }\n    str.push(\"\");\n  });\n  return str.join(\"\\n\");\n}\n\nfunction printQuantitativeProfile(p) {\n  return [\n    \"distinct: \" + p.distinct,\n    \"nulls:    \" + p.nulls,\n    \"min:      \" + p.min,\n    \"max:      \" + p.max,\n    \"median:   \" + p.median,\n    \"mean:     \" + p.mean,\n    \"stdev:    \" + p.stdev,\n    \"modeskew: \" + p.modeskew\n  ].join(\"\\n\");\n}\n\nfunction printCategoricalProfile(p) {\n  var list = [\n    \"distinct: \" + p.distinct,\n    \"nulls:    \" + p.nulls,\n    \"top values: \"\n  ];\n  var u = p.unique;\n  var top = util.keys(u)\n    .sort(function(a,b) { return u[b] - u[a]; })\n    .slice(0, 6)\n    .map(function(v) { return \" '\" + v + \"' (\" + u[v] + \")\"; });\n  return list.concat(top).join(\"\\n\");\n}\n},{\"./stats\":7,\"./util\":9}],9:[function(require,module,exports){\n(function (process){\nvar Buffer = require('buffer').Buffer;\nvar u = module.exports = {};\n\n// where are we?\n\nu.isNode = typeof process !== 'undefined'\n        && typeof process.stderr !== 'undefined';\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) == '[object Function]';\n};\n\nu.isString = function(obj) {\n  return toString.call(obj) == '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) == '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return !isNaN(parseFloat(obj)) && isFinite(obj);\n};\n\nu.isBoolean = function(obj) {\n  return toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) == '[object Date]';\n};\n\nu.isNotNull = function(obj) {\n  return obj != null && (typeof obj !== 'number' ? true : !isNaN(obj));\n};\n\nu.isBuffer = (Buffer && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) { return s == null ? null : +s; };\n\nu.boolean = function(s) { return s == null ? null : s==='false' ? false : !!s; };\n\nu.date = function(s) { return s == null ? null : Date.parse(s); }\n\nu.array = function(x) { return x != null ? (u.isArray(x) ? x : [x]) : []; };\n\nu.str = function(x) {\n  return u.isArray(x) ? \"[\" + x.map(u.str) + \"]\"\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? (\"'\"+util_escape_str(x)+\"'\") : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, \"$1\\\\'\");\n}\n\n// utility functions\n\nu.identity = function(x) { return x; };\n\nu.true = function() { return true; };\n\nu.false = function() { return false; };\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list) {\n  return list.reduce(function(obj, x) {\n    return (obj[x] = 1, obj);\n  }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  return values.join(\"|\");\n};\n\n// data access functions\n\nu.field = function(f) {\n  return f.split(\"\\\\.\")\n    .map(function(d) { return d.split(\".\"); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += \".\" + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return (u.isFunction(f) || f==null)\n    ? f : u.isString(f) && (s=u.field(f)).length > 1\n    ? function(x) { return s.reduce(function(x,f) {\n          return x[f];\n        }, x);\n      }\n    : function(x) { return x[f]; };\n};\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1\n    ? function(x, v) {\n        for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n        x[s[i]] = v;\n      }\n    : function(x, v) { x[f] = v; };\n};\n\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === \"-\") { s = -1; f = f.slice(1); }\n    else if (f[0] === \"+\") { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null && b === null) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\n// ES6 compatibility per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill\n// We could have used the polyfill code, but lets wait until ES6 becomes a standard first\nu.startsWith = String.prototype.startsWith\n  ? function(string, searchString) {\n    return string.startsWith(searchString);\n  }\n  : function(string, searchString) {\n    return string.lastIndexOf(searchString, 0) === 0;\n  };\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : \"\";\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case \"left\":\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case \"middle\":\n    case \"center\":\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) + ellipsis\n        + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join(\"\").trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n\n}).call(this,require('_process'))\n\n},{\"_process\":3,\"buffer\":2}],10:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  util = require('./util'),\n  vlfield = require('./field'),\n  vlenc = require('./enc'),\n  schema = require('./schema/schema');\n\nmodule.exports = (function() {\n  function Encoding(marktype, enc, data, config, filter, theme) {\n    var defaults = schema.instantiate();\n\n    var spec = {\n      data: data,\n      marktype: marktype,\n      enc: enc,\n      config: config,\n      filter: filter || []\n    };\n\n    // type to bitcode\n    for (var e in defaults.enc) {\n      defaults.enc[e].type = consts.dataTypes[defaults.enc[e].type];\n    }\n\n    var specExtended = schema.util.merge(defaults, theme || {}, spec) ;\n\n    this._data = specExtended.data;\n    this._marktype = specExtended.marktype;\n    this._enc = specExtended.enc;\n    this._config = specExtended.config;\n    this._filter = specExtended.filter;\n  }\n\n  var proto = Encoding.prototype;\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(encType) {\n    // equivalent to calling vlenc.has(this._enc, encType)\n    return this._enc[encType].name !== undefined;\n  };\n\n  proto.enc = function(et) {\n    return this._enc[et];\n  };\n\n  proto.filter = function() {\n    var filterNull = [],\n      fields = this.fields(),\n      self = this;\n\n    util.forEach(fields, function(fieldList, fieldName) {\n      if (fieldName === '*') return; //count\n\n      if ((self.config('filterNull').Q && fieldList.containsType[Q]) ||\n          (self.config('filterNull').T && fieldList.containsType[T]) ||\n          (self.config('filterNull').O && fieldList.containsType[O])) {\n        filterNull.push({\n          operands: [fieldName],\n          operator: 'notNull'\n        });\n      }\n    });\n\n    return filterNull.concat(this._filter);\n  };\n\n  // get \"field\" property for vega\n  proto.field = function(et, nodata, nofn) {\n    if (!this.has(et)) return null;\n\n    var f = (nodata ? '' : 'data.');\n\n    if (vlfield.isCount(this._enc[et])) {\n      return f + 'count';\n    } else if (!nofn && this._enc[et].bin) {\n      return f + 'bin_' + this._enc[et].name;\n    } else if (!nofn && this._enc[et].aggr) {\n      return f + this._enc[et].aggr + '_' + this._enc[et].name;\n    } else if (!nofn && this._enc[et].fn) {\n      return f + this._enc[et].fn + '_' + this._enc[et].name;\n    } else {\n      return f + this._enc[et].name;\n    }\n  };\n\n  proto.fieldName = function(et) {\n    return this._enc[et].name;\n  };\n\n  /*\n   * return key-value pairs of field name and list of fields of that field name\n   */\n  proto.fields = function() {\n    return vlenc.fields(this._enc);\n  };\n\n  proto.fieldTitle = function(et) {\n    if (vlfield.isCount(this._enc[et])) {\n      return vlfield.count.displayName;\n    }\n    var fn = this._enc[et].aggr || this._enc[et].fn || (this._enc[et].bin && \"bin\");\n    if (fn) {\n      return fn.toUpperCase() + '(' + this._enc[et].name + ')';\n    } else {\n      return this._enc[et].name;\n    }\n  };\n\n  proto.scale = function(et) {\n    return this._enc[et].scale || {};\n  };\n\n  proto.axis = function(et) {\n    return this._enc[et].axis || {};\n  };\n\n  proto.band = function(et) {\n    return this._enc[et].band || {};\n  };\n\n  proto.bandSize = function(encType, useSmallBand) {\n    useSmallBand = useSmallBand ||\n      //isBandInSmallMultiples\n      (encType === Y && this.has(ROW) && this.has(Y)) ||\n      (encType === X && this.has(COL) && this.has(X));\n\n    // if band.size is explicitly specified, follow the specification, otherwise draw value from config.\n    return this.band(encType).size ||\n      this.config(useSmallBand ? 'smallBandSize' : 'largeBandSize');\n  };\n\n  proto.aggr = function(et) {\n    return this._enc[et].aggr;\n  };\n\n  // returns false if binning is disabled, otherwise an object with binning properties\n  proto.bin = function(et) {\n    var bin = this._enc[et].bin;\n    if (bin === {})\n      return false;\n    if (bin === true)\n      return {\n        maxbins: schema.MAXBINS_DEFAULT\n      };\n    return bin;\n  };\n\n  proto.legend = function(et) {\n    return this._enc[et].legend;\n  };\n\n  proto.value = function(et) {\n    return this._enc[et].value;\n  };\n\n  proto.fn = function(et) {\n    return this._enc[et].fn;\n  };\n\n  proto.sort = function(et, stats) {\n    var sort = this._enc[et].sort,\n      enc = this._enc,\n      isType = vlfield.isType.byCode;\n\n    // console.log('sort:', sort, 'support:', Encoding.toggleSort.support({enc:this._enc}, stats) , 'toggle:', this.config('toggleSort'))\n\n    if ((!sort || sort.length===0) &&\n        Encoding.toggleSort.support({enc:this._enc}, stats, true) && //HACK\n        this.config('toggleSort') === 'Q'\n      ) {\n      var qField = isType(enc.x, O) ? enc.y : enc.x;\n\n      if (isType(enc[et], O)) {\n        sort = [{\n          name: qField.name,\n          aggr: qField.aggr,\n          type: qField.type,\n          reverse: true\n        }];\n      }\n    }\n\n    return sort;\n  };\n\n  proto.length = function() {\n    return util.keys(this._enc).length;\n  };\n\n  proto.map = function(f) {\n    return vlenc.map(this._enc, f);\n  };\n\n  proto.reduce = function(f, init) {\n    return vlenc.reduce(this._enc, f, init);\n  };\n\n  proto.forEach = function(f) {\n    return vlenc.forEach(this._enc, f);\n  };\n\n  proto.type = function(et) {\n    return this.has(et) ? this._enc[et].type : null;\n  };\n\n  proto.role = function(et) {\n    return this.has(et) ? vlfield.role(this._enc[et]) : null;\n  };\n\n  proto.text = function(prop) {\n    var text = this._enc[TEXT].text;\n    return prop ? text[prop] : text;\n  };\n\n  proto.font = function(prop) {\n    var font = this._enc[TEXT].font;\n    return prop ? font[prop] : font;\n  };\n\n  proto.isType = function(et, type) {\n    var field = this.enc(et);\n    return field && Encoding.isType(field, type);\n  };\n\n  Encoding.isType = function (fieldDef, type) {\n    // FIXME vlfield.isType\n    return (fieldDef.type & type) > 0;\n  };\n\n  Encoding.isOrdinalScale = function(encoding, encType) {\n    return vlfield.isOrdinalScale(encoding.enc(encType), true);\n  };\n\n  Encoding.isDimension = function(encoding, encType) {\n    return vlfield.isDimension(encoding.enc(encType), true);\n  };\n\n  Encoding.isMeasure = function(encoding, encType) {\n    return vlfield.isMeasure(encoding.enc(encType), true);\n  };\n\n  proto.isOrdinalScale = function(encType) {\n    return this.has(encType) && Encoding.isOrdinalScale(this, encType);\n  };\n\n  proto.isDimension = function(encType) {\n    return this.has(encType) && Encoding.isDimension(this, encType);\n  };\n\n  proto.isMeasure = function(encType) {\n    return this.has(encType) && Encoding.isMeasure(this, encType);\n  };\n\n  proto.isAggregate = function() {\n    return vlenc.isAggregate(this._enc);\n  };\n\n  Encoding.isAggregate = function(spec) {\n    return vlenc.isAggregate(spec.enc);\n  };\n\n  Encoding.alwaysNoOcclusion = function(spec) {\n    // FIXME raw OxQ with # of rows = # of O\n    return vlenc.isAggregate(spec.enc);\n  };\n\n  Encoding.isStack = function(spec) {\n    // FIXME update this once we have control for stack ...\n    return (spec.marktype === 'bar' || spec.marktype === 'area') &&\n      spec.enc.color;\n  };\n\n  proto.isStack = function() {\n    // FIXME update this once we have control for stack ...\n    return (this.is('bar') || this.is('area')) && this.has('color');\n  };\n\n  proto.cardinality = function(encType, stats) {\n    return vlfield.cardinality(this.enc(encType), stats, this.config('filterNull'), true);\n  };\n\n  proto.isRaw = function() {\n    return !this.isAggregate();\n  };\n\n  proto.data = function(name) {\n    return this._data[name];\n  };\n\n   // returns whether the encoding has values embedded\n  proto.hasValues = function() {\n    var vals = this.data('values');\n    return vals && vals.length;\n  };\n\n  proto.config = function(name) {\n    return this._config[name];\n  };\n\n  proto.toSpec = function(excludeConfig, excludeData) {\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    // convert type's bitcode to type name\n    for (var e in enc) {\n      enc[e].type = consts.dataTypeNames[enc[e].type];\n    }\n\n    spec = {\n      marktype: this._marktype,\n      enc: enc,\n      filter: this._filter\n    };\n\n    if (!excludeConfig) {\n      spec.config = util.duplicate(this._config);\n    }\n\n    if (!excludeData) {\n      spec.data = util.duplicate(this._data);\n    }\n\n    // remove defaults\n    var defaults = schema.instantiate();\n    return schema.util.subtract(spec, defaults);\n  };\n\n  proto.toShorthand = function() {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + this._marktype +\n      c.delim + vlenc.shorthand(this._enc);\n  };\n\n  Encoding.shorthand = function (spec) {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + spec.marktype +\n      c.delim + vlenc.shorthand(spec.enc);\n  };\n\n  Encoding.fromShorthand = function(shorthand, data, config, theme) {\n    var c = consts.shorthand,\n        split = shorthand.split(c.delim),\n        marktype = split.shift().split(c.assign)[1].trim(),\n        enc = vlenc.fromShorthand(split, true);\n\n    return new Encoding(marktype, enc, data, config, null, theme);\n  };\n\n  Encoding.specFromShorthand = function(shorthand, data, config, excludeConfig) {\n    return Encoding.fromShorthand(shorthand, data, config).toSpec(excludeConfig);\n  };\n\n  Encoding.fromSpec = function(spec, theme) {\n    var enc = util.duplicate(spec.enc || {});\n\n    //convert type from string to bitcode (e.g, O=1)\n    for (var e in enc) {\n      enc[e].type = consts.dataTypes[enc[e].type];\n    }\n\n    return new Encoding(spec.marktype, enc, spec.data, spec.config, spec.filter, theme);\n  };\n\n  Encoding.transpose = function(spec) {\n    var oldenc = spec.enc,\n      enc = util.duplicate(spec.enc);\n    enc.x = oldenc.y;\n    enc.y = oldenc.x;\n    enc.row = oldenc.col;\n    enc.col = oldenc.row;\n    spec.enc = enc;\n    return spec;\n  };\n\n  Encoding.toggleSort = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.toggleSort = spec.config.toggleSort === 'Q' ? 'O' :'Q';\n    return spec;\n  };\n\n\n  Encoding.toggleSort.direction = function(spec, useTypeCode) {\n    if (!Encoding.toggleSort.support(spec, useTypeCode)) { return; }\n    var enc = spec.enc;\n    return enc.x.type === 'O' ? 'x' :  'y';\n  };\n\n  Encoding.toggleSort.mode = function(spec) {\n    return spec.config.toggleSort;\n  };\n\n  Encoding.toggleSort.support = function(spec, stats, useTypeCode) {\n    var enc = spec.enc,\n      isType = vlfield.isType.get(useTypeCode);\n\n    if (vlenc.has(enc, ROW) || vlenc.has(enc, COL) ||\n      !vlenc.has(enc, X) || !vlenc.has(enc, Y) ||\n      !Encoding.alwaysNoOcclusion(spec, stats)) {\n      return false;\n    }\n\n    return ( isType(enc.x, O) && vlfield.isMeasure(enc.y, useTypeCode)) ? 'x' :\n      ( isType(enc.y, O) && vlfield.isMeasure(enc.x, useTypeCode)) ? 'y' : false;\n  };\n\n  Encoding.toggleFilterNullO = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.filterNull = spec.config.filterNull || { //FIXME\n      T: true,\n      Q: true\n    };\n    spec.config.filterNull.O = !spec.config.filterNull.O;\n    return spec;\n  };\n\n  Encoding.toggleFilterNullO.support = function(spec, stats) {\n    var fields = vlenc.fields(spec.enc);\n    for (var fieldName in fields) {\n      var fieldList = fields[fieldName];\n      if (fieldList.containsType.O && fieldName in stats && stats[fieldName].nulls > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  return Encoding;\n})();\n\n},{\"./consts\":28,\"./enc\":30,\"./field\":31,\"./globals\":32,\"./schema/schema\":33,\"./util\":35}],11:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util');\n\nmodule.exports = aggregates;\n\nfunction aggregates(spec, encoding, opt) {\n  opt = opt || {};\n\n  var dims = {}, meas = {}, detail = {}, facets = {},\n    data = spec.data[1]; // currently data[0] is raw and data[1] is table\n\n  encoding.forEach(function(field, encType) {\n    if (field.aggr) {\n      if (field.aggr === 'count') {\n        meas.count = {op: 'count', field: '*'};\n      }else {\n        meas[field.aggr + '|'+ field.name] = {\n          op: field.aggr,\n          field: 'data.'+ field.name\n        };\n      }\n    } else {\n      dims[field.name] = encoding.field(encType);\n      if (encType == ROW || encType == COL) {\n        facets[field.name] = dims[field.name];\n      }else if (encType !== X && encType !== Y) {\n        detail[field.name] = dims[field.name];\n      }\n    }\n  });\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0) {\n    if (!data.transform) data.transform = [];\n    data.transform.push({\n      type: 'aggregate',\n      groupby: dims,\n      fields: meas\n    });\n  }\n  return {\n    details: util.vals(detail),\n    dims: dims,\n    facets: util.vals(facets),\n    aggregated: meas.length > 0\n  };\n}\n\n},{\"../globals\":32,\"../util\":35}],12:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  getter = util.getter,\n  time = require('./time');\n\nvar axis = module.exports = {};\n\naxis.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    var s = props[x].scale;\n    if (s === X || s === Y) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\naxis.defs = function(names, encoding, layout, stats, opt) {\n  return names.reduce(function(a, name) {\n    a.push(axis.def(name, encoding, layout, stats, opt));\n    return a;\n  }, []);\n};\n\naxis.def = function(name, encoding, layout, stats, opt) {\n  var type = name;\n  var isCol = name == COL, isRow = name == ROW;\n  var rowOffset = axisTitleOffset(encoding, layout, Y) + 20,\n    cellPadding = layout.cellPadding;\n\n\n  if (isCol) type = 'x';\n  if (isRow) type = 'y';\n\n  var def = {\n    type: type,\n    scale: name\n  };\n\n  if (encoding.axis(name).grid) {\n    def.grid = true;\n    def.layer = (isRow || isCol) ? 'front' :  'back';\n\n    if (isCol) {\n      // set grid property -- put the lines on the right the cell\n      setter(def, ['properties', 'grid'], {\n        x: {\n          offset: layout.cellWidth * (1+ cellPadding/2.0),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'col'\n        },\n        y: {\n          value: -layout.cellHeight * (cellPadding/2),\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      });\n    } else if (isRow) {\n      // set grid property -- put the lines on the top\n      setter(def, ['properties', 'grid'], {\n        y: {\n          offset: -layout.cellHeight * (cellPadding/2),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'row'\n        },\n        x: {\n          value: rowOffset\n        },\n        x2: {\n          offset: rowOffset + (layout.cellWidth * 0.05),\n          // default value(s) -- vega doesn't do recursive merge\n          group: \"mark.group.width\",\n          mult: 1\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      });\n    } else {\n      setter(def, ['properties', 'grid'], {\n        stroke: { value: encoding.config('gridColor') },\n        opacity: { value: encoding.config('gridOpacity') }\n      });\n    }\n  }\n\n  if (encoding.axis(name).title) {\n    def = axis_title(def, name, encoding, layout, opt);\n  }\n\n  if (isRow || isCol) {\n    setter(def, ['properties', 'ticks'], {\n      opacity: {value: 0}\n    });\n    setter(def, ['properties', 'majorTicks'], {\n      opacity: {value: 0}\n    });\n    setter(def, ['properties', 'axis'], {\n      opacity: {value: 0}\n    });\n  }\n\n  if (isCol) {\n    def.orient = 'top';\n  }\n\n  if (isRow) {\n    def.offset = rowOffset;\n  }\n\n  if (name == X) {\n    if (encoding.has(Y) && encoding.isOrdinalScale(Y) && encoding.cardinality(Y, stats) > 30) {\n      def.orient = 'top';\n    }\n\n    if (encoding.isDimension(X) || encoding.isType(X, T)) {\n      setter(def, ['properties','labels'], {\n        angle: {value: 270},\n        align: {value: 'right'},\n        baseline: {value: 'middle'}\n      });\n    } else { // Q\n      def.ticks = 5;\n    }\n  }\n\n  def = axis_labels(def, name, encoding, layout, opt);\n\n  return def;\n};\n\nfunction axis_title(def, name, encoding, layout, opt) {\n  // jshint unused:false\n\n  var maxlength = null,\n    fieldTitle = encoding.fieldTitle(name);\n  if (name===X) {\n    maxlength = layout.cellWidth / encoding.config('characterWidth');\n  } else if (name === Y) {\n    maxlength = layout.cellHeight / encoding.config('characterWidth');\n  }\n\n  def.title = maxlength ? util.truncate(fieldTitle, maxlength) : fieldTitle;\n\n  if (name === ROW) {\n    setter(def, ['properties','title'], {\n      angle: {value: 0},\n      align: {value: 'right'},\n      baseline: {value: 'middle'},\n      dy: {value: (-layout.height/2) -20}\n    });\n  }\n\n  def.titleOffset = axisTitleOffset(encoding, layout, name);\n  return def;\n}\n\nfunction axis_labels(def, name, encoding, layout, opt) {\n  // jshint unused:false\n\n  var fn;\n  // add custom label for time type\n  if (encoding.isType(name, T) && (fn = encoding.fn(name)) && (time.hasScale(fn))) {\n    setter(def, ['properties','labels','text','scale'], 'time-'+ fn);\n  }\n\n  var textTemplatePath = ['properties','labels','text','template'];\n  if (encoding.axis(name).format) {\n    def.format = encoding.axis(name).format;\n  } else if (encoding.isType(name, Q)) {\n    setter(def, textTemplatePath, \"{{data | number:'.3s'}}\");\n  } else if (encoding.isType(name, T) && !encoding.fn(name)) {\n    setter(def, textTemplatePath, \"{{data | time:'%Y-%m-%d'}}\");\n  } else if (encoding.isType(name, T) && encoding.fn(name) === 'year') {\n    setter(def, textTemplatePath, \"{{data | number:'d'}}\");\n  } else if (encoding.isType(name, O) && encoding.axis(name).maxLabelLength) {\n    setter(def, textTemplatePath, '{{data | truncate:' + encoding.axis(name).maxLabelLength + '}}');\n  }\n\n  return def;\n}\n\nfunction axisTitleOffset(encoding, layout, name) {\n  var value = encoding.axis(name).titleOffset;\n  if (value) {\n    return value;\n  }\n  switch (name) {\n    case ROW: return 0;\n    case COL: return 35;\n  }\n  return getter(layout, [name, 'axisTitleOffset']);\n}\n\n},{\"../globals\":32,\"../util\":35,\"./time\":27}],13:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nmodule.exports = binning;\n\nfunction binning(spec, encoding, opt) {\n  opt = opt || {};\n\n  if (!spec.transform) spec.transform = [];\n\n  encoding.forEach(function(field, encType) {\n    if (encoding.bin(encType)) {\n      spec.transform.push({\n        type: 'bin',\n        field: 'data.' + field.name,\n        output: 'data.bin_' + field.name,\n        maxbins: encoding.bin(encType).maxbins\n      });\n    }\n  });\n}\n\n},{\"../globals\":32}],14:[function(require,module,exports){\n'use strict';\n\nvar summary = module.exports = require('datalib/src/summary');\n\nrequire('../globals');\n\nmodule.exports = compile;\n\nvar Encoding = require('../Encoding'),\n  axis = compile.axis = require('./axis'),\n  filter = compile.filter = require('./filter'),\n  legend = compile.legend = require('./legend'),\n  marks = compile.marks = require('./marks'),\n  scale = compile.scale = require('./scale');\n\ncompile.aggregate = require('./aggregate');\ncompile.bin = require('./bin');\ncompile.facet = require('./facet');\ncompile.group = require('./group');\ncompile.layout = require('./layout');\ncompile.sort = require('./sort');\ncompile.stack = require('./stack');\ncompile.style = require('./style');\ncompile.subfacet = require('./subfacet');\ncompile.template = require('./template');\ncompile.time = require('./time');\n\nfunction compile(spec, stats, theme) {\n  return compile.encoding(Encoding.fromSpec(spec, theme), stats);\n}\n\ncompile.shorthand = function (shorthand, stats, config, theme) {\n  return compile.encoding(Encoding.fromShorthand(shorthand, config, theme), stats);\n};\n\ncompile.encoding = function (encoding, stats) {\n  // no need to pass stats if you pass in the data\n  if (!stats && encoding.hasValues()) {\n    stats = summary(encoding.data('values')).reduce(function(s, p) {\n      s[p.field] = p;\n      return s;\n    }, {});\n  }\n\n  var layout = compile.layout(encoding, stats),\n    style = compile.style(encoding, stats),\n    spec = compile.template(encoding, layout, stats),\n    group = spec.marks[0],\n    mark = marks[encoding.marktype()],\n    mdefs = marks.def(mark, encoding, layout, style),\n    mdef = mdefs[0];  // TODO: remove this dirty hack by refactoring the whole flow\n\n  filter.addFilters(spec, encoding);\n  var sorting = compile.sort(spec, encoding, stats);\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  for (var i = 0; i < mdefs.length; i++) {\n    group.marks.push(mdefs[i]);\n  }\n\n  compile.bin(spec.data[1], encoding);\n\n  var lineType = marks[encoding.marktype()].line;\n\n  spec = compile.time(spec, encoding);\n\n  // handle subfacets\n  var aggResult = compile.aggregate(spec, encoding),\n    details = aggResult.details,\n    hasDetails = details && details.length > 0,\n    stack = hasDetails && compile.stack(spec, encoding, mdef, aggResult.facets);\n\n  if (hasDetails && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    compile.subfacet(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  //TODO(kanitw): have some config to turn off auto-sort for line (for line chart that encodes temporal information)\n  if (lineType) {\n    var f = (encoding.isMeasure(X) && encoding.isDimension(Y)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    // TODO: why - ?\n    mdef.from.transform = [{type: 'sort', by: '-' + encoding.field(f)}];\n  }\n\n  // Small Multiples\n  if (hasRow || hasCol) {\n    spec = compile.facet(group, encoding, layout, style, sorting, spec, mdef, stack, stats);\n    spec.legends = legend.defs(encoding);\n  } else {\n    group.scales = scale.defs(scale.names(mdef.properties.update), encoding, layout, style, sorting,\n      {stack: stack, stats: stats});\n    group.axes = axis.defs(axis.names(mdef.properties.update), encoding, layout, stats);\n    group.legends = legend.defs(encoding);\n  }\n\n  filter.filterLessThanZero(spec, encoding);\n\n  return spec;\n};\n\n\n},{\"../Encoding\":10,\"../globals\":32,\"./aggregate\":11,\"./axis\":12,\"./bin\":13,\"./facet\":15,\"./filter\":16,\"./group\":17,\"./layout\":18,\"./legend\":19,\"./marks\":20,\"./scale\":21,\"./sort\":22,\"./stack\":23,\"./style\":24,\"./subfacet\":25,\"./template\":26,\"./time\":27,\"datalib/src/summary\":8}],15:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util');\n\nvar axis = require('./axis'),\n  groupdef = require('./group').def,\n  scale = require('./scale');\n\nmodule.exports = faceting;\n\nfunction faceting(group, encoding, layout, style, sorting, spec, mdef, stack, stats) {\n  var enter = group.properties.enter;\n  var facetKeys = [], cellAxes = [], from, axesGrp;\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  enter.fill = {value: encoding.config('cellBackgroundColor')};\n\n  //move \"from\" to cell level and add facet transform\n  group.from = {data: group.marks[0].from.data};\n\n  // Hack, this needs to be refactored\n  for (var i = 0; i < group.marks.length; i++) {\n    var mark = group.marks[i];\n    if (mark.from.transform) {\n      delete mark.from.data; //need to keep transform for subfacetting case\n    } else {\n      delete mark.from;\n    }\n  }\n\n  if (hasRow) {\n    if (!encoding.isDimension(ROW)) {\n      util.error('Row encoding should be ordinal.');\n    }\n    enter.y = {scale: ROW, field: 'keys.' + facetKeys.length};\n    enter.height = {'value': layout.cellHeight}; // HACK\n\n    facetKeys.push(encoding.field(ROW));\n\n    if (hasCol) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.field(COL)]});\n    }\n\n    axesGrp = groupdef('x-axes', {\n        axes: encoding.has(X) ? axis.defs(['x'], encoding, layout, stats) : undefined,\n        x: hasCol ? {scale: COL, field: 'keys.0'} : {value: 0},\n        width: hasCol && {'value': layout.cellWidth}, //HACK?\n        from: from\n      });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['row'], encoding, layout, stats));\n  } else { // doesn't have row\n    if (encoding.has(X)) {\n      //keep x axis in the cell\n      cellAxes.push.apply(cellAxes, axis.defs(['x'], encoding, layout, stats));\n    }\n  }\n\n  if (hasCol) {\n    if (!encoding.isDimension(COL)) {\n      util.error('Col encoding should be ordinal.');\n    }\n    enter.x = {scale: COL, field: 'keys.' + facetKeys.length};\n    enter.width = {'value': layout.cellWidth}; // HACK\n\n    facetKeys.push(encoding.field(COL));\n\n    if (hasRow) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.field(ROW)]});\n    }\n\n    axesGrp = groupdef('y-axes', {\n      axes: encoding.has(Y) ? axis.defs(['y'], encoding, layout, stats) : undefined,\n      y: hasRow && {scale: ROW, field: 'keys.0'},\n      x: hasRow && {value: 0},\n      height: hasRow && {'value': layout.cellHeight}, //HACK?\n      from: from\n    });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['col'], encoding, layout, stats));\n  } else { // doesn't have col\n    if (encoding.has(Y)) {\n      cellAxes.push.apply(cellAxes, axis.defs(['y'], encoding, layout, stats));\n    }\n  }\n\n  // assuming equal cellWidth here\n  // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n  spec.scales = (spec.scales || []).concat(scale.defs(\n    scale.names(enter).concat(scale.names(mdef.properties.update)),\n    encoding,\n    layout,\n    style,\n    sorting,\n    {stack: stack, facet: true, stats: stats}\n  )); // row/col scales + cell scales\n\n  if (cellAxes.length > 0) {\n    group.axes = cellAxes;\n  }\n\n  // add facet transform\n  var trans = (group.from.transform || (group.from.transform = []));\n  trans.unshift({type: 'facet', keys: facetKeys});\n\n  return spec;\n}\n\n},{\"../globals\":32,\"../util\":35,\"./axis\":12,\"./group\":17,\"./scale\":21}],16:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar filter = module.exports = {};\n\nvar BINARY = {\n  '>':  true,\n  '>=': true,\n  '=':  true,\n  '!=': true,\n  '<':  true,\n  '<=': true\n};\n\nfilter.addFilters = function(spec, encoding) {\n  var filters = encoding.filter(),\n    data = spec.data[0];  // apply filters to raw data before aggregation\n\n  if (!data.transform)\n    data.transform = [];\n\n  // add custom filters\n  for (var i in filters) {\n    var filter = filters[i];\n\n    var condition = '';\n    var operator = filter.operator;\n    var operands = filter.operands;\n\n    if (BINARY[operator]) {\n      // expects a field and a value\n      if (operator === '=') {\n        operator = '==';\n      }\n\n      var op1 = operands[0];\n      var op2 = operands[1];\n      condition = 'd.data.' + op1 + operator + op2;\n    } else if (operator === 'notNull') {\n      // expects a number of fields\n      for (var j in operands) {\n        condition += 'd.data.' + operands[j] + '!==null';\n        if (j < operands.length - 1) {\n          condition += ' && ';\n        }\n      }\n    } else {\n      console.warn('Unsupported operator: ', operator);\n    }\n\n    data.transform.push({\n      type: 'filter',\n      test: condition\n    });\n  }\n};\n\n// remove less than 0 values if we use log function\nfilter.filterLessThanZero = function(spec, encoding) {\n  encoding.forEach(function(field, encType) {\n    if (encoding.scale(encType).type === 'log') {\n      spec.data[1].transform.push({\n        type: 'filter',\n        test: 'd.' + encoding.field(encType) + '>0'\n      });\n    }\n  });\n};\n\n\n},{\"../globals\":32}],17:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  def: groupdef\n};\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: 'group',\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: 'width'},\n        height: opt.height || {group: 'height'}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n\n},{}],18:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter;\n\nmodule.exports = vllayout;\n\nfunction vllayout(encoding, stats) {\n  var layout = box(encoding, stats);\n  layout = offset(encoding, stats, layout);\n  return layout;\n}\n\n/*\n  HACK to set chart size\n  NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  One solution is to update Vega to support auto-sizing\n  In the meantime, auto-padding (mostly) does the trick\n */\nfunction box(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y),\n      marktype = encoding.marktype();\n\n  // FIXME/HACK we need to take filter into account\n  var xCardinality = hasX && encoding.isDimension(X) ? encoding.cardinality(X, stats) : 1,\n    yCardinality = hasY && encoding.isDimension(Y) ? encoding.cardinality(Y, stats) : 1;\n\n  var useSmallBand = xCardinality > encoding.config('largeBandMaxCardinality') ||\n    yCardinality > encoding.config('largeBandMaxCardinality');\n\n  var cellWidth, cellHeight, cellPadding = encoding.config('cellPadding');\n\n  // set cellWidth\n  if (hasX) {\n    if (encoding.isOrdinalScale(X)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellWidth = (xCardinality + encoding.band(X).padding) * encoding.bandSize(X, useSmallBand);\n    } else {\n      cellWidth = hasCol || hasRow ? encoding.enc(COL).width :  encoding.config(\"singleWidth\");\n    }\n  } else {\n    if (marktype === TEXT) {\n      cellWidth = encoding.config('textCellWidth');\n    } else {\n      cellWidth = encoding.bandSize(X);\n    }\n  }\n\n  // set cellHeight\n  if (hasY) {\n    if (encoding.isOrdinalScale(Y)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellHeight = (yCardinality + encoding.band(Y).padding) * encoding.bandSize(Y, useSmallBand);\n    } else {\n      cellHeight = hasCol || hasRow ? encoding.enc(ROW).height :  encoding.config(\"singleHeight\");\n    }\n  } else {\n    cellHeight = encoding.bandSize(Y);\n  }\n\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n\n  var width = cellWidth, height = cellHeight;\n  if (hasCol) {\n    var colCardinality = encoding.cardinality(COL, stats);\n    width = cellWidth * ((1 + cellPadding) * (colCardinality - 1) + 1);\n  }\n  if (hasRow) {\n    var rowCardinality =  encoding.cardinality(ROW, stats);\n    height = cellHeight * ((1 + cellPadding) * (rowCardinality - 1) + 1);\n  }\n\n  return {\n    // width and height of the whole cell\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    cellPadding: cellPadding,\n    // width and height of the chart\n    width: width,\n    height: height,\n    // information about x and y, such as band size\n    x: {useSmallBand: useSmallBand},\n    y: {useSmallBand: useSmallBand}\n  };\n}\n\nfunction getMaxLength(encoding, stats, et) {\n  // FIXME determine constant for Q and T in a nicer way\n  return encoding.isType(et, Q) ? 20 :\n    encoding.isType(et, T) ? 20 :\n    stats[encoding.fieldName(et)].max;\n}\n\nfunction offset(encoding, stats, layout) {\n  [X, Y].forEach(function (x) {\n    var maxLength;\n    if (encoding.isDimension(x) || encoding.isType(x, T)) {\n      maxLength =  getMaxLength(encoding, stats, x);\n    } else if (encoding.aggr(x) === 'count') {\n      //assign default value for count as it won't have stats\n      maxLength =  3;\n    } else if (encoding.isType(x, Q)) {\n      if (x===X) {\n        maxLength = 3;\n      } else { // Y\n        //assume that default formating is always shorter than 7\n        maxLength = Math.min(getMaxLength(encoding, stats, x), 7);\n      }\n    }\n    setter(layout,[x, 'axisTitleOffset'], encoding.config('characterWidth') *  maxLength + 20);\n  });\n  return layout;\n}\n\n},{\"../globals\":32,\"../util\":35}],19:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar time = require('./time');\n\nvar legend = module.exports = {};\n\nlegend.defs = function(encoding) {\n  var defs = [];\n  // TODO: support alpha\n\n  if (encoding.has(COLOR) && encoding.legend(COLOR)) {\n    defs.push(legend.def(COLOR, encoding, {\n      fill: COLOR,\n      orient: 'right'\n    }));\n  }\n\n  if (encoding.has(SIZE) && encoding.legend(SIZE)) {\n    defs.push(legend.def(SIZE, encoding, {\n      size: SIZE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  if (encoding.has(SHAPE) && encoding.legend(SHAPE)) {\n    if (defs.length === 2) {\n      // TODO: fix this\n      console.error('Vega-lite currently only supports two legends');\n      return defs;\n    }\n    defs.push(legend.def(SHAPE, encoding, {\n      shape: SHAPE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  return defs;\n};\n\nlegend.def = function(name, encoding, props) {\n  var def = props, fn;\n\n  def.title = encoding.fieldTitle(name);\n\n  if (encoding.isType(name, T) && (fn = encoding.fn(name)) &&\n    time.hasScale(fn)) {\n    var properties = def.properties = def.properties || {},\n      labels = properties.labels = properties.labels || {},\n      text = labels.text = labels.text || {};\n\n    text.scale = 'time-'+ fn;\n  }\n\n  return def;\n};\n\n},{\"../globals\":32,\"./time\":27}],20:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar marks = module.exports = {};\n\nmarks.def = function(mark, encoding, layout, style) {\n  var defs = [];\n\n  // to add a background to text, we need to add it before the text\n  if (encoding.marktype() === TEXT && encoding.has(COLOR)) {\n    var bg = {\n      x: {value: 0},\n      y: {value: 0},\n      x2: {value: layout.cellWidth},\n      y2: {value: layout.cellHeight},\n      fill: {scale: COLOR, field: encoding.field(COLOR)}\n    };\n    defs.push({\n      type: 'rect',\n      from: {data: TABLE},\n      properties: {enter: bg, update: bg}\n    });\n  }\n\n  // add the mark def for the main thing\n  var p = mark.prop(encoding, layout, style);\n  defs.push({\n    type: mark.type,\n    from: {data: TABLE},\n    properties: {enter: p, update: p}\n  });\n\n  return defs;\n};\n\nmarks.bar = {\n  type: 'rect',\n  stack: true,\n  prop: bar_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1}\n};\n\nmarks.line = {\n  type: 'line',\n  line: true,\n  prop: line_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1, detail:1}\n};\n\nmarks.area = {\n  type: 'area',\n  stack: true,\n  line: true,\n  requiredEncoding: ['x', 'y'],\n  prop: area_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1}\n};\n\nmarks.tick = {\n  type: 'rect',\n  prop: tick_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1, detail: 1}\n};\n\nmarks.circle = {\n  type: 'symbol',\n  prop: filled_point_props('circle'),\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1, detail: 1}\n};\n\nmarks.square = {\n  type: 'symbol',\n  prop: filled_point_props('square'),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: 'symbol',\n  prop: point_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1, shape: 1, detail: 1}\n};\n\nmarks.text = {\n  type: 'text',\n  prop: text_props,\n  requiredEncoding: ['text'],\n  supportedEncoding: {row: 1, col: 1, size: 1, color: 1, alpha: 1, text: 1}\n};\n\nfunction bar_props(e, layout, style) {\n  // jshint unused:false\n\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: e.scale(X).type === 'log' ? 1 : 0};\n    }\n  } else if (e.has(X)) { // is ordinal\n    p.xc = {scale: X, field: e.field(X)};\n  } else {\n    // TODO add single bar offset\n    p.xc = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: e.scale(Y).type === 'log' ? 1 : 0};\n  } else if (e.has(Y)) { // is ordinal\n    p.yc = {scale: Y, field: e.field(Y)};\n  } else {\n    // TODO add single bar offset\n    p.yc = {group: 'height'};\n  }\n\n  // width\n  if (!e.has(X) || e.isOrdinalScale(X)) { // no X or X is ordinal\n    if (e.has(SIZE)) {\n      p.width = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      p.width = {\n        value: e.bandSize(X, layout.x.useSmallBand),\n        offset: -1\n      };\n    }\n  } else { // X is Quant or Time Scale\n    p.width = {value: 2};\n  }\n\n  // height\n  if (!e.has(Y) || e.isOrdinalScale(Y)) { // no Y or Y is ordinal\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      p.height = {\n        value: e.bandSize(Y, layout.y.useSmallBand),\n        offset: -1\n      };\n    }\n  } else { // Y is Quant or Time Scale\n    p.height = {value: 2};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction point_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.value(SIZE)};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.field(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.value(SHAPE)};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else if (!e.has(COLOR)) {\n    p.opacity = {value: style.opacity};\n  }\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction line_props(e,layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction area_props(e, layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: 'horizontal'};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction tick_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(X)) {\n      p.x.offset = -e.bandSize(X, layout.x.useSmallBand) / 3;\n    }\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    if (e.isDimension(Y)) {\n      p.y.offset = -e.bandSize(Y, layout.y.useSmallBand) / 3;\n    }\n  } else if (!e.has(Y)) {\n    p.y = {value: 0};\n  }\n\n  // width\n  if (!e.has(X) || e.isDimension(X)) {\n    p.width = {value: e.bandSize(X, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.width = {value: 1};\n  }\n\n  // height\n  if (!e.has(Y) || e.isDimension(Y)) {\n    p.height = {value: e.bandSize(Y, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.height = {value: 1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else if (!e.has(COLOR)) {\n    p.opacity = {value: style.opacity};\n  }\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, layout, style) {\n    var p = {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.field(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.field(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.field(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.value(SIZE)};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.field(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n\n    // alpha\n    if (e.has(ALPHA)) {\n      p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n    } else if (e.value(ALPHA) !== undefined) {\n      p.opacity = {value: e.value(ALPHA)};\n    } else if (!e.has(COLOR)) {\n      p.opacity = {value: style.opacity};\n    }\n\n    return p;\n  };\n}\n\nfunction text_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    if (e.has(TEXT) && e.isType(TEXT, Q)) {\n      p.x = {value: layout.cellWidth-5};\n    } else {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.fontSize = {value: e.font('size')};\n  }\n\n  // fill\n  // color should be set to background\n  p.fill = {value: 'black'};\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else {\n    p.opacity = {value: style.opacity};\n  }\n\n  // text\n  if (e.has(TEXT)) {\n    if (e.isType(TEXT, Q)) {\n      p.text = {template: \"{{\" + e.field(TEXT) + \" | number:'.3s'}}\"};\n      p.align = {value: 'right'};\n    } else {\n      p.text = {field: e.field(TEXT)};\n    }\n  } else {\n    p.text = {value: 'Abc'};\n  }\n\n  p.font = {value: e.font('family')};\n  p.fontWeight = {value: e.font('weight')};\n  p.fontStyle = {value: e.font('style')};\n  p.baseline = {value: e.text('baseline')};\n\n  return p;\n}\n\n},{\"../globals\":32}],21:[function(require,module,exports){\n'use strict';\nrequire('../globals');\nvar util = require('../util'),\n  time = require('./time');\n\nvar scale = module.exports = {};\n\nscale.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\nscale.defs = function(names, encoding, layout, style, sorting, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale.type(name, encoding),\n      domain: scale_domain(name, encoding, sorting, opt)\n    };\n    if (s.type === 'ordinal' && !encoding.bin(name) && encoding.sort(name).length === 0) {\n      s.sort = true;\n    }\n\n    scale_range(s, encoding, layout, style, opt);\n\n    return (a.push(s), a);\n  }, []);\n};\n\nscale.type = function(name, encoding) {\n\n  switch (encoding.type(name)) {\n    case O: return 'ordinal';\n    case T:\n      var fn = encoding.fn(name);\n      return (fn && time.scale.type(fn, name)) || 'time';\n    case Q:\n      if (encoding.bin(name)) {\n        return name === COLOR ? 'linear' : 'ordinal';\n      }\n      return encoding.scale(name).type;\n  }\n};\n\nfunction scale_domain(name, encoding, sorting, opt) {\n  if (encoding.isType(name, T)) {\n    var range = time.scale.domain(encoding.fn(name), name);\n    if(range) return range;\n  }\n\n  if (encoding.bin(name)) {\n    // TODO: add includeEmptyConfig here\n    if (opt.stats) {\n      var bins = util.getbins(opt.stats[encoding.fieldName(name)], encoding.bin(name).maxbins);\n      var domain = util.range(bins.start, bins.stop, bins.step);\n      return name === Y ? domain.reverse() : domain;\n    }\n  }\n\n  return name == opt.stack ?\n    {\n      data: STACKED,\n      field: 'data.' + (opt.facet ? 'max_' : '') + 'sum_' + encoding.field(name, true)\n    } :\n    {data: sorting.getDataset(name), field: encoding.field(name)};\n}\n\nfunction scale_range(s, encoding, layout, style, opt) {\n  // jshint unused:false\n  var spec = encoding.scale(s.name);\n  switch (s.name) {\n    case X:\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(X, layout.x.useSmallBand);\n      } else {\n        s.range = layout.cellWidth ? [0, layout.cellWidth] : 'width';\n\n        if (encoding.isType(s.name,T) && encoding.fn(s.name) === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n      s.round = true;\n      if (s.type === 'time') {\n        s.nice = encoding.fn(s.name);\n      }else {\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(Y, layout.y.useSmallBand);\n      } else {\n        s.range = layout.cellHeight ? [layout.cellHeight, 0] : 'height';\n\n        if (encoding.isType(s.name,T) && encoding.fn(s.name) === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n\n      s.round = true;\n\n      if (s.type === 'time') {\n        s.nice = encoding.fn(s.name) || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case ROW: // support only ordinal\n      s.bandWidth = layout.cellHeight;\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL: // support only ordinal\n      s.bandWidth = layout.cellWidth;\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is('bar')) {\n        // FIXME this is definitely incorrect\n        // but let's fix it later since bar size is a bad encoding anyway\n        s.range = [3, Math.max(encoding.bandSize(X), encoding.bandSize(Y))];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else { //point\n        var bandSize = Math.min(encoding.bandSize(X), encoding.bandSize(Y)) - 1;\n        s.range = [10, 0.8 * bandSize*bandSize];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = 'shapes';\n      break;\n    case COLOR:\n      var range = encoding.scale(COLOR).range;\n      if (range === undefined) {\n        if (s.type === 'ordinal') {\n          // FIXME\n          range = style.colorRange;\n        } else {\n          range = ['#A9DB9F', '#0D5C21'];\n          s.zero = false;\n        }\n      }\n      s.range = range;\n      break;\n    case ALPHA:\n      s.range = [0.2, 1.0];\n      break;\n    default:\n      throw new Error('Unknown encoding name: '+ s.name);\n  }\n\n  switch (s.name) {\n    case ROW:\n    case COL:\n      s.padding = encoding.config('cellPadding');\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (s.type === 'ordinal') { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.band(s.name).padding;\n      }\n  }\n}\n\n},{\"../globals\":32,\"../util\":35,\"./time\":27}],22:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nmodule.exports = addSortTransforms;\n\n// adds new transforms that produce sorted fields\nfunction addSortTransforms(spec, encoding, stats, opt) {\n  // jshint unused:false\n\n  var datasetMapping = {};\n  var counter = 0;\n\n  encoding.forEach(function(field, encType) {\n    var sortBy = encoding.sort(encType, stats);\n    if (sortBy.length > 0) {\n      var fields = sortBy.map(function(d) {\n        return {\n          op: d.aggr,\n          field: 'data.' + d.name\n        };\n      });\n\n      var byClause = sortBy.map(function(d) {\n        var reverse = (d.reverse ? '-' : '');\n        return reverse + 'data.' + (d.aggr==='count' ? 'count' : (d.aggr + '_' + d.name));\n      });\n\n      var dataName = 'sorted' + counter++;\n\n      var transforms = [\n        {\n          type: 'aggregate',\n          groupby: ['data.' + field.name],\n          fields: fields\n        },\n        {\n          type: 'sort',\n          by: byClause\n        }\n      ];\n\n      spec.data.push({\n        name: dataName,\n        source: RAW,\n        transform: transforms\n      });\n\n      datasetMapping[encType] = dataName;\n    }\n  });\n\n  return {\n    spec: spec,\n    getDataset: function(encType) {\n      var data = datasetMapping[encType];\n      if (!data) {\n        return TABLE;\n      }\n      return data;\n    }\n  };\n}\n\n},{\"../globals\":32}],23:[function(require,module,exports){\n\"use strict\";\n\nrequire('../globals');\n\nvar  marks = require('./marks');\n\nmodule.exports = stacking;\n\nfunction stacking(spec, encoding, mdef, facets) {\n  if (!marks[encoding.marktype()].stack) return false;\n\n  // TODO: add || encoding.has(LOD) here once LOD is implemented\n  if (!encoding.has(COLOR)) return false;\n\n  var dim=null, val=null, idx =null,\n    isXMeasure = encoding.isMeasure(X),\n    isYMeasure = encoding.isMeasure(Y);\n\n  if (isXMeasure && !isYMeasure) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  } else if (isYMeasure && !isXMeasure) {\n    dim = X;\n    val = Y;\n    idx = 1;\n  } else {\n    return null; // no stack encoding\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: TABLE,\n    transform: [{\n      type: 'aggregate',\n      groupby: [encoding.field(dim)].concat(facets), // dim and other facets\n      fields: [{op: 'sum', field: encoding.field(val)}] // TODO check if field with aggr is correct?\n    }]\n  };\n\n  if (facets && facets.length > 0) {\n    stacked.transform.push({ //calculate max for each facet\n      type: 'aggregate',\n      groupby: facets,\n      fields: [{op: 'max', field: 'data.sum_' + encoding.field(val, true)}]\n    });\n  }\n\n  spec.data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: 'stack',\n    point: encoding.field(dim),\n    height: encoding.field(val),\n    output: {y1: val, y0: val + '2'}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val + '2'] = mdef.properties.enter[val + '2'] = {scale: val, field: val + '2'};\n\n  return val; //return stack encoding\n}\n\n},{\"../globals\":32,\"./marks\":20}],24:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar vlfield = require('../field');\n\nmodule.exports = function(encoding, stats) {\n  return {\n    opacity: estimateOpacity(encoding, stats),\n    colorRange: colorRange(encoding, stats)\n  };\n};\n\nfunction colorRange(encoding, stats){\n  if (encoding.has(COLOR) && encoding.isDimension(COLOR)) {\n    var cardinality = encoding.cardinality(COLOR, stats);\n    if (cardinality <= 10) {\n      return \"category10\";\n    } else {\n      return \"category20\";\n    }\n    // TODO can vega interpolate range for ordinal scale?\n  }\n  return null;\n}\n\nfunction estimateOpacity(encoding,stats) {\n  if (!stats) {\n    return 1;\n  }\n\n  var numPoints = 0;\n\n  if (encoding.isAggregate()) { // aggregate plot\n    numPoints = 1;\n\n    //  get number of points in each \"cell\"\n    //  by calculating product of cardinality\n    //  for each non faceting and non-ordinal X / Y fields\n    //  note that ordinal x,y are not include since we can\n    //  consider that ordinal x are subdividing the cell into subcells anyway\n    encoding.forEach(function(field, encType) {\n\n      if (encType !== ROW && encType !== COL &&\n          !((encType === X || encType === Y) &&\n          vlfield.isOrdinalScale(field, true))\n        ) {\n        numPoints *= encoding.cardinality(encType, stats);\n      }\n    });\n\n  } else { // raw plot\n    numPoints = stats.count;\n\n    // small multiples divide number of points\n    var numMultiples = 1;\n    if (encoding.has(ROW)) {\n      numMultiples *= encoding.cardinality(ROW, stats);\n    }\n    if (encoding.has(COL)) {\n      numMultiples *= encoding.cardinality(COL, stats);\n    }\n    numPoints /= numMultiples;\n  }\n\n  var opacity = 0;\n  if (numPoints < 20) {\n    opacity = 1;\n  } else if (numPoints < 200) {\n    opacity = 0.7;\n  } else if (numPoints < 1000 || encoding.is('tick')) {\n    opacity = 0.6;\n  } else {\n    opacity = 0.3;\n  }\n\n  return opacity;\n}\n\n\n},{\"../field\":31,\"../globals\":32}],25:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar groupdef = require('./group').def;\n\nmodule.exports = subfaceting;\n\nfunction subfaceting(group, mdef, details, stack, encoding) {\n  var m = group.marks,\n    g = groupdef('subfacet', {marks: m});\n\n  group.marks = [g];\n  g.from = mdef.from;\n  delete mdef.from;\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: 'facet', keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: 'sort', by: encoding.field(COLOR)});\n  }\n}\n\n},{\"../globals\":32,\"./group\":17}],26:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar groupdef = require('./group').def,\n  vlfield = require('../field');\n\nmodule.exports = template;\n\nfunction template(encoding, layout, stats) {\n  // jshint unused:false\n\n  var data = {name: RAW, format: {}},\n    table = {name: TABLE, source: RAW},\n    dataUrl = encoding.data('url'),\n    dataType = encoding.data('formatType'),\n    values = encoding.data('values');\n\n  if (encoding.hasValues()) {\n    data.values = values;\n  } else {\n    data.url = dataUrl;\n    data.format.type = dataType;\n  }\n\n  encoding.forEach(function(field, encType) {\n    var name;\n    if (field.type == T) {\n      data.format.parse = data.format.parse || {};\n      data.format.parse[field.name] = 'date';\n    } else if (field.type == Q) {\n      data.format.parse = data.format.parse || {};\n      if (vlfield.isCount(field)) {\n        name = 'count';\n      } else {\n        name = field.name;\n      }\n      data.format.parse[name] = 'number';\n    }\n  });\n\n  return {\n    width: layout.width,\n    height: layout.height,\n    padding: 'auto',\n    data: [data, table],\n    marks: [groupdef('cell', {\n      width: layout.cellWidth ? {value: layout.cellWidth} : undefined,\n      height: layout.cellHeight ? {value: layout.cellHeight} : undefined\n    })]\n  };\n}\n\n},{\"../field\":31,\"../globals\":32,\"./group\":17}],27:[function(require,module,exports){\n'use strict';\n\nvar util = require('../util');\n\nmodule.exports = time;\n\nfunction time(spec, encoding, opt) {\n  // jshint unused:false\n  var timeFields = {}, timeFn = {};\n\n  // find unique formula transformation and bin function\n  encoding.forEach(function(field, encType) {\n    if (field.type === T && field.fn) {\n      timeFields[encoding.field(encType)] = {\n        field: field,\n        encType: encType\n      };\n      timeFn[field.fn] = true;\n    }\n  });\n\n  // add formula transform\n  var data = spec.data[1],\n    transform = data.transform = data.transform || [];\n\n  for (var f in timeFields) {\n    var tf = timeFields[f];\n    time.transform(transform, encoding, tf.encType, tf.field);\n  }\n\n  // add scales\n  var scales = spec.scales = spec.scales || [];\n  for (var fn in timeFn) {\n    time.scale(scales, fn, encoding);\n  }\n  return spec;\n}\n\ntime.cardinality = function(field, stats, filterNull, type) {\n  var fn = field.fn;\n  switch (fn) {\n    case 'seconds': return 60;\n    case 'minutes': return 60;\n    case 'hours': return 24;\n    case 'day': return 7;\n    case 'date': return 31;\n    case 'month': return 12;\n    case 'year':\n      var stat = stats[field.name],\n        yearstat = stats['year_'+field.name];\n\n      if (!yearstat) { return null; }\n\n      return yearstat.distinct -\n        (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n  }\n\n  return null;\n};\n\nfunction fieldFn(func, field) {\n  return 'utc' + func + '(d.data.'+ field.name +')';\n}\n\n/**\n * @return {String} date binning formula of the given field\n */\ntime.formula = function(field) {\n  return fieldFn(field.fn, field);\n};\n\n/** add formula transforms to data */\ntime.transform = function(transform, encoding, encType, field) {\n  transform.push({\n    type: 'formula',\n    field: encoding.field(encType),\n    expr: time.formula(field)\n  });\n};\n\n/** append custom time scales for axis label */\ntime.scale = function(scales, fn, encoding) {\n  var labelLength = encoding.config('timeScaleLabelLength');\n  // TODO add option for shorter scale / custom range\n  switch (fn) {\n    case 'day':\n      scales.push({\n        name: 'time-'+fn,\n        type: 'ordinal',\n        domain: util.range(0, 7),\n        range: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].map(\n          function(s) { return s.substr(0, labelLength);}\n        )\n      });\n      break;\n    case 'month':\n      scales.push({\n        name: 'time-'+fn,\n        type: 'ordinal',\n        domain: util.range(0, 12),\n        range: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'].map(\n            function(s) { return s.substr(0, labelLength);}\n          )\n      });\n      break;\n  }\n};\n\ntime.isOrdinalFn = function(fn) {\n  switch (fn) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'day':\n    case 'date':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\ntime.scale.type = function(fn, name) {\n  if (name === COLOR) {\n    return 'linear'; // this has order\n  }\n\n  return time.isOrdinalFn(fn) || name === COL || name === ROW ? 'ordinal' : 'linear';\n};\n\ntime.scale.domain = function(fn, name) {\n  var isColor = name === COLOR;\n  switch (fn) {\n    case 'seconds':\n    case 'minutes': return isColor ? [0,59] : util.range(0, 60);\n    case 'hours': return isColor ? [0,23] : util.range(0, 24);\n    case 'day': return isColor ? [0,6] : util.range(0, 7);\n    case 'date': return isColor ? [1,31] : util.range(1, 32);\n    case 'month': return isColor ? [0,11] : util.range(0, 12);\n  }\n  return null;\n};\n\n/** whether a particular time function has custom scale for labels implemented in time.scale */\ntime.hasScale = function(fn) {\n  switch (fn) {\n    case 'day':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\n\n\n},{\"../util\":35}],28:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, ALPHA, TEXT, DETAIL];\n\nconsts.dataTypes = {'O': O, 'Q': Q, 'T': T};\n\nconsts.dataTypeNames = ['O', 'Q', 'T'].reduce(function(r, x) {\n  r[consts.dataTypes[x]] = x;\n  return r;\n},{});\n\nconsts.shorthand = {\n  delim:  '|',\n  assign: '=',\n  type:   ',',\n  func:   '_'\n};\n\n},{\"./globals\":32}],29:[function(require,module,exports){\n'use strict';\n\nvar vldata = module.exports = {};\n\n/** Mapping from datalib's inferred type to Vega-lite's type */\nvldata.types = {\n  'boolean': 'O',\n  'number': 'Q',\n  'integer': 'Q',\n  'date': 'T',\n  'string': 'O'\n};\n\n\n},{}],30:[function(require,module,exports){\n// utility for enc\n\n'use strict';\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  vlfield = require('./field'),\n  util = require('./util'),\n  schema = require('./schema/schema'),\n  encTypes = schema.encTypes;\n\nvar vlenc = module.exports = {};\n\nvlenc.countRetinal = function(enc) {\n  var count = 0;\n  if (enc.color) count++;\n  if (enc.alpha) count++;\n  if (enc.size) count++;\n  if (enc.shape) count++;\n  return count;\n};\n\nvlenc.has = function(enc, encType) {\n  var fieldDef = enc && enc[encType];\n  return fieldDef && fieldDef.name;\n};\n\nvlenc.isAggregate = function(enc) {\n  for (var k in enc) {\n    if (vlenc.has(enc, k) && enc[k].aggr) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvlenc.forEach = function(enc, f) {\n  var i = 0;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      f(enc[k], k, i++);\n    }\n  });\n};\n\nvlenc.map = function(enc, f) {\n  var arr = [];\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      arr.push(f(enc[k], k, enc));\n    }\n  });\n  return arr;\n};\n\nvlenc.reduce = function(enc, f, init) {\n  var r = init;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      r = f(r, enc[k], k,  enc);\n    }\n  });\n  return r;\n};\n\n/*\n * return key-value pairs of field name and list of fields of that field name\n */\nvlenc.fields = function(enc) {\n  return vlenc.reduce(enc, function (m, field) {\n    var fieldList = m[field.name] = m[field.name] || [],\n      containsType = fieldList.containsType = fieldList.containsType || {};\n\n    if (fieldList.indexOf(field) === -1) {\n      fieldList.push(field);\n      // augment the array with containsType.Q / O / T\n      containsType[field.type] = true;\n    }\n    return m;\n  }, {});\n};\n\nvlenc.shorthand = function(enc) {\n  return vlenc.map(enc, function(field, et) {\n    return et + c.assign + vlfield.shorthand(field);\n  }).join(c.delim);\n};\n\nvlenc.fromShorthand = function(shorthand, convertType) {\n  var enc = util.isArray(shorthand) ? shorthand : shorthand.split(c.delim);\n  return enc.reduce(function(m, e) {\n    var split = e.split(c.assign),\n        enctype = split[0].trim(),\n        field = split[1];\n\n    m[enctype] = vlfield.fromShorthand(field, convertType);\n    return m;\n  }, {});\n};\n},{\"./consts\":28,\"./field\":31,\"./schema/schema\":33,\"./util\":35}],31:[function(require,module,exports){\n'use strict';\n\n// utility for field\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compile/time'),\n  util = require('./util'),\n  schema = require('./schema/schema');\n\nvar vlfield = module.exports = {};\n\nvlfield.shorthand = function(f) {\n  var c = consts.shorthand;\n  return (f.aggr ? f.aggr + c.func : '') +\n    (f.fn ? f.fn + c.func : '') +\n    (f.bin ? 'bin' + c.func : '') +\n    (f.name || '') + c.type +\n    (consts.dataTypeNames[f.type] || f.type);\n};\n\nvlfield.shorthands = function(fields, delim) {\n  delim = delim || c.delim;\n  return fields.map(vlfield.shorthand).join(delim);\n};\n\nvlfield.fromShorthand = function(shorthand, convertType) {\n  var split = shorthand.split(c.type), i;\n  var o = {\n    name: split[0].trim(),\n    type: convertType ? consts.dataTypes[split[1].trim()] : split[1].trim()\n  };\n\n  // check aggregate type\n  for (i in schema.aggr.enum) {\n    var a = schema.aggr.enum[i];\n    if (o.name.indexOf(a + '_') === 0) {\n      o.name = o.name.substr(a.length + 1);\n      if (a == 'count' && o.name.length === 0) o.name = '*';\n      o.aggr = a;\n      break;\n    }\n  }\n\n  // check time fn\n  for (i in schema.timefns) {\n    var f = schema.timefns[i];\n    if (o.name && o.name.indexOf(f + '_') === 0) {\n      o.name = o.name.substr(o.length + 1);\n      o.fn = f;\n      break;\n    }\n  }\n\n  // check bin\n  if (o.name && o.name.indexOf('bin_') === 0) {\n    o.name = o.name.substr(4);\n    o.bin = true;\n  }\n\n  return o;\n};\n\nvar typeOrder = {\n  O: 0,\n  G: 1,\n  T: 2,\n  Q: 3\n};\n\nvlfield.order = {};\n\nvlfield.order.type = function(field) {\n  if (field.aggr==='count') return 4;\n  return typeOrder[field.type];\n};\n\nvlfield.order.typeThenName = function(field) {\n  return vlfield.order.type(field) + '_' + field.name.toLowerCase();\n};\n\nvlfield.order.original = function() {\n  return 0; // no swap will occur\n};\n\nvlfield.order.name = function(field) {\n  return field.name;\n};\n\nvlfield.order.typeThenCardinality = function(field, stats){\n  return stats[field.name].distinct;\n};\n\n// FIXME refactor\nvlfield.isType = function (fieldDef, type) {\n  return (fieldDef.type & type) > 0;\n};\n\nvlfield.isType.byCode = vlfield.isType;\n\nvlfield.isType.byName = function (field, type) {\n  return field.type === consts.dataTypeNames[type];\n};\n\n\nfunction getIsType(useTypeCode) {\n  return useTypeCode ? vlfield.isType.byCode : vlfield.isType.byName;\n}\n\nvlfield.isType.get = getIsType; //FIXME\n\n/*\n * Most fields that use ordinal scale are dimensions.\n * However, YEAR(T), YEARMONTH(T) use time scale, not ordinal but are dimensions too.\n */\nvlfield.isOrdinalScale = function(field, useTypeCode /*optional*/) {\n  var isType = getIsType(useTypeCode);\n  return  isType(field, O) || field.bin ||\n    ( isType(field, T) && field.fn && time.isOrdinalFn(field.fn) );\n};\n\nfunction isDimension(field, useTypeCode /*optional*/) {\n  var isType = getIsType(useTypeCode);\n  return  isType(field, O) || !!field.bin ||\n    ( isType(field, T) && !!field.fn );\n}\n\n/**\n * For encoding, use encoding.isDimension() to avoid confusion.\n * Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.isDimension = function(field, useTypeCode /*optional*/) {\n  return field && isDimension(field, useTypeCode);\n};\n\nvlfield.isMeasure = function(field, useTypeCode) {\n  return field && !isDimension(field, useTypeCode);\n};\n\nvlfield.role = function(field) {\n  return isDimension(field) ? 'dimension' : 'measure';\n};\n\nvlfield.count = function() {\n  return {name:'*', aggr: 'count', type:'Q', displayName: vlfield.count.displayName};\n};\n\nvlfield.count.displayName = 'Number of Records';\n\nvlfield.isCount = function(field) {\n  return field.aggr === 'count';\n};\n\n/**\n * For encoding, use encoding.cardinality() to avoid confusion.  Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.cardinality = function(field, stats, filterNull, useTypeCode) {\n  // FIXME need to take filter into account\n\n  var stat = stats[field.name];\n  var isType = getIsType(useTypeCode),\n    type = useTypeCode ? consts.dataTypeNames[field.type] : field.type;\n\n  filterNull = filterNull || {};\n\n  if (field.bin) {\n    var bins = util.getbins(stat, field.bin.maxbins || schema.MAXBINS_DEFAULT);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  if (isType(field, T)) {\n    var cardinality = time.cardinality(field, stats, filterNull, type);\n    if(cardinality !== null) return cardinality;\n    //otherwise use calculation below\n  }\n  if (field.aggr) {\n    return 1;\n  }\n\n  // remove null\n  return stat.distinct -\n    (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n};\n\n},{\"./compile/time\":27,\"./consts\":28,\"./schema/schema\":33,\"./util\":35}],32:[function(require,module,exports){\n(function (global){\n'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.TABLE = 'table';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.ALPHA = 'alpha';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.O = 1;\ng.Q = 2;\ng.T = 4;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],33:[function(require,module,exports){\n// Package of defining Vega-lite Specification's json schema\n\"use strict\";\n\nvar schema = module.exports = {},\n  util = require('../util');\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: 'string',\n  enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\n};\n\nschema.aggr = {\n  type: 'string',\n  enum: ['avg', 'sum', 'min', 'max', 'count'],\n  supportedEnums: {\n    Q: ['avg', 'sum', 'min', 'max', 'count'],\n    O: [],\n    T: ['avg', 'min', 'max'],\n    '': ['count']\n  },\n  supportedTypes: {'Q': true, 'O': true, 'T': true, '': true}\n};\nschema.band = {\n  type: 'object',\n  properties: {\n    size: {\n      type: 'integer',\n      minimum: 0\n    },\n    padding: {\n      type: 'integer',\n      minimum: 0,\n      default: 1\n    }\n  }\n};\n\nschema.getSupportedRole = function(encType) {\n  return schema.schema.properties.enc.properties[encType].supportedRole;\n};\n\nschema.timefns = ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'];\n\nschema.defaultTimeFn = 'month';\n\nschema.fn = {\n  type: 'string',\n  enum: schema.timefns,\n  supportedTypes: {'T': true}\n};\n\n//TODO(kanitw): add other type of function here\n\nschema.scale_type = {\n  type: 'string',\n  enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\n  default: 'linear',\n  supportedTypes: {'Q': true}\n};\n\nschema.field = {\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string'\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nschema.MAXBINS_DEFAULT = 15;\n\nvar bin = {\n  type: ['boolean', 'object'],\n  default: false,\n  properties: {\n    maxbins: {\n      type: 'integer',\n      default: schema.MAXBINS_DEFAULT,\n      minimum: 2\n    }\n  },\n  supportedTypes: {'Q': true} // TODO: add 'O' after finishing #81\n};\n\nvar typicalField = merge(clone(schema.field), {\n  type: 'object',\n  properties: {\n    type: {\n      type: 'string',\n      enum: ['O', 'Q', 'T']\n    },\n    aggr: schema.aggr,\n    fn: schema.fn,\n    bin: bin,\n    scale: {\n      type: 'object',\n      properties: {\n        type: schema.scale_type,\n        reverse: {\n          type: 'boolean',\n          default: false,\n          supportedTypes: {'Q': true, 'T': true}\n        },\n        zero: {\n          type: 'boolean',\n          description: 'Include zero',\n          default: true,\n          supportedTypes: {'Q': true, 'T': true}\n        },\n        nice: {\n          type: 'string',\n          enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\n          supportedTypes: {'T': true}\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: 'object',\n  supportedRole: {\n    dimension: true\n  },\n  properties: {\n    type: {\n      type: 'string',\n      enum: ['O','Q', 'T'] // ordinal-only field supports Q when bin is applied and T when fn is applied.\n    },\n    fn: schema.fn,\n    bin: bin,\n    aggr: {\n      type: 'string',\n      enum: ['count'],\n      supportedTypes: {'O': true}\n    }\n  }\n});\n\nvar axisMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true},\n  properties: {\n    axis: {\n      type: 'object',\n      properties: {\n        grid: {\n          type: 'boolean',\n          default: true,\n          description: 'A flag indicate if gridlines should be created in addition to ticks.'\n        },\n        title: {\n          type: 'boolean',\n          default: true,\n          description: 'A title for the axis.'\n        },\n        titleOffset: {\n          type: 'integer',\n          default: undefined,  // auto\n          description: 'A title offset value for the axis.'\n        },\n        format: {\n          type: 'string',\n          default: undefined,  // auto\n          description: 'The formatting pattern for axis labels.'\n        },\n        maxLabelLength: {\n          type: 'integer',\n          default: 25,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar sortMixin = {\n  type: 'object',\n  properties: {\n    sort: {\n      type: 'array',\n      default: [],\n      items: {\n        type: 'object',\n        supportedTypes: {'O': true},\n        required: ['name', 'aggr'],\n        name: {\n          type: 'string'\n        },\n        aggr: {\n          type: 'string',\n          enum: ['avg', 'sum', 'min', 'max', 'count']\n        },\n        reverse: {\n          type: 'boolean',\n          default: false\n        }\n      }\n    }\n  }\n};\n\nvar bandMixin = {\n  type: 'object',\n  properties: {\n    band: schema.band\n  }\n};\n\nvar legendMixin = {\n  type: 'object',\n  properties: {\n    legend: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nvar textMixin = {\n  type: 'object',\n  supportedMarktypes: {'text': true},\n  properties: {\n    text: {\n      type: 'object',\n      properties: {\n        align: {\n          type: 'string',\n          default: 'left'\n        },\n        baseline: {\n          type: 'string',\n          default: 'middle'\n        },\n        margin: {\n          type: 'integer',\n          default: 4,\n          minimum: 0\n        }\n      }\n    },\n    font: {\n      type: 'object',\n      properties: {\n        weight: {\n          type: 'string',\n          enum: ['normal', 'bold'],\n          default: 'normal'\n        },\n        size: {\n          type: 'integer',\n          default: 10,\n          minimum: 0\n        },\n        family: {\n          type: 'string',\n          default: 'Helvetica Neue'\n        },\n        style: {\n          type: 'string',\n          default: 'normal',\n          enum: ['normal', 'italic']\n        }\n      }\n    }\n  }\n};\n\nvar sizeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, bar: true, circle: true, square: true, text: true},\n  properties: {\n    value: {\n      type: 'integer',\n      default: 30,\n      minimum: 0\n    }\n  }\n};\n\nvar colorMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'string',\n      role: 'color',\n      default: 'steelblue'\n    },\n    scale: {\n      type: 'object',\n      properties: {\n        range: {\n          type: ['string', 'array']\n        }\n      }\n    }\n  }\n};\n\nvar alphaMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'number',\n      default: undefined,  // auto\n      minimum: 0,\n      maximum: 1\n    }\n  }\n};\n\nvar shapeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, circle: true, square: true},\n  properties: {\n    value: {\n      type: 'string',\n      enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\n      default: 'circle'\n    }\n  }\n};\n\nvar detailMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, line: true, circle: true, square: true}\n};\n\nvar rowMixin = {\n  properties: {\n    height: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    grid: {\n      type: 'boolean',\n      default: true,\n      description: 'A flag indicate if gridlines should be created in addition to ticks.'\n    },\n  }\n};\n\nvar colMixin = {\n  properties: {\n    width: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    axis: {\n      properties: {\n        maxLabelLength: {\n          type: 'integer',\n          default: 12,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar facetMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, text: true},\n  properties: {\n    padding: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.1\n    }\n  }\n};\n\nvar requiredNameType = {\n  required: ['name', 'type']\n};\n\nvar multiRoleField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: true\n  }\n});\n\nvar quantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: 'ordinal-only' // using alpha / size to encoding category lead to order interpretation\n  }\n});\n\nvar onlyQuantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true\n  }\n});\n\nvar x = merge(clone(multiRoleField), axisMixin, bandMixin, requiredNameType, sortMixin);\nvar y = clone(x);\n\nvar facet = merge(clone(onlyOrdinalField), requiredNameType, facetMixin, sortMixin);\nvar row = merge(clone(facet), axisMixin, rowMixin);\nvar col = merge(clone(facet), axisMixin, colMixin);\n\nvar size = merge(clone(quantitativeField), legendMixin, sizeMixin, sortMixin);\nvar color = merge(clone(multiRoleField), legendMixin, colorMixin, sortMixin);\nvar alpha = merge(clone(quantitativeField), alphaMixin, sortMixin);\nvar shape = merge(clone(onlyOrdinalField), legendMixin, shapeMixin, sortMixin);\nvar detail = merge(clone(onlyOrdinalField), detailMixin, sortMixin);\n\n// we only put aggregated measure in pivot table\nvar text = merge(clone(onlyQuantitativeField), textMixin, sortMixin);\n\n// TODO add label\n\nvar filter = {\n  type: 'array',\n  items: {\n    type: 'object',\n    properties: {\n      operands: {\n        type: 'array',\n        items: {\n          type: ['string', 'boolean', 'integer', 'number']\n        }\n      },\n      operator: {\n        type: 'string',\n        enum: ['>', '>=', '=', '!=', '<', '<=', 'notNull']\n      }\n    }\n  }\n};\n\nvar data = {\n  type: 'object',\n  properties: {\n    // data source\n    formatType: {\n      type: 'string',\n      enum: ['json', 'csv'],\n      default: 'json'\n    },\n    url: {\n      type: 'string',\n      default: undefined\n    },\n    values: {\n      type: 'array',\n      description: 'Pass array of objects instead of a url to a file.',\n      items: {\n        type: 'object',\n        additionalProperties: true\n      }\n    }\n  }\n};\n\nvar config = {\n  type: 'object',\n  properties: {\n    // template\n    width: {\n      type: 'integer',\n      default: undefined\n    },\n    height: {\n      type: 'integer',\n      default: undefined\n    },\n    viewport: {\n      type: 'array',\n      items: {\n        type: 'integer'\n      },\n      default: undefined\n    },\n    gridColor: {\n      type: 'string',\n      role: 'color',\n      default: 'black'\n    },\n    gridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.08\n    },\n\n    // filter null\n    filterNull: {\n      type: 'object',\n      properties: {\n        O: {type:'boolean', default: false},\n        Q: {type:'boolean', default: true},\n        T: {type:'boolean', default: true}\n      }\n    },\n    toggleSort: {\n      type: 'string',\n      default: 'O'\n    },\n\n    // single plot\n    singleHeight: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    singleWidth: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    // band size\n    largeBandSize: {\n      type: 'integer',\n      default: 21,\n      minimum: 0\n    },\n    smallBandSize: {\n      //small multiples or single plot with high cardinality\n      type: 'integer',\n      default: 12,\n      minimum: 0\n    },\n    largeBandMaxCardinality: {\n      type: 'integer',\n      default: 10\n    },\n    // small multiples\n    cellPadding: {\n      type: 'number',\n      default: 0.1\n    },\n    cellGridColor: {\n      type: 'string',\n      role: 'color',\n      default: 'black'\n    },\n    cellGridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.15\n    },\n    cellBackgroundColor: {\n      type: 'string',\n      role: 'color',\n      default: 'transparent'\n    },\n    textCellWidth: {\n      type: 'integer',\n      default: 90,\n      minimum: 0\n    },\n\n    // marks\n    strokeWidth: {\n      type: 'integer',\n      default: 2,\n      minimum: 0\n    },\n\n    // scales\n    timeScaleLabelLength: {\n      type: 'integer',\n      default: 3,\n      minimum: 0\n    },\n    // other\n    characterWidth: {\n      type: 'integer',\n      default: 6\n    }\n  }\n};\n\n/** @type Object Schema of a vega-lite specification */\nschema.schema = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  description: 'Schema for Vega-lite specification',\n  type: 'object',\n  required: ['marktype', 'enc', 'data'],\n  properties: {\n    data: data,\n    marktype: schema.marktype,\n    enc: {\n      type: 'object',\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        alpha: alpha,\n        shape: shape,\n        text: text,\n        detail: detail\n      }\n    },\n    filter: filter,\n    config: config\n  }\n};\n\nschema.encTypes = util.keys(schema.schema.properties.enc.properties);\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function() {\n  return schema.util.instantiate(schema.schema);\n};\n\n},{\"../util\":35,\"./schemautil\":34}],34:[function(require,module,exports){\n'use strict';\n\nvar schemautil = module.exports = {},\n  util = require('../util');\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\nschemautil.extend = function(instance, schema) {\n  return schemautil.merge(schemautil.instantiate(schema), instance);\n};\n\n// instantiate a schema\nschemautil.instantiate = function(schema) {\n  var val;\n  if (schema === undefined) {\n    return undefined;\n  } else if ('default' in schema) {\n    val = schema.default;\n    return util.isObject(val) ? util.duplicate(val) : val;\n  } else if (schema.type === 'object') {\n    var instance = {};\n    for (var name in schema.properties) {\n      val = schemautil.instantiate(schema.properties[name]);\n      if (val !== undefined) {\n        instance[name] = val;\n      }\n    }\n    return instance;\n  } else if (schema.type === 'array') {\n    return [];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nschemautil.subtract = function(instance, defaults) {\n  var changes = {};\n  for (var prop in instance) {\n    var def = defaults[prop];\n    var ins = instance[prop];\n    // Note: does not properly subtract arrays\n    if (!defaults || def !== ins) {\n      if (typeof ins === 'object' && !util.isArray(ins) && def) {\n        var c = schemautil.subtract(ins, def);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else if (!util.isArray(ins) || ins.length > 0) {\n        changes[prop] = ins;\n      }\n    }\n  }\n  return changes;\n};\n\nschemautil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction merge(dest, src) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (var p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      merge(dest[p], src[p]);\n    }\n  }\n  return dest;\n}\n},{\"../util\":35}],35:[function(require,module,exports){\n'use strict';\n\nvar util = module.exports = require('datalib/src/util');\n\nutil.extend(util, require('datalib/src/generate'));\nutil.bin = require('datalib/src/bin');\n\nutil.isin = function(item, array) {\n  return array.indexOf(item) !== -1;\n};\n\nutil.forEach = function(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  } else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k , obj);\n    }\n  }\n};\n\nutil.reduce = function(obj, f, init, thisArg) {\n  if (obj.reduce) {\n    return obj.reduce.call(thisArg, f, init);\n  } else {\n    for (var k in obj) {\n      init = f.call(thisArg, init, obj[k], k, obj);\n    }\n    return init;\n  }\n};\n\nutil.map = function(obj, f, thisArg) {\n  if (obj.map) {\n    return obj.map.call(thisArg, f);\n  } else {\n    var output = [];\n    for (var k in obj) {\n      output.push( f.call(thisArg, obj[k], k, obj));\n    }\n  }\n};\n\nutil.any = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (f(arr[k], k, i++)) return true;\n  }\n  return false;\n};\n\nutil.all = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (!f(arr[k], k, i++)) return false;\n  }\n  return true;\n};\n\nutil.getbins = function(stats, maxbins) {\n  return util.bin({\n    min: stats.min,\n    max: stats.max,\n    maxbins: maxbins\n  });\n};\n\n/**\n * x[p[0]]...[p[n]] = val\n * @param noaugment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.setter = function(x, p, val, noaugment) {\n  for (var i=0; i<p.length-1; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  x[p[i]] = val;\n};\n\n\n/**\n * returns x[p[0]]...[p[n]]\n * @param augment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.getter = function(x, p, noaugment) {\n  for (var i=0; i<p.length; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  return x;\n};\n\nutil.error = function(msg) {\n  console.error('[VL Error]', msg);\n};\n\n\n},{\"datalib/src/bin\":4,\"datalib/src/generate\":6,\"datalib/src/util\":9}]},{},[1])(1)\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvdmwiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9iaW4uanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvZGF0ZS11bml0cy5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9nZW5lcmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9zdGF0cy5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9zdW1tYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL3V0aWwuanMiLCJzcmMvRW5jb2RpbmcuanMiLCJzcmMvY29tcGlsZS9hZ2dyZWdhdGUuanMiLCJzcmMvY29tcGlsZS9heGlzLmpzIiwic3JjL2NvbXBpbGUvYmluLmpzIiwic3JjL2NvbXBpbGUvY29tcGlsZS5qcyIsInNyYy9jb21waWxlL2ZhY2V0LmpzIiwic3JjL2NvbXBpbGUvZmlsdGVyLmpzIiwic3JjL2NvbXBpbGUvZ3JvdXAuanMiLCJzcmMvY29tcGlsZS9sYXlvdXQuanMiLCJzcmMvY29tcGlsZS9sZWdlbmQuanMiLCJzcmMvY29tcGlsZS9tYXJrcy5qcyIsInNyYy9jb21waWxlL3NjYWxlLmpzIiwic3JjL2NvbXBpbGUvc29ydC5qcyIsInNyYy9jb21waWxlL3N0YWNrLmpzIiwic3JjL2NvbXBpbGUvc3R5bGUuanMiLCJzcmMvY29tcGlsZS9zdWJmYWNldC5qcyIsInNyYy9jb21waWxlL3RlbXBsYXRlLmpzIiwic3JjL2NvbXBpbGUvdGltZS5qcyIsInNyYy9jb25zdHMuanMiLCJzcmMvZGF0YS5qcyIsInNyYy9lbmMuanMiLCJzcmMvZmllbGQuanMiLCJzcmMvZ2xvYmFscy5qcyIsInNyYy9zY2hlbWEvc2NoZW1hLmpzIiwic3JjL3NjaGVtYS9zY2hlbWF1dGlsLmpzIiwic3JjL3V0aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL2dsb2JhbHMnKTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgICBjb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0cycpO1xuXG52YXIgdmwgPSB7fTtcblxudXRpbC5leHRlbmQodmwsIGNvbnN0cywgdXRpbCk7XG5cbnZsLkVuY29kaW5nID0gcmVxdWlyZSgnLi9FbmNvZGluZycpO1xudmwuY29tcGlsZSA9IHJlcXVpcmUoJy4vY29tcGlsZS9jb21waWxlJyk7XG52bC5kYXRhID0gcmVxdWlyZSgnLi9kYXRhJyk7XG52bC5maWVsZCA9IHJlcXVpcmUoJy4vZmllbGQnKTtcbnZsLmVuYyA9IHJlcXVpcmUoJy4vZW5jJyk7XG52bC5zY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYS9zY2hlbWEnKTtcbnZsLnRvU2hvcnRoYW5kID0gdmwuRW5jb2Rpbmcuc2hvcnRoYW5kO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZsOyIsbnVsbCwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50UXVldWU7XG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtpXSgpO1xuICAgICAgICB9XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbn1cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgcXVldWUucHVzaChmdW4pO1xuICAgIGlmICghZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgdW5pdHMgPSByZXF1aXJlKCcuL2RhdGUtdW5pdHMnKTtcbnZhciBFUFNJTE9OID0gMWUtMTU7XG5cbmZ1bmN0aW9uIGJpbihvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gIC8vIGRldGVybWluZSByYW5nZVxuICB2YXIgbWF4YiA9IG9wdC5tYXhiaW5zIHx8IDE1LFxuICAgICAgYmFzZSA9IG9wdC5iYXNlIHx8IDEwLFxuICAgICAgbG9nYiA9IE1hdGgubG9nKGJhc2UpLFxuICAgICAgZGl2ID0gb3B0LmRpdiB8fCBbNSwgMl0sICAgICAgXG4gICAgICBtaW4gPSBvcHQubWluLFxuICAgICAgbWF4ID0gb3B0Lm1heCxcbiAgICAgIHNwYW4gPSBtYXggLSBtaW4sXG4gICAgICBzdGVwLCBsb2diLCBsZXZlbCwgbWluc3RlcCwgcHJlY2lzaW9uLCB2LCBpLCBlcHM7XG5cbiAgaWYgKG9wdC5zdGVwICE9IG51bGwpIHtcbiAgICAvLyBpZiBzdGVwIHNpemUgaXMgZXhwbGljaXRseSBnaXZlbiwgdXNlIHRoYXRcbiAgICBzdGVwID0gb3B0LnN0ZXA7XG4gIH0gZWxzZSBpZiAob3B0LnN0ZXBzKSB7XG4gICAgLy8gaWYgcHJvdmlkZWQsIGxpbWl0IGNob2ljZSB0byBhY2NlcHRhYmxlIHN0ZXAgc2l6ZXNcbiAgICBzdGVwID0gb3B0LnN0ZXBzW01hdGgubWluKFxuICAgICAgb3B0LnN0ZXBzLmxlbmd0aCAtIDEsXG4gICAgICBiaXNlY3Qob3B0LnN0ZXBzLCBzcGFuL21heGIsIDAsIG9wdC5zdGVwcy5sZW5ndGgpXG4gICAgKV07XG4gIH0gZWxzZSB7XG4gICAgLy8gZWxzZSB1c2Ugc3BhbiB0byBkZXRlcm1pbmUgc3RlcCBzaXplXG4gICAgbGV2ZWwgPSBNYXRoLmNlaWwoTWF0aC5sb2cobWF4YikgLyBsb2diKTtcbiAgICBtaW5zdGVwID0gb3B0Lm1pbnN0ZXAgfHwgMDtcbiAgICBzdGVwID0gTWF0aC5tYXgoXG4gICAgICBtaW5zdGVwLFxuICAgICAgTWF0aC5wb3coYmFzZSwgTWF0aC5yb3VuZChNYXRoLmxvZyhzcGFuKSAvIGxvZ2IpIC0gbGV2ZWwpXG4gICAgKTtcbiAgICBcbiAgICAvLyBpbmNyZWFzZSBzdGVwIHNpemUgaWYgdG9vIG1hbnkgYmluc1xuICAgIGRvIHsgc3RlcCAqPSBiYXNlOyB9IHdoaWxlIChNYXRoLmNlaWwoc3Bhbi9zdGVwKSA+IG1heGIpO1xuXG4gICAgLy8gZGVjcmVhc2Ugc3RlcCBzaXplIGlmIGFsbG93ZWRcbiAgICBmb3IgKGk9MDsgaTxkaXYubGVuZ3RoOyArK2kpIHtcbiAgICAgIHYgPSBzdGVwIC8gZGl2W2ldO1xuICAgICAgaWYgKHYgPj0gbWluc3RlcCAmJiBzcGFuIC8gdiA8PSBtYXhiKSBzdGVwID0gdjtcbiAgICB9XG4gIH1cblxuICAvLyB1cGRhdGUgcHJlY2lzaW9uLCBtaW4gYW5kIG1heFxuICB2ID0gTWF0aC5sb2coc3RlcCk7XG4gIHByZWNpc2lvbiA9IHYgPj0gMCA/IDAgOiB+figtdiAvIGxvZ2IpICsgMTtcbiAgZXBzID0gTWF0aC5wb3coYmFzZSwgLXByZWNpc2lvbiAtIDEpO1xuICBtaW4gPSBNYXRoLm1pbihtaW4sIE1hdGguZmxvb3IobWluIC8gc3RlcCArIGVwcykgKiBzdGVwKTtcbiAgbWF4ID0gTWF0aC5jZWlsKG1heCAvIHN0ZXApICogc3RlcDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBtaW4sXG4gICAgc3RvcDogIG1heCxcbiAgICBzdGVwOiAgc3RlcCxcbiAgICB1bml0OiAge3ByZWNpc2lvbjogcHJlY2lzaW9ufSxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgaW5kZXg6IGluZGV4XG4gIH07XG59O1xuXG5mdW5jdGlvbiBiaXNlY3QoYSwgeCwgbG8sIGhpKSB7XG4gIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgaWYgKHV0aWwuY21wKGFbbWlkXSwgeCkgPCAwKSB7IGxvID0gbWlkICsgMTsgfVxuICAgIGVsc2UgeyBoaSA9IG1pZDsgfVxuICB9XG4gIHJldHVybiBsbztcbn07XG5cbmZ1bmN0aW9uIHZhbHVlKHYpIHtcbiAgcmV0dXJuIHRoaXMuc3RlcCAqIE1hdGguZmxvb3IodiAvIHRoaXMuc3RlcCArIEVQU0lMT04pO1xufVxuXG5mdW5jdGlvbiBpbmRleCh2KSB7XG4gIHJldHVybiBNYXRoLmZsb29yKCh2IC0gdGhpcy5zdGFydCkgLyB0aGlzLnN0ZXAgKyBFUFNJTE9OKTtcbn1cblxuZnVuY3Rpb24gZGF0ZV92YWx1ZSh2KSB7XG4gIHJldHVybiB0aGlzLnVuaXQuZGF0ZSh2YWx1ZS5jYWxsKHRoaXMsIHYpKTtcbn1cblxuZnVuY3Rpb24gZGF0ZV9pbmRleCh2KSB7XG4gIHJldHVybiBpbmRleC5jYWxsKHRoaXMsIHRoaXMudW5pdC51bml0KHYpKTtcbn1cblxuYmluLmRhdGUgPSBmdW5jdGlvbihvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gIC8vIGZpbmQgdGltZSBzdGVwLCB0aGVuIGJpblxuICB2YXIgZG1pbiA9IG9wdC5taW4sXG4gICAgICBkbWF4ID0gb3B0Lm1heCxcbiAgICAgIG1heGIgPSBvcHQubWF4YmlucyB8fCAyMCxcbiAgICAgIG1pbmIgPSBvcHQubWluYmlucyB8fCA0LFxuICAgICAgc3BhbiA9ICgrZG1heCkgLSAoK2RtaW4pO1xuICAgICAgdW5pdCA9IG9wdC51bml0ID8gdW5pdHNbb3B0LnVuaXRdIDogdW5pdHMuZmluZChzcGFuLCBtaW5iLCBtYXhiKSxcbiAgICAgIGJpbnMgPSBiaW4oe1xuICAgICAgICBtaW46ICAgICB1bml0Lm1pbiAhPSBudWxsID8gdW5pdC5taW4gOiB1bml0LnVuaXQoZG1pbiksXG4gICAgICAgIG1heDogICAgIHVuaXQubWF4ICE9IG51bGwgPyB1bml0Lm1heCA6IHVuaXQudW5pdChkbWF4KSxcbiAgICAgICAgbWF4YmluczogbWF4YixcbiAgICAgICAgbWluc3RlcDogdW5pdC5taW5zdGVwLFxuICAgICAgICBzdGVwczogICB1bml0LnN0ZXBcbiAgICAgIH0pO1xuXG4gIGJpbnMudW5pdCA9IHVuaXQ7XG4gIGJpbnMuaW5kZXggPSBkYXRlX2luZGV4O1xuICBpZiAoIW9wdC5yYXcpIGJpbnMudmFsdWUgPSBkYXRlX3ZhbHVlO1xuICByZXR1cm4gYmlucztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmluO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIFNURVBTID0gW1xuICBbMzE1MzZlNiwgNV0sICAvLyAxLXllYXJcbiAgWzc3NzZlNiwgNF0sICAgLy8gMy1tb250aFxuICBbMjU5MmU2LCA0XSwgICAvLyAxLW1vbnRoXG4gIFsxMjA5NmU1LCAzXSwgIC8vIDItd2Vla1xuICBbNjA0OGU1LCAzXSwgICAvLyAxLXdlZWtcbiAgWzE3MjhlNSwgM10sICAgLy8gMi1kYXlcbiAgWzg2NGU1LCAzXSwgICAgLy8gMS1kYXlcbiAgWzQzMmU1LCAyXSwgICAgLy8gMTItaG91clxuICBbMjE2ZTUsIDJdLCAgICAvLyA2LWhvdXJcbiAgWzEwOGU1LCAyXSwgICAgLy8gMy1ob3VyXG4gIFszNmU1LCAyXSwgICAgIC8vIDEtaG91clxuICBbMThlNSwgMV0sICAgICAvLyAzMC1taW51dGVcbiAgWzllNSwgMV0sICAgICAgLy8gMTUtbWludXRlXG4gIFszZTUsIDFdLCAgICAgIC8vIDUtbWludXRlXG4gIFs2ZTQsIDFdLCAgICAgIC8vIDEtbWludXRlXG4gIFszZTQsIDBdLCAgICAgIC8vIDMwLXNlY29uZFxuICBbMTVlMywgMF0sICAgICAvLyAxNS1zZWNvbmRcbiAgWzVlMywgMF0sICAgICAgLy8gNS1zZWNvbmRcbiAgWzFlMywgMF0gICAgICAgLy8gMS1zZWNvbmRcbl07XG5cbnZhciBlbnRyaWVzID0gW1xuICB7XG4gICAgdHlwZTogXCJzZWNvbmRcIixcbiAgICBtaW5zdGVwOiAxLFxuICAgIGZvcm1hdDogXCIlWSAlYiAlLWQgJUg6JU06JVMuJUxcIixcbiAgICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoZCAqIDFlMyk7XG4gICAgfSxcbiAgICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gKCtkIC8gMWUzKTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcIm1pbnV0ZVwiLFxuICAgIG1pbnN0ZXA6IDEsXG4gICAgZm9ybWF0OiBcIiVZICViICUtZCAlSDolTVwiLFxuICAgIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShkICogNmU0KTtcbiAgICB9LFxuICAgIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiB+figrZCAvIDZlNCk7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdHlwZTogXCJob3VyXCIsXG4gICAgbWluc3RlcDogMSxcbiAgICBmb3JtYXQ6IFwiJVkgJWIgJS1kICVIOjAwXCIsXG4gICAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGQgKiAzNmU1KTtcbiAgICB9LFxuICAgIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiB+figrZCAvIDM2ZTUpO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZGF5XCIsXG4gICAgbWluc3RlcDogMSxcbiAgICBzdGVwOiBbMSwgN10sXG4gICAgZm9ybWF0OiBcIiVZICViICUtZFwiLFxuICAgIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShkICogODY0ZTUpO1xuICAgIH0sXG4gICAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIH5+KCtkIC8gODY0ZTUpO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHR5cGU6IFwibW9udGhcIixcbiAgICBtaW5zdGVwOiAxLFxuICAgIHN0ZXA6IFsxLCAzLCA2XSxcbiAgICBmb3JtYXQ6IFwiJWIgJVlcIixcbiAgICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMofn4oZCAvIDEyKSwgZCAlIDEyLCAxKSk7XG4gICAgfSxcbiAgICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgICBpZiAodXRpbC5pc051bWJlcihkKSkgZCA9IG5ldyBEYXRlKGQpO1xuICAgICAgcmV0dXJuIDEyICogZC5nZXRVVENGdWxsWWVhcigpICsgZC5nZXRVVENNb250aCgpO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHR5cGU6IFwieWVhclwiLFxuICAgIG1pbnN0ZXA6IDEsXG4gICAgZm9ybWF0OiBcIiVZXCIsXG4gICAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKGQsIDAsIDEpKTtcbiAgICB9LFxuICAgIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiAodXRpbC5pc051bWJlcihkKSA/IG5ldyBEYXRlKGQpIDogZCkuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICB9XG4gIH1cbl07XG5cbnZhciBtaW51dGVPZkhvdXIgPSB7XG4gIHR5cGU6IFwibWludXRlT2ZIb3VyXCIsXG4gIG1pbjogMCxcbiAgbWF4OiA1OSxcbiAgbWluc3RlcDogMSxcbiAgZm9ybWF0OiBcIiVNXCIsXG4gIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgMSwgMCwgZCkpO1xuICB9LFxuICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuICh1dGlsLmlzTnVtYmVyKGQpID8gbmV3IERhdGUoZCkgOiBkKS5nZXRVVENNaW51dGVzKCk7XG4gIH1cbn07XG5cbnZhciBob3VyT2ZEYXkgPSB7XG4gIHR5cGU6IFwiaG91ck9mRGF5XCIsXG4gIG1pbjogMCxcbiAgbWF4OiAyMyxcbiAgbWluc3RlcDogMSxcbiAgZm9ybWF0OiBcIiVIXCIsXG4gIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgMSwgZCkpO1xuICB9LFxuICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuICh1dGlsLmlzTnVtYmVyKGQpID8gbmV3IERhdGUoZCkgOiBkKS5nZXRVVENIb3VycygpO1xuICB9XG59O1xuXG52YXIgZGF5T2ZXZWVrID0ge1xuICB0eXBlOiBcImRheU9mV2Vla1wiLFxuICBtaW46IDAsXG4gIG1heDogNixcbiAgc3RlcDogWzFdLFxuICBmb3JtYXQ6IFwiJWFcIixcbiAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCAwLCA0ICsgZCkpO1xuICB9LFxuICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuICh1dGlsLmlzTnVtYmVyKGQpID8gbmV3IERhdGUoZCkgOiBkKS5nZXRVVENEYXkoKTtcbiAgfVxufTtcblxudmFyIGRheU9mTW9udGggPSB7XG4gIHR5cGU6IFwiZGF5T2ZNb250aFwiLFxuICBtaW46IDEsXG4gIG1heDogMzEsXG4gIHN0ZXA6IFsxXSxcbiAgZm9ybWF0OiBcIiUtZFwiLFxuICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIGQpKTtcbiAgfSxcbiAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiAodXRpbC5pc051bWJlcihkKSA/IG5ldyBEYXRlKGQpIDogZCkuZ2V0VVRDRGF0ZSgpO1xuICB9XG59O1xuXG52YXIgbW9udGhPZlllYXIgPSB7XG4gIHR5cGU6IFwibW9udGhPZlllYXJcIixcbiAgbWluOiAwLFxuICBtYXg6IDExLFxuICBzdGVwOiBbMV0sXG4gIGZvcm1hdDogXCIlYlwiLFxuICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIGQgJSAxMiwgMSkpO1xuICB9LFxuICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuICh1dGlsLmlzTnVtYmVyKGQpID8gbmV3IERhdGUoZCkgOiBkKS5nZXRVVENNb250aCgpO1xuICB9XG59O1xuXG52YXIgdW5pdHMgPSB7XG4gIFwic2Vjb25kXCI6ICAgICAgIGVudHJpZXNbMF0sXG4gIFwibWludXRlXCI6ICAgICAgIGVudHJpZXNbMV0sXG4gIFwiaG91clwiOiAgICAgICAgIGVudHJpZXNbMl0sXG4gIFwiZGF5XCI6ICAgICAgICAgIGVudHJpZXNbM10sXG4gIFwibW9udGhcIjogICAgICAgIGVudHJpZXNbNF0sXG4gIFwieWVhclwiOiAgICAgICAgIGVudHJpZXNbNV0sXG4gIFwibWludXRlT2ZIb3VyXCI6IG1pbnV0ZU9mSG91cixcbiAgXCJob3VyT2ZEYXlcIjogICAgaG91ck9mRGF5LFxuICBcImRheU9mV2Vla1wiOiAgICBkYXlPZldlZWssXG4gIFwiZGF5T2ZNb250aFwiOiAgIGRheU9mTW9udGgsXG4gIFwibW9udGhPZlllYXJcIjogIG1vbnRoT2ZZZWFyLFxuICBcInRpbWVzdGVwc1wiOiAgICBlbnRyaWVzXG59O1xuXG51bml0cy5maW5kID0gZnVuY3Rpb24oc3BhbiwgbWluYiwgbWF4Yikge1xuICB2YXIgaSwgbGVuLCBiaW5zLCBzdGVwID0gU1RFUFNbMF07XG5cbiAgZm9yIChpID0gMSwgbGVuID0gU1RFUFMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBzdGVwID0gU1RFUFNbaV07XG4gICAgaWYgKHNwYW4gPiBzdGVwWzBdKSB7XG4gICAgICBiaW5zID0gc3BhbiAvIHN0ZXBbMF07XG4gICAgICBpZiAoYmlucyA+IG1heGIpIHtcbiAgICAgICAgcmV0dXJuIGVudHJpZXNbU1RFUFNbaSAtIDFdWzFdXTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5zID49IG1pbmIpIHtcbiAgICAgICAgcmV0dXJuIGVudHJpZXNbc3RlcFsxXV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBlbnRyaWVzW1NURVBTW1NURVBTLmxlbmd0aCAtIDFdWzFdXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pdHM7XG4iLCJ2YXIgZ2VuID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuZ2VuLnJlcGVhdCA9IGZ1bmN0aW9uKHZhbCwgbikge1xuICB2YXIgYSA9IEFycmF5KG4pLCBpO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIGFbaV0gPSB2YWw7XG4gIHJldHVybiBhO1xufTtcblxuZ2VuLnplcm9zID0gZnVuY3Rpb24obikge1xuICByZXR1cm4gZ2VuLnJlcGVhdCgwLCBuKTtcbn07XG5cbmdlbi5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgIHN0ZXAgPSAxO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgc3RvcCA9IHN0YXJ0O1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgfVxuICBpZiAoKHN0b3AgLSBzdGFydCkgLyBzdGVwID09IEluZmluaXR5KSB0aHJvdyBuZXcgRXJyb3IoJ0luZmluaXRlIHJhbmdlJyk7XG4gIHZhciByYW5nZSA9IFtdLCBpID0gLTEsIGo7XG4gIGlmIChzdGVwIDwgMCkgd2hpbGUgKChqID0gc3RhcnQgKyBzdGVwICogKytpKSA+IHN0b3ApIHJhbmdlLnB1c2goaik7XG4gIGVsc2Ugd2hpbGUgKChqID0gc3RhcnQgKyBzdGVwICogKytpKSA8IHN0b3ApIHJhbmdlLnB1c2goaik7XG4gIHJldHVybiByYW5nZTtcbn07XG5cbmdlbi5yYW5kb20gPSB7fTtcblxuZ2VuLnJhbmRvbS51bmlmb3JtID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0bWF4ID0gbWluO1xuXHRcdG1pbiA9IDA7XG5cdH1cblx0dmFyIGQgPSBtYXggLSBtaW47XG5cdHZhciBmID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG1pbiArIGQgKiBNYXRoLnJhbmRvbSgpO1xuXHR9O1xuXHRmLnNhbXBsZXMgPSBmdW5jdGlvbihuKSB7IHJldHVybiBnZW4uemVyb3MobikubWFwKGYpOyB9O1xuXHRyZXR1cm4gZjtcbn07XG5cbmdlbi5yYW5kb20uaW50ZWdlciA9IGZ1bmN0aW9uKGEsIGIpIHtcblx0aWYgKGIgPT09IHVuZGVmaW5lZCkge1xuXHRcdGIgPSBhO1xuXHRcdGEgPSAwO1xuXHR9XG4gIHZhciBkID0gYiAtIGE7XG5cdHZhciBmID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGEgKyBNYXRoLmZsb29yKGQgKiBNYXRoLnJhbmRvbSgpKTtcblx0fTtcblx0Zi5zYW1wbGVzID0gZnVuY3Rpb24obikgeyByZXR1cm4gZ2VuLnplcm9zKG4pLm1hcChmKTsgfTtcblx0cmV0dXJuIGY7XG59O1xuXG5nZW4ucmFuZG9tLm5vcm1hbCA9IGZ1bmN0aW9uKG1lYW4sIHN0ZGV2KSB7XG5cdG1lYW4gPSBtZWFuIHx8IDA7XG5cdHN0ZGV2ID0gc3RkZXYgfHwgMTtcblx0dmFyIG5leHQgPSB1bmRlZmluZWQ7XG5cdHZhciBmID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHggPSAwLCB5ID0gMCwgcmRzLCBjO1xuXHRcdGlmIChuZXh0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHggPSBuZXh0O1xuXHRcdFx0bmV4dCA9IHVuZGVmaW5lZDtcblx0XHRcdHJldHVybiB4O1xuXHRcdH1cblx0XHRkbyB7XG5cdFx0XHR4ID0gTWF0aC5yYW5kb20oKSoyLTE7XG5cdFx0XHR5ID0gTWF0aC5yYW5kb20oKSoyLTE7XG5cdFx0XHRyZHMgPSB4KnggKyB5Knk7XG5cdFx0fSB3aGlsZSAocmRzID09IDAgfHwgcmRzID4gMSk7XG5cdFx0YyA9IE1hdGguc3FydCgtMipNYXRoLmxvZyhyZHMpL3Jkcyk7IC8vIEJveC1NdWxsZXIgdHJhbnNmb3JtXG5cdFx0bmV4dCA9IG1lYW4gKyB5KmMqc3RkZXY7XG5cdFx0cmV0dXJuIG1lYW4gKyB4KmMqc3RkZXY7XG5cdH07XG5cdGYuc2FtcGxlcyA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIGdlbi56ZXJvcyhuKS5tYXAoZik7IH07XG5cdHJldHVybiBmO1xufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGdlbiA9IHJlcXVpcmUoJy4vZ2VuZXJhdGUnKTtcbnZhciBzdGF0cyA9IHt9O1xuXG4vLyBDb2xsZWN0IHVuaXF1ZSB2YWx1ZXMgYW5kIGFzc29jaWF0ZWQgY291bnRzLlxuLy8gT3V0cHV0OiBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvYnNlcnZlZCBvcmRlclxuLy8gVGhlIGFycmF5IGluY2x1ZGVzIGFuIGFkZGl0aW9uYWwgJ2NvdW50cycgcHJvcGVydHksXG4vLyB3aGljaCBpcyBhIGhhc2ggZnJvbSB1bmlxdWUgdmFsdWVzIHRvIG9jY3VycmVuY2UgY291bnRzLlxuc3RhdHMudW5pcXVlID0gZnVuY3Rpb24odmFsdWVzLCBmLCByZXN1bHRzKSB7XG4gIGlmICghdXRpbC5pc0FycmF5KHZhbHVlcykgfHwgdmFsdWVzLmxlbmd0aD09PTApIHJldHVybiBbXTtcbiAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG4gIHZhciB1ID0ge30sIHYsIGk7XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgaW4gdSkge1xuICAgICAgdVt2XSArPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB1W3ZdID0gMTtcbiAgICAgIHJlc3VsdHMucHVzaCh2KTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0cy5jb3VudHMgPSB1O1xuICByZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIENvdW50IHRoZSBudW1iZXIgb2Ygbm9uLW51bGwgdmFsdWVzLlxuc3RhdHMuY291bnQgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgaWYgKCF1dGlsLmlzQXJyYXkodmFsdWVzKSB8fCB2YWx1ZXMubGVuZ3RoPT09MCkgcmV0dXJuIDA7XG4gIHZhciB2LCBpLCBjb3VudCA9IDA7XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgIT0gbnVsbCkgY291bnQgKz0gMTtcbiAgfVxuICByZXR1cm4gY291bnQ7XG59O1xuXG4vLyBDb3VudCB0aGUgbnVtYmVyIG9mIGRpc3RpbmN0IHZhbHVlcy5cbnN0YXRzLmNvdW50LmRpc3RpbmN0ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGlmICghdXRpbC5pc0FycmF5KHZhbHVlcykgfHwgdmFsdWVzLmxlbmd0aD09PTApIHJldHVybiAwO1xuICB2YXIgdSA9IHt9LCB2LCBpLCBjb3VudCA9IDA7XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgaW4gdSkgY29udGludWU7XG4gICAgdVt2XSA9IDE7XG4gICAgY291bnQgKz0gMTtcbiAgfVxuICByZXR1cm4gY291bnQ7XG59O1xuXG4vLyBDb3VudCB0aGUgbnVtYmVyIG9mIG51bGwgb3IgdW5kZWZpbmVkIHZhbHVlcy5cbnN0YXRzLmNvdW50Lm51bGxzID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGlmICghdXRpbC5pc0FycmF5KHZhbHVlcykgfHwgdmFsdWVzLmxlbmd0aD09PTApIHJldHVybiAwO1xuICB2YXIgdiwgaSwgY291bnQgPSAwO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2ID09IG51bGwpIGNvdW50ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbWVkaWFuIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5tZWRpYW4gPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgaWYgKCF1dGlsLmlzQXJyYXkodmFsdWVzKSB8fCB2YWx1ZXMubGVuZ3RoPT09MCkgcmV0dXJuIDA7XG4gIGlmIChmKSB2YWx1ZXMgPSB2YWx1ZXMubWFwKGYpO1xuICB2YWx1ZXMgPSB2YWx1ZXMuZmlsdGVyKHV0aWwuaXNOb3ROdWxsKS5zb3J0KHV0aWwuY21wKTtcbiAgdmFyIGhhbGYgPSBNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGgvMik7XG4gIGlmICh2YWx1ZXMubGVuZ3RoICUgMikge1xuICAgIHJldHVybiB2YWx1ZXNbaGFsZl07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh2YWx1ZXNbaGFsZi0xXSArIHZhbHVlc1toYWxmXSkgLyAyLjA7XG4gIH1cbn07XG5cbi8vIENvbXB1dGUgdGhlIHF1YW50aWxlIG9mIGEgc29ydGVkIGFycmF5IG9mIG51bWJlcnMuXG4vLyBBZGFwdGVkIGZyb20gdGhlIEQzLmpzIGltcGxlbWVudGF0aW9uLlxuc3RhdHMucXVhbnRpbGUgPSBmdW5jdGlvbih2YWx1ZXMsIGYsIHApIHtcbiAgaWYgKHAgPT09IHVuZGVmaW5lZCkgeyBwID0gZjsgZiA9IHV0aWwuaWRlbnRpdHk7IH1cbiAgdmFyIEggPSAodmFsdWVzLmxlbmd0aCAtIDEpICogcCArIDEsXG4gICAgICBoID0gTWF0aC5mbG9vcihIKSxcbiAgICAgIHYgPSArZih2YWx1ZXNbaCAtIDFdKSxcbiAgICAgIGUgPSBIIC0gaDtcbiAgcmV0dXJuIGUgPyB2ICsgZSAqIChmKHZhbHVlc1toXSkgLSB2KSA6IHY7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtZWFuIChhdmVyYWdlKSBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMubWVhbiA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBpZiAoIXV0aWwuaXNBcnJheSh2YWx1ZXMpIHx8IHZhbHVlcy5sZW5ndGg9PT0wKSByZXR1cm4gMDtcbiAgdmFyIG1lYW4gPSAwLCBkZWx0YSwgaSwgYywgdjtcbiAgZm9yIChpPTAsIGM9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodiAhPSBudWxsICYmICFpc05hTih2KSkge1xuICAgICAgZGVsdGEgPSB2IC0gbWVhbjtcbiAgICAgIG1lYW4gPSBtZWFuICsgZGVsdGEgLyAoKytjKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lYW47XG59O1xuXG4vLyBDb21wdXRlIHRoZSBzYW1wbGUgdmFyaWFuY2Ugb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLnZhcmlhbmNlID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGlmICghdXRpbC5pc0FycmF5KHZhbHVlcykgfHwgdmFsdWVzLmxlbmd0aD09PTApIHJldHVybiAwO1xuICB2YXIgbWVhbiA9IDAsIE0yID0gMCwgZGVsdGEsIGksIGMsIHY7XG4gIGZvciAoaT0wLCBjPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgIT0gbnVsbCAmJiAhaXNOYU4odikpIHtcbiAgICAgIGRlbHRhID0gdiAtIG1lYW47XG4gICAgICBtZWFuID0gbWVhbiArIGRlbHRhIC8gKCsrYyk7XG4gICAgICBNMiA9IE0yICsgZGVsdGEgKiAodiAtIG1lYW4pO1xuICAgIH1cbiAgfVxuICBNMiA9IE0yIC8gKGMgLSAxKTtcbiAgcmV0dXJuIE0yO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2FtcGxlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMuc3RkZXYgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgcmV0dXJuIE1hdGguc3FydChzdGF0cy52YXJpYW5jZSh2YWx1ZXMsIGYpKTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIFBlYXJzb24gbW9kZSBza2V3bmVzcyAoKG1lZGlhbi1tZWFuKS9zdGRldikgb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLm1vZGVza2V3ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHZhciBhdmcgPSBzdGF0cy5tZWFuKHZhbHVlcywgZiksXG4gICAgICBtZWQgPSBzdGF0cy5tZWRpYW4odmFsdWVzLCBmKSxcbiAgICAgIHN0ZCA9IHN0YXRzLnN0ZGV2KHZhbHVlcywgZik7XG4gIHJldHVybiBzdGQgPT09IDAgPyAwIDogKGF2ZyAtIG1lZCkgLyBzdGQ7XG59O1xuXG4vLyBGaW5kIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG9mIGFuIGFycmF5IG9mIHZhbHVlcy5cbnN0YXRzLmV4dGVudCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICB2YXIgYSwgYiwgdiwgaSwgbiA9IHZhbHVlcy5sZW5ndGg7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzTm90TnVsbCh2KSkgeyBhID0gYiA9IHY7IGJyZWFrOyB9XG4gIH1cbiAgZm9yICg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNOb3ROdWxsKHYpKSB7XG4gICAgICBpZiAodiA8IGEpIGEgPSB2O1xuICAgICAgaWYgKHYgPiBiKSBiID0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFthLCBiXTtcbn07XG5cbi8vIEZpbmQgdGhlIGludGVnZXIgaW5kaWNlcyBvZiB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZXMuXG5zdGF0cy5leHRlbnQuaW5kZXggPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgdmFyIGEsIGIsIHgsIHksIHYsIGksIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc05vdE51bGwodikpIHsgYSA9IGIgPSB2OyB4ID0geSA9IGk7IGJyZWFrOyB9XG4gIH1cbiAgZm9yICg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNOb3ROdWxsKHYpKSB7XG4gICAgICBpZiAodiA8IGEpIHsgYSA9IHY7IHggPSBpOyB9XG4gICAgICBpZiAodiA+IGIpIHsgYiA9IHY7IHkgPSBpOyB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbeCwgeV07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXG5zdGF0cy5kb3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIHN1bSA9IDAsIGksIHY7XG4gIGlmICghYikge1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoICE9PSBhLmxlbmd0aCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJBcnJheSBsZW5ndGhzIG11c3QgbWF0Y2guXCIpO1xuICAgIH1cbiAgICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHYgPSB2YWx1ZXNbaV0gKiBhW2ldO1xuICAgICAgaWYgKCFpc05hTih2KSkgc3VtICs9IHY7XG4gICAgfVxuICB9IGVsc2UgeyAgXG4gICAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2ID0gYSh2YWx1ZXNbaV0pICogYih2YWx1ZXNbaV0pO1xuICAgICAgaWYgKCFpc05hTih2KSkgc3VtICs9IHY7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdW07XG59O1xuXG4vLyBDb21wdXRlIGFzY2VuZGluZyByYW5rIHNjb3JlcyBmb3IgYW4gYXJyYXkgb2YgdmFsdWVzLlxuLy8gVGllcyBhcmUgYXNzaWduZWQgdGhlaXIgY29sbGVjdGl2ZSBtZWFuIHJhbmsuXG5zdGF0cy5yYW5rID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHZhciBhID0gdmFsdWVzLm1hcChmdW5jdGlvbih2LCBpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZHg6IGksXG4gICAgICAgIHZhbDogKGYgPyBmKHYpIDogdilcbiAgICAgIH07XG4gICAgfSlcbiAgICAuc29ydCh1dGlsLmNvbXBhcmF0b3IoXCJ2YWxcIikpO1xuXG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIHIgPSBBcnJheShuKSxcbiAgICAgIHRpZSA9IC0xLCBwID0ge30sIGksIHYsIG11O1xuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHYgPSBhW2ldLnZhbDtcbiAgICBpZiAodGllIDwgMCAmJiBwID09PSB2KSB7XG4gICAgICB0aWUgPSBpIC0gMTtcbiAgICB9IGVsc2UgaWYgKHRpZSA+IC0xICYmIHAgIT09IHYpIHtcbiAgICAgIG11ID0gMSArIChpLTEgKyB0aWUpIC8gMjtcbiAgICAgIGZvciAoOyB0aWU8aTsgKyt0aWUpIHJbYVt0aWVdLmlkeF0gPSBtdTtcbiAgICAgIHRpZSA9IC0xO1xuICAgIH1cbiAgICByW2FbaV0uaWR4XSA9IGkgKyAxO1xuICAgIHAgPSB2O1xuICB9XG5cbiAgaWYgKHRpZSA+IC0xKSB7XG4gICAgbXUgPSAxICsgKG4tMSArIHRpZSkgLyAyO1xuICAgIGZvciAoOyB0aWU8bjsgKyt0aWUpIHJbYVt0aWVdLmlkeF0gPSBtdTtcbiAgfVxuXG4gIHJldHVybiByO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2FtcGxlIFBlYXJzb24gcHJvZHVjdC1tb21lbnQgY29ycmVsYXRpb24gb2YgdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuc3RhdHMuY29yID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciBmbiA9IGI7XG4gIGIgPSBmbiA/IHZhbHVlcy5tYXAoYikgOiBhLFxuICBhID0gZm4gPyB2YWx1ZXMubWFwKGEpIDogdmFsdWVzO1xuXG4gIHZhciBkb3QgPSBzdGF0cy5kb3QoYSwgYiksXG4gICAgICBtdWEgPSBzdGF0cy5tZWFuKGEpLFxuICAgICAgbXViID0gc3RhdHMubWVhbihiKSxcbiAgICAgIHNkYSA9IHN0YXRzLnN0ZGV2KGEpLFxuICAgICAgc2RiID0gc3RhdHMuc3RkZXYoYiksXG4gICAgICBuID0gdmFsdWVzLmxlbmd0aDtcblxuICByZXR1cm4gKGRvdCAtIG4qbXVhKm11YikgLyAoKG4tMSkgKiBzZGEgKiBzZGIpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgU3BlYXJtYW4gcmFuayBjb3JyZWxhdGlvbiBvZiB0d28gYXJyYXlzIG9mIHZhbHVlcy5cbnN0YXRzLmNvci5yYW5rID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciByYSA9IGIgPyBzdGF0cy5yYW5rKHZhbHVlcywgYSkgOiBzdGF0cy5yYW5rKHZhbHVlcyksXG4gICAgICByYiA9IGIgPyBzdGF0cy5yYW5rKHZhbHVlcywgYikgOiBzdGF0cy5yYW5rKGEpLFxuICAgICAgbiA9IHZhbHVlcy5sZW5ndGgsIGksIHMsIGQ7XG5cbiAgZm9yIChpPTAsIHM9MDsgaTxuOyArK2kpIHtcbiAgICBkID0gcmFbaV0gLSByYltpXTtcbiAgICBzICs9IGQgKiBkO1xuICB9XG5cbiAgcmV0dXJuIDEgLSA2KnMgLyAobiAqIChuKm4tMSkpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgZGlzdGFuY2UgY29ycmVsYXRpb24gb2YgdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9jb3JyZWxhdGlvblxuc3RhdHMuY29yLmRpc3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIFggPSBiID8gdmFsdWVzLm1hcChhKSA6IHZhbHVlcyxcbiAgICAgIFkgPSBiID8gdmFsdWVzLm1hcChiKSA6IGE7XG5cbiAgdmFyIEEgPSBzdGF0cy5kaXN0Lm1hdChYKSxcbiAgICAgIEIgPSBzdGF0cy5kaXN0Lm1hdChZKSxcbiAgICAgIG4gPSBBLmxlbmd0aCxcbiAgICAgIGksIGFhLCBiYiwgYWI7XG5cbiAgZm9yIChpPTAsIGFhPTAsIGJiPTAsIGFiPTA7IGk8bjsgKytpKSB7XG4gICAgYWEgKz0gQVtpXSpBW2ldO1xuICAgIGJiICs9IEJbaV0qQltpXTtcbiAgICBhYiArPSBBW2ldKkJbaV07XG4gIH1cblxuICByZXR1cm4gTWF0aC5zcXJ0KGFiIC8gTWF0aC5zcXJ0KGFhKmJiKSk7XG59O1xuXG4vLyBDb21wdXRlIHRoZSB2ZWN0b3IgZGlzdGFuY2UgYmV0d2VlbiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXG4vLyBEZWZhdWx0IGlzIEV1Y2xpZGVhbiAoZXhwPTIpIGRpc3RhbmNlLCBjb25maWd1cmFibGUgdmlhIGV4cCBhcmd1bWVudC5cbnN0YXRzLmRpc3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIGV4cCkge1xuICB2YXIgZiA9IHV0aWwuaXNGdW5jdGlvbihiKSxcbiAgICAgIFggPSB2YWx1ZXMsXG4gICAgICBZID0gZiA/IHZhbHVlcyA6IGEsXG4gICAgICBlID0gZiA/IGV4cCA6IGIsXG4gICAgICBuID0gdmFsdWVzLmxlbmd0aCwgcyA9IDAsIGQsIGk7XG5cbiAgaWYgKGUgPT09IDIgfHwgZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgICBkID0gZiA/IChhKFhbaV0pLWIoWVtpXSkpIDogKFhbaV0tWVtpXSk7XG4gICAgICBzICs9IGQqZDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguc3FydChzKTsgXG4gIH0gZWxzZSB7XG4gICAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgICBkID0gTWF0aC5hYnMoZiA/IChhKFhbaV0pLWIoWVtpXSkpIDogKFhbaV0tWVtpXSkpO1xuICAgICAgcyArPSBNYXRoLnBvdyhkLCBlKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgucG93KHMsIDEvZSk7XG4gIH1cbn07XG5cbi8vIENvbnN0cnVjdCBhIG1lYW4tY2VudGVyZWQgZGlzdGFuY2UgbWF0cml4IGZvciBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMuZGlzdC5tYXQgPSBmdW5jdGlvbihYKSB7XG4gIHZhciBuID0gWC5sZW5ndGgsXG4gICAgICBtID0gbipuLFxuICAgICAgQSA9IEFycmF5KG0pLFxuICAgICAgUiA9IGdlbi56ZXJvcyhuKSxcbiAgICAgIE0gPSAwLCB2LCBpLCBqO1xuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIEFbaSpuK2ldID0gMDtcbiAgICBmb3IgKGo9aSsxOyBqPG47ICsraikge1xuICAgICAgQVtpKm4ral0gPSAodiA9IE1hdGguYWJzKFhbaV0gLSBYW2pdKSk7XG4gICAgICBBW2oqbitpXSA9IHY7XG4gICAgICBSW2ldICs9IHY7XG4gICAgICBSW2pdICs9IHY7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgTSArPSBSW2ldO1xuICAgIFJbaV0gLz0gbjtcbiAgfVxuICBNIC89IG07XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgZm9yIChqPWk7IGo8bjsgKytqKSB7XG4gICAgICBBW2kqbitqXSArPSBNIC0gUltpXSAtIFJbal07XG4gICAgICBBW2oqbitpXSA9IEFbaSpuK2pdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBBO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgU2hhbm5vbiBlbnRyb3B5IChsb2cgYmFzZSAyKSBvZiBhbiBhcnJheSBvZiBjb3VudHMuXG5zdGF0cy5lbnRyb3B5ID0gZnVuY3Rpb24oY291bnRzLCBmKSB7XG4gIHZhciBpLCBwLCBzID0gMCwgSCA9IDAsIE4gPSBjb3VudHMubGVuZ3RoO1xuICBmb3IgKGk9MDsgaTxOOyArK2kpIHtcbiAgICBzICs9IChmID8gZihjb3VudHNbaV0pIDogY291bnRzW2ldKTtcbiAgfVxuICBpZiAocyA9PT0gMCkgcmV0dXJuIDA7XG4gIGZvciAoaT0wOyBpPE47ICsraSkge1xuICAgIHAgPSAoZiA/IGYoY291bnRzW2ldKSA6IGNvdW50c1tpXSkgLyBzO1xuICAgIGlmIChwID4gMCkgSCArPSBwICogTWF0aC5sb2cocCkgLyBNYXRoLkxOMjtcbiAgfVxuICByZXR1cm4gLUg7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBub3JtYWxpemVkIFNoYW5ub24gZW50cm9weSAobG9nIGJhc2UgMikgb2YgYW4gYXJyYXkgb2YgY291bnRzLlxuc3RhdHMuZW50cm9weS5ub3JtYWxpemVkID0gZnVuY3Rpb24oY291bnRzLCBmKSB7XG4gIHZhciBIID0gc3RhdHMuZW50cm9weShjb3VudHMsIGYpO1xuICByZXR1cm4gSD09PTAgPyAwIDogSCAqIE1hdGguTE4yIC8gTWF0aC5sb2coY291bnRzLmxlbmd0aCk7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtdXR1YWwgaW5mb3JtYXRpb24gYmV0d2VlbiB0d28gZGlzY3JldGUgdmFyaWFibGVzLlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NdXR1YWxfaW5mb3JtYXRpb25cbnN0YXRzLmVudHJvcHkubXV0dWFsID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBjb3VudHMpIHtcbiAgdmFyIHggPSBjb3VudHMgPyB2YWx1ZXMubWFwKGEpIDogdmFsdWVzLFxuICAgICAgeSA9IGNvdW50cyA/IHZhbHVlcy5tYXAoYikgOiBhLFxuICAgICAgeiA9IGNvdW50cyA/IHZhbHVlcy5tYXAoY291bnRzKSA6IGI7XG5cbiAgdmFyIHB4ID0ge30sXG5cdCAgICBweSA9IHt9LFxuXHQgICAgaSwgeHgsIHl5LCB6eiwgcyA9IDAsIHQsIE4gPSB6Lmxlbmd0aCwgcCwgSSA9IDA7XG5cblx0Zm9yIChpPTA7IGk8TjsgKytpKSB7XG5cdCAgcHhbeFtpXV0gPSAwO1xuXHQgIHB5W3lbaV1dID0gMDtcbiAgfVxuXG5cdGZvciAoaT0wOyBpPE47ICsraSkge1xuXHRcdHB4W3hbaV1dICs9IHpbaV07XG5cdFx0cHlbeVtpXV0gKz0geltpXTtcblx0XHRzICs9IHpbaV07XG5cdH1cblxuXHR0ID0gMSAvIChzICogTWF0aC5MTjIpO1xuXHRmb3IgKGk9MDsgaTxOOyArK2kpIHtcblx0XHRpZiAoeltpXSA9PT0gMCkgY29udGludWU7XG5cdFx0cCA9IChzICogeltpXSkgLyAocHhbeFtpXV0gKiBweVt5W2ldXSk7XG5cdFx0SSArPSB6W2ldICogdCAqIE1hdGgubG9nKHApO1xuXHR9XG5cblx0cmV0dXJuIEk7XG59O1xuXG4vLyBDb21wdXRlIGEgcHJvZmlsZSBvZiBzdW1tYXJ5IHN0YXRpc3RpY3MgZm9yIGEgdmFyaWFibGUuXG5zdGF0cy5wcm9maWxlID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHZhciBwID0ge30sXG4gICAgICBtZWFuID0gMCxcbiAgICAgIGNvdW50ID0gMCxcbiAgICAgIGRpc3RpbmN0ID0gMCxcbiAgICAgIG1pbiA9IG51bGwsXG4gICAgICBtYXggPSBudWxsLFxuICAgICAgTTIgPSAwLFxuICAgICAgdmFscyA9IFtdLFxuICAgICAgdSA9IHt9LCBkZWx0YSwgc2QsIGksIHYsIHgsIGhhbGYsIGgsIGgyO1xuXG4gIC8vIGNvbXB1dGUgc3VtbWFyeSBzdGF0c1xuICBmb3IgKGk9MCwgYz0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuXG4gICAgLy8gdXBkYXRlIHVuaXF1ZSB2YWx1ZXNcbiAgICB1W3ZdID0gKHYgaW4gdSkgPyB1W3ZdICsgMSA6IChkaXN0aW5jdCArPSAxLCAxKTtcblxuICAgIGlmICh1dGlsLmlzTm90TnVsbCh2KSkge1xuICAgICAgLy8gdXBkYXRlIG1pbi9tYXhcbiAgICAgIGlmIChtaW49PT1udWxsIHx8IHYgPCBtaW4pIG1pbiA9IHY7XG4gICAgICBpZiAobWF4PT09bnVsbCB8fCB2ID4gbWF4KSBtYXggPSB2O1xuICAgICAgLy8gdXBkYXRlIHN0YXRzXG4gICAgICB4ID0gKHR5cGVvZiB2ID09PSAnc3RyaW5nJykgPyB2Lmxlbmd0aCA6IHY7XG4gICAgICBkZWx0YSA9IHggLSBtZWFuO1xuICAgICAgbWVhbiA9IG1lYW4gKyBkZWx0YSAvICgrK2NvdW50KTtcbiAgICAgIE0yID0gTTIgKyBkZWx0YSAqICh4IC0gbWVhbik7XG4gICAgICB2YWxzLnB1c2goeCk7XG4gICAgfVxuICB9XG4gIE0yID0gTTIgLyAoY291bnQgLSAxKTtcbiAgc2QgPSBNYXRoLnNxcnQoTTIpO1xuXG4gIC8vIHNvcnQgdmFsdWVzIGZvciBtZWRpYW4gYW5kIGlxclxuICB2YWxzLnNvcnQodXRpbC5jbXApO1xuXG4gIHJldHVybiB7XG4gICAgdW5pcXVlOiAgIHUsXG4gICAgY291bnQ6ICAgIGNvdW50LFxuICAgIG51bGxzOiAgICB2YWx1ZXMubGVuZ3RoIC0gY291bnQsXG4gICAgZGlzdGluY3Q6IGRpc3RpbmN0LFxuICAgIG1pbjogICAgICBtaW4sXG4gICAgbWF4OiAgICAgIG1heCxcbiAgICBtZWFuOiAgICAgbWVhbixcbiAgICBzdGRldjogICAgc2QsXG4gICAgbWVkaWFuOiAgICh2ID0gc3RhdHMucXVhbnRpbGUodmFscywgMC41KSksXG4gICAgbW9kZXNrZXc6IHNkID09PSAwID8gMCA6IChtZWFuIC0gdikgLyBzZCxcbiAgICBpcXI6ICAgICAgW3N0YXRzLnF1YW50aWxlKHZhbHMsIDAuMjUpLCBzdGF0cy5xdWFudGlsZSh2YWxzLCAwLjc1KV1cbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhdHM7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBzdGF0cyA9IHJlcXVpcmUoJy4vc3RhdHMnKTtcblxuLy8gQ29tcHV0ZSBwcm9maWxlcyBmb3IgYWxsIHZhcmlhYmxlcyBpbiBhIGRhdGEgc2V0LlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhLCBmaWVsZHMpIHtcbiAgaWYgKGRhdGEgPT0gbnVsbCB8fCBkYXRhLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gIGZpZWxkcyA9IGZpZWxkcyB8fCB1dGlsLmtleXMoZGF0YVswXSk7XG5cbiAgdmFyIHByb2ZpbGVzID0gZmllbGRzLm1hcChmdW5jdGlvbihmKSB7XG4gICAgdmFyIHAgPSBzdGF0cy5wcm9maWxlKGRhdGEsIHV0aWwuYWNjZXNzb3IoZikpO1xuICAgIHJldHVybiAocC5maWVsZCA9IGYsIHApO1xuICB9KTtcbiAgXG4gIHByb2ZpbGVzLnRvU3RyaW5nID0gcHJpbnRTdW1tYXJ5O1xuICByZXR1cm4gcHJvZmlsZXM7XG59O1xuXG5mdW5jdGlvbiBwcmludFN1bW1hcnkoKSB7XG4gIHZhciBwcm9maWxlcyA9IHRoaXM7XG4gIHZhciBzdHIgPSBbXTtcbiAgcHJvZmlsZXMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgc3RyLnB1c2goXCItLS0tLSBGaWVsZDogJ1wiICsgcC5maWVsZCArIFwiJyAtLS0tLVwiKTtcbiAgICBpZiAodHlwZW9mIHAubWluID09PSAnc3RyaW5nJyB8fCBwLmRpc3RpbmN0IDwgMTApIHtcbiAgICAgIHN0ci5wdXNoKHByaW50Q2F0ZWdvcmljYWxQcm9maWxlKHApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyLnB1c2gocHJpbnRRdWFudGl0YXRpdmVQcm9maWxlKHApKTtcbiAgICB9XG4gICAgc3RyLnB1c2goXCJcIik7XG4gIH0pO1xuICByZXR1cm4gc3RyLmpvaW4oXCJcXG5cIik7XG59XG5cbmZ1bmN0aW9uIHByaW50UXVhbnRpdGF0aXZlUHJvZmlsZShwKSB7XG4gIHJldHVybiBbXG4gICAgXCJkaXN0aW5jdDogXCIgKyBwLmRpc3RpbmN0LFxuICAgIFwibnVsbHM6ICAgIFwiICsgcC5udWxscyxcbiAgICBcIm1pbjogICAgICBcIiArIHAubWluLFxuICAgIFwibWF4OiAgICAgIFwiICsgcC5tYXgsXG4gICAgXCJtZWRpYW46ICAgXCIgKyBwLm1lZGlhbixcbiAgICBcIm1lYW46ICAgICBcIiArIHAubWVhbixcbiAgICBcInN0ZGV2OiAgICBcIiArIHAuc3RkZXYsXG4gICAgXCJtb2Rlc2tldzogXCIgKyBwLm1vZGVza2V3XG4gIF0uam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gcHJpbnRDYXRlZ29yaWNhbFByb2ZpbGUocCkge1xuICB2YXIgbGlzdCA9IFtcbiAgICBcImRpc3RpbmN0OiBcIiArIHAuZGlzdGluY3QsXG4gICAgXCJudWxsczogICAgXCIgKyBwLm51bGxzLFxuICAgIFwidG9wIHZhbHVlczogXCJcbiAgXTtcbiAgdmFyIHUgPSBwLnVuaXF1ZTtcbiAgdmFyIHRvcCA9IHV0aWwua2V5cyh1KVxuICAgIC5zb3J0KGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gdVtiXSAtIHVbYV07IH0pXG4gICAgLnNsaWNlKDAsIDYpXG4gICAgLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiBcIiAnXCIgKyB2ICsgXCInIChcIiArIHVbdl0gKyBcIilcIjsgfSk7XG4gIHJldHVybiBsaXN0LmNvbmNhdCh0b3ApLmpvaW4oXCJcXG5cIik7XG59IiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1ID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gd2hlcmUgYXJlIHdlP1xuXG51LmlzTm9kZSA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAmJiB0eXBlb2YgcHJvY2Vzcy5zdGRlcnIgIT09ICd1bmRlZmluZWQnO1xuXG4vLyB0eXBlIGNoZWNraW5nIGZ1bmN0aW9uc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG51LmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xufTtcblxudS5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnUuaXNTdHJpbmcgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBTdHJpbmddJztcbn07XG5cbnUuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnUuaXNOdW1iZXIgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG9iaikpICYmIGlzRmluaXRlKG9iaik7XG59O1xuXG51LmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEJvb2xlYW5dJztcbn07XG5cbnUuaXNEYXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgRGF0ZV0nO1xufTtcblxudS5pc05vdE51bGwgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmICh0eXBlb2Ygb2JqICE9PSAnbnVtYmVyJyA/IHRydWUgOiAhaXNOYU4ob2JqKSk7XG59O1xuXG51LmlzQnVmZmVyID0gKEJ1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIpIHx8IHUuZmFsc2U7XG5cbi8vIHR5cGUgY29lcmNpb24gZnVuY3Rpb25zXG5cbnUubnVtYmVyID0gZnVuY3Rpb24ocykgeyByZXR1cm4gcyA9PSBudWxsID8gbnVsbCA6ICtzOyB9O1xuXG51LmJvb2xlYW4gPSBmdW5jdGlvbihzKSB7IHJldHVybiBzID09IG51bGwgPyBudWxsIDogcz09PSdmYWxzZScgPyBmYWxzZSA6ICEhczsgfTtcblxudS5kYXRlID0gZnVuY3Rpb24ocykgeyByZXR1cm4gcyA9PSBudWxsID8gbnVsbCA6IERhdGUucGFyc2Uocyk7IH1cblxudS5hcnJheSA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggIT0gbnVsbCA/ICh1LmlzQXJyYXkoeCkgPyB4IDogW3hdKSA6IFtdOyB9O1xuXG51LnN0ciA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHUuaXNBcnJheSh4KSA/IFwiW1wiICsgeC5tYXAodS5zdHIpICsgXCJdXCJcbiAgICA6IHUuaXNPYmplY3QoeCkgPyBKU09OLnN0cmluZ2lmeSh4KVxuICAgIDogdS5pc1N0cmluZyh4KSA/IChcIidcIit1dGlsX2VzY2FwZV9zdHIoeCkrXCInXCIpIDogeDtcbn07XG5cbnZhciBlc2NhcGVfc3RyX3JlID0gLyhefFteXFxcXF0pJy9nO1xuXG5mdW5jdGlvbiB1dGlsX2VzY2FwZV9zdHIoeCkge1xuICByZXR1cm4geC5yZXBsYWNlKGVzY2FwZV9zdHJfcmUsIFwiJDFcXFxcJ1wiKTtcbn1cblxuLy8gdXRpbGl0eSBmdW5jdGlvbnNcblxudS5pZGVudGl0eSA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg7IH07XG5cbnUudHJ1ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfTtcblxudS5mYWxzZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cbnUuZHVwbGljYXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufTtcblxudS5lcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKTtcbn07XG5cbnUuZXh0ZW5kID0gZnVuY3Rpb24ob2JqKSB7XG4gIGZvciAodmFyIHgsIG5hbWUsIGk9MSwgbGVuPWFyZ3VtZW50cy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICB4ID0gYXJndW1lbnRzW2ldO1xuICAgIGZvciAobmFtZSBpbiB4KSB7IG9ialtuYW1lXSA9IHhbbmFtZV07IH1cbiAgfVxuICByZXR1cm4gb2JqO1xufTtcblxudS5rZXlzID0gZnVuY3Rpb24oeCkge1xuICB2YXIga2V5cyA9IFtdLCBrO1xuICBmb3IgKGsgaW4geCkga2V5cy5wdXNoKGspO1xuICByZXR1cm4ga2V5cztcbn07XG5cbnUudmFscyA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIHZhbHMgPSBbXSwgaztcbiAgZm9yIChrIGluIHgpIHZhbHMucHVzaCh4W2tdKTtcbiAgcmV0dXJuIHZhbHM7XG59O1xuXG51LnRvTWFwID0gZnVuY3Rpb24obGlzdCkge1xuICByZXR1cm4gbGlzdC5yZWR1Y2UoZnVuY3Rpb24ob2JqLCB4KSB7XG4gICAgcmV0dXJuIChvYmpbeF0gPSAxLCBvYmopO1xuICB9LCB7fSk7XG59O1xuXG51LmtleXN0ciA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICAvLyB1c2UgdG8gZW5zdXJlIGNvbnNpc3RlbnQga2V5IGdlbmVyYXRpb24gYWNyb3NzIG1vZHVsZXNcbiAgcmV0dXJuIHZhbHVlcy5qb2luKFwifFwiKTtcbn07XG5cbi8vIGRhdGEgYWNjZXNzIGZ1bmN0aW9uc1xuXG51LmZpZWxkID0gZnVuY3Rpb24oZikge1xuICByZXR1cm4gZi5zcGxpdChcIlxcXFwuXCIpXG4gICAgLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiBkLnNwbGl0KFwiLlwiKTsgfSlcbiAgICAucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGlmIChhLmxlbmd0aCkgeyBhW2EubGVuZ3RoLTFdICs9IFwiLlwiICsgYi5zaGlmdCgpOyB9XG4gICAgICBhLnB1c2guYXBwbHkoYSwgYik7XG4gICAgICByZXR1cm4gYTtcbiAgICB9LCBbXSk7XG59O1xuXG51LmFjY2Vzc29yID0gZnVuY3Rpb24oZikge1xuICB2YXIgcztcbiAgcmV0dXJuICh1LmlzRnVuY3Rpb24oZikgfHwgZj09bnVsbClcbiAgICA/IGYgOiB1LmlzU3RyaW5nKGYpICYmIChzPXUuZmllbGQoZikpLmxlbmd0aCA+IDFcbiAgICA/IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHMucmVkdWNlKGZ1bmN0aW9uKHgsZikge1xuICAgICAgICAgIHJldHVybiB4W2ZdO1xuICAgICAgICB9LCB4KTtcbiAgICAgIH1cbiAgICA6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHhbZl07IH07XG59O1xuXG51Lm11dGF0b3IgPSBmdW5jdGlvbihmKSB7XG4gIHZhciBzO1xuICByZXR1cm4gdS5pc1N0cmluZyhmKSAmJiAocz11LmZpZWxkKGYpKS5sZW5ndGggPiAxXG4gICAgPyBmdW5jdGlvbih4LCB2KSB7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxzLmxlbmd0aC0xOyArK2kpIHggPSB4W3NbaV1dO1xuICAgICAgICB4W3NbaV1dID0gdjtcbiAgICAgIH1cbiAgICA6IGZ1bmN0aW9uKHgsIHYpIHsgeFtmXSA9IHY7IH07XG59O1xuXG5cbi8vIGNvbXBhcmlzb24gLyBzb3J0aW5nIGZ1bmN0aW9uc1xuXG51LmNvbXBhcmF0b3IgPSBmdW5jdGlvbihzb3J0KSB7XG4gIHZhciBzaWduID0gW107XG4gIGlmIChzb3J0ID09PSB1bmRlZmluZWQpIHNvcnQgPSBbXTtcbiAgc29ydCA9IHUuYXJyYXkoc29ydCkubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICB2YXIgcyA9IDE7XG4gICAgaWYgICAgICAoZlswXSA9PT0gXCItXCIpIHsgcyA9IC0xOyBmID0gZi5zbGljZSgxKTsgfVxuICAgIGVsc2UgaWYgKGZbMF0gPT09IFwiK1wiKSB7IHMgPSArMTsgZiA9IGYuc2xpY2UoMSk7IH1cbiAgICBzaWduLnB1c2gocyk7XG4gICAgcmV0dXJuIHUuYWNjZXNzb3IoZik7XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24oYSxiKSB7XG4gICAgdmFyIGksIG4sIGYsIHgsIHk7XG4gICAgZm9yIChpPTAsIG49c29ydC5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBmID0gc29ydFtpXTsgeCA9IGYoYSk7IHkgPSBmKGIpO1xuICAgICAgaWYgKHggPCB5KSByZXR1cm4gLTEgKiBzaWduW2ldO1xuICAgICAgaWYgKHggPiB5KSByZXR1cm4gc2lnbltpXTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG59O1xuXG51LmNtcCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoYSA+PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoYSA9PT0gbnVsbCAmJiBiID09PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoYSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChiID09PSBudWxsKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIE5hTjtcbn07XG5cbnUubnVtY21wID0gZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSAtIGI7IH07XG5cbnUuc3RhYmxlc29ydCA9IGZ1bmN0aW9uKGFycmF5LCBzb3J0QnksIGtleUZuKSB7XG4gIHZhciBpbmRpY2VzID0gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKGlkeCwgdiwgaSkge1xuICAgIHJldHVybiAoaWR4W2tleUZuKHYpXSA9IGksIGlkeCk7XG4gIH0sIHt9KTtcblxuICBhcnJheS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgc2EgPSBzb3J0QnkoYSksXG4gICAgICAgIHNiID0gc29ydEJ5KGIpO1xuICAgIHJldHVybiBzYSA8IHNiID8gLTEgOiBzYSA+IHNiID8gMVxuICAgICAgICAgOiAoaW5kaWNlc1trZXlGbihhKV0gLSBpbmRpY2VzW2tleUZuKGIpXSk7XG4gIH0pO1xuXG4gIHJldHVybiBhcnJheTtcbn07XG5cblxuLy8gc3RyaW5nIGZ1bmN0aW9uc1xuXG4vLyBFUzYgY29tcGF0aWJpbGl0eSBwZXIgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGgjUG9seWZpbGxcbi8vIFdlIGNvdWxkIGhhdmUgdXNlZCB0aGUgcG9seWZpbGwgY29kZSwgYnV0IGxldHMgd2FpdCB1bnRpbCBFUzYgYmVjb21lcyBhIHN0YW5kYXJkIGZpcnN0XG51LnN0YXJ0c1dpdGggPSBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGhcbiAgPyBmdW5jdGlvbihzdHJpbmcsIHNlYXJjaFN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcpO1xuICB9XG4gIDogZnVuY3Rpb24oc3RyaW5nLCBzZWFyY2hTdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxhc3RJbmRleE9mKHNlYXJjaFN0cmluZywgMCkgPT09IDA7XG4gIH07XG5cbnUudHJ1bmNhdGUgPSBmdW5jdGlvbihzLCBsZW5ndGgsIHBvcywgd29yZCwgZWxsaXBzaXMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoO1xuICBpZiAobGVuIDw9IGxlbmd0aCkgcmV0dXJuIHM7XG4gIGVsbGlwc2lzID0gZWxsaXBzaXMgIT09IHVuZGVmaW5lZCA/IFN0cmluZyhlbGxpcHNpcykgOiBcIuKAplwiO1xuICB2YXIgbCA9IE1hdGgubWF4KDAsIGxlbmd0aCAtIGVsbGlwc2lzLmxlbmd0aCk7XG5cbiAgc3dpdGNoIChwb3MpIHtcbiAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgcmV0dXJuIGVsbGlwc2lzICsgKHdvcmQgPyB0cnVuY2F0ZU9uV29yZChzLGwsMSkgOiBzLnNsaWNlKGxlbi1sKSk7XG4gICAgY2FzZSBcIm1pZGRsZVwiOlxuICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgIHZhciBsMSA9IE1hdGguY2VpbChsLzIpLCBsMiA9IE1hdGguZmxvb3IobC8yKTtcbiAgICAgIHJldHVybiAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbDEpIDogcy5zbGljZSgwLGwxKSkgKyBlbGxpcHNpc1xuICAgICAgICArICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsMiwxKSA6IHMuc2xpY2UobGVuLWwyKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbCkgOiBzLnNsaWNlKDAsbCkpICsgZWxsaXBzaXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHRydW5jYXRlT25Xb3JkKHMsIGxlbiwgcmV2KSB7XG4gIHZhciBjbnQgPSAwLCB0b2sgPSBzLnNwbGl0KHRydW5jYXRlX3dvcmRfcmUpO1xuICBpZiAocmV2KSB7XG4gICAgcyA9ICh0b2sgPSB0b2sucmV2ZXJzZSgpKVxuICAgICAgLmZpbHRlcihmdW5jdGlvbih3KSB7IGNudCArPSB3Lmxlbmd0aDsgcmV0dXJuIGNudCA8PSBsZW47IH0pXG4gICAgICAucmV2ZXJzZSgpO1xuICB9IGVsc2Uge1xuICAgIHMgPSB0b2suZmlsdGVyKGZ1bmN0aW9uKHcpIHsgY250ICs9IHcubGVuZ3RoOyByZXR1cm4gY250IDw9IGxlbjsgfSk7XG4gIH1cbiAgcmV0dXJuIHMubGVuZ3RoID8gcy5qb2luKFwiXCIpLnRyaW0oKSA6IHRva1swXS5zbGljZSgwLCBsZW4pO1xufVxuXG52YXIgdHJ1bmNhdGVfd29yZF9yZSA9IC8oW1xcdTAwMDlcXHUwMDBBXFx1MDAwQlxcdTAwMENcXHUwMDBEXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUyMDI4XFx1MjAyOVxcdTMwMDBcXHVGRUZGXSkvO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL2dsb2JhbHMnKTtcblxudmFyIGNvbnN0cyA9IHJlcXVpcmUoJy4vY29uc3RzJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgdmxmaWVsZCA9IHJlcXVpcmUoJy4vZmllbGQnKSxcbiAgdmxlbmMgPSByZXF1aXJlKCcuL2VuYycpLFxuICBzY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYS9zY2hlbWEnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEVuY29kaW5nKG1hcmt0eXBlLCBlbmMsIGRhdGEsIGNvbmZpZywgZmlsdGVyLCB0aGVtZSkge1xuICAgIHZhciBkZWZhdWx0cyA9IHNjaGVtYS5pbnN0YW50aWF0ZSgpO1xuXG4gICAgdmFyIHNwZWMgPSB7XG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgbWFya3R5cGU6IG1hcmt0eXBlLFxuICAgICAgZW5jOiBlbmMsXG4gICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgIGZpbHRlcjogZmlsdGVyIHx8IFtdXG4gICAgfTtcblxuICAgIC8vIHR5cGUgdG8gYml0Y29kZVxuICAgIGZvciAodmFyIGUgaW4gZGVmYXVsdHMuZW5jKSB7XG4gICAgICBkZWZhdWx0cy5lbmNbZV0udHlwZSA9IGNvbnN0cy5kYXRhVHlwZXNbZGVmYXVsdHMuZW5jW2VdLnR5cGVdO1xuICAgIH1cblxuICAgIHZhciBzcGVjRXh0ZW5kZWQgPSBzY2hlbWEudXRpbC5tZXJnZShkZWZhdWx0cywgdGhlbWUgfHwge30sIHNwZWMpIDtcblxuICAgIHRoaXMuX2RhdGEgPSBzcGVjRXh0ZW5kZWQuZGF0YTtcbiAgICB0aGlzLl9tYXJrdHlwZSA9IHNwZWNFeHRlbmRlZC5tYXJrdHlwZTtcbiAgICB0aGlzLl9lbmMgPSBzcGVjRXh0ZW5kZWQuZW5jO1xuICAgIHRoaXMuX2NvbmZpZyA9IHNwZWNFeHRlbmRlZC5jb25maWc7XG4gICAgdGhpcy5fZmlsdGVyID0gc3BlY0V4dGVuZGVkLmZpbHRlcjtcbiAgfVxuXG4gIHZhciBwcm90byA9IEVuY29kaW5nLnByb3RvdHlwZTtcblxuICBwcm90by5tYXJrdHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXJrdHlwZTtcbiAgfTtcblxuICBwcm90by5pcyA9IGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gdGhpcy5fbWFya3R5cGUgPT09IG07XG4gIH07XG5cbiAgcHJvdG8uaGFzID0gZnVuY3Rpb24oZW5jVHlwZSkge1xuICAgIC8vIGVxdWl2YWxlbnQgdG8gY2FsbGluZyB2bGVuYy5oYXModGhpcy5fZW5jLCBlbmNUeXBlKVxuICAgIHJldHVybiB0aGlzLl9lbmNbZW5jVHlwZV0ubmFtZSAhPT0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIHByb3RvLmVuYyA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF07XG4gIH07XG5cbiAgcHJvdG8uZmlsdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZpbHRlck51bGwgPSBbXSxcbiAgICAgIGZpZWxkcyA9IHRoaXMuZmllbGRzKCksXG4gICAgICBzZWxmID0gdGhpcztcblxuICAgIHV0aWwuZm9yRWFjaChmaWVsZHMsIGZ1bmN0aW9uKGZpZWxkTGlzdCwgZmllbGROYW1lKSB7XG4gICAgICBpZiAoZmllbGROYW1lID09PSAnKicpIHJldHVybjsgLy9jb3VudFxuXG4gICAgICBpZiAoKHNlbGYuY29uZmlnKCdmaWx0ZXJOdWxsJykuUSAmJiBmaWVsZExpc3QuY29udGFpbnNUeXBlW1FdKSB8fFxuICAgICAgICAgIChzZWxmLmNvbmZpZygnZmlsdGVyTnVsbCcpLlQgJiYgZmllbGRMaXN0LmNvbnRhaW5zVHlwZVtUXSkgfHxcbiAgICAgICAgICAoc2VsZi5jb25maWcoJ2ZpbHRlck51bGwnKS5PICYmIGZpZWxkTGlzdC5jb250YWluc1R5cGVbT10pKSB7XG4gICAgICAgIGZpbHRlck51bGwucHVzaCh7XG4gICAgICAgICAgb3BlcmFuZHM6IFtmaWVsZE5hbWVdLFxuICAgICAgICAgIG9wZXJhdG9yOiAnbm90TnVsbCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZmlsdGVyTnVsbC5jb25jYXQodGhpcy5fZmlsdGVyKTtcbiAgfTtcblxuICAvLyBnZXQgXCJmaWVsZFwiIHByb3BlcnR5IGZvciB2ZWdhXG4gIHByb3RvLmZpZWxkID0gZnVuY3Rpb24oZXQsIG5vZGF0YSwgbm9mbikge1xuICAgIGlmICghdGhpcy5oYXMoZXQpKSByZXR1cm4gbnVsbDtcblxuICAgIHZhciBmID0gKG5vZGF0YSA/ICcnIDogJ2RhdGEuJyk7XG5cbiAgICBpZiAodmxmaWVsZC5pc0NvdW50KHRoaXMuX2VuY1tldF0pKSB7XG4gICAgICByZXR1cm4gZiArICdjb3VudCc7XG4gICAgfSBlbHNlIGlmICghbm9mbiAmJiB0aGlzLl9lbmNbZXRdLmJpbikge1xuICAgICAgcmV0dXJuIGYgKyAnYmluXycgKyB0aGlzLl9lbmNbZXRdLm5hbWU7XG4gICAgfSBlbHNlIGlmICghbm9mbiAmJiB0aGlzLl9lbmNbZXRdLmFnZ3IpIHtcbiAgICAgIHJldHVybiBmICsgdGhpcy5fZW5jW2V0XS5hZ2dyICsgJ18nICsgdGhpcy5fZW5jW2V0XS5uYW1lO1xuICAgIH0gZWxzZSBpZiAoIW5vZm4gJiYgdGhpcy5fZW5jW2V0XS5mbikge1xuICAgICAgcmV0dXJuIGYgKyB0aGlzLl9lbmNbZXRdLmZuICsgJ18nICsgdGhpcy5fZW5jW2V0XS5uYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZiArIHRoaXMuX2VuY1tldF0ubmFtZTtcbiAgICB9XG4gIH07XG5cbiAgcHJvdG8uZmllbGROYW1lID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5uYW1lO1xuICB9O1xuXG4gIC8qXG4gICAqIHJldHVybiBrZXktdmFsdWUgcGFpcnMgb2YgZmllbGQgbmFtZSBhbmQgbGlzdCBvZiBmaWVsZHMgb2YgdGhhdCBmaWVsZCBuYW1lXG4gICAqL1xuICBwcm90by5maWVsZHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmxlbmMuZmllbGRzKHRoaXMuX2VuYyk7XG4gIH07XG5cbiAgcHJvdG8uZmllbGRUaXRsZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgaWYgKHZsZmllbGQuaXNDb3VudCh0aGlzLl9lbmNbZXRdKSkge1xuICAgICAgcmV0dXJuIHZsZmllbGQuY291bnQuZGlzcGxheU5hbWU7XG4gICAgfVxuICAgIHZhciBmbiA9IHRoaXMuX2VuY1tldF0uYWdnciB8fCB0aGlzLl9lbmNbZXRdLmZuIHx8ICh0aGlzLl9lbmNbZXRdLmJpbiAmJiBcImJpblwiKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHJldHVybiBmbi50b1VwcGVyQ2FzZSgpICsgJygnICsgdGhpcy5fZW5jW2V0XS5uYW1lICsgJyknO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5uYW1lO1xuICAgIH1cbiAgfTtcblxuICBwcm90by5zY2FsZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0uc2NhbGUgfHwge307XG4gIH07XG5cbiAgcHJvdG8uYXhpcyA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0uYXhpcyB8fCB7fTtcbiAgfTtcblxuICBwcm90by5iYW5kID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5iYW5kIHx8IHt9O1xuICB9O1xuXG4gIHByb3RvLmJhbmRTaXplID0gZnVuY3Rpb24oZW5jVHlwZSwgdXNlU21hbGxCYW5kKSB7XG4gICAgdXNlU21hbGxCYW5kID0gdXNlU21hbGxCYW5kIHx8XG4gICAgICAvL2lzQmFuZEluU21hbGxNdWx0aXBsZXNcbiAgICAgIChlbmNUeXBlID09PSBZICYmIHRoaXMuaGFzKFJPVykgJiYgdGhpcy5oYXMoWSkpIHx8XG4gICAgICAoZW5jVHlwZSA9PT0gWCAmJiB0aGlzLmhhcyhDT0wpICYmIHRoaXMuaGFzKFgpKTtcblxuICAgIC8vIGlmIGJhbmQuc2l6ZSBpcyBleHBsaWNpdGx5IHNwZWNpZmllZCwgZm9sbG93IHRoZSBzcGVjaWZpY2F0aW9uLCBvdGhlcndpc2UgZHJhdyB2YWx1ZSBmcm9tIGNvbmZpZy5cbiAgICByZXR1cm4gdGhpcy5iYW5kKGVuY1R5cGUpLnNpemUgfHxcbiAgICAgIHRoaXMuY29uZmlnKHVzZVNtYWxsQmFuZCA/ICdzbWFsbEJhbmRTaXplJyA6ICdsYXJnZUJhbmRTaXplJyk7XG4gIH07XG5cbiAgcHJvdG8uYWdnciA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0uYWdncjtcbiAgfTtcblxuICAvLyByZXR1cm5zIGZhbHNlIGlmIGJpbm5pbmcgaXMgZGlzYWJsZWQsIG90aGVyd2lzZSBhbiBvYmplY3Qgd2l0aCBiaW5uaW5nIHByb3BlcnRpZXNcbiAgcHJvdG8uYmluID0gZnVuY3Rpb24oZXQpIHtcbiAgICB2YXIgYmluID0gdGhpcy5fZW5jW2V0XS5iaW47XG4gICAgaWYgKGJpbiA9PT0ge30pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGJpbiA9PT0gdHJ1ZSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1heGJpbnM6IHNjaGVtYS5NQVhCSU5TX0RFRkFVTFRcbiAgICAgIH07XG4gICAgcmV0dXJuIGJpbjtcbiAgfTtcblxuICBwcm90by5sZWdlbmQgPSBmdW5jdGlvbihldCkge1xuICAgIHJldHVybiB0aGlzLl9lbmNbZXRdLmxlZ2VuZDtcbiAgfTtcblxuICBwcm90by52YWx1ZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0udmFsdWU7XG4gIH07XG5cbiAgcHJvdG8uZm4gPSBmdW5jdGlvbihldCkge1xuICAgIHJldHVybiB0aGlzLl9lbmNbZXRdLmZuO1xuICB9O1xuXG4gIHByb3RvLnNvcnQgPSBmdW5jdGlvbihldCwgc3RhdHMpIHtcbiAgICB2YXIgc29ydCA9IHRoaXMuX2VuY1tldF0uc29ydCxcbiAgICAgIGVuYyA9IHRoaXMuX2VuYyxcbiAgICAgIGlzVHlwZSA9IHZsZmllbGQuaXNUeXBlLmJ5Q29kZTtcblxuICAgIC8vIGNvbnNvbGUubG9nKCdzb3J0OicsIHNvcnQsICdzdXBwb3J0OicsIEVuY29kaW5nLnRvZ2dsZVNvcnQuc3VwcG9ydCh7ZW5jOnRoaXMuX2VuY30sIHN0YXRzKSAsICd0b2dnbGU6JywgdGhpcy5jb25maWcoJ3RvZ2dsZVNvcnQnKSlcblxuICAgIGlmICgoIXNvcnQgfHwgc29ydC5sZW5ndGg9PT0wKSAmJlxuICAgICAgICBFbmNvZGluZy50b2dnbGVTb3J0LnN1cHBvcnQoe2VuYzp0aGlzLl9lbmN9LCBzdGF0cywgdHJ1ZSkgJiYgLy9IQUNLXG4gICAgICAgIHRoaXMuY29uZmlnKCd0b2dnbGVTb3J0JykgPT09ICdRJ1xuICAgICAgKSB7XG4gICAgICB2YXIgcUZpZWxkID0gaXNUeXBlKGVuYy54LCBPKSA/IGVuYy55IDogZW5jLng7XG5cbiAgICAgIGlmIChpc1R5cGUoZW5jW2V0XSwgTykpIHtcbiAgICAgICAgc29ydCA9IFt7XG4gICAgICAgICAgbmFtZTogcUZpZWxkLm5hbWUsXG4gICAgICAgICAgYWdncjogcUZpZWxkLmFnZ3IsXG4gICAgICAgICAgdHlwZTogcUZpZWxkLnR5cGUsXG4gICAgICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgICAgICB9XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc29ydDtcbiAgfTtcblxuICBwcm90by5sZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdXRpbC5rZXlzKHRoaXMuX2VuYykubGVuZ3RoO1xuICB9O1xuXG4gIHByb3RvLm1hcCA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gdmxlbmMubWFwKHRoaXMuX2VuYywgZik7XG4gIH07XG5cbiAgcHJvdG8ucmVkdWNlID0gZnVuY3Rpb24oZiwgaW5pdCkge1xuICAgIHJldHVybiB2bGVuYy5yZWR1Y2UodGhpcy5fZW5jLCBmLCBpbml0KTtcbiAgfTtcblxuICBwcm90by5mb3JFYWNoID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiB2bGVuYy5mb3JFYWNoKHRoaXMuX2VuYywgZik7XG4gIH07XG5cbiAgcHJvdG8udHlwZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGV0KSA/IHRoaXMuX2VuY1tldF0udHlwZSA6IG51bGw7XG4gIH07XG5cbiAgcHJvdG8ucm9sZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGV0KSA/IHZsZmllbGQucm9sZSh0aGlzLl9lbmNbZXRdKSA6IG51bGw7XG4gIH07XG5cbiAgcHJvdG8udGV4dCA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICB2YXIgdGV4dCA9IHRoaXMuX2VuY1tURVhUXS50ZXh0O1xuICAgIHJldHVybiBwcm9wID8gdGV4dFtwcm9wXSA6IHRleHQ7XG4gIH07XG5cbiAgcHJvdG8uZm9udCA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICB2YXIgZm9udCA9IHRoaXMuX2VuY1tURVhUXS5mb250O1xuICAgIHJldHVybiBwcm9wID8gZm9udFtwcm9wXSA6IGZvbnQ7XG4gIH07XG5cbiAgcHJvdG8uaXNUeXBlID0gZnVuY3Rpb24oZXQsIHR5cGUpIHtcbiAgICB2YXIgZmllbGQgPSB0aGlzLmVuYyhldCk7XG4gICAgcmV0dXJuIGZpZWxkICYmIEVuY29kaW5nLmlzVHlwZShmaWVsZCwgdHlwZSk7XG4gIH07XG5cbiAgRW5jb2RpbmcuaXNUeXBlID0gZnVuY3Rpb24gKGZpZWxkRGVmLCB0eXBlKSB7XG4gICAgLy8gRklYTUUgdmxmaWVsZC5pc1R5cGVcbiAgICByZXR1cm4gKGZpZWxkRGVmLnR5cGUgJiB0eXBlKSA+IDA7XG4gIH07XG5cbiAgRW5jb2RpbmcuaXNPcmRpbmFsU2NhbGUgPSBmdW5jdGlvbihlbmNvZGluZywgZW5jVHlwZSkge1xuICAgIHJldHVybiB2bGZpZWxkLmlzT3JkaW5hbFNjYWxlKGVuY29kaW5nLmVuYyhlbmNUeXBlKSwgdHJ1ZSk7XG4gIH07XG5cbiAgRW5jb2RpbmcuaXNEaW1lbnNpb24gPSBmdW5jdGlvbihlbmNvZGluZywgZW5jVHlwZSkge1xuICAgIHJldHVybiB2bGZpZWxkLmlzRGltZW5zaW9uKGVuY29kaW5nLmVuYyhlbmNUeXBlKSwgdHJ1ZSk7XG4gIH07XG5cbiAgRW5jb2RpbmcuaXNNZWFzdXJlID0gZnVuY3Rpb24oZW5jb2RpbmcsIGVuY1R5cGUpIHtcbiAgICByZXR1cm4gdmxmaWVsZC5pc01lYXN1cmUoZW5jb2RpbmcuZW5jKGVuY1R5cGUpLCB0cnVlKTtcbiAgfTtcblxuICBwcm90by5pc09yZGluYWxTY2FsZSA9IGZ1bmN0aW9uKGVuY1R5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoZW5jVHlwZSkgJiYgRW5jb2RpbmcuaXNPcmRpbmFsU2NhbGUodGhpcywgZW5jVHlwZSk7XG4gIH07XG5cbiAgcHJvdG8uaXNEaW1lbnNpb24gPSBmdW5jdGlvbihlbmNUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGVuY1R5cGUpICYmIEVuY29kaW5nLmlzRGltZW5zaW9uKHRoaXMsIGVuY1R5cGUpO1xuICB9O1xuXG4gIHByb3RvLmlzTWVhc3VyZSA9IGZ1bmN0aW9uKGVuY1R5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoZW5jVHlwZSkgJiYgRW5jb2RpbmcuaXNNZWFzdXJlKHRoaXMsIGVuY1R5cGUpO1xuICB9O1xuXG4gIHByb3RvLmlzQWdncmVnYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZsZW5jLmlzQWdncmVnYXRlKHRoaXMuX2VuYyk7XG4gIH07XG5cbiAgRW5jb2RpbmcuaXNBZ2dyZWdhdGUgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgcmV0dXJuIHZsZW5jLmlzQWdncmVnYXRlKHNwZWMuZW5jKTtcbiAgfTtcblxuICBFbmNvZGluZy5hbHdheXNOb09jY2x1c2lvbiA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAvLyBGSVhNRSByYXcgT3hRIHdpdGggIyBvZiByb3dzID0gIyBvZiBPXG4gICAgcmV0dXJuIHZsZW5jLmlzQWdncmVnYXRlKHNwZWMuZW5jKTtcbiAgfTtcblxuICBFbmNvZGluZy5pc1N0YWNrID0gZnVuY3Rpb24oc3BlYykge1xuICAgIC8vIEZJWE1FIHVwZGF0ZSB0aGlzIG9uY2Ugd2UgaGF2ZSBjb250cm9sIGZvciBzdGFjayAuLi5cbiAgICByZXR1cm4gKHNwZWMubWFya3R5cGUgPT09ICdiYXInIHx8IHNwZWMubWFya3R5cGUgPT09ICdhcmVhJykgJiZcbiAgICAgIHNwZWMuZW5jLmNvbG9yO1xuICB9O1xuXG4gIHByb3RvLmlzU3RhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBGSVhNRSB1cGRhdGUgdGhpcyBvbmNlIHdlIGhhdmUgY29udHJvbCBmb3Igc3RhY2sgLi4uXG4gICAgcmV0dXJuICh0aGlzLmlzKCdiYXInKSB8fCB0aGlzLmlzKCdhcmVhJykpICYmIHRoaXMuaGFzKCdjb2xvcicpO1xuICB9O1xuXG4gIHByb3RvLmNhcmRpbmFsaXR5ID0gZnVuY3Rpb24oZW5jVHlwZSwgc3RhdHMpIHtcbiAgICByZXR1cm4gdmxmaWVsZC5jYXJkaW5hbGl0eSh0aGlzLmVuYyhlbmNUeXBlKSwgc3RhdHMsIHRoaXMuY29uZmlnKCdmaWx0ZXJOdWxsJyksIHRydWUpO1xuICB9O1xuXG4gIHByb3RvLmlzUmF3ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzQWdncmVnYXRlKCk7XG4gIH07XG5cbiAgcHJvdG8uZGF0YSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVtuYW1lXTtcbiAgfTtcblxuICAgLy8gcmV0dXJucyB3aGV0aGVyIHRoZSBlbmNvZGluZyBoYXMgdmFsdWVzIGVtYmVkZGVkXG4gIHByb3RvLmhhc1ZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWxzID0gdGhpcy5kYXRhKCd2YWx1ZXMnKTtcbiAgICByZXR1cm4gdmFscyAmJiB2YWxzLmxlbmd0aDtcbiAgfTtcblxuICBwcm90by5jb25maWcgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZ1tuYW1lXTtcbiAgfTtcblxuICBwcm90by50b1NwZWMgPSBmdW5jdGlvbihleGNsdWRlQ29uZmlnLCBleGNsdWRlRGF0YSkge1xuICAgIHZhciBlbmMgPSB1dGlsLmR1cGxpY2F0ZSh0aGlzLl9lbmMpLFxuICAgICAgc3BlYztcblxuICAgIC8vIGNvbnZlcnQgdHlwZSdzIGJpdGNvZGUgdG8gdHlwZSBuYW1lXG4gICAgZm9yICh2YXIgZSBpbiBlbmMpIHtcbiAgICAgIGVuY1tlXS50eXBlID0gY29uc3RzLmRhdGFUeXBlTmFtZXNbZW5jW2VdLnR5cGVdO1xuICAgIH1cblxuICAgIHNwZWMgPSB7XG4gICAgICBtYXJrdHlwZTogdGhpcy5fbWFya3R5cGUsXG4gICAgICBlbmM6IGVuYyxcbiAgICAgIGZpbHRlcjogdGhpcy5fZmlsdGVyXG4gICAgfTtcblxuICAgIGlmICghZXhjbHVkZUNvbmZpZykge1xuICAgICAgc3BlYy5jb25maWcgPSB1dGlsLmR1cGxpY2F0ZSh0aGlzLl9jb25maWcpO1xuICAgIH1cblxuICAgIGlmICghZXhjbHVkZURhdGEpIHtcbiAgICAgIHNwZWMuZGF0YSA9IHV0aWwuZHVwbGljYXRlKHRoaXMuX2RhdGEpO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBkZWZhdWx0c1xuICAgIHZhciBkZWZhdWx0cyA9IHNjaGVtYS5pbnN0YW50aWF0ZSgpO1xuICAgIHJldHVybiBzY2hlbWEudXRpbC5zdWJ0cmFjdChzcGVjLCBkZWZhdWx0cyk7XG4gIH07XG5cbiAgcHJvdG8udG9TaG9ydGhhbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYyA9IGNvbnN0cy5zaG9ydGhhbmQ7XG4gICAgcmV0dXJuICdtYXJrJyArIGMuYXNzaWduICsgdGhpcy5fbWFya3R5cGUgK1xuICAgICAgYy5kZWxpbSArIHZsZW5jLnNob3J0aGFuZCh0aGlzLl9lbmMpO1xuICB9O1xuXG4gIEVuY29kaW5nLnNob3J0aGFuZCA9IGZ1bmN0aW9uIChzcGVjKSB7XG4gICAgdmFyIGMgPSBjb25zdHMuc2hvcnRoYW5kO1xuICAgIHJldHVybiAnbWFyaycgKyBjLmFzc2lnbiArIHNwZWMubWFya3R5cGUgK1xuICAgICAgYy5kZWxpbSArIHZsZW5jLnNob3J0aGFuZChzcGVjLmVuYyk7XG4gIH07XG5cbiAgRW5jb2RpbmcuZnJvbVNob3J0aGFuZCA9IGZ1bmN0aW9uKHNob3J0aGFuZCwgZGF0YSwgY29uZmlnLCB0aGVtZSkge1xuICAgIHZhciBjID0gY29uc3RzLnNob3J0aGFuZCxcbiAgICAgICAgc3BsaXQgPSBzaG9ydGhhbmQuc3BsaXQoYy5kZWxpbSksXG4gICAgICAgIG1hcmt0eXBlID0gc3BsaXQuc2hpZnQoKS5zcGxpdChjLmFzc2lnbilbMV0udHJpbSgpLFxuICAgICAgICBlbmMgPSB2bGVuYy5mcm9tU2hvcnRoYW5kKHNwbGl0LCB0cnVlKTtcblxuICAgIHJldHVybiBuZXcgRW5jb2RpbmcobWFya3R5cGUsIGVuYywgZGF0YSwgY29uZmlnLCBudWxsLCB0aGVtZSk7XG4gIH07XG5cbiAgRW5jb2Rpbmcuc3BlY0Zyb21TaG9ydGhhbmQgPSBmdW5jdGlvbihzaG9ydGhhbmQsIGRhdGEsIGNvbmZpZywgZXhjbHVkZUNvbmZpZykge1xuICAgIHJldHVybiBFbmNvZGluZy5mcm9tU2hvcnRoYW5kKHNob3J0aGFuZCwgZGF0YSwgY29uZmlnKS50b1NwZWMoZXhjbHVkZUNvbmZpZyk7XG4gIH07XG5cbiAgRW5jb2RpbmcuZnJvbVNwZWMgPSBmdW5jdGlvbihzcGVjLCB0aGVtZSkge1xuICAgIHZhciBlbmMgPSB1dGlsLmR1cGxpY2F0ZShzcGVjLmVuYyB8fCB7fSk7XG5cbiAgICAvL2NvbnZlcnQgdHlwZSBmcm9tIHN0cmluZyB0byBiaXRjb2RlIChlLmcsIE89MSlcbiAgICBmb3IgKHZhciBlIGluIGVuYykge1xuICAgICAgZW5jW2VdLnR5cGUgPSBjb25zdHMuZGF0YVR5cGVzW2VuY1tlXS50eXBlXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEVuY29kaW5nKHNwZWMubWFya3R5cGUsIGVuYywgc3BlYy5kYXRhLCBzcGVjLmNvbmZpZywgc3BlYy5maWx0ZXIsIHRoZW1lKTtcbiAgfTtcblxuICBFbmNvZGluZy50cmFuc3Bvc2UgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgdmFyIG9sZGVuYyA9IHNwZWMuZW5jLFxuICAgICAgZW5jID0gdXRpbC5kdXBsaWNhdGUoc3BlYy5lbmMpO1xuICAgIGVuYy54ID0gb2xkZW5jLnk7XG4gICAgZW5jLnkgPSBvbGRlbmMueDtcbiAgICBlbmMucm93ID0gb2xkZW5jLmNvbDtcbiAgICBlbmMuY29sID0gb2xkZW5jLnJvdztcbiAgICBzcGVjLmVuYyA9IGVuYztcbiAgICByZXR1cm4gc3BlYztcbiAgfTtcblxuICBFbmNvZGluZy50b2dnbGVTb3J0ID0gZnVuY3Rpb24oc3BlYykge1xuICAgIHNwZWMuY29uZmlnID0gc3BlYy5jb25maWcgfHwge307XG4gICAgc3BlYy5jb25maWcudG9nZ2xlU29ydCA9IHNwZWMuY29uZmlnLnRvZ2dsZVNvcnQgPT09ICdRJyA/ICdPJyA6J1EnO1xuICAgIHJldHVybiBzcGVjO1xuICB9O1xuXG5cbiAgRW5jb2RpbmcudG9nZ2xlU29ydC5kaXJlY3Rpb24gPSBmdW5jdGlvbihzcGVjLCB1c2VUeXBlQ29kZSkge1xuICAgIGlmICghRW5jb2RpbmcudG9nZ2xlU29ydC5zdXBwb3J0KHNwZWMsIHVzZVR5cGVDb2RlKSkgeyByZXR1cm47IH1cbiAgICB2YXIgZW5jID0gc3BlYy5lbmM7XG4gICAgcmV0dXJuIGVuYy54LnR5cGUgPT09ICdPJyA/ICd4JyA6ICAneSc7XG4gIH07XG5cbiAgRW5jb2RpbmcudG9nZ2xlU29ydC5tb2RlID0gZnVuY3Rpb24oc3BlYykge1xuICAgIHJldHVybiBzcGVjLmNvbmZpZy50b2dnbGVTb3J0O1xuICB9O1xuXG4gIEVuY29kaW5nLnRvZ2dsZVNvcnQuc3VwcG9ydCA9IGZ1bmN0aW9uKHNwZWMsIHN0YXRzLCB1c2VUeXBlQ29kZSkge1xuICAgIHZhciBlbmMgPSBzcGVjLmVuYyxcbiAgICAgIGlzVHlwZSA9IHZsZmllbGQuaXNUeXBlLmdldCh1c2VUeXBlQ29kZSk7XG5cbiAgICBpZiAodmxlbmMuaGFzKGVuYywgUk9XKSB8fCB2bGVuYy5oYXMoZW5jLCBDT0wpIHx8XG4gICAgICAhdmxlbmMuaGFzKGVuYywgWCkgfHwgIXZsZW5jLmhhcyhlbmMsIFkpIHx8XG4gICAgICAhRW5jb2RpbmcuYWx3YXlzTm9PY2NsdXNpb24oc3BlYywgc3RhdHMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuICggaXNUeXBlKGVuYy54LCBPKSAmJiB2bGZpZWxkLmlzTWVhc3VyZShlbmMueSwgdXNlVHlwZUNvZGUpKSA/ICd4JyA6XG4gICAgICAoIGlzVHlwZShlbmMueSwgTykgJiYgdmxmaWVsZC5pc01lYXN1cmUoZW5jLngsIHVzZVR5cGVDb2RlKSkgPyAneScgOiBmYWxzZTtcbiAgfTtcblxuICBFbmNvZGluZy50b2dnbGVGaWx0ZXJOdWxsTyA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICBzcGVjLmNvbmZpZyA9IHNwZWMuY29uZmlnIHx8IHt9O1xuICAgIHNwZWMuY29uZmlnLmZpbHRlck51bGwgPSBzcGVjLmNvbmZpZy5maWx0ZXJOdWxsIHx8IHsgLy9GSVhNRVxuICAgICAgVDogdHJ1ZSxcbiAgICAgIFE6IHRydWVcbiAgICB9O1xuICAgIHNwZWMuY29uZmlnLmZpbHRlck51bGwuTyA9ICFzcGVjLmNvbmZpZy5maWx0ZXJOdWxsLk87XG4gICAgcmV0dXJuIHNwZWM7XG4gIH07XG5cbiAgRW5jb2RpbmcudG9nZ2xlRmlsdGVyTnVsbE8uc3VwcG9ydCA9IGZ1bmN0aW9uKHNwZWMsIHN0YXRzKSB7XG4gICAgdmFyIGZpZWxkcyA9IHZsZW5jLmZpZWxkcyhzcGVjLmVuYyk7XG4gICAgZm9yICh2YXIgZmllbGROYW1lIGluIGZpZWxkcykge1xuICAgICAgdmFyIGZpZWxkTGlzdCA9IGZpZWxkc1tmaWVsZE5hbWVdO1xuICAgICAgaWYgKGZpZWxkTGlzdC5jb250YWluc1R5cGUuTyAmJiBmaWVsZE5hbWUgaW4gc3RhdHMgJiYgc3RhdHNbZmllbGROYW1lXS5udWxscyA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICByZXR1cm4gRW5jb2Rpbmc7XG59KSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFnZ3JlZ2F0ZXM7XG5cbmZ1bmN0aW9uIGFnZ3JlZ2F0ZXMoc3BlYywgZW5jb2RpbmcsIG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG5cbiAgdmFyIGRpbXMgPSB7fSwgbWVhcyA9IHt9LCBkZXRhaWwgPSB7fSwgZmFjZXRzID0ge30sXG4gICAgZGF0YSA9IHNwZWMuZGF0YVsxXTsgLy8gY3VycmVudGx5IGRhdGFbMF0gaXMgcmF3IGFuZCBkYXRhWzFdIGlzIHRhYmxlXG5cbiAgZW5jb2RpbmcuZm9yRWFjaChmdW5jdGlvbihmaWVsZCwgZW5jVHlwZSkge1xuICAgIGlmIChmaWVsZC5hZ2dyKSB7XG4gICAgICBpZiAoZmllbGQuYWdnciA9PT0gJ2NvdW50Jykge1xuICAgICAgICBtZWFzLmNvdW50ID0ge29wOiAnY291bnQnLCBmaWVsZDogJyonfTtcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgbWVhc1tmaWVsZC5hZ2dyICsgJ3wnKyBmaWVsZC5uYW1lXSA9IHtcbiAgICAgICAgICBvcDogZmllbGQuYWdncixcbiAgICAgICAgICBmaWVsZDogJ2RhdGEuJysgZmllbGQubmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkaW1zW2ZpZWxkLm5hbWVdID0gZW5jb2RpbmcuZmllbGQoZW5jVHlwZSk7XG4gICAgICBpZiAoZW5jVHlwZSA9PSBST1cgfHwgZW5jVHlwZSA9PSBDT0wpIHtcbiAgICAgICAgZmFjZXRzW2ZpZWxkLm5hbWVdID0gZGltc1tmaWVsZC5uYW1lXTtcbiAgICAgIH1lbHNlIGlmIChlbmNUeXBlICE9PSBYICYmIGVuY1R5cGUgIT09IFkpIHtcbiAgICAgICAgZGV0YWlsW2ZpZWxkLm5hbWVdID0gZGltc1tmaWVsZC5uYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBkaW1zID0gdXRpbC52YWxzKGRpbXMpO1xuICBtZWFzID0gdXRpbC52YWxzKG1lYXMpO1xuXG4gIGlmIChtZWFzLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoIWRhdGEudHJhbnNmb3JtKSBkYXRhLnRyYW5zZm9ybSA9IFtdO1xuICAgIGRhdGEudHJhbnNmb3JtLnB1c2goe1xuICAgICAgdHlwZTogJ2FnZ3JlZ2F0ZScsXG4gICAgICBncm91cGJ5OiBkaW1zLFxuICAgICAgZmllbGRzOiBtZWFzXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkZXRhaWxzOiB1dGlsLnZhbHMoZGV0YWlsKSxcbiAgICBkaW1zOiBkaW1zLFxuICAgIGZhY2V0czogdXRpbC52YWxzKGZhY2V0cyksXG4gICAgYWdncmVnYXRlZDogbWVhcy5sZW5ndGggPiAwXG4gIH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIHNldHRlciA9IHV0aWwuc2V0dGVyLFxuICBnZXR0ZXIgPSB1dGlsLmdldHRlcixcbiAgdGltZSA9IHJlcXVpcmUoJy4vdGltZScpO1xuXG52YXIgYXhpcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmF4aXMubmFtZXMgPSBmdW5jdGlvbihwcm9wcykge1xuICByZXR1cm4gdXRpbC5rZXlzKHV0aWwua2V5cyhwcm9wcykucmVkdWNlKGZ1bmN0aW9uKGEsIHgpIHtcbiAgICB2YXIgcyA9IHByb3BzW3hdLnNjYWxlO1xuICAgIGlmIChzID09PSBYIHx8IHMgPT09IFkpIGFbcHJvcHNbeF0uc2NhbGVdID0gMTtcbiAgICByZXR1cm4gYTtcbiAgfSwge30pKTtcbn07XG5cbmF4aXMuZGVmcyA9IGZ1bmN0aW9uKG5hbWVzLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cywgb3B0KSB7XG4gIHJldHVybiBuYW1lcy5yZWR1Y2UoZnVuY3Rpb24oYSwgbmFtZSkge1xuICAgIGEucHVzaChheGlzLmRlZihuYW1lLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cywgb3B0KSk7XG4gICAgcmV0dXJuIGE7XG4gIH0sIFtdKTtcbn07XG5cbmF4aXMuZGVmID0gZnVuY3Rpb24obmFtZSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMsIG9wdCkge1xuICB2YXIgdHlwZSA9IG5hbWU7XG4gIHZhciBpc0NvbCA9IG5hbWUgPT0gQ09MLCBpc1JvdyA9IG5hbWUgPT0gUk9XO1xuICB2YXIgcm93T2Zmc2V0ID0gYXhpc1RpdGxlT2Zmc2V0KGVuY29kaW5nLCBsYXlvdXQsIFkpICsgMjAsXG4gICAgY2VsbFBhZGRpbmcgPSBsYXlvdXQuY2VsbFBhZGRpbmc7XG5cblxuICBpZiAoaXNDb2wpIHR5cGUgPSAneCc7XG4gIGlmIChpc1JvdykgdHlwZSA9ICd5JztcblxuICB2YXIgZGVmID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgc2NhbGU6IG5hbWVcbiAgfTtcblxuICBpZiAoZW5jb2RpbmcuYXhpcyhuYW1lKS5ncmlkKSB7XG4gICAgZGVmLmdyaWQgPSB0cnVlO1xuICAgIGRlZi5sYXllciA9IChpc1JvdyB8fCBpc0NvbCkgPyAnZnJvbnQnIDogICdiYWNrJztcblxuICAgIGlmIChpc0NvbCkge1xuICAgICAgLy8gc2V0IGdyaWQgcHJvcGVydHkgLS0gcHV0IHRoZSBsaW5lcyBvbiB0aGUgcmlnaHQgdGhlIGNlbGxcbiAgICAgIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsICdncmlkJ10sIHtcbiAgICAgICAgeDoge1xuICAgICAgICAgIG9mZnNldDogbGF5b3V0LmNlbGxXaWR0aCAqICgxKyBjZWxsUGFkZGluZy8yLjApLFxuICAgICAgICAgIC8vIGRlZmF1bHQgdmFsdWUocykgLS0gdmVnYSBkb2Vzbid0IGRvIHJlY3Vyc2l2ZSBtZXJnZVxuICAgICAgICAgIHNjYWxlOiAnY29sJ1xuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgdmFsdWU6IC1sYXlvdXQuY2VsbEhlaWdodCAqIChjZWxsUGFkZGluZy8yKSxcbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlOiB7IHZhbHVlOiBlbmNvZGluZy5jb25maWcoJ2NlbGxHcmlkQ29sb3InKSB9LFxuICAgICAgICBvcGFjaXR5OiB7IHZhbHVlOiBlbmNvZGluZy5jb25maWcoJ2NlbGxHcmlkT3BhY2l0eScpIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXNSb3cpIHtcbiAgICAgIC8vIHNldCBncmlkIHByb3BlcnR5IC0tIHB1dCB0aGUgbGluZXMgb24gdGhlIHRvcFxuICAgICAgc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywgJ2dyaWQnXSwge1xuICAgICAgICB5OiB7XG4gICAgICAgICAgb2Zmc2V0OiAtbGF5b3V0LmNlbGxIZWlnaHQgKiAoY2VsbFBhZGRpbmcvMiksXG4gICAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZShzKSAtLSB2ZWdhIGRvZXNuJ3QgZG8gcmVjdXJzaXZlIG1lcmdlXG4gICAgICAgICAgc2NhbGU6ICdyb3cnXG4gICAgICAgIH0sXG4gICAgICAgIHg6IHtcbiAgICAgICAgICB2YWx1ZTogcm93T2Zmc2V0XG4gICAgICAgIH0sXG4gICAgICAgIHgyOiB7XG4gICAgICAgICAgb2Zmc2V0OiByb3dPZmZzZXQgKyAobGF5b3V0LmNlbGxXaWR0aCAqIDAuMDUpLFxuICAgICAgICAgIC8vIGRlZmF1bHQgdmFsdWUocykgLS0gdmVnYSBkb2Vzbid0IGRvIHJlY3Vyc2l2ZSBtZXJnZVxuICAgICAgICAgIGdyb3VwOiBcIm1hcmsuZ3JvdXAud2lkdGhcIixcbiAgICAgICAgICBtdWx0OiAxXG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZTogeyB2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdjZWxsR3JpZENvbG9yJykgfSxcbiAgICAgICAgb3BhY2l0eTogeyB2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdjZWxsR3JpZE9wYWNpdHknKSB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywgJ2dyaWQnXSwge1xuICAgICAgICBzdHJva2U6IHsgdmFsdWU6IGVuY29kaW5nLmNvbmZpZygnZ3JpZENvbG9yJykgfSxcbiAgICAgICAgb3BhY2l0eTogeyB2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdncmlkT3BhY2l0eScpIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmNvZGluZy5heGlzKG5hbWUpLnRpdGxlKSB7XG4gICAgZGVmID0gYXhpc190aXRsZShkZWYsIG5hbWUsIGVuY29kaW5nLCBsYXlvdXQsIG9wdCk7XG4gIH1cblxuICBpZiAoaXNSb3cgfHwgaXNDb2wpIHtcbiAgICBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCAndGlja3MnXSwge1xuICAgICAgb3BhY2l0eToge3ZhbHVlOiAwfVxuICAgIH0pO1xuICAgIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsICdtYWpvclRpY2tzJ10sIHtcbiAgICAgIG9wYWNpdHk6IHt2YWx1ZTogMH1cbiAgICB9KTtcbiAgICBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCAnYXhpcyddLCB7XG4gICAgICBvcGFjaXR5OiB7dmFsdWU6IDB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoaXNDb2wpIHtcbiAgICBkZWYub3JpZW50ID0gJ3RvcCc7XG4gIH1cblxuICBpZiAoaXNSb3cpIHtcbiAgICBkZWYub2Zmc2V0ID0gcm93T2Zmc2V0O1xuICB9XG5cbiAgaWYgKG5hbWUgPT0gWCkge1xuICAgIGlmIChlbmNvZGluZy5oYXMoWSkgJiYgZW5jb2RpbmcuaXNPcmRpbmFsU2NhbGUoWSkgJiYgZW5jb2RpbmcuY2FyZGluYWxpdHkoWSwgc3RhdHMpID4gMzApIHtcbiAgICAgIGRlZi5vcmllbnQgPSAndG9wJztcbiAgICB9XG5cbiAgICBpZiAoZW5jb2RpbmcuaXNEaW1lbnNpb24oWCkgfHwgZW5jb2RpbmcuaXNUeXBlKFgsIFQpKSB7XG4gICAgICBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCdsYWJlbHMnXSwge1xuICAgICAgICBhbmdsZToge3ZhbHVlOiAyNzB9LFxuICAgICAgICBhbGlnbjoge3ZhbHVlOiAncmlnaHQnfSxcbiAgICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogJ21pZGRsZSd9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgeyAvLyBRXG4gICAgICBkZWYudGlja3MgPSA1O1xuICAgIH1cbiAgfVxuXG4gIGRlZiA9IGF4aXNfbGFiZWxzKGRlZiwgbmFtZSwgZW5jb2RpbmcsIGxheW91dCwgb3B0KTtcblxuICByZXR1cm4gZGVmO1xufTtcblxuZnVuY3Rpb24gYXhpc190aXRsZShkZWYsIG5hbWUsIGVuY29kaW5nLCBsYXlvdXQsIG9wdCkge1xuICAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG5cbiAgdmFyIG1heGxlbmd0aCA9IG51bGwsXG4gICAgZmllbGRUaXRsZSA9IGVuY29kaW5nLmZpZWxkVGl0bGUobmFtZSk7XG4gIGlmIChuYW1lPT09WCkge1xuICAgIG1heGxlbmd0aCA9IGxheW91dC5jZWxsV2lkdGggLyBlbmNvZGluZy5jb25maWcoJ2NoYXJhY3RlcldpZHRoJyk7XG4gIH0gZWxzZSBpZiAobmFtZSA9PT0gWSkge1xuICAgIG1heGxlbmd0aCA9IGxheW91dC5jZWxsSGVpZ2h0IC8gZW5jb2RpbmcuY29uZmlnKCdjaGFyYWN0ZXJXaWR0aCcpO1xuICB9XG5cbiAgZGVmLnRpdGxlID0gbWF4bGVuZ3RoID8gdXRpbC50cnVuY2F0ZShmaWVsZFRpdGxlLCBtYXhsZW5ndGgpIDogZmllbGRUaXRsZTtcblxuICBpZiAobmFtZSA9PT0gUk9XKSB7XG4gICAgc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywndGl0bGUnXSwge1xuICAgICAgYW5nbGU6IHt2YWx1ZTogMH0sXG4gICAgICBhbGlnbjoge3ZhbHVlOiAncmlnaHQnfSxcbiAgICAgIGJhc2VsaW5lOiB7dmFsdWU6ICdtaWRkbGUnfSxcbiAgICAgIGR5OiB7dmFsdWU6ICgtbGF5b3V0LmhlaWdodC8yKSAtMjB9XG4gICAgfSk7XG4gIH1cblxuICBkZWYudGl0bGVPZmZzZXQgPSBheGlzVGl0bGVPZmZzZXQoZW5jb2RpbmcsIGxheW91dCwgbmFtZSk7XG4gIHJldHVybiBkZWY7XG59XG5cbmZ1bmN0aW9uIGF4aXNfbGFiZWxzKGRlZiwgbmFtZSwgZW5jb2RpbmcsIGxheW91dCwgb3B0KSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcblxuICB2YXIgZm47XG4gIC8vIGFkZCBjdXN0b20gbGFiZWwgZm9yIHRpbWUgdHlwZVxuICBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFQpICYmIChmbiA9IGVuY29kaW5nLmZuKG5hbWUpKSAmJiAodGltZS5oYXNTY2FsZShmbikpKSB7XG4gICAgc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywnbGFiZWxzJywndGV4dCcsJ3NjYWxlJ10sICd0aW1lLScrIGZuKTtcbiAgfVxuXG4gIHZhciB0ZXh0VGVtcGxhdGVQYXRoID0gWydwcm9wZXJ0aWVzJywnbGFiZWxzJywndGV4dCcsJ3RlbXBsYXRlJ107XG4gIGlmIChlbmNvZGluZy5heGlzKG5hbWUpLmZvcm1hdCkge1xuICAgIGRlZi5mb3JtYXQgPSBlbmNvZGluZy5heGlzKG5hbWUpLmZvcm1hdDtcbiAgfSBlbHNlIGlmIChlbmNvZGluZy5pc1R5cGUobmFtZSwgUSkpIHtcbiAgICBzZXR0ZXIoZGVmLCB0ZXh0VGVtcGxhdGVQYXRoLCBcInt7ZGF0YSB8IG51bWJlcjonLjNzJ319XCIpO1xuICB9IGVsc2UgaWYgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBUKSAmJiAhZW5jb2RpbmcuZm4obmFtZSkpIHtcbiAgICBzZXR0ZXIoZGVmLCB0ZXh0VGVtcGxhdGVQYXRoLCBcInt7ZGF0YSB8IHRpbWU6JyVZLSVtLSVkJ319XCIpO1xuICB9IGVsc2UgaWYgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBUKSAmJiBlbmNvZGluZy5mbihuYW1lKSA9PT0gJ3llYXInKSB7XG4gICAgc2V0dGVyKGRlZiwgdGV4dFRlbXBsYXRlUGF0aCwgXCJ7e2RhdGEgfCBudW1iZXI6J2QnfX1cIik7XG4gIH0gZWxzZSBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIE8pICYmIGVuY29kaW5nLmF4aXMobmFtZSkubWF4TGFiZWxMZW5ndGgpIHtcbiAgICBzZXR0ZXIoZGVmLCB0ZXh0VGVtcGxhdGVQYXRoLCAne3tkYXRhIHwgdHJ1bmNhdGU6JyArIGVuY29kaW5nLmF4aXMobmFtZSkubWF4TGFiZWxMZW5ndGggKyAnfX0nKTtcbiAgfVxuXG4gIHJldHVybiBkZWY7XG59XG5cbmZ1bmN0aW9uIGF4aXNUaXRsZU9mZnNldChlbmNvZGluZywgbGF5b3V0LCBuYW1lKSB7XG4gIHZhciB2YWx1ZSA9IGVuY29kaW5nLmF4aXMobmFtZSkudGl0bGVPZmZzZXQ7XG4gIGlmICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlIFJPVzogcmV0dXJuIDA7XG4gICAgY2FzZSBDT0w6IHJldHVybiAzNTtcbiAgfVxuICByZXR1cm4gZ2V0dGVyKGxheW91dCwgW25hbWUsICdheGlzVGl0bGVPZmZzZXQnXSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5uaW5nO1xuXG5mdW5jdGlvbiBiaW5uaW5nKHNwZWMsIGVuY29kaW5nLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gIGlmICghc3BlYy50cmFuc2Zvcm0pIHNwZWMudHJhbnNmb3JtID0gW107XG5cbiAgZW5jb2RpbmcuZm9yRWFjaChmdW5jdGlvbihmaWVsZCwgZW5jVHlwZSkge1xuICAgIGlmIChlbmNvZGluZy5iaW4oZW5jVHlwZSkpIHtcbiAgICAgIHNwZWMudHJhbnNmb3JtLnB1c2goe1xuICAgICAgICB0eXBlOiAnYmluJyxcbiAgICAgICAgZmllbGQ6ICdkYXRhLicgKyBmaWVsZC5uYW1lLFxuICAgICAgICBvdXRwdXQ6ICdkYXRhLmJpbl8nICsgZmllbGQubmFtZSxcbiAgICAgICAgbWF4YmluczogZW5jb2RpbmcuYmluKGVuY1R5cGUpLm1heGJpbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdW1tYXJ5ID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdkYXRhbGliL3NyYy9zdW1tYXJ5Jyk7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlO1xuXG52YXIgRW5jb2RpbmcgPSByZXF1aXJlKCcuLi9FbmNvZGluZycpLFxuICBheGlzID0gY29tcGlsZS5heGlzID0gcmVxdWlyZSgnLi9heGlzJyksXG4gIGZpbHRlciA9IGNvbXBpbGUuZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKSxcbiAgbGVnZW5kID0gY29tcGlsZS5sZWdlbmQgPSByZXF1aXJlKCcuL2xlZ2VuZCcpLFxuICBtYXJrcyA9IGNvbXBpbGUubWFya3MgPSByZXF1aXJlKCcuL21hcmtzJyksXG4gIHNjYWxlID0gY29tcGlsZS5zY2FsZSA9IHJlcXVpcmUoJy4vc2NhbGUnKTtcblxuY29tcGlsZS5hZ2dyZWdhdGUgPSByZXF1aXJlKCcuL2FnZ3JlZ2F0ZScpO1xuY29tcGlsZS5iaW4gPSByZXF1aXJlKCcuL2JpbicpO1xuY29tcGlsZS5mYWNldCA9IHJlcXVpcmUoJy4vZmFjZXQnKTtcbmNvbXBpbGUuZ3JvdXAgPSByZXF1aXJlKCcuL2dyb3VwJyk7XG5jb21waWxlLmxheW91dCA9IHJlcXVpcmUoJy4vbGF5b3V0Jyk7XG5jb21waWxlLnNvcnQgPSByZXF1aXJlKCcuL3NvcnQnKTtcbmNvbXBpbGUuc3RhY2sgPSByZXF1aXJlKCcuL3N0YWNrJyk7XG5jb21waWxlLnN0eWxlID0gcmVxdWlyZSgnLi9zdHlsZScpO1xuY29tcGlsZS5zdWJmYWNldCA9IHJlcXVpcmUoJy4vc3ViZmFjZXQnKTtcbmNvbXBpbGUudGVtcGxhdGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlJyk7XG5jb21waWxlLnRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKTtcblxuZnVuY3Rpb24gY29tcGlsZShzcGVjLCBzdGF0cywgdGhlbWUpIHtcbiAgcmV0dXJuIGNvbXBpbGUuZW5jb2RpbmcoRW5jb2RpbmcuZnJvbVNwZWMoc3BlYywgdGhlbWUpLCBzdGF0cyk7XG59XG5cbmNvbXBpbGUuc2hvcnRoYW5kID0gZnVuY3Rpb24gKHNob3J0aGFuZCwgc3RhdHMsIGNvbmZpZywgdGhlbWUpIHtcbiAgcmV0dXJuIGNvbXBpbGUuZW5jb2RpbmcoRW5jb2RpbmcuZnJvbVNob3J0aGFuZChzaG9ydGhhbmQsIGNvbmZpZywgdGhlbWUpLCBzdGF0cyk7XG59O1xuXG5jb21waWxlLmVuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGF0cykge1xuICAvLyBubyBuZWVkIHRvIHBhc3Mgc3RhdHMgaWYgeW91IHBhc3MgaW4gdGhlIGRhdGFcbiAgaWYgKCFzdGF0cyAmJiBlbmNvZGluZy5oYXNWYWx1ZXMoKSkge1xuICAgIHN0YXRzID0gc3VtbWFyeShlbmNvZGluZy5kYXRhKCd2YWx1ZXMnKSkucmVkdWNlKGZ1bmN0aW9uKHMsIHApIHtcbiAgICAgIHNbcC5maWVsZF0gPSBwO1xuICAgICAgcmV0dXJuIHM7XG4gICAgfSwge30pO1xuICB9XG5cbiAgdmFyIGxheW91dCA9IGNvbXBpbGUubGF5b3V0KGVuY29kaW5nLCBzdGF0cyksXG4gICAgc3R5bGUgPSBjb21waWxlLnN0eWxlKGVuY29kaW5nLCBzdGF0cyksXG4gICAgc3BlYyA9IGNvbXBpbGUudGVtcGxhdGUoZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpLFxuICAgIGdyb3VwID0gc3BlYy5tYXJrc1swXSxcbiAgICBtYXJrID0gbWFya3NbZW5jb2RpbmcubWFya3R5cGUoKV0sXG4gICAgbWRlZnMgPSBtYXJrcy5kZWYobWFyaywgZW5jb2RpbmcsIGxheW91dCwgc3R5bGUpLFxuICAgIG1kZWYgPSBtZGVmc1swXTsgIC8vIFRPRE86IHJlbW92ZSB0aGlzIGRpcnR5IGhhY2sgYnkgcmVmYWN0b3JpbmcgdGhlIHdob2xlIGZsb3dcblxuICBmaWx0ZXIuYWRkRmlsdGVycyhzcGVjLCBlbmNvZGluZyk7XG4gIHZhciBzb3J0aW5nID0gY29tcGlsZS5zb3J0KHNwZWMsIGVuY29kaW5nLCBzdGF0cyk7XG5cbiAgdmFyIGhhc1JvdyA9IGVuY29kaW5nLmhhcyhST1cpLCBoYXNDb2wgPSBlbmNvZGluZy5oYXMoQ09MKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1kZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgZ3JvdXAubWFya3MucHVzaChtZGVmc1tpXSk7XG4gIH1cblxuICBjb21waWxlLmJpbihzcGVjLmRhdGFbMV0sIGVuY29kaW5nKTtcblxuICB2YXIgbGluZVR5cGUgPSBtYXJrc1tlbmNvZGluZy5tYXJrdHlwZSgpXS5saW5lO1xuXG4gIHNwZWMgPSBjb21waWxlLnRpbWUoc3BlYywgZW5jb2RpbmcpO1xuXG4gIC8vIGhhbmRsZSBzdWJmYWNldHNcbiAgdmFyIGFnZ1Jlc3VsdCA9IGNvbXBpbGUuYWdncmVnYXRlKHNwZWMsIGVuY29kaW5nKSxcbiAgICBkZXRhaWxzID0gYWdnUmVzdWx0LmRldGFpbHMsXG4gICAgaGFzRGV0YWlscyA9IGRldGFpbHMgJiYgZGV0YWlscy5sZW5ndGggPiAwLFxuICAgIHN0YWNrID0gaGFzRGV0YWlscyAmJiBjb21waWxlLnN0YWNrKHNwZWMsIGVuY29kaW5nLCBtZGVmLCBhZ2dSZXN1bHQuZmFjZXRzKTtcblxuICBpZiAoaGFzRGV0YWlscyAmJiAoc3RhY2sgfHwgbGluZVR5cGUpKSB7XG4gICAgLy9zdWJmYWNldCB0byBncm91cCBzdGFjayAvIGxpbmUgdG9nZXRoZXIgaW4gb25lIGdyb3VwXG4gICAgY29tcGlsZS5zdWJmYWNldChncm91cCwgbWRlZiwgZGV0YWlscywgc3RhY2ssIGVuY29kaW5nKTtcbiAgfVxuXG4gIC8vIGF1dG8tc29ydCBsaW5lL2FyZWEgdmFsdWVzXG4gIC8vVE9ETyhrYW5pdHcpOiBoYXZlIHNvbWUgY29uZmlnIHRvIHR1cm4gb2ZmIGF1dG8tc29ydCBmb3IgbGluZSAoZm9yIGxpbmUgY2hhcnQgdGhhdCBlbmNvZGVzIHRlbXBvcmFsIGluZm9ybWF0aW9uKVxuICBpZiAobGluZVR5cGUpIHtcbiAgICB2YXIgZiA9IChlbmNvZGluZy5pc01lYXN1cmUoWCkgJiYgZW5jb2RpbmcuaXNEaW1lbnNpb24oWSkpID8gWSA6IFg7XG4gICAgaWYgKCFtZGVmLmZyb20pIG1kZWYuZnJvbSA9IHt9O1xuICAgIC8vIFRPRE86IHdoeSAtID9cbiAgICBtZGVmLmZyb20udHJhbnNmb3JtID0gW3t0eXBlOiAnc29ydCcsIGJ5OiAnLScgKyBlbmNvZGluZy5maWVsZChmKX1dO1xuICB9XG5cbiAgLy8gU21hbGwgTXVsdGlwbGVzXG4gIGlmIChoYXNSb3cgfHwgaGFzQ29sKSB7XG4gICAgc3BlYyA9IGNvbXBpbGUuZmFjZXQoZ3JvdXAsIGVuY29kaW5nLCBsYXlvdXQsIHN0eWxlLCBzb3J0aW5nLCBzcGVjLCBtZGVmLCBzdGFjaywgc3RhdHMpO1xuICAgIHNwZWMubGVnZW5kcyA9IGxlZ2VuZC5kZWZzKGVuY29kaW5nKTtcbiAgfSBlbHNlIHtcbiAgICBncm91cC5zY2FsZXMgPSBzY2FsZS5kZWZzKHNjYWxlLm5hbWVzKG1kZWYucHJvcGVydGllcy51cGRhdGUpLCBlbmNvZGluZywgbGF5b3V0LCBzdHlsZSwgc29ydGluZyxcbiAgICAgIHtzdGFjazogc3RhY2ssIHN0YXRzOiBzdGF0c30pO1xuICAgIGdyb3VwLmF4ZXMgPSBheGlzLmRlZnMoYXhpcy5uYW1lcyhtZGVmLnByb3BlcnRpZXMudXBkYXRlKSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpO1xuICAgIGdyb3VwLmxlZ2VuZHMgPSBsZWdlbmQuZGVmcyhlbmNvZGluZyk7XG4gIH1cblxuICBmaWx0ZXIuZmlsdGVyTGVzc1RoYW5aZXJvKHNwZWMsIGVuY29kaW5nKTtcblxuICByZXR1cm4gc3BlYztcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxudmFyIGF4aXMgPSByZXF1aXJlKCcuL2F4aXMnKSxcbiAgZ3JvdXBkZWYgPSByZXF1aXJlKCcuL2dyb3VwJykuZGVmLFxuICBzY2FsZSA9IHJlcXVpcmUoJy4vc2NhbGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWNldGluZztcblxuZnVuY3Rpb24gZmFjZXRpbmcoZ3JvdXAsIGVuY29kaW5nLCBsYXlvdXQsIHN0eWxlLCBzb3J0aW5nLCBzcGVjLCBtZGVmLCBzdGFjaywgc3RhdHMpIHtcbiAgdmFyIGVudGVyID0gZ3JvdXAucHJvcGVydGllcy5lbnRlcjtcbiAgdmFyIGZhY2V0S2V5cyA9IFtdLCBjZWxsQXhlcyA9IFtdLCBmcm9tLCBheGVzR3JwO1xuXG4gIHZhciBoYXNSb3cgPSBlbmNvZGluZy5oYXMoUk9XKSwgaGFzQ29sID0gZW5jb2RpbmcuaGFzKENPTCk7XG5cbiAgZW50ZXIuZmlsbCA9IHt2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdjZWxsQmFja2dyb3VuZENvbG9yJyl9O1xuXG4gIC8vbW92ZSBcImZyb21cIiB0byBjZWxsIGxldmVsIGFuZCBhZGQgZmFjZXQgdHJhbnNmb3JtXG4gIGdyb3VwLmZyb20gPSB7ZGF0YTogZ3JvdXAubWFya3NbMF0uZnJvbS5kYXRhfTtcblxuICAvLyBIYWNrLCB0aGlzIG5lZWRzIHRvIGJlIHJlZmFjdG9yZWRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5tYXJrcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtYXJrID0gZ3JvdXAubWFya3NbaV07XG4gICAgaWYgKG1hcmsuZnJvbS50cmFuc2Zvcm0pIHtcbiAgICAgIGRlbGV0ZSBtYXJrLmZyb20uZGF0YTsgLy9uZWVkIHRvIGtlZXAgdHJhbnNmb3JtIGZvciBzdWJmYWNldHRpbmcgY2FzZVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgbWFyay5mcm9tO1xuICAgIH1cbiAgfVxuXG4gIGlmIChoYXNSb3cpIHtcbiAgICBpZiAoIWVuY29kaW5nLmlzRGltZW5zaW9uKFJPVykpIHtcbiAgICAgIHV0aWwuZXJyb3IoJ1JvdyBlbmNvZGluZyBzaG91bGQgYmUgb3JkaW5hbC4nKTtcbiAgICB9XG4gICAgZW50ZXIueSA9IHtzY2FsZTogUk9XLCBmaWVsZDogJ2tleXMuJyArIGZhY2V0S2V5cy5sZW5ndGh9O1xuICAgIGVudGVyLmhlaWdodCA9IHsndmFsdWUnOiBsYXlvdXQuY2VsbEhlaWdodH07IC8vIEhBQ0tcblxuICAgIGZhY2V0S2V5cy5wdXNoKGVuY29kaW5nLmZpZWxkKFJPVykpO1xuXG4gICAgaWYgKGhhc0NvbCkge1xuICAgICAgZnJvbSA9IHV0aWwuZHVwbGljYXRlKGdyb3VwLmZyb20pO1xuICAgICAgZnJvbS50cmFuc2Zvcm0gPSBmcm9tLnRyYW5zZm9ybSB8fCBbXTtcbiAgICAgIGZyb20udHJhbnNmb3JtLnVuc2hpZnQoe3R5cGU6ICdmYWNldCcsIGtleXM6IFtlbmNvZGluZy5maWVsZChDT0wpXX0pO1xuICAgIH1cblxuICAgIGF4ZXNHcnAgPSBncm91cGRlZigneC1heGVzJywge1xuICAgICAgICBheGVzOiBlbmNvZGluZy5oYXMoWCkgPyBheGlzLmRlZnMoWyd4J10sIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgeDogaGFzQ29sID8ge3NjYWxlOiBDT0wsIGZpZWxkOiAna2V5cy4wJ30gOiB7dmFsdWU6IDB9LFxuICAgICAgICB3aWR0aDogaGFzQ29sICYmIHsndmFsdWUnOiBsYXlvdXQuY2VsbFdpZHRofSwgLy9IQUNLP1xuICAgICAgICBmcm9tOiBmcm9tXG4gICAgICB9KTtcblxuICAgIHNwZWMubWFya3MudW5zaGlmdChheGVzR3JwKTsgLy8gbmVlZCB0byBwcmVwZW5kIHNvIGl0IGFwcGVhcnMgdW5kZXIgdGhlIHBsb3RzXG4gICAgKHNwZWMuYXhlcyA9IHNwZWMuYXhlcyB8fCBbXSk7XG4gICAgc3BlYy5heGVzLnB1c2guYXBwbHkoc3BlYy5heGVzLCBheGlzLmRlZnMoWydyb3cnXSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpKTtcbiAgfSBlbHNlIHsgLy8gZG9lc24ndCBoYXZlIHJvd1xuICAgIGlmIChlbmNvZGluZy5oYXMoWCkpIHtcbiAgICAgIC8va2VlcCB4IGF4aXMgaW4gdGhlIGNlbGxcbiAgICAgIGNlbGxBeGVzLnB1c2guYXBwbHkoY2VsbEF4ZXMsIGF4aXMuZGVmcyhbJ3gnXSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaGFzQ29sKSB7XG4gICAgaWYgKCFlbmNvZGluZy5pc0RpbWVuc2lvbihDT0wpKSB7XG4gICAgICB1dGlsLmVycm9yKCdDb2wgZW5jb2Rpbmcgc2hvdWxkIGJlIG9yZGluYWwuJyk7XG4gICAgfVxuICAgIGVudGVyLnggPSB7c2NhbGU6IENPTCwgZmllbGQ6ICdrZXlzLicgKyBmYWNldEtleXMubGVuZ3RofTtcbiAgICBlbnRlci53aWR0aCA9IHsndmFsdWUnOiBsYXlvdXQuY2VsbFdpZHRofTsgLy8gSEFDS1xuXG4gICAgZmFjZXRLZXlzLnB1c2goZW5jb2RpbmcuZmllbGQoQ09MKSk7XG5cbiAgICBpZiAoaGFzUm93KSB7XG4gICAgICBmcm9tID0gdXRpbC5kdXBsaWNhdGUoZ3JvdXAuZnJvbSk7XG4gICAgICBmcm9tLnRyYW5zZm9ybSA9IGZyb20udHJhbnNmb3JtIHx8IFtdO1xuICAgICAgZnJvbS50cmFuc2Zvcm0udW5zaGlmdCh7dHlwZTogJ2ZhY2V0Jywga2V5czogW2VuY29kaW5nLmZpZWxkKFJPVyldfSk7XG4gICAgfVxuXG4gICAgYXhlc0dycCA9IGdyb3VwZGVmKCd5LWF4ZXMnLCB7XG4gICAgICBheGVzOiBlbmNvZGluZy5oYXMoWSkgPyBheGlzLmRlZnMoWyd5J10sIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSA6IHVuZGVmaW5lZCxcbiAgICAgIHk6IGhhc1JvdyAmJiB7c2NhbGU6IFJPVywgZmllbGQ6ICdrZXlzLjAnfSxcbiAgICAgIHg6IGhhc1JvdyAmJiB7dmFsdWU6IDB9LFxuICAgICAgaGVpZ2h0OiBoYXNSb3cgJiYgeyd2YWx1ZSc6IGxheW91dC5jZWxsSGVpZ2h0fSwgLy9IQUNLP1xuICAgICAgZnJvbTogZnJvbVxuICAgIH0pO1xuXG4gICAgc3BlYy5tYXJrcy51bnNoaWZ0KGF4ZXNHcnApOyAvLyBuZWVkIHRvIHByZXBlbmQgc28gaXQgYXBwZWFycyB1bmRlciB0aGUgcGxvdHNcbiAgICAoc3BlYy5heGVzID0gc3BlYy5heGVzIHx8IFtdKTtcbiAgICBzcGVjLmF4ZXMucHVzaC5hcHBseShzcGVjLmF4ZXMsIGF4aXMuZGVmcyhbJ2NvbCddLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cykpO1xuICB9IGVsc2UgeyAvLyBkb2Vzbid0IGhhdmUgY29sXG4gICAgaWYgKGVuY29kaW5nLmhhcyhZKSkge1xuICAgICAgY2VsbEF4ZXMucHVzaC5hcHBseShjZWxsQXhlcywgYXhpcy5kZWZzKFsneSddLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cykpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGFzc3VtaW5nIGVxdWFsIGNlbGxXaWR0aCBoZXJlXG4gIC8vIFRPRE86IHN1cHBvcnQgaGV0ZXJvZ2Vub3VzIGNlbGxXaWR0aCAobWF5YmUgYnkgdXNpbmcgbXVsdGlwbGUgc2NhbGVzPylcbiAgc3BlYy5zY2FsZXMgPSAoc3BlYy5zY2FsZXMgfHwgW10pLmNvbmNhdChzY2FsZS5kZWZzKFxuICAgIHNjYWxlLm5hbWVzKGVudGVyKS5jb25jYXQoc2NhbGUubmFtZXMobWRlZi5wcm9wZXJ0aWVzLnVwZGF0ZSkpLFxuICAgIGVuY29kaW5nLFxuICAgIGxheW91dCxcbiAgICBzdHlsZSxcbiAgICBzb3J0aW5nLFxuICAgIHtzdGFjazogc3RhY2ssIGZhY2V0OiB0cnVlLCBzdGF0czogc3RhdHN9XG4gICkpOyAvLyByb3cvY29sIHNjYWxlcyArIGNlbGwgc2NhbGVzXG5cbiAgaWYgKGNlbGxBeGVzLmxlbmd0aCA+IDApIHtcbiAgICBncm91cC5heGVzID0gY2VsbEF4ZXM7XG4gIH1cblxuICAvLyBhZGQgZmFjZXQgdHJhbnNmb3JtXG4gIHZhciB0cmFucyA9IChncm91cC5mcm9tLnRyYW5zZm9ybSB8fCAoZ3JvdXAuZnJvbS50cmFuc2Zvcm0gPSBbXSkpO1xuICB0cmFucy51bnNoaWZ0KHt0eXBlOiAnZmFjZXQnLCBrZXlzOiBmYWNldEtleXN9KTtcblxuICByZXR1cm4gc3BlYztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgZmlsdGVyID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxudmFyIEJJTkFSWSA9IHtcbiAgJz4nOiAgdHJ1ZSxcbiAgJz49JzogdHJ1ZSxcbiAgJz0nOiAgdHJ1ZSxcbiAgJyE9JzogdHJ1ZSxcbiAgJzwnOiAgdHJ1ZSxcbiAgJzw9JzogdHJ1ZVxufTtcblxuZmlsdGVyLmFkZEZpbHRlcnMgPSBmdW5jdGlvbihzcGVjLCBlbmNvZGluZykge1xuICB2YXIgZmlsdGVycyA9IGVuY29kaW5nLmZpbHRlcigpLFxuICAgIGRhdGEgPSBzcGVjLmRhdGFbMF07ICAvLyBhcHBseSBmaWx0ZXJzIHRvIHJhdyBkYXRhIGJlZm9yZSBhZ2dyZWdhdGlvblxuXG4gIGlmICghZGF0YS50cmFuc2Zvcm0pXG4gICAgZGF0YS50cmFuc2Zvcm0gPSBbXTtcblxuICAvLyBhZGQgY3VzdG9tIGZpbHRlcnNcbiAgZm9yICh2YXIgaSBpbiBmaWx0ZXJzKSB7XG4gICAgdmFyIGZpbHRlciA9IGZpbHRlcnNbaV07XG5cbiAgICB2YXIgY29uZGl0aW9uID0gJyc7XG4gICAgdmFyIG9wZXJhdG9yID0gZmlsdGVyLm9wZXJhdG9yO1xuICAgIHZhciBvcGVyYW5kcyA9IGZpbHRlci5vcGVyYW5kcztcblxuICAgIGlmIChCSU5BUllbb3BlcmF0b3JdKSB7XG4gICAgICAvLyBleHBlY3RzIGEgZmllbGQgYW5kIGEgdmFsdWVcbiAgICAgIGlmIChvcGVyYXRvciA9PT0gJz0nKSB7XG4gICAgICAgIG9wZXJhdG9yID0gJz09JztcbiAgICAgIH1cblxuICAgICAgdmFyIG9wMSA9IG9wZXJhbmRzWzBdO1xuICAgICAgdmFyIG9wMiA9IG9wZXJhbmRzWzFdO1xuICAgICAgY29uZGl0aW9uID0gJ2QuZGF0YS4nICsgb3AxICsgb3BlcmF0b3IgKyBvcDI7XG4gICAgfSBlbHNlIGlmIChvcGVyYXRvciA9PT0gJ25vdE51bGwnKSB7XG4gICAgICAvLyBleHBlY3RzIGEgbnVtYmVyIG9mIGZpZWxkc1xuICAgICAgZm9yICh2YXIgaiBpbiBvcGVyYW5kcykge1xuICAgICAgICBjb25kaXRpb24gKz0gJ2QuZGF0YS4nICsgb3BlcmFuZHNbal0gKyAnIT09bnVsbCc7XG4gICAgICAgIGlmIChqIDwgb3BlcmFuZHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGNvbmRpdGlvbiArPSAnICYmICc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBvcGVyYXRvcjogJywgb3BlcmF0b3IpO1xuICAgIH1cblxuICAgIGRhdGEudHJhbnNmb3JtLnB1c2goe1xuICAgICAgdHlwZTogJ2ZpbHRlcicsXG4gICAgICB0ZXN0OiBjb25kaXRpb25cbiAgICB9KTtcbiAgfVxufTtcblxuLy8gcmVtb3ZlIGxlc3MgdGhhbiAwIHZhbHVlcyBpZiB3ZSB1c2UgbG9nIGZ1bmN0aW9uXG5maWx0ZXIuZmlsdGVyTGVzc1RoYW5aZXJvID0gZnVuY3Rpb24oc3BlYywgZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcuZm9yRWFjaChmdW5jdGlvbihmaWVsZCwgZW5jVHlwZSkge1xuICAgIGlmIChlbmNvZGluZy5zY2FsZShlbmNUeXBlKS50eXBlID09PSAnbG9nJykge1xuICAgICAgc3BlYy5kYXRhWzFdLnRyYW5zZm9ybS5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2ZpbHRlcicsXG4gICAgICAgIHRlc3Q6ICdkLicgKyBlbmNvZGluZy5maWVsZChlbmNUeXBlKSArICc+MCdcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZWY6IGdyb3VwZGVmXG59O1xuXG5mdW5jdGlvbiBncm91cGRlZihuYW1lLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuICByZXR1cm4ge1xuICAgIF9uYW1lOiBuYW1lIHx8IHVuZGVmaW5lZCxcbiAgICB0eXBlOiAnZ3JvdXAnLFxuICAgIGZyb206IG9wdC5mcm9tLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIHg6IG9wdC54IHx8IHVuZGVmaW5lZCxcbiAgICAgICAgeTogb3B0LnkgfHwgdW5kZWZpbmVkLFxuICAgICAgICB3aWR0aDogb3B0LndpZHRoIHx8IHtncm91cDogJ3dpZHRoJ30sXG4gICAgICAgIGhlaWdodDogb3B0LmhlaWdodCB8fCB7Z3JvdXA6ICdoZWlnaHQnfVxuICAgICAgfVxuICAgIH0sXG4gICAgc2NhbGVzOiBvcHQuc2NhbGVzIHx8IHVuZGVmaW5lZCxcbiAgICBheGVzOiBvcHQuYXhlcyB8fCB1bmRlZmluZWQsXG4gICAgbWFya3M6IG9wdC5tYXJrcyB8fCBbXVxuICB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICBzZXR0ZXIgPSB1dGlsLnNldHRlcjtcblxubW9kdWxlLmV4cG9ydHMgPSB2bGxheW91dDtcblxuZnVuY3Rpb24gdmxsYXlvdXQoZW5jb2RpbmcsIHN0YXRzKSB7XG4gIHZhciBsYXlvdXQgPSBib3goZW5jb2RpbmcsIHN0YXRzKTtcbiAgbGF5b3V0ID0gb2Zmc2V0KGVuY29kaW5nLCBzdGF0cywgbGF5b3V0KTtcbiAgcmV0dXJuIGxheW91dDtcbn1cblxuLypcbiAgSEFDSyB0byBzZXQgY2hhcnQgc2l6ZVxuICBOT1RFOiB0aGlzIGZhaWxzIGZvciBwbG90cyBkcml2ZW4gYnkgZGVyaXZlZCB2YWx1ZXMgKGUuZy4sIGFnZ3JlZ2F0ZXMpXG4gIE9uZSBzb2x1dGlvbiBpcyB0byB1cGRhdGUgVmVnYSB0byBzdXBwb3J0IGF1dG8tc2l6aW5nXG4gIEluIHRoZSBtZWFudGltZSwgYXV0by1wYWRkaW5nIChtb3N0bHkpIGRvZXMgdGhlIHRyaWNrXG4gKi9cbmZ1bmN0aW9uIGJveChlbmNvZGluZywgc3RhdHMpIHtcbiAgdmFyIGhhc1JvdyA9IGVuY29kaW5nLmhhcyhST1cpLFxuICAgICAgaGFzQ29sID0gZW5jb2RpbmcuaGFzKENPTCksXG4gICAgICBoYXNYID0gZW5jb2RpbmcuaGFzKFgpLFxuICAgICAgaGFzWSA9IGVuY29kaW5nLmhhcyhZKSxcbiAgICAgIG1hcmt0eXBlID0gZW5jb2RpbmcubWFya3R5cGUoKTtcblxuICAvLyBGSVhNRS9IQUNLIHdlIG5lZWQgdG8gdGFrZSBmaWx0ZXIgaW50byBhY2NvdW50XG4gIHZhciB4Q2FyZGluYWxpdHkgPSBoYXNYICYmIGVuY29kaW5nLmlzRGltZW5zaW9uKFgpID8gZW5jb2RpbmcuY2FyZGluYWxpdHkoWCwgc3RhdHMpIDogMSxcbiAgICB5Q2FyZGluYWxpdHkgPSBoYXNZICYmIGVuY29kaW5nLmlzRGltZW5zaW9uKFkpID8gZW5jb2RpbmcuY2FyZGluYWxpdHkoWSwgc3RhdHMpIDogMTtcblxuICB2YXIgdXNlU21hbGxCYW5kID0geENhcmRpbmFsaXR5ID4gZW5jb2RpbmcuY29uZmlnKCdsYXJnZUJhbmRNYXhDYXJkaW5hbGl0eScpIHx8XG4gICAgeUNhcmRpbmFsaXR5ID4gZW5jb2RpbmcuY29uZmlnKCdsYXJnZUJhbmRNYXhDYXJkaW5hbGl0eScpO1xuXG4gIHZhciBjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIGNlbGxQYWRkaW5nID0gZW5jb2RpbmcuY29uZmlnKCdjZWxsUGFkZGluZycpO1xuXG4gIC8vIHNldCBjZWxsV2lkdGhcbiAgaWYgKGhhc1gpIHtcbiAgICBpZiAoZW5jb2RpbmcuaXNPcmRpbmFsU2NhbGUoWCkpIHtcbiAgICAgIC8vIGZvciBvcmRpbmFsLCBoYXNDb2wgb3Igbm90IGRvZXNuJ3QgbWF0dGVyIC0tIHdlIHNjYWxlIGJhc2VkIG9uIGNhcmRpbmFsaXR5XG4gICAgICBjZWxsV2lkdGggPSAoeENhcmRpbmFsaXR5ICsgZW5jb2RpbmcuYmFuZChYKS5wYWRkaW5nKSAqIGVuY29kaW5nLmJhbmRTaXplKFgsIHVzZVNtYWxsQmFuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbGxXaWR0aCA9IGhhc0NvbCB8fCBoYXNSb3cgPyBlbmNvZGluZy5lbmMoQ09MKS53aWR0aCA6ICBlbmNvZGluZy5jb25maWcoXCJzaW5nbGVXaWR0aFwiKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKG1hcmt0eXBlID09PSBURVhUKSB7XG4gICAgICBjZWxsV2lkdGggPSBlbmNvZGluZy5jb25maWcoJ3RleHRDZWxsV2lkdGgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VsbFdpZHRoID0gZW5jb2RpbmcuYmFuZFNpemUoWCk7XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IGNlbGxIZWlnaHRcbiAgaWYgKGhhc1kpIHtcbiAgICBpZiAoZW5jb2RpbmcuaXNPcmRpbmFsU2NhbGUoWSkpIHtcbiAgICAgIC8vIGZvciBvcmRpbmFsLCBoYXNDb2wgb3Igbm90IGRvZXNuJ3QgbWF0dGVyIC0tIHdlIHNjYWxlIGJhc2VkIG9uIGNhcmRpbmFsaXR5XG4gICAgICBjZWxsSGVpZ2h0ID0gKHlDYXJkaW5hbGl0eSArIGVuY29kaW5nLmJhbmQoWSkucGFkZGluZykgKiBlbmNvZGluZy5iYW5kU2l6ZShZLCB1c2VTbWFsbEJhbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZWxsSGVpZ2h0ID0gaGFzQ29sIHx8IGhhc1JvdyA/IGVuY29kaW5nLmVuYyhST1cpLmhlaWdodCA6ICBlbmNvZGluZy5jb25maWcoXCJzaW5nbGVIZWlnaHRcIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNlbGxIZWlnaHQgPSBlbmNvZGluZy5iYW5kU2l6ZShZKTtcbiAgfVxuXG4gIC8vIENlbGwgYmFuZHMgdXNlIHJhbmdlQmFuZHMoKS4gVGhlcmUgYXJlIG4tMSBwYWRkaW5nLiAgT3V0ZXJwYWRkaW5nID0gMCBmb3IgY2VsbHNcblxuICB2YXIgd2lkdGggPSBjZWxsV2lkdGgsIGhlaWdodCA9IGNlbGxIZWlnaHQ7XG4gIGlmIChoYXNDb2wpIHtcbiAgICB2YXIgY29sQ2FyZGluYWxpdHkgPSBlbmNvZGluZy5jYXJkaW5hbGl0eShDT0wsIHN0YXRzKTtcbiAgICB3aWR0aCA9IGNlbGxXaWR0aCAqICgoMSArIGNlbGxQYWRkaW5nKSAqIChjb2xDYXJkaW5hbGl0eSAtIDEpICsgMSk7XG4gIH1cbiAgaWYgKGhhc1Jvdykge1xuICAgIHZhciByb3dDYXJkaW5hbGl0eSA9ICBlbmNvZGluZy5jYXJkaW5hbGl0eShST1csIHN0YXRzKTtcbiAgICBoZWlnaHQgPSBjZWxsSGVpZ2h0ICogKCgxICsgY2VsbFBhZGRpbmcpICogKHJvd0NhcmRpbmFsaXR5IC0gMSkgKyAxKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgd2hvbGUgY2VsbFxuICAgIGNlbGxXaWR0aDogY2VsbFdpZHRoLFxuICAgIGNlbGxIZWlnaHQ6IGNlbGxIZWlnaHQsXG4gICAgY2VsbFBhZGRpbmc6IGNlbGxQYWRkaW5nLFxuICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGNoYXJ0XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIC8vIGluZm9ybWF0aW9uIGFib3V0IHggYW5kIHksIHN1Y2ggYXMgYmFuZCBzaXplXG4gICAgeDoge3VzZVNtYWxsQmFuZDogdXNlU21hbGxCYW5kfSxcbiAgICB5OiB7dXNlU21hbGxCYW5kOiB1c2VTbWFsbEJhbmR9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldE1heExlbmd0aChlbmNvZGluZywgc3RhdHMsIGV0KSB7XG4gIC8vIEZJWE1FIGRldGVybWluZSBjb25zdGFudCBmb3IgUSBhbmQgVCBpbiBhIG5pY2VyIHdheVxuICByZXR1cm4gZW5jb2RpbmcuaXNUeXBlKGV0LCBRKSA/IDIwIDpcbiAgICBlbmNvZGluZy5pc1R5cGUoZXQsIFQpID8gMjAgOlxuICAgIHN0YXRzW2VuY29kaW5nLmZpZWxkTmFtZShldCldLm1heDtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0KGVuY29kaW5nLCBzdGF0cywgbGF5b3V0KSB7XG4gIFtYLCBZXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgdmFyIG1heExlbmd0aDtcbiAgICBpZiAoZW5jb2RpbmcuaXNEaW1lbnNpb24oeCkgfHwgZW5jb2RpbmcuaXNUeXBlKHgsIFQpKSB7XG4gICAgICBtYXhMZW5ndGggPSAgZ2V0TWF4TGVuZ3RoKGVuY29kaW5nLCBzdGF0cywgeCk7XG4gICAgfSBlbHNlIGlmIChlbmNvZGluZy5hZ2dyKHgpID09PSAnY291bnQnKSB7XG4gICAgICAvL2Fzc2lnbiBkZWZhdWx0IHZhbHVlIGZvciBjb3VudCBhcyBpdCB3b24ndCBoYXZlIHN0YXRzXG4gICAgICBtYXhMZW5ndGggPSAgMztcbiAgICB9IGVsc2UgaWYgKGVuY29kaW5nLmlzVHlwZSh4LCBRKSkge1xuICAgICAgaWYgKHg9PT1YKSB7XG4gICAgICAgIG1heExlbmd0aCA9IDM7XG4gICAgICB9IGVsc2UgeyAvLyBZXG4gICAgICAgIC8vYXNzdW1lIHRoYXQgZGVmYXVsdCBmb3JtYXRpbmcgaXMgYWx3YXlzIHNob3J0ZXIgdGhhbiA3XG4gICAgICAgIG1heExlbmd0aCA9IE1hdGgubWluKGdldE1heExlbmd0aChlbmNvZGluZywgc3RhdHMsIHgpLCA3KTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0dGVyKGxheW91dCxbeCwgJ2F4aXNUaXRsZU9mZnNldCddLCBlbmNvZGluZy5jb25maWcoJ2NoYXJhY3RlcldpZHRoJykgKiAgbWF4TGVuZ3RoICsgMjApO1xuICB9KTtcbiAgcmV0dXJuIGxheW91dDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgdGltZSA9IHJlcXVpcmUoJy4vdGltZScpO1xuXG52YXIgbGVnZW5kID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxubGVnZW5kLmRlZnMgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB2YXIgZGVmcyA9IFtdO1xuICAvLyBUT0RPOiBzdXBwb3J0IGFscGhhXG5cbiAgaWYgKGVuY29kaW5nLmhhcyhDT0xPUikgJiYgZW5jb2RpbmcubGVnZW5kKENPTE9SKSkge1xuICAgIGRlZnMucHVzaChsZWdlbmQuZGVmKENPTE9SLCBlbmNvZGluZywge1xuICAgICAgZmlsbDogQ09MT1IsXG4gICAgICBvcmllbnQ6ICdyaWdodCdcbiAgICB9KSk7XG4gIH1cblxuICBpZiAoZW5jb2RpbmcuaGFzKFNJWkUpICYmIGVuY29kaW5nLmxlZ2VuZChTSVpFKSkge1xuICAgIGRlZnMucHVzaChsZWdlbmQuZGVmKFNJWkUsIGVuY29kaW5nLCB7XG4gICAgICBzaXplOiBTSVpFLFxuICAgICAgb3JpZW50OiBkZWZzLmxlbmd0aCA9PT0gMSA/ICdsZWZ0JyA6ICdyaWdodCdcbiAgICB9KSk7XG4gIH1cblxuICBpZiAoZW5jb2RpbmcuaGFzKFNIQVBFKSAmJiBlbmNvZGluZy5sZWdlbmQoU0hBUEUpKSB7XG4gICAgaWYgKGRlZnMubGVuZ3RoID09PSAyKSB7XG4gICAgICAvLyBUT0RPOiBmaXggdGhpc1xuICAgICAgY29uc29sZS5lcnJvcignVmVnYS1saXRlIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIHR3byBsZWdlbmRzJyk7XG4gICAgICByZXR1cm4gZGVmcztcbiAgICB9XG4gICAgZGVmcy5wdXNoKGxlZ2VuZC5kZWYoU0hBUEUsIGVuY29kaW5nLCB7XG4gICAgICBzaGFwZTogU0hBUEUsXG4gICAgICBvcmllbnQ6IGRlZnMubGVuZ3RoID09PSAxID8gJ2xlZnQnIDogJ3JpZ2h0J1xuICAgIH0pKTtcbiAgfVxuXG4gIHJldHVybiBkZWZzO1xufTtcblxubGVnZW5kLmRlZiA9IGZ1bmN0aW9uKG5hbWUsIGVuY29kaW5nLCBwcm9wcykge1xuICB2YXIgZGVmID0gcHJvcHMsIGZuO1xuXG4gIGRlZi50aXRsZSA9IGVuY29kaW5nLmZpZWxkVGl0bGUobmFtZSk7XG5cbiAgaWYgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBUKSAmJiAoZm4gPSBlbmNvZGluZy5mbihuYW1lKSkgJiZcbiAgICB0aW1lLmhhc1NjYWxlKGZuKSkge1xuICAgIHZhciBwcm9wZXJ0aWVzID0gZGVmLnByb3BlcnRpZXMgPSBkZWYucHJvcGVydGllcyB8fCB7fSxcbiAgICAgIGxhYmVscyA9IHByb3BlcnRpZXMubGFiZWxzID0gcHJvcGVydGllcy5sYWJlbHMgfHwge30sXG4gICAgICB0ZXh0ID0gbGFiZWxzLnRleHQgPSBsYWJlbHMudGV4dCB8fCB7fTtcblxuICAgIHRleHQuc2NhbGUgPSAndGltZS0nKyBmbjtcbiAgfVxuXG4gIHJldHVybiBkZWY7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciBtYXJrcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbm1hcmtzLmRlZiA9IGZ1bmN0aW9uKG1hcmssIGVuY29kaW5nLCBsYXlvdXQsIHN0eWxlKSB7XG4gIHZhciBkZWZzID0gW107XG5cbiAgLy8gdG8gYWRkIGEgYmFja2dyb3VuZCB0byB0ZXh0LCB3ZSBuZWVkIHRvIGFkZCBpdCBiZWZvcmUgdGhlIHRleHRcbiAgaWYgKGVuY29kaW5nLm1hcmt0eXBlKCkgPT09IFRFWFQgJiYgZW5jb2RpbmcuaGFzKENPTE9SKSkge1xuICAgIHZhciBiZyA9IHtcbiAgICAgIHg6IHt2YWx1ZTogMH0sXG4gICAgICB5OiB7dmFsdWU6IDB9LFxuICAgICAgeDI6IHt2YWx1ZTogbGF5b3V0LmNlbGxXaWR0aH0sXG4gICAgICB5Mjoge3ZhbHVlOiBsYXlvdXQuY2VsbEhlaWdodH0sXG4gICAgICBmaWxsOiB7c2NhbGU6IENPTE9SLCBmaWVsZDogZW5jb2RpbmcuZmllbGQoQ09MT1IpfVxuICAgIH07XG4gICAgZGVmcy5wdXNoKHtcbiAgICAgIHR5cGU6ICdyZWN0JyxcbiAgICAgIGZyb206IHtkYXRhOiBUQUJMRX0sXG4gICAgICBwcm9wZXJ0aWVzOiB7ZW50ZXI6IGJnLCB1cGRhdGU6IGJnfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gYWRkIHRoZSBtYXJrIGRlZiBmb3IgdGhlIG1haW4gdGhpbmdcbiAgdmFyIHAgPSBtYXJrLnByb3AoZW5jb2RpbmcsIGxheW91dCwgc3R5bGUpO1xuICBkZWZzLnB1c2goe1xuICAgIHR5cGU6IG1hcmsudHlwZSxcbiAgICBmcm9tOiB7ZGF0YTogVEFCTEV9LFxuICAgIHByb3BlcnRpZXM6IHtlbnRlcjogcCwgdXBkYXRlOiBwfVxuICB9KTtcblxuICByZXR1cm4gZGVmcztcbn07XG5cbm1hcmtzLmJhciA9IHtcbiAgdHlwZTogJ3JlY3QnLFxuICBzdGFjazogdHJ1ZSxcbiAgcHJvcDogYmFyX3Byb3BzLFxuICByZXF1aXJlZEVuY29kaW5nOiBbJ3gnLCAneSddLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCB4OiAxLCB5OiAxLCBzaXplOiAxLCBjb2xvcjogMSwgYWxwaGE6IDF9XG59O1xuXG5tYXJrcy5saW5lID0ge1xuICB0eXBlOiAnbGluZScsXG4gIGxpbmU6IHRydWUsXG4gIHByb3A6IGxpbmVfcHJvcHMsXG4gIHJlcXVpcmVkRW5jb2Rpbmc6IFsneCcsICd5J10sXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OiAxLCBjb2w6IDEsIHg6IDEsIHk6IDEsIGNvbG9yOiAxLCBhbHBoYTogMSwgZGV0YWlsOjF9XG59O1xuXG5tYXJrcy5hcmVhID0ge1xuICB0eXBlOiAnYXJlYScsXG4gIHN0YWNrOiB0cnVlLFxuICBsaW5lOiB0cnVlLFxuICByZXF1aXJlZEVuY29kaW5nOiBbJ3gnLCAneSddLFxuICBwcm9wOiBhcmVhX3Byb3BzLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCB4OiAxLCB5OiAxLCBjb2xvcjogMSwgYWxwaGE6IDF9XG59O1xuXG5tYXJrcy50aWNrID0ge1xuICB0eXBlOiAncmVjdCcsXG4gIHByb3A6IHRpY2tfcHJvcHMsXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OiAxLCBjb2w6IDEsIHg6IDEsIHk6IDEsIGNvbG9yOiAxLCBhbHBoYTogMSwgZGV0YWlsOiAxfVxufTtcblxubWFya3MuY2lyY2xlID0ge1xuICB0eXBlOiAnc3ltYm9sJyxcbiAgcHJvcDogZmlsbGVkX3BvaW50X3Byb3BzKCdjaXJjbGUnKSxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgeDogMSwgeTogMSwgc2l6ZTogMSwgY29sb3I6IDEsIGFscGhhOiAxLCBkZXRhaWw6IDF9XG59O1xuXG5tYXJrcy5zcXVhcmUgPSB7XG4gIHR5cGU6ICdzeW1ib2wnLFxuICBwcm9wOiBmaWxsZWRfcG9pbnRfcHJvcHMoJ3NxdWFyZScpLFxuICBzdXBwb3J0ZWRFbmNvZGluZzogbWFya3MuY2lyY2xlLnN1cHBvcnRlZEVuY29kaW5nXG59O1xuXG5tYXJrcy5wb2ludCA9IHtcbiAgdHlwZTogJ3N5bWJvbCcsXG4gIHByb3A6IHBvaW50X3Byb3BzLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCB4OiAxLCB5OiAxLCBzaXplOiAxLCBjb2xvcjogMSwgYWxwaGE6IDEsIHNoYXBlOiAxLCBkZXRhaWw6IDF9XG59O1xuXG5tYXJrcy50ZXh0ID0ge1xuICB0eXBlOiAndGV4dCcsXG4gIHByb3A6IHRleHRfcHJvcHMsXG4gIHJlcXVpcmVkRW5jb2Rpbmc6IFsndGV4dCddLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCBzaXplOiAxLCBjb2xvcjogMSwgYWxwaGE6IDEsIHRleHQ6IDF9XG59O1xuXG5mdW5jdGlvbiBiYXJfcHJvcHMoZSwgbGF5b3V0LCBzdHlsZSkge1xuICAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG5cbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmlzTWVhc3VyZShYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICAgIGlmIChlLmlzRGltZW5zaW9uKFkpKSB7XG4gICAgICBwLngyID0ge3NjYWxlOiBYLCB2YWx1ZTogZS5zY2FsZShYKS50eXBlID09PSAnbG9nJyA/IDEgOiAwfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZS5oYXMoWCkpIHsgLy8gaXMgb3JkaW5hbFxuICAgIHAueGMgPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkKFgpfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUT0RPIGFkZCBzaW5nbGUgYmFyIG9mZnNldFxuICAgIHAueGMgPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5pc01lYXN1cmUoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgICBwLnkyID0ge3NjYWxlOiBZLCB2YWx1ZTogZS5zY2FsZShZKS50eXBlID09PSAnbG9nJyA/IDEgOiAwfTtcbiAgfSBlbHNlIGlmIChlLmhhcyhZKSkgeyAvLyBpcyBvcmRpbmFsXG4gICAgcC55YyA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICB9IGVsc2Uge1xuICAgIC8vIFRPRE8gYWRkIHNpbmdsZSBiYXIgb2Zmc2V0XG4gICAgcC55YyA9IHtncm91cDogJ2hlaWdodCd9O1xuICB9XG5cbiAgLy8gd2lkdGhcbiAgaWYgKCFlLmhhcyhYKSB8fCBlLmlzT3JkaW5hbFNjYWxlKFgpKSB7IC8vIG5vIFggb3IgWCBpcyBvcmRpbmFsXG4gICAgaWYgKGUuaGFzKFNJWkUpKSB7XG4gICAgICBwLndpZHRoID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZChTSVpFKX07XG4gICAgfSBlbHNlIHtcbiAgICAgIHAud2lkdGggPSB7XG4gICAgICAgIHZhbHVlOiBlLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCksXG4gICAgICAgIG9mZnNldDogLTFcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgeyAvLyBYIGlzIFF1YW50IG9yIFRpbWUgU2NhbGVcbiAgICBwLndpZHRoID0ge3ZhbHVlOiAyfTtcbiAgfVxuXG4gIC8vIGhlaWdodFxuICBpZiAoIWUuaGFzKFkpIHx8IGUuaXNPcmRpbmFsU2NhbGUoWSkpIHsgLy8gbm8gWSBvciBZIGlzIG9yZGluYWxcbiAgICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICAgIHAuaGVpZ2h0ID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZChTSVpFKX07XG4gICAgfSBlbHNlIHtcbiAgICAgIHAuaGVpZ2h0ID0ge1xuICAgICAgICB2YWx1ZTogZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpLFxuICAgICAgICBvZmZzZXQ6IC0xXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHsgLy8gWSBpcyBRdWFudCBvciBUaW1lIFNjYWxlXG4gICAgcC5oZWlnaHQgPSB7dmFsdWU6IDJ9O1xuICB9XG5cbiAgLy8gZmlsbFxuICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5maWxsID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGQoQ09MT1IpfTtcbiAgfSBlbHNlIHtcbiAgICBwLmZpbGwgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgfVxuXG4gIC8vIGFscGhhXG4gIGlmIChlLmhhcyhBTFBIQSkpIHtcbiAgICBwLm9wYWNpdHkgPSB7c2NhbGU6IEFMUEhBLCBmaWVsZDogZS5maWVsZChBTFBIQSl9O1xuICB9IGVsc2UgaWYgKGUudmFsdWUoQUxQSEEpICE9PSB1bmRlZmluZWQpIHtcbiAgICBwLm9wYWNpdHkgPSB7dmFsdWU6IGUudmFsdWUoQUxQSEEpfTtcbiAgfVxuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBwb2ludF9wcm9wcyhlLCBsYXlvdXQsIHN0eWxlKSB7XG4gIHZhciBwID0ge307XG5cbiAgLy8geFxuICBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkKFgpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7dmFsdWU6IGUuYmFuZFNpemUoWCwgbGF5b3V0LngudXNlU21hbGxCYW5kKSAvIDJ9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7dmFsdWU6IGUuYmFuZFNpemUoWSwgbGF5b3V0LnkudXNlU21hbGxCYW5kKSAvIDJ9O1xuICB9XG5cbiAgLy8gc2l6ZVxuICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICBwLnNpemUgPSB7c2NhbGU6IFNJWkUsIGZpZWxkOiBlLmZpZWxkKFNJWkUpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoU0laRSkpIHtcbiAgICBwLnNpemUgPSB7dmFsdWU6IGUudmFsdWUoU0laRSl9O1xuICB9XG5cbiAgLy8gc2hhcGVcbiAgaWYgKGUuaGFzKFNIQVBFKSkge1xuICAgIHAuc2hhcGUgPSB7c2NhbGU6IFNIQVBFLCBmaWVsZDogZS5maWVsZChTSEFQRSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhTSEFQRSkpIHtcbiAgICBwLnNoYXBlID0ge3ZhbHVlOiBlLnZhbHVlKFNIQVBFKX07XG4gIH1cblxuICAvLyBzdHJva2VcbiAgaWYgKGUuaGFzKENPTE9SKSkge1xuICAgIHAuc3Ryb2tlID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGQoQ09MT1IpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5zdHJva2UgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgfVxuXG4gIC8vIGFscGhhXG4gIGlmIChlLmhhcyhBTFBIQSkpIHtcbiAgICBwLm9wYWNpdHkgPSB7c2NhbGU6IEFMUEhBLCBmaWVsZDogZS5maWVsZChBTFBIQSl9O1xuICB9IGVsc2UgaWYgKGUudmFsdWUoQUxQSEEpICE9PSB1bmRlZmluZWQpIHtcbiAgICBwLm9wYWNpdHkgPSB7dmFsdWU6IGUudmFsdWUoQUxQSEEpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5vcGFjaXR5ID0ge3ZhbHVlOiBzdHlsZS5vcGFjaXR5fTtcbiAgfVxuXG4gIHAuc3Ryb2tlV2lkdGggPSB7dmFsdWU6IGUuY29uZmlnKCdzdHJva2VXaWR0aCcpfTtcblxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gbGluZV9wcm9wcyhlLGxheW91dCwgc3R5bGUpIHtcbiAgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuICB2YXIgcCA9IHt9O1xuXG4gIC8vIHhcbiAgaWYgKGUuaGFzKFgpKSB7XG4gICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZChYKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFgpKSB7XG4gICAgcC54ID0ge3ZhbHVlOiAwfTtcbiAgfVxuXG4gIC8vIHlcbiAgaWYgKGUuaGFzKFkpKSB7XG4gICAgcC55ID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZChZKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFkpKSB7XG4gICAgcC55ID0ge2dyb3VwOiAnaGVpZ2h0J307XG4gIH1cblxuICAvLyBzdHJva2VcbiAgaWYgKGUuaGFzKENPTE9SKSkge1xuICAgIHAuc3Ryb2tlID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGQoQ09MT1IpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5zdHJva2UgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgfVxuXG4gIC8vIGFscGhhXG4gIGlmIChlLmhhcyhBTFBIQSkpIHtcbiAgICBwLm9wYWNpdHkgPSB7c2NhbGU6IEFMUEhBLCBmaWVsZDogZS5maWVsZChBTFBIQSl9O1xuICB9IGVsc2UgaWYgKGUudmFsdWUoQUxQSEEpICE9PSB1bmRlZmluZWQpIHtcbiAgICBwLm9wYWNpdHkgPSB7dmFsdWU6IGUudmFsdWUoQUxQSEEpfTtcbiAgfVxuXG4gIHAuc3Ryb2tlV2lkdGggPSB7dmFsdWU6IGUuY29uZmlnKCdzdHJva2VXaWR0aCcpfTtcblxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gYXJlYV9wcm9wcyhlLCBsYXlvdXQsIHN0eWxlKSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmlzTWVhc3VyZShYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICAgIGlmIChlLmlzRGltZW5zaW9uKFkpKSB7XG4gICAgICBwLngyID0ge3NjYWxlOiBYLCB2YWx1ZTogMH07XG4gICAgICBwLm9yaWVudCA9IHt2YWx1ZTogJ2hvcml6b250YWwnfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkKFgpfTtcbiAgfSBlbHNlIHtcbiAgICBwLnggPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5pc01lYXN1cmUoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgICBwLnkyID0ge3NjYWxlOiBZLCB2YWx1ZTogMH07XG4gIH0gZWxzZSBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgfSBlbHNlIHtcbiAgICBwLnkgPSB7Z3JvdXA6ICdoZWlnaHQnfTtcbiAgfVxuXG4gIC8vIHN0cm9rZVxuICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5maWxsID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGQoQ09MT1IpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5maWxsID0ge3ZhbHVlOiBlLnZhbHVlKENPTE9SKX07XG4gIH1cblxuICAvLyBhbHBoYVxuICBpZiAoZS5oYXMoQUxQSEEpKSB7XG4gICAgcC5vcGFjaXR5ID0ge3NjYWxlOiBBTFBIQSwgZmllbGQ6IGUuZmllbGQoQUxQSEEpfTtcbiAgfSBlbHNlIGlmIChlLnZhbHVlKEFMUEhBKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcC5vcGFjaXR5ID0ge3ZhbHVlOiBlLnZhbHVlKEFMUEhBKX07XG4gIH1cblxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gdGlja19wcm9wcyhlLCBsYXlvdXQsIHN0eWxlKSB7XG4gIHZhciBwID0ge307XG5cbiAgLy8geFxuICBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkKFgpfTtcbiAgICBpZiAoZS5pc0RpbWVuc2lvbihYKSkge1xuICAgICAgcC54Lm9mZnNldCA9IC1lLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCkgLyAzO1xuICAgIH1cbiAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgICBpZiAoZS5pc0RpbWVuc2lvbihZKSkge1xuICAgICAgcC55Lm9mZnNldCA9IC1lLmJhbmRTaXplKFksIGxheW91dC55LnVzZVNtYWxsQmFuZCkgLyAzO1xuICAgIH1cbiAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8gd2lkdGhcbiAgaWYgKCFlLmhhcyhYKSB8fCBlLmlzRGltZW5zaW9uKFgpKSB7XG4gICAgcC53aWR0aCA9IHt2YWx1ZTogZS5iYW5kU2l6ZShYLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMS41fTtcbiAgfSBlbHNlIHtcbiAgICBwLndpZHRoID0ge3ZhbHVlOiAxfTtcbiAgfVxuXG4gIC8vIGhlaWdodFxuICBpZiAoIWUuaGFzKFkpIHx8IGUuaXNEaW1lbnNpb24oWSkpIHtcbiAgICBwLmhlaWdodCA9IHt2YWx1ZTogZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMS41fTtcbiAgfSBlbHNlIHtcbiAgICBwLmhlaWdodCA9IHt2YWx1ZTogMX07XG4gIH1cblxuICAvLyBmaWxsXG4gIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZChDT0xPUil9O1xuICB9IGVsc2Uge1xuICAgIHAuZmlsbCA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICB9XG5cbiAgLy8gYWxwaGFcbiAgaWYgKGUuaGFzKEFMUEhBKSkge1xuICAgIHAub3BhY2l0eSA9IHtzY2FsZTogQUxQSEEsIGZpZWxkOiBlLmZpZWxkKEFMUEhBKX07XG4gIH0gZWxzZSBpZiAoZS52YWx1ZShBTFBIQSkgIT09IHVuZGVmaW5lZCkge1xuICAgIHAub3BhY2l0eSA9IHt2YWx1ZTogZS52YWx1ZShBTFBIQSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICBwLm9wYWNpdHkgPSB7dmFsdWU6IHN0eWxlLm9wYWNpdHl9O1xuICB9XG5cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIGZpbGxlZF9wb2ludF9wcm9wcyhzaGFwZSkge1xuICByZXR1cm4gZnVuY3Rpb24oZSwgbGF5b3V0LCBzdHlsZSkge1xuICAgIHZhciBwID0ge307XG5cbiAgICAvLyB4XG4gICAgaWYgKGUuaGFzKFgpKSB7XG4gICAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkKFgpfTtcbiAgICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgICAgcC54ID0ge3ZhbHVlOiBlLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCkgLyAyfTtcbiAgICB9XG5cbiAgICAvLyB5XG4gICAgaWYgKGUuaGFzKFkpKSB7XG4gICAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgICB9IGVsc2UgaWYgKCFlLmhhcyhZKSkge1xuICAgICAgcC55ID0ge3ZhbHVlOiBlLmJhbmRTaXplKFksIGxheW91dC55LnVzZVNtYWxsQmFuZCkgLyAyfTtcbiAgICB9XG5cbiAgICAvLyBzaXplXG4gICAgaWYgKGUuaGFzKFNJWkUpKSB7XG4gICAgICBwLnNpemUgPSB7c2NhbGU6IFNJWkUsIGZpZWxkOiBlLmZpZWxkKFNJWkUpfTtcbiAgICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgICAgcC5zaXplID0ge3ZhbHVlOiBlLnZhbHVlKFNJWkUpfTtcbiAgICB9XG5cbiAgICAvLyBzaGFwZVxuICAgIHAuc2hhcGUgPSB7dmFsdWU6IHNoYXBlfTtcblxuICAgIC8vIGZpbGxcbiAgICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgICBwLmZpbGwgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZChDT0xPUil9O1xuICAgIH0gZWxzZSBpZiAoIWUuaGFzKENPTE9SKSkge1xuICAgICAgcC5maWxsID0ge3ZhbHVlOiBlLnZhbHVlKENPTE9SKX07XG4gICAgfVxuXG4gICAgLy8gYWxwaGFcbiAgICBpZiAoZS5oYXMoQUxQSEEpKSB7XG4gICAgICBwLm9wYWNpdHkgPSB7c2NhbGU6IEFMUEhBLCBmaWVsZDogZS5maWVsZChBTFBIQSl9O1xuICAgIH0gZWxzZSBpZiAoZS52YWx1ZShBTFBIQSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcC5vcGFjaXR5ID0ge3ZhbHVlOiBlLnZhbHVlKEFMUEhBKX07XG4gICAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgICBwLm9wYWNpdHkgPSB7dmFsdWU6IHN0eWxlLm9wYWNpdHl9O1xuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0X3Byb3BzKGUsIGxheW91dCwgc3R5bGUpIHtcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmhhcyhYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgIGlmIChlLmhhcyhURVhUKSAmJiBlLmlzVHlwZShURVhULCBRKSkge1xuICAgICAgcC54ID0ge3ZhbHVlOiBsYXlvdXQuY2VsbFdpZHRoLTV9O1xuICAgIH0gZWxzZSB7XG4gICAgICBwLnggPSB7dmFsdWU6IGUuYmFuZFNpemUoWCwgbGF5b3V0LngudXNlU21hbGxCYW5kKSAvIDJ9O1xuICAgIH1cbiAgfVxuXG4gIC8vIHlcbiAgaWYgKGUuaGFzKFkpKSB7XG4gICAgcC55ID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZChZKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFkpKSB7XG4gICAgcC55ID0ge3ZhbHVlOiBlLmJhbmRTaXplKFksIGxheW91dC55LnVzZVNtYWxsQmFuZCkgLyAyfTtcbiAgfVxuXG4gIC8vIHNpemVcbiAgaWYgKGUuaGFzKFNJWkUpKSB7XG4gICAgcC5mb250U2l6ZSA9IHtzY2FsZTogU0laRSwgZmllbGQ6IGUuZmllbGQoU0laRSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhTSVpFKSkge1xuICAgIHAuZm9udFNpemUgPSB7dmFsdWU6IGUuZm9udCgnc2l6ZScpfTtcbiAgfVxuXG4gIC8vIGZpbGxcbiAgLy8gY29sb3Igc2hvdWxkIGJlIHNldCB0byBiYWNrZ3JvdW5kXG4gIHAuZmlsbCA9IHt2YWx1ZTogJ2JsYWNrJ307XG5cbiAgLy8gYWxwaGFcbiAgaWYgKGUuaGFzKEFMUEhBKSkge1xuICAgIHAub3BhY2l0eSA9IHtzY2FsZTogQUxQSEEsIGZpZWxkOiBlLmZpZWxkKEFMUEhBKX07XG4gIH0gZWxzZSBpZiAoZS52YWx1ZShBTFBIQSkgIT09IHVuZGVmaW5lZCkge1xuICAgIHAub3BhY2l0eSA9IHt2YWx1ZTogZS52YWx1ZShBTFBIQSl9O1xuICB9IGVsc2Uge1xuICAgIHAub3BhY2l0eSA9IHt2YWx1ZTogc3R5bGUub3BhY2l0eX07XG4gIH1cblxuICAvLyB0ZXh0XG4gIGlmIChlLmhhcyhURVhUKSkge1xuICAgIGlmIChlLmlzVHlwZShURVhULCBRKSkge1xuICAgICAgcC50ZXh0ID0ge3RlbXBsYXRlOiBcInt7XCIgKyBlLmZpZWxkKFRFWFQpICsgXCIgfCBudW1iZXI6Jy4zcyd9fVwifTtcbiAgICAgIHAuYWxpZ24gPSB7dmFsdWU6ICdyaWdodCd9O1xuICAgIH0gZWxzZSB7XG4gICAgICBwLnRleHQgPSB7ZmllbGQ6IGUuZmllbGQoVEVYVCl9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwLnRleHQgPSB7dmFsdWU6ICdBYmMnfTtcbiAgfVxuXG4gIHAuZm9udCA9IHt2YWx1ZTogZS5mb250KCdmYW1pbHknKX07XG4gIHAuZm9udFdlaWdodCA9IHt2YWx1ZTogZS5mb250KCd3ZWlnaHQnKX07XG4gIHAuZm9udFN0eWxlID0ge3ZhbHVlOiBlLmZvbnQoJ3N0eWxlJyl9O1xuICBwLmJhc2VsaW5lID0ge3ZhbHVlOiBlLnRleHQoJ2Jhc2VsaW5lJyl9O1xuXG4gIHJldHVybiBwO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIHRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKTtcblxudmFyIHNjYWxlID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuc2NhbGUubmFtZXMgPSBmdW5jdGlvbihwcm9wcykge1xuICByZXR1cm4gdXRpbC5rZXlzKHV0aWwua2V5cyhwcm9wcykucmVkdWNlKGZ1bmN0aW9uKGEsIHgpIHtcbiAgICBpZiAocHJvcHNbeF0gJiYgcHJvcHNbeF0uc2NhbGUpIGFbcHJvcHNbeF0uc2NhbGVdID0gMTtcbiAgICByZXR1cm4gYTtcbiAgfSwge30pKTtcbn07XG5cbnNjYWxlLmRlZnMgPSBmdW5jdGlvbihuYW1lcywgZW5jb2RpbmcsIGxheW91dCwgc3R5bGUsIHNvcnRpbmcsIG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG5cbiAgcmV0dXJuIG5hbWVzLnJlZHVjZShmdW5jdGlvbihhLCBuYW1lKSB7XG4gICAgdmFyIHMgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdHlwZTogc2NhbGUudHlwZShuYW1lLCBlbmNvZGluZyksXG4gICAgICBkb21haW46IHNjYWxlX2RvbWFpbihuYW1lLCBlbmNvZGluZywgc29ydGluZywgb3B0KVxuICAgIH07XG4gICAgaWYgKHMudHlwZSA9PT0gJ29yZGluYWwnICYmICFlbmNvZGluZy5iaW4obmFtZSkgJiYgZW5jb2Rpbmcuc29ydChuYW1lKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHMuc29ydCA9IHRydWU7XG4gICAgfVxuXG4gICAgc2NhbGVfcmFuZ2UocywgZW5jb2RpbmcsIGxheW91dCwgc3R5bGUsIG9wdCk7XG5cbiAgICByZXR1cm4gKGEucHVzaChzKSwgYSk7XG4gIH0sIFtdKTtcbn07XG5cbnNjYWxlLnR5cGUgPSBmdW5jdGlvbihuYW1lLCBlbmNvZGluZykge1xuXG4gIHN3aXRjaCAoZW5jb2RpbmcudHlwZShuYW1lKSkge1xuICAgIGNhc2UgTzogcmV0dXJuICdvcmRpbmFsJztcbiAgICBjYXNlIFQ6XG4gICAgICB2YXIgZm4gPSBlbmNvZGluZy5mbihuYW1lKTtcbiAgICAgIHJldHVybiAoZm4gJiYgdGltZS5zY2FsZS50eXBlKGZuLCBuYW1lKSkgfHwgJ3RpbWUnO1xuICAgIGNhc2UgUTpcbiAgICAgIGlmIChlbmNvZGluZy5iaW4obmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUgPT09IENPTE9SID8gJ2xpbmVhcicgOiAnb3JkaW5hbCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5jb2Rpbmcuc2NhbGUobmFtZSkudHlwZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gc2NhbGVfZG9tYWluKG5hbWUsIGVuY29kaW5nLCBzb3J0aW5nLCBvcHQpIHtcbiAgaWYgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBUKSkge1xuICAgIHZhciByYW5nZSA9IHRpbWUuc2NhbGUuZG9tYWluKGVuY29kaW5nLmZuKG5hbWUpLCBuYW1lKTtcbiAgICBpZihyYW5nZSkgcmV0dXJuIHJhbmdlO1xuICB9XG5cbiAgaWYgKGVuY29kaW5nLmJpbihuYW1lKSkge1xuICAgIC8vIFRPRE86IGFkZCBpbmNsdWRlRW1wdHlDb25maWcgaGVyZVxuICAgIGlmIChvcHQuc3RhdHMpIHtcbiAgICAgIHZhciBiaW5zID0gdXRpbC5nZXRiaW5zKG9wdC5zdGF0c1tlbmNvZGluZy5maWVsZE5hbWUobmFtZSldLCBlbmNvZGluZy5iaW4obmFtZSkubWF4Ymlucyk7XG4gICAgICB2YXIgZG9tYWluID0gdXRpbC5yYW5nZShiaW5zLnN0YXJ0LCBiaW5zLnN0b3AsIGJpbnMuc3RlcCk7XG4gICAgICByZXR1cm4gbmFtZSA9PT0gWSA/IGRvbWFpbi5yZXZlcnNlKCkgOiBkb21haW47XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgPT0gb3B0LnN0YWNrID9cbiAgICB7XG4gICAgICBkYXRhOiBTVEFDS0VELFxuICAgICAgZmllbGQ6ICdkYXRhLicgKyAob3B0LmZhY2V0ID8gJ21heF8nIDogJycpICsgJ3N1bV8nICsgZW5jb2RpbmcuZmllbGQobmFtZSwgdHJ1ZSlcbiAgICB9IDpcbiAgICB7ZGF0YTogc29ydGluZy5nZXREYXRhc2V0KG5hbWUpLCBmaWVsZDogZW5jb2RpbmcuZmllbGQobmFtZSl9O1xufVxuXG5mdW5jdGlvbiBzY2FsZV9yYW5nZShzLCBlbmNvZGluZywgbGF5b3V0LCBzdHlsZSwgb3B0KSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIHNwZWMgPSBlbmNvZGluZy5zY2FsZShzLm5hbWUpO1xuICBzd2l0Y2ggKHMubmFtZSkge1xuICAgIGNhc2UgWDpcbiAgICAgIGlmIChzLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICBzLmJhbmRXaWR0aCA9IGVuY29kaW5nLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzLnJhbmdlID0gbGF5b3V0LmNlbGxXaWR0aCA/IFswLCBsYXlvdXQuY2VsbFdpZHRoXSA6ICd3aWR0aCc7XG5cbiAgICAgICAgaWYgKGVuY29kaW5nLmlzVHlwZShzLm5hbWUsVCkgJiYgZW5jb2RpbmcuZm4ocy5uYW1lKSA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgcy56ZXJvID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcy56ZXJvID0gc3BlYy56ZXJvID09PSB1bmRlZmluZWQgPyB0cnVlIDogc3BlYy56ZXJvO1xuICAgICAgICB9XG5cbiAgICAgICAgcy5yZXZlcnNlID0gc3BlYy5yZXZlcnNlO1xuICAgICAgfVxuICAgICAgcy5yb3VuZCA9IHRydWU7XG4gICAgICBpZiAocy50eXBlID09PSAndGltZScpIHtcbiAgICAgICAgcy5uaWNlID0gZW5jb2RpbmcuZm4ocy5uYW1lKTtcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgcy5uaWNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWTpcbiAgICAgIGlmIChzLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICBzLmJhbmRXaWR0aCA9IGVuY29kaW5nLmJhbmRTaXplKFksIGxheW91dC55LnVzZVNtYWxsQmFuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzLnJhbmdlID0gbGF5b3V0LmNlbGxIZWlnaHQgPyBbbGF5b3V0LmNlbGxIZWlnaHQsIDBdIDogJ2hlaWdodCc7XG5cbiAgICAgICAgaWYgKGVuY29kaW5nLmlzVHlwZShzLm5hbWUsVCkgJiYgZW5jb2RpbmcuZm4ocy5uYW1lKSA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgcy56ZXJvID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcy56ZXJvID0gc3BlYy56ZXJvID09PSB1bmRlZmluZWQgPyB0cnVlIDogc3BlYy56ZXJvO1xuICAgICAgICB9XG5cbiAgICAgICAgcy5yZXZlcnNlID0gc3BlYy5yZXZlcnNlO1xuICAgICAgfVxuXG4gICAgICBzLnJvdW5kID0gdHJ1ZTtcblxuICAgICAgaWYgKHMudHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgIHMubmljZSA9IGVuY29kaW5nLmZuKHMubmFtZSkgfHwgZW5jb2RpbmcuY29uZmlnKCd0aW1lU2NhbGVOaWNlJyk7XG4gICAgICB9ZWxzZSB7XG4gICAgICAgIHMubmljZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFJPVzogLy8gc3VwcG9ydCBvbmx5IG9yZGluYWxcbiAgICAgIHMuYmFuZFdpZHRoID0gbGF5b3V0LmNlbGxIZWlnaHQ7XG4gICAgICBzLnJvdW5kID0gdHJ1ZTtcbiAgICAgIHMubmljZSA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENPTDogLy8gc3VwcG9ydCBvbmx5IG9yZGluYWxcbiAgICAgIHMuYmFuZFdpZHRoID0gbGF5b3V0LmNlbGxXaWR0aDtcbiAgICAgIHMucm91bmQgPSB0cnVlO1xuICAgICAgcy5uaWNlID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0laRTpcbiAgICAgIGlmIChlbmNvZGluZy5pcygnYmFyJykpIHtcbiAgICAgICAgLy8gRklYTUUgdGhpcyBpcyBkZWZpbml0ZWx5IGluY29ycmVjdFxuICAgICAgICAvLyBidXQgbGV0J3MgZml4IGl0IGxhdGVyIHNpbmNlIGJhciBzaXplIGlzIGEgYmFkIGVuY29kaW5nIGFueXdheVxuICAgICAgICBzLnJhbmdlID0gWzMsIE1hdGgubWF4KGVuY29kaW5nLmJhbmRTaXplKFgpLCBlbmNvZGluZy5iYW5kU2l6ZShZKSldO1xuICAgICAgfSBlbHNlIGlmIChlbmNvZGluZy5pcyhURVhUKSkge1xuICAgICAgICBzLnJhbmdlID0gWzgsIDQwXTtcbiAgICAgIH0gZWxzZSB7IC8vcG9pbnRcbiAgICAgICAgdmFyIGJhbmRTaXplID0gTWF0aC5taW4oZW5jb2RpbmcuYmFuZFNpemUoWCksIGVuY29kaW5nLmJhbmRTaXplKFkpKSAtIDE7XG4gICAgICAgIHMucmFuZ2UgPSBbMTAsIDAuOCAqIGJhbmRTaXplKmJhbmRTaXplXTtcbiAgICAgIH1cbiAgICAgIHMucm91bmQgPSB0cnVlO1xuICAgICAgcy56ZXJvID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNIQVBFOlxuICAgICAgcy5yYW5nZSA9ICdzaGFwZXMnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDT0xPUjpcbiAgICAgIHZhciByYW5nZSA9IGVuY29kaW5nLnNjYWxlKENPTE9SKS5yYW5nZTtcbiAgICAgIGlmIChyYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChzLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgcmFuZ2UgPSBzdHlsZS5jb2xvclJhbmdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJhbmdlID0gWycjQTlEQjlGJywgJyMwRDVDMjEnXTtcbiAgICAgICAgICBzLnplcm8gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcy5yYW5nZSA9IHJhbmdlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBTFBIQTpcbiAgICAgIHMucmFuZ2UgPSBbMC4yLCAxLjBdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZyBuYW1lOiAnKyBzLm5hbWUpO1xuICB9XG5cbiAgc3dpdGNoIChzLm5hbWUpIHtcbiAgICBjYXNlIFJPVzpcbiAgICBjYXNlIENPTDpcbiAgICAgIHMucGFkZGluZyA9IGVuY29kaW5nLmNvbmZpZygnY2VsbFBhZGRpbmcnKTtcbiAgICAgIHMub3V0ZXJQYWRkaW5nID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWDpcbiAgICBjYXNlIFk6XG4gICAgICBpZiAocy50eXBlID09PSAnb3JkaW5hbCcpIHsgLy8mJiAhcy5iYW5kV2lkdGhcbiAgICAgICAgcy5wb2ludHMgPSB0cnVlO1xuICAgICAgICBzLnBhZGRpbmcgPSBlbmNvZGluZy5iYW5kKHMubmFtZSkucGFkZGluZztcbiAgICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYWRkU29ydFRyYW5zZm9ybXM7XG5cbi8vIGFkZHMgbmV3IHRyYW5zZm9ybXMgdGhhdCBwcm9kdWNlIHNvcnRlZCBmaWVsZHNcbmZ1bmN0aW9uIGFkZFNvcnRUcmFuc2Zvcm1zKHNwZWMsIGVuY29kaW5nLCBzdGF0cywgb3B0KSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcblxuICB2YXIgZGF0YXNldE1hcHBpbmcgPSB7fTtcbiAgdmFyIGNvdW50ZXIgPSAwO1xuXG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICB2YXIgc29ydEJ5ID0gZW5jb2Rpbmcuc29ydChlbmNUeXBlLCBzdGF0cyk7XG4gICAgaWYgKHNvcnRCeS5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgZmllbGRzID0gc29ydEJ5Lm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb3A6IGQuYWdncixcbiAgICAgICAgICBmaWVsZDogJ2RhdGEuJyArIGQubmFtZVxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBieUNsYXVzZSA9IHNvcnRCeS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICB2YXIgcmV2ZXJzZSA9IChkLnJldmVyc2UgPyAnLScgOiAnJyk7XG4gICAgICAgIHJldHVybiByZXZlcnNlICsgJ2RhdGEuJyArIChkLmFnZ3I9PT0nY291bnQnID8gJ2NvdW50JyA6IChkLmFnZ3IgKyAnXycgKyBkLm5hbWUpKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZGF0YU5hbWUgPSAnc29ydGVkJyArIGNvdW50ZXIrKztcblxuICAgICAgdmFyIHRyYW5zZm9ybXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgICAgICBncm91cGJ5OiBbJ2RhdGEuJyArIGZpZWxkLm5hbWVdLFxuICAgICAgICAgIGZpZWxkczogZmllbGRzXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAnc29ydCcsXG4gICAgICAgICAgYnk6IGJ5Q2xhdXNlXG4gICAgICAgIH1cbiAgICAgIF07XG5cbiAgICAgIHNwZWMuZGF0YS5wdXNoKHtcbiAgICAgICAgbmFtZTogZGF0YU5hbWUsXG4gICAgICAgIHNvdXJjZTogUkFXLFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybXNcbiAgICAgIH0pO1xuXG4gICAgICBkYXRhc2V0TWFwcGluZ1tlbmNUeXBlXSA9IGRhdGFOYW1lO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBzcGVjOiBzcGVjLFxuICAgIGdldERhdGFzZXQ6IGZ1bmN0aW9uKGVuY1R5cGUpIHtcbiAgICAgIHZhciBkYXRhID0gZGF0YXNldE1hcHBpbmdbZW5jVHlwZV07XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIFRBQkxFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyICBtYXJrcyA9IHJlcXVpcmUoJy4vbWFya3MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja2luZztcblxuZnVuY3Rpb24gc3RhY2tpbmcoc3BlYywgZW5jb2RpbmcsIG1kZWYsIGZhY2V0cykge1xuICBpZiAoIW1hcmtzW2VuY29kaW5nLm1hcmt0eXBlKCldLnN0YWNrKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gVE9ETzogYWRkIHx8IGVuY29kaW5nLmhhcyhMT0QpIGhlcmUgb25jZSBMT0QgaXMgaW1wbGVtZW50ZWRcbiAgaWYgKCFlbmNvZGluZy5oYXMoQ09MT1IpKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGRpbT1udWxsLCB2YWw9bnVsbCwgaWR4ID1udWxsLFxuICAgIGlzWE1lYXN1cmUgPSBlbmNvZGluZy5pc01lYXN1cmUoWCksXG4gICAgaXNZTWVhc3VyZSA9IGVuY29kaW5nLmlzTWVhc3VyZShZKTtcblxuICBpZiAoaXNYTWVhc3VyZSAmJiAhaXNZTWVhc3VyZSkge1xuICAgIGRpbSA9IFk7XG4gICAgdmFsID0gWDtcbiAgICBpZHggPSAwO1xuICB9IGVsc2UgaWYgKGlzWU1lYXN1cmUgJiYgIWlzWE1lYXN1cmUpIHtcbiAgICBkaW0gPSBYO1xuICAgIHZhbCA9IFk7XG4gICAgaWR4ID0gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDsgLy8gbm8gc3RhY2sgZW5jb2RpbmdcbiAgfVxuXG4gIC8vIGFkZCB0cmFuc2Zvcm0gdG8gY29tcHV0ZSBzdW1zIGZvciBzY2FsZVxuICB2YXIgc3RhY2tlZCA9IHtcbiAgICBuYW1lOiBTVEFDS0VELFxuICAgIHNvdXJjZTogVEFCTEUsXG4gICAgdHJhbnNmb3JtOiBbe1xuICAgICAgdHlwZTogJ2FnZ3JlZ2F0ZScsXG4gICAgICBncm91cGJ5OiBbZW5jb2RpbmcuZmllbGQoZGltKV0uY29uY2F0KGZhY2V0cyksIC8vIGRpbSBhbmQgb3RoZXIgZmFjZXRzXG4gICAgICBmaWVsZHM6IFt7b3A6ICdzdW0nLCBmaWVsZDogZW5jb2RpbmcuZmllbGQodmFsKX1dIC8vIFRPRE8gY2hlY2sgaWYgZmllbGQgd2l0aCBhZ2dyIGlzIGNvcnJlY3Q/XG4gICAgfV1cbiAgfTtcblxuICBpZiAoZmFjZXRzICYmIGZhY2V0cy5sZW5ndGggPiAwKSB7XG4gICAgc3RhY2tlZC50cmFuc2Zvcm0ucHVzaCh7IC8vY2FsY3VsYXRlIG1heCBmb3IgZWFjaCBmYWNldFxuICAgICAgdHlwZTogJ2FnZ3JlZ2F0ZScsXG4gICAgICBncm91cGJ5OiBmYWNldHMsXG4gICAgICBmaWVsZHM6IFt7b3A6ICdtYXgnLCBmaWVsZDogJ2RhdGEuc3VtXycgKyBlbmNvZGluZy5maWVsZCh2YWwsIHRydWUpfV1cbiAgICB9KTtcbiAgfVxuXG4gIHNwZWMuZGF0YS5wdXNoKHN0YWNrZWQpO1xuXG4gIC8vIGFkZCBzdGFjayB0cmFuc2Zvcm0gdG8gbWFya1xuICBtZGVmLmZyb20udHJhbnNmb3JtID0gW3tcbiAgICB0eXBlOiAnc3RhY2snLFxuICAgIHBvaW50OiBlbmNvZGluZy5maWVsZChkaW0pLFxuICAgIGhlaWdodDogZW5jb2RpbmcuZmllbGQodmFsKSxcbiAgICBvdXRwdXQ6IHt5MTogdmFsLCB5MDogdmFsICsgJzInfVxuICB9XTtcblxuICAvLyBUT0RPOiBUaGlzIGlzIHN1cGVyIGhhY2staXNoIC0tIGNvbnNvbGlkYXRlIGludG8gbW9kdWxhciBtYXJrIHByb3BlcnRpZXM/XG4gIG1kZWYucHJvcGVydGllcy51cGRhdGVbdmFsXSA9IG1kZWYucHJvcGVydGllcy5lbnRlclt2YWxdID0ge3NjYWxlOiB2YWwsIGZpZWxkOiB2YWx9O1xuICBtZGVmLnByb3BlcnRpZXMudXBkYXRlW3ZhbCArICcyJ10gPSBtZGVmLnByb3BlcnRpZXMuZW50ZXJbdmFsICsgJzInXSA9IHtzY2FsZTogdmFsLCBmaWVsZDogdmFsICsgJzInfTtcblxuICByZXR1cm4gdmFsOyAvL3JldHVybiBzdGFjayBlbmNvZGluZ1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciB2bGZpZWxkID0gcmVxdWlyZSgnLi4vZmllbGQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhdHMpIHtcbiAgcmV0dXJuIHtcbiAgICBvcGFjaXR5OiBlc3RpbWF0ZU9wYWNpdHkoZW5jb2RpbmcsIHN0YXRzKSxcbiAgICBjb2xvclJhbmdlOiBjb2xvclJhbmdlKGVuY29kaW5nLCBzdGF0cylcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGNvbG9yUmFuZ2UoZW5jb2RpbmcsIHN0YXRzKXtcbiAgaWYgKGVuY29kaW5nLmhhcyhDT0xPUikgJiYgZW5jb2RpbmcuaXNEaW1lbnNpb24oQ09MT1IpKSB7XG4gICAgdmFyIGNhcmRpbmFsaXR5ID0gZW5jb2RpbmcuY2FyZGluYWxpdHkoQ09MT1IsIHN0YXRzKTtcbiAgICBpZiAoY2FyZGluYWxpdHkgPD0gMTApIHtcbiAgICAgIHJldHVybiBcImNhdGVnb3J5MTBcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwiY2F0ZWdvcnkyMFwiO1xuICAgIH1cbiAgICAvLyBUT0RPIGNhbiB2ZWdhIGludGVycG9sYXRlIHJhbmdlIGZvciBvcmRpbmFsIHNjYWxlP1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBlc3RpbWF0ZU9wYWNpdHkoZW5jb2Rpbmcsc3RhdHMpIHtcbiAgaWYgKCFzdGF0cykge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIG51bVBvaW50cyA9IDA7XG5cbiAgaWYgKGVuY29kaW5nLmlzQWdncmVnYXRlKCkpIHsgLy8gYWdncmVnYXRlIHBsb3RcbiAgICBudW1Qb2ludHMgPSAxO1xuXG4gICAgLy8gIGdldCBudW1iZXIgb2YgcG9pbnRzIGluIGVhY2ggXCJjZWxsXCJcbiAgICAvLyAgYnkgY2FsY3VsYXRpbmcgcHJvZHVjdCBvZiBjYXJkaW5hbGl0eVxuICAgIC8vICBmb3IgZWFjaCBub24gZmFjZXRpbmcgYW5kIG5vbi1vcmRpbmFsIFggLyBZIGZpZWxkc1xuICAgIC8vICBub3RlIHRoYXQgb3JkaW5hbCB4LHkgYXJlIG5vdCBpbmNsdWRlIHNpbmNlIHdlIGNhblxuICAgIC8vICBjb25zaWRlciB0aGF0IG9yZGluYWwgeCBhcmUgc3ViZGl2aWRpbmcgdGhlIGNlbGwgaW50byBzdWJjZWxscyBhbnl3YXlcbiAgICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBlbmNUeXBlKSB7XG5cbiAgICAgIGlmIChlbmNUeXBlICE9PSBST1cgJiYgZW5jVHlwZSAhPT0gQ09MICYmXG4gICAgICAgICAgISgoZW5jVHlwZSA9PT0gWCB8fCBlbmNUeXBlID09PSBZKSAmJlxuICAgICAgICAgIHZsZmllbGQuaXNPcmRpbmFsU2NhbGUoZmllbGQsIHRydWUpKVxuICAgICAgICApIHtcbiAgICAgICAgbnVtUG9pbnRzICo9IGVuY29kaW5nLmNhcmRpbmFsaXR5KGVuY1R5cGUsIHN0YXRzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9IGVsc2UgeyAvLyByYXcgcGxvdFxuICAgIG51bVBvaW50cyA9IHN0YXRzLmNvdW50O1xuXG4gICAgLy8gc21hbGwgbXVsdGlwbGVzIGRpdmlkZSBudW1iZXIgb2YgcG9pbnRzXG4gICAgdmFyIG51bU11bHRpcGxlcyA9IDE7XG4gICAgaWYgKGVuY29kaW5nLmhhcyhST1cpKSB7XG4gICAgICBudW1NdWx0aXBsZXMgKj0gZW5jb2RpbmcuY2FyZGluYWxpdHkoUk9XLCBzdGF0cyk7XG4gICAgfVxuICAgIGlmIChlbmNvZGluZy5oYXMoQ09MKSkge1xuICAgICAgbnVtTXVsdGlwbGVzICo9IGVuY29kaW5nLmNhcmRpbmFsaXR5KENPTCwgc3RhdHMpO1xuICAgIH1cbiAgICBudW1Qb2ludHMgLz0gbnVtTXVsdGlwbGVzO1xuICB9XG5cbiAgdmFyIG9wYWNpdHkgPSAwO1xuICBpZiAobnVtUG9pbnRzIDwgMjApIHtcbiAgICBvcGFjaXR5ID0gMTtcbiAgfSBlbHNlIGlmIChudW1Qb2ludHMgPCAyMDApIHtcbiAgICBvcGFjaXR5ID0gMC43O1xuICB9IGVsc2UgaWYgKG51bVBvaW50cyA8IDEwMDAgfHwgZW5jb2RpbmcuaXMoJ3RpY2snKSkge1xuICAgIG9wYWNpdHkgPSAwLjY7XG4gIH0gZWxzZSB7XG4gICAgb3BhY2l0eSA9IDAuMztcbiAgfVxuXG4gIHJldHVybiBvcGFjaXR5O1xufVxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIGdyb3VwZGVmID0gcmVxdWlyZSgnLi9ncm91cCcpLmRlZjtcblxubW9kdWxlLmV4cG9ydHMgPSBzdWJmYWNldGluZztcblxuZnVuY3Rpb24gc3ViZmFjZXRpbmcoZ3JvdXAsIG1kZWYsIGRldGFpbHMsIHN0YWNrLCBlbmNvZGluZykge1xuICB2YXIgbSA9IGdyb3VwLm1hcmtzLFxuICAgIGcgPSBncm91cGRlZignc3ViZmFjZXQnLCB7bWFya3M6IG19KTtcblxuICBncm91cC5tYXJrcyA9IFtnXTtcbiAgZy5mcm9tID0gbWRlZi5mcm9tO1xuICBkZWxldGUgbWRlZi5mcm9tO1xuXG4gIC8vVE9ETyB0ZXN0IExPRCAtLSB3ZSBzaG91bGQgc3VwcG9ydCBzdGFjayAvIGxpbmUgd2l0aG91dCBjb2xvciAoTE9EKSBmaWVsZFxuICB2YXIgdHJhbnMgPSAoZy5mcm9tLnRyYW5zZm9ybSB8fCAoZy5mcm9tLnRyYW5zZm9ybSA9IFtdKSk7XG4gIHRyYW5zLnVuc2hpZnQoe3R5cGU6ICdmYWNldCcsIGtleXM6IGRldGFpbHN9KTtcblxuICBpZiAoc3RhY2sgJiYgZW5jb2RpbmcuaGFzKENPTE9SKSkge1xuICAgIHRyYW5zLnVuc2hpZnQoe3R5cGU6ICdzb3J0JywgYnk6IGVuY29kaW5nLmZpZWxkKENPTE9SKX0pO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIGdyb3VwZGVmID0gcmVxdWlyZSgnLi9ncm91cCcpLmRlZixcbiAgdmxmaWVsZCA9IHJlcXVpcmUoJy4uL2ZpZWxkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdGVtcGxhdGU7XG5cbmZ1bmN0aW9uIHRlbXBsYXRlKGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcblxuICB2YXIgZGF0YSA9IHtuYW1lOiBSQVcsIGZvcm1hdDoge319LFxuICAgIHRhYmxlID0ge25hbWU6IFRBQkxFLCBzb3VyY2U6IFJBV30sXG4gICAgZGF0YVVybCA9IGVuY29kaW5nLmRhdGEoJ3VybCcpLFxuICAgIGRhdGFUeXBlID0gZW5jb2RpbmcuZGF0YSgnZm9ybWF0VHlwZScpLFxuICAgIHZhbHVlcyA9IGVuY29kaW5nLmRhdGEoJ3ZhbHVlcycpO1xuXG4gIGlmIChlbmNvZGluZy5oYXNWYWx1ZXMoKSkge1xuICAgIGRhdGEudmFsdWVzID0gdmFsdWVzO1xuICB9IGVsc2Uge1xuICAgIGRhdGEudXJsID0gZGF0YVVybDtcbiAgICBkYXRhLmZvcm1hdC50eXBlID0gZGF0YVR5cGU7XG4gIH1cblxuICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBlbmNUeXBlKSB7XG4gICAgdmFyIG5hbWU7XG4gICAgaWYgKGZpZWxkLnR5cGUgPT0gVCkge1xuICAgICAgZGF0YS5mb3JtYXQucGFyc2UgPSBkYXRhLmZvcm1hdC5wYXJzZSB8fCB7fTtcbiAgICAgIGRhdGEuZm9ybWF0LnBhcnNlW2ZpZWxkLm5hbWVdID0gJ2RhdGUnO1xuICAgIH0gZWxzZSBpZiAoZmllbGQudHlwZSA9PSBRKSB7XG4gICAgICBkYXRhLmZvcm1hdC5wYXJzZSA9IGRhdGEuZm9ybWF0LnBhcnNlIHx8IHt9O1xuICAgICAgaWYgKHZsZmllbGQuaXNDb3VudChmaWVsZCkpIHtcbiAgICAgICAgbmFtZSA9ICdjb3VudCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lID0gZmllbGQubmFtZTtcbiAgICAgIH1cbiAgICAgIGRhdGEuZm9ybWF0LnBhcnNlW25hbWVdID0gJ251bWJlcic7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiBsYXlvdXQud2lkdGgsXG4gICAgaGVpZ2h0OiBsYXlvdXQuaGVpZ2h0LFxuICAgIHBhZGRpbmc6ICdhdXRvJyxcbiAgICBkYXRhOiBbZGF0YSwgdGFibGVdLFxuICAgIG1hcmtzOiBbZ3JvdXBkZWYoJ2NlbGwnLCB7XG4gICAgICB3aWR0aDogbGF5b3V0LmNlbGxXaWR0aCA/IHt2YWx1ZTogbGF5b3V0LmNlbGxXaWR0aH0gOiB1bmRlZmluZWQsXG4gICAgICBoZWlnaHQ6IGxheW91dC5jZWxsSGVpZ2h0ID8ge3ZhbHVlOiBsYXlvdXQuY2VsbEhlaWdodH0gOiB1bmRlZmluZWRcbiAgICB9KV1cbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdGltZTtcblxuZnVuY3Rpb24gdGltZShzcGVjLCBlbmNvZGluZywgb3B0KSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIHRpbWVGaWVsZHMgPSB7fSwgdGltZUZuID0ge307XG5cbiAgLy8gZmluZCB1bmlxdWUgZm9ybXVsYSB0cmFuc2Zvcm1hdGlvbiBhbmQgYmluIGZ1bmN0aW9uXG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICBpZiAoZmllbGQudHlwZSA9PT0gVCAmJiBmaWVsZC5mbikge1xuICAgICAgdGltZUZpZWxkc1tlbmNvZGluZy5maWVsZChlbmNUeXBlKV0gPSB7XG4gICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgZW5jVHlwZTogZW5jVHlwZVxuICAgICAgfTtcbiAgICAgIHRpbWVGbltmaWVsZC5mbl0gPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYWRkIGZvcm11bGEgdHJhbnNmb3JtXG4gIHZhciBkYXRhID0gc3BlYy5kYXRhWzFdLFxuICAgIHRyYW5zZm9ybSA9IGRhdGEudHJhbnNmb3JtID0gZGF0YS50cmFuc2Zvcm0gfHwgW107XG5cbiAgZm9yICh2YXIgZiBpbiB0aW1lRmllbGRzKSB7XG4gICAgdmFyIHRmID0gdGltZUZpZWxkc1tmXTtcbiAgICB0aW1lLnRyYW5zZm9ybSh0cmFuc2Zvcm0sIGVuY29kaW5nLCB0Zi5lbmNUeXBlLCB0Zi5maWVsZCk7XG4gIH1cblxuICAvLyBhZGQgc2NhbGVzXG4gIHZhciBzY2FsZXMgPSBzcGVjLnNjYWxlcyA9IHNwZWMuc2NhbGVzIHx8IFtdO1xuICBmb3IgKHZhciBmbiBpbiB0aW1lRm4pIHtcbiAgICB0aW1lLnNjYWxlKHNjYWxlcywgZm4sIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gc3BlYztcbn1cblxudGltZS5jYXJkaW5hbGl0eSA9IGZ1bmN0aW9uKGZpZWxkLCBzdGF0cywgZmlsdGVyTnVsbCwgdHlwZSkge1xuICB2YXIgZm4gPSBmaWVsZC5mbjtcbiAgc3dpdGNoIChmbikge1xuICAgIGNhc2UgJ3NlY29uZHMnOiByZXR1cm4gNjA7XG4gICAgY2FzZSAnbWludXRlcyc6IHJldHVybiA2MDtcbiAgICBjYXNlICdob3Vycyc6IHJldHVybiAyNDtcbiAgICBjYXNlICdkYXknOiByZXR1cm4gNztcbiAgICBjYXNlICdkYXRlJzogcmV0dXJuIDMxO1xuICAgIGNhc2UgJ21vbnRoJzogcmV0dXJuIDEyO1xuICAgIGNhc2UgJ3llYXInOlxuICAgICAgdmFyIHN0YXQgPSBzdGF0c1tmaWVsZC5uYW1lXSxcbiAgICAgICAgeWVhcnN0YXQgPSBzdGF0c1sneWVhcl8nK2ZpZWxkLm5hbWVdO1xuXG4gICAgICBpZiAoIXllYXJzdGF0KSB7IHJldHVybiBudWxsOyB9XG5cbiAgICAgIHJldHVybiB5ZWFyc3RhdC5kaXN0aW5jdCAtXG4gICAgICAgIChzdGF0Lm51bGxzID4gMCAmJiBmaWx0ZXJOdWxsW3R5cGVdID8gMSA6IDApO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5mdW5jdGlvbiBmaWVsZEZuKGZ1bmMsIGZpZWxkKSB7XG4gIHJldHVybiAndXRjJyArIGZ1bmMgKyAnKGQuZGF0YS4nKyBmaWVsZC5uYW1lICsnKSc7XG59XG5cbi8qKlxuICogQHJldHVybiB7U3RyaW5nfSBkYXRlIGJpbm5pbmcgZm9ybXVsYSBvZiB0aGUgZ2l2ZW4gZmllbGRcbiAqL1xudGltZS5mb3JtdWxhID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuIGZpZWxkRm4oZmllbGQuZm4sIGZpZWxkKTtcbn07XG5cbi8qKiBhZGQgZm9ybXVsYSB0cmFuc2Zvcm1zIHRvIGRhdGEgKi9cbnRpbWUudHJhbnNmb3JtID0gZnVuY3Rpb24odHJhbnNmb3JtLCBlbmNvZGluZywgZW5jVHlwZSwgZmllbGQpIHtcbiAgdHJhbnNmb3JtLnB1c2goe1xuICAgIHR5cGU6ICdmb3JtdWxhJyxcbiAgICBmaWVsZDogZW5jb2RpbmcuZmllbGQoZW5jVHlwZSksXG4gICAgZXhwcjogdGltZS5mb3JtdWxhKGZpZWxkKVxuICB9KTtcbn07XG5cbi8qKiBhcHBlbmQgY3VzdG9tIHRpbWUgc2NhbGVzIGZvciBheGlzIGxhYmVsICovXG50aW1lLnNjYWxlID0gZnVuY3Rpb24oc2NhbGVzLCBmbiwgZW5jb2RpbmcpIHtcbiAgdmFyIGxhYmVsTGVuZ3RoID0gZW5jb2RpbmcuY29uZmlnKCd0aW1lU2NhbGVMYWJlbExlbmd0aCcpO1xuICAvLyBUT0RPIGFkZCBvcHRpb24gZm9yIHNob3J0ZXIgc2NhbGUgLyBjdXN0b20gcmFuZ2VcbiAgc3dpdGNoIChmbikge1xuICAgIGNhc2UgJ2RheSc6XG4gICAgICBzY2FsZXMucHVzaCh7XG4gICAgICAgIG5hbWU6ICd0aW1lLScrZm4sXG4gICAgICAgIHR5cGU6ICdvcmRpbmFsJyxcbiAgICAgICAgZG9tYWluOiB1dGlsLnJhbmdlKDAsIDcpLFxuICAgICAgICByYW5nZTogWydNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5JywgJ1N1bmRheSddLm1hcChcbiAgICAgICAgICBmdW5jdGlvbihzKSB7IHJldHVybiBzLnN1YnN0cigwLCBsYWJlbExlbmd0aCk7fVxuICAgICAgICApXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIHNjYWxlcy5wdXNoKHtcbiAgICAgICAgbmFtZTogJ3RpbWUtJytmbixcbiAgICAgICAgdHlwZTogJ29yZGluYWwnLFxuICAgICAgICBkb21haW46IHV0aWwucmFuZ2UoMCwgMTIpLFxuICAgICAgICByYW5nZTogWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ10ubWFwKFxuICAgICAgICAgICAgZnVuY3Rpb24ocykgeyByZXR1cm4gcy5zdWJzdHIoMCwgbGFiZWxMZW5ndGgpO31cbiAgICAgICAgICApXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG50aW1lLmlzT3JkaW5hbEZuID0gZnVuY3Rpb24oZm4pIHtcbiAgc3dpdGNoIChmbikge1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2RhdGUnOlxuICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnRpbWUuc2NhbGUudHlwZSA9IGZ1bmN0aW9uKGZuLCBuYW1lKSB7XG4gIGlmIChuYW1lID09PSBDT0xPUikge1xuICAgIHJldHVybiAnbGluZWFyJzsgLy8gdGhpcyBoYXMgb3JkZXJcbiAgfVxuXG4gIHJldHVybiB0aW1lLmlzT3JkaW5hbEZuKGZuKSB8fCBuYW1lID09PSBDT0wgfHwgbmFtZSA9PT0gUk9XID8gJ29yZGluYWwnIDogJ2xpbmVhcic7XG59O1xuXG50aW1lLnNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKGZuLCBuYW1lKSB7XG4gIHZhciBpc0NvbG9yID0gbmFtZSA9PT0gQ09MT1I7XG4gIHN3aXRjaCAoZm4pIHtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdtaW51dGVzJzogcmV0dXJuIGlzQ29sb3IgPyBbMCw1OV0gOiB1dGlsLnJhbmdlKDAsIDYwKTtcbiAgICBjYXNlICdob3Vycyc6IHJldHVybiBpc0NvbG9yID8gWzAsMjNdIDogdXRpbC5yYW5nZSgwLCAyNCk7XG4gICAgY2FzZSAnZGF5JzogcmV0dXJuIGlzQ29sb3IgPyBbMCw2XSA6IHV0aWwucmFuZ2UoMCwgNyk7XG4gICAgY2FzZSAnZGF0ZSc6IHJldHVybiBpc0NvbG9yID8gWzEsMzFdIDogdXRpbC5yYW5nZSgxLCAzMik7XG4gICAgY2FzZSAnbW9udGgnOiByZXR1cm4gaXNDb2xvciA/IFswLDExXSA6IHV0aWwucmFuZ2UoMCwgMTIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqIHdoZXRoZXIgYSBwYXJ0aWN1bGFyIHRpbWUgZnVuY3Rpb24gaGFzIGN1c3RvbSBzY2FsZSBmb3IgbGFiZWxzIGltcGxlbWVudGVkIGluIHRpbWUuc2NhbGUgKi9cbnRpbWUuaGFzU2NhbGUgPSBmdW5jdGlvbihmbikge1xuICBzd2l0Y2ggKGZuKSB7XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdtb250aCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5cbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9nbG9iYWxzJyk7XG5cbnZhciBjb25zdHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5jb25zdHMuZW5jb2RpbmdUeXBlcyA9IFtYLCBZLCBST1csIENPTCwgU0laRSwgU0hBUEUsIENPTE9SLCBBTFBIQSwgVEVYVCwgREVUQUlMXTtcblxuY29uc3RzLmRhdGFUeXBlcyA9IHsnTyc6IE8sICdRJzogUSwgJ1QnOiBUfTtcblxuY29uc3RzLmRhdGFUeXBlTmFtZXMgPSBbJ08nLCAnUScsICdUJ10ucmVkdWNlKGZ1bmN0aW9uKHIsIHgpIHtcbiAgcltjb25zdHMuZGF0YVR5cGVzW3hdXSA9IHg7XG4gIHJldHVybiByO1xufSx7fSk7XG5cbmNvbnN0cy5zaG9ydGhhbmQgPSB7XG4gIGRlbGltOiAgJ3wnLFxuICBhc3NpZ246ICc9JyxcbiAgdHlwZTogICAnLCcsXG4gIGZ1bmM6ICAgJ18nXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdmxkYXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLyoqIE1hcHBpbmcgZnJvbSBkYXRhbGliJ3MgaW5mZXJyZWQgdHlwZSB0byBWZWdhLWxpdGUncyB0eXBlICovXG52bGRhdGEudHlwZXMgPSB7XG4gICdib29sZWFuJzogJ08nLFxuICAnbnVtYmVyJzogJ1EnLFxuICAnaW50ZWdlcic6ICdRJyxcbiAgJ2RhdGUnOiAnVCcsXG4gICdzdHJpbmcnOiAnTydcbn07XG5cbiIsIi8vIHV0aWxpdHkgZm9yIGVuY1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0cycpLFxuICBjID0gY29uc3RzLnNob3J0aGFuZCxcbiAgdmxmaWVsZCA9IHJlcXVpcmUoJy4vZmllbGQnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICBzY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYS9zY2hlbWEnKSxcbiAgZW5jVHlwZXMgPSBzY2hlbWEuZW5jVHlwZXM7XG5cbnZhciB2bGVuYyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnZsZW5jLmNvdW50UmV0aW5hbCA9IGZ1bmN0aW9uKGVuYykge1xuICB2YXIgY291bnQgPSAwO1xuICBpZiAoZW5jLmNvbG9yKSBjb3VudCsrO1xuICBpZiAoZW5jLmFscGhhKSBjb3VudCsrO1xuICBpZiAoZW5jLnNpemUpIGNvdW50Kys7XG4gIGlmIChlbmMuc2hhcGUpIGNvdW50Kys7XG4gIHJldHVybiBjb3VudDtcbn07XG5cbnZsZW5jLmhhcyA9IGZ1bmN0aW9uKGVuYywgZW5jVHlwZSkge1xuICB2YXIgZmllbGREZWYgPSBlbmMgJiYgZW5jW2VuY1R5cGVdO1xuICByZXR1cm4gZmllbGREZWYgJiYgZmllbGREZWYubmFtZTtcbn07XG5cbnZsZW5jLmlzQWdncmVnYXRlID0gZnVuY3Rpb24oZW5jKSB7XG4gIGZvciAodmFyIGsgaW4gZW5jKSB7XG4gICAgaWYgKHZsZW5jLmhhcyhlbmMsIGspICYmIGVuY1trXS5hZ2dyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmxlbmMuZm9yRWFjaCA9IGZ1bmN0aW9uKGVuYywgZikge1xuICB2YXIgaSA9IDA7XG4gIGVuY1R5cGVzLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIGlmICh2bGVuYy5oYXMoZW5jLCBrKSkge1xuICAgICAgZihlbmNba10sIGssIGkrKyk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZsZW5jLm1hcCA9IGZ1bmN0aW9uKGVuYywgZikge1xuICB2YXIgYXJyID0gW107XG4gIGVuY1R5cGVzLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIGlmICh2bGVuYy5oYXMoZW5jLCBrKSkge1xuICAgICAgYXJyLnB1c2goZihlbmNba10sIGssIGVuYykpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhcnI7XG59O1xuXG52bGVuYy5yZWR1Y2UgPSBmdW5jdGlvbihlbmMsIGYsIGluaXQpIHtcbiAgdmFyIHIgPSBpbml0O1xuICBlbmNUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICBpZiAodmxlbmMuaGFzKGVuYywgaykpIHtcbiAgICAgIHIgPSBmKHIsIGVuY1trXSwgaywgIGVuYyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHI7XG59O1xuXG4vKlxuICogcmV0dXJuIGtleS12YWx1ZSBwYWlycyBvZiBmaWVsZCBuYW1lIGFuZCBsaXN0IG9mIGZpZWxkcyBvZiB0aGF0IGZpZWxkIG5hbWVcbiAqL1xudmxlbmMuZmllbGRzID0gZnVuY3Rpb24oZW5jKSB7XG4gIHJldHVybiB2bGVuYy5yZWR1Y2UoZW5jLCBmdW5jdGlvbiAobSwgZmllbGQpIHtcbiAgICB2YXIgZmllbGRMaXN0ID0gbVtmaWVsZC5uYW1lXSA9IG1bZmllbGQubmFtZV0gfHwgW10sXG4gICAgICBjb250YWluc1R5cGUgPSBmaWVsZExpc3QuY29udGFpbnNUeXBlID0gZmllbGRMaXN0LmNvbnRhaW5zVHlwZSB8fCB7fTtcblxuICAgIGlmIChmaWVsZExpc3QuaW5kZXhPZihmaWVsZCkgPT09IC0xKSB7XG4gICAgICBmaWVsZExpc3QucHVzaChmaWVsZCk7XG4gICAgICAvLyBhdWdtZW50IHRoZSBhcnJheSB3aXRoIGNvbnRhaW5zVHlwZS5RIC8gTyAvIFRcbiAgICAgIGNvbnRhaW5zVHlwZVtmaWVsZC50eXBlXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBtO1xuICB9LCB7fSk7XG59O1xuXG52bGVuYy5zaG9ydGhhbmQgPSBmdW5jdGlvbihlbmMpIHtcbiAgcmV0dXJuIHZsZW5jLm1hcChlbmMsIGZ1bmN0aW9uKGZpZWxkLCBldCkge1xuICAgIHJldHVybiBldCArIGMuYXNzaWduICsgdmxmaWVsZC5zaG9ydGhhbmQoZmllbGQpO1xuICB9KS5qb2luKGMuZGVsaW0pO1xufTtcblxudmxlbmMuZnJvbVNob3J0aGFuZCA9IGZ1bmN0aW9uKHNob3J0aGFuZCwgY29udmVydFR5cGUpIHtcbiAgdmFyIGVuYyA9IHV0aWwuaXNBcnJheShzaG9ydGhhbmQpID8gc2hvcnRoYW5kIDogc2hvcnRoYW5kLnNwbGl0KGMuZGVsaW0pO1xuICByZXR1cm4gZW5jLnJlZHVjZShmdW5jdGlvbihtLCBlKSB7XG4gICAgdmFyIHNwbGl0ID0gZS5zcGxpdChjLmFzc2lnbiksXG4gICAgICAgIGVuY3R5cGUgPSBzcGxpdFswXS50cmltKCksXG4gICAgICAgIGZpZWxkID0gc3BsaXRbMV07XG5cbiAgICBtW2VuY3R5cGVdID0gdmxmaWVsZC5mcm9tU2hvcnRoYW5kKGZpZWxkLCBjb252ZXJ0VHlwZSk7XG4gICAgcmV0dXJuIG07XG4gIH0sIHt9KTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyB1dGlsaXR5IGZvciBmaWVsZFxuXG52YXIgY29uc3RzID0gcmVxdWlyZSgnLi9jb25zdHMnKSxcbiAgYyA9IGNvbnN0cy5zaG9ydGhhbmQsXG4gIHRpbWUgPSByZXF1aXJlKCcuL2NvbXBpbGUvdGltZScpLFxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gIHNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hL3NjaGVtYScpO1xuXG52YXIgdmxmaWVsZCA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnZsZmllbGQuc2hvcnRoYW5kID0gZnVuY3Rpb24oZikge1xuICB2YXIgYyA9IGNvbnN0cy5zaG9ydGhhbmQ7XG4gIHJldHVybiAoZi5hZ2dyID8gZi5hZ2dyICsgYy5mdW5jIDogJycpICtcbiAgICAoZi5mbiA/IGYuZm4gKyBjLmZ1bmMgOiAnJykgK1xuICAgIChmLmJpbiA/ICdiaW4nICsgYy5mdW5jIDogJycpICtcbiAgICAoZi5uYW1lIHx8ICcnKSArIGMudHlwZSArXG4gICAgKGNvbnN0cy5kYXRhVHlwZU5hbWVzW2YudHlwZV0gfHwgZi50eXBlKTtcbn07XG5cbnZsZmllbGQuc2hvcnRoYW5kcyA9IGZ1bmN0aW9uKGZpZWxkcywgZGVsaW0pIHtcbiAgZGVsaW0gPSBkZWxpbSB8fCBjLmRlbGltO1xuICByZXR1cm4gZmllbGRzLm1hcCh2bGZpZWxkLnNob3J0aGFuZCkuam9pbihkZWxpbSk7XG59O1xuXG52bGZpZWxkLmZyb21TaG9ydGhhbmQgPSBmdW5jdGlvbihzaG9ydGhhbmQsIGNvbnZlcnRUeXBlKSB7XG4gIHZhciBzcGxpdCA9IHNob3J0aGFuZC5zcGxpdChjLnR5cGUpLCBpO1xuICB2YXIgbyA9IHtcbiAgICBuYW1lOiBzcGxpdFswXS50cmltKCksXG4gICAgdHlwZTogY29udmVydFR5cGUgPyBjb25zdHMuZGF0YVR5cGVzW3NwbGl0WzFdLnRyaW0oKV0gOiBzcGxpdFsxXS50cmltKClcbiAgfTtcblxuICAvLyBjaGVjayBhZ2dyZWdhdGUgdHlwZVxuICBmb3IgKGkgaW4gc2NoZW1hLmFnZ3IuZW51bSkge1xuICAgIHZhciBhID0gc2NoZW1hLmFnZ3IuZW51bVtpXTtcbiAgICBpZiAoby5uYW1lLmluZGV4T2YoYSArICdfJykgPT09IDApIHtcbiAgICAgIG8ubmFtZSA9IG8ubmFtZS5zdWJzdHIoYS5sZW5ndGggKyAxKTtcbiAgICAgIGlmIChhID09ICdjb3VudCcgJiYgby5uYW1lLmxlbmd0aCA9PT0gMCkgby5uYW1lID0gJyonO1xuICAgICAgby5hZ2dyID0gYTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIHRpbWUgZm5cbiAgZm9yIChpIGluIHNjaGVtYS50aW1lZm5zKSB7XG4gICAgdmFyIGYgPSBzY2hlbWEudGltZWZuc1tpXTtcbiAgICBpZiAoby5uYW1lICYmIG8ubmFtZS5pbmRleE9mKGYgKyAnXycpID09PSAwKSB7XG4gICAgICBvLm5hbWUgPSBvLm5hbWUuc3Vic3RyKG8ubGVuZ3RoICsgMSk7XG4gICAgICBvLmZuID0gZjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGJpblxuICBpZiAoby5uYW1lICYmIG8ubmFtZS5pbmRleE9mKCdiaW5fJykgPT09IDApIHtcbiAgICBvLm5hbWUgPSBvLm5hbWUuc3Vic3RyKDQpO1xuICAgIG8uYmluID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBvO1xufTtcblxudmFyIHR5cGVPcmRlciA9IHtcbiAgTzogMCxcbiAgRzogMSxcbiAgVDogMixcbiAgUTogM1xufTtcblxudmxmaWVsZC5vcmRlciA9IHt9O1xuXG52bGZpZWxkLm9yZGVyLnR5cGUgPSBmdW5jdGlvbihmaWVsZCkge1xuICBpZiAoZmllbGQuYWdncj09PSdjb3VudCcpIHJldHVybiA0O1xuICByZXR1cm4gdHlwZU9yZGVyW2ZpZWxkLnR5cGVdO1xufTtcblxudmxmaWVsZC5vcmRlci50eXBlVGhlbk5hbWUgPSBmdW5jdGlvbihmaWVsZCkge1xuICByZXR1cm4gdmxmaWVsZC5vcmRlci50eXBlKGZpZWxkKSArICdfJyArIGZpZWxkLm5hbWUudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZsZmllbGQub3JkZXIub3JpZ2luYWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDA7IC8vIG5vIHN3YXAgd2lsbCBvY2N1clxufTtcblxudmxmaWVsZC5vcmRlci5uYW1lID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuIGZpZWxkLm5hbWU7XG59O1xuXG52bGZpZWxkLm9yZGVyLnR5cGVUaGVuQ2FyZGluYWxpdHkgPSBmdW5jdGlvbihmaWVsZCwgc3RhdHMpe1xuICByZXR1cm4gc3RhdHNbZmllbGQubmFtZV0uZGlzdGluY3Q7XG59O1xuXG4vLyBGSVhNRSByZWZhY3RvclxudmxmaWVsZC5pc1R5cGUgPSBmdW5jdGlvbiAoZmllbGREZWYsIHR5cGUpIHtcbiAgcmV0dXJuIChmaWVsZERlZi50eXBlICYgdHlwZSkgPiAwO1xufTtcblxudmxmaWVsZC5pc1R5cGUuYnlDb2RlID0gdmxmaWVsZC5pc1R5cGU7XG5cbnZsZmllbGQuaXNUeXBlLmJ5TmFtZSA9IGZ1bmN0aW9uIChmaWVsZCwgdHlwZSkge1xuICByZXR1cm4gZmllbGQudHlwZSA9PT0gY29uc3RzLmRhdGFUeXBlTmFtZXNbdHlwZV07XG59O1xuXG5cbmZ1bmN0aW9uIGdldElzVHlwZSh1c2VUeXBlQ29kZSkge1xuICByZXR1cm4gdXNlVHlwZUNvZGUgPyB2bGZpZWxkLmlzVHlwZS5ieUNvZGUgOiB2bGZpZWxkLmlzVHlwZS5ieU5hbWU7XG59XG5cbnZsZmllbGQuaXNUeXBlLmdldCA9IGdldElzVHlwZTsgLy9GSVhNRVxuXG4vKlxuICogTW9zdCBmaWVsZHMgdGhhdCB1c2Ugb3JkaW5hbCBzY2FsZSBhcmUgZGltZW5zaW9ucy5cbiAqIEhvd2V2ZXIsIFlFQVIoVCksIFlFQVJNT05USChUKSB1c2UgdGltZSBzY2FsZSwgbm90IG9yZGluYWwgYnV0IGFyZSBkaW1lbnNpb25zIHRvby5cbiAqL1xudmxmaWVsZC5pc09yZGluYWxTY2FsZSA9IGZ1bmN0aW9uKGZpZWxkLCB1c2VUeXBlQ29kZSAvKm9wdGlvbmFsKi8pIHtcbiAgdmFyIGlzVHlwZSA9IGdldElzVHlwZSh1c2VUeXBlQ29kZSk7XG4gIHJldHVybiAgaXNUeXBlKGZpZWxkLCBPKSB8fCBmaWVsZC5iaW4gfHxcbiAgICAoIGlzVHlwZShmaWVsZCwgVCkgJiYgZmllbGQuZm4gJiYgdGltZS5pc09yZGluYWxGbihmaWVsZC5mbikgKTtcbn07XG5cbmZ1bmN0aW9uIGlzRGltZW5zaW9uKGZpZWxkLCB1c2VUeXBlQ29kZSAvKm9wdGlvbmFsKi8pIHtcbiAgdmFyIGlzVHlwZSA9IGdldElzVHlwZSh1c2VUeXBlQ29kZSk7XG4gIHJldHVybiAgaXNUeXBlKGZpZWxkLCBPKSB8fCAhIWZpZWxkLmJpbiB8fFxuICAgICggaXNUeXBlKGZpZWxkLCBUKSAmJiAhIWZpZWxkLmZuICk7XG59XG5cbi8qKlxuICogRm9yIGVuY29kaW5nLCB1c2UgZW5jb2RpbmcuaXNEaW1lbnNpb24oKSB0byBhdm9pZCBjb25mdXNpb24uXG4gKiBPciB1c2UgRW5jb2RpbmcuaXNUeXBlIGlmIHlvdXIgZmllbGQgaXMgZnJvbSBFbmNvZGluZyAoYW5kIHRodXMgaGF2ZSBudW1lcmljIGRhdGEgdHlwZSkuXG4gKiBvdGhlcndpc2UsIGRvIG5vdCBzcGVjaWZpYyBpc1R5cGUgc28gd2UgY2FuIHVzZSB0aGUgZGVmYXVsdCBpc1R5cGVOYW1lIGhlcmUuXG4gKi9cbnZsZmllbGQuaXNEaW1lbnNpb24gPSBmdW5jdGlvbihmaWVsZCwgdXNlVHlwZUNvZGUgLypvcHRpb25hbCovKSB7XG4gIHJldHVybiBmaWVsZCAmJiBpc0RpbWVuc2lvbihmaWVsZCwgdXNlVHlwZUNvZGUpO1xufTtcblxudmxmaWVsZC5pc01lYXN1cmUgPSBmdW5jdGlvbihmaWVsZCwgdXNlVHlwZUNvZGUpIHtcbiAgcmV0dXJuIGZpZWxkICYmICFpc0RpbWVuc2lvbihmaWVsZCwgdXNlVHlwZUNvZGUpO1xufTtcblxudmxmaWVsZC5yb2xlID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuIGlzRGltZW5zaW9uKGZpZWxkKSA/ICdkaW1lbnNpb24nIDogJ21lYXN1cmUnO1xufTtcblxudmxmaWVsZC5jb3VudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge25hbWU6JyonLCBhZ2dyOiAnY291bnQnLCB0eXBlOidRJywgZGlzcGxheU5hbWU6IHZsZmllbGQuY291bnQuZGlzcGxheU5hbWV9O1xufTtcblxudmxmaWVsZC5jb3VudC5kaXNwbGF5TmFtZSA9ICdOdW1iZXIgb2YgUmVjb3Jkcyc7XG5cbnZsZmllbGQuaXNDb3VudCA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiBmaWVsZC5hZ2dyID09PSAnY291bnQnO1xufTtcblxuLyoqXG4gKiBGb3IgZW5jb2RpbmcsIHVzZSBlbmNvZGluZy5jYXJkaW5hbGl0eSgpIHRvIGF2b2lkIGNvbmZ1c2lvbi4gIE9yIHVzZSBFbmNvZGluZy5pc1R5cGUgaWYgeW91ciBmaWVsZCBpcyBmcm9tIEVuY29kaW5nIChhbmQgdGh1cyBoYXZlIG51bWVyaWMgZGF0YSB0eXBlKS5cbiAqIG90aGVyd2lzZSwgZG8gbm90IHNwZWNpZmljIGlzVHlwZSBzbyB3ZSBjYW4gdXNlIHRoZSBkZWZhdWx0IGlzVHlwZU5hbWUgaGVyZS5cbiAqL1xudmxmaWVsZC5jYXJkaW5hbGl0eSA9IGZ1bmN0aW9uKGZpZWxkLCBzdGF0cywgZmlsdGVyTnVsbCwgdXNlVHlwZUNvZGUpIHtcbiAgLy8gRklYTUUgbmVlZCB0byB0YWtlIGZpbHRlciBpbnRvIGFjY291bnRcblxuICB2YXIgc3RhdCA9IHN0YXRzW2ZpZWxkLm5hbWVdO1xuICB2YXIgaXNUeXBlID0gZ2V0SXNUeXBlKHVzZVR5cGVDb2RlKSxcbiAgICB0eXBlID0gdXNlVHlwZUNvZGUgPyBjb25zdHMuZGF0YVR5cGVOYW1lc1tmaWVsZC50eXBlXSA6IGZpZWxkLnR5cGU7XG5cbiAgZmlsdGVyTnVsbCA9IGZpbHRlck51bGwgfHwge307XG5cbiAgaWYgKGZpZWxkLmJpbikge1xuICAgIHZhciBiaW5zID0gdXRpbC5nZXRiaW5zKHN0YXQsIGZpZWxkLmJpbi5tYXhiaW5zIHx8IHNjaGVtYS5NQVhCSU5TX0RFRkFVTFQpO1xuICAgIHJldHVybiAoYmlucy5zdG9wIC0gYmlucy5zdGFydCkgLyBiaW5zLnN0ZXA7XG4gIH1cbiAgaWYgKGlzVHlwZShmaWVsZCwgVCkpIHtcbiAgICB2YXIgY2FyZGluYWxpdHkgPSB0aW1lLmNhcmRpbmFsaXR5KGZpZWxkLCBzdGF0cywgZmlsdGVyTnVsbCwgdHlwZSk7XG4gICAgaWYoY2FyZGluYWxpdHkgIT09IG51bGwpIHJldHVybiBjYXJkaW5hbGl0eTtcbiAgICAvL290aGVyd2lzZSB1c2UgY2FsY3VsYXRpb24gYmVsb3dcbiAgfVxuICBpZiAoZmllbGQuYWdncikge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLy8gcmVtb3ZlIG51bGxcbiAgcmV0dXJuIHN0YXQuZGlzdGluY3QgLVxuICAgIChzdGF0Lm51bGxzID4gMCAmJiBmaWx0ZXJOdWxsW3R5cGVdID8gMSA6IDApO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gZGVjbGFyZSBnbG9iYWwgY29uc3RhbnRcbnZhciBnID0gZ2xvYmFsIHx8IHdpbmRvdztcblxuZy5UQUJMRSA9ICd0YWJsZSc7XG5nLlJBVyA9ICdyYXcnO1xuZy5TVEFDS0VEID0gJ3N0YWNrZWQnO1xuZy5JTkRFWCA9ICdpbmRleCc7XG5cbmcuWCA9ICd4JztcbmcuWSA9ICd5JztcbmcuUk9XID0gJ3Jvdyc7XG5nLkNPTCA9ICdjb2wnO1xuZy5TSVpFID0gJ3NpemUnO1xuZy5TSEFQRSA9ICdzaGFwZSc7XG5nLkNPTE9SID0gJ2NvbG9yJztcbmcuQUxQSEEgPSAnYWxwaGEnO1xuZy5URVhUID0gJ3RleHQnO1xuZy5ERVRBSUwgPSAnZGV0YWlsJztcblxuZy5PID0gMTtcbmcuUSA9IDI7XG5nLlQgPSA0O1xuIiwiLy8gUGFja2FnZSBvZiBkZWZpbmluZyBWZWdhLWxpdGUgU3BlY2lmaWNhdGlvbidzIGpzb24gc2NoZW1hXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHNjaGVtYSA9IG1vZHVsZS5leHBvcnRzID0ge30sXG4gIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbnNjaGVtYS51dGlsID0gcmVxdWlyZSgnLi9zY2hlbWF1dGlsJyk7XG5cbnNjaGVtYS5tYXJrdHlwZSA9IHtcbiAgdHlwZTogJ3N0cmluZycsXG4gIGVudW06IFsncG9pbnQnLCAndGljaycsICdiYXInLCAnbGluZScsICdhcmVhJywgJ2NpcmNsZScsICdzcXVhcmUnLCAndGV4dCddXG59O1xuXG5zY2hlbWEuYWdnciA9IHtcbiAgdHlwZTogJ3N0cmluZycsXG4gIGVudW06IFsnYXZnJywgJ3N1bScsICdtaW4nLCAnbWF4JywgJ2NvdW50J10sXG4gIHN1cHBvcnRlZEVudW1zOiB7XG4gICAgUTogWydhdmcnLCAnc3VtJywgJ21pbicsICdtYXgnLCAnY291bnQnXSxcbiAgICBPOiBbXSxcbiAgICBUOiBbJ2F2ZycsICdtaW4nLCAnbWF4J10sXG4gICAgJyc6IFsnY291bnQnXVxuICB9LFxuICBzdXBwb3J0ZWRUeXBlczogeydRJzogdHJ1ZSwgJ08nOiB0cnVlLCAnVCc6IHRydWUsICcnOiB0cnVlfVxufTtcbnNjaGVtYS5iYW5kID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIHNpemU6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIG1pbmltdW06IDBcbiAgICB9LFxuICAgIHBhZGRpbmc6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBkZWZhdWx0OiAxXG4gICAgfVxuICB9XG59O1xuXG5zY2hlbWEuZ2V0U3VwcG9ydGVkUm9sZSA9IGZ1bmN0aW9uKGVuY1R5cGUpIHtcbiAgcmV0dXJuIHNjaGVtYS5zY2hlbWEucHJvcGVydGllcy5lbmMucHJvcGVydGllc1tlbmNUeXBlXS5zdXBwb3J0ZWRSb2xlO1xufTtcblxuc2NoZW1hLnRpbWVmbnMgPSBbJ3llYXInLCAnbW9udGgnLCAnZGF5JywgJ2RhdGUnLCAnaG91cnMnLCAnbWludXRlcycsICdzZWNvbmRzJ107XG5cbnNjaGVtYS5kZWZhdWx0VGltZUZuID0gJ21vbnRoJztcblxuc2NoZW1hLmZuID0ge1xuICB0eXBlOiAnc3RyaW5nJyxcbiAgZW51bTogc2NoZW1hLnRpbWVmbnMsXG4gIHN1cHBvcnRlZFR5cGVzOiB7J1QnOiB0cnVlfVxufTtcblxuLy9UT0RPKGthbml0dyk6IGFkZCBvdGhlciB0eXBlIG9mIGZ1bmN0aW9uIGhlcmVcblxuc2NoZW1hLnNjYWxlX3R5cGUgPSB7XG4gIHR5cGU6ICdzdHJpbmcnLFxuICBlbnVtOiBbJ2xpbmVhcicsICdsb2cnLCAncG93JywgJ3NxcnQnLCAncXVhbnRpbGUnXSxcbiAgZGVmYXVsdDogJ2xpbmVhcicsXG4gIHN1cHBvcnRlZFR5cGVzOiB7J1EnOiB0cnVlfVxufTtcblxuc2NoZW1hLmZpZWxkID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfVxuICB9XG59O1xuXG52YXIgY2xvbmUgPSB1dGlsLmR1cGxpY2F0ZTtcbnZhciBtZXJnZSA9IHNjaGVtYS51dGlsLm1lcmdlO1xuXG5zY2hlbWEuTUFYQklOU19ERUZBVUxUID0gMTU7XG5cbnZhciBiaW4gPSB7XG4gIHR5cGU6IFsnYm9vbGVhbicsICdvYmplY3QnXSxcbiAgZGVmYXVsdDogZmFsc2UsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBtYXhiaW5zOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiBzY2hlbWEuTUFYQklOU19ERUZBVUxULFxuICAgICAgbWluaW11bTogMlxuICAgIH1cbiAgfSxcbiAgc3VwcG9ydGVkVHlwZXM6IHsnUSc6IHRydWV9IC8vIFRPRE86IGFkZCAnTycgYWZ0ZXIgZmluaXNoaW5nICM4MVxufTtcblxudmFyIHR5cGljYWxGaWVsZCA9IG1lcmdlKGNsb25lKHNjaGVtYS5maWVsZCksIHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGVudW06IFsnTycsICdRJywgJ1QnXVxuICAgIH0sXG4gICAgYWdncjogc2NoZW1hLmFnZ3IsXG4gICAgZm46IHNjaGVtYS5mbixcbiAgICBiaW46IGJpbixcbiAgICBzY2FsZToge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHR5cGU6IHNjaGVtYS5zY2FsZV90eXBlLFxuICAgICAgICByZXZlcnNlOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgIHN1cHBvcnRlZFR5cGVzOiB7J1EnOiB0cnVlLCAnVCc6IHRydWV9XG4gICAgICAgIH0sXG4gICAgICAgIHplcm86IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdJbmNsdWRlIHplcm8nLFxuICAgICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgICAgc3VwcG9ydGVkVHlwZXM6IHsnUSc6IHRydWUsICdUJzogdHJ1ZX1cbiAgICAgICAgfSxcbiAgICAgICAgbmljZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGVudW06IFsnc2Vjb25kJywgJ21pbnV0ZScsICdob3VyJywgJ2RheScsICd3ZWVrJywgJ21vbnRoJywgJ3llYXInXSxcbiAgICAgICAgICBzdXBwb3J0ZWRUeXBlczogeydUJzogdHJ1ZX1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbnZhciBvbmx5T3JkaW5hbEZpZWxkID0gbWVyZ2UoY2xvbmUoc2NoZW1hLmZpZWxkKSwge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkUm9sZToge1xuICAgIGRpbWVuc2lvbjogdHJ1ZVxuICB9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdHlwZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbJ08nLCdRJywgJ1QnXSAvLyBvcmRpbmFsLW9ubHkgZmllbGQgc3VwcG9ydHMgUSB3aGVuIGJpbiBpcyBhcHBsaWVkIGFuZCBUIHdoZW4gZm4gaXMgYXBwbGllZC5cbiAgICB9LFxuICAgIGZuOiBzY2hlbWEuZm4sXG4gICAgYmluOiBiaW4sXG4gICAgYWdncjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbJ2NvdW50J10sXG4gICAgICBzdXBwb3J0ZWRUeXBlczogeydPJzogdHJ1ZX1cbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgYXhpc01peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7cG9pbnQ6IHRydWUsIHRpY2s6IHRydWUsIGJhcjogdHJ1ZSwgbGluZTogdHJ1ZSwgYXJlYTogdHJ1ZSwgY2lyY2xlOiB0cnVlLCBzcXVhcmU6IHRydWV9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgYXhpczoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0EgZmxhZyBpbmRpY2F0ZSBpZiBncmlkbGluZXMgc2hvdWxkIGJlIGNyZWF0ZWQgaW4gYWRkaXRpb24gdG8gdGlja3MuJ1xuICAgICAgICB9LFxuICAgICAgICB0aXRsZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQSB0aXRsZSBmb3IgdGhlIGF4aXMuJ1xuICAgICAgICB9LFxuICAgICAgICB0aXRsZU9mZnNldDoge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsICAvLyBhdXRvXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdBIHRpdGxlIG9mZnNldCB2YWx1ZSBmb3IgdGhlIGF4aXMuJ1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXQ6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsICAvLyBhdXRvXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdUaGUgZm9ybWF0dGluZyBwYXR0ZXJuIGZvciBheGlzIGxhYmVscy4nXG4gICAgICAgIH0sXG4gICAgICAgIG1heExhYmVsTGVuZ3RoOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIGRlZmF1bHQ6IDI1LFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdUcnVuY2F0ZSBsYWJlbHMgdGhhdCBhcmUgdG9vIGxvbmcuJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgc29ydE1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIHNvcnQ6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBkZWZhdWx0OiBbXSxcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBzdXBwb3J0ZWRUeXBlczogeydPJzogdHJ1ZX0sXG4gICAgICAgIHJlcXVpcmVkOiBbJ25hbWUnLCAnYWdnciddLFxuICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICAgICAgfSxcbiAgICAgICAgYWdncjoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGVudW06IFsnYXZnJywgJ3N1bScsICdtaW4nLCAnbWF4JywgJ2NvdW50J11cbiAgICAgICAgfSxcbiAgICAgICAgcmV2ZXJzZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgYmFuZE1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIGJhbmQ6IHNjaGVtYS5iYW5kXG4gIH1cbn07XG5cbnZhciBsZWdlbmRNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBsZWdlbmQ6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0ZXh0TWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHsndGV4dCc6IHRydWV9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdGV4dDoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGFsaWduOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogJ2xlZnQnXG4gICAgICAgIH0sXG4gICAgICAgIGJhc2VsaW5lOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogJ21pZGRsZSdcbiAgICAgICAgfSxcbiAgICAgICAgbWFyZ2luOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIGRlZmF1bHQ6IDQsXG4gICAgICAgICAgbWluaW11bTogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBmb250OiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgd2VpZ2h0OiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZW51bTogWydub3JtYWwnLCAnYm9sZCddLFxuICAgICAgICAgIGRlZmF1bHQ6ICdub3JtYWwnXG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgZGVmYXVsdDogMTAsXG4gICAgICAgICAgbWluaW11bTogMFxuICAgICAgICB9LFxuICAgICAgICBmYW1pbHk6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiAnSGVsdmV0aWNhIE5ldWUnXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogJ25vcm1hbCcsXG4gICAgICAgICAgZW51bTogWydub3JtYWwnLCAnaXRhbGljJ11cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHNpemVNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczoge3BvaW50OiB0cnVlLCBiYXI6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlLCB0ZXh0OiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAzMCxcbiAgICAgIG1pbmltdW06IDBcbiAgICB9XG4gIH1cbn07XG5cbnZhciBjb2xvck1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7cG9pbnQ6IHRydWUsIHRpY2s6IHRydWUsIGJhcjogdHJ1ZSwgbGluZTogdHJ1ZSwgYXJlYTogdHJ1ZSwgY2lyY2xlOiB0cnVlLCBzcXVhcmU6IHRydWUsICd0ZXh0JzogdHJ1ZX0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByb2xlOiAnY29sb3InLFxuICAgICAgZGVmYXVsdDogJ3N0ZWVsYmx1ZSdcbiAgICB9LFxuICAgIHNjYWxlOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICB0eXBlOiBbJ3N0cmluZycsICdhcnJheSddXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBhbHBoYU1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7cG9pbnQ6IHRydWUsIHRpY2s6IHRydWUsIGJhcjogdHJ1ZSwgbGluZTogdHJ1ZSwgYXJlYTogdHJ1ZSwgY2lyY2xlOiB0cnVlLCBzcXVhcmU6IHRydWUsICd0ZXh0JzogdHJ1ZX0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWQsICAvLyBhdXRvXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgbWF4aW11bTogMVxuICAgIH1cbiAgfVxufTtcblxudmFyIHNoYXBlTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgY2lyY2xlOiB0cnVlLCBzcXVhcmU6IHRydWV9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogWydjaXJjbGUnLCAnc3F1YXJlJywgJ2Nyb3NzJywgJ2RpYW1vbmQnLCAndHJpYW5nbGUtdXAnLCAndHJpYW5nbGUtZG93biddLFxuICAgICAgZGVmYXVsdDogJ2NpcmNsZSdcbiAgICB9XG4gIH1cbn07XG5cbnZhciBkZXRhaWxNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczoge3BvaW50OiB0cnVlLCB0aWNrOiB0cnVlLCBsaW5lOiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZX1cbn07XG5cbnZhciByb3dNaXhpbiA9IHtcbiAgcHJvcGVydGllczoge1xuICAgIGhlaWdodDoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgZGVmYXVsdDogMTUwXG4gICAgfSxcbiAgICBncmlkOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgZGVzY3JpcHRpb246ICdBIGZsYWcgaW5kaWNhdGUgaWYgZ3JpZGxpbmVzIHNob3VsZCBiZSBjcmVhdGVkIGluIGFkZGl0aW9uIHRvIHRpY2tzLidcbiAgICB9LFxuICB9XG59O1xuXG52YXIgY29sTWl4aW4gPSB7XG4gIHByb3BlcnRpZXM6IHtcbiAgICB3aWR0aDoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgZGVmYXVsdDogMTUwXG4gICAgfSxcbiAgICBheGlzOiB7XG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIG1heExhYmVsTGVuZ3RoOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIGRlZmF1bHQ6IDEyLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdUcnVuY2F0ZSBsYWJlbHMgdGhhdCBhcmUgdG9vIGxvbmcuJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgZmFjZXRNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczoge3BvaW50OiB0cnVlLCB0aWNrOiB0cnVlLCBiYXI6IHRydWUsIGxpbmU6IHRydWUsIGFyZWE6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlLCB0ZXh0OiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIHBhZGRpbmc6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgbWluaW11bTogMCxcbiAgICAgIG1heGltdW06IDEsXG4gICAgICBkZWZhdWx0OiAwLjFcbiAgICB9XG4gIH1cbn07XG5cbnZhciByZXF1aXJlZE5hbWVUeXBlID0ge1xuICByZXF1aXJlZDogWyduYW1lJywgJ3R5cGUnXVxufTtcblxudmFyIG11bHRpUm9sZUZpZWxkID0gbWVyZ2UoY2xvbmUodHlwaWNhbEZpZWxkKSwge1xuICBzdXBwb3J0ZWRSb2xlOiB7XG4gICAgbWVhc3VyZTogdHJ1ZSxcbiAgICBkaW1lbnNpb246IHRydWVcbiAgfVxufSk7XG5cbnZhciBxdWFudGl0YXRpdmVGaWVsZCA9IG1lcmdlKGNsb25lKHR5cGljYWxGaWVsZCksIHtcbiAgc3VwcG9ydGVkUm9sZToge1xuICAgIG1lYXN1cmU6IHRydWUsXG4gICAgZGltZW5zaW9uOiAnb3JkaW5hbC1vbmx5JyAvLyB1c2luZyBhbHBoYSAvIHNpemUgdG8gZW5jb2RpbmcgY2F0ZWdvcnkgbGVhZCB0byBvcmRlciBpbnRlcnByZXRhdGlvblxuICB9XG59KTtcblxudmFyIG9ubHlRdWFudGl0YXRpdmVGaWVsZCA9IG1lcmdlKGNsb25lKHR5cGljYWxGaWVsZCksIHtcbiAgc3VwcG9ydGVkUm9sZToge1xuICAgIG1lYXN1cmU6IHRydWVcbiAgfVxufSk7XG5cbnZhciB4ID0gbWVyZ2UoY2xvbmUobXVsdGlSb2xlRmllbGQpLCBheGlzTWl4aW4sIGJhbmRNaXhpbiwgcmVxdWlyZWROYW1lVHlwZSwgc29ydE1peGluKTtcbnZhciB5ID0gY2xvbmUoeCk7XG5cbnZhciBmYWNldCA9IG1lcmdlKGNsb25lKG9ubHlPcmRpbmFsRmllbGQpLCByZXF1aXJlZE5hbWVUeXBlLCBmYWNldE1peGluLCBzb3J0TWl4aW4pO1xudmFyIHJvdyA9IG1lcmdlKGNsb25lKGZhY2V0KSwgYXhpc01peGluLCByb3dNaXhpbik7XG52YXIgY29sID0gbWVyZ2UoY2xvbmUoZmFjZXQpLCBheGlzTWl4aW4sIGNvbE1peGluKTtcblxudmFyIHNpemUgPSBtZXJnZShjbG9uZShxdWFudGl0YXRpdmVGaWVsZCksIGxlZ2VuZE1peGluLCBzaXplTWl4aW4sIHNvcnRNaXhpbik7XG52YXIgY29sb3IgPSBtZXJnZShjbG9uZShtdWx0aVJvbGVGaWVsZCksIGxlZ2VuZE1peGluLCBjb2xvck1peGluLCBzb3J0TWl4aW4pO1xudmFyIGFscGhhID0gbWVyZ2UoY2xvbmUocXVhbnRpdGF0aXZlRmllbGQpLCBhbHBoYU1peGluLCBzb3J0TWl4aW4pO1xudmFyIHNoYXBlID0gbWVyZ2UoY2xvbmUob25seU9yZGluYWxGaWVsZCksIGxlZ2VuZE1peGluLCBzaGFwZU1peGluLCBzb3J0TWl4aW4pO1xudmFyIGRldGFpbCA9IG1lcmdlKGNsb25lKG9ubHlPcmRpbmFsRmllbGQpLCBkZXRhaWxNaXhpbiwgc29ydE1peGluKTtcblxuLy8gd2Ugb25seSBwdXQgYWdncmVnYXRlZCBtZWFzdXJlIGluIHBpdm90IHRhYmxlXG52YXIgdGV4dCA9IG1lcmdlKGNsb25lKG9ubHlRdWFudGl0YXRpdmVGaWVsZCksIHRleHRNaXhpbiwgc29ydE1peGluKTtcblxuLy8gVE9ETyBhZGQgbGFiZWxcblxudmFyIGZpbHRlciA9IHtcbiAgdHlwZTogJ2FycmF5JyxcbiAgaXRlbXM6IHtcbiAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBvcGVyYW5kczoge1xuICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICBpdGVtczoge1xuICAgICAgICAgIHR5cGU6IFsnc3RyaW5nJywgJ2Jvb2xlYW4nLCAnaW50ZWdlcicsICdudW1iZXInXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb3BlcmF0b3I6IHtcbiAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgIGVudW06IFsnPicsICc+PScsICc9JywgJyE9JywgJzwnLCAnPD0nLCAnbm90TnVsbCddXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgZGF0YSA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvLyBkYXRhIHNvdXJjZVxuICAgIGZvcm1hdFR5cGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogWydqc29uJywgJ2NzdiddLFxuICAgICAgZGVmYXVsdDogJ2pzb24nXG4gICAgfSxcbiAgICB1cmw6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBkZXNjcmlwdGlvbjogJ1Bhc3MgYXJyYXkgb2Ygb2JqZWN0cyBpbnN0ZWFkIG9mIGEgdXJsIHRvIGEgZmlsZS4nLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgY29uZmlnID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIC8vIHRlbXBsYXRlXG4gICAgd2lkdGg6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgaGVpZ2h0OiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICB9LFxuICAgIHZpZXdwb3J0OiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogJ2ludGVnZXInXG4gICAgICB9LFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICBncmlkQ29sb3I6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcm9sZTogJ2NvbG9yJyxcbiAgICAgIGRlZmF1bHQ6ICdibGFjaydcbiAgICB9LFxuICAgIGdyaWRPcGFjaXR5OiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBtYXhpbXVtOiAxLFxuICAgICAgZGVmYXVsdDogMC4wOFxuICAgIH0sXG5cbiAgICAvLyBmaWx0ZXIgbnVsbFxuICAgIGZpbHRlck51bGw6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBPOiB7dHlwZTonYm9vbGVhbicsIGRlZmF1bHQ6IGZhbHNlfSxcbiAgICAgICAgUToge3R5cGU6J2Jvb2xlYW4nLCBkZWZhdWx0OiB0cnVlfSxcbiAgICAgICAgVDoge3R5cGU6J2Jvb2xlYW4nLCBkZWZhdWx0OiB0cnVlfVxuICAgICAgfVxuICAgIH0sXG4gICAgdG9nZ2xlU29ydDoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBkZWZhdWx0OiAnTydcbiAgICB9LFxuXG4gICAgLy8gc2luZ2xlIHBsb3RcbiAgICBzaW5nbGVIZWlnaHQ6IHtcbiAgICAgIC8vIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgYmFuZFdpZHRoICogKGNhcmRpbmFsaXR5ICsgcGFkZGluZylcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDIwMCxcbiAgICAgIG1pbmltdW06IDBcbiAgICB9LFxuICAgIHNpbmdsZVdpZHRoOiB7XG4gICAgICAvLyB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IGJhbmRXaWR0aCAqIChjYXJkaW5hbGl0eSArIHBhZGRpbmcpXG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAyMDAsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICAvLyBiYW5kIHNpemVcbiAgICBsYXJnZUJhbmRTaXplOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAyMSxcbiAgICAgIG1pbmltdW06IDBcbiAgICB9LFxuICAgIHNtYWxsQmFuZFNpemU6IHtcbiAgICAgIC8vc21hbGwgbXVsdGlwbGVzIG9yIHNpbmdsZSBwbG90IHdpdGggaGlnaCBjYXJkaW5hbGl0eVxuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMTIsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICBsYXJnZUJhbmRNYXhDYXJkaW5hbGl0eToge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMTBcbiAgICB9LFxuICAgIC8vIHNtYWxsIG11bHRpcGxlc1xuICAgIGNlbGxQYWRkaW5nOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIGRlZmF1bHQ6IDAuMVxuICAgIH0sXG4gICAgY2VsbEdyaWRDb2xvcjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByb2xlOiAnY29sb3InLFxuICAgICAgZGVmYXVsdDogJ2JsYWNrJ1xuICAgIH0sXG4gICAgY2VsbEdyaWRPcGFjaXR5OiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBtYXhpbXVtOiAxLFxuICAgICAgZGVmYXVsdDogMC4xNVxuICAgIH0sXG4gICAgY2VsbEJhY2tncm91bmRDb2xvcjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByb2xlOiAnY29sb3InLFxuICAgICAgZGVmYXVsdDogJ3RyYW5zcGFyZW50J1xuICAgIH0sXG4gICAgdGV4dENlbGxXaWR0aDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogOTAsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcblxuICAgIC8vIG1hcmtzXG4gICAgc3Ryb2tlV2lkdGg6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDIsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcblxuICAgIC8vIHNjYWxlc1xuICAgIHRpbWVTY2FsZUxhYmVsTGVuZ3RoOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAzLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgLy8gb3RoZXJcbiAgICBjaGFyYWN0ZXJXaWR0aDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogNlxuICAgIH1cbiAgfVxufTtcblxuLyoqIEB0eXBlIE9iamVjdCBTY2hlbWEgb2YgYSB2ZWdhLWxpdGUgc3BlY2lmaWNhdGlvbiAqL1xuc2NoZW1hLnNjaGVtYSA9IHtcbiAgJHNjaGVtYTogJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hIycsXG4gIGRlc2NyaXB0aW9uOiAnU2NoZW1hIGZvciBWZWdhLWxpdGUgc3BlY2lmaWNhdGlvbicsXG4gIHR5cGU6ICdvYmplY3QnLFxuICByZXF1aXJlZDogWydtYXJrdHlwZScsICdlbmMnLCAnZGF0YSddLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgZGF0YTogZGF0YSxcbiAgICBtYXJrdHlwZTogc2NoZW1hLm1hcmt0eXBlLFxuICAgIGVuYzoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHJvdzogcm93LFxuICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICBhbHBoYTogYWxwaGEsXG4gICAgICAgIHNoYXBlOiBzaGFwZSxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICAgIH1cbiAgICB9LFxuICAgIGZpbHRlcjogZmlsdGVyLFxuICAgIGNvbmZpZzogY29uZmlnXG4gIH1cbn07XG5cbnNjaGVtYS5lbmNUeXBlcyA9IHV0aWwua2V5cyhzY2hlbWEuc2NoZW1hLnByb3BlcnRpZXMuZW5jLnByb3BlcnRpZXMpO1xuXG4vKiogSW5zdGFudGlhdGUgYSB2ZXJib3NlIHZsIHNwZWMgZnJvbSB0aGUgc2NoZW1hICovXG5zY2hlbWEuaW5zdGFudGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHNjaGVtYS51dGlsLmluc3RhbnRpYXRlKHNjaGVtYS5zY2hlbWEpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNjaGVtYXV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IHt9LFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XG59O1xuXG5zY2hlbWF1dGlsLmV4dGVuZCA9IGZ1bmN0aW9uKGluc3RhbmNlLCBzY2hlbWEpIHtcbiAgcmV0dXJuIHNjaGVtYXV0aWwubWVyZ2Uoc2NoZW1hdXRpbC5pbnN0YW50aWF0ZShzY2hlbWEpLCBpbnN0YW5jZSk7XG59O1xuXG4vLyBpbnN0YW50aWF0ZSBhIHNjaGVtYVxuc2NoZW1hdXRpbC5pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uKHNjaGVtYSkge1xuICB2YXIgdmFsO1xuICBpZiAoc2NoZW1hID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKCdkZWZhdWx0JyBpbiBzY2hlbWEpIHtcbiAgICB2YWwgPSBzY2hlbWEuZGVmYXVsdDtcbiAgICByZXR1cm4gdXRpbC5pc09iamVjdCh2YWwpID8gdXRpbC5kdXBsaWNhdGUodmFsKSA6IHZhbDtcbiAgfSBlbHNlIGlmIChzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB7fTtcbiAgICBmb3IgKHZhciBuYW1lIGluIHNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICB2YWwgPSBzY2hlbWF1dGlsLmluc3RhbnRpYXRlKHNjaGVtYS5wcm9wZXJ0aWVzW25hbWVdKTtcbiAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbnN0YW5jZVtuYW1lXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2UgaWYgKHNjaGVtYS50eXBlID09PSAnYXJyYXknKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vLyByZW1vdmUgYWxsIGRlZmF1bHRzIGZyb20gYW4gaW5zdGFuY2VcbnNjaGVtYXV0aWwuc3VidHJhY3QgPSBmdW5jdGlvbihpbnN0YW5jZSwgZGVmYXVsdHMpIHtcbiAgdmFyIGNoYW5nZXMgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBpbnN0YW5jZSkge1xuICAgIHZhciBkZWYgPSBkZWZhdWx0c1twcm9wXTtcbiAgICB2YXIgaW5zID0gaW5zdGFuY2VbcHJvcF07XG4gICAgLy8gTm90ZTogZG9lcyBub3QgcHJvcGVybHkgc3VidHJhY3QgYXJyYXlzXG4gICAgaWYgKCFkZWZhdWx0cyB8fCBkZWYgIT09IGlucykge1xuICAgICAgaWYgKHR5cGVvZiBpbnMgPT09ICdvYmplY3QnICYmICF1dGlsLmlzQXJyYXkoaW5zKSAmJiBkZWYpIHtcbiAgICAgICAgdmFyIGMgPSBzY2hlbWF1dGlsLnN1YnRyYWN0KGlucywgZGVmKTtcbiAgICAgICAgaWYgKCFpc0VtcHR5KGMpKVxuICAgICAgICAgIGNoYW5nZXNbcHJvcF0gPSBjO1xuICAgICAgfSBlbHNlIGlmICghdXRpbC5pc0FycmF5KGlucykgfHwgaW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY2hhbmdlc1twcm9wXSA9IGlucztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoYW5nZXM7XG59O1xuXG5zY2hlbWF1dGlsLm1lcmdlID0gZnVuY3Rpb24oLypkZXN0Kiwgc3JjMCwgc3JjMSwgLi4uKi8pe1xuICB2YXIgZGVzdCA9IGFyZ3VtZW50c1swXTtcbiAgZm9yICh2YXIgaT0xIDsgaTxhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBkZXN0ID0gbWVyZ2UoZGVzdCwgYXJndW1lbnRzW2ldKTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn07XG5cbi8vIHJlY3Vyc2l2ZWx5IG1lcmdlcyBzcmMgaW50byBkZXN0XG5mdW5jdGlvbiBtZXJnZShkZXN0LCBzcmMpIHtcbiAgaWYgKHR5cGVvZiBzcmMgIT09ICdvYmplY3QnIHx8IHNyYyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBkZXN0O1xuICB9XG5cbiAgZm9yICh2YXIgcCBpbiBzcmMpIHtcbiAgICBpZiAoIXNyYy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChzcmNbcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3JjW3BdICE9PSAnb2JqZWN0JyB8fCBzcmNbcF0gPT09IG51bGwpIHtcbiAgICAgIGRlc3RbcF0gPSBzcmNbcF07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVzdFtwXSAhPT0gJ29iamVjdCcgfHwgZGVzdFtwXSA9PT0gbnVsbCkge1xuICAgICAgZGVzdFtwXSA9IG1lcmdlKHNyY1twXS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgPyBbXSA6IHt9LCBzcmNbcF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZShkZXN0W3BdLCBzcmNbcF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVzdDtcbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdkYXRhbGliL3NyYy91dGlsJyk7XG5cbnV0aWwuZXh0ZW5kKHV0aWwsIHJlcXVpcmUoJ2RhdGFsaWIvc3JjL2dlbmVyYXRlJykpO1xudXRpbC5iaW4gPSByZXF1aXJlKCdkYXRhbGliL3NyYy9iaW4nKTtcblxudXRpbC5pc2luID0gZnVuY3Rpb24oaXRlbSwgYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSkgIT09IC0xO1xufTtcblxudXRpbC5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBmLCB0aGlzQXJnKSB7XG4gIGlmIChvYmouZm9yRWFjaCkge1xuICAgIG9iai5mb3JFYWNoLmNhbGwodGhpc0FyZywgZik7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgIGYuY2FsbCh0aGlzQXJnLCBvYmpba10sIGsgLCBvYmopO1xuICAgIH1cbiAgfVxufTtcblxudXRpbC5yZWR1Y2UgPSBmdW5jdGlvbihvYmosIGYsIGluaXQsIHRoaXNBcmcpIHtcbiAgaWYgKG9iai5yZWR1Y2UpIHtcbiAgICByZXR1cm4gb2JqLnJlZHVjZS5jYWxsKHRoaXNBcmcsIGYsIGluaXQpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICBpbml0ID0gZi5jYWxsKHRoaXNBcmcsIGluaXQsIG9ialtrXSwgaywgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIGluaXQ7XG4gIH1cbn07XG5cbnV0aWwubWFwID0gZnVuY3Rpb24ob2JqLCBmLCB0aGlzQXJnKSB7XG4gIGlmIChvYmoubWFwKSB7XG4gICAgcmV0dXJuIG9iai5tYXAuY2FsbCh0aGlzQXJnLCBmKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgIG91dHB1dC5wdXNoKCBmLmNhbGwodGhpc0FyZywgb2JqW2tdLCBrLCBvYmopKTtcbiAgICB9XG4gIH1cbn07XG5cbnV0aWwuYW55ID0gZnVuY3Rpb24oYXJyLCBmKSB7XG4gIHZhciBpID0gMCwgaztcbiAgZm9yIChrIGluIGFycikge1xuICAgIGlmIChmKGFycltrXSwgaywgaSsrKSkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudXRpbC5hbGwgPSBmdW5jdGlvbihhcnIsIGYpIHtcbiAgdmFyIGkgPSAwLCBrO1xuICBmb3IgKGsgaW4gYXJyKSB7XG4gICAgaWYgKCFmKGFycltrXSwgaywgaSsrKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxudXRpbC5nZXRiaW5zID0gZnVuY3Rpb24oc3RhdHMsIG1heGJpbnMpIHtcbiAgcmV0dXJuIHV0aWwuYmluKHtcbiAgICBtaW46IHN0YXRzLm1pbixcbiAgICBtYXg6IHN0YXRzLm1heCxcbiAgICBtYXhiaW5zOiBtYXhiaW5zXG4gIH0pO1xufTtcblxuLyoqXG4gKiB4W3BbMF1dLi4uW3Bbbl1dID0gdmFsXG4gKiBAcGFyYW0gbm9hdWdtZW50IGRldGVybWluZSB3aGV0aGVyIG5ldyBvYmplY3Qgc2hvdWxkIGJlIGFkZGVkIGZcbiAqIG9yIG5vbi1leGlzdGluZyBwcm9wZXJ0aWVzIGFsb25nIHRoZSBwYXRoXG4gKi9cbnV0aWwuc2V0dGVyID0gZnVuY3Rpb24oeCwgcCwgdmFsLCBub2F1Z21lbnQpIHtcbiAgZm9yICh2YXIgaT0wOyBpPHAubGVuZ3RoLTE7ICsraSkge1xuICAgIGlmICghbm9hdWdtZW50ICYmICEocFtpXSBpbiB4KSl7XG4gICAgICB4ID0geFtwW2ldXSA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geFtwW2ldXTtcbiAgICB9XG4gIH1cbiAgeFtwW2ldXSA9IHZhbDtcbn07XG5cblxuLyoqXG4gKiByZXR1cm5zIHhbcFswXV0uLi5bcFtuXV1cbiAqIEBwYXJhbSBhdWdtZW50IGRldGVybWluZSB3aGV0aGVyIG5ldyBvYmplY3Qgc2hvdWxkIGJlIGFkZGVkIGZcbiAqIG9yIG5vbi1leGlzdGluZyBwcm9wZXJ0aWVzIGFsb25nIHRoZSBwYXRoXG4gKi9cbnV0aWwuZ2V0dGVyID0gZnVuY3Rpb24oeCwgcCwgbm9hdWdtZW50KSB7XG4gIGZvciAodmFyIGk9MDsgaTxwLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCFub2F1Z21lbnQgJiYgIShwW2ldIGluIHgpKXtcbiAgICAgIHggPSB4W3BbaV1dID0ge307XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4W3BbaV1dO1xuICAgIH1cbiAgfVxuICByZXR1cm4geDtcbn07XG5cbnV0aWwuZXJyb3IgPSBmdW5jdGlvbihtc2cpIHtcbiAgY29uc29sZS5lcnJvcignW1ZMIEVycm9yXScsIG1zZyk7XG59O1xuXG4iXX0=\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var util = require('./util');\nvar units = require('./date-units');\nvar EPSILON = 1e-15;\n\nfunction bin(opt) {\n  opt = opt || {};\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, logb, level, minstep, precision, v, i, eps;\n\n  if (opt.step != null) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n};\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n};\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbin.date = function(opt) {\n  opt = opt || {};\n\n  // find time step, then bin\n  var dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin);\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      bins = bin({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  bins.unit = unit;\n  bins.index = date_index;\n  if (!opt.raw) bins.value = date_value;\n  return bins;\n};\n\nmodule.exports = bin;\n","var util = require('./util');\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nvar entries = [\n  {\n    type: \"second\",\n    minstep: 1,\n    format: \"%Y %b %-d %H:%M:%S.%L\",\n    date: function(d) {\n      return new Date(d * 1e3);\n    },\n    unit: function(d) {\n      return (+d / 1e3);\n    }\n  },\n  {\n    type: \"minute\",\n    minstep: 1,\n    format: \"%Y %b %-d %H:%M\",\n    date: function(d) {\n      return new Date(d * 6e4);\n    },\n    unit: function(d) {\n      return ~~(+d / 6e4);\n    }\n  },\n  {\n    type: \"hour\",\n    minstep: 1,\n    format: \"%Y %b %-d %H:00\",\n    date: function(d) {\n      return new Date(d * 36e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 36e5);\n    }\n  },\n  {\n    type: \"day\",\n    minstep: 1,\n    step: [1, 7],\n    format: \"%Y %b %-d\",\n    date: function(d) {\n      return new Date(d * 864e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 864e5);\n    }\n  },\n  {\n    type: \"month\",\n    minstep: 1,\n    step: [1, 3, 6],\n    format: \"%b %Y\",\n    date: function(d) {\n      return new Date(Date.UTC(~~(d / 12), d % 12, 1));\n    },\n    unit: function(d) {\n      if (util.isNumber(d)) d = new Date(d);\n      return 12 * d.getUTCFullYear() + d.getUTCMonth();\n    }\n  },\n  {\n    type: \"year\",\n    minstep: 1,\n    format: \"%Y\",\n    date: function(d) {\n      return new Date(Date.UTC(d, 0, 1));\n    },\n    unit: function(d) {\n      return (util.isNumber(d) ? new Date(d) : d).getUTCFullYear();\n    }\n  }\n];\n\nvar minuteOfHour = {\n  type: \"minuteOfHour\",\n  min: 0,\n  max: 59,\n  minstep: 1,\n  format: \"%M\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, 0, d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCMinutes();\n  }\n};\n\nvar hourOfDay = {\n  type: \"hourOfDay\",\n  min: 0,\n  max: 23,\n  minstep: 1,\n  format: \"%H\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCHours();\n  }\n};\n\nvar dayOfWeek = {\n  type: \"dayOfWeek\",\n  min: 0,\n  max: 6,\n  step: [1],\n  format: \"%a\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 4 + d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCDay();\n  }\n};\n\nvar dayOfMonth = {\n  type: \"dayOfMonth\",\n  min: 1,\n  max: 31,\n  step: [1],\n  format: \"%-d\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCDate();\n  }\n};\n\nvar monthOfYear = {\n  type: \"monthOfYear\",\n  min: 0,\n  max: 11,\n  step: [1],\n  format: \"%b\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, d % 12, 1));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCMonth();\n  }\n};\n\nvar units = {\n  \"second\":       entries[0],\n  \"minute\":       entries[1],\n  \"hour\":         entries[2],\n  \"day\":          entries[3],\n  \"month\":        entries[4],\n  \"year\":         entries[5],\n  \"minuteOfHour\": minuteOfHour,\n  \"hourOfDay\":    hourOfDay,\n  \"dayOfWeek\":    dayOfWeek,\n  \"dayOfMonth\":   dayOfMonth,\n  \"monthOfYear\":  monthOfYear,\n  \"timesteps\":    entries\n};\n\nunits.find = function(span, minb, maxb) {\n  var i, len, bins, step = STEPS[0];\n\n  for (i = 1, len = STEPS.length; i < len; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return entries[STEPS[i - 1][1]];\n      }\n      if (bins >= minb) {\n        return entries[step[1]];\n      }\n    }\n  }\n  return entries[STEPS[STEPS.length - 1][1]];\n};\n\nmodule.exports = units;\n","var gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n\t\tmax = min;\n\t\tmin = 0;\n\t}\n\tvar d = max - min;\n\tvar f = function() {\n\t\treturn min + d * Math.random();\n\t};\n\tf.samples = function(n) { return gen.zeros(n).map(f); };\n\treturn f;\n};\n\ngen.random.integer = function(a, b) {\n\tif (b === undefined) {\n\t\tb = a;\n\t\ta = 0;\n\t}\n  var d = b - a;\n\tvar f = function() {\n\t\treturn a + Math.floor(d * Math.random());\n\t};\n\tf.samples = function(n) { return gen.zeros(n).map(f); };\n\treturn f;\n};\n\ngen.random.normal = function(mean, stdev) {\n\tmean = mean || 0;\n\tstdev = stdev || 1;\n\tvar next = undefined;\n\tvar f = function() {\n\t\tvar x = 0, y = 0, rds, c;\n\t\tif (next !== undefined) {\n\t\t\tx = next;\n\t\t\tnext = undefined;\n\t\t\treturn x;\n\t\t}\n\t\tdo {\n\t\t\tx = Math.random()*2-1;\n\t\t\ty = Math.random()*2-1;\n\t\t\trds = x*x + y*y;\n\t\t} while (rds == 0 || rds > 1);\n\t\tc = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n\t\tnext = mean + y*c*stdev;\n\t\treturn mean + x*c*stdev;\n\t};\n\tf.samples = function(n) { return gen.zeros(n).map(f); };\n\treturn f;\n};","var util = require('./util');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values and associated counts.\n// Output: an array of unique values, in observed order\n// The array includes an additional 'counts' property,\n// which is a hash from unique values to occurrence counts.\nstats.unique = function(values, f, results) {\n  if (!util.isArray(values) || values.length===0) return [];\n  results = results || [];\n  var u = {}, v, i;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) {\n      u[v] += 1;\n    } else {\n      u[v] = 1;\n      results.push(v);\n    }\n  }\n  results.counts = u;\n  return results;\n};\n\n// Count the number of non-null values.\nstats.count = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\nstats.count.distinct = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var u = {}, v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Count the number of null or undefined values.\nstats.count.nulls = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  if (f) values = values.map(f);\n  values = values.filter(util.isNotNull).sort(util.cmp);\n  var half = Math.floor(values.length/2);\n  if (values.length % 2) {\n    return values[half];\n  } else {\n    return (values[half-1] + values[half]) / 2.0;\n  }\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null && !isNaN(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null && !isNaN(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isNotNull(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isNotNull(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  var a, b, x, y, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isNotNull(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isNotNull(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error(\"Array lengths must match.\");\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (!isNaN(v)) sum += v;\n    }\n  } else {  \n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (!isNaN(v)) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  var a = values.map(function(v, i) {\n      return {\n        idx: i,\n        val: (f ? f(v) : v)\n      };\n    })\n    .sort(util.comparator(\"val\"));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(b) : a,\n  a = fn ? values.map(a) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, a) : stats.rank(values),\n      rb = b ? stats.rank(values, b) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(a) : values,\n      Y = b ? values.map(b) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      n = values.length, s = 0, d, i;\n\n  if (e === 2 || e === undefined) {\n    for (i=0; i<n; ++i) {\n      d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n      s += d*d;\n    }\n    return Math.sqrt(s); \n  } else {\n    for (i=0; i<n; ++i) {\n      d = Math.abs(f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]));\n      s += Math.pow(d, e);\n    }\n    return Math.pow(s, 1/e);\n  }\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  var i, p, s = 0, H = 0, N = counts.length;\n  for (i=0; i<N; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<N; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p > 0) H += p * Math.log(p) / Math.LN2;\n  }\n  return -H;\n};\n\n// Compute the normalized Shannon entropy (log base 2) of an array of counts.\nstats.entropy.normalized = function(counts, f) {\n  var H = stats.entropy(counts, f);\n  return H===0 ? 0 : H * Math.LN2 / Math.log(counts.length);\n};\n\n// Compute the mutual information between two discrete variables.\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.entropy.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(a) : values,\n      y = counts ? values.map(b) : a,\n      z = counts ? values.map(counts) : b;\n\n  var px = {},\n\t    py = {},\n\t    i, xx, yy, zz, s = 0, t, N = z.length, p, I = 0;\n\n\tfor (i=0; i<N; ++i) {\n\t  px[x[i]] = 0;\n\t  py[y[i]] = 0;\n  }\n\n\tfor (i=0; i<N; ++i) {\n\t\tpx[x[i]] += z[i];\n\t\tpy[y[i]] += z[i];\n\t\ts += z[i];\n\t}\n\n\tt = 1 / (s * Math.LN2);\n\tfor (i=0; i<N; ++i) {\n\t\tif (z[i] === 0) continue;\n\t\tp = (s * z[i]) / (px[x[i]] * py[y[i]]);\n\t\tI += z[i] * t * Math.log(p);\n\t}\n\n\treturn I;\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var p = {},\n      mean = 0,\n      count = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x, half, h, h2;\n\n  // compute summary stats\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (util.isNotNull(v)) {\n      // update min/max\n      if (min===null || v < min) min = v;\n      if (max===null || v > max) max = v;\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      delta = x - mean;\n      mean = mean + delta / (++count);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (count - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    unique:   u,\n    count:    count,\n    nulls:    values.length - count,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd,\n    iqr:      [stats.quantile(vals, 0.25), stats.quantile(vals, 0.75)]\n  };\n};\n\nmodule.exports = stats;","var util = require('./util');\nvar stats = require('./stats');\n\n// Compute profiles for all variables in a data set.\nmodule.exports = function(data, fields) {\n  if (data == null || data.length === 0) return null;\n  fields = fields || util.keys(data[0]);\n\n  var profiles = fields.map(function(f) {\n    var p = stats.profile(data, util.accessor(f));\n    return (p.field = f, p);\n  });\n  \n  profiles.toString = printSummary;\n  return profiles;\n};\n\nfunction printSummary() {\n  var profiles = this;\n  var str = [];\n  profiles.forEach(function(p) {\n    str.push(\"----- Field: '\" + p.field + \"' -----\");\n    if (typeof p.min === 'string' || p.distinct < 10) {\n      str.push(printCategoricalProfile(p));\n    } else {\n      str.push(printQuantitativeProfile(p));\n    }\n    str.push(\"\");\n  });\n  return str.join(\"\\n\");\n}\n\nfunction printQuantitativeProfile(p) {\n  return [\n    \"distinct: \" + p.distinct,\n    \"nulls:    \" + p.nulls,\n    \"min:      \" + p.min,\n    \"max:      \" + p.max,\n    \"median:   \" + p.median,\n    \"mean:     \" + p.mean,\n    \"stdev:    \" + p.stdev,\n    \"modeskew: \" + p.modeskew\n  ].join(\"\\n\");\n}\n\nfunction printCategoricalProfile(p) {\n  var list = [\n    \"distinct: \" + p.distinct,\n    \"nulls:    \" + p.nulls,\n    \"top values: \"\n  ];\n  var u = p.unique;\n  var top = util.keys(u)\n    .sort(function(a,b) { return u[b] - u[a]; })\n    .slice(0, 6)\n    .map(function(v) { return \" '\" + v + \"' (\" + u[v] + \")\"; });\n  return list.concat(top).join(\"\\n\");\n}","var Buffer = require('buffer').Buffer;\nvar u = module.exports = {};\n\n// where are we?\n\nu.isNode = typeof process !== 'undefined'\n        && typeof process.stderr !== 'undefined';\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) == '[object Function]';\n};\n\nu.isString = function(obj) {\n  return toString.call(obj) == '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) == '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return !isNaN(parseFloat(obj)) && isFinite(obj);\n};\n\nu.isBoolean = function(obj) {\n  return toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) == '[object Date]';\n};\n\nu.isNotNull = function(obj) {\n  return obj != null && (typeof obj !== 'number' ? true : !isNaN(obj));\n};\n\nu.isBuffer = (Buffer && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) { return s == null ? null : +s; };\n\nu.boolean = function(s) { return s == null ? null : s==='false' ? false : !!s; };\n\nu.date = function(s) { return s == null ? null : Date.parse(s); }\n\nu.array = function(x) { return x != null ? (u.isArray(x) ? x : [x]) : []; };\n\nu.str = function(x) {\n  return u.isArray(x) ? \"[\" + x.map(u.str) + \"]\"\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? (\"'\"+util_escape_str(x)+\"'\") : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, \"$1\\\\'\");\n}\n\n// utility functions\n\nu.identity = function(x) { return x; };\n\nu.true = function() { return true; };\n\nu.false = function() { return false; };\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list) {\n  return list.reduce(function(obj, x) {\n    return (obj[x] = 1, obj);\n  }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  return values.join(\"|\");\n};\n\n// data access functions\n\nu.field = function(f) {\n  return f.split(\"\\\\.\")\n    .map(function(d) { return d.split(\".\"); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += \".\" + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return (u.isFunction(f) || f==null)\n    ? f : u.isString(f) && (s=u.field(f)).length > 1\n    ? function(x) { return s.reduce(function(x,f) {\n          return x[f];\n        }, x);\n      }\n    : function(x) { return x[f]; };\n};\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1\n    ? function(x, v) {\n        for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n        x[s[i]] = v;\n      }\n    : function(x, v) { x[f] = v; };\n};\n\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === \"-\") { s = -1; f = f.slice(1); }\n    else if (f[0] === \"+\") { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null && b === null) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\n// ES6 compatibility per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill\n// We could have used the polyfill code, but lets wait until ES6 becomes a standard first\nu.startsWith = String.prototype.startsWith\n  ? function(string, searchString) {\n    return string.startsWith(searchString);\n  }\n  : function(string, searchString) {\n    return string.lastIndexOf(searchString, 0) === 0;\n  };\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : \"\";\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case \"left\":\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case \"middle\":\n    case \"center\":\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) + ellipsis\n        + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join(\"\").trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n","'use strict';\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  util = require('./util'),\n  vlfield = require('./field'),\n  vlenc = require('./enc'),\n  schema = require('./schema/schema');\n\nmodule.exports = (function() {\n  function Encoding(marktype, enc, data, config, filter, theme) {\n    var defaults = schema.instantiate();\n\n    var spec = {\n      data: data,\n      marktype: marktype,\n      enc: enc,\n      config: config,\n      filter: filter || []\n    };\n\n    // type to bitcode\n    for (var e in defaults.enc) {\n      defaults.enc[e].type = consts.dataTypes[defaults.enc[e].type];\n    }\n\n    var specExtended = schema.util.merge(defaults, theme || {}, spec) ;\n\n    this._data = specExtended.data;\n    this._marktype = specExtended.marktype;\n    this._enc = specExtended.enc;\n    this._config = specExtended.config;\n    this._filter = specExtended.filter;\n  }\n\n  var proto = Encoding.prototype;\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(encType) {\n    // equivalent to calling vlenc.has(this._enc, encType)\n    return this._enc[encType].name !== undefined;\n  };\n\n  proto.enc = function(et) {\n    return this._enc[et];\n  };\n\n  proto.filter = function() {\n    var filterNull = [],\n      fields = this.fields(),\n      self = this;\n\n    util.forEach(fields, function(fieldList, fieldName) {\n      if (fieldName === '*') return; //count\n\n      if ((self.config('filterNull').Q && fieldList.containsType[Q]) ||\n          (self.config('filterNull').T && fieldList.containsType[T]) ||\n          (self.config('filterNull').O && fieldList.containsType[O])) {\n        filterNull.push({\n          operands: [fieldName],\n          operator: 'notNull'\n        });\n      }\n    });\n\n    return filterNull.concat(this._filter);\n  };\n\n  // get \"field\" property for vega\n  proto.field = function(et, nodata, nofn) {\n    if (!this.has(et)) return null;\n\n    var f = (nodata ? '' : 'data.');\n\n    if (vlfield.isCount(this._enc[et])) {\n      return f + 'count';\n    } else if (!nofn && this._enc[et].bin) {\n      return f + 'bin_' + this._enc[et].name;\n    } else if (!nofn && this._enc[et].aggr) {\n      return f + this._enc[et].aggr + '_' + this._enc[et].name;\n    } else if (!nofn && this._enc[et].fn) {\n      return f + this._enc[et].fn + '_' + this._enc[et].name;\n    } else {\n      return f + this._enc[et].name;\n    }\n  };\n\n  proto.fieldName = function(et) {\n    return this._enc[et].name;\n  };\n\n  /*\n   * return key-value pairs of field name and list of fields of that field name\n   */\n  proto.fields = function() {\n    return vlenc.fields(this._enc);\n  };\n\n  proto.fieldTitle = function(et) {\n    if (vlfield.isCount(this._enc[et])) {\n      return vlfield.count.displayName;\n    }\n    var fn = this._enc[et].aggr || this._enc[et].fn || (this._enc[et].bin && \"bin\");\n    if (fn) {\n      return fn.toUpperCase() + '(' + this._enc[et].name + ')';\n    } else {\n      return this._enc[et].name;\n    }\n  };\n\n  proto.scale = function(et) {\n    return this._enc[et].scale || {};\n  };\n\n  proto.axis = function(et) {\n    return this._enc[et].axis || {};\n  };\n\n  proto.band = function(et) {\n    return this._enc[et].band || {};\n  };\n\n  proto.bandSize = function(encType, useSmallBand) {\n    useSmallBand = useSmallBand ||\n      //isBandInSmallMultiples\n      (encType === Y && this.has(ROW) && this.has(Y)) ||\n      (encType === X && this.has(COL) && this.has(X));\n\n    // if band.size is explicitly specified, follow the specification, otherwise draw value from config.\n    return this.band(encType).size ||\n      this.config(useSmallBand ? 'smallBandSize' : 'largeBandSize');\n  };\n\n  proto.aggr = function(et) {\n    return this._enc[et].aggr;\n  };\n\n  // returns false if binning is disabled, otherwise an object with binning properties\n  proto.bin = function(et) {\n    var bin = this._enc[et].bin;\n    if (bin === {})\n      return false;\n    if (bin === true)\n      return {\n        maxbins: schema.MAXBINS_DEFAULT\n      };\n    return bin;\n  };\n\n  proto.legend = function(et) {\n    return this._enc[et].legend;\n  };\n\n  proto.value = function(et) {\n    return this._enc[et].value;\n  };\n\n  proto.fn = function(et) {\n    return this._enc[et].fn;\n  };\n\n  proto.sort = function(et, stats) {\n    var sort = this._enc[et].sort,\n      enc = this._enc,\n      isType = vlfield.isType.byCode;\n\n    // console.log('sort:', sort, 'support:', Encoding.toggleSort.support({enc:this._enc}, stats) , 'toggle:', this.config('toggleSort'))\n\n    if ((!sort || sort.length===0) &&\n        Encoding.toggleSort.support({enc:this._enc}, stats, true) && //HACK\n        this.config('toggleSort') === 'Q'\n      ) {\n      var qField = isType(enc.x, O) ? enc.y : enc.x;\n\n      if (isType(enc[et], O)) {\n        sort = [{\n          name: qField.name,\n          aggr: qField.aggr,\n          type: qField.type,\n          reverse: true\n        }];\n      }\n    }\n\n    return sort;\n  };\n\n  proto.length = function() {\n    return util.keys(this._enc).length;\n  };\n\n  proto.map = function(f) {\n    return vlenc.map(this._enc, f);\n  };\n\n  proto.reduce = function(f, init) {\n    return vlenc.reduce(this._enc, f, init);\n  };\n\n  proto.forEach = function(f) {\n    return vlenc.forEach(this._enc, f);\n  };\n\n  proto.type = function(et) {\n    return this.has(et) ? this._enc[et].type : null;\n  };\n\n  proto.role = function(et) {\n    return this.has(et) ? vlfield.role(this._enc[et]) : null;\n  };\n\n  proto.text = function(prop) {\n    var text = this._enc[TEXT].text;\n    return prop ? text[prop] : text;\n  };\n\n  proto.font = function(prop) {\n    var font = this._enc[TEXT].font;\n    return prop ? font[prop] : font;\n  };\n\n  proto.isType = function(et, type) {\n    var field = this.enc(et);\n    return field && Encoding.isType(field, type);\n  };\n\n  Encoding.isType = function (fieldDef, type) {\n    // FIXME vlfield.isType\n    return (fieldDef.type & type) > 0;\n  };\n\n  Encoding.isOrdinalScale = function(encoding, encType) {\n    return vlfield.isOrdinalScale(encoding.enc(encType), true);\n  };\n\n  Encoding.isDimension = function(encoding, encType) {\n    return vlfield.isDimension(encoding.enc(encType), true);\n  };\n\n  Encoding.isMeasure = function(encoding, encType) {\n    return vlfield.isMeasure(encoding.enc(encType), true);\n  };\n\n  proto.isOrdinalScale = function(encType) {\n    return this.has(encType) && Encoding.isOrdinalScale(this, encType);\n  };\n\n  proto.isDimension = function(encType) {\n    return this.has(encType) && Encoding.isDimension(this, encType);\n  };\n\n  proto.isMeasure = function(encType) {\n    return this.has(encType) && Encoding.isMeasure(this, encType);\n  };\n\n  proto.isAggregate = function() {\n    return vlenc.isAggregate(this._enc);\n  };\n\n  Encoding.isAggregate = function(spec) {\n    return vlenc.isAggregate(spec.enc);\n  };\n\n  Encoding.alwaysNoOcclusion = function(spec) {\n    // FIXME raw OxQ with # of rows = # of O\n    return vlenc.isAggregate(spec.enc);\n  };\n\n  Encoding.isStack = function(spec) {\n    // FIXME update this once we have control for stack ...\n    return (spec.marktype === 'bar' || spec.marktype === 'area') &&\n      spec.enc.color;\n  };\n\n  proto.isStack = function() {\n    // FIXME update this once we have control for stack ...\n    return (this.is('bar') || this.is('area')) && this.has('color');\n  };\n\n  proto.cardinality = function(encType, stats) {\n    return vlfield.cardinality(this.enc(encType), stats, this.config('filterNull'), true);\n  };\n\n  proto.isRaw = function() {\n    return !this.isAggregate();\n  };\n\n  proto.data = function(name) {\n    return this._data[name];\n  };\n\n   // returns whether the encoding has values embedded\n  proto.hasValues = function() {\n    var vals = this.data('values');\n    return vals && vals.length;\n  };\n\n  proto.config = function(name) {\n    return this._config[name];\n  };\n\n  proto.toSpec = function(excludeConfig, excludeData) {\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    // convert type's bitcode to type name\n    for (var e in enc) {\n      enc[e].type = consts.dataTypeNames[enc[e].type];\n    }\n\n    spec = {\n      marktype: this._marktype,\n      enc: enc,\n      filter: this._filter\n    };\n\n    if (!excludeConfig) {\n      spec.config = util.duplicate(this._config);\n    }\n\n    if (!excludeData) {\n      spec.data = util.duplicate(this._data);\n    }\n\n    // remove defaults\n    var defaults = schema.instantiate();\n    return schema.util.subtract(spec, defaults);\n  };\n\n  proto.toShorthand = function() {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + this._marktype +\n      c.delim + vlenc.shorthand(this._enc);\n  };\n\n  Encoding.shorthand = function (spec) {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + spec.marktype +\n      c.delim + vlenc.shorthand(spec.enc);\n  };\n\n  Encoding.fromShorthand = function(shorthand, data, config, theme) {\n    var c = consts.shorthand,\n        split = shorthand.split(c.delim),\n        marktype = split.shift().split(c.assign)[1].trim(),\n        enc = vlenc.fromShorthand(split, true);\n\n    return new Encoding(marktype, enc, data, config, null, theme);\n  };\n\n  Encoding.specFromShorthand = function(shorthand, data, config, excludeConfig) {\n    return Encoding.fromShorthand(shorthand, data, config).toSpec(excludeConfig);\n  };\n\n  Encoding.fromSpec = function(spec, theme) {\n    var enc = util.duplicate(spec.enc || {});\n\n    //convert type from string to bitcode (e.g, O=1)\n    for (var e in enc) {\n      enc[e].type = consts.dataTypes[enc[e].type];\n    }\n\n    return new Encoding(spec.marktype, enc, spec.data, spec.config, spec.filter, theme);\n  };\n\n  Encoding.transpose = function(spec) {\n    var oldenc = spec.enc,\n      enc = util.duplicate(spec.enc);\n    enc.x = oldenc.y;\n    enc.y = oldenc.x;\n    enc.row = oldenc.col;\n    enc.col = oldenc.row;\n    spec.enc = enc;\n    return spec;\n  };\n\n  Encoding.toggleSort = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.toggleSort = spec.config.toggleSort === 'Q' ? 'O' :'Q';\n    return spec;\n  };\n\n\n  Encoding.toggleSort.direction = function(spec, useTypeCode) {\n    if (!Encoding.toggleSort.support(spec, useTypeCode)) { return; }\n    var enc = spec.enc;\n    return enc.x.type === 'O' ? 'x' :  'y';\n  };\n\n  Encoding.toggleSort.mode = function(spec) {\n    return spec.config.toggleSort;\n  };\n\n  Encoding.toggleSort.support = function(spec, stats, useTypeCode) {\n    var enc = spec.enc,\n      isType = vlfield.isType.get(useTypeCode);\n\n    if (vlenc.has(enc, ROW) || vlenc.has(enc, COL) ||\n      !vlenc.has(enc, X) || !vlenc.has(enc, Y) ||\n      !Encoding.alwaysNoOcclusion(spec, stats)) {\n      return false;\n    }\n\n    return ( isType(enc.x, O) && vlfield.isMeasure(enc.y, useTypeCode)) ? 'x' :\n      ( isType(enc.y, O) && vlfield.isMeasure(enc.x, useTypeCode)) ? 'y' : false;\n  };\n\n  Encoding.toggleFilterNullO = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.filterNull = spec.config.filterNull || { //FIXME\n      T: true,\n      Q: true\n    };\n    spec.config.filterNull.O = !spec.config.filterNull.O;\n    return spec;\n  };\n\n  Encoding.toggleFilterNullO.support = function(spec, stats) {\n    var fields = vlenc.fields(spec.enc);\n    for (var fieldName in fields) {\n      var fieldList = fields[fieldName];\n      if (fieldList.containsType.O && fieldName in stats && stats[fieldName].nulls > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  return Encoding;\n})();\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util');\n\nmodule.exports = aggregates;\n\nfunction aggregates(spec, encoding, opt) {\n  opt = opt || {};\n\n  var dims = {}, meas = {}, detail = {}, facets = {},\n    data = spec.data[1]; // currently data[0] is raw and data[1] is table\n\n  encoding.forEach(function(field, encType) {\n    if (field.aggr) {\n      if (field.aggr === 'count') {\n        meas.count = {op: 'count', field: '*'};\n      }else {\n        meas[field.aggr + '|'+ field.name] = {\n          op: field.aggr,\n          field: 'data.'+ field.name\n        };\n      }\n    } else {\n      dims[field.name] = encoding.field(encType);\n      if (encType == ROW || encType == COL) {\n        facets[field.name] = dims[field.name];\n      }else if (encType !== X && encType !== Y) {\n        detail[field.name] = dims[field.name];\n      }\n    }\n  });\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0) {\n    if (!data.transform) data.transform = [];\n    data.transform.push({\n      type: 'aggregate',\n      groupby: dims,\n      fields: meas\n    });\n  }\n  return {\n    details: util.vals(detail),\n    dims: dims,\n    facets: util.vals(facets),\n    aggregated: meas.length > 0\n  };\n}\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  getter = util.getter,\n  time = require('./time');\n\nvar axis = module.exports = {};\n\naxis.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    var s = props[x].scale;\n    if (s === X || s === Y) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\naxis.defs = function(names, encoding, layout, stats, opt) {\n  return names.reduce(function(a, name) {\n    a.push(axis.def(name, encoding, layout, stats, opt));\n    return a;\n  }, []);\n};\n\naxis.def = function(name, encoding, layout, stats, opt) {\n  var type = name;\n  var isCol = name == COL, isRow = name == ROW;\n  var rowOffset = axisTitleOffset(encoding, layout, Y) + 20,\n    cellPadding = layout.cellPadding;\n\n\n  if (isCol) type = 'x';\n  if (isRow) type = 'y';\n\n  var def = {\n    type: type,\n    scale: name\n  };\n\n  if (encoding.axis(name).grid) {\n    def.grid = true;\n    def.layer = (isRow || isCol) ? 'front' :  'back';\n\n    if (isCol) {\n      // set grid property -- put the lines on the right the cell\n      setter(def, ['properties', 'grid'], {\n        x: {\n          offset: layout.cellWidth * (1+ cellPadding/2.0),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'col'\n        },\n        y: {\n          value: -layout.cellHeight * (cellPadding/2),\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      });\n    } else if (isRow) {\n      // set grid property -- put the lines on the top\n      setter(def, ['properties', 'grid'], {\n        y: {\n          offset: -layout.cellHeight * (cellPadding/2),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'row'\n        },\n        x: {\n          value: rowOffset\n        },\n        x2: {\n          offset: rowOffset + (layout.cellWidth * 0.05),\n          // default value(s) -- vega doesn't do recursive merge\n          group: \"mark.group.width\",\n          mult: 1\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      });\n    } else {\n      setter(def, ['properties', 'grid'], {\n        stroke: { value: encoding.config('gridColor') },\n        opacity: { value: encoding.config('gridOpacity') }\n      });\n    }\n  }\n\n  if (encoding.axis(name).title) {\n    def = axis_title(def, name, encoding, layout, opt);\n  }\n\n  if (isRow || isCol) {\n    setter(def, ['properties', 'ticks'], {\n      opacity: {value: 0}\n    });\n    setter(def, ['properties', 'majorTicks'], {\n      opacity: {value: 0}\n    });\n    setter(def, ['properties', 'axis'], {\n      opacity: {value: 0}\n    });\n  }\n\n  if (isCol) {\n    def.orient = 'top';\n  }\n\n  if (isRow) {\n    def.offset = rowOffset;\n  }\n\n  if (name == X) {\n    if (encoding.has(Y) && encoding.isOrdinalScale(Y) && encoding.cardinality(Y, stats) > 30) {\n      def.orient = 'top';\n    }\n\n    if (encoding.isDimension(X) || encoding.isType(X, T)) {\n      setter(def, ['properties','labels'], {\n        angle: {value: 270},\n        align: {value: 'right'},\n        baseline: {value: 'middle'}\n      });\n    } else { // Q\n      def.ticks = 5;\n    }\n  }\n\n  def = axis_labels(def, name, encoding, layout, opt);\n\n  return def;\n};\n\nfunction axis_title(def, name, encoding, layout, opt) {\n  // jshint unused:false\n\n  var maxlength = null,\n    fieldTitle = encoding.fieldTitle(name);\n  if (name===X) {\n    maxlength = layout.cellWidth / encoding.config('characterWidth');\n  } else if (name === Y) {\n    maxlength = layout.cellHeight / encoding.config('characterWidth');\n  }\n\n  def.title = maxlength ? util.truncate(fieldTitle, maxlength) : fieldTitle;\n\n  if (name === ROW) {\n    setter(def, ['properties','title'], {\n      angle: {value: 0},\n      align: {value: 'right'},\n      baseline: {value: 'middle'},\n      dy: {value: (-layout.height/2) -20}\n    });\n  }\n\n  def.titleOffset = axisTitleOffset(encoding, layout, name);\n  return def;\n}\n\nfunction axis_labels(def, name, encoding, layout, opt) {\n  // jshint unused:false\n\n  var fn;\n  // add custom label for time type\n  if (encoding.isType(name, T) && (fn = encoding.fn(name)) && (time.hasScale(fn))) {\n    setter(def, ['properties','labels','text','scale'], 'time-'+ fn);\n  }\n\n  var textTemplatePath = ['properties','labels','text','template'];\n  if (encoding.axis(name).format) {\n    def.format = encoding.axis(name).format;\n  } else if (encoding.isType(name, Q)) {\n    setter(def, textTemplatePath, \"{{data | number:'.3s'}}\");\n  } else if (encoding.isType(name, T) && !encoding.fn(name)) {\n    setter(def, textTemplatePath, \"{{data | time:'%Y-%m-%d'}}\");\n  } else if (encoding.isType(name, T) && encoding.fn(name) === 'year') {\n    setter(def, textTemplatePath, \"{{data | number:'d'}}\");\n  } else if (encoding.isType(name, O) && encoding.axis(name).maxLabelLength) {\n    setter(def, textTemplatePath, '{{data | truncate:' + encoding.axis(name).maxLabelLength + '}}');\n  }\n\n  return def;\n}\n\nfunction axisTitleOffset(encoding, layout, name) {\n  var value = encoding.axis(name).titleOffset;\n  if (value) {\n    return value;\n  }\n  switch (name) {\n    case ROW: return 0;\n    case COL: return 35;\n  }\n  return getter(layout, [name, 'axisTitleOffset']);\n}\n","'use strict';\n\nrequire('../globals');\n\nmodule.exports = binning;\n\nfunction binning(spec, encoding, opt) {\n  opt = opt || {};\n\n  if (!spec.transform) spec.transform = [];\n\n  encoding.forEach(function(field, encType) {\n    if (encoding.bin(encType)) {\n      spec.transform.push({\n        type: 'bin',\n        field: 'data.' + field.name,\n        output: 'data.bin_' + field.name,\n        maxbins: encoding.bin(encType).maxbins\n      });\n    }\n  });\n}\n","'use strict';\n\nvar summary = module.exports = require('datalib/src/summary');\n\nrequire('../globals');\n\nmodule.exports = compile;\n\nvar Encoding = require('../Encoding'),\n  axis = compile.axis = require('./axis'),\n  filter = compile.filter = require('./filter'),\n  legend = compile.legend = require('./legend'),\n  marks = compile.marks = require('./marks'),\n  scale = compile.scale = require('./scale');\n\ncompile.aggregate = require('./aggregate');\ncompile.bin = require('./bin');\ncompile.facet = require('./facet');\ncompile.group = require('./group');\ncompile.layout = require('./layout');\ncompile.sort = require('./sort');\ncompile.stack = require('./stack');\ncompile.style = require('./style');\ncompile.subfacet = require('./subfacet');\ncompile.template = require('./template');\ncompile.time = require('./time');\n\nfunction compile(spec, stats, theme) {\n  return compile.encoding(Encoding.fromSpec(spec, theme), stats);\n}\n\ncompile.shorthand = function (shorthand, stats, config, theme) {\n  return compile.encoding(Encoding.fromShorthand(shorthand, config, theme), stats);\n};\n\ncompile.encoding = function (encoding, stats) {\n  // no need to pass stats if you pass in the data\n  if (!stats && encoding.hasValues()) {\n    stats = summary(encoding.data('values')).reduce(function(s, p) {\n      s[p.field] = p;\n      return s;\n    }, {});\n  }\n\n  var layout = compile.layout(encoding, stats),\n    style = compile.style(encoding, stats),\n    spec = compile.template(encoding, layout, stats),\n    group = spec.marks[0],\n    mark = marks[encoding.marktype()],\n    mdefs = marks.def(mark, encoding, layout, style),\n    mdef = mdefs[0];  // TODO: remove this dirty hack by refactoring the whole flow\n\n  filter.addFilters(spec, encoding);\n  var sorting = compile.sort(spec, encoding, stats);\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  for (var i = 0; i < mdefs.length; i++) {\n    group.marks.push(mdefs[i]);\n  }\n\n  compile.bin(spec.data[1], encoding);\n\n  var lineType = marks[encoding.marktype()].line;\n\n  spec = compile.time(spec, encoding);\n\n  // handle subfacets\n  var aggResult = compile.aggregate(spec, encoding),\n    details = aggResult.details,\n    hasDetails = details && details.length > 0,\n    stack = hasDetails && compile.stack(spec, encoding, mdef, aggResult.facets);\n\n  if (hasDetails && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    compile.subfacet(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  //TODO(kanitw): have some config to turn off auto-sort for line (for line chart that encodes temporal information)\n  if (lineType) {\n    var f = (encoding.isMeasure(X) && encoding.isDimension(Y)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    // TODO: why - ?\n    mdef.from.transform = [{type: 'sort', by: '-' + encoding.field(f)}];\n  }\n\n  // Small Multiples\n  if (hasRow || hasCol) {\n    spec = compile.facet(group, encoding, layout, style, sorting, spec, mdef, stack, stats);\n    spec.legends = legend.defs(encoding);\n  } else {\n    group.scales = scale.defs(scale.names(mdef.properties.update), encoding, layout, style, sorting,\n      {stack: stack, stats: stats});\n    group.axes = axis.defs(axis.names(mdef.properties.update), encoding, layout, stats);\n    group.legends = legend.defs(encoding);\n  }\n\n  filter.filterLessThanZero(spec, encoding);\n\n  return spec;\n};\n\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util');\n\nvar axis = require('./axis'),\n  groupdef = require('./group').def,\n  scale = require('./scale');\n\nmodule.exports = faceting;\n\nfunction faceting(group, encoding, layout, style, sorting, spec, mdef, stack, stats) {\n  var enter = group.properties.enter;\n  var facetKeys = [], cellAxes = [], from, axesGrp;\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  enter.fill = {value: encoding.config('cellBackgroundColor')};\n\n  //move \"from\" to cell level and add facet transform\n  group.from = {data: group.marks[0].from.data};\n\n  // Hack, this needs to be refactored\n  for (var i = 0; i < group.marks.length; i++) {\n    var mark = group.marks[i];\n    if (mark.from.transform) {\n      delete mark.from.data; //need to keep transform for subfacetting case\n    } else {\n      delete mark.from;\n    }\n  }\n\n  if (hasRow) {\n    if (!encoding.isDimension(ROW)) {\n      util.error('Row encoding should be ordinal.');\n    }\n    enter.y = {scale: ROW, field: 'keys.' + facetKeys.length};\n    enter.height = {'value': layout.cellHeight}; // HACK\n\n    facetKeys.push(encoding.field(ROW));\n\n    if (hasCol) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.field(COL)]});\n    }\n\n    axesGrp = groupdef('x-axes', {\n        axes: encoding.has(X) ? axis.defs(['x'], encoding, layout, stats) : undefined,\n        x: hasCol ? {scale: COL, field: 'keys.0'} : {value: 0},\n        width: hasCol && {'value': layout.cellWidth}, //HACK?\n        from: from\n      });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['row'], encoding, layout, stats));\n  } else { // doesn't have row\n    if (encoding.has(X)) {\n      //keep x axis in the cell\n      cellAxes.push.apply(cellAxes, axis.defs(['x'], encoding, layout, stats));\n    }\n  }\n\n  if (hasCol) {\n    if (!encoding.isDimension(COL)) {\n      util.error('Col encoding should be ordinal.');\n    }\n    enter.x = {scale: COL, field: 'keys.' + facetKeys.length};\n    enter.width = {'value': layout.cellWidth}; // HACK\n\n    facetKeys.push(encoding.field(COL));\n\n    if (hasRow) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.field(ROW)]});\n    }\n\n    axesGrp = groupdef('y-axes', {\n      axes: encoding.has(Y) ? axis.defs(['y'], encoding, layout, stats) : undefined,\n      y: hasRow && {scale: ROW, field: 'keys.0'},\n      x: hasRow && {value: 0},\n      height: hasRow && {'value': layout.cellHeight}, //HACK?\n      from: from\n    });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['col'], encoding, layout, stats));\n  } else { // doesn't have col\n    if (encoding.has(Y)) {\n      cellAxes.push.apply(cellAxes, axis.defs(['y'], encoding, layout, stats));\n    }\n  }\n\n  // assuming equal cellWidth here\n  // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n  spec.scales = (spec.scales || []).concat(scale.defs(\n    scale.names(enter).concat(scale.names(mdef.properties.update)),\n    encoding,\n    layout,\n    style,\n    sorting,\n    {stack: stack, facet: true, stats: stats}\n  )); // row/col scales + cell scales\n\n  if (cellAxes.length > 0) {\n    group.axes = cellAxes;\n  }\n\n  // add facet transform\n  var trans = (group.from.transform || (group.from.transform = []));\n  trans.unshift({type: 'facet', keys: facetKeys});\n\n  return spec;\n}\n","'use strict';\n\nrequire('../globals');\n\nvar filter = module.exports = {};\n\nvar BINARY = {\n  '>':  true,\n  '>=': true,\n  '=':  true,\n  '!=': true,\n  '<':  true,\n  '<=': true\n};\n\nfilter.addFilters = function(spec, encoding) {\n  var filters = encoding.filter(),\n    data = spec.data[0];  // apply filters to raw data before aggregation\n\n  if (!data.transform)\n    data.transform = [];\n\n  // add custom filters\n  for (var i in filters) {\n    var filter = filters[i];\n\n    var condition = '';\n    var operator = filter.operator;\n    var operands = filter.operands;\n\n    if (BINARY[operator]) {\n      // expects a field and a value\n      if (operator === '=') {\n        operator = '==';\n      }\n\n      var op1 = operands[0];\n      var op2 = operands[1];\n      condition = 'd.data.' + op1 + operator + op2;\n    } else if (operator === 'notNull') {\n      // expects a number of fields\n      for (var j in operands) {\n        condition += 'd.data.' + operands[j] + '!==null';\n        if (j < operands.length - 1) {\n          condition += ' && ';\n        }\n      }\n    } else {\n      console.warn('Unsupported operator: ', operator);\n    }\n\n    data.transform.push({\n      type: 'filter',\n      test: condition\n    });\n  }\n};\n\n// remove less than 0 values if we use log function\nfilter.filterLessThanZero = function(spec, encoding) {\n  encoding.forEach(function(field, encType) {\n    if (encoding.scale(encType).type === 'log') {\n      spec.data[1].transform.push({\n        type: 'filter',\n        test: 'd.' + encoding.field(encType) + '>0'\n      });\n    }\n  });\n};\n\n","'use strict';\n\nmodule.exports = {\n  def: groupdef\n};\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: 'group',\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: 'width'},\n        height: opt.height || {group: 'height'}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter;\n\nmodule.exports = vllayout;\n\nfunction vllayout(encoding, stats) {\n  var layout = box(encoding, stats);\n  layout = offset(encoding, stats, layout);\n  return layout;\n}\n\n/*\n  HACK to set chart size\n  NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  One solution is to update Vega to support auto-sizing\n  In the meantime, auto-padding (mostly) does the trick\n */\nfunction box(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y),\n      marktype = encoding.marktype();\n\n  // FIXME/HACK we need to take filter into account\n  var xCardinality = hasX && encoding.isDimension(X) ? encoding.cardinality(X, stats) : 1,\n    yCardinality = hasY && encoding.isDimension(Y) ? encoding.cardinality(Y, stats) : 1;\n\n  var useSmallBand = xCardinality > encoding.config('largeBandMaxCardinality') ||\n    yCardinality > encoding.config('largeBandMaxCardinality');\n\n  var cellWidth, cellHeight, cellPadding = encoding.config('cellPadding');\n\n  // set cellWidth\n  if (hasX) {\n    if (encoding.isOrdinalScale(X)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellWidth = (xCardinality + encoding.band(X).padding) * encoding.bandSize(X, useSmallBand);\n    } else {\n      cellWidth = hasCol || hasRow ? encoding.enc(COL).width :  encoding.config(\"singleWidth\");\n    }\n  } else {\n    if (marktype === TEXT) {\n      cellWidth = encoding.config('textCellWidth');\n    } else {\n      cellWidth = encoding.bandSize(X);\n    }\n  }\n\n  // set cellHeight\n  if (hasY) {\n    if (encoding.isOrdinalScale(Y)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellHeight = (yCardinality + encoding.band(Y).padding) * encoding.bandSize(Y, useSmallBand);\n    } else {\n      cellHeight = hasCol || hasRow ? encoding.enc(ROW).height :  encoding.config(\"singleHeight\");\n    }\n  } else {\n    cellHeight = encoding.bandSize(Y);\n  }\n\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n\n  var width = cellWidth, height = cellHeight;\n  if (hasCol) {\n    var colCardinality = encoding.cardinality(COL, stats);\n    width = cellWidth * ((1 + cellPadding) * (colCardinality - 1) + 1);\n  }\n  if (hasRow) {\n    var rowCardinality =  encoding.cardinality(ROW, stats);\n    height = cellHeight * ((1 + cellPadding) * (rowCardinality - 1) + 1);\n  }\n\n  return {\n    // width and height of the whole cell\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    cellPadding: cellPadding,\n    // width and height of the chart\n    width: width,\n    height: height,\n    // information about x and y, such as band size\n    x: {useSmallBand: useSmallBand},\n    y: {useSmallBand: useSmallBand}\n  };\n}\n\nfunction getMaxLength(encoding, stats, et) {\n  // FIXME determine constant for Q and T in a nicer way\n  return encoding.isType(et, Q) ? 20 :\n    encoding.isType(et, T) ? 20 :\n    stats[encoding.fieldName(et)].max;\n}\n\nfunction offset(encoding, stats, layout) {\n  [X, Y].forEach(function (x) {\n    var maxLength;\n    if (encoding.isDimension(x) || encoding.isType(x, T)) {\n      maxLength =  getMaxLength(encoding, stats, x);\n    } else if (encoding.aggr(x) === 'count') {\n      //assign default value for count as it won't have stats\n      maxLength =  3;\n    } else if (encoding.isType(x, Q)) {\n      if (x===X) {\n        maxLength = 3;\n      } else { // Y\n        //assume that default formating is always shorter than 7\n        maxLength = Math.min(getMaxLength(encoding, stats, x), 7);\n      }\n    }\n    setter(layout,[x, 'axisTitleOffset'], encoding.config('characterWidth') *  maxLength + 20);\n  });\n  return layout;\n}\n","'use strict';\n\nrequire('../globals');\n\nvar time = require('./time');\n\nvar legend = module.exports = {};\n\nlegend.defs = function(encoding) {\n  var defs = [];\n  // TODO: support alpha\n\n  if (encoding.has(COLOR) && encoding.legend(COLOR)) {\n    defs.push(legend.def(COLOR, encoding, {\n      fill: COLOR,\n      orient: 'right'\n    }));\n  }\n\n  if (encoding.has(SIZE) && encoding.legend(SIZE)) {\n    defs.push(legend.def(SIZE, encoding, {\n      size: SIZE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  if (encoding.has(SHAPE) && encoding.legend(SHAPE)) {\n    if (defs.length === 2) {\n      // TODO: fix this\n      console.error('Vega-lite currently only supports two legends');\n      return defs;\n    }\n    defs.push(legend.def(SHAPE, encoding, {\n      shape: SHAPE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  return defs;\n};\n\nlegend.def = function(name, encoding, props) {\n  var def = props, fn;\n\n  def.title = encoding.fieldTitle(name);\n\n  if (encoding.isType(name, T) && (fn = encoding.fn(name)) &&\n    time.hasScale(fn)) {\n    var properties = def.properties = def.properties || {},\n      labels = properties.labels = properties.labels || {},\n      text = labels.text = labels.text || {};\n\n    text.scale = 'time-'+ fn;\n  }\n\n  return def;\n};\n","'use strict';\n\nrequire('../globals');\n\nvar marks = module.exports = {};\n\nmarks.def = function(mark, encoding, layout, style) {\n  var defs = [];\n\n  // to add a background to text, we need to add it before the text\n  if (encoding.marktype() === TEXT && encoding.has(COLOR)) {\n    var bg = {\n      x: {value: 0},\n      y: {value: 0},\n      x2: {value: layout.cellWidth},\n      y2: {value: layout.cellHeight},\n      fill: {scale: COLOR, field: encoding.field(COLOR)}\n    };\n    defs.push({\n      type: 'rect',\n      from: {data: TABLE},\n      properties: {enter: bg, update: bg}\n    });\n  }\n\n  // add the mark def for the main thing\n  var p = mark.prop(encoding, layout, style);\n  defs.push({\n    type: mark.type,\n    from: {data: TABLE},\n    properties: {enter: p, update: p}\n  });\n\n  return defs;\n};\n\nmarks.bar = {\n  type: 'rect',\n  stack: true,\n  prop: bar_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1}\n};\n\nmarks.line = {\n  type: 'line',\n  line: true,\n  prop: line_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1, detail:1}\n};\n\nmarks.area = {\n  type: 'area',\n  stack: true,\n  line: true,\n  requiredEncoding: ['x', 'y'],\n  prop: area_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1}\n};\n\nmarks.tick = {\n  type: 'rect',\n  prop: tick_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1, detail: 1}\n};\n\nmarks.circle = {\n  type: 'symbol',\n  prop: filled_point_props('circle'),\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1, detail: 1}\n};\n\nmarks.square = {\n  type: 'symbol',\n  prop: filled_point_props('square'),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: 'symbol',\n  prop: point_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1, shape: 1, detail: 1}\n};\n\nmarks.text = {\n  type: 'text',\n  prop: text_props,\n  requiredEncoding: ['text'],\n  supportedEncoding: {row: 1, col: 1, size: 1, color: 1, alpha: 1, text: 1}\n};\n\nfunction bar_props(e, layout, style) {\n  // jshint unused:false\n\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: e.scale(X).type === 'log' ? 1 : 0};\n    }\n  } else if (e.has(X)) { // is ordinal\n    p.xc = {scale: X, field: e.field(X)};\n  } else {\n    // TODO add single bar offset\n    p.xc = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: e.scale(Y).type === 'log' ? 1 : 0};\n  } else if (e.has(Y)) { // is ordinal\n    p.yc = {scale: Y, field: e.field(Y)};\n  } else {\n    // TODO add single bar offset\n    p.yc = {group: 'height'};\n  }\n\n  // width\n  if (!e.has(X) || e.isOrdinalScale(X)) { // no X or X is ordinal\n    if (e.has(SIZE)) {\n      p.width = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      p.width = {\n        value: e.bandSize(X, layout.x.useSmallBand),\n        offset: -1\n      };\n    }\n  } else { // X is Quant or Time Scale\n    p.width = {value: 2};\n  }\n\n  // height\n  if (!e.has(Y) || e.isOrdinalScale(Y)) { // no Y or Y is ordinal\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      p.height = {\n        value: e.bandSize(Y, layout.y.useSmallBand),\n        offset: -1\n      };\n    }\n  } else { // Y is Quant or Time Scale\n    p.height = {value: 2};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction point_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.value(SIZE)};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.field(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.value(SHAPE)};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else if (!e.has(COLOR)) {\n    p.opacity = {value: style.opacity};\n  }\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction line_props(e,layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction area_props(e, layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: 'horizontal'};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction tick_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(X)) {\n      p.x.offset = -e.bandSize(X, layout.x.useSmallBand) / 3;\n    }\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    if (e.isDimension(Y)) {\n      p.y.offset = -e.bandSize(Y, layout.y.useSmallBand) / 3;\n    }\n  } else if (!e.has(Y)) {\n    p.y = {value: 0};\n  }\n\n  // width\n  if (!e.has(X) || e.isDimension(X)) {\n    p.width = {value: e.bandSize(X, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.width = {value: 1};\n  }\n\n  // height\n  if (!e.has(Y) || e.isDimension(Y)) {\n    p.height = {value: e.bandSize(Y, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.height = {value: 1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else if (!e.has(COLOR)) {\n    p.opacity = {value: style.opacity};\n  }\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, layout, style) {\n    var p = {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.field(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.field(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.field(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.value(SIZE)};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.field(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n\n    // alpha\n    if (e.has(ALPHA)) {\n      p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n    } else if (e.value(ALPHA) !== undefined) {\n      p.opacity = {value: e.value(ALPHA)};\n    } else if (!e.has(COLOR)) {\n      p.opacity = {value: style.opacity};\n    }\n\n    return p;\n  };\n}\n\nfunction text_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    if (e.has(TEXT) && e.isType(TEXT, Q)) {\n      p.x = {value: layout.cellWidth-5};\n    } else {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.fontSize = {value: e.font('size')};\n  }\n\n  // fill\n  // color should be set to background\n  p.fill = {value: 'black'};\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else {\n    p.opacity = {value: style.opacity};\n  }\n\n  // text\n  if (e.has(TEXT)) {\n    if (e.isType(TEXT, Q)) {\n      p.text = {template: \"{{\" + e.field(TEXT) + \" | number:'.3s'}}\"};\n      p.align = {value: 'right'};\n    } else {\n      p.text = {field: e.field(TEXT)};\n    }\n  } else {\n    p.text = {value: 'Abc'};\n  }\n\n  p.font = {value: e.font('family')};\n  p.fontWeight = {value: e.font('weight')};\n  p.fontStyle = {value: e.font('style')};\n  p.baseline = {value: e.text('baseline')};\n\n  return p;\n}\n","'use strict';\nrequire('../globals');\nvar util = require('../util'),\n  time = require('./time');\n\nvar scale = module.exports = {};\n\nscale.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\nscale.defs = function(names, encoding, layout, style, sorting, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale.type(name, encoding),\n      domain: scale_domain(name, encoding, sorting, opt)\n    };\n    if (s.type === 'ordinal' && !encoding.bin(name) && encoding.sort(name).length === 0) {\n      s.sort = true;\n    }\n\n    scale_range(s, encoding, layout, style, opt);\n\n    return (a.push(s), a);\n  }, []);\n};\n\nscale.type = function(name, encoding) {\n\n  switch (encoding.type(name)) {\n    case O: return 'ordinal';\n    case T:\n      var fn = encoding.fn(name);\n      return (fn && time.scale.type(fn, name)) || 'time';\n    case Q:\n      if (encoding.bin(name)) {\n        return name === COLOR ? 'linear' : 'ordinal';\n      }\n      return encoding.scale(name).type;\n  }\n};\n\nfunction scale_domain(name, encoding, sorting, opt) {\n  if (encoding.isType(name, T)) {\n    var range = time.scale.domain(encoding.fn(name), name);\n    if(range) return range;\n  }\n\n  if (encoding.bin(name)) {\n    // TODO: add includeEmptyConfig here\n    if (opt.stats) {\n      var bins = util.getbins(opt.stats[encoding.fieldName(name)], encoding.bin(name).maxbins);\n      var domain = util.range(bins.start, bins.stop, bins.step);\n      return name === Y ? domain.reverse() : domain;\n    }\n  }\n\n  return name == opt.stack ?\n    {\n      data: STACKED,\n      field: 'data.' + (opt.facet ? 'max_' : '') + 'sum_' + encoding.field(name, true)\n    } :\n    {data: sorting.getDataset(name), field: encoding.field(name)};\n}\n\nfunction scale_range(s, encoding, layout, style, opt) {\n  // jshint unused:false\n  var spec = encoding.scale(s.name);\n  switch (s.name) {\n    case X:\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(X, layout.x.useSmallBand);\n      } else {\n        s.range = layout.cellWidth ? [0, layout.cellWidth] : 'width';\n\n        if (encoding.isType(s.name,T) && encoding.fn(s.name) === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n      s.round = true;\n      if (s.type === 'time') {\n        s.nice = encoding.fn(s.name);\n      }else {\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(Y, layout.y.useSmallBand);\n      } else {\n        s.range = layout.cellHeight ? [layout.cellHeight, 0] : 'height';\n\n        if (encoding.isType(s.name,T) && encoding.fn(s.name) === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n\n      s.round = true;\n\n      if (s.type === 'time') {\n        s.nice = encoding.fn(s.name) || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case ROW: // support only ordinal\n      s.bandWidth = layout.cellHeight;\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL: // support only ordinal\n      s.bandWidth = layout.cellWidth;\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is('bar')) {\n        // FIXME this is definitely incorrect\n        // but let's fix it later since bar size is a bad encoding anyway\n        s.range = [3, Math.max(encoding.bandSize(X), encoding.bandSize(Y))];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else { //point\n        var bandSize = Math.min(encoding.bandSize(X), encoding.bandSize(Y)) - 1;\n        s.range = [10, 0.8 * bandSize*bandSize];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = 'shapes';\n      break;\n    case COLOR:\n      var range = encoding.scale(COLOR).range;\n      if (range === undefined) {\n        if (s.type === 'ordinal') {\n          // FIXME\n          range = style.colorRange;\n        } else {\n          range = ['#A9DB9F', '#0D5C21'];\n          s.zero = false;\n        }\n      }\n      s.range = range;\n      break;\n    case ALPHA:\n      s.range = [0.2, 1.0];\n      break;\n    default:\n      throw new Error('Unknown encoding name: '+ s.name);\n  }\n\n  switch (s.name) {\n    case ROW:\n    case COL:\n      s.padding = encoding.config('cellPadding');\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (s.type === 'ordinal') { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.band(s.name).padding;\n      }\n  }\n}\n","'use strict';\n\nrequire('../globals');\n\nmodule.exports = addSortTransforms;\n\n// adds new transforms that produce sorted fields\nfunction addSortTransforms(spec, encoding, stats, opt) {\n  // jshint unused:false\n\n  var datasetMapping = {};\n  var counter = 0;\n\n  encoding.forEach(function(field, encType) {\n    var sortBy = encoding.sort(encType, stats);\n    if (sortBy.length > 0) {\n      var fields = sortBy.map(function(d) {\n        return {\n          op: d.aggr,\n          field: 'data.' + d.name\n        };\n      });\n\n      var byClause = sortBy.map(function(d) {\n        var reverse = (d.reverse ? '-' : '');\n        return reverse + 'data.' + (d.aggr==='count' ? 'count' : (d.aggr + '_' + d.name));\n      });\n\n      var dataName = 'sorted' + counter++;\n\n      var transforms = [\n        {\n          type: 'aggregate',\n          groupby: ['data.' + field.name],\n          fields: fields\n        },\n        {\n          type: 'sort',\n          by: byClause\n        }\n      ];\n\n      spec.data.push({\n        name: dataName,\n        source: RAW,\n        transform: transforms\n      });\n\n      datasetMapping[encType] = dataName;\n    }\n  });\n\n  return {\n    spec: spec,\n    getDataset: function(encType) {\n      var data = datasetMapping[encType];\n      if (!data) {\n        return TABLE;\n      }\n      return data;\n    }\n  };\n}\n","\"use strict\";\n\nrequire('../globals');\n\nvar  marks = require('./marks');\n\nmodule.exports = stacking;\n\nfunction stacking(spec, encoding, mdef, facets) {\n  if (!marks[encoding.marktype()].stack) return false;\n\n  // TODO: add || encoding.has(LOD) here once LOD is implemented\n  if (!encoding.has(COLOR)) return false;\n\n  var dim=null, val=null, idx =null,\n    isXMeasure = encoding.isMeasure(X),\n    isYMeasure = encoding.isMeasure(Y);\n\n  if (isXMeasure && !isYMeasure) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  } else if (isYMeasure && !isXMeasure) {\n    dim = X;\n    val = Y;\n    idx = 1;\n  } else {\n    return null; // no stack encoding\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: TABLE,\n    transform: [{\n      type: 'aggregate',\n      groupby: [encoding.field(dim)].concat(facets), // dim and other facets\n      fields: [{op: 'sum', field: encoding.field(val)}] // TODO check if field with aggr is correct?\n    }]\n  };\n\n  if (facets && facets.length > 0) {\n    stacked.transform.push({ //calculate max for each facet\n      type: 'aggregate',\n      groupby: facets,\n      fields: [{op: 'max', field: 'data.sum_' + encoding.field(val, true)}]\n    });\n  }\n\n  spec.data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: 'stack',\n    point: encoding.field(dim),\n    height: encoding.field(val),\n    output: {y1: val, y0: val + '2'}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val + '2'] = mdef.properties.enter[val + '2'] = {scale: val, field: val + '2'};\n\n  return val; //return stack encoding\n}\n","'use strict';\n\nrequire('../globals');\n\nvar vlfield = require('../field');\n\nmodule.exports = function(encoding, stats) {\n  return {\n    opacity: estimateOpacity(encoding, stats),\n    colorRange: colorRange(encoding, stats)\n  };\n};\n\nfunction colorRange(encoding, stats){\n  if (encoding.has(COLOR) && encoding.isDimension(COLOR)) {\n    var cardinality = encoding.cardinality(COLOR, stats);\n    if (cardinality <= 10) {\n      return \"category10\";\n    } else {\n      return \"category20\";\n    }\n    // TODO can vega interpolate range for ordinal scale?\n  }\n  return null;\n}\n\nfunction estimateOpacity(encoding,stats) {\n  if (!stats) {\n    return 1;\n  }\n\n  var numPoints = 0;\n\n  if (encoding.isAggregate()) { // aggregate plot\n    numPoints = 1;\n\n    //  get number of points in each \"cell\"\n    //  by calculating product of cardinality\n    //  for each non faceting and non-ordinal X / Y fields\n    //  note that ordinal x,y are not include since we can\n    //  consider that ordinal x are subdividing the cell into subcells anyway\n    encoding.forEach(function(field, encType) {\n\n      if (encType !== ROW && encType !== COL &&\n          !((encType === X || encType === Y) &&\n          vlfield.isOrdinalScale(field, true))\n        ) {\n        numPoints *= encoding.cardinality(encType, stats);\n      }\n    });\n\n  } else { // raw plot\n    numPoints = stats.count;\n\n    // small multiples divide number of points\n    var numMultiples = 1;\n    if (encoding.has(ROW)) {\n      numMultiples *= encoding.cardinality(ROW, stats);\n    }\n    if (encoding.has(COL)) {\n      numMultiples *= encoding.cardinality(COL, stats);\n    }\n    numPoints /= numMultiples;\n  }\n\n  var opacity = 0;\n  if (numPoints < 20) {\n    opacity = 1;\n  } else if (numPoints < 200) {\n    opacity = 0.7;\n  } else if (numPoints < 1000 || encoding.is('tick')) {\n    opacity = 0.6;\n  } else {\n    opacity = 0.3;\n  }\n\n  return opacity;\n}\n\n","'use strict';\n\nrequire('../globals');\n\nvar groupdef = require('./group').def;\n\nmodule.exports = subfaceting;\n\nfunction subfaceting(group, mdef, details, stack, encoding) {\n  var m = group.marks,\n    g = groupdef('subfacet', {marks: m});\n\n  group.marks = [g];\n  g.from = mdef.from;\n  delete mdef.from;\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: 'facet', keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: 'sort', by: encoding.field(COLOR)});\n  }\n}\n","'use strict';\n\nrequire('../globals');\n\nvar groupdef = require('./group').def,\n  vlfield = require('../field');\n\nmodule.exports = template;\n\nfunction template(encoding, layout, stats) {\n  // jshint unused:false\n\n  var data = {name: RAW, format: {}},\n    table = {name: TABLE, source: RAW},\n    dataUrl = encoding.data('url'),\n    dataType = encoding.data('formatType'),\n    values = encoding.data('values');\n\n  if (encoding.hasValues()) {\n    data.values = values;\n  } else {\n    data.url = dataUrl;\n    data.format.type = dataType;\n  }\n\n  encoding.forEach(function(field, encType) {\n    var name;\n    if (field.type == T) {\n      data.format.parse = data.format.parse || {};\n      data.format.parse[field.name] = 'date';\n    } else if (field.type == Q) {\n      data.format.parse = data.format.parse || {};\n      if (vlfield.isCount(field)) {\n        name = 'count';\n      } else {\n        name = field.name;\n      }\n      data.format.parse[name] = 'number';\n    }\n  });\n\n  return {\n    width: layout.width,\n    height: layout.height,\n    padding: 'auto',\n    data: [data, table],\n    marks: [groupdef('cell', {\n      width: layout.cellWidth ? {value: layout.cellWidth} : undefined,\n      height: layout.cellHeight ? {value: layout.cellHeight} : undefined\n    })]\n  };\n}\n","'use strict';\n\nvar util = require('../util');\n\nmodule.exports = time;\n\nfunction time(spec, encoding, opt) {\n  // jshint unused:false\n  var timeFields = {}, timeFn = {};\n\n  // find unique formula transformation and bin function\n  encoding.forEach(function(field, encType) {\n    if (field.type === T && field.fn) {\n      timeFields[encoding.field(encType)] = {\n        field: field,\n        encType: encType\n      };\n      timeFn[field.fn] = true;\n    }\n  });\n\n  // add formula transform\n  var data = spec.data[1],\n    transform = data.transform = data.transform || [];\n\n  for (var f in timeFields) {\n    var tf = timeFields[f];\n    time.transform(transform, encoding, tf.encType, tf.field);\n  }\n\n  // add scales\n  var scales = spec.scales = spec.scales || [];\n  for (var fn in timeFn) {\n    time.scale(scales, fn, encoding);\n  }\n  return spec;\n}\n\ntime.cardinality = function(field, stats, filterNull, type) {\n  var fn = field.fn;\n  switch (fn) {\n    case 'seconds': return 60;\n    case 'minutes': return 60;\n    case 'hours': return 24;\n    case 'day': return 7;\n    case 'date': return 31;\n    case 'month': return 12;\n    case 'year':\n      var stat = stats[field.name],\n        yearstat = stats['year_'+field.name];\n\n      if (!yearstat) { return null; }\n\n      return yearstat.distinct -\n        (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n  }\n\n  return null;\n};\n\nfunction fieldFn(func, field) {\n  return 'utc' + func + '(d.data.'+ field.name +')';\n}\n\n/**\n * @return {String} date binning formula of the given field\n */\ntime.formula = function(field) {\n  return fieldFn(field.fn, field);\n};\n\n/** add formula transforms to data */\ntime.transform = function(transform, encoding, encType, field) {\n  transform.push({\n    type: 'formula',\n    field: encoding.field(encType),\n    expr: time.formula(field)\n  });\n};\n\n/** append custom time scales for axis label */\ntime.scale = function(scales, fn, encoding) {\n  var labelLength = encoding.config('timeScaleLabelLength');\n  // TODO add option for shorter scale / custom range\n  switch (fn) {\n    case 'day':\n      scales.push({\n        name: 'time-'+fn,\n        type: 'ordinal',\n        domain: util.range(0, 7),\n        range: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].map(\n          function(s) { return s.substr(0, labelLength);}\n        )\n      });\n      break;\n    case 'month':\n      scales.push({\n        name: 'time-'+fn,\n        type: 'ordinal',\n        domain: util.range(0, 12),\n        range: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'].map(\n            function(s) { return s.substr(0, labelLength);}\n          )\n      });\n      break;\n  }\n};\n\ntime.isOrdinalFn = function(fn) {\n  switch (fn) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'day':\n    case 'date':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\ntime.scale.type = function(fn, name) {\n  if (name === COLOR) {\n    return 'linear'; // this has order\n  }\n\n  return time.isOrdinalFn(fn) || name === COL || name === ROW ? 'ordinal' : 'linear';\n};\n\ntime.scale.domain = function(fn, name) {\n  var isColor = name === COLOR;\n  switch (fn) {\n    case 'seconds':\n    case 'minutes': return isColor ? [0,59] : util.range(0, 60);\n    case 'hours': return isColor ? [0,23] : util.range(0, 24);\n    case 'day': return isColor ? [0,6] : util.range(0, 7);\n    case 'date': return isColor ? [1,31] : util.range(1, 32);\n    case 'month': return isColor ? [0,11] : util.range(0, 12);\n  }\n  return null;\n};\n\n/** whether a particular time function has custom scale for labels implemented in time.scale */\ntime.hasScale = function(fn) {\n  switch (fn) {\n    case 'day':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\n\n","'use strict';\n\nrequire('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, ALPHA, TEXT, DETAIL];\n\nconsts.dataTypes = {'O': O, 'Q': Q, 'T': T};\n\nconsts.dataTypeNames = ['O', 'Q', 'T'].reduce(function(r, x) {\n  r[consts.dataTypes[x]] = x;\n  return r;\n},{});\n\nconsts.shorthand = {\n  delim:  '|',\n  assign: '=',\n  type:   ',',\n  func:   '_'\n};\n","'use strict';\n\nvar vldata = module.exports = {};\n\n/** Mapping from datalib's inferred type to Vega-lite's type */\nvldata.types = {\n  'boolean': 'O',\n  'number': 'Q',\n  'integer': 'Q',\n  'date': 'T',\n  'string': 'O'\n};\n\n","// utility for enc\n\n'use strict';\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  vlfield = require('./field'),\n  util = require('./util'),\n  schema = require('./schema/schema'),\n  encTypes = schema.encTypes;\n\nvar vlenc = module.exports = {};\n\nvlenc.countRetinal = function(enc) {\n  var count = 0;\n  if (enc.color) count++;\n  if (enc.alpha) count++;\n  if (enc.size) count++;\n  if (enc.shape) count++;\n  return count;\n};\n\nvlenc.has = function(enc, encType) {\n  var fieldDef = enc && enc[encType];\n  return fieldDef && fieldDef.name;\n};\n\nvlenc.isAggregate = function(enc) {\n  for (var k in enc) {\n    if (vlenc.has(enc, k) && enc[k].aggr) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvlenc.forEach = function(enc, f) {\n  var i = 0;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      f(enc[k], k, i++);\n    }\n  });\n};\n\nvlenc.map = function(enc, f) {\n  var arr = [];\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      arr.push(f(enc[k], k, enc));\n    }\n  });\n  return arr;\n};\n\nvlenc.reduce = function(enc, f, init) {\n  var r = init;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      r = f(r, enc[k], k,  enc);\n    }\n  });\n  return r;\n};\n\n/*\n * return key-value pairs of field name and list of fields of that field name\n */\nvlenc.fields = function(enc) {\n  return vlenc.reduce(enc, function (m, field) {\n    var fieldList = m[field.name] = m[field.name] || [],\n      containsType = fieldList.containsType = fieldList.containsType || {};\n\n    if (fieldList.indexOf(field) === -1) {\n      fieldList.push(field);\n      // augment the array with containsType.Q / O / T\n      containsType[field.type] = true;\n    }\n    return m;\n  }, {});\n};\n\nvlenc.shorthand = function(enc) {\n  return vlenc.map(enc, function(field, et) {\n    return et + c.assign + vlfield.shorthand(field);\n  }).join(c.delim);\n};\n\nvlenc.fromShorthand = function(shorthand, convertType) {\n  var enc = util.isArray(shorthand) ? shorthand : shorthand.split(c.delim);\n  return enc.reduce(function(m, e) {\n    var split = e.split(c.assign),\n        enctype = split[0].trim(),\n        field = split[1];\n\n    m[enctype] = vlfield.fromShorthand(field, convertType);\n    return m;\n  }, {});\n};","'use strict';\n\n// utility for field\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compile/time'),\n  util = require('./util'),\n  schema = require('./schema/schema');\n\nvar vlfield = module.exports = {};\n\nvlfield.shorthand = function(f) {\n  var c = consts.shorthand;\n  return (f.aggr ? f.aggr + c.func : '') +\n    (f.fn ? f.fn + c.func : '') +\n    (f.bin ? 'bin' + c.func : '') +\n    (f.name || '') + c.type +\n    (consts.dataTypeNames[f.type] || f.type);\n};\n\nvlfield.shorthands = function(fields, delim) {\n  delim = delim || c.delim;\n  return fields.map(vlfield.shorthand).join(delim);\n};\n\nvlfield.fromShorthand = function(shorthand, convertType) {\n  var split = shorthand.split(c.type), i;\n  var o = {\n    name: split[0].trim(),\n    type: convertType ? consts.dataTypes[split[1].trim()] : split[1].trim()\n  };\n\n  // check aggregate type\n  for (i in schema.aggr.enum) {\n    var a = schema.aggr.enum[i];\n    if (o.name.indexOf(a + '_') === 0) {\n      o.name = o.name.substr(a.length + 1);\n      if (a == 'count' && o.name.length === 0) o.name = '*';\n      o.aggr = a;\n      break;\n    }\n  }\n\n  // check time fn\n  for (i in schema.timefns) {\n    var f = schema.timefns[i];\n    if (o.name && o.name.indexOf(f + '_') === 0) {\n      o.name = o.name.substr(o.length + 1);\n      o.fn = f;\n      break;\n    }\n  }\n\n  // check bin\n  if (o.name && o.name.indexOf('bin_') === 0) {\n    o.name = o.name.substr(4);\n    o.bin = true;\n  }\n\n  return o;\n};\n\nvar typeOrder = {\n  O: 0,\n  G: 1,\n  T: 2,\n  Q: 3\n};\n\nvlfield.order = {};\n\nvlfield.order.type = function(field) {\n  if (field.aggr==='count') return 4;\n  return typeOrder[field.type];\n};\n\nvlfield.order.typeThenName = function(field) {\n  return vlfield.order.type(field) + '_' + field.name.toLowerCase();\n};\n\nvlfield.order.original = function() {\n  return 0; // no swap will occur\n};\n\nvlfield.order.name = function(field) {\n  return field.name;\n};\n\nvlfield.order.typeThenCardinality = function(field, stats){\n  return stats[field.name].distinct;\n};\n\n// FIXME refactor\nvlfield.isType = function (fieldDef, type) {\n  return (fieldDef.type & type) > 0;\n};\n\nvlfield.isType.byCode = vlfield.isType;\n\nvlfield.isType.byName = function (field, type) {\n  return field.type === consts.dataTypeNames[type];\n};\n\n\nfunction getIsType(useTypeCode) {\n  return useTypeCode ? vlfield.isType.byCode : vlfield.isType.byName;\n}\n\nvlfield.isType.get = getIsType; //FIXME\n\n/*\n * Most fields that use ordinal scale are dimensions.\n * However, YEAR(T), YEARMONTH(T) use time scale, not ordinal but are dimensions too.\n */\nvlfield.isOrdinalScale = function(field, useTypeCode /*optional*/) {\n  var isType = getIsType(useTypeCode);\n  return  isType(field, O) || field.bin ||\n    ( isType(field, T) && field.fn && time.isOrdinalFn(field.fn) );\n};\n\nfunction isDimension(field, useTypeCode /*optional*/) {\n  var isType = getIsType(useTypeCode);\n  return  isType(field, O) || !!field.bin ||\n    ( isType(field, T) && !!field.fn );\n}\n\n/**\n * For encoding, use encoding.isDimension() to avoid confusion.\n * Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.isDimension = function(field, useTypeCode /*optional*/) {\n  return field && isDimension(field, useTypeCode);\n};\n\nvlfield.isMeasure = function(field, useTypeCode) {\n  return field && !isDimension(field, useTypeCode);\n};\n\nvlfield.role = function(field) {\n  return isDimension(field) ? 'dimension' : 'measure';\n};\n\nvlfield.count = function() {\n  return {name:'*', aggr: 'count', type:'Q', displayName: vlfield.count.displayName};\n};\n\nvlfield.count.displayName = 'Number of Records';\n\nvlfield.isCount = function(field) {\n  return field.aggr === 'count';\n};\n\n/**\n * For encoding, use encoding.cardinality() to avoid confusion.  Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.cardinality = function(field, stats, filterNull, useTypeCode) {\n  // FIXME need to take filter into account\n\n  var stat = stats[field.name];\n  var isType = getIsType(useTypeCode),\n    type = useTypeCode ? consts.dataTypeNames[field.type] : field.type;\n\n  filterNull = filterNull || {};\n\n  if (field.bin) {\n    var bins = util.getbins(stat, field.bin.maxbins || schema.MAXBINS_DEFAULT);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  if (isType(field, T)) {\n    var cardinality = time.cardinality(field, stats, filterNull, type);\n    if(cardinality !== null) return cardinality;\n    //otherwise use calculation below\n  }\n  if (field.aggr) {\n    return 1;\n  }\n\n  // remove null\n  return stat.distinct -\n    (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n};\n","'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.TABLE = 'table';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.ALPHA = 'alpha';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.O = 1;\ng.Q = 2;\ng.T = 4;\n","// Package of defining Vega-lite Specification's json schema\n\"use strict\";\n\nvar schema = module.exports = {},\n  util = require('../util');\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: 'string',\n  enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\n};\n\nschema.aggr = {\n  type: 'string',\n  enum: ['avg', 'sum', 'min', 'max', 'count'],\n  supportedEnums: {\n    Q: ['avg', 'sum', 'min', 'max', 'count'],\n    O: [],\n    T: ['avg', 'min', 'max'],\n    '': ['count']\n  },\n  supportedTypes: {'Q': true, 'O': true, 'T': true, '': true}\n};\nschema.band = {\n  type: 'object',\n  properties: {\n    size: {\n      type: 'integer',\n      minimum: 0\n    },\n    padding: {\n      type: 'integer',\n      minimum: 0,\n      default: 1\n    }\n  }\n};\n\nschema.getSupportedRole = function(encType) {\n  return schema.schema.properties.enc.properties[encType].supportedRole;\n};\n\nschema.timefns = ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'];\n\nschema.defaultTimeFn = 'month';\n\nschema.fn = {\n  type: 'string',\n  enum: schema.timefns,\n  supportedTypes: {'T': true}\n};\n\n//TODO(kanitw): add other type of function here\n\nschema.scale_type = {\n  type: 'string',\n  enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\n  default: 'linear',\n  supportedTypes: {'Q': true}\n};\n\nschema.field = {\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string'\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nschema.MAXBINS_DEFAULT = 15;\n\nvar bin = {\n  type: ['boolean', 'object'],\n  default: false,\n  properties: {\n    maxbins: {\n      type: 'integer',\n      default: schema.MAXBINS_DEFAULT,\n      minimum: 2\n    }\n  },\n  supportedTypes: {'Q': true} // TODO: add 'O' after finishing #81\n};\n\nvar typicalField = merge(clone(schema.field), {\n  type: 'object',\n  properties: {\n    type: {\n      type: 'string',\n      enum: ['O', 'Q', 'T']\n    },\n    aggr: schema.aggr,\n    fn: schema.fn,\n    bin: bin,\n    scale: {\n      type: 'object',\n      properties: {\n        type: schema.scale_type,\n        reverse: {\n          type: 'boolean',\n          default: false,\n          supportedTypes: {'Q': true, 'T': true}\n        },\n        zero: {\n          type: 'boolean',\n          description: 'Include zero',\n          default: true,\n          supportedTypes: {'Q': true, 'T': true}\n        },\n        nice: {\n          type: 'string',\n          enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\n          supportedTypes: {'T': true}\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: 'object',\n  supportedRole: {\n    dimension: true\n  },\n  properties: {\n    type: {\n      type: 'string',\n      enum: ['O','Q', 'T'] // ordinal-only field supports Q when bin is applied and T when fn is applied.\n    },\n    fn: schema.fn,\n    bin: bin,\n    aggr: {\n      type: 'string',\n      enum: ['count'],\n      supportedTypes: {'O': true}\n    }\n  }\n});\n\nvar axisMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true},\n  properties: {\n    axis: {\n      type: 'object',\n      properties: {\n        grid: {\n          type: 'boolean',\n          default: true,\n          description: 'A flag indicate if gridlines should be created in addition to ticks.'\n        },\n        title: {\n          type: 'boolean',\n          default: true,\n          description: 'A title for the axis.'\n        },\n        titleOffset: {\n          type: 'integer',\n          default: undefined,  // auto\n          description: 'A title offset value for the axis.'\n        },\n        format: {\n          type: 'string',\n          default: undefined,  // auto\n          description: 'The formatting pattern for axis labels.'\n        },\n        maxLabelLength: {\n          type: 'integer',\n          default: 25,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar sortMixin = {\n  type: 'object',\n  properties: {\n    sort: {\n      type: 'array',\n      default: [],\n      items: {\n        type: 'object',\n        supportedTypes: {'O': true},\n        required: ['name', 'aggr'],\n        name: {\n          type: 'string'\n        },\n        aggr: {\n          type: 'string',\n          enum: ['avg', 'sum', 'min', 'max', 'count']\n        },\n        reverse: {\n          type: 'boolean',\n          default: false\n        }\n      }\n    }\n  }\n};\n\nvar bandMixin = {\n  type: 'object',\n  properties: {\n    band: schema.band\n  }\n};\n\nvar legendMixin = {\n  type: 'object',\n  properties: {\n    legend: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nvar textMixin = {\n  type: 'object',\n  supportedMarktypes: {'text': true},\n  properties: {\n    text: {\n      type: 'object',\n      properties: {\n        align: {\n          type: 'string',\n          default: 'left'\n        },\n        baseline: {\n          type: 'string',\n          default: 'middle'\n        },\n        margin: {\n          type: 'integer',\n          default: 4,\n          minimum: 0\n        }\n      }\n    },\n    font: {\n      type: 'object',\n      properties: {\n        weight: {\n          type: 'string',\n          enum: ['normal', 'bold'],\n          default: 'normal'\n        },\n        size: {\n          type: 'integer',\n          default: 10,\n          minimum: 0\n        },\n        family: {\n          type: 'string',\n          default: 'Helvetica Neue'\n        },\n        style: {\n          type: 'string',\n          default: 'normal',\n          enum: ['normal', 'italic']\n        }\n      }\n    }\n  }\n};\n\nvar sizeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, bar: true, circle: true, square: true, text: true},\n  properties: {\n    value: {\n      type: 'integer',\n      default: 30,\n      minimum: 0\n    }\n  }\n};\n\nvar colorMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'string',\n      role: 'color',\n      default: 'steelblue'\n    },\n    scale: {\n      type: 'object',\n      properties: {\n        range: {\n          type: ['string', 'array']\n        }\n      }\n    }\n  }\n};\n\nvar alphaMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'number',\n      default: undefined,  // auto\n      minimum: 0,\n      maximum: 1\n    }\n  }\n};\n\nvar shapeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, circle: true, square: true},\n  properties: {\n    value: {\n      type: 'string',\n      enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\n      default: 'circle'\n    }\n  }\n};\n\nvar detailMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, line: true, circle: true, square: true}\n};\n\nvar rowMixin = {\n  properties: {\n    height: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    grid: {\n      type: 'boolean',\n      default: true,\n      description: 'A flag indicate if gridlines should be created in addition to ticks.'\n    },\n  }\n};\n\nvar colMixin = {\n  properties: {\n    width: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    axis: {\n      properties: {\n        maxLabelLength: {\n          type: 'integer',\n          default: 12,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar facetMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, text: true},\n  properties: {\n    padding: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.1\n    }\n  }\n};\n\nvar requiredNameType = {\n  required: ['name', 'type']\n};\n\nvar multiRoleField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: true\n  }\n});\n\nvar quantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: 'ordinal-only' // using alpha / size to encoding category lead to order interpretation\n  }\n});\n\nvar onlyQuantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true\n  }\n});\n\nvar x = merge(clone(multiRoleField), axisMixin, bandMixin, requiredNameType, sortMixin);\nvar y = clone(x);\n\nvar facet = merge(clone(onlyOrdinalField), requiredNameType, facetMixin, sortMixin);\nvar row = merge(clone(facet), axisMixin, rowMixin);\nvar col = merge(clone(facet), axisMixin, colMixin);\n\nvar size = merge(clone(quantitativeField), legendMixin, sizeMixin, sortMixin);\nvar color = merge(clone(multiRoleField), legendMixin, colorMixin, sortMixin);\nvar alpha = merge(clone(quantitativeField), alphaMixin, sortMixin);\nvar shape = merge(clone(onlyOrdinalField), legendMixin, shapeMixin, sortMixin);\nvar detail = merge(clone(onlyOrdinalField), detailMixin, sortMixin);\n\n// we only put aggregated measure in pivot table\nvar text = merge(clone(onlyQuantitativeField), textMixin, sortMixin);\n\n// TODO add label\n\nvar filter = {\n  type: 'array',\n  items: {\n    type: 'object',\n    properties: {\n      operands: {\n        type: 'array',\n        items: {\n          type: ['string', 'boolean', 'integer', 'number']\n        }\n      },\n      operator: {\n        type: 'string',\n        enum: ['>', '>=', '=', '!=', '<', '<=', 'notNull']\n      }\n    }\n  }\n};\n\nvar data = {\n  type: 'object',\n  properties: {\n    // data source\n    formatType: {\n      type: 'string',\n      enum: ['json', 'csv'],\n      default: 'json'\n    },\n    url: {\n      type: 'string',\n      default: undefined\n    },\n    values: {\n      type: 'array',\n      description: 'Pass array of objects instead of a url to a file.',\n      items: {\n        type: 'object',\n        additionalProperties: true\n      }\n    }\n  }\n};\n\nvar config = {\n  type: 'object',\n  properties: {\n    // template\n    width: {\n      type: 'integer',\n      default: undefined\n    },\n    height: {\n      type: 'integer',\n      default: undefined\n    },\n    viewport: {\n      type: 'array',\n      items: {\n        type: 'integer'\n      },\n      default: undefined\n    },\n    gridColor: {\n      type: 'string',\n      role: 'color',\n      default: 'black'\n    },\n    gridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.08\n    },\n\n    // filter null\n    filterNull: {\n      type: 'object',\n      properties: {\n        O: {type:'boolean', default: false},\n        Q: {type:'boolean', default: true},\n        T: {type:'boolean', default: true}\n      }\n    },\n    toggleSort: {\n      type: 'string',\n      default: 'O'\n    },\n\n    // single plot\n    singleHeight: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    singleWidth: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    // band size\n    largeBandSize: {\n      type: 'integer',\n      default: 21,\n      minimum: 0\n    },\n    smallBandSize: {\n      //small multiples or single plot with high cardinality\n      type: 'integer',\n      default: 12,\n      minimum: 0\n    },\n    largeBandMaxCardinality: {\n      type: 'integer',\n      default: 10\n    },\n    // small multiples\n    cellPadding: {\n      type: 'number',\n      default: 0.1\n    },\n    cellGridColor: {\n      type: 'string',\n      role: 'color',\n      default: 'black'\n    },\n    cellGridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.15\n    },\n    cellBackgroundColor: {\n      type: 'string',\n      role: 'color',\n      default: 'transparent'\n    },\n    textCellWidth: {\n      type: 'integer',\n      default: 90,\n      minimum: 0\n    },\n\n    // marks\n    strokeWidth: {\n      type: 'integer',\n      default: 2,\n      minimum: 0\n    },\n\n    // scales\n    timeScaleLabelLength: {\n      type: 'integer',\n      default: 3,\n      minimum: 0\n    },\n    // other\n    characterWidth: {\n      type: 'integer',\n      default: 6\n    }\n  }\n};\n\n/** @type Object Schema of a vega-lite specification */\nschema.schema = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  description: 'Schema for Vega-lite specification',\n  type: 'object',\n  required: ['marktype', 'enc', 'data'],\n  properties: {\n    data: data,\n    marktype: schema.marktype,\n    enc: {\n      type: 'object',\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        alpha: alpha,\n        shape: shape,\n        text: text,\n        detail: detail\n      }\n    },\n    filter: filter,\n    config: config\n  }\n};\n\nschema.encTypes = util.keys(schema.schema.properties.enc.properties);\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function() {\n  return schema.util.instantiate(schema.schema);\n};\n","'use strict';\n\nvar schemautil = module.exports = {},\n  util = require('../util');\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\nschemautil.extend = function(instance, schema) {\n  return schemautil.merge(schemautil.instantiate(schema), instance);\n};\n\n// instantiate a schema\nschemautil.instantiate = function(schema) {\n  var val;\n  if (schema === undefined) {\n    return undefined;\n  } else if ('default' in schema) {\n    val = schema.default;\n    return util.isObject(val) ? util.duplicate(val) : val;\n  } else if (schema.type === 'object') {\n    var instance = {};\n    for (var name in schema.properties) {\n      val = schemautil.instantiate(schema.properties[name]);\n      if (val !== undefined) {\n        instance[name] = val;\n      }\n    }\n    return instance;\n  } else if (schema.type === 'array') {\n    return [];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nschemautil.subtract = function(instance, defaults) {\n  var changes = {};\n  for (var prop in instance) {\n    var def = defaults[prop];\n    var ins = instance[prop];\n    // Note: does not properly subtract arrays\n    if (!defaults || def !== ins) {\n      if (typeof ins === 'object' && !util.isArray(ins) && def) {\n        var c = schemautil.subtract(ins, def);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else if (!util.isArray(ins) || ins.length > 0) {\n        changes[prop] = ins;\n      }\n    }\n  }\n  return changes;\n};\n\nschemautil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction merge(dest, src) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (var p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      merge(dest[p], src[p]);\n    }\n  }\n  return dest;\n}","'use strict';\n\nvar util = module.exports = require('datalib/src/util');\n\nutil.extend(util, require('datalib/src/generate'));\nutil.bin = require('datalib/src/bin');\n\nutil.isin = function(item, array) {\n  return array.indexOf(item) !== -1;\n};\n\nutil.forEach = function(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  } else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k , obj);\n    }\n  }\n};\n\nutil.reduce = function(obj, f, init, thisArg) {\n  if (obj.reduce) {\n    return obj.reduce.call(thisArg, f, init);\n  } else {\n    for (var k in obj) {\n      init = f.call(thisArg, init, obj[k], k, obj);\n    }\n    return init;\n  }\n};\n\nutil.map = function(obj, f, thisArg) {\n  if (obj.map) {\n    return obj.map.call(thisArg, f);\n  } else {\n    var output = [];\n    for (var k in obj) {\n      output.push( f.call(thisArg, obj[k], k, obj));\n    }\n  }\n};\n\nutil.any = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (f(arr[k], k, i++)) return true;\n  }\n  return false;\n};\n\nutil.all = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (!f(arr[k], k, i++)) return false;\n  }\n  return true;\n};\n\nutil.getbins = function(stats, maxbins) {\n  return util.bin({\n    min: stats.min,\n    max: stats.max,\n    maxbins: maxbins\n  });\n};\n\n/**\n * x[p[0]]...[p[n]] = val\n * @param noaugment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.setter = function(x, p, val, noaugment) {\n  for (var i=0; i<p.length-1; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  x[p[i]] = val;\n};\n\n\n/**\n * returns x[p[0]]...[p[n]]\n * @param augment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.getter = function(x, p, noaugment) {\n  for (var i=0; i<p.length; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  return x;\n};\n\nutil.error = function(msg) {\n  console.error('[VL Error]', msg);\n};\n\n"],"sourceRoot":"/source/"}