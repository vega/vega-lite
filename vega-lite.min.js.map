{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","vega-lite.js","node_modules/colorbrewer/colorbrewer.js","node_modules/colorbrewer/index.js","node_modules/d3-color/build/color.js","node_modules/d3-format/build/format.js","node_modules/d3-time-format/build/timeFormat.js","node_modules/datalib/node_modules/d3-time/build/time.js","node_modules/datalib/src/bins/bins.js","node_modules/datalib/src/generate.js","node_modules/datalib/src/import/type.js","node_modules/datalib/src/stats.js","node_modules/datalib/src/time.js","node_modules/datalib/src/util.js","src/Encoding.js","src/compiler/aggregate.js","src/compiler/axis.js","src/compiler/bin.js","src/compiler/compiler.js","src/compiler/facet.js","src/compiler/filter.js","src/compiler/group.js","src/compiler/layout.js","src/compiler/legend.js","src/compiler/marks.js","src/compiler/scale.js","src/compiler/sort.js","src/compiler/stack.js","src/compiler/style.js","src/compiler/subfacet.js","src/compiler/template.js","src/compiler/time.js","src/consts.js","src/data.js","src/enc.js","src/field.js","src/globals.js","src/schema/schema.js","src/schema/schemautil.js","src/util.js","src/vl"],"names":["f","exports","module","define","amd","g","window","global","self","this","vl","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,2,"colorbrewer","YlGn",3,4,5,6,7,8,9,"YlGnBu","GnBu","BuGn","PuBuGn","PuBu","BuPu","RdPu","PuRd","OrRd","YlOrRd","YlOrBr","Purples","Blues","Greens","Oranges","Reds","Greys","PuOr",10,11,"BrBG","PRGn","PiYG","RdBu","RdGy","RdYlBu","Spectral","RdYlGn","Accent","Dark2","Paired",12,"Pastel1","Pastel2","Set1","Set2","Set3","./colorbrewer.js","Map","clear","prototype","set","k","v","_","get","has","delete","Object","create",{"end":{"file":"?","comments_before":[],"nlb":false,"endpos":20771,"endcol":12,"endline":332,"pos":20767,"col":8,"line":332,"value":"size","type":"name"},"start":{"file":"?","comments_before":[],"nlb":false,"endpos":20771,"endcol":12,"endline":332,"pos":20767,"col":8,"line":332,"value":"size","type":"name"},"name":"size"},"size","forEach","c","m","apply","arguments","factory","color","deltaHue","h1","h0","delta","Math","round","Color","format","trim","toLowerCase","reHex3","exec","parseInt","rgb","reHex6","rgbn","reRgbInteger","reRgbPercent","reHslPercent","hsl","named","b","NaN","Rgb","isNaN","max","toString","min","h","Hsl","range","hsl2rgb","m1","m2","lab","Lab","Hcl","deg2rad","sin","cos","rgb2xyz","x","xyz2lab","Xn","y","Yn","z","Zn","t3","pow","t2","t0","lab2xyz","t1","xyz2rgb","hcl","sqrt","atan2","rad2deg","cubehelix","Cubehelix","BC_DA","ED","EB","bl","E","C","D","interpolateCubehelixGamma","gamma","ah","as","al","bh","bs","interpolateCubehelixGammaLong","interpolateHclLong","ac","bc","interpolateHcl","interpolateLab","aa","ab","ba","bb","interpolateHslLong","interpolateHsl","interpolateRgb","ar","ag","br","bg","displayable","darker","brighter","_prototype","__prototype","Kn","___prototype","PI","____prototype","A","B","cosh","sinh","interpolateCubehelix","interpolateCubehelixLong","formatDecimal","p","toExponential","indexOf","coefficient","slice","exponent","abs","formatPrefixAuto","d","prefixExponent","floor","Array","join","formatRounded","formatDefault","toPrecision","out","i1","i0","FormatSpecifier","specifier","match","re","fill","align","sign","symbol","zero","width","comma","precision","type","formatTypes","formatSpecifier","identity","formatGroup","grouping","thousands","value","j","push","substring","reverse","localeFormat","locale","prefix","currency","test","suffix","formatType","maybeSuffix","valuePrefix","valueSuffix","valueNegative","prefixes","charCodeAt","decimal","group","Infinity","padding","formatPrefix","precisionRound","step","precisionPrefix","precisionFixed","%","toFixed","X","toUpperCase","timeFormat","utcDate","date","Date","UTC","H","M","S","L","setUTCFullYear","localDate","setFullYear","newYear","parseLiteralPercent","string","percentRe","parseZone","Z","parseWeekdayNumber","numberRe","w","parseWeekNumberSunday","U","parseWeekNumberMonday","W","parseYear","parseMonthNumber","parseDayOfMonth","parseDayOfYear","parseHour24","parseMinutes","parseSeconds","parseMilliseconds","parseFullYear","formatLiteralPercent","formatUTCZone","pad","formatUTCFullYear","getUTCFullYear","formatUTCYear","newInterval","floori","offseti","count","interval","d0","d1","ceil","offset","start","stop","filter","setTime","end","utcWeekday","setUTCHours","setUTCDate","getUTCDate","getUTCDay","formatUTCWeekNumberMonday","utcMonday","utcYear","formatUTCWeekdayNumber","formatUTCWeekNumberSunday","utcSunday","formatUTCSeconds","getUTCSeconds","formatUTCMinutes","getUTCMinutes","formatUTCMonthNumber","getUTCMonth","formatUTCMilliseconds","getUTCMilliseconds","formatUTCDayOfYear","utcDay","formatUTCHour12","getUTCHours","formatUTCHour24","formatUTCDayOfMonth","formatZone","getTimezoneOffset","formatFullYear","getFullYear","formatYear","weekday","setHours","setDate","getDate","getDay","formatWeekNumberMonday","monday","year","formatWeekdayNumber","formatWeekNumberSunday","sunday","formatSeconds","getSeconds","formatMinutes","getMinutes","formatMonthNumber","getMonth","formatMilliseconds","getMilliseconds","formatDayOfYear","day","formatHour12","getHours","formatHour24","formatDayOfMonth","formatLookup","names","map","requote","replace","requoteRe","formatRe","RegExp","newFormat","formats","pads","charAt","newParse","newDate","parseSpecifier","parse","parses","parseShortWeekday","shortWeekdayRe","shortWeekdayLookup","parseWeekday","weekdayRe","weekdayLookup","parseShortMonth","shortMonthRe","shortMonthLookup","parseMonth","monthRe","monthLookup","parseLocaleDateTime","locale_dateTime","parseLocaleDate","locale_date","parseLocaleTime","locale_time","parsePeriod","periodLookup","formatShortWeekday","locale_shortWeekdays","formatWeekday","locale_weekdays","formatShortMonth","locale_shortMonths","formatMonth","locale_months","formatPeriod","locale_periods","formatUTCShortWeekday","formatUTCWeekday","formatUTCShortMonth","formatUTCMonth","formatUTCPeriod","dateTime","time","periods","days","shortDays","months","shortMonths","I","Y","utcFormats","utcFormat","formatIsoNative","toISOString","-","0","setUTCMonth","setMonth","isoSpecifier","formatIso","isoFormat","second","setMilliseconds","seconds","minute","setSeconds","minutes","hour","setMinutes","hours","sundays","mondays","tuesday","tuesdays","wednesday","wednesdays","thursday","thursdays","friday","fridays","saturday","saturdays","week","weeks","month","years","utcSecond","setUTCMilliseconds","utcSeconds","utcMinute","setUTCSeconds","utcMinutes","utcHour","setUTCMinutes","utcHours","utcDays","utcSundays","utcMondays","utcTuesday","utcTuesdays","utcWednesday","utcWednesdays","utcThursday","utcThursdays","utcFriday","utcFridays","utcSaturday","utcSaturdays","utcWeek","utcWeeks","utcMonth","utcMonths","utcYears","bins","opt","level","minstep","eps","maxb","maxbins","base","logb","log","div","span","steps","bisect","unit","index","lo","hi","mid","util","cmp","EPSILON","date_value","date_index","units","utc","dmin","dmax","minb","minbins","find","spec","raw","../time","../util","gen","repeat","val","zeros","random","uniform","undefined","samples","integer","normal","mean","stdev","next","rds","annotation","data","types","TYPES","values","$","isString","isValid","isDate","isNumber","isBoolean","typeAll","fields","keys","reduce","infer","TESTS","splice","inferAll","PARSERS","boolean","number","all","parsers","stats","unique","results","valid","missing","distinct","median","sort","quantile","quartile","q","sum","variance","isArray","M2","modeskew","avg","med","std","extent","dot","rank","mu","idx","comparator","tie","cor","fn","mua","mub","sda","sdb","ra","rb","dist","mat","exp","isFunction","L2","R","entropy","counts","LN2","mutual","px","py","info","profile","sd","vals","q1","q3","summary","field","__summary__","./generate","./import/type","./util","tempDate","entry","STEPS","toUnitMap","d3_time","baseDate","utcBaseDate","d3-time",13,"util_escape_str","escape_str_re","strrep","str","truncateOnWord","len","rev","cnt","tok","split","truncate_word_re","buffer","FNAME","namedfunc","name","duplicate","obj","JSON","stringify","equal","extend","toMap","list","keystr","String","isObject","isBuffer","Buffer","array","shift","accessor","mutator","$func","op","$valid","$length","$in","$year","$month","$date","dates","$day","weekdays","$hour","$minute","$second","$utcYear","$utcMonth","$utcDate","$utcDay","$utcHour","$utcMinute","$utcSecond","numcmp","stablesort","sortBy","keyFn","indices","sa","sb","pos","padchar","truncate","word","ellipsis","l1","l2","./time",14,"consts","vlfield","vlenc","schema","Encoding","theme","defaults","instantiate","specExtended","merge","_data","_marktype","marktype","_enc","encoding","_config","config","_filter","proto","fromShorthand","shorthand","delim","assign","enc","fromSpec","toShorthand","specFromShorthand","excludeConfig","toSpec","excludeData","subtract","is","encType","et","filterNull","fieldList","fieldName","Q","containsType","T","O","N","operands","operator","concat","fieldRef","_vega2","fieldTitle","isCount","displayName","aggregate","timeUnit","bin","scale","axis","bandSize","useSmallBand","ROW","COL","band","MAXBINS_DEFAULT","numberFormat","fieldStats","formatConfig","isTypes","toggleSort","support","qField","init","isType","isOrdinalScale","isDimension","isMeasure","isAggregate","alwaysNoOcclusion","isStack","cardinality","isRaw","hasValues","transpose","oldenc","row","col","direction","mode","toggleFilterNullO","nulls","./consts","./enc","./field","./globals","./schema/schema",15,"aggregates","dataTable","dims","meas","detail","facets","nofn","transform","groupby","details","aggregated","../globals",16,"setter","getter","props","defs","layout","def","isCol","isRow","properties","layer","orient","labels","rotate","ticks","titleOffset","grid","title","hideTicks","cellPadding","cellWidth","cellHeight","stroke","opacity","x2","mult","majorTicks","ax","maxLength","titleMaxLength","angle","baseline","dy","height","hasScale","maxLabelLength",17,"binning","output",18,"compiler","legend","marks","facet","stack","style","subfacet","template","compile","compileEncoding","rawTable","addFilters","aggResult","sorting","mark","mdefs","mdef","lineType","line","hasDetails","from","by","legends","scales","update","axes","filterLessThanZero","../Encoding","./aggregate","./axis","./bin","./facet","./filter","./group","./layout","./legend","./marks","./scale","./sort","./stack","./style","./subfacet","./template","datalib/src/stats",19,"faceting","axesGrp","enter","facetKeys","cellAxes","hasRow","hasCol","error","unshift","groupdef","trans",20,"BINARY",">",">=","=","!=","<","<=","filters","condition","op1","op2","console","warn",21,"_name",22,"vllayout","box","hasX","hasY","xCardinality","yCardinality","TEXT","colCardinality","rowCardinality","getMaxNumberLength","d3_format","getMaxLength","extraOffset","d3-format",23,"COLOR","SIZE","SHAPE","shape","text",24,"bar_props","xc","y2","yc","point_props","filled","strokeWidth","line_props","area_props","tick_props","filled_point_props","text_props","fontSize","font","placeholder","family","fontWeight","weight","fontStyle","TABLE","prop","bar","requiredEncoding","supportedEncoding","area","tick","circle","square","point",25,"domain","fieldStat","getbins","numbins","STACKED","prefn","scaleUseRawDomain","useRawDomain","notCountOrSum","isOrdinalFn","RAW","getDataset","bandWidth","nice","outerPadding","points","colorScale","ordinalPalette","c10palette","c20palette","palette","ps","interpolate","interpolator","../schema/schema","d3-color",26,"addSortTransforms","datasetMapping","counter","byClause","dataName","transforms","source","../field",27,"stacking","dim","isXMeasure","isYMeasure","stacked","y1","y0",28,"estimateOpacity","numPoints","numMultiples",29,"subfaceting",30,"table","dataUrl","dataType","url",31,"timeFields","timeUnits","tf","fieldFn","func","d3_time_format","LONG_DATE","stat","yearstat","formula","expr","scaleLabel","labelLength","substr","isColor","d3-time-format",32,"encodingTypes","DETAIL",33,"vldata","*",34,"encTypes","countRetinal","fieldDef","arr","enctype",35,"shorthands","timefns","tu","./compiler/time",36,"INDEX",37,"enum","supportedEnums","supportedTypes","getSupportedRole","supportedRole","defaultTimeFn","scale_type","default","clone","minimum","description","typicalField","onlyOrdinalField","dimension","axisMixin","supportedMarktypes","sortMixin","items","required","bandMixin","legendMixin","textMixin","role","margin","sizeMixin","colorMixin","maximum","shapeMixin","detailMixin","rowMixin","colMixin","facetMixin","requiredNameType","multiRoleField","measure","quantitativeField","onlyQuantitativeField","additionalProperties","viewport","gridColor","gridOpacity","singleHeight","singleWidth","largeBandSize","smallBandSize","largeBandMaxCardinality","cellGridColor","cellGridOpacity","cellBackgroundColor","textCellWidth","singleBarOffset","timeScaleLabelLength","dayScaleLabel","monthScaleLabel","characterWidth","maxSmallNumber","smallNumberFormat","largeNumberFormat","$schema","./schemautil",38,"dest","src","hasOwnProperty","constructor","schemautil","isEmpty","instance","changes","ins",39,"isin","item","thisArg","any","noaugment","msg","datalib/src/bins/bins","datalib/src/generate","datalib/src/util",40,"./Encoding","./compiler/compiler","./data"],"mappings":"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","file":"vega-lite.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.vl = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\n},{}],2:[function(require,module,exports){\n// This product includes color specifications and designs developed by Cynthia Brewer (http://colorbrewer.org/).\n// JavaScript specs as packaged in the D3 library (d3js.org). Please see license at http://colorbrewer.org/export/LICENSE.txt\n!function() {\n\nvar colorbrewer = {YlGn: {\n3: [\"#f7fcb9\",\"#addd8e\",\"#31a354\"],\n4: [\"#ffffcc\",\"#c2e699\",\"#78c679\",\"#238443\"],\n5: [\"#ffffcc\",\"#c2e699\",\"#78c679\",\"#31a354\",\"#006837\"],\n6: [\"#ffffcc\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#31a354\",\"#006837\"],\n7: [\"#ffffcc\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#005a32\"],\n8: [\"#ffffe5\",\"#f7fcb9\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#005a32\"],\n9: [\"#ffffe5\",\"#f7fcb9\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#006837\",\"#004529\"]\n},YlGnBu: {\n3: [\"#edf8b1\",\"#7fcdbb\",\"#2c7fb8\"],\n4: [\"#ffffcc\",\"#a1dab4\",\"#41b6c4\",\"#225ea8\"],\n5: [\"#ffffcc\",\"#a1dab4\",\"#41b6c4\",\"#2c7fb8\",\"#253494\"],\n6: [\"#ffffcc\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#2c7fb8\",\"#253494\"],\n7: [\"#ffffcc\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#0c2c84\"],\n8: [\"#ffffd9\",\"#edf8b1\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#0c2c84\"],\n9: [\"#ffffd9\",\"#edf8b1\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#253494\",\"#081d58\"]\n},GnBu: {\n3: [\"#e0f3db\",\"#a8ddb5\",\"#43a2ca\"],\n4: [\"#f0f9e8\",\"#bae4bc\",\"#7bccc4\",\"#2b8cbe\"],\n5: [\"#f0f9e8\",\"#bae4bc\",\"#7bccc4\",\"#43a2ca\",\"#0868ac\"],\n6: [\"#f0f9e8\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#43a2ca\",\"#0868ac\"],\n7: [\"#f0f9e8\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#08589e\"],\n8: [\"#f7fcf0\",\"#e0f3db\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#08589e\"],\n9: [\"#f7fcf0\",\"#e0f3db\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#0868ac\",\"#084081\"]\n},BuGn: {\n3: [\"#e5f5f9\",\"#99d8c9\",\"#2ca25f\"],\n4: [\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#238b45\"],\n5: [\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\"],\n6: [\"#edf8fb\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\"],\n7: [\"#edf8fb\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#005824\"],\n8: [\"#f7fcfd\",\"#e5f5f9\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#005824\"],\n9: [\"#f7fcfd\",\"#e5f5f9\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#006d2c\",\"#00441b\"]\n},PuBuGn: {\n3: [\"#ece2f0\",\"#a6bddb\",\"#1c9099\"],\n4: [\"#f6eff7\",\"#bdc9e1\",\"#67a9cf\",\"#02818a\"],\n5: [\"#f6eff7\",\"#bdc9e1\",\"#67a9cf\",\"#1c9099\",\"#016c59\"],\n6: [\"#f6eff7\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#1c9099\",\"#016c59\"],\n7: [\"#f6eff7\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016450\"],\n8: [\"#fff7fb\",\"#ece2f0\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016450\"],\n9: [\"#fff7fb\",\"#ece2f0\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016c59\",\"#014636\"]\n},PuBu: {\n3: [\"#ece7f2\",\"#a6bddb\",\"#2b8cbe\"],\n4: [\"#f1eef6\",\"#bdc9e1\",\"#74a9cf\",\"#0570b0\"],\n5: [\"#f1eef6\",\"#bdc9e1\",\"#74a9cf\",\"#2b8cbe\",\"#045a8d\"],\n6: [\"#f1eef6\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#2b8cbe\",\"#045a8d\"],\n7: [\"#f1eef6\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#034e7b\"],\n8: [\"#fff7fb\",\"#ece7f2\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#034e7b\"],\n9: [\"#fff7fb\",\"#ece7f2\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#045a8d\",\"#023858\"]\n},BuPu: {\n3: [\"#e0ecf4\",\"#9ebcda\",\"#8856a7\"],\n4: [\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#88419d\"],\n5: [\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#8856a7\",\"#810f7c\"],\n6: [\"#edf8fb\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8856a7\",\"#810f7c\"],\n7: [\"#edf8fb\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#6e016b\"],\n8: [\"#f7fcfd\",\"#e0ecf4\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#6e016b\"],\n9: [\"#f7fcfd\",\"#e0ecf4\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#810f7c\",\"#4d004b\"]\n},RdPu: {\n3: [\"#fde0dd\",\"#fa9fb5\",\"#c51b8a\"],\n4: [\"#feebe2\",\"#fbb4b9\",\"#f768a1\",\"#ae017e\"],\n5: [\"#feebe2\",\"#fbb4b9\",\"#f768a1\",\"#c51b8a\",\"#7a0177\"],\n6: [\"#feebe2\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#c51b8a\",\"#7a0177\"],\n7: [\"#feebe2\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\"],\n8: [\"#fff7f3\",\"#fde0dd\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\"],\n9: [\"#fff7f3\",\"#fde0dd\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\",\"#49006a\"]\n},PuRd: {\n3: [\"#e7e1ef\",\"#c994c7\",\"#dd1c77\"],\n4: [\"#f1eef6\",\"#d7b5d8\",\"#df65b0\",\"#ce1256\"],\n5: [\"#f1eef6\",\"#d7b5d8\",\"#df65b0\",\"#dd1c77\",\"#980043\"],\n6: [\"#f1eef6\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#dd1c77\",\"#980043\"],\n7: [\"#f1eef6\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#91003f\"],\n8: [\"#f7f4f9\",\"#e7e1ef\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#91003f\"],\n9: [\"#f7f4f9\",\"#e7e1ef\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#980043\",\"#67001f\"]\n},OrRd: {\n3: [\"#fee8c8\",\"#fdbb84\",\"#e34a33\"],\n4: [\"#fef0d9\",\"#fdcc8a\",\"#fc8d59\",\"#d7301f\"],\n5: [\"#fef0d9\",\"#fdcc8a\",\"#fc8d59\",\"#e34a33\",\"#b30000\"],\n6: [\"#fef0d9\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#e34a33\",\"#b30000\"],\n7: [\"#fef0d9\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#990000\"],\n8: [\"#fff7ec\",\"#fee8c8\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#990000\"],\n9: [\"#fff7ec\",\"#fee8c8\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#b30000\",\"#7f0000\"]\n},YlOrRd: {\n3: [\"#ffeda0\",\"#feb24c\",\"#f03b20\"],\n4: [\"#ffffb2\",\"#fecc5c\",\"#fd8d3c\",\"#e31a1c\"],\n5: [\"#ffffb2\",\"#fecc5c\",\"#fd8d3c\",\"#f03b20\",\"#bd0026\"],\n6: [\"#ffffb2\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#f03b20\",\"#bd0026\"],\n7: [\"#ffffb2\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#b10026\"],\n8: [\"#ffffcc\",\"#ffeda0\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#b10026\"],\n9: [\"#ffffcc\",\"#ffeda0\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#bd0026\",\"#800026\"]\n},YlOrBr: {\n3: [\"#fff7bc\",\"#fec44f\",\"#d95f0e\"],\n4: [\"#ffffd4\",\"#fed98e\",\"#fe9929\",\"#cc4c02\"],\n5: [\"#ffffd4\",\"#fed98e\",\"#fe9929\",\"#d95f0e\",\"#993404\"],\n6: [\"#ffffd4\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#d95f0e\",\"#993404\"],\n7: [\"#ffffd4\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#8c2d04\"],\n8: [\"#ffffe5\",\"#fff7bc\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#8c2d04\"],\n9: [\"#ffffe5\",\"#fff7bc\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#993404\",\"#662506\"]\n},Purples: {\n3: [\"#efedf5\",\"#bcbddc\",\"#756bb1\"],\n4: [\"#f2f0f7\",\"#cbc9e2\",\"#9e9ac8\",\"#6a51a3\"],\n5: [\"#f2f0f7\",\"#cbc9e2\",\"#9e9ac8\",\"#756bb1\",\"#54278f\"],\n6: [\"#f2f0f7\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#756bb1\",\"#54278f\"],\n7: [\"#f2f0f7\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#4a1486\"],\n8: [\"#fcfbfd\",\"#efedf5\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#4a1486\"],\n9: [\"#fcfbfd\",\"#efedf5\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#54278f\",\"#3f007d\"]\n},Blues: {\n3: [\"#deebf7\",\"#9ecae1\",\"#3182bd\"],\n4: [\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#2171b5\"],\n5: [\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#3182bd\",\"#08519c\"],\n6: [\"#eff3ff\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#3182bd\",\"#08519c\"],\n7: [\"#eff3ff\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#084594\"],\n8: [\"#f7fbff\",\"#deebf7\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#084594\"],\n9: [\"#f7fbff\",\"#deebf7\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#08519c\",\"#08306b\"]\n},Greens: {\n3: [\"#e5f5e0\",\"#a1d99b\",\"#31a354\"],\n4: [\"#edf8e9\",\"#bae4b3\",\"#74c476\",\"#238b45\"],\n5: [\"#edf8e9\",\"#bae4b3\",\"#74c476\",\"#31a354\",\"#006d2c\"],\n6: [\"#edf8e9\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#31a354\",\"#006d2c\"],\n7: [\"#edf8e9\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#005a32\"],\n8: [\"#f7fcf5\",\"#e5f5e0\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#005a32\"],\n9: [\"#f7fcf5\",\"#e5f5e0\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#006d2c\",\"#00441b\"]\n},Oranges: {\n3: [\"#fee6ce\",\"#fdae6b\",\"#e6550d\"],\n4: [\"#feedde\",\"#fdbe85\",\"#fd8d3c\",\"#d94701\"],\n5: [\"#feedde\",\"#fdbe85\",\"#fd8d3c\",\"#e6550d\",\"#a63603\"],\n6: [\"#feedde\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#e6550d\",\"#a63603\"],\n7: [\"#feedde\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#8c2d04\"],\n8: [\"#fff5eb\",\"#fee6ce\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#8c2d04\"],\n9: [\"#fff5eb\",\"#fee6ce\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#a63603\",\"#7f2704\"]\n},Reds: {\n3: [\"#fee0d2\",\"#fc9272\",\"#de2d26\"],\n4: [\"#fee5d9\",\"#fcae91\",\"#fb6a4a\",\"#cb181d\"],\n5: [\"#fee5d9\",\"#fcae91\",\"#fb6a4a\",\"#de2d26\",\"#a50f15\"],\n6: [\"#fee5d9\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#de2d26\",\"#a50f15\"],\n7: [\"#fee5d9\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#99000d\"],\n8: [\"#fff5f0\",\"#fee0d2\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#99000d\"],\n9: [\"#fff5f0\",\"#fee0d2\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#a50f15\",\"#67000d\"]\n},Greys: {\n3: [\"#f0f0f0\",\"#bdbdbd\",\"#636363\"],\n4: [\"#f7f7f7\",\"#cccccc\",\"#969696\",\"#525252\"],\n5: [\"#f7f7f7\",\"#cccccc\",\"#969696\",\"#636363\",\"#252525\"],\n6: [\"#f7f7f7\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#636363\",\"#252525\"],\n7: [\"#f7f7f7\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\"],\n8: [\"#ffffff\",\"#f0f0f0\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\"],\n9: [\"#ffffff\",\"#f0f0f0\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\",\"#000000\"]\n},PuOr: {\n3: [\"#f1a340\",\"#f7f7f7\",\"#998ec3\"],\n4: [\"#e66101\",\"#fdb863\",\"#b2abd2\",\"#5e3c99\"],\n5: [\"#e66101\",\"#fdb863\",\"#f7f7f7\",\"#b2abd2\",\"#5e3c99\"],\n6: [\"#b35806\",\"#f1a340\",\"#fee0b6\",\"#d8daeb\",\"#998ec3\",\"#542788\"],\n7: [\"#b35806\",\"#f1a340\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#998ec3\",\"#542788\"],\n8: [\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\"],\n9: [\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\"],\n10: [\"#7f3b08\",\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\",\"#2d004b\"],\n11: [\"#7f3b08\",\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\",\"#2d004b\"]\n},BrBG: {\n3: [\"#d8b365\",\"#f5f5f5\",\"#5ab4ac\"],\n4: [\"#a6611a\",\"#dfc27d\",\"#80cdc1\",\"#018571\"],\n5: [\"#a6611a\",\"#dfc27d\",\"#f5f5f5\",\"#80cdc1\",\"#018571\"],\n6: [\"#8c510a\",\"#d8b365\",\"#f6e8c3\",\"#c7eae5\",\"#5ab4ac\",\"#01665e\"],\n7: [\"#8c510a\",\"#d8b365\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#5ab4ac\",\"#01665e\"],\n8: [\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\"],\n9: [\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\"],\n10: [\"#543005\",\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\",\"#003c30\"],\n11: [\"#543005\",\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\",\"#003c30\"]\n},PRGn: {\n3: [\"#af8dc3\",\"#f7f7f7\",\"#7fbf7b\"],\n4: [\"#7b3294\",\"#c2a5cf\",\"#a6dba0\",\"#008837\"],\n5: [\"#7b3294\",\"#c2a5cf\",\"#f7f7f7\",\"#a6dba0\",\"#008837\"],\n6: [\"#762a83\",\"#af8dc3\",\"#e7d4e8\",\"#d9f0d3\",\"#7fbf7b\",\"#1b7837\"],\n7: [\"#762a83\",\"#af8dc3\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#7fbf7b\",\"#1b7837\"],\n8: [\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\"],\n9: [\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\"],\n10: [\"#40004b\",\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\",\"#00441b\"],\n11: [\"#40004b\",\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\",\"#00441b\"]\n},PiYG: {\n3: [\"#e9a3c9\",\"#f7f7f7\",\"#a1d76a\"],\n4: [\"#d01c8b\",\"#f1b6da\",\"#b8e186\",\"#4dac26\"],\n5: [\"#d01c8b\",\"#f1b6da\",\"#f7f7f7\",\"#b8e186\",\"#4dac26\"],\n6: [\"#c51b7d\",\"#e9a3c9\",\"#fde0ef\",\"#e6f5d0\",\"#a1d76a\",\"#4d9221\"],\n7: [\"#c51b7d\",\"#e9a3c9\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#a1d76a\",\"#4d9221\"],\n8: [\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\"],\n9: [\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\"],\n10: [\"#8e0152\",\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\",\"#276419\"],\n11: [\"#8e0152\",\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\",\"#276419\"]\n},RdBu: {\n3: [\"#ef8a62\",\"#f7f7f7\",\"#67a9cf\"],\n4: [\"#ca0020\",\"#f4a582\",\"#92c5de\",\"#0571b0\"],\n5: [\"#ca0020\",\"#f4a582\",\"#f7f7f7\",\"#92c5de\",\"#0571b0\"],\n6: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#d1e5f0\",\"#67a9cf\",\"#2166ac\"],\n7: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#67a9cf\",\"#2166ac\"],\n8: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\"],\n9: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\"],\n10: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\",\"#053061\"],\n11: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\",\"#053061\"]\n},RdGy: {\n3: [\"#ef8a62\",\"#ffffff\",\"#999999\"],\n4: [\"#ca0020\",\"#f4a582\",\"#bababa\",\"#404040\"],\n5: [\"#ca0020\",\"#f4a582\",\"#ffffff\",\"#bababa\",\"#404040\"],\n6: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#e0e0e0\",\"#999999\",\"#4d4d4d\"],\n7: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#999999\",\"#4d4d4d\"],\n8: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\"],\n9: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\"],\n10: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\",\"#1a1a1a\"],\n11: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\",\"#1a1a1a\"]\n},RdYlBu: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#91bfdb\"],\n4: [\"#d7191c\",\"#fdae61\",\"#abd9e9\",\"#2c7bb6\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#abd9e9\",\"#2c7bb6\"],\n6: [\"#d73027\",\"#fc8d59\",\"#fee090\",\"#e0f3f8\",\"#91bfdb\",\"#4575b4\"],\n7: [\"#d73027\",\"#fc8d59\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#91bfdb\",\"#4575b4\"],\n8: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\"],\n9: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\"],\n10: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\",\"#313695\"],\n11: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\",\"#313695\"]\n},Spectral: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#99d594\"],\n4: [\"#d7191c\",\"#fdae61\",\"#abdda4\",\"#2b83ba\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#abdda4\",\"#2b83ba\"],\n6: [\"#d53e4f\",\"#fc8d59\",\"#fee08b\",\"#e6f598\",\"#99d594\",\"#3288bd\"],\n7: [\"#d53e4f\",\"#fc8d59\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#99d594\",\"#3288bd\"],\n8: [\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\"],\n9: [\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\"],\n10: [\"#9e0142\",\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\",\"#5e4fa2\"],\n11: [\"#9e0142\",\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\",\"#5e4fa2\"]\n},RdYlGn: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#91cf60\"],\n4: [\"#d7191c\",\"#fdae61\",\"#a6d96a\",\"#1a9641\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#a6d96a\",\"#1a9641\"],\n6: [\"#d73027\",\"#fc8d59\",\"#fee08b\",\"#d9ef8b\",\"#91cf60\",\"#1a9850\"],\n7: [\"#d73027\",\"#fc8d59\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#91cf60\",\"#1a9850\"],\n8: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\"],\n9: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\"],\n10: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\",\"#006837\"],\n11: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\",\"#006837\"]\n},Accent: {\n3: [\"#7fc97f\",\"#beaed4\",\"#fdc086\"],\n4: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\"],\n5: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\"],\n6: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\"],\n7: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\",\"#bf5b17\"],\n8: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\",\"#bf5b17\",\"#666666\"]\n},Dark2: {\n3: [\"#1b9e77\",\"#d95f02\",\"#7570b3\"],\n4: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\"],\n5: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\"],\n6: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\"],\n7: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\",\"#a6761d\"],\n8: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\",\"#a6761d\",\"#666666\"]\n},Paired: {\n3: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\"],\n4: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\"],\n5: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\"],\n6: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\"],\n7: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\"],\n8: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\"],\n9: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\"],\n10: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\"],\n11: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\",\"#ffff99\"],\n12: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\",\"#ffff99\",\"#b15928\"]\n},Pastel1: {\n3: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\"],\n4: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\"],\n5: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\"],\n6: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\"],\n7: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\"],\n8: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\"#fddaec\"],\n9: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\"#fddaec\",\"#f2f2f2\"]\n},Pastel2: {\n3: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\"],\n4: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\"],\n5: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\"],\n6: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\"],\n7: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\",\"#f1e2cc\"],\n8: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\",\"#f1e2cc\",\"#cccccc\"]\n},Set1: {\n3: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\"],\n4: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\"],\n5: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\"],\n6: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\"],\n7: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\"],\n8: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\",\"#f781bf\"],\n9: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\",\"#f781bf\",\"#999999\"]\n},Set2: {\n3: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\"],\n4: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\"],\n5: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\"],\n6: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\"],\n7: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\",\"#e5c494\"],\n8: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\",\"#e5c494\",\"#b3b3b3\"]\n},Set3: {\n3: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\"],\n4: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\"],\n5: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\"],\n6: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\"],\n7: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\"],\n8: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\"],\n9: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\"],\n10: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\"],\n11: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\",\"#ccebc5\"],\n12: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\",\"#ccebc5\",\"#ffed6f\"]\n}};\n\nif (typeof define === \"function\" && define.amd) {\n    define(colorbrewer);\n} else if (typeof module === \"object\" && module.exports) {\n    module.exports = colorbrewer;\n} else {\n    this.colorbrewer = colorbrewer;\n}\n\n}();\n\n},{}],3:[function(require,module,exports){\nmodule.exports = require('./colorbrewer.js');\n\n},{\"./colorbrewer.js\":2}],4:[function(require,module,exports){\nif (typeof Map === \"undefined\") {\n  Map = function() { this.clear(); };\n  Map.prototype = {\n    set: function(k, v) { this._[k] = v; return this; },\n    get: function(k) { return this._[k]; },\n    has: function(k) { return k in this._; },\n    delete: function(k) { return k in this._ && delete this._[k]; },\n    clear: function() { this._ = Object.create(null); },\n    get size() { var n = 0; for (var k in this._) ++n; return n; },\n    forEach: function(c) { for (var k in this._) c(this._[k], k, this); }\n  };\n} else (function() {\n  var m = new Map;\n  if (m.set(0, 0) !== m) {\n    m = m.set;\n    Map.prototype.set = function() { m.apply(this, arguments); return this; };\n  }\n})();\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.color = {}));\n}(this, function (exports) { 'use strict';\n\n  function deltaHue(h1, h0) {\n    var delta = h1 - h0;\n    return delta > 180 || delta < -180\n        ? delta - 360 * Math.round(delta / 360)\n        : delta;\n  }\n\n  function Color() {}\n\n  var reHex3 = /^#([0-9a-f]{3})$/;\n  var reHex6 = /^#([0-9a-f]{6})$/;\n  var reRgbInteger = /^rgb\\(\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*\\)$/;\n  var reRgbPercent = /^rgb\\(\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n  var reHslPercent = /^hsl\\(\\s*([-+]?\\d+(?:\\.\\d+)?)\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n\n  color.prototype = Color.prototype = {\n    displayable: function() {\n      return this.rgb().displayable();\n    },\n    toString: function() {\n      return this.rgb() + \"\";\n    }\n  };\n\n  function color(format) {\n    var m;\n    format = (format + \"\").trim().toLowerCase();\n    return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf))) // #f00\n        : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000\n        : (m = reRgbInteger.exec(format)) ? rgb(m[1], m[2], m[3]) // rgb(255,0,0)\n        : (m = reRgbPercent.exec(format)) ? rgb(m[1] * 2.55, m[2] * 2.55, m[3] * 2.55) // rgb(100%,0%,0%)\n        : (m = reHslPercent.exec(format)) ? hsl(m[1], m[2] * .01, m[3] * .01) // hsl(120,50%,50%)\n        : named.has(format) ? rgbn(named.get(format))\n        : null;\n  }\n\n  function rgbn(n) {\n    return rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff);\n  }\n\n  var named = (new Map)\n      .set(\"aliceblue\", 0xf0f8ff)\n      .set(\"antiquewhite\", 0xfaebd7)\n      .set(\"aqua\", 0x00ffff)\n      .set(\"aquamarine\", 0x7fffd4)\n      .set(\"azure\", 0xf0ffff)\n      .set(\"beige\", 0xf5f5dc)\n      .set(\"bisque\", 0xffe4c4)\n      .set(\"black\", 0x000000)\n      .set(\"blanchedalmond\", 0xffebcd)\n      .set(\"blue\", 0x0000ff)\n      .set(\"blueviolet\", 0x8a2be2)\n      .set(\"brown\", 0xa52a2a)\n      .set(\"burlywood\", 0xdeb887)\n      .set(\"cadetblue\", 0x5f9ea0)\n      .set(\"chartreuse\", 0x7fff00)\n      .set(\"chocolate\", 0xd2691e)\n      .set(\"coral\", 0xff7f50)\n      .set(\"cornflowerblue\", 0x6495ed)\n      .set(\"cornsilk\", 0xfff8dc)\n      .set(\"crimson\", 0xdc143c)\n      .set(\"cyan\", 0x00ffff)\n      .set(\"darkblue\", 0x00008b)\n      .set(\"darkcyan\", 0x008b8b)\n      .set(\"darkgoldenrod\", 0xb8860b)\n      .set(\"darkgray\", 0xa9a9a9)\n      .set(\"darkgreen\", 0x006400)\n      .set(\"darkgrey\", 0xa9a9a9)\n      .set(\"darkkhaki\", 0xbdb76b)\n      .set(\"darkmagenta\", 0x8b008b)\n      .set(\"darkolivegreen\", 0x556b2f)\n      .set(\"darkorange\", 0xff8c00)\n      .set(\"darkorchid\", 0x9932cc)\n      .set(\"darkred\", 0x8b0000)\n      .set(\"darksalmon\", 0xe9967a)\n      .set(\"darkseagreen\", 0x8fbc8f)\n      .set(\"darkslateblue\", 0x483d8b)\n      .set(\"darkslategray\", 0x2f4f4f)\n      .set(\"darkslategrey\", 0x2f4f4f)\n      .set(\"darkturquoise\", 0x00ced1)\n      .set(\"darkviolet\", 0x9400d3)\n      .set(\"deeppink\", 0xff1493)\n      .set(\"deepskyblue\", 0x00bfff)\n      .set(\"dimgray\", 0x696969)\n      .set(\"dimgrey\", 0x696969)\n      .set(\"dodgerblue\", 0x1e90ff)\n      .set(\"firebrick\", 0xb22222)\n      .set(\"floralwhite\", 0xfffaf0)\n      .set(\"forestgreen\", 0x228b22)\n      .set(\"fuchsia\", 0xff00ff)\n      .set(\"gainsboro\", 0xdcdcdc)\n      .set(\"ghostwhite\", 0xf8f8ff)\n      .set(\"gold\", 0xffd700)\n      .set(\"goldenrod\", 0xdaa520)\n      .set(\"gray\", 0x808080)\n      .set(\"green\", 0x008000)\n      .set(\"greenyellow\", 0xadff2f)\n      .set(\"grey\", 0x808080)\n      .set(\"honeydew\", 0xf0fff0)\n      .set(\"hotpink\", 0xff69b4)\n      .set(\"indianred\", 0xcd5c5c)\n      .set(\"indigo\", 0x4b0082)\n      .set(\"ivory\", 0xfffff0)\n      .set(\"khaki\", 0xf0e68c)\n      .set(\"lavender\", 0xe6e6fa)\n      .set(\"lavenderblush\", 0xfff0f5)\n      .set(\"lawngreen\", 0x7cfc00)\n      .set(\"lemonchiffon\", 0xfffacd)\n      .set(\"lightblue\", 0xadd8e6)\n      .set(\"lightcoral\", 0xf08080)\n      .set(\"lightcyan\", 0xe0ffff)\n      .set(\"lightgoldenrodyellow\", 0xfafad2)\n      .set(\"lightgray\", 0xd3d3d3)\n      .set(\"lightgreen\", 0x90ee90)\n      .set(\"lightgrey\", 0xd3d3d3)\n      .set(\"lightpink\", 0xffb6c1)\n      .set(\"lightsalmon\", 0xffa07a)\n      .set(\"lightseagreen\", 0x20b2aa)\n      .set(\"lightskyblue\", 0x87cefa)\n      .set(\"lightslategray\", 0x778899)\n      .set(\"lightslategrey\", 0x778899)\n      .set(\"lightsteelblue\", 0xb0c4de)\n      .set(\"lightyellow\", 0xffffe0)\n      .set(\"lime\", 0x00ff00)\n      .set(\"limegreen\", 0x32cd32)\n      .set(\"linen\", 0xfaf0e6)\n      .set(\"magenta\", 0xff00ff)\n      .set(\"maroon\", 0x800000)\n      .set(\"mediumaquamarine\", 0x66cdaa)\n      .set(\"mediumblue\", 0x0000cd)\n      .set(\"mediumorchid\", 0xba55d3)\n      .set(\"mediumpurple\", 0x9370db)\n      .set(\"mediumseagreen\", 0x3cb371)\n      .set(\"mediumslateblue\", 0x7b68ee)\n      .set(\"mediumspringgreen\", 0x00fa9a)\n      .set(\"mediumturquoise\", 0x48d1cc)\n      .set(\"mediumvioletred\", 0xc71585)\n      .set(\"midnightblue\", 0x191970)\n      .set(\"mintcream\", 0xf5fffa)\n      .set(\"mistyrose\", 0xffe4e1)\n      .set(\"moccasin\", 0xffe4b5)\n      .set(\"navajowhite\", 0xffdead)\n      .set(\"navy\", 0x000080)\n      .set(\"oldlace\", 0xfdf5e6)\n      .set(\"olive\", 0x808000)\n      .set(\"olivedrab\", 0x6b8e23)\n      .set(\"orange\", 0xffa500)\n      .set(\"orangered\", 0xff4500)\n      .set(\"orchid\", 0xda70d6)\n      .set(\"palegoldenrod\", 0xeee8aa)\n      .set(\"palegreen\", 0x98fb98)\n      .set(\"paleturquoise\", 0xafeeee)\n      .set(\"palevioletred\", 0xdb7093)\n      .set(\"papayawhip\", 0xffefd5)\n      .set(\"peachpuff\", 0xffdab9)\n      .set(\"peru\", 0xcd853f)\n      .set(\"pink\", 0xffc0cb)\n      .set(\"plum\", 0xdda0dd)\n      .set(\"powderblue\", 0xb0e0e6)\n      .set(\"purple\", 0x800080)\n      .set(\"rebeccapurple\", 0x663399)\n      .set(\"red\", 0xff0000)\n      .set(\"rosybrown\", 0xbc8f8f)\n      .set(\"royalblue\", 0x4169e1)\n      .set(\"saddlebrown\", 0x8b4513)\n      .set(\"salmon\", 0xfa8072)\n      .set(\"sandybrown\", 0xf4a460)\n      .set(\"seagreen\", 0x2e8b57)\n      .set(\"seashell\", 0xfff5ee)\n      .set(\"sienna\", 0xa0522d)\n      .set(\"silver\", 0xc0c0c0)\n      .set(\"skyblue\", 0x87ceeb)\n      .set(\"slateblue\", 0x6a5acd)\n      .set(\"slategray\", 0x708090)\n      .set(\"slategrey\", 0x708090)\n      .set(\"snow\", 0xfffafa)\n      .set(\"springgreen\", 0x00ff7f)\n      .set(\"steelblue\", 0x4682b4)\n      .set(\"tan\", 0xd2b48c)\n      .set(\"teal\", 0x008080)\n      .set(\"thistle\", 0xd8bfd8)\n      .set(\"tomato\", 0xff6347)\n      .set(\"turquoise\", 0x40e0d0)\n      .set(\"violet\", 0xee82ee)\n      .set(\"wheat\", 0xf5deb3)\n      .set(\"white\", 0xffffff)\n      .set(\"whitesmoke\", 0xf5f5f5)\n      .set(\"yellow\", 0xffff00)\n      .set(\"yellowgreen\", 0x9acd32);\n\n  var darker = .7;\n  var brighter = 1 / darker;\n\n  function rgb(r, g, b) {\n    if (arguments.length === 1) {\n      if (!(r instanceof Color)) r = color(r);\n      if (r) {\n        r = r.rgb();\n        b = r.b;\n        g = r.g;\n        r = r.r;\n      } else {\n        r = g = b = NaN;\n      }\n    }\n    return new Rgb(r, g, b);\n  }\n\n  function Rgb(r, g, b) {\n    this.r = +r;\n    this.g = +g;\n    this.b = +b;\n  }\n\n  var _prototype = rgb.prototype = Rgb.prototype = new Color;\n\n  _prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k);\n  };\n\n  _prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k);\n  };\n\n  _prototype.rgb = function() {\n    return this;\n  };\n\n  _prototype.displayable = function() {\n    return (0 <= this.r && this.r <= 255)\n        && (0 <= this.g && this.g <= 255)\n        && (0 <= this.b && this.b <= 255);\n  };\n\n  _prototype.toString = function() {\n    return format(this.r, this.g, this.b);\n  };\n\n  function format(r, g, b) {\n    return \"#\"\n        + (isNaN(r) ? \"00\" : (r = Math.round(r)) < 16 ? \"0\" + Math.max(0, r).toString(16) : Math.min(255, r).toString(16))\n        + (isNaN(g) ? \"00\" : (g = Math.round(g)) < 16 ? \"0\" + Math.max(0, g).toString(16) : Math.min(255, g).toString(16))\n        + (isNaN(b) ? \"00\" : (b = Math.round(b)) < 16 ? \"0\" + Math.max(0, b).toString(16) : Math.min(255, b).toString(16));\n  }\n\n  function hsl(h, s, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Hsl) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n      } else {\n        if (!(h instanceof Color)) h = color(h);\n        if (h) {\n          if (h instanceof Hsl) return h;\n          h = h.rgb();\n          var r = h.r / 255,\n              g = h.g / 255,\n              b = h.b / 255,\n              min = Math.min(r, g, b),\n              max = Math.max(r, g, b),\n              range = max - min;\n          l = (max + min) / 2;\n          if (range) {\n            s = l < .5 ? range / (max + min) : range / (2 - max - min);\n            if (r === max) h = (g - b) / range + (g < b) * 6;\n            else if (g === max) h = (b - r) / range + 2;\n            else h = (r - g) / range + 4;\n            h *= 60;\n          } else {\n            h = NaN;\n            s = l > 0 && l < 1 ? 0 : h;\n          }\n        } else {\n          h = s = l = NaN;\n        }\n      }\n    }\n    return new Hsl(h, s, l);\n  }\n\n  function Hsl(h, s, l) {\n    this.h = +h;\n    this.s = +s;\n    this.l = +l;\n  }\n\n  var __prototype = hsl.prototype = Hsl.prototype = new Color;\n\n  __prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Hsl(this.h, this.s, this.l * k);\n  };\n\n  __prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Hsl(this.h, this.s, this.l * k);\n  };\n\n  __prototype.rgb = function() {\n    var h = this.h % 360 + (this.h < 0) * 360,\n        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,\n        l = this.l,\n        m2 = l + (l < .5 ? l : 1 - l) * s,\n        m1 = 2 * l - m2;\n    return new Rgb(\n      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),\n      hsl2rgb(h, m1, m2),\n      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2)\n    );\n  };\n\n  __prototype.displayable = function() {\n    return (0 <= this.s && this.s <= 1 || isNaN(this.s))\n        && (0 <= this.l && this.l <= 1);\n  };\n\n  /* From FvD 13.37, CSS Color Module Level 3 */\n  function hsl2rgb(h, m1, m2) {\n    return (h < 60 ? m1 + (m2 - m1) * h / 60\n        : h < 180 ? m2\n        : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60\n        : m1) * 255;\n  }\n\n  var Kn = 18;\n\n  var Xn = 0.950470;\n  var Yn = 1;\n  var Zn = 1.088830;\n  var t0 = 4 / 29;\n  var t1 = 6 / 29;\n  var t2 = 3 * t1 * t1;\n  var t3 = t1 * t1 * t1;\n\n  function lab(l, a, b) {\n    if (arguments.length === 1) {\n      if (l instanceof Lab) {\n        b = l.b;\n        a = l.a;\n        l = l.l;\n      } else if (l instanceof Hcl) {\n        var h = l.h * deg2rad;\n        b = Math.sin(h) * l.c;\n        a = Math.cos(h) * l.c;\n        l = l.l;\n      } else {\n        if (!(l instanceof Rgb)) l = rgb(l);\n        var r = rgb2xyz(l.r),\n            g = rgb2xyz(l.g),\n            b = rgb2xyz(l.b),\n            x = xyz2lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / Xn),\n            y = xyz2lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / Yn),\n            z = xyz2lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / Zn);\n        b = 200 * (y - z);\n        a = 500 * (x - y);\n        l = 116 * y - 16;\n      }\n    }\n    return new Lab(l, a, b);\n  }\n\n  function Lab(l, a, b) {\n    this.l = +l;\n    this.a = +a;\n    this.b = +b;\n  }\n\n  var ___prototype = lab.prototype = Lab.prototype = new Color;\n\n  ___prototype.brighter = function(k) {\n    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b);\n  };\n\n  ___prototype.darker = function(k) {\n    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b);\n  };\n\n  ___prototype.rgb = function() {\n    var y = (this.l + 16) / 116,\n        x = isNaN(this.a) ? y : y + this.a / 500,\n        z = isNaN(this.b) ? y : y - this.b / 200;\n    y = Yn * lab2xyz(y);\n    x = Xn * lab2xyz(x);\n    z = Zn * lab2xyz(z);\n    return new Rgb(\n      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB\n      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),\n      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z)\n    );\n  };\n\n  function xyz2lab(t) {\n    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n  }\n\n  function lab2xyz(t) {\n    return t > t1 ? t * t * t : t2 * (t - t0);\n  }\n\n  function xyz2rgb(x) {\n    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n  }\n\n  function rgb2xyz(x) {\n    return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n  }\n\n  var deg2rad = Math.PI / 180;\n  var rad2deg = 180 / Math.PI;\n\n  function hcl(h, c, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Hcl) {\n        l = h.l;\n        c = h.c;\n        h = h.h;\n      } else {\n        if (!(h instanceof Lab)) h = lab(h);\n        l = h.l;\n        c = Math.sqrt(h.a * h.a + h.b * h.b);\n        h = Math.atan2(h.b, h.a) * rad2deg;\n        if (h < 0) h += 360;\n      }\n    }\n    return new Hcl(h, c, l);\n  }\n\n  function Hcl(h, c, l) {\n    this.h = +h;\n    this.c = +c;\n    this.l = +l;\n  }\n\n  var ____prototype = hcl.prototype = Hcl.prototype = new Color;\n\n  ____prototype.brighter = function(k) {\n    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k));\n  };\n\n  ____prototype.darker = function(k) {\n    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k));\n  };\n\n  ____prototype.rgb = function() {\n    return lab(this).rgb();\n  };\n\n  var A = -0.14861;\n  var B = +1.78277;\n  var C = -0.29227;\n  var D = -0.90649;\n  var E = +1.97294;\n  var ED = E * D;\n  var EB = E * B;\n  var BC_DA = B * C - D * A;\n\n  function cubehelix(h, s, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Cubehelix) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n      } else {\n        if (!(h instanceof Rgb)) h = rgb(h);\n        var r = h.r / 255, g = h.g / 255, b = h.b / 255;\n        l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB);\n        var bl = b - l, k = (E * (g - l) - C * bl) / D;\n        s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)); // NaN if l=0 or l=1\n        h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;\n        if (h < 0) h += 360;\n      }\n    }\n    return new Cubehelix(h, s, l);\n  }\n\n  function Cubehelix(h, s, l) {\n    this.h = +h;\n    this.s = +s;\n    this.l = +l;\n  }\n\n  var prototype = cubehelix.prototype = Cubehelix.prototype = new Color;\n\n  prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Cubehelix(this.h, this.s, this.l * k);\n  };\n\n  prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Cubehelix(this.h, this.s, this.l * k);\n  };\n\n  prototype.rgb = function() {\n    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,\n        l = +this.l,\n        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),\n        cosh = Math.cos(h),\n        sinh = Math.sin(h);\n    return new Rgb(\n      255 * (l + a * (A * cosh + B * sinh)),\n      255 * (l + a * (C * cosh + D * sinh)),\n      255 * (l + a * (E * cosh))\n    );\n  };\n\n  function interpolateCubehelixGamma(gamma) {\n    return function(a, b) {\n      a = cubehelix(a);\n      b = cubehelix(b);\n      var ah = isNaN(a.h) ? b.h : a.h,\n          as = isNaN(a.s) ? b.s : a.s,\n          al = a.l,\n          bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n          bs = isNaN(b.s) ? 0 : b.s - as,\n          bl = b.l - al;\n      return function(t) {\n        a.h = ah + bh * t;\n        a.s = as + bs * t;\n        a.l = al + bl * Math.pow(t, gamma);\n        return a + \"\";\n      };\n    };\n  }\n\n  function interpolateCubehelixGammaLong(gamma) {\n    return function(a, b) {\n      a = cubehelix(a);\n      b = cubehelix(b);\n      var ah = isNaN(a.h) ? b.h : a.h,\n          as = isNaN(a.s) ? b.s : a.s,\n          al = a.l,\n          bh = isNaN(b.h) ? 0 : b.h - ah,\n          bs = isNaN(b.s) ? 0 : b.s - as,\n          bl = b.l - al;\n      return function(t) {\n        a.h = ah + bh * t;\n        a.s = as + bs * t;\n        a.l = al + bl * Math.pow(t, gamma);\n        return a + \"\";\n      };\n    };\n  }\n\n  function interpolateHclLong(a, b) {\n    a = hcl(a);\n    b = hcl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        ac = isNaN(a.c) ? b.c : a.c,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : b.h - ah,\n        bc = isNaN(b.c) ? 0 : b.c - ac,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.c = ac + bc * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHcl(a, b) {\n    a = hcl(a);\n    b = hcl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        ac = isNaN(a.c) ? b.c : a.c,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n        bc = isNaN(b.c) ? 0 : b.c - ac,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.c = ac + bc * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateLab(a, b) {\n    a = lab(a);\n    b = lab(b);\n    var al = a.l,\n        aa = a.a,\n        ab = a.b,\n        bl = b.l - al,\n        ba = b.a - aa,\n        bb = b.b - ab;\n    return function(t) {\n      a.l = al + bl * t;\n      a.a = aa + ba * t;\n      a.b = ab + bb * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHslLong(a, b) {\n    a = hsl(a);\n    b = hsl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : b.h - ah,\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHsl(a, b) {\n    a = hsl(a);\n    b = hsl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateRgb(a, b) {\n    a = rgb(a);\n    b = rgb(b);\n    var ar = a.r,\n        ag = a.g,\n        ab = a.b,\n        br = b.r - ar,\n        bg = b.g - ag,\n        bb = b.b - ab;\n    return function(t) {\n      return format(Math.round(ar + br * t), Math.round(ag + bg * t), Math.round(ab + bb * t));\n    };\n  }\n\n  exports.interpolateCubehelix = interpolateCubehelixGamma(1);\n  exports.interpolateCubehelixLong = interpolateCubehelixGammaLong(1);\n\n  exports.color = color;\n  exports.rgb = rgb;\n  exports.hsl = hsl;\n  exports.lab = lab;\n  exports.hcl = hcl;\n  exports.cubehelix = cubehelix;\n  exports.interpolateRgb = interpolateRgb;\n  exports.interpolateHsl = interpolateHsl;\n  exports.interpolateHslLong = interpolateHslLong;\n  exports.interpolateLab = interpolateLab;\n  exports.interpolateHcl = interpolateHcl;\n  exports.interpolateHclLong = interpolateHclLong;\n  exports.interpolateCubehelixGamma = interpolateCubehelixGamma;\n  exports.interpolateCubehelixGammaLong = interpolateCubehelixGammaLong;\n\n}));\n},{}],5:[function(require,module,exports){\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.format = {}));\n}(this, function (exports) { 'use strict';\n\n  var prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\n\n  // Computes the decimal coefficient and exponent of the specified number x with\n  // significant digits p, where x is positive and p is in [1, 21] or undefined.\n  // For example, formatDecimal(1.23) returns [\"123\", 0].\n  function formatDecimal(x, p) {\n    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, Infinity\n    var i, coefficient = x.slice(0, i);\n\n    // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n    // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n    return [\n      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n      +x.slice(i + 1)\n    ];\n  }\n\n  function exponent(x) {\n    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;\n  }\n\n  var prefixExponent;\n\n  function formatPrefixAuto(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1],\n        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n        n = coefficient.length;\n    return i === n ? coefficient\n        : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n        : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n        : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimal(x, p + i - 1)[0]; // less than 1y!\n  }\n\n  function formatRounded(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1];\n    return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n        : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n  }\n\n  function formatDefault(x, p) {\n    x = x.toPrecision(p);\n\n    out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {\n      switch (x[i]) {\n        case \".\": i0 = i1 = i; break;\n        case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n        case \"e\": break out;\n        default: if (i0 > 0) i0 = 0; break;\n      }\n    }\n\n    return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;\n  }\n\n  var formatTypes = {\n    \"\": formatDefault,\n    \"%\": function(x, p) { return (x * 100).toFixed(p); },\n    \"b\": function(x) { return Math.round(x).toString(2); },\n    \"c\": function(x) { return x + \"\"; },\n    \"d\": function(x) { return Math.round(x).toString(10); },\n    \"e\": function(x, p) { return x.toExponential(p); },\n    \"f\": function(x, p) { return x.toFixed(p); },\n    \"g\": function(x, p) { return x.toPrecision(p); },\n    \"o\": function(x) { return Math.round(x).toString(8); },\n    \"p\": function(x, p) { return formatRounded(x * 100, p); },\n    \"r\": formatRounded,\n    \"s\": formatPrefixAuto,\n    \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n    \"x\": function(x) { return Math.round(x).toString(16); }\n  };\n\n\n  // [[fill]align][sign][symbol][0][width][,][.precision][type]\n  var re = /^(?:(.)?([<>=^]))?([+\\-\\( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?([a-z%])?$/i;\n\n  function FormatSpecifier(specifier) {\n    if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n\n    var match,\n        fill = match[1] || \" \",\n        align = match[2] || \">\",\n        sign = match[3] || \"-\",\n        symbol = match[4] || \"\",\n        zero = !!match[5],\n        width = match[6] && +match[6],\n        comma = !!match[7],\n        precision = match[8] && +match[8].slice(1),\n        type = match[9] || \"\";\n\n    // The \"n\" type is an alias for \",g\".\n    if (type === \"n\") comma = true, type = \"g\";\n\n    // Map invalid types to the default format.\n    else if (!formatTypes[type]) type = \"\";\n\n    // If zero fill is specified, padding goes after sign and before digits.\n    if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n    this.fill = fill;\n    this.align = align;\n    this.sign = sign;\n    this.symbol = symbol;\n    this.zero = zero;\n    this.width = width;\n    this.comma = comma;\n    this.precision = precision;\n    this.type = type;\n  }\n\n  FormatSpecifier.prototype.toString = function() {\n    return this.fill\n        + this.align\n        + this.sign\n        + this.symbol\n        + (this.zero ? \"0\" : \"\")\n        + (this.width == null ? \"\" : Math.max(1, this.width | 0))\n        + (this.comma ? \",\" : \"\")\n        + (this.precision == null ? \"\" : \".\" + Math.max(0, this.precision | 0))\n        + this.type;\n  };\n\n  function formatSpecifier(specifier) {\n    return new FormatSpecifier(specifier);\n  }\n\n  function identity(x) {\n    return x;\n  }\n\n  function formatGroup(grouping, thousands) {\n    return function(value, width) {\n      var i = value.length,\n          t = [],\n          j = 0,\n          g = grouping[0],\n          length = 0;\n\n      while (i > 0 && g > 0) {\n        if (length + g + 1 > width) g = Math.max(1, width - length);\n        t.push(value.substring(i -= g, i + g));\n        if ((length += g + 1) > width) break;\n        g = grouping[j = (j + 1) % grouping.length];\n      }\n\n      return t.reverse().join(thousands);\n    };\n  }\n\n  function localeFormat(locale) {\n    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,\n        currency = locale.currency,\n        decimal = locale.decimal;\n\n    function format(specifier) {\n      specifier = formatSpecifier(specifier);\n\n      var fill = specifier.fill,\n          align = specifier.align,\n          sign = specifier.sign,\n          symbol = specifier.symbol,\n          zero = specifier.zero,\n          width = specifier.width,\n          comma = specifier.comma,\n          precision = specifier.precision,\n          type = specifier.type;\n\n      // Compute the prefix and suffix.\n      // For SI-prefix, the suffix is lazily computed.\n      var prefix = symbol === \"$\" ? currency[0] : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n          suffix = symbol === \"$\" ? currency[1] : /[%p]/.test(type) ? \"%\" : \"\";\n\n      // What format function should we use?\n      // Is this an integer type?\n      // Can this type generate exponential notation?\n      var formatType = formatTypes[type],\n          maybeSuffix = !type || /[defgprs%]/.test(type);\n\n      // Set the default precision if not specified,\n      // or clamp the specified precision to the supported range.\n      // For significant precision, it must be in [1, 21].\n      // For fixed precision, it must be in [0, 20].\n      precision = precision == null ? (type ? 6 : 12)\n          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n          : Math.max(0, Math.min(20, precision));\n\n      return function(value) {\n        var valuePrefix = prefix,\n            valueSuffix = suffix;\n\n        if (type === \"c\") {\n          valueSuffix = formatType(value) + valueSuffix;\n          value = \"\";\n        } else {\n          value = +value;\n\n          // Convert negative to positive, and compute the prefix.\n          // Note that -0 is not less than 0, but 1 / -0 is!\n          var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);\n\n          // Perform the initial formatting.\n          value = formatType(value, precision);\n\n          // Compute the prefix and suffix.\n          valuePrefix = (valueNegative ? (sign === \"(\" ? sign : \"-\") : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n          valueSuffix = valueSuffix + (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n          // Break the formatted value into the integer value part that can be\n          // grouped, and fractional or exponential suffix part that is not.\n          if (maybeSuffix) {\n            var i = -1, n = value.length, c;\n            while (++i < n) {\n              if (c = value.charCodeAt(i), 48 > c || c > 57) {\n                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n                value = value.slice(0, i);\n                break;\n              }\n            }\n          }\n        }\n\n        // If the fill character is not \"0\", grouping is applied before padding.\n        if (comma && !zero) value = group(value, Infinity);\n\n        // Compute the padding.\n        var length = valuePrefix.length + value.length + valueSuffix.length,\n            padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n        // If the fill character is \"0\", grouping is applied after padding.\n        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n        // Reconstruct the final output based on the desired alignment.\n        switch (align) {\n          case \"<\": return valuePrefix + value + valueSuffix + padding;\n          case \"=\": return valuePrefix + padding + value + valueSuffix;\n          case \"^\": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);\n        }\n        return padding + valuePrefix + value + valueSuffix;\n      };\n    }\n\n    function formatPrefix(specifier, value) {\n      var f = format((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,\n          k = Math.pow(10, -e),\n          prefix = prefixes[8 + e / 3];\n      return function(value) {\n        return f(k * value) + prefix;\n      };\n    }\n\n    return {\n      format: format,\n      formatPrefix: formatPrefix\n    };\n  }\n\n  var locale = localeFormat({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"$\", \"\"]\n  });\n\n  exports.format = locale.format;\n  exports.formatPrefix = locale.formatPrefix;\n\n  function precisionRound(step, max) {\n    return Math.max(0, exponent(Math.abs(max)) - exponent(Math.abs(step))) + 1;\n  }\n\n  function precisionPrefix(step, value) {\n    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));\n  }\n\n  function precisionFixed(step) {\n    return Math.max(0, -exponent(Math.abs(step)));\n  }\n\n  exports.formatSpecifier = formatSpecifier;\n  exports.localeFormat = localeFormat;\n  exports.precisionFixed = precisionFixed;\n  exports.precisionPrefix = precisionPrefix;\n  exports.precisionRound = precisionRound;\n\n}));\n},{}],6:[function(require,module,exports){\nif (typeof Map === \"undefined\") {\n  Map = function() { this.clear(); };\n  Map.prototype = {\n    set: function(k, v) { this._[k] = v; return this; },\n    get: function(k) { return this._[k]; },\n    has: function(k) { return k in this._; },\n    delete: function(k) { return k in this._ && delete this._[k]; },\n    clear: function() { this._ = Object.create(null); },\n    get size() { var n = 0; for (var k in this._) ++n; return n; },\n    forEach: function(c) { for (var k in this._) c(this._[k], k, this); }\n  };\n} else (function() {\n  var m = new Map;\n  if (m.set(0, 0) !== m) {\n    m = m.set;\n    Map.prototype.set = function() { m.apply(this, arguments); return this; };\n  }\n})();\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.timeFormat = {}));\n}(this, function (exports) { 'use strict';\n\n  function utcDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n      date.setUTCFullYear(d.y);\n      return date;\n    }\n    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n  }\n\n  function localDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n      date.setFullYear(d.y);\n      return date;\n    }\n    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n  }\n\n  var pads = {\"-\": \"\", \"_\": \" \", \"0\": \"0\"};\n\n  function newYear(y) {\n    return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};\n  }\n\n  var percentRe = /^%/;\n\n  function parseLiteralPercent(d, string, i) {\n    var n = percentRe.exec(string.slice(i, i + 1));\n    return n ? i + n[0].length : -1;\n  }\n\n  function parseZone(d, string, i) {\n    return /^[+-]\\d{4}$/.test(string = string.slice(i, i + 5))\n        ? (d.Z = -string, i + 5) // sign differs from getTimezoneOffset!\n        : -1;\n  }\n\n  var numberRe = /^\\s*\\d+/;\n\n  function parseWeekdayNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 1));\n    return n ? (d.w = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberSunday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.U = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberMonday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.W = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n  }\n\n  function parseMonthNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n  }\n\n  function parseDayOfMonth(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseDayOfYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseHour24(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.H = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMinutes(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.M = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseSeconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.S = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMilliseconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.L = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseFullYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 4));\n    return n ? (d.y = +n[0], i + n[0].length) : -1;\n  }\n\n  function formatLiteralPercent() {\n    return \"%\";\n  }\n\n  function formatUTCZone() {\n    return \"+0000\";\n  }\n\n  function pad(value, fill, width) {\n    var sign = value < 0 ? \"-\" : \"\",\n        string = (sign ? -value : value) + \"\",\n        length = string.length;\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n  }\n\n  function formatUTCFullYear(d, p) {\n    return pad(d.getUTCFullYear() % 10000, p, 4);\n  }\n\n  function formatUTCYear(d, p) {\n    return pad(d.getUTCFullYear() % 100, p, 2);\n  }\n\n  var t1 = new Date;\n\n  var t0 = new Date;\n\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  }\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, offset) {\n    date.setUTCFullYear(date.getUTCFullYear() + offset);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, offset) {\n      date.setUTCDate(date.getUTCDate() + offset * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcMonday = utcWeekday(1);\n\n  function formatUTCWeekNumberMonday(d, p) {\n    return pad(utcMonday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCWeekdayNumber(d) {\n    return d.getUTCDay();\n  }\n\n  var utcSunday = utcWeekday(0);\n\n  function formatUTCWeekNumberSunday(d, p) {\n    return pad(utcSunday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCSeconds(d, p) {\n    return pad(d.getUTCSeconds(), p, 2);\n  }\n\n  function formatUTCMinutes(d, p) {\n    return pad(d.getUTCMinutes(), p, 2);\n  }\n\n  function formatUTCMonthNumber(d, p) {\n    return pad(d.getUTCMonth() + 1, p, 2);\n  }\n\n  function formatUTCMilliseconds(d, p) {\n    return pad(d.getUTCMilliseconds(), p, 3);\n  }\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, offset) {\n    date.setUTCDate(date.getUTCDate() + offset);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  function formatUTCDayOfYear(d, p) {\n    return pad(1 + utcDay.count(utcYear(d), d), p, 3);\n  }\n\n  function formatUTCHour12(d, p) {\n    return pad(d.getUTCHours() % 12 || 12, p, 2);\n  }\n\n  function formatUTCHour24(d, p) {\n    return pad(d.getUTCHours(), p, 2);\n  }\n\n  function formatUTCDayOfMonth(d, p) {\n    return pad(d.getUTCDate(), p, 2);\n  }\n\n  function formatZone(d) {\n    var z = d.getTimezoneOffset();\n    return (z > 0 ? \"-\" : (z *= -1, \"+\"))\n        + pad(z / 60 | 0, \"0\", 2)\n        + pad(z % 60, \"0\", 2);\n  }\n\n  function formatFullYear(d, p) {\n    return pad(d.getFullYear() % 10000, p, 4);\n  }\n\n  function formatYear(d, p) {\n    return pad(d.getFullYear() % 100, p, 2);\n  }\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, offset) {\n    date.setFullYear(date.getFullYear() + offset);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, offset) {\n      date.setDate(date.getDate() + offset * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var monday = weekday(1);\n\n  function formatWeekNumberMonday(d, p) {\n    return pad(monday.count(year(d), d), p, 2);\n  }\n\n  function formatWeekdayNumber(d) {\n    return d.getDay();\n  }\n\n  var sunday = weekday(0);\n\n  function formatWeekNumberSunday(d, p) {\n    return pad(sunday.count(year(d), d), p, 2);\n  }\n\n  function formatSeconds(d, p) {\n    return pad(d.getSeconds(), p, 2);\n  }\n\n  function formatMinutes(d, p) {\n    return pad(d.getMinutes(), p, 2);\n  }\n\n  function formatMonthNumber(d, p) {\n    return pad(d.getMonth() + 1, p, 2);\n  }\n\n  function formatMilliseconds(d, p) {\n    return pad(d.getMilliseconds(), p, 3);\n  }\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, offset) {\n    date.setDate(date.getDate() + offset);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  function formatDayOfYear(d, p) {\n    return pad(1 + day.count(year(d), d), p, 3);\n  }\n\n  function formatHour12(d, p) {\n    return pad(d.getHours() % 12 || 12, p, 2);\n  }\n\n  function formatHour24(d, p) {\n    return pad(d.getHours(), p, 2);\n  }\n\n  function formatDayOfMonth(d, p) {\n    return pad(d.getDate(), p, 2);\n  }\n\n  function formatLookup(names) {\n    var map = new Map, i = -1, n = names.length;\n    while (++i < n) map.set(names[i].toLowerCase(), i);\n    return map;\n  }\n\n  var requoteRe = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\n  function requote(s) {\n    return s.replace(requoteRe, \"\\\\$&\");\n  }\n\n  function formatRe(names) {\n    return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n  }\n\n  function localeFormat(locale) {\n    var locale_dateTime = locale.dateTime,\n        locale_date = locale.date,\n        locale_time = locale.time,\n        locale_periods = locale.periods,\n        locale_weekdays = locale.days,\n        locale_shortWeekdays = locale.shortDays,\n        locale_months = locale.months,\n        locale_shortMonths = locale.shortMonths;\n\n    var periodLookup = formatLookup(locale_periods),\n        weekdayRe = formatRe(locale_weekdays),\n        weekdayLookup = formatLookup(locale_weekdays),\n        shortWeekdayRe = formatRe(locale_shortWeekdays),\n        shortWeekdayLookup = formatLookup(locale_shortWeekdays),\n        monthRe = formatRe(locale_months),\n        monthLookup = formatLookup(locale_months),\n        shortMonthRe = formatRe(locale_shortMonths),\n        shortMonthLookup = formatLookup(locale_shortMonths);\n\n    var formats = {\n      \"a\": formatShortWeekday,\n      \"A\": formatWeekday,\n      \"b\": formatShortMonth,\n      \"B\": formatMonth,\n      \"c\": null,\n      \"d\": formatDayOfMonth,\n      \"e\": formatDayOfMonth,\n      \"H\": formatHour24,\n      \"I\": formatHour12,\n      \"j\": formatDayOfYear,\n      \"L\": formatMilliseconds,\n      \"m\": formatMonthNumber,\n      \"M\": formatMinutes,\n      \"p\": formatPeriod,\n      \"S\": formatSeconds,\n      \"U\": formatWeekNumberSunday,\n      \"w\": formatWeekdayNumber,\n      \"W\": formatWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatYear,\n      \"Y\": formatFullYear,\n      \"Z\": formatZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var utcFormats = {\n      \"a\": formatUTCShortWeekday,\n      \"A\": formatUTCWeekday,\n      \"b\": formatUTCShortMonth,\n      \"B\": formatUTCMonth,\n      \"c\": null,\n      \"d\": formatUTCDayOfMonth,\n      \"e\": formatUTCDayOfMonth,\n      \"H\": formatUTCHour24,\n      \"I\": formatUTCHour12,\n      \"j\": formatUTCDayOfYear,\n      \"L\": formatUTCMilliseconds,\n      \"m\": formatUTCMonthNumber,\n      \"M\": formatUTCMinutes,\n      \"p\": formatUTCPeriod,\n      \"S\": formatUTCSeconds,\n      \"U\": formatUTCWeekNumberSunday,\n      \"w\": formatUTCWeekdayNumber,\n      \"W\": formatUTCWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatUTCYear,\n      \"Y\": formatUTCFullYear,\n      \"Z\": formatUTCZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var parses = {\n      \"a\": parseShortWeekday,\n      \"A\": parseWeekday,\n      \"b\": parseShortMonth,\n      \"B\": parseMonth,\n      \"c\": parseLocaleDateTime,\n      \"d\": parseDayOfMonth,\n      \"e\": parseDayOfMonth,\n      \"H\": parseHour24,\n      \"I\": parseHour24,\n      \"j\": parseDayOfYear,\n      \"L\": parseMilliseconds,\n      \"m\": parseMonthNumber,\n      \"M\": parseMinutes,\n      \"p\": parsePeriod,\n      \"S\": parseSeconds,\n      \"U\": parseWeekNumberSunday,\n      \"w\": parseWeekdayNumber,\n      \"W\": parseWeekNumberMonday,\n      \"x\": parseLocaleDate,\n      \"X\": parseLocaleTime,\n      \"y\": parseYear,\n      \"Y\": parseFullYear,\n      \"Z\": parseZone,\n      \"%\": parseLiteralPercent\n    };\n\n    // These recursive directive definitions must be deferred.\n    formats.x = newFormat(locale_date, formats);\n    formats.X = newFormat(locale_time, formats);\n    formats.c = newFormat(locale_dateTime, formats);\n    utcFormats.x = newFormat(locale_date, utcFormats);\n    utcFormats.X = newFormat(locale_time, utcFormats);\n    utcFormats.c = newFormat(locale_dateTime, utcFormats);\n\n    function newFormat(specifier, formats) {\n      return function(date) {\n        var string = [],\n            i = -1,\n            j = 0,\n            n = specifier.length,\n            c,\n            pad,\n            format;\n\n        while (++i < n) {\n          if (specifier.charCodeAt(i) === 37) {\n            string.push(specifier.slice(j, i));\n            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);\n            if (format = formats[c]) c = format(date, pad == null ? (c === \"e\" ? \" \" : \"0\") : pad);\n            string.push(c);\n            j = i + 1;\n          }\n        }\n\n        string.push(specifier.slice(j, i));\n        return string.join(\"\");\n      };\n    }\n\n    function newParse(specifier, newDate) {\n      return function(string) {\n        var d = newYear(1900),\n            i = parseSpecifier(d, specifier, string, 0);\n        if (i != string.length) return null;\n\n        // The am-pm flag is 0 for AM, and 1 for PM.\n        if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\n        // If a time zone is specified, all fields are interpreted as UTC and then\n        // offset according to the specified time zone.\n        if (\"Z\" in d) {\n          if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n            var day = utcDate(newYear(d.y)).getUTCDay();\n            if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n            d.m = 0;\n            d.d = d.w + d.U * 7 - (day + 6) % 7;\n          }\n          d.H += d.Z / 100 | 0;\n          d.M += d.Z % 100;\n          return utcDate(d);\n        }\n\n        // Otherwise, all fields are in local time.\n        if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n          var day = newDate(newYear(d.y)).getDay();\n          if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n          d.m = 0;\n          d.d = d.w + d.U * 7 - (day + 6) % 7;\n        }\n        return newDate(d);\n      };\n    }\n\n    function parseSpecifier(d, specifier, string, j) {\n      var i = 0,\n          n = specifier.length,\n          m = string.length,\n          c,\n          parse;\n\n      while (i < n) {\n        if (j >= m) return -1;\n        c = specifier.charCodeAt(i++);\n        if (c === 37) {\n          c = specifier.charAt(i++);\n          parse = parses[c in pads ? specifier.charAt(i++) : c];\n          if (!parse || ((j = parse(d, string, j)) < 0)) return -1;\n        } else if (c != string.charCodeAt(j++)) {\n          return -1;\n        }\n      }\n\n      return j;\n    }\n\n    function parseShortWeekday(d, string, i) {\n      var n = shortWeekdayRe.exec(string.slice(i));\n      return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseWeekday(d, string, i) {\n      var n = weekdayRe.exec(string.slice(i));\n      return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseShortMonth(d, string, i) {\n      var n = shortMonthRe.exec(string.slice(i));\n      return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseMonth(d, string, i) {\n      var n = monthRe.exec(string.slice(i));\n      return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseLocaleDateTime(d, string, i) {\n      return parseSpecifier(d, locale_dateTime, string, i);\n    }\n\n    function parseLocaleDate(d, string, i) {\n      return parseSpecifier(d, locale_date, string, i);\n    }\n\n    function parseLocaleTime(d, string, i) {\n      return parseSpecifier(d, locale_time, string, i);\n    }\n\n    function parsePeriod(d, string, i) {\n      var n = periodLookup.get(string.slice(i, i += 2).toLowerCase());\n      return n == null ? -1 : (d.p = n, i);\n    }\n\n    function formatShortWeekday(d) {\n      return locale_shortWeekdays[d.getDay()];\n    }\n\n    function formatWeekday(d) {\n      return locale_weekdays[d.getDay()];\n    }\n\n    function formatShortMonth(d) {\n      return locale_shortMonths[d.getMonth()];\n    }\n\n    function formatMonth(d) {\n      return locale_months[d.getMonth()];\n    }\n\n    function formatPeriod(d) {\n      return locale_periods[+(d.getHours() >= 12)];\n    }\n\n    function formatUTCShortWeekday(d) {\n      return locale_shortWeekdays[d.getUTCDay()];\n    }\n\n    function formatUTCWeekday(d) {\n      return locale_weekdays[d.getUTCDay()];\n    }\n\n    function formatUTCShortMonth(d) {\n      return locale_shortMonths[d.getUTCMonth()];\n    }\n\n    function formatUTCMonth(d) {\n      return locale_months[d.getUTCMonth()];\n    }\n\n    function formatUTCPeriod(d) {\n      return locale_periods[+(d.getUTCHours() >= 12)];\n    }\n\n    return {\n      format: function(specifier) {\n        var f = newFormat(specifier += \"\", formats);\n        f.parse = newParse(specifier, localDate);\n        f.toString = function() { return specifier; };\n        return f;\n      },\n      utcFormat: function(specifier) {\n        var f = newFormat(specifier += \"\", utcFormats);\n        f.parse = newParse(specifier, utcDate);\n        f.toString = function() { return specifier; };\n        return f;\n      }\n    };\n  }\n\n  var locale = localeFormat({\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%m/%d/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  });\n\n  exports.format = locale.format;\n  exports.utcFormat = locale.utcFormat;\n\n  var isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\n\n  function formatIsoNative(date) {\n    return date.toISOString();\n  }\n\n  formatIsoNative.parse = function(string) {\n    var date = new Date(string);\n    return isNaN(date) ? null : date;\n  };\n\n  formatIsoNative.toString = function() {\n    return isoSpecifier;\n  };\n\n  var formatIso = Date.prototype.toISOString && +new Date(\"2000-01-01T00:00:00.000Z\")\n      ? formatIsoNative\n      : locale.utcFormat(isoSpecifier);\n\n  var isoFormat = formatIso;\n\n  exports.isoFormat = isoFormat;\n  exports.localeFormat = localeFormat;\n\n}));\n},{}],7:[function(require,module,exports){\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t1 = new Date;\n\n  var t0 = new Date;\n\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  }\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  exports.seconds = second.range;\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  exports.minutes = minute.range;\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  exports.hours = hour.range;\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  exports.days = day.range;\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  exports.sunday = weekday(0);\n\n  exports.sundays = exports.sunday.range;\n\n  exports.monday = weekday(1);\n\n  exports.mondays = exports.monday.range;\n\n  exports.tuesday = weekday(2);\n\n  exports.tuesdays = exports.tuesday.range;\n\n  exports.wednesday = weekday(3);\n\n  exports.wednesdays = exports.wednesday.range;\n\n  exports.thursday = weekday(4);\n\n  exports.thursdays = exports.thursday.range;\n\n  exports.friday = weekday(5);\n\n  exports.fridays = exports.friday.range;\n\n  exports.saturday = weekday(6);\n\n  exports.saturdays = exports.saturday.range;\n\n  var week = exports.sunday;\n\n  exports.weeks = week.range;\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  });\n\n  exports.months = month.range;\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  exports.years = year.range;\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  exports.utcSeconds = utcSecond.range;\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  exports.utcMinutes = utcMinute.range;\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  exports.utcHours = utcHour.range;\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  exports.utcDays = utcDay.range;\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  exports.utcSunday = utcWeekday(0);\n\n  exports.utcSundays = exports.utcSunday.range;\n\n  exports.utcMonday = utcWeekday(1);\n\n  exports.utcMondays = exports.utcMonday.range;\n\n  exports.utcTuesday = utcWeekday(2);\n\n  exports.utcTuesdays = exports.utcTuesday.range;\n\n  exports.utcWednesday = utcWeekday(3);\n\n  exports.utcWednesdays = exports.utcWednesday.range;\n\n  exports.utcThursday = utcWeekday(4);\n\n  exports.utcThursdays = exports.utcThursday.range;\n\n  exports.utcFriday = utcWeekday(5);\n\n  exports.utcFridays = exports.utcFriday.range;\n\n  exports.utcSaturday = utcWeekday(6);\n\n  exports.utcSaturdays = exports.utcSaturday.range;\n\n  var utcWeek = exports.utcSunday;\n\n  exports.utcWeeks = utcWeek.range;\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  });\n\n  exports.utcMonths = utcMonth.range;\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  exports.utcYears = utcYear.range;\n\n  exports.interval = newInterval;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.week = week;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcWeek = utcWeek;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n\n}));\n},{}],8:[function(require,module,exports){\nvar util = require('../util'),\n    time = require('../time'),\n    EPSILON = 1e-15;\n\nfunction bins(opt) {\n  if (!opt) { throw Error(\"Missing binning options.\"); }\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  if (!opt) { throw Error(\"Missing date binning options.\"); }\n\n  // find time step, then bin\n  var units = opt.utc ? time.utc : time,\n      dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n\n},{\"../time\":12,\"../util\":13}],9:[function(require,module,exports){\nvar gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n},{}],10:[function(require,module,exports){\nvar util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    types[f] = infer(data, f);\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;\n},{\"../util\":13}],11:[function(require,module,exports){\nvar util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length < 2) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (v === v) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (v === v) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance] \n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;\n},{\"./generate\":9,\"./import/type\":10,\"./util\":13}],12:[function(require,module,exports){\nvar d3_time = require('d3-time');\n\nvar tempDate = new Date(),\n    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD\n    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);\n\nfunction date(d) {\n  return (tempDate.setTime(+d), tempDate);\n}\n\n// create a time unit entry\nfunction entry(type, date, unit, step, min, max) {\n  var e = {\n    type: type,\n    date: date,\n    unit: unit\n  };\n  if (step) {\n    e.step = step;\n  } else {\n    e.minstep = 1;\n  }\n  if (min != null) e.min = min;\n  if (max != null) e.max = max;\n  return e;\n}\n\nfunction create(type, unit, base, step, min, max) {\n  return entry(type,\n    function(d) { return unit.offset(base, d); },\n    function(d) { return unit.count(base, d); },\n    step, min, max);\n}\n\nvar locale = [\n  create('second', d3_time.second, baseDate),\n  create('minute', d3_time.minute, baseDate),\n  create('hour',   d3_time.hour,   baseDate),\n  create('day',    d3_time.day,    baseDate, [1, 7]),\n  create('month',  d3_time.month,  baseDate, [1, 3, 6]),\n  create('year',   d3_time.year,   baseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(1970, 0, 1, 0, 0, d); },\n    function(d) { return date(d).getSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(1970, 0, 1, 0, d); },\n    function(d) { return date(d).getMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(1970, 0, 1, d); },\n    function(d) { return date(d).getHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(1970, 0, 4+d); },\n    function(d) { return date(d).getDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(1970, 0, d); },\n    function(d) { return date(d).getDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(1970, d % 12, 1); },\n    function(d) { return date(d).getMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar utc = [\n  create('second', d3_time.utcSecond, utcBaseDate),\n  create('minute', d3_time.utcMinute, utcBaseDate),\n  create('hour',   d3_time.utcHour,   utcBaseDate),\n  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),\n  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),\n  create('year',   d3_time.utcYear,   utcBaseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },\n    function(d) { return date(d).getUTCSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },\n    function(d) { return date(d).getUTCMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },\n    function(d) { return date(d).getUTCHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },\n    function(d) { return date(d).getUTCDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(Date.UTC(1970, 0, d)); },\n    function(d) { return date(d).getUTCDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },\n    function(d) { return date(d).getUTCMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction find(units, span, minb, maxb) {\n  var step = STEPS[0], i, n, bins;\n\n  for (i=1, n=STEPS.length; i<n; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return units[STEPS[i-1][1]];\n      }\n      if (bins >= minb) {\n        return units[step[1]];\n      }\n    }\n  }\n  return units[STEPS[n-1][1]];\n}\n\nfunction toUnitMap(units) {\n  var map = {}, i, n;\n  for (i=0, n=units.length; i<n; ++i) {\n    map[units[i].type] = units[i];\n  }\n  map.find = function(span, minb, maxb) {\n    return find(units, span, minb, maxb);\n  };\n  return map;\n}\n\nmodule.exports = toUnitMap(locale);\nmodule.exports.utc = toUnitMap(utc);\n\n},{\"d3-time\":7}],13:[function(require,module,exports){\nvar buffer = require('buffer'),\n    time = require('./time'),\n    utc = time.utc;\n\nvar u = module.exports = {};\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (buffer.Buffer && buffer.Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\nu.date = function(s) {\n  return s == null || s === '' ? null : Date.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nu.field = function(f) {\n  return String(f).split('\\\\.')\n    .map(function(d) { return d.split('.'); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += '.' + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\nu.$year   = u.$func('year', time.year.unit);\nu.$month  = u.$func('month', time.months.unit);\nu.$date   = u.$func('date', time.dates.unit);\nu.$day    = u.$func('day', time.weekdays.unit);\nu.$hour   = u.$func('hour', time.hours.unit);\nu.$minute = u.$func('minute', time.minutes.unit);\nu.$second = u.$func('second', time.seconds.unit);\n\nu.$utcYear   = u.$func('utcYear', utc.year.unit);\nu.$utcMonth  = u.$func('utcMonth', utc.months.unit);\nu.$utcDate   = u.$func('utcDate', utc.dates.unit);\nu.$utcDay    = u.$func('utcDay', utc.weekdays.unit);\nu.$utcHour   = u.$func('utcHour', utc.hours.unit);\nu.$utcMinute = u.$func('utcMinute', utc.minutes.unit);\nu.$utcSecond = u.$func('utcSecond', utc.seconds.unit);\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n\n},{\"./time\":12,\"buffer\":1}],14:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  util = require('./util'),\n  vlfield = require('./field'),\n  vlenc = require('./enc'),\n  schema = require('./schema/schema');\n\nmodule.exports = (function() {\n  function Encoding(spec, theme) {\n    var defaults = schema.instantiate(),\n      specExtended = schema.util.merge(defaults, theme || {}, spec) ;\n\n    this._data = specExtended.data;\n    this._marktype = specExtended.marktype;\n    this._enc = specExtended.encoding;\n    this._config = specExtended.config;\n    this._filter = specExtended.filter;\n    // this._vega2 = true;\n  }\n\n  var proto = Encoding.prototype;\n\n  Encoding.fromShorthand = function(shorthand, data, config, theme) {\n    var c = consts.shorthand,\n        split = shorthand.split(c.delim),\n        marktype = split.shift().split(c.assign)[1].trim(),\n        enc = vlenc.fromShorthand(split);\n\n    return new Encoding({\n      data: data,\n      marktype: marktype,\n      encoding: enc,\n      config: config,\n      filter: []\n    }, theme);\n  };\n\n  Encoding.fromSpec = function(spec, theme) {\n    return new Encoding(spec, theme);\n  };\n\n  proto.toShorthand = function() {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + this._marktype +\n      c.delim + vlenc.shorthand(this._enc);\n  };\n\n  Encoding.shorthand = function (spec) {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + spec.marktype +\n      c.delim + vlenc.shorthand(spec.encoding);\n  };\n\n  Encoding.specFromShorthand = function(shorthand, data, config, excludeConfig) {\n    return Encoding.fromShorthand(shorthand, data, config).toSpec(excludeConfig);\n  };\n\n  proto.toSpec = function(excludeConfig, excludeData) {\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    spec = {\n      marktype: this._marktype,\n      encoding: enc,\n      filter: this._filter\n    };\n\n    if (!excludeConfig) {\n      spec.config = util.duplicate(this._config);\n    }\n\n    if (!excludeData) {\n      spec.data = util.duplicate(this._data);\n    }\n\n    // remove defaults\n    var defaults = schema.instantiate();\n    return schema.util.subtract(spec, defaults);\n  };\n\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(encType) {\n    // equivalent to calling vlenc.has(this._enc, encType)\n    return this._enc[encType].name !== undefined;\n  };\n\n  proto.field = function(et) {\n    return this._enc[et];\n  };\n\n  proto.filter = function() {\n    var filterNull = [],\n      fields = this.fields(),\n      self = this;\n\n    util.forEach(fields, function(fieldList, fieldName) {\n      if (fieldName === '*') return; //count\n\n      if ((self.config('filterNull').Q && fieldList.containsType[Q]) ||\n          (self.config('filterNull').T && fieldList.containsType[T]) ||\n          (self.config('filterNull').O && fieldList.containsType[O]) ||\n          (self.config('filterNull').N && fieldList.containsType[N])) {\n        filterNull.push({\n          operands: [fieldName],\n          operator: 'notNull'\n        });\n      }\n    });\n\n    return filterNull.concat(this._filter);\n  };\n\n  // get \"field\" reference for vega\n  proto.fieldRef = function(et, opt) {\n    opt = opt || {};\n    opt.data = !this._vega2 && (opt.data !== false);\n    return vlfield.fieldRef(this._enc[et], opt);\n  };\n\n  proto.fieldName = function(et) {\n    return this._enc[et].name;\n  };\n\n  /*\n   * return key-value pairs of field name and list of fields of that field name\n   */\n  proto.fields = function() {\n    return vlenc.fields(this._enc);\n  };\n\n  proto.fieldTitle = function(et) {\n    if (vlfield.isCount(this._enc[et])) {\n      return vlfield.count.displayName;\n    }\n    var fn = this._enc[et].aggregate || this._enc[et].timeUnit || (this._enc[et].bin && 'bin');\n    if (fn) {\n      return fn.toUpperCase() + '(' + this._enc[et].name + ')';\n    } else {\n      return this._enc[et].name;\n    }\n  };\n\n  proto.scale = function(et) {\n    return this._enc[et].scale || {};\n  };\n\n  proto.axis = function(et) {\n    return this._enc[et].axis || {};\n  };\n\n  proto.bandSize = function(encType, useSmallBand) {\n    useSmallBand = useSmallBand ||\n      //isBandInSmallMultiples\n      (encType === Y && this.has(ROW) && this.has(Y)) ||\n      (encType === X && this.has(COL) && this.has(X));\n\n    // if band.size is explicitly specified, follow the specification, otherwise draw value from config.\n    return this.field(encType).band.size ||\n      this.config(useSmallBand ? 'smallBandSize' : 'largeBandSize');\n  };\n\n  proto.aggregate = function(et) {\n    return this._enc[et].aggregate;\n  };\n\n  // returns false if binning is disabled, otherwise an object with binning properties\n  proto.bin = function(et) {\n    var bin = this._enc[et].bin;\n    if (bin === {})\n      return false;\n    if (bin === true)\n      return {\n        maxbins: schema.MAXBINS_DEFAULT\n      };\n    return bin;\n  };\n\n  proto.value = function(et) {\n    return this._enc[et].value;\n  };\n\n  proto.numberFormat = function(fieldStats) {\n    var formatConfig = fieldStats.max > this.config('maxSmallNumber') ?\n      'largeNumberFormat': 'smallNumberFormat';\n    return this.config(formatConfig);\n  };\n\n  proto.sort = function(et, stats) {\n    var sort = this._enc[et].sort,\n      enc = this._enc,\n      isTypes = vlfield.isTypes;\n\n    if ((!sort || sort.length===0) &&\n        // FIXME\n        Encoding.toggleSort.support({encoding:this._enc}, stats, true) && //HACK\n        this.config('toggleSort') === Q\n      ) {\n      var qField = isTypes(enc.x, [N, O]) ? enc.y : enc.x;\n\n      if (isTypes(enc[et], [N, O])) {\n        sort = [{\n          name: qField.name,\n          aggregate: qField.aggregate,\n          type: qField.type,\n          reverse: true\n        }];\n      }\n    }\n\n    return sort;\n  };\n\n  proto.map = function(f) {\n    return vlenc.map(this._enc, f);\n  };\n\n  proto.reduce = function(f, init) {\n    return vlenc.reduce(this._enc, f, init);\n  };\n\n  proto.forEach = function(f) {\n    return vlenc.forEach(this._enc, f);\n  };\n\n  proto.type = function(et) {\n    return this.has(et) ? this._enc[et].type : null;\n  };\n\n  proto.isType = function(et, type) {\n    var field = this.field(et);\n    return field && vlfield.isType(field, type);\n  };\n\n  proto.isTypes = function(et, type) {\n    var field = this.field(et);\n    return field && vlfield.isTypes(field, type);\n  };\n\n  Encoding.isOrdinalScale = function(encoding, encType) {\n    return vlfield.isOrdinalScale(encoding.field(encType));\n  };\n\n  Encoding.isDimension = function(encoding, encType) {\n    return vlfield.isDimension(encoding.field(encType));\n  };\n\n  Encoding.isMeasure = function(encoding, encType) {\n    return vlfield.isMeasure(encoding.field(encType));\n  };\n\n  proto.isOrdinalScale = function(encType) {\n    return this.has(encType) && Encoding.isOrdinalScale(this, encType);\n  };\n\n  proto.isDimension = function(encType) {\n    return this.has(encType) && Encoding.isDimension(this, encType);\n  };\n\n  proto.isMeasure = function(encType) {\n    return this.has(encType) && Encoding.isMeasure(this, encType);\n  };\n\n  proto.isAggregate = function() {\n    return vlenc.isAggregate(this._enc);\n  };\n\n  Encoding.isAggregate = function(spec) {\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.alwaysNoOcclusion = function(spec) {\n    // FIXME raw OxQ with # of rows = # of O\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.isStack = function(spec) {\n    // FIXME update this once we have control for stack ...\n    return (spec.marktype === 'bar' || spec.marktype === 'area') &&\n      spec.encoding.color;\n  };\n\n  proto.isStack = function() {\n    // FIXME update this once we have control for stack ...\n    return (this.is('bar') || this.is('area')) && this.has('color');\n  };\n\n  proto.cardinality = function(encType, stats) {\n    return vlfield.cardinality(this.field(encType), stats, this.config('filterNull'));\n  };\n\n  proto.isRaw = function() {\n    return !this.isAggregate();\n  };\n\n  proto.data = function(name) {\n    return name ? this._data[name] : this._data;\n  };\n\n   // returns whether the encoding has values embedded\n  proto.hasValues = function() {\n    var vals = this.data('values');\n    return vals && vals.length;\n  };\n\n  proto.config = function(name) {\n    return this._config[name];\n  };\n\n  Encoding.transpose = function(spec) {\n    var oldenc = spec.encoding,\n      enc = util.duplicate(spec.encoding);\n    enc.x = oldenc.y;\n    enc.y = oldenc.x;\n    enc.row = oldenc.col;\n    enc.col = oldenc.row;\n    spec.encoding = enc;\n    return spec;\n  };\n\n  // FIXME: REMOVE everything below here\n\n  Encoding.toggleSort = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.toggleSort = spec.config.toggleSort === Q ? N : Q;\n    return spec;\n  };\n\n\n  Encoding.toggleSort.direction = function(spec) {\n    if (!Encoding.toggleSort.support(spec)) { return; }\n    var enc = spec.encoding;\n    return enc.x.type === N ? 'x' : 'y';\n  };\n\n  Encoding.toggleSort.mode = function(spec) {\n    return spec.config.toggleSort;\n  };\n\n  Encoding.toggleSort.support = function(spec, stats) {\n    var enc = spec.encoding,\n      isTypes = vlfield.isTypes;\n\n    if (vlenc.has(enc, ROW) || vlenc.has(enc, COL) ||\n      !vlenc.has(enc, X) || !vlenc.has(enc, Y) ||\n      !Encoding.alwaysNoOcclusion(spec, stats)) {\n      return false;\n    }\n\n    return ( isTypes(enc.x, [N,O]) && vlfield.isMeasure(enc.y)) ? 'x' :\n      ( isTypes(enc.y, [N,O]) && vlfield.isMeasure(enc.x)) ? 'y' : false;\n  };\n\n  Encoding.toggleFilterNullO = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.filterNull = spec.config.filterNull || { //FIXME\n      T: true,\n      Q: true\n    };\n    spec.config.filterNull.O = !spec.config.filterNull.O;\n    return spec;\n  };\n\n  Encoding.toggleFilterNullO.support = function(spec, stats) {\n    var fields = vlenc.fields(spec.encoding);\n    for (var fieldName in fields) {\n      var fieldList = fields[fieldName];\n      if (fieldList.containsType.O && fieldName in stats && stats[fieldName].nulls > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  return Encoding;\n})();\n\n},{\"./consts\":32,\"./enc\":34,\"./field\":35,\"./globals\":36,\"./schema/schema\":37,\"./util\":39}],15:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util');\n\nmodule.exports = aggregates;\n\nfunction aggregates(dataTable, encoding, opt) {\n  opt = opt || {};\n\n  var dims = {}, meas = {}, detail = {}, facets = {};\n\n  encoding.forEach(function(field, encType) {\n    if (field.aggregate) {\n      if (field.aggregate === 'count') {\n        meas.count = {op: 'count', field: '*'};\n      }else {\n        meas[field.aggregate + '|'+ field.name] = {\n          op: field.aggregate,\n          field: encoding.fieldRef(encType, {nofn: true})\n        };\n      }\n    } else {\n      dims[field.name] = encoding.fieldRef(encType);\n      if (encType == ROW || encType == COL) {\n        facets[field.name] = dims[field.name];\n      }else if (encType !== X && encType !== Y) {\n        detail[field.name] = dims[field.name];\n      }\n    }\n  });\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0) {\n    if (!dataTable.transform) dataTable.transform = [];\n    dataTable.transform.push({\n      type: 'aggregate',\n      groupby: dims,\n      fields: meas\n    });\n  }\n  return {\n    details: util.vals(detail),\n    dims: dims,\n    facets: util.vals(facets),\n    aggregated: meas.length > 0\n  };\n}\n\n},{\"../globals\":36,\"../util\":39}],16:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  getter = util.getter,\n  time = require('./time');\n\nvar axis = module.exports = {};\n\naxis.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    var s = props[x].scale;\n    if (s === X || s === Y) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\naxis.defs = function(names, encoding, layout, stats, opt) {\n  return names.reduce(function(a, name) {\n    a.push(axis.def(name, encoding, layout, stats, opt));\n    return a;\n  }, []);\n};\n\naxis.def = function(name, encoding, layout, stats, opt) {\n  var isCol = name == COL,\n    isRow = name == ROW,\n    type = isCol ? 'x' : isRow ? 'y' : name;\n\n  var def = {\n    type: type,\n    scale: name,\n    properties: {},\n    layer: encoding.field(name).axis.layer,\n    orient: axis.orient(name, encoding, stats)\n  };\n\n  // Add axis label custom scale (for bin / time)\n  def = axis.labels.scale(def, encoding, name);\n  def = axis.labels.format(def, name, encoding, stats);\n\n  // for x-axis, set ticks for Q or rotate scale for ordinal scale\n  if (name == X) {\n    if (encoding.isDimension(X) || encoding.isType(X, T)) {\n      // TODO(kanitw): Jul 19, 2015 - #506 add condition for rotation\n      def = axis.labels.rotate(def);\n    } else { // Q\n      def.ticks = encoding.field(name).axis.ticks;\n    }\n  }\n\n  // TitleOffset depends on labels rotation\n  def.titleOffset = axis.titleOffset(encoding, layout, name);\n\n  //def.offset is used in axis.grid\n  if(isRow) def.offset = axis.titleOffset(encoding, layout, Y) + 20;\n  // FIXME(kanitw): Jul 19, 2015 - offset for column when x is put on top\n\n  def = axis.grid(def, name, encoding, layout);\n  def = axis.title(def, name, encoding, layout, opt);\n\n  if (isRow || isCol) def = axis.hideTicks(def);\n\n  return def;\n};\n\naxis.orient = function(name, encoding, stats) {\n  var orient = encoding.field(name).axis.orient;\n  if (orient) return orient;\n\n  if (name===COL) return 'top';\n\n  // x-axis for long y - put on top\n  if (name===X && encoding.has(Y) && encoding.isOrdinalScale(Y) && encoding.cardinality(Y, stats) > 30) {\n    return 'top';\n  }\n\n  return undefined;\n};\n\naxis.grid = function(def, name, encoding, layout) {\n  var cellPadding = layout.cellPadding,\n    isCol = name == COL,\n    isRow = name == ROW;\n\n  if (encoding.axis(name).grid) {\n    def.grid = true;\n\n    if (isCol) {\n      // set grid property -- put the lines on the right the cell\n      def.properties.grid = {\n        x: {\n          offset: layout.cellWidth * (1+ cellPadding/2.0),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'col'\n        },\n        y: {\n          value: -layout.cellHeight * (cellPadding/2),\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      };\n    } else if (isRow) {\n      // set grid property -- put the lines on the top\n      def.properties.grid = {\n        y: {\n          offset: -layout.cellHeight * (cellPadding/2),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'row'\n        },\n        x: {\n          value: def.offset\n        },\n        x2: {\n          offset: def.offset + (layout.cellWidth * 0.05),\n          // default value(s) -- vega doesn't do recursive merge\n          group: 'mark.group.width',\n          mult: 1\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      };\n    } else {\n      def.properties.grid = {\n        stroke: { value: encoding.config('gridColor') },\n        opacity: { value: encoding.config('gridOpacity') }\n      };\n    }\n  }\n  return def;\n};\n\naxis.hideTicks = function(def) {\n  def.properties.ticks = {opacity: {value: 0}};\n  def.properties.majorTicks = {opacity: {value: 0}};\n  def.properties.axis = {opacity: {value: 0}};\n  return def;\n};\n\naxis.title = function (def, name, encoding, layout) {\n  var ax = encoding.field(name).axis;\n\n  if (ax.title) {\n    def.title = ax.title;\n  } else {\n    // if not defined, automatically determine axis title from field def\n    var fieldTitle = encoding.fieldTitle(name),\n      maxLength;\n\n    if (ax.titleMaxLength) {\n      maxLength = ax.titleMaxLength;\n    } else if (name===X) {\n      maxLength = layout.cellWidth / encoding.config('characterWidth');\n    } else if (name === Y) {\n      maxLength = layout.cellHeight / encoding.config('characterWidth');\n    }\n\n    def.title = maxLength ? util.truncate(fieldTitle, maxLength) : fieldTitle;\n  }\n\n  if (name === ROW) {\n    def.properties.title = {\n      angle: {value: 0},\n      align: {value: 'right'},\n      baseline: {value: 'middle'},\n      dy: {value: (-layout.height/2) -20}\n    };\n  }\n\n  return def;\n};\n\naxis.labels = {};\n\n/** add custom label for time type and bin */\naxis.labels.scale = function(def, encoding, name) {\n  // time\n  var timeUnit = encoding.field(name).timeUnit;\n  if (encoding.isType(name, T) && timeUnit && (time.hasScale(timeUnit))) {\n    setter(def, ['properties','labels','text','scale'], 'time-'+ timeUnit);\n  }\n  // FIXME bin\n  return def;\n};\n\n/**\n * Determine number format or truncate if maxLabel length is presented.\n */\naxis.labels.format = function (def, name, encoding, stats) {\n  var fieldStats = stats[encoding.field(name).name];\n\n  if (encoding.axis(name).format) {\n    def.format = encoding.axis(name).format;\n  } else if (encoding.isType(name, Q) || fieldStats.type === 'number') {\n    def.format = encoding.numberFormat(fieldStats);\n  } else if (encoding.isType(name, T)) {\n    var timeUnit = encoding.field(name).timeUnit;\n    if (!timeUnit) {\n      def.format = encoding.config('timeFormat');\n    } else if (timeUnit === 'year') {\n      def.format = 'd';\n    }\n  } else if (encoding.isTypes(name, [N, O]) && encoding.axis(name).maxLabelLength) {\n    setter(def,\n      ['properties','labels','text','template'],\n      '{{data | truncate:' + encoding.axis(name).maxLabelLength + '}}'\n      );\n  }\n\n  return def;\n};\n\naxis.labels.rotate = function(def) {\n var align = def.orient ==='top' ? 'left' : 'right';\n setter(def, ['properties','labels', 'angle', 'value'], 270);\n setter(def, ['properties','labels', 'align', 'value'], align);\n setter(def, ['properties','labels', 'baseline', 'value'], 'middle');\n return def;\n};\n\naxis.titleOffset = function (encoding, layout, name) {\n  // return specified value if specified\n  var value = encoding.axis(name).titleOffset;\n  if (value)  return value;\n\n  switch (name) {\n    //FIXME make this adjustable\n    case ROW: return 0;\n    case COL: return 35;\n  }\n  return getter(layout, [name, 'axisTitleOffset']);\n};\n\n},{\"../globals\":36,\"../util\":39,\"./time\":31}],17:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nmodule.exports = binning;\n\nfunction binning(dataTable, encoding, opt) {\n  opt = opt || {};\n\n  if (!dataTable.transform) dataTable.transform = [];\n\n  encoding.forEach(function(field, encType) {\n    if (encoding.bin(encType)) {\n      dataTable.transform.push({\n        type: 'bin',\n        field: encoding.fieldRef(encType, {nofn: true}),\n        output: encoding.fieldRef(encType),\n        maxbins: encoding.bin(encType).maxbins\n      });\n    }\n  });\n\n  return dataTable;\n}\n\n},{\"../globals\":36}],18:[function(require,module,exports){\n'use strict';\n\nvar summary = module.exports = require('datalib/src/stats').summary;\n\nrequire('../globals');\n\nvar compiler = module.exports = {};\n\nvar Encoding = require('../Encoding'),\n  axis = compiler.axis = require('./axis'),\n  filter = compiler.filter = require('./filter'),\n  legend = compiler.legend = require('./legend'),\n  marks = compiler.marks = require('./marks'),\n  scale = compiler.scale = require('./scale');\n\ncompiler.aggregate = require('./aggregate');\ncompiler.bin = require('./bin');\ncompiler.facet = require('./facet');\ncompiler.group = require('./group');\ncompiler.layout = require('./layout');\ncompiler.sort = require('./sort');\ncompiler.stack = require('./stack');\ncompiler.style = require('./style');\ncompiler.subfacet = require('./subfacet');\ncompiler.template = require('./template');\ncompiler.time = require('./time');\n\ncompiler.compile = function (spec, stats, theme) {\n  return compiler.compileEncoding(Encoding.fromSpec(spec, theme), stats);\n};\n\ncompiler.shorthand = function (shorthand, stats, config, theme) {\n  return compiler.compileEncoding(Encoding.fromShorthand(shorthand, config, theme), stats);\n};\n\ncompiler.compileEncoding = function (encoding, stats) {\n  // no need to pass stats if you pass in the data\n  if (!stats && encoding.hasValues()) {\n    stats = summary(encoding.data('values')).reduce(function(s, p) {\n      s[p.field] = p;\n      return s;\n    }, {});\n  }\n\n  var layout = compiler.layout(encoding, stats),\n    spec = compiler.template(encoding, layout, stats);\n\n  // .data related stuff\n  var rawTable = spec.data[0],\n    dataTable = spec.data[1];\n\n  rawTable = filter.addFilters(rawTable, encoding); // modify rawTable\n  spec = compiler.time(spec, encoding);              // modify rawTable, add scales\n  dataTable = compiler.bin(dataTable, encoding);     // modify dataTable\n  var aggResult = compiler.aggregate(dataTable, encoding); // modify dataTable\n  var sorting = compiler.sort(spec.data, encoding, stats); // append new data\n\n  // marks\n  var style = compiler.style(encoding, stats),\n    group = spec.marks[0],\n    mark = marks[encoding.marktype()],\n    mdefs = marks.def(mark, encoding, layout, style, stats),\n    mdef = mdefs[0];  // TODO: remove this dirty hack by refactoring the whole flow\n\n  for (var i = 0; i < mdefs.length; i++) {\n    group.marks.push(mdefs[i]);\n  }\n\n  var lineType = marks[encoding.marktype()].line;\n\n  // handle subfacets\n\n  var details = aggResult.details,\n    hasDetails = details && details.length > 0,\n    stack = hasDetails && compiler.stack(spec.data, encoding, mdef, aggResult.facets); // modify spec.data, mdef.{from,properties}\n\n  if (hasDetails && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    compiler.subfacet(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  //TODO(kanitw): have some config to turn off auto-sort for line (for line chart that encodes temporal information)\n  if (lineType) {\n    var f = (encoding.isMeasure(X) && encoding.isDimension(Y)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    // TODO: why - ?\n    mdef.from.transform = [{type: 'sort', by: '-' + encoding.fieldRef(f)}];\n  }\n\n  // Small Multiples\n  if (encoding.has(ROW) || encoding.has(COL)) {\n    spec = compiler.facet(group, encoding, layout, style, sorting, spec, mdef, stack, stats);\n    spec.legends = legend.defs(encoding);\n  } else {\n    group.scales = scale.defs(scale.names(mdef.properties.update), encoding, layout, stats, style, sorting, {stack: stack});\n    group.axes = axis.defs(axis.names(mdef.properties.update), encoding, layout, stats);\n    group.legends = legend.defs(encoding);\n  }\n\n  filter.filterLessThanZero(dataTable, encoding);\n\n  return spec;\n};\n\n\n},{\"../Encoding\":14,\"../globals\":36,\"./aggregate\":15,\"./axis\":16,\"./bin\":17,\"./facet\":19,\"./filter\":20,\"./group\":21,\"./layout\":22,\"./legend\":23,\"./marks\":24,\"./scale\":25,\"./sort\":26,\"./stack\":27,\"./style\":28,\"./subfacet\":29,\"./template\":30,\"./time\":31,\"datalib/src/stats\":11}],19:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util');\n\nvar axis = require('./axis'),\n  groupdef = require('./group').def,\n  scale = require('./scale');\n\nmodule.exports = faceting;\n\nfunction faceting(group, encoding, layout, style, sorting, spec, mdef, stack, stats) {\n  var enter = group.properties.enter;\n  var facetKeys = [], cellAxes = [], from, axesGrp;\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  enter.fill = {value: encoding.config('cellBackgroundColor')};\n\n  //move \"from\" to cell level and add facet transform\n  group.from = {data: group.marks[0].from.data};\n\n  // Hack, this needs to be refactored\n  for (var i = 0; i < group.marks.length; i++) {\n    var mark = group.marks[i];\n    if (mark.from.transform) {\n      delete mark.from.data; //need to keep transform for subfacetting case\n    } else {\n      delete mark.from;\n    }\n  }\n\n  if (hasRow) {\n    if (!encoding.isDimension(ROW)) {\n      util.error('Row encoding should be ordinal.');\n    }\n    enter.y = {scale: ROW, field: 'keys.' + facetKeys.length};\n    enter.height = {'value': layout.cellHeight}; // HACK\n\n    facetKeys.push(encoding.fieldRef(ROW));\n\n    if (hasCol) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.fieldRef(COL)]});\n    }\n\n    axesGrp = groupdef('x-axes', {\n        axes: encoding.has(X) ? axis.defs(['x'], encoding, layout, stats) : undefined,\n        x: hasCol ? {scale: COL, field: 'keys.0'} : {value: 0},\n        width: hasCol && {'value': layout.cellWidth}, //HACK?\n        from: from\n      });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['row'], encoding, layout, stats));\n  } else { // doesn't have row\n    if (encoding.has(X)) {\n      //keep x axis in the cell\n      cellAxes.push.apply(cellAxes, axis.defs(['x'], encoding, layout, stats));\n    }\n  }\n\n  if (hasCol) {\n    if (!encoding.isDimension(COL)) {\n      util.error('Col encoding should be ordinal.');\n    }\n    enter.x = {scale: COL, field: 'keys.' + facetKeys.length};\n    enter.width = {'value': layout.cellWidth}; // HACK\n\n    facetKeys.push(encoding.fieldRef(COL));\n\n    if (hasRow) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.fieldRef(ROW)]});\n    }\n\n    axesGrp = groupdef('y-axes', {\n      axes: encoding.has(Y) ? axis.defs(['y'], encoding, layout, stats) : undefined,\n      y: hasRow && {scale: ROW, field: 'keys.0'},\n      x: hasRow && {value: 0},\n      height: hasRow && {'value': layout.cellHeight}, //HACK?\n      from: from\n    });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['col'], encoding, layout, stats));\n  } else { // doesn't have col\n    if (encoding.has(Y)) {\n      cellAxes.push.apply(cellAxes, axis.defs(['y'], encoding, layout, stats));\n    }\n  }\n\n  // assuming equal cellWidth here\n  // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n  spec.scales = (spec.scales || []).concat(scale.defs(\n    scale.names(enter).concat(scale.names(mdef.properties.update)),\n    encoding,\n    layout,\n    stats,\n    style,\n    sorting,\n    {stack: stack, facet: true}\n  )); // row/col scales + cell scales\n\n  if (cellAxes.length > 0) {\n    group.axes = cellAxes;\n  }\n\n  // add facet transform\n  var trans = (group.from.transform || (group.from.transform = []));\n  trans.unshift({type: 'facet', keys: facetKeys});\n\n  return spec;\n}\n\n},{\"../globals\":36,\"../util\":39,\"./axis\":16,\"./group\":21,\"./scale\":25}],20:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar filter = module.exports = {};\n\nvar BINARY = {\n  '>':  true,\n  '>=': true,\n  '=':  true,\n  '!=': true,\n  '<':  true,\n  '<=': true\n};\n\nfilter.addFilters = function(rawTable, encoding) {\n  var filters = encoding.filter();  // apply filters to raw data before aggregation\n\n  if (!rawTable.transform)\n    rawTable.transform = [];\n\n  // add custom filters\n  for (var i=0, l=filters.length; i<l; i++) {\n    var filter = filters[i];\n\n    var condition = '';\n    var operator = filter.operator;\n    var operands = filter.operands;\n\n    var d = 'd.' + (encoding._vega2 ? '' : 'data.');\n\n    if (BINARY[operator]) {\n      // expects a field and a value\n      if (operator === '=') {\n        operator = '==';\n      }\n\n      var op1 = operands[0];\n      var op2 = operands[1];\n      condition = d + op1 + operator + op2;\n    } else if (operator === 'notNull') {\n      // expects a number of fields\n      for (var j=0; j<operands.length; j++) {\n        condition += d + operands[j] + '!==null';\n        if (j < operands.length - 1) {\n          condition += ' && ';\n        }\n      }\n    } else {\n      console.warn('Unsupported operator: ', operator);\n    }\n\n    rawTable.transform.push({\n      type: 'filter',\n      test: condition\n    });\n  }\n\n  return rawTable;\n};\n\n// remove less than 0 values if we use log function\nfilter.filterLessThanZero = function(dataTable, encoding) {\n  encoding.forEach(function(field, encType) {\n    if (encoding.scale(encType).type === 'log') {\n      dataTable.transform.push({\n        type: 'filter',\n        test: 'd.' + encoding.fieldRef(encType) + '>0'\n      });\n    }\n  });\n};\n\n},{\"../globals\":36}],21:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  def: groupdef\n};\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: 'group',\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: 'width'},\n        height: opt.height || {group: 'height'}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n\n},{}],22:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  time = require('./time'),\n  d3_format = require('d3-format');\n\nmodule.exports = vllayout;\n\nfunction vllayout(encoding, stats) {\n  var layout = box(encoding, stats);\n  layout = offset(encoding, stats, layout);\n  return layout;\n}\n\n/*\n  HACK to set chart size\n  NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  One solution is to update Vega to support auto-sizing\n  In the meantime, auto-padding (mostly) does the trick\n */\nfunction box(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y),\n      marktype = encoding.marktype();\n\n  // FIXME/HACK we need to take filter into account\n  var xCardinality = hasX && encoding.isDimension(X) ? encoding.cardinality(X, stats) : 1,\n    yCardinality = hasY && encoding.isDimension(Y) ? encoding.cardinality(Y, stats) : 1;\n\n  var useSmallBand = xCardinality > encoding.config('largeBandMaxCardinality') ||\n    yCardinality > encoding.config('largeBandMaxCardinality');\n\n  var cellWidth, cellHeight, cellPadding = encoding.config('cellPadding');\n\n  // set cellWidth\n  if (hasX) {\n    if (encoding.isOrdinalScale(X)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellWidth = (xCardinality + encoding.field(X).band.padding) * encoding.bandSize(X, useSmallBand);\n    } else {\n      cellWidth = hasCol || hasRow ? encoding.field(COL).width :  encoding.config('singleWidth');\n    }\n  } else {\n    if (marktype === TEXT) {\n      cellWidth = encoding.config('textCellWidth');\n    } else {\n      cellWidth = encoding.bandSize(X);\n    }\n  }\n\n  // set cellHeight\n  if (hasY) {\n    if (encoding.isOrdinalScale(Y)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellHeight = (yCardinality + encoding.field(Y).band.padding) * encoding.bandSize(Y, useSmallBand);\n    } else {\n      cellHeight = hasCol || hasRow ? encoding.field(ROW).height :  encoding.config('singleHeight');\n    }\n  } else {\n    cellHeight = encoding.bandSize(Y);\n  }\n\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n\n  var width = cellWidth, height = cellHeight;\n  if (hasCol) {\n    var colCardinality = encoding.cardinality(COL, stats);\n    width = cellWidth * ((1 + cellPadding) * (colCardinality - 1) + 1);\n  }\n  if (hasRow) {\n    var rowCardinality =  encoding.cardinality(ROW, stats);\n    height = cellHeight * ((1 + cellPadding) * (rowCardinality - 1) + 1);\n  }\n\n  return {\n    // width and height of the whole cell\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    cellPadding: cellPadding,\n    // width and height of the chart\n    width: width,\n    height: height,\n    // information about x and y, such as band size\n    x: {useSmallBand: useSmallBand},\n    y: {useSmallBand: useSmallBand}\n  };\n}\n\n\n// FIXME fieldStats.max isn't always the longest\nfunction getMaxNumberLength(encoding, et, fieldStats) {\n  var format = encoding.numberFormat(et, fieldStats);\n\n  return d3_format.format(format)(fieldStats.max).length;\n}\n\nfunction getMaxLength(encoding, stats, et) {\n  var field = encoding.field(et),\n    fieldStats = stats[field.name];\n\n  if (field.bin) {\n    // TODO once bin support range, need to update this\n    return getMaxNumberLength(encoding, et, fieldStats);\n  } if (encoding.isType(et, Q)) {\n    return getMaxNumberLength(encoding, et, fieldStats);\n  } else if (encoding.isType(et, T)) {\n    return time.maxLength(encoding.field(et).timeUnit, encoding);\n  } else if (encoding.isTypes(et, [N, O])) {\n    if(fieldStats.type === 'number') {\n      return getMaxNumberLength(encoding, et, fieldStats);\n    } else {\n      return Math.min(fieldStats.max, encoding.axis(et).maxLabelLength || Infinity);\n    }\n  }\n}\n\nfunction offset(encoding, stats, layout) {\n  [X, Y].forEach(function (et) {\n    // TODO(kanitw): Jul 19, 2015 - create a set of visual test for extraOffset\n    var extraOffset = et === X ? 20 : 22,\n      maxLength;\n    if (encoding.isDimension(et) || encoding.isType(et, T)) {\n      maxLength = getMaxLength(encoding, stats, et);\n    } else if (\n      // TODO once we have #512 (allow using inferred type)\n      // Need to adjust condition here.\n      encoding.isType(et, Q) ||\n      encoding.aggregate(et) === 'count'\n    ) {\n      if (\n        et===Y\n        // || (et===X && false)\n        // FIXME determine when X would rotate, but should move this to axis.js first #506\n      ) {\n        maxLength = getMaxLength(encoding, stats, et);\n      }\n    } else {\n      // nothing\n    }\n\n    if (maxLength) {\n      setter(layout,[et, 'axisTitleOffset'], encoding.config('characterWidth') *  maxLength + extraOffset);\n    } else {\n      // if no max length (no rotation case), use maxLength = 3\n      setter(layout,[et, 'axisTitleOffset'], encoding.config('characterWidth') * 3 + extraOffset);\n    }\n\n  });\n  return layout;\n}\n\n},{\"../globals\":36,\"../util\":39,\"./time\":31,\"d3-format\":5}],23:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar time = require('./time');\n\nvar legend = module.exports = {};\n\nlegend.defs = function(encoding) {\n  var defs = [];\n  // TODO: support alpha\n\n  if (encoding.has(COLOR) && encoding.field(COLOR).legend) {\n    defs.push(legend.def(COLOR, encoding, {\n      fill: COLOR,\n      orient: 'right'\n    }));\n  }\n\n  if (encoding.has(SIZE) && encoding.field(SIZE).legend) {\n    defs.push(legend.def(SIZE, encoding, {\n      size: SIZE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  if (encoding.has(SHAPE) && encoding.field(SHAPE).legend) {\n    if (defs.length === 2) {\n      // TODO: fix this\n      console.error('Vega-lite currently only supports two legends');\n      return defs;\n    }\n    defs.push(legend.def(SHAPE, encoding, {\n      shape: SHAPE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  return defs;\n};\n\nlegend.def = function(name, encoding, props) {\n  var def = props,\n    timeUnit = encoding.field(name).timeUnit;\n\n  def.title = encoding.fieldTitle(name);\n\n  if (encoding.isType(name, T) &&\n    timeUnit &&\n    time.hasScale(timeUnit)\n  ) {\n    var properties = def.properties = def.properties || {},\n      labels = properties.labels = properties.labels || {},\n      text = labels.text = labels.text || {};\n\n    text.scale = 'time-'+ timeUnit;\n  }\n\n  return def;\n};\n\n},{\"../globals\":36,\"./time\":31}],24:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar marks = module.exports = {};\n\nmarks.def = function(mark, encoding, layout, style, stats) {\n  var defs = [];\n\n  // to add a background to text, we need to add it before the text\n  if (encoding.marktype() === TEXT && encoding.has(COLOR)) {\n    var bg = {\n      x: {value: 0},\n      y: {value: 0},\n      x2: {value: layout.cellWidth},\n      y2: {value: layout.cellHeight},\n      fill: {scale: COLOR, field: encoding.fieldRef(COLOR)}\n    };\n    defs.push({\n      type: 'rect',\n      from: {data: TABLE},\n      properties: {enter: bg, update: bg}\n    });\n  }\n\n  // add the mark def for the main thing\n  var p = mark.prop(encoding, layout, style, stats);\n  defs.push({\n    type: mark.type,\n    from: {data: TABLE},\n    properties: {enter: p, update: p}\n  });\n\n  return defs;\n};\n\nmarks.bar = {\n  type: 'rect',\n  stack: true,\n  prop: bar_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1}\n};\n\nmarks.line = {\n  type: 'line',\n  line: true,\n  prop: line_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, detail:1}\n};\n\nmarks.area = {\n  type: 'area',\n  stack: true,\n  line: true,\n  requiredEncoding: ['x', 'y'],\n  prop: area_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1}\n};\n\nmarks.tick = {\n  type: 'rect',\n  prop: tick_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, detail: 1}\n};\n\nmarks.circle = {\n  type: 'symbol',\n  prop: filled_point_props('circle'),\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, detail: 1}\n};\n\nmarks.square = {\n  type: 'symbol',\n  prop: filled_point_props('square'),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: 'symbol',\n  prop: point_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, shape: 1, detail: 1}\n};\n\nmarks.text = {\n  type: 'text',\n  prop: text_props,\n  requiredEncoding: ['text'],\n  supportedEncoding: {row: 1, col: 1, size: 1, color: 1, text: 1}\n};\n\nfunction bar_props(e, layout, style) {\n  // jshint unused:false\n\n  var p = {};\n\n  // x's and width\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (!e.has(Y) || e.isDimension(Y)) {\n      p.x2 = {value: 0};\n    }\n  } else {\n    if (e.has(X)) { // is ordinal\n       p.xc = {scale: X, field: e.fieldRef(X)};\n    } else {\n       p.x = {value: 0, offset: e.config('singleBarOffset')};\n    }\n  }\n\n  // width\n  if (!p.x2) {\n    if (!e.has(X) || e.isOrdinalScale(X)) { // no X or X is ordinal\n      if (e.has(SIZE)) {\n        p.width = {scale: SIZE, field: e.fieldRef(SIZE)};\n      } else {\n        p.width = {\n          value: e.bandSize(X, layout.x.useSmallBand),\n          offset: -1\n        };\n      }\n    } else { // X is Quant or Time Scale\n      p.width = {value: 2};\n    }\n  }\n\n  // y's & height\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    p.y2 = {group: 'height'};\n  } else {\n    if (e.has(Y)) { // is ordinal\n      p.yc = {scale: Y, field: e.fieldRef(Y)};\n    } else {\n      p.y2 = {group: 'height', offset: -e.config('singleBarOffset')};\n    }\n\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.fieldRef(SIZE)};\n    } else {\n      p.height = {\n        value: e.bandSize(Y, layout.y.useSmallBand),\n        offset: -1\n      };\n    }\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // opacity\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction point_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.fieldRef(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.value(SIZE)};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.fieldRef(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.value(SHAPE)};\n  }\n\n  // stroke\n  if (e.field(SHAPE).filled) {\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n  } else {\n    if (e.has(COLOR)) {\n      p.stroke = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.stroke = {value: e.value(COLOR)};\n    }\n    p.strokeWidth = {value: e.config('strokeWidth')};\n  }\n\n  // opacity\n  var opacity = e.field(COLOR).opacity  || style.opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction line_props(e,layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction area_props(e, layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: 'horizontal'};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else {\n    p.y = {group: 'height'};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction tick_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (e.isDimension(X)) {\n      p.x.offset = -e.bandSize(X, layout.x.useSmallBand) / 3;\n    }\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    if (e.isDimension(Y)) {\n      p.y.offset = -e.bandSize(Y, layout.y.useSmallBand) / 3;\n    }\n  } else if (!e.has(Y)) {\n    p.y = {value: 0};\n  }\n\n  // width\n  if (!e.has(X) || e.isDimension(X)) {\n    p.width = {value: e.bandSize(X, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.width = {value: 1};\n  }\n\n  // height\n  if (!e.has(Y) || e.isDimension(Y)) {\n    p.height = {value: e.bandSize(Y, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.height = {value: 1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity  || style.opacity;\n  if(opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, layout, style) {\n    var p = {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.fieldRef(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.fieldRef(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.fieldRef(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.value(SIZE)};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n\n    var opacity = e.field(COLOR).opacity  || style.opacity;\n    if(opacity) p.opacity = {value: opacity};\n\n    return p;\n  };\n}\n\nfunction text_props(e, layout, style, stats) {\n  var p = {},\n    field = e.field(TEXT);\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    if (e.has(TEXT) && e.isType(TEXT, Q)) {\n      p.x = {value: layout.cellWidth-5};\n    } else {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.fieldRef(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.fontSize = {value: field.font.size};\n  }\n\n  // fill\n  // color should be set to background\n  p.fill = {value: field.text.color};\n\n  var opacity = e.field(COLOR).opacity  || style.opacity;\n  if(opacity) p.opacity = {value: opacity};\n\n  // text\n  if (e.has(TEXT)) {\n    if (e.isType(TEXT, Q)) {\n      var fieldStats = stats[e.fieldName(name)],\n        numberFormat = field.format || e.numberFormat(fieldStats);\n\n      p.text = {template: '{{' + e.fieldRef(TEXT) + ' | number:\\'' +\n        numberFormat +'\\'}}'};\n      p.align = {value: field.align};\n    } else {\n      p.text = {field: e.fieldRef(TEXT)};\n    }\n  } else {\n    p.text = {value: field.placeholder};\n  }\n\n  p.font = {value: field.font.family};\n  p.fontWeight = {value: field.font.weight};\n  p.fontStyle = {value: field.font.style};\n  p.baseline = {value: field.baseline};\n\n  return p;\n}\n\n},{\"../globals\":36}],25:[function(require,module,exports){\n'use strict';\nrequire('../globals');\nvar util = require('../util'),\n  time = require('./time'),\n  colorbrewer = require('colorbrewer'),\n  interpolateLab = require('d3-color').interpolateLab,\n  schema = require('../schema/schema');\n\nvar scale = module.exports = {};\n\nscale.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\nscale.defs = function(names, encoding, layout, stats, style, sorting, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale.type(name, encoding),\n      domain: scale.domain(name, encoding, stats, sorting, opt)\n    };\n\n    s.sort = scale.sort(s, encoding, name) || undefined;\n\n    scale.range(s, encoding, layout, stats, opt);\n\n    return (a.push(s), a);\n  }, []);\n};\n\nscale.sort = function(s, encoding, name) {\n  return s.type === 'ordinal' && (\n    !!encoding.bin(name) ||\n    encoding.sort(name).length === 0\n  );\n};\n\nscale.type = function(name, encoding) {\n\n  switch (encoding.type(name)) {\n    case N: //fall through\n    case O: return 'ordinal';\n    case T:\n      var timeUnit = encoding.field(name).timeUnit;\n      return timeUnit ? time.scale.type(timeUnit, name) : 'time';\n    case Q:\n      if (encoding.bin(name)) {\n        return name === COLOR ? 'linear' : 'ordinal';\n      }\n      return encoding.scale(name).type;\n  }\n};\n\nscale.domain = function (name, encoding, stats, sorting, opt) {\n  var field = encoding.field(name);\n\n  if (encoding.isType(name, T)) {\n    var range = time.scale.domain(field.timeUnit, name);\n    if(range) return range;\n  }\n\n  if (field.bin) {\n    // TODO(kanitw): this must be changed in vg2\n    var fieldStat = stats[field.name],\n      bins = util.getbins(fieldStat, field.bin.maxbins || schema.MAXBINS_DEFAULT),\n      numbins = (bins.stop - bins.start) / bins.step;\n    return util.range(numbins).map(function(i) {\n      return bins.start + bins.step * i;\n    });\n  }\n\n  if (name == opt.stack) {\n    return {\n      data: STACKED,\n      field: encoding.fieldRef(name, {\n        data: !encoding._vega2,\n        prefn: (opt.facet ? 'max_' : '') + 'sum_'\n      })\n    };\n  }\n  var aggregate = encoding.aggregate(name),\n    timeUnit = field.timeUnit,\n    scaleUseRawDomain = encoding.scale(name).useRawDomain,\n    useRawDomain = scaleUseRawDomain !== undefined ?\n      scaleUseRawDomain : encoding.config('useRawDomain'),\n    notCountOrSum = !aggregate || (aggregate !=='count' && aggregate !== 'sum');\n\n  if ( useRawDomain && notCountOrSum && (\n      // Q always uses non-ordinal scale except when it's binned and thus uses ordinal scale.\n      (encoding.isType(name, Q) && !field.bin) ||\n      // T uses non-ordinal scale when there's no unit or when the unit is not ordinal.\n      (encoding.isType(name, T) && (!timeUnit || !time.isOrdinalFn(timeUnit)))\n    )\n  ) {\n    return {data: RAW, field: encoding.fieldRef(name, {nofn: !timeUnit})};\n  }\n\n  return {data: sorting.getDataset(name), field: encoding.fieldRef(name)};\n};\n\n\nscale.range = function (s, encoding, layout, stats) {\n  var spec = encoding.scale(s.name),\n    field = encoding.field(s.name),\n    timeUnit = field.timeUnit;\n\n  switch (s.name) {\n    case X:\n      s.range = layout.cellWidth ? [0, layout.cellWidth] : 'width';\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(X, layout.x.useSmallBand);\n      } else {\n        if (encoding.isType(s.name,T) && timeUnit === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n      s.round = true;\n      if (s.type === 'time') {\n        s.nice = timeUnit || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (s.type === 'ordinal') {\n        s.range = layout.cellHeight ?\n          (field.bin ? [layout.cellHeight, 0] : [0, layout.cellHeight]) :\n          'height';\n        s.bandWidth = encoding.bandSize(Y, layout.y.useSmallBand);\n      } else {\n        s.range = layout.cellHeight ? [layout.cellHeight, 0] : 'height';\n        if (encoding.isType(s.name,T) && timeUnit === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n\n      s.round = true;\n\n      if (s.type === 'time') {\n        s.nice = timeUnit || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case ROW: // support only ordinal\n      s.bandWidth = layout.cellHeight;\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL: // support only ordinal\n      s.bandWidth = layout.cellWidth;\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is('bar')) {\n        // FIXME this is definitely incorrect\n        // but let's fix it later since bar size is a bad encoding anyway\n        s.range = [3, Math.max(encoding.bandSize(X), encoding.bandSize(Y))];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else { //point\n        var bandSize = Math.min(encoding.bandSize(X), encoding.bandSize(Y)) - 1;\n        s.range = [10, 0.8 * bandSize*bandSize];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = 'shapes';\n      break;\n    case COLOR:\n      s.range = scale.color(s, encoding, stats);\n      break;\n    default:\n      throw new Error('Unknown encoding name: '+ s.name);\n  }\n\n  switch (s.name) {\n    case ROW:\n    case COL:\n      s.padding = encoding.config('cellPadding');\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (s.type === 'ordinal') { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.field(s.name).band.padding;\n      }\n  }\n};\n\nscale.color = function(s, encoding, stats) {\n  var colorScale = encoding.scale(COLOR),\n    range = colorScale.range,\n    cardinality = encoding.cardinality(COLOR, stats),\n    type = encoding.type(COLOR);\n\n  if (range === undefined) {\n    var ordinalPalette = colorScale.ordinalPalette;\n    if (s.type === 'ordinal') {\n      if (type === N) {\n        // use categorical color scale\n        if (cardinality <= 10) {\n          range = colorScale.c10palette;\n        } else {\n          range = colorScale.c20palette;\n        }\n      } else {\n        if (cardinality <= 2) {\n          range = [colorbrewer[ordinalPalette][3][0], colorbrewer[ordinalPalette][3][2]];\n        } else {\n          range = ordinalPalette;\n        }\n      }\n    } else { //time or quantitative\n      var palette = colorbrewer[ordinalPalette][9];\n      range = [palette[0], palette[8]];\n      s.zero = false;\n    }\n  }\n  return scale.color.palette(range, cardinality, type);\n};\n\nscale.color.palette = function(range, cardinality, type) {\n  switch (range) {\n    case 'category10k':\n      // tableau's category 10, ordered by perceptual kernel study results\n      // https://github.com/uwdata/perceptual-kernels\n      return ['#2ca02c', '#e377c2', '#7f7f7f', '#17becf', '#8c564b', '#d62728', '#bcbd22', '#9467bd', '#ff7f0e', '#1f77b4'];\n\n    // d3/tableau category10/20/20b/20c\n    case 'category10':\n      return ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];\n\n    case 'category20':\n      return ['#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'];\n\n    case 'category20b':\n      return ['#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39', '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b', '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'];\n\n    case 'category20c':\n      return ['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#e6550d', '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354', '#74c476', '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc', '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9'];\n  }\n\n  if (range in colorbrewer) {\n    var palette = colorbrewer[range],\n      ps = 5;\n\n    // if cardinality pre-defined, use it.\n    if (cardinality in palette) return palette[cardinality];\n\n    // if not, use the highest cardinality one for nominal\n    if (type === N) {\n      return palette[Math.max.apply(null, util.keys(palette))];\n    }\n\n    // otherwise, interpolate\n    return scale.color.interpolate(palette[ps][0], palette[ps][ps-1], cardinality);\n  }\n\n  return range;\n};\n\nscale.color.interpolate = function (start, end, cardinality) {\n  var interpolator = interpolateLab(start, end);\n  return util.range(cardinality).map(function(i) { return interpolator(i*1.0/(cardinality-1)); });\n};\n\n},{\"../globals\":36,\"../schema/schema\":37,\"../util\":39,\"./time\":31,\"colorbrewer\":3,\"d3-color\":4}],26:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar vlfield = require('../field');\n\nmodule.exports = addSortTransforms;\n\n// adds new transforms that produce sorted fields\nfunction addSortTransforms(data, encoding, stats, opt) {\n  // jshint unused:false\n\n  var datasetMapping = {};\n  var counter = 0;\n\n  encoding.forEach(function(field, encType) {\n    var sortBy = encoding.sort(encType, stats);\n    if (sortBy.length > 0) {\n      var fields = sortBy.map(function(d) {\n        return {\n          op: d.aggregate,\n          field: vlfield.fieldRef(d, {nofn: true, data: !encoding._vega2})\n        };\n      });\n\n      var byClause = sortBy.map(function(d) {\n        var reverse = (d.reverse ? '-' : '');\n        return reverse + vlfield.fieldRef(d, {data: !encoding._vega2});\n      });\n\n      var dataName = 'sorted' + counter++;\n\n      var transforms = [\n        {\n          type: 'aggregate',\n          groupby: [ encoding.fieldRef(encType) ],\n          fields: fields\n        },\n        {\n          type: 'sort',\n          by: byClause\n        }\n      ];\n\n      data.push({\n        name: dataName,\n        source: RAW,\n        transform: transforms\n      });\n\n      datasetMapping[encType] = dataName;\n    }\n  });\n\n  return {\n    getDataset: function(encType) {\n      var data = datasetMapping[encType];\n      if (!data) {\n        return TABLE;\n      }\n      return data;\n    }\n  };\n}\n\n\n},{\"../field\":35,\"../globals\":36}],27:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar  marks = require('./marks');\n\nmodule.exports = stacking;\n\nfunction stacking(data, encoding, mdef, facets) {\n  if (!marks[encoding.marktype()].stack) return false;\n\n  // TODO: add || encoding.has(LOD) here once LOD is implemented\n  if (!encoding.has(COLOR)) return false;\n\n  var dim=null, val=null, idx =null,\n    isXMeasure = encoding.isMeasure(X),\n    isYMeasure = encoding.isMeasure(Y);\n\n  if (isXMeasure && !isYMeasure) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  } else if (isYMeasure && !isXMeasure) {\n    dim = X;\n    val = Y;\n    idx = 1;\n  } else {\n    return null; // no stack encoding\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: TABLE,\n    transform: [{\n      type: 'aggregate',\n      groupby: [encoding.fieldRef(dim)].concat(facets), // dim and other facets\n      fields: [{op: 'sum', field: encoding.fieldRef(val)}] // TODO check if field with aggregate is correct?\n    }]\n  };\n\n  if (facets && facets.length > 0) {\n    stacked.transform.push({ //calculate max for each facet\n      type: 'aggregate',\n      groupby: facets,\n      fields: [{\n        op: 'max',\n        field: encoding.fieldName(val, {fn: 'sum'})\n      }]\n    });\n  }\n\n  data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: 'stack',\n    point: encoding.fieldRef(dim),\n    height: encoding.fieldRef(val),\n    output: {y1: val, y0: val + '2'}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val + '2'] = mdef.properties.enter[val + '2'] = {scale: val, field: val + '2'};\n\n  return val; //return stack encoding\n}\n\n},{\"../globals\":36,\"./marks\":24}],28:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar vlfield = require('../field');\n\nmodule.exports = function(encoding, stats) {\n  return {\n    opacity: estimateOpacity(encoding, stats),\n  };\n};\n\nfunction estimateOpacity(encoding,stats) {\n  if (!stats) {\n    return 1;\n  }\n\n  var numPoints = 0;\n\n  if (encoding.isAggregate()) { // aggregate plot\n    numPoints = 1;\n\n    //  get number of points in each \"cell\"\n    //  by calculating product of cardinality\n    //  for each non faceting and non-ordinal X / Y fields\n    //  note that ordinal x,y are not include since we can\n    //  consider that ordinal x are subdividing the cell into subcells anyway\n    encoding.forEach(function(field, encType) {\n\n      if (encType !== ROW && encType !== COL &&\n          !((encType === X || encType === Y) &&\n          vlfield.isOrdinalScale(field))\n        ) {\n        numPoints *= encoding.cardinality(encType, stats);\n      }\n    });\n\n  } else { // raw plot\n    numPoints = stats.count;\n\n    // small multiples divide number of points\n    var numMultiples = 1;\n    if (encoding.has(ROW)) {\n      numMultiples *= encoding.cardinality(ROW, stats);\n    }\n    if (encoding.has(COL)) {\n      numMultiples *= encoding.cardinality(COL, stats);\n    }\n    numPoints /= numMultiples;\n  }\n\n  var opacity = 0;\n  if (numPoints < 20) {\n    opacity = 1;\n  } else if (numPoints < 200) {\n    opacity = 0.7;\n  } else if (numPoints < 1000 || encoding.is('tick')) {\n    opacity = 0.6;\n  } else {\n    opacity = 0.3;\n  }\n\n  return opacity;\n}\n\n\n},{\"../field\":35,\"../globals\":36}],29:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar groupdef = require('./group').def;\n\nmodule.exports = subfaceting;\n\nfunction subfaceting(group, mdef, details, stack, encoding) {\n  var m = group.marks,\n    g = groupdef('subfacet', {marks: m});\n\n  group.marks = [g];\n  g.from = mdef.from;\n  delete mdef.from;\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: 'facet', keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: 'sort', by: encoding.fieldRef(COLOR)});\n  }\n}\n\n},{\"../globals\":36,\"./group\":21}],30:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar groupdef = require('./group').def,\n  vlfield = require('../field');\n\nmodule.exports = template;\n\nfunction template(encoding, layout, stats) {\n  // jshint unused:false\n\n  var data = {name: RAW, format: {}},\n    table = {name: TABLE, source: RAW},\n    dataUrl = encoding.data('url'),\n    dataType = encoding.data('formatType'),\n    values = encoding.data('values');\n\n  if (encoding.hasValues()) {\n    data.values = values;\n  } else {\n    data.url = dataUrl;\n    data.format.type = dataType;\n  }\n\n  encoding.forEach(function(field, encType) {\n    var name;\n    if (field.type == T) {\n      data.format.parse = data.format.parse || {};\n      data.format.parse[field.name] = 'date';\n    } else if (field.type == Q) {\n      data.format.parse = data.format.parse || {};\n      if (vlfield.isCount(field)) {\n        name = 'count';\n      } else {\n        name = field.name;\n      }\n      data.format.parse[name] = 'number';\n    }\n  });\n\n  return {\n    width: layout.width,\n    height: layout.height,\n    padding: 'auto',\n    data: [data, table],\n    marks: [groupdef('cell', {\n      width: layout.cellWidth ? {value: layout.cellWidth} : undefined,\n      height: layout.cellHeight ? {value: layout.cellHeight} : undefined\n    })]\n  };\n}\n\n},{\"../field\":35,\"../globals\":36,\"./group\":21}],31:[function(require,module,exports){\n'use strict';\n\nvar util = require('../util'),\n  d3_time_format = require('d3-time-format');\n\nmodule.exports = time;\n\nvar LONG_DATE = new Date(2014, 8, 17);\n\nfunction time(spec, encoding) { // FIXME refactor to reduce side effect #276\n  // jshint unused:false\n  var timeFields = {}, timeUnits = {};\n\n  // find unique formula transformation and bin function\n  encoding.forEach(function(field, encType) {\n    if (field.type === T && field.timeUnit) {\n      timeFields[encoding.fieldRef(encType)] = {\n        field: field,\n        encType: encType\n      };\n      timeUnits[field.timeUnit] = true;\n    }\n  });\n\n  // add formula transform\n  var data = spec.data[0],\n    transform = data.transform = data.transform || [];\n\n  for (var f in timeFields) {\n    var tf = timeFields[f];\n    time.transform(transform, encoding, tf.encType, tf.field);\n  }\n\n  // add scales\n  var scales = spec.scales = spec.scales || [];\n  for (var timeUnit in timeUnits) {\n    var scale = time.scale.def(timeUnit, encoding);\n    if (scale) scales.push(scale);\n  }\n  return spec;\n}\n\ntime.cardinality = function(field, stats, filterNull, type) {\n  var timeUnit = field.timeUnit;\n  switch (timeUnit) {\n    case 'seconds': return 60;\n    case 'minutes': return 60;\n    case 'hours': return 24;\n    case 'day': return 7;\n    case 'date': return 31;\n    case 'month': return 12;\n    case 'year':\n      var stat = stats[field.name],\n        yearstat = stats['year_'+field.name];\n\n      if (!yearstat) { return null; }\n\n      return yearstat.distinct -\n        (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n  }\n\n  return null;\n};\n\ntime.maxLength = function(timeUnit, encoding) {\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'date':\n      return 2;\n    case 'month':\n    case 'day':\n      var range = time.range(timeUnit, encoding);\n      if (range) {\n        // return the longest name in the range\n        return Math.max.apply(null, range.map(function(r) {return r.length;}));\n      }\n      return 2;\n    case 'year':\n      return 4; //'1998'\n  }\n  // no time unit\n  var timeFormat = encoding.config('timeFormat');\n  return d3_time_format.utcFormat(timeFormat)(LONG_DATE).length;\n};\n\nfunction fieldFn(func, field) {\n  return 'utc' + func + '(d.data.'+ field.name +')';\n}\n\n/**\n * @return {String} date binning formula of the given field\n */\ntime.formula = function(field) {\n  return fieldFn(field.timeUnit, field);\n};\n\n/** add formula transforms to data */\ntime.transform = function(transform, encoding, encType, field) {\n  transform.push({\n    type: 'formula',\n    field: encoding.fieldRef(encType),\n    expr: time.formula(field)\n  });\n};\n\ntime.range = function(timeUnit, encoding) {\n  var labelLength = encoding.config('timeScaleLabelLength'),\n    scaleLabel;\n  switch (timeUnit) {\n    case 'day':\n      scaleLabel = encoding.config('dayScaleLabel');\n      break;\n    case 'month':\n      scaleLabel = encoding.config('monthScaleLabel');\n      break;\n  }\n  if (scaleLabel) {\n    return labelLength ? scaleLabel.map(\n        function(s) { return s.substr(0, labelLength);}\n      ) : scaleLabel;\n  }\n  return;\n};\n\n\ntime.scale = {};\n\n/** append custom time scales for axis label */\ntime.scale.def = function(timeUnit, encoding) {\n  var range = time.range(timeUnit, encoding);\n\n  if (range) {\n    return {\n      name: 'time-'+timeUnit,\n      type: 'ordinal',\n      domain: time.scale.domain(timeUnit),\n      range: range\n    };\n  }\n  return null;\n};\n\ntime.isOrdinalFn = function(timeUnit) {\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'day':\n    case 'date':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\ntime.scale.type = function(timeUnit, name) {\n  if (name === COLOR) {\n    return 'linear'; // time has order, so use interpolated ordinal color scale.\n  }\n\n  return time.isOrdinalFn(timeUnit) || name === COL || name === ROW ? 'ordinal' : 'linear';\n};\n\ntime.scale.domain = function(timeUnit, name) {\n  var isColor = name === COLOR;\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes': return isColor ? [0,59] : util.range(0, 60);\n    case 'hours': return isColor ? [0,23] : util.range(0, 24);\n    case 'day': return isColor ? [0,6] : util.range(0, 7);\n    case 'date': return isColor ? [1,31] : util.range(1, 32);\n    case 'month': return isColor ? [0,11] : util.range(0, 12);\n  }\n  return null;\n};\n\n/** whether a particular time function has custom scale for labels implemented in time.scale */\ntime.hasScale = function(timeUnit) {\n  switch (timeUnit) {\n    case 'day':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\n},{\"../util\":39,\"d3-time-format\":6}],32:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, TEXT, DETAIL];\n\nconsts.shorthand = {\n  delim:  '|',\n  assign: '=',\n  type:   ',',\n  func:   '_'\n};\n\n},{\"./globals\":36}],33:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar stats = require('datalib/src/stats');\n\nvar vldata = module.exports = {};\n\n/** Mapping from datalib's inferred type to Vega-lite's type */\nvldata.types = {\n  'boolean': N,\n  'number': Q,\n  'integer': Q,\n  'date': T,\n  'string': N\n};\n\nvldata.stats = function(data) {\n  var summary = stats.summary(data);\n\n  return summary.reduce(function(s, profile) {\n    s[profile.field] = profile;\n    return s;\n  }, {\n    '*': {\n      max: data.length,\n      min: 0\n    }\n  });\n};\n},{\"./globals\":36,\"datalib/src/stats\":11}],34:[function(require,module,exports){\n// utility for enc\n\n'use strict';\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  vlfield = require('./field'),\n  util = require('./util'),\n  schema = require('./schema/schema'),\n  encTypes = schema.encTypes;\n\nvar vlenc = module.exports = {};\n\nvlenc.countRetinal = function(enc) {\n  var count = 0;\n  if (enc.color) count++;\n  if (enc.size) count++;\n  if (enc.shape) count++;\n  return count;\n};\n\nvlenc.has = function(enc, encType) {\n  var fieldDef = enc && enc[encType];\n  return fieldDef && fieldDef.name;\n};\n\nvlenc.isAggregate = function(enc) {\n  for (var k in enc) {\n    if (vlenc.has(enc, k) && enc[k].aggregate) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvlenc.forEach = function(enc, f) {\n  var i = 0;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      f(enc[k], k, i++);\n    }\n  });\n};\n\nvlenc.map = function(enc, f) {\n  var arr = [];\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      arr.push(f(enc[k], k, enc));\n    }\n  });\n  return arr;\n};\n\nvlenc.reduce = function(enc, f, init) {\n  var r = init;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      r = f(r, enc[k], k,  enc);\n    }\n  });\n  return r;\n};\n\n/*\n * return key-value pairs of field name and list of fields of that field name\n */\nvlenc.fields = function(enc) {\n  return vlenc.reduce(enc, function (m, field) {\n    var fieldList = m[field.name] = m[field.name] || [],\n      containsType = fieldList.containsType = fieldList.containsType || {};\n\n    if (fieldList.indexOf(field) === -1) {\n      fieldList.push(field);\n      // augment the array with containsType.Q / O / N / T\n      containsType[field.type] = true;\n    }\n    return m;\n  }, {});\n};\n\nvlenc.shorthand = function(enc) {\n  return vlenc.map(enc, function(field, et) {\n    return et + c.assign + vlfield.shorthand(field);\n  }).join(c.delim);\n};\n\nvlenc.fromShorthand = function(shorthand) {\n  var enc = util.isArray(shorthand) ? shorthand : shorthand.split(c.delim);\n  return enc.reduce(function(m, e) {\n    var split = e.split(c.assign),\n        enctype = split[0].trim(),\n        field = split[1];\n\n    m[enctype] = vlfield.fromShorthand(field);\n    return m;\n  }, {});\n};\n},{\"./consts\":32,\"./field\":35,\"./schema/schema\":37,\"./util\":39}],35:[function(require,module,exports){\n'use strict';\n\n// utility for field\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compiler/time'),\n  util = require('./util'),\n  schema = require('./schema/schema');\n\nvar vlfield = module.exports = {};\n\n/**\n * @param field\n * @param opt\n *   opt.nofn -- exclude bin, aggregate, timeUnit\n *   opt.data - include 'data.'\n *   opt.fn - replace fn with custom function prefix\n *   opt.prefn - prepend fn with custom function prefix\n\n * @return {[type]}       [description]\n */\nvlfield.fieldRef = function(field, opt) {\n  opt = opt || {};\n\n  var f = (opt.data ? 'data.' : '') + (opt.prefn || ''),\n    nofn = opt.nofn || opt.fn,\n    name = field.name;\n\n  if (vlfield.isCount(field)) {\n    return f + 'count';\n  } else if (!nofn && field.bin) {\n    return f + 'bin_' + name;\n  } else if (!nofn && field.aggregate) {\n    return f + field.aggregate + '_' + name;\n  } else if (!nofn && field.timeUnit) {\n    return f + field.timeUnit + '_' + name;\n  } else if (opt.fn) {\n    return f + opt.fn + '_' + name;\n  } else {\n    return f + name;\n  }\n};\n\nvlfield.shorthand = function(f) {\n  var c = consts.shorthand;\n  return (f.aggregate ? f.aggregate + c.func : '') +\n    (f.timeUnit ? f.timeUnit + c.func : '') +\n    (f.bin ? 'bin' + c.func : '') +\n    (f.name || '') + c.type + f.type;\n};\n\nvlfield.shorthands = function(fields, delim) {\n  delim = delim || c.delim;\n  return fields.map(vlfield.shorthand).join(delim);\n};\n\nvlfield.fromShorthand = function(shorthand) {\n  var split = shorthand.split(c.type), i;\n  var o = {\n    name: split[0].trim(),\n    type: split[1].trim()\n  };\n\n  // check aggregate type\n  for (i in schema.aggregate.enum) {\n    var a = schema.aggregate.enum[i];\n    if (o.name.indexOf(a + '_') === 0) {\n      o.name = o.name.substr(a.length + 1);\n      if (a == 'count' && o.name.length === 0) o.name = '*';\n      o.aggregate = a;\n      break;\n    }\n  }\n\n  // check time timeUnit\n  for (i in schema.timefns) {\n    var tu = schema.timefns[i];\n    if (o.name && o.name.indexOf(tu + '_') === 0) {\n      o.name = o.name.substr(o.length + 1);\n      o.timeUnit = tu;\n      break;\n    }\n  }\n\n  // check bin\n  if (o.name && o.name.indexOf('bin_') === 0) {\n    o.name = o.name.substr(4);\n    o.bin = true;\n  }\n\n  return o;\n};\n\nvar isType = vlfield.isType = function (fieldDef, type) {\n  return fieldDef.type === type;\n};\n\nvar isTypes = vlfield.isTypes = function (fieldDef, types) {\n  for (var t=0; t<types.length; t++) {\n    if(fieldDef.type === types[t]) return true;\n  }\n  return false;\n};\n\n/*\n * Most fields that use ordinal scale are dimensions.\n * However, YEAR(T), YEARMONTH(T) use time scale, not ordinal but are dimensions too.\n */\nvlfield.isOrdinalScale = function(field) {\n  return  isTypes(field, [N, O]) || field.bin ||\n    ( isType(field, T) && field.timeUnit && time.isOrdinalFn(field.timeUnit) );\n};\n\nfunction isDimension(field) {\n  return  isTypes(field, [N, O]) || !!field.bin ||\n    ( isType(field, T) && !!field.timeUnit );\n}\n\n/**\n * For encoding, use encoding.isDimension() to avoid confusion.\n * Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.isDimension = function(field) {\n  return field && isDimension(field);\n};\n\nvlfield.isMeasure = function(field) {\n  return field && !isDimension(field);\n};\n\nvlfield.count = function() {\n  return {name:'*', aggregate: 'count', type: Q, displayName: vlfield.count.displayName};\n};\n\nvlfield.count.displayName = 'Number of Records';\n\nvlfield.isCount = function(field) {\n  return field.aggregate === 'count';\n};\n\n/**\n * For encoding, use encoding.cardinality() to avoid confusion.  Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.cardinality = function(field, stats, filterNull) {\n  // FIXME need to take filter into account\n\n  var stat = stats[field.name];\n  var type = field.type;\n\n  filterNull = filterNull || {};\n\n  if (field.bin) {\n    var bins = util.getbins(stat, field.bin.maxbins || schema.MAXBINS_DEFAULT);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  if (isType(field, T)) {\n    var cardinality = time.cardinality(field, stats, filterNull, type);\n    if(cardinality !== null) return cardinality;\n    //otherwise use calculation below\n  }\n  if (field.aggregate) {\n    return 1;\n  }\n\n  // remove null\n  return stat.distinct -\n    (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n};\n\n},{\"./compiler/time\":31,\"./consts\":32,\"./globals\":36,\"./schema/schema\":37,\"./util\":39}],36:[function(require,module,exports){\n(function (global){\n'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.TABLE = 'table';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.N = 'N';\ng.O = 'O';\ng.Q = 'Q';\ng.T = 'T';\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],37:[function(require,module,exports){\n// Package of defining Vega-lite Specification's json schema\n'use strict';\n\nrequire('../globals');\n\nvar schema = module.exports = {},\n  util = require('../util'),\n  toMap = util.toMap,\n  colorbrewer = require('colorbrewer');\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: 'string',\n  enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\n};\n\nschema.aggregate = {\n  type: 'string',\n  enum: ['avg', 'sum', 'median', 'min', 'max', 'count'],\n  supportedEnums: {\n    Q: ['avg', 'median', 'sum', 'min', 'max', 'count'],\n    O: ['median','min','max'],\n    N: [],\n    T: ['avg', 'median', 'min', 'max'],\n    '': ['count']\n  },\n  supportedTypes: toMap([Q, N, O, T, ''])\n};\n\nschema.getSupportedRole = function(encType) {\n  return schema.schema.properties.encoding.properties[encType].supportedRole;\n};\n\nschema.timeUnits = ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'];\n\nschema.defaultTimeFn = 'month';\n\nschema.timeUnit = {\n  type: 'string',\n  enum: schema.timeUnits,\n  supportedTypes: toMap([T])\n};\n\nschema.scale_type = {\n  type: 'string',\n  // TODO(kanitw) read vega's schema here, add description\n  enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\n  default: 'linear',\n  supportedTypes: toMap([Q])\n};\n\nschema.field = {\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string'\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nschema.MAXBINS_DEFAULT = 15;\n\nvar bin = {\n  type: ['boolean', 'object'],\n  default: false,\n  properties: {\n    maxbins: {\n      type: 'integer',\n      default: schema.MAXBINS_DEFAULT,\n      minimum: 2,\n      description: 'Maximum number of bins.'\n    }\n  },\n  supportedTypes: toMap([Q]) // TODO: add O after finishing #81\n};\n\nvar typicalField = merge(clone(schema.field), {\n  type: 'object',\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T]\n    },\n    aggregate: schema.aggregate,\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    scale: {\n      type: 'object',\n      properties: {\n        type: schema.scale_type,\n        reverse: {\n          type: 'boolean',\n          default: false,\n          supportedTypes: toMap([Q, T])\n        },\n        zero: {\n          type: 'boolean',\n          description: 'Include zero',\n          default: true,\n          supportedTypes: toMap([Q, T])\n        },\n        nice: {\n          type: 'string',\n          enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\n          supportedTypes: toMap([T])\n        },\n        useRawDomain: {\n          type: 'boolean',\n          default: undefined,\n          description: 'Use the raw data range as scale domain instead of ' +\n                       'aggregated data for aggregate axis. ' +\n                       'This option does not work with sum or count aggregate' +\n                       'as they might have a substantially larger scale range.' +\n                       'By default, use value from config.useRawDomain.'\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: 'object',\n  supportedRole: {\n    dimension: true\n  },\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T] // ordinal-only field supports Q when bin is applied and T when time unit is applied.\n    },\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    aggregate: {\n      type: 'string',\n      enum: ['count'],\n      supportedTypes: toMap([N, O]) // FIXME this looks weird to me\n    }\n  }\n});\n\nvar axisMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true},\n  properties: {\n    axis: {\n      type: 'object',\n      properties: {\n        grid: {\n          type: 'boolean',\n          default: true,\n          description: 'A flag indicate if gridlines should be created in addition to ticks.'\n        },\n        layer: {\n          type: 'string',\n          default: 'back',\n          description: 'A string indicating if the axis (and any gridlines) should be placed above or below the data marks.'\n        },\n        orient: {\n          type: 'string',\n          default: undefined,\n          enum: ['top', 'right', 'left', 'bottom'],\n          description: 'The orientation of the axis. One of top, bottom, left or right. The orientation can be used to further specialize the axis type (e.g., a y axis oriented for the right edge of the chart).'\n        },\n        ticks :{\n          type: 'integer',\n          default: 5,\n          description: 'A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale\\'s range.'\n        },\n        title: {\n          type: 'string',\n          default: undefined,\n          description: 'A title for the axis. (Shows field name and its function by default.)'\n        },\n        titleMaxLength: {\n          type: 'integer',\n          default: undefined,\n          description: 'Max length for axis title if the title is automatically generated from the field\\'s description'\n        },\n        titleOffset: {\n          type: 'integer',\n          default: undefined,  // auto\n          description: 'A title offset value for the axis.'\n        },\n        format: {\n          type: 'string',\n          default: undefined,  // auto\n          description: 'The formatting pattern for axis labels. '+\n                       'If not undefined, this will be determined by ' +\n                       'small/largeNumberFormat and the max value ' +\n                       'of the field.'\n        },\n        maxLabelLength: {\n          type: 'integer',\n          default: 25,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar sortMixin = {\n  type: 'object',\n  properties: {\n    sort: {\n      type: 'array',\n      default: [],\n      items: {\n        type: 'object',\n        supportedTypes: toMap([N, O]),\n        required: ['name', 'aggregate'],\n        properties: {\n          name: {\n            type: 'string'\n          },\n          aggregate: {\n            type: 'string',\n            enum: ['avg', 'sum', 'min', 'max', 'count']\n          },\n          reverse: {\n            type: 'boolean',\n            default: false\n          }\n        }\n      }\n    }\n  }\n};\n\nvar bandMixin = {\n  type: 'object',\n  properties: {\n    band: {\n      type: 'object',\n      properties: {\n        size: {\n          type: 'integer',\n          minimum: 0,\n          default: undefined\n        },\n        padding: {\n          type: 'integer',\n          minimum: 0,\n          default: 1\n        }\n      }\n    }\n  }\n};\n\nvar legendMixin = {\n  type: 'object',\n  properties: {\n    legend: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nvar textMixin = {\n  type: 'object',\n  supportedMarktypes: {'text': true},\n  properties: {\n    align: {\n      type: 'string',\n      default: 'right'\n    },\n    baseline: {\n      type: 'string',\n      default: 'middle'\n    },\n    color: {\n      type: 'string',\n      role: 'color',\n      default: '#000000'\n    },\n    margin: {\n      type: 'integer',\n      default: 4,\n      minimum: 0\n    },\n    placeholder: {\n      type: 'string',\n      default: 'Abc'\n    },\n    font: {\n      type: 'object',\n      properties: {\n        weight: {\n          type: 'string',\n          enum: ['normal', 'bold'],\n          default: 'normal'\n        },\n        size: {\n          type: 'integer',\n          default: 10,\n          minimum: 0\n        },\n        family: {\n          type: 'string',\n          default: 'Helvetica Neue'\n        },\n        style: {\n          type: 'string',\n          default: 'normal',\n          enum: ['normal', 'italic']\n        }\n      }\n    },\n    format: {\n      type: 'string',\n      default: undefined,  // auto\n      description: 'The formatting pattern for text value. '+\n                   'If not undefined, this will be determined by ' +\n                   'small/largeNumberFormat and the max value ' +\n                   'of the field.'\n    },\n  }\n};\n\nvar sizeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, bar: true, circle: true, square: true, text: true},\n  properties: {\n    value: {\n      type: 'integer',\n      default: 30,\n      minimum: 0\n    }\n  }\n};\n\nvar colorMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'string',\n      role: 'color',\n      default: 'steelblue'\n    },\n    opacity: {\n      type: 'number',\n      default: undefined,  // auto\n      minimum: 0,\n      maximum: 1\n    },\n    scale: {\n      type: 'object',\n      properties: {\n        range: {\n          type: ['string', 'array'],\n          default: undefined,\n          description:\n            'color palette, if undefined vega-lite will use data property' +\n            'to pick one from c10palette, c20palette, or ordinalPalette'\n        },\n        c10palette: {\n          type: 'string',\n          default: 'category10',\n          enum: [\n            // Tableau\n            'category10', 'category10k',\n            // Color Brewer\n            'Pastel1', 'Pastel2', 'Set1', 'Set2', 'Set3'\n          ]\n        },\n        c20palette: {\n          type: 'string',\n          default: 'category20',\n          enum: ['category20', 'category20b', 'category20c']\n        },\n        ordinalPalette: {\n          type: 'string',\n          default: 'BuGn',\n          enum: util.keys(colorbrewer)\n        }\n      }\n    }\n  }\n};\n\nvar shapeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, circle: true, square: true},\n  properties: {\n    value: {\n      type: 'string',\n      enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\n      default: 'circle'\n    },\n    filled: {\n      type: 'boolean',\n      default: false,\n      description: 'whether the shape\\'s color should be used as fill color instead of stroke color'\n    }\n  }\n};\n\nvar detailMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, line: true, circle: true, square: true}\n};\n\nvar rowMixin = {\n  properties: {\n    height: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    }\n  }\n};\n\nvar colMixin = {\n  properties: {\n    width: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    axis: {\n      properties: {\n        maxLabelLength: {\n          type: 'integer',\n          default: 12,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar facetMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, text: true},\n  properties: {\n    padding: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.1\n    }\n  }\n};\n\nvar requiredNameType = {\n  required: ['name', 'type']\n};\n\nvar multiRoleField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: true\n  }\n});\n\nvar quantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: 'ordinal-only' // using size to encoding category lead to order interpretation\n  }\n});\n\nvar onlyQuantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true\n  }\n});\n\nvar x = merge(clone(multiRoleField), axisMixin, bandMixin, requiredNameType, sortMixin);\nvar y = clone(x);\n\nvar facet = merge(clone(onlyOrdinalField), requiredNameType, facetMixin, sortMixin);\nvar row = merge(clone(facet), axisMixin, rowMixin);\nvar col = merge(clone(facet), axisMixin, colMixin);\n\nvar size = merge(clone(quantitativeField), legendMixin, sizeMixin, sortMixin);\nvar color = merge(clone(multiRoleField), legendMixin, colorMixin, sortMixin);\n\nvar shape = merge(clone(onlyOrdinalField), legendMixin, shapeMixin, sortMixin);\nvar detail = merge(clone(onlyOrdinalField), detailMixin, sortMixin);\n\n// we only put aggregated measure in pivot table\nvar text = merge(clone(onlyQuantitativeField), textMixin, sortMixin);\n\n// TODO add label\n\nvar filter = {\n  type: 'array',\n  items: {\n    type: 'object',\n    properties: {\n      operands: {\n        type: 'array',\n        items: {\n          type: ['string', 'boolean', 'integer', 'number']\n        }\n      },\n      operator: {\n        type: 'string',\n        enum: ['>', '>=', '=', '!=', '<', '<=', 'notNull']\n      }\n    }\n  }\n};\n\nvar data = {\n  type: 'object',\n  properties: {\n    // data source\n    formatType: {\n      type: 'string',\n      enum: ['json', 'csv'],\n      default: 'json'\n    },\n    url: {\n      type: 'string',\n      default: undefined\n    },\n    values: {\n      type: 'array',\n      default: undefined,\n      description: 'Pass array of objects instead of a url to a file.',\n      items: {\n        type: 'object',\n        additionalProperties: true\n      }\n    }\n  }\n};\n\nvar config = {\n  type: 'object',\n  properties: {\n    // template\n    width: {\n      type: 'integer',\n      default: undefined\n    },\n    height: {\n      type: 'integer',\n      default: undefined\n    },\n    viewport: {\n      type: 'array',\n      items: {\n        type: 'integer'\n      },\n      default: undefined\n    },\n    gridColor: {\n      type: 'string',\n      role: 'color',\n      default: 'black'\n    },\n    gridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.08\n    },\n\n    // filter null\n    filterNull: {\n      type: 'object',\n      properties: {\n        O: {type:'boolean', default: false},\n        Q: {type:'boolean', default: true},\n        T: {type:'boolean', default: true}\n      }\n    },\n    toggleSort: {\n      type: 'string',\n      default: O\n    },\n\n    // single plot\n    singleHeight: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    singleWidth: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    // band size\n    largeBandSize: {\n      type: 'integer',\n      default: 21,\n      minimum: 0\n    },\n    smallBandSize: {\n      //small multiples or single plot with high cardinality\n      type: 'integer',\n      default: 12,\n      minimum: 0\n    },\n    largeBandMaxCardinality: {\n      type: 'integer',\n      default: 10\n    },\n    // small multiples\n    cellPadding: {\n      type: 'number',\n      default: 0.1\n    },\n    cellGridColor: {\n      type: 'string',\n      role: 'color',\n      default: 'black'\n    },\n    cellGridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.15\n    },\n    cellBackgroundColor: {\n      type: 'string',\n      role: 'color',\n      default: 'transparent'\n    },\n    textCellWidth: {\n      type: 'integer',\n      default: 90,\n      minimum: 0\n    },\n\n    // marks\n    strokeWidth: {\n      type: 'integer',\n      default: 2,\n      minimum: 0\n    },\n    singleBarOffset: {\n      type: 'integer',\n      default: 5,\n      minimum: 0\n    },\n    // scales\n    timeScaleLabelLength: {\n      type: 'integer',\n      default: 3,\n      minimum: 0,\n      description: 'Max length for values in dayScaleLabel and monthScaleLabel.  Zero means using full names in dayScaleLabel/monthScaleLabel.'\n    },\n    dayScaleLabel: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      default: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n      description: 'Axis labels for day of week, starting from Sunday.' +\n        '(Consistent with Javascript -- See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getDay.'\n    },\n    monthScaleLabel: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      default: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n      description: 'Axis labels for month.'\n    },\n    // other\n    characterWidth: {\n      type: 'integer',\n      default: 6\n    },\n    maxSmallNumber: {\n      type: 'number',\n      default: 10000,\n      description: 'maximum number that a field will be considered smallNumber.'+\n                   'Used for axis labelling.'\n    },\n    smallNumberFormat: {\n      type: 'string',\n      default: '',\n      description: 'D3 Number format for axis labels and text tables '+\n                   'for number <= maxSmallNumber. Used for axis labelling.'\n    },\n    largeNumberFormat: {\n      type: 'string',\n      default: '.3s',\n      description: 'D3 Number format for axis labels and text tables ' +\n                   'for number > maxSmallNumber.'\n    },\n    timeFormat: {\n      type: 'string',\n      default: '%Y-%m-%d',\n      description: 'Date format for axis labels.'\n    },\n    useRawDomain: {\n      type: 'boolean',\n      default: false,\n      description: 'Use the raw data range as scale domain instead of ' +\n                   'aggregated data for aggregate axis. ' +\n                   'This option does not work with sum or count aggregate' +\n                   'as they might have a substantially larger scale range.' +\n                   'By default, use value from config.useRawDomain.'\n    }\n  }\n};\n\n/** @type Object Schema of a vega-lite specification */\nschema.schema = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  description: 'Schema for Vega-lite specification',\n  type: 'object',\n  required: ['marktype', 'encoding', 'data'],\n  properties: {\n    data: data,\n    marktype: schema.marktype,\n    encoding: {\n      type: 'object',\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        shape: shape,\n        text: text,\n        detail: detail\n      }\n    },\n    filter: filter,\n    config: config\n  }\n};\n\nschema.encTypes = util.keys(schema.schema.properties.encoding.properties);\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function() {\n  return schema.util.instantiate(schema.schema);\n};\n\n},{\"../globals\":36,\"../util\":39,\"./schemautil\":38,\"colorbrewer\":3}],38:[function(require,module,exports){\n'use strict';\n\nvar schemautil = module.exports = {},\n  util = require('../util');\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\nschemautil.extend = function(instance, schema) {\n  return schemautil.merge(schemautil.instantiate(schema), instance);\n};\n\n// instantiate a schema\nschemautil.instantiate = function(schema) {\n  var val;\n  if (schema === undefined) {\n    return undefined;\n  } else if ('default' in schema) {\n    val = schema.default;\n    return util.isObject(val) ? util.duplicate(val) : val;\n  } else if (schema.type === 'object') {\n    var instance = {};\n    for (var name in schema.properties) {\n      val = schemautil.instantiate(schema.properties[name]);\n      if (val !== undefined) {\n        instance[name] = val;\n      }\n    }\n    return instance;\n  } else if (schema.type === 'array') {\n    return [];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nschemautil.subtract = function(instance, defaults) {\n  var changes = {};\n  for (var prop in instance) {\n    var def = defaults[prop];\n    var ins = instance[prop];\n    // Note: does not properly subtract arrays\n    if (!defaults || def !== ins) {\n      if (typeof ins === 'object' && !util.isArray(ins) && def) {\n        var c = schemautil.subtract(ins, def);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else if (!util.isArray(ins) || ins.length > 0) {\n        changes[prop] = ins;\n      }\n    }\n  }\n  return changes;\n};\n\nschemautil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction merge(dest, src) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (var p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      merge(dest[p], src[p]);\n    }\n  }\n  return dest;\n}\n},{\"../util\":39}],39:[function(require,module,exports){\n'use strict';\n\nvar util = module.exports = require('datalib/src/util');\n\nutil.extend(util, require('datalib/src/generate'));\nutil.extend(util, require('datalib/src/stats'));\nutil.bin = require('datalib/src/bins/bins');\n\nutil.isin = function(item, array) {\n  return array.indexOf(item) !== -1;\n};\n\nutil.forEach = function(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  } else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k , obj);\n    }\n  }\n};\n\nutil.reduce = function(obj, f, init, thisArg) {\n  if (obj.reduce) {\n    return obj.reduce.call(thisArg, f, init);\n  } else {\n    for (var k in obj) {\n      init = f.call(thisArg, init, obj[k], k, obj);\n    }\n    return init;\n  }\n};\n\nutil.map = function(obj, f, thisArg) {\n  if (obj.map) {\n    return obj.map.call(thisArg, f);\n  } else {\n    var output = [];\n    for (var k in obj) {\n      output.push( f.call(thisArg, obj[k], k, obj));\n    }\n  }\n};\n\nutil.any = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (f(arr[k], k, i++)) return true;\n  }\n  return false;\n};\n\nutil.all = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (!f(arr[k], k, i++)) return false;\n  }\n  return true;\n};\n\nutil.getbins = function(stats, maxbins) {\n  return util.bin({\n    min: stats.min,\n    max: stats.max,\n    maxbins: maxbins\n  });\n};\n\n/**\n * x[p[0]]...[p[n]] = val\n * @param noaugment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.setter = function(x, p, val, noaugment) {\n  for (var i=0; i<p.length-1; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  x[p[i]] = val;\n};\n\n\n/**\n * returns x[p[0]]...[p[n]]\n * @param augment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.getter = function(x, p, noaugment) {\n  for (var i=0; i<p.length; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  return x;\n};\n\nutil.error = function(msg) {\n  console.error('[VL Error]', msg);\n};\n\n\n},{\"datalib/src/bins/bins\":8,\"datalib/src/generate\":9,\"datalib/src/stats\":11,\"datalib/src/util\":13}],40:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar util = require('./util'),\n    consts = require('./consts');\n\nvar vl = {};\n\nutil.extend(vl, consts, util);\n\nvl.Encoding = require('./Encoding');\nvl.compiler = require('./compiler/compiler');\nvl.compile = vl.compiler.compile;\nvl.data = require('./data');\nvl.enc = require('./enc');\nvl.field = require('./field');\nvl.schema = require('./schema/schema');\nvl.toShorthand = vl.Encoding.shorthand;\n\nmodule.exports = vl;\n},{\"./Encoding\":14,\"./compiler/compiler\":18,\"./consts\":32,\"./data\":33,\"./enc\":34,\"./field\":35,\"./globals\":36,\"./schema/schema\":37,\"./util\":39}]},{},[40])(40)\n});\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yYnJld2VyL2NvbG9yYnJld2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yYnJld2VyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2QzLWNvbG9yL2J1aWxkL2NvbG9yLmpzIiwibm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9idWlsZC9mb3JtYXQuanMiLCJub2RlX21vZHVsZXMvZDMtdGltZS1mb3JtYXQvYnVpbGQvdGltZUZvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL25vZGVfbW9kdWxlcy9kMy10aW1lL2J1aWxkL3RpbWUuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvYmlucy9iaW5zLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2dlbmVyYXRlLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC90eXBlLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL3N0YXRzLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL3RpbWUuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvdXRpbC5qcyIsInNyYy9FbmNvZGluZy5qcyIsInNyYy9jb21waWxlci9hZ2dyZWdhdGUuanMiLCJzcmMvY29tcGlsZXIvYXhpcy5qcyIsInNyYy9jb21waWxlci9iaW4uanMiLCJzcmMvY29tcGlsZXIvY29tcGlsZXIuanMiLCJzcmMvY29tcGlsZXIvZmFjZXQuanMiLCJzcmMvY29tcGlsZXIvZmlsdGVyLmpzIiwic3JjL2NvbXBpbGVyL2dyb3VwLmpzIiwic3JjL2NvbXBpbGVyL2xheW91dC5qcyIsInNyYy9jb21waWxlci9sZWdlbmQuanMiLCJzcmMvY29tcGlsZXIvbWFya3MuanMiLCJzcmMvY29tcGlsZXIvc2NhbGUuanMiLCJzcmMvY29tcGlsZXIvc29ydC5qcyIsInNyYy9jb21waWxlci9zdGFjay5qcyIsInNyYy9jb21waWxlci9zdHlsZS5qcyIsInNyYy9jb21waWxlci9zdWJmYWNldC5qcyIsInNyYy9jb21waWxlci90ZW1wbGF0ZS5qcyIsInNyYy9jb21waWxlci90aW1lLmpzIiwic3JjL2NvbnN0cy5qcyIsInNyYy9kYXRhLmpzIiwic3JjL2VuYy5qcyIsInNyYy9maWVsZC5qcyIsInNyYy9nbG9iYWxzLmpzIiwic3JjL3NjaGVtYS9zY2hlbWEuanMiLCJzcmMvc2NoZW1hL3NjaGVtYXV0aWwuanMiLCJzcmMvdXRpbC5qcyIsInNyYy92bCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNUQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3dUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLG51bGwsIi8vIFRoaXMgcHJvZHVjdCBpbmNsdWRlcyBjb2xvciBzcGVjaWZpY2F0aW9ucyBhbmQgZGVzaWducyBkZXZlbG9wZWQgYnkgQ3ludGhpYSBCcmV3ZXIgKGh0dHA6Ly9jb2xvcmJyZXdlci5vcmcvKS5cbi8vIEphdmFTY3JpcHQgc3BlY3MgYXMgcGFja2FnZWQgaW4gdGhlIEQzIGxpYnJhcnkgKGQzanMub3JnKS4gUGxlYXNlIHNlZSBsaWNlbnNlIGF0IGh0dHA6Ly9jb2xvcmJyZXdlci5vcmcvZXhwb3J0L0xJQ0VOU0UudHh0XG4hZnVuY3Rpb24oKSB7XG5cbnZhciBjb2xvcmJyZXdlciA9IHtZbEduOiB7XG4zOiBbXCIjZjdmY2I5XCIsXCIjYWRkZDhlXCIsXCIjMzFhMzU0XCJdLFxuNDogW1wiI2ZmZmZjY1wiLFwiI2MyZTY5OVwiLFwiIzc4YzY3OVwiLFwiIzIzODQ0M1wiXSxcbjU6IFtcIiNmZmZmY2NcIixcIiNjMmU2OTlcIixcIiM3OGM2NzlcIixcIiMzMWEzNTRcIixcIiMwMDY4MzdcIl0sXG42OiBbXCIjZmZmZmNjXCIsXCIjZDlmMGEzXCIsXCIjYWRkZDhlXCIsXCIjNzhjNjc5XCIsXCIjMzFhMzU0XCIsXCIjMDA2ODM3XCJdLFxuNzogW1wiI2ZmZmZjY1wiLFwiI2Q5ZjBhM1wiLFwiI2FkZGQ4ZVwiLFwiIzc4YzY3OVwiLFwiIzQxYWI1ZFwiLFwiIzIzODQ0M1wiLFwiIzAwNWEzMlwiXSxcbjg6IFtcIiNmZmZmZTVcIixcIiNmN2ZjYjlcIixcIiNkOWYwYTNcIixcIiNhZGRkOGVcIixcIiM3OGM2NzlcIixcIiM0MWFiNWRcIixcIiMyMzg0NDNcIixcIiMwMDVhMzJcIl0sXG45OiBbXCIjZmZmZmU1XCIsXCIjZjdmY2I5XCIsXCIjZDlmMGEzXCIsXCIjYWRkZDhlXCIsXCIjNzhjNjc5XCIsXCIjNDFhYjVkXCIsXCIjMjM4NDQzXCIsXCIjMDA2ODM3XCIsXCIjMDA0NTI5XCJdXG59LFlsR25CdToge1xuMzogW1wiI2VkZjhiMVwiLFwiIzdmY2RiYlwiLFwiIzJjN2ZiOFwiXSxcbjQ6IFtcIiNmZmZmY2NcIixcIiNhMWRhYjRcIixcIiM0MWI2YzRcIixcIiMyMjVlYThcIl0sXG41OiBbXCIjZmZmZmNjXCIsXCIjYTFkYWI0XCIsXCIjNDFiNmM0XCIsXCIjMmM3ZmI4XCIsXCIjMjUzNDk0XCJdLFxuNjogW1wiI2ZmZmZjY1wiLFwiI2M3ZTliNFwiLFwiIzdmY2RiYlwiLFwiIzQxYjZjNFwiLFwiIzJjN2ZiOFwiLFwiIzI1MzQ5NFwiXSxcbjc6IFtcIiNmZmZmY2NcIixcIiNjN2U5YjRcIixcIiM3ZmNkYmJcIixcIiM0MWI2YzRcIixcIiMxZDkxYzBcIixcIiMyMjVlYThcIixcIiMwYzJjODRcIl0sXG44OiBbXCIjZmZmZmQ5XCIsXCIjZWRmOGIxXCIsXCIjYzdlOWI0XCIsXCIjN2ZjZGJiXCIsXCIjNDFiNmM0XCIsXCIjMWQ5MWMwXCIsXCIjMjI1ZWE4XCIsXCIjMGMyYzg0XCJdLFxuOTogW1wiI2ZmZmZkOVwiLFwiI2VkZjhiMVwiLFwiI2M3ZTliNFwiLFwiIzdmY2RiYlwiLFwiIzQxYjZjNFwiLFwiIzFkOTFjMFwiLFwiIzIyNWVhOFwiLFwiIzI1MzQ5NFwiLFwiIzA4MWQ1OFwiXVxufSxHbkJ1OiB7XG4zOiBbXCIjZTBmM2RiXCIsXCIjYThkZGI1XCIsXCIjNDNhMmNhXCJdLFxuNDogW1wiI2YwZjllOFwiLFwiI2JhZTRiY1wiLFwiIzdiY2NjNFwiLFwiIzJiOGNiZVwiXSxcbjU6IFtcIiNmMGY5ZThcIixcIiNiYWU0YmNcIixcIiM3YmNjYzRcIixcIiM0M2EyY2FcIixcIiMwODY4YWNcIl0sXG42OiBbXCIjZjBmOWU4XCIsXCIjY2NlYmM1XCIsXCIjYThkZGI1XCIsXCIjN2JjY2M0XCIsXCIjNDNhMmNhXCIsXCIjMDg2OGFjXCJdLFxuNzogW1wiI2YwZjllOFwiLFwiI2NjZWJjNVwiLFwiI2E4ZGRiNVwiLFwiIzdiY2NjNFwiLFwiIzRlYjNkM1wiLFwiIzJiOGNiZVwiLFwiIzA4NTg5ZVwiXSxcbjg6IFtcIiNmN2ZjZjBcIixcIiNlMGYzZGJcIixcIiNjY2ViYzVcIixcIiNhOGRkYjVcIixcIiM3YmNjYzRcIixcIiM0ZWIzZDNcIixcIiMyYjhjYmVcIixcIiMwODU4OWVcIl0sXG45OiBbXCIjZjdmY2YwXCIsXCIjZTBmM2RiXCIsXCIjY2NlYmM1XCIsXCIjYThkZGI1XCIsXCIjN2JjY2M0XCIsXCIjNGViM2QzXCIsXCIjMmI4Y2JlXCIsXCIjMDg2OGFjXCIsXCIjMDg0MDgxXCJdXG59LEJ1R246IHtcbjM6IFtcIiNlNWY1ZjlcIixcIiM5OWQ4YzlcIixcIiMyY2EyNWZcIl0sXG40OiBbXCIjZWRmOGZiXCIsXCIjYjJlMmUyXCIsXCIjNjZjMmE0XCIsXCIjMjM4YjQ1XCJdLFxuNTogW1wiI2VkZjhmYlwiLFwiI2IyZTJlMlwiLFwiIzY2YzJhNFwiLFwiIzJjYTI1ZlwiLFwiIzAwNmQyY1wiXSxcbjY6IFtcIiNlZGY4ZmJcIixcIiNjY2VjZTZcIixcIiM5OWQ4YzlcIixcIiM2NmMyYTRcIixcIiMyY2EyNWZcIixcIiMwMDZkMmNcIl0sXG43OiBbXCIjZWRmOGZiXCIsXCIjY2NlY2U2XCIsXCIjOTlkOGM5XCIsXCIjNjZjMmE0XCIsXCIjNDFhZTc2XCIsXCIjMjM4YjQ1XCIsXCIjMDA1ODI0XCJdLFxuODogW1wiI2Y3ZmNmZFwiLFwiI2U1ZjVmOVwiLFwiI2NjZWNlNlwiLFwiIzk5ZDhjOVwiLFwiIzY2YzJhNFwiLFwiIzQxYWU3NlwiLFwiIzIzOGI0NVwiLFwiIzAwNTgyNFwiXSxcbjk6IFtcIiNmN2ZjZmRcIixcIiNlNWY1ZjlcIixcIiNjY2VjZTZcIixcIiM5OWQ4YzlcIixcIiM2NmMyYTRcIixcIiM0MWFlNzZcIixcIiMyMzhiNDVcIixcIiMwMDZkMmNcIixcIiMwMDQ0MWJcIl1cbn0sUHVCdUduOiB7XG4zOiBbXCIjZWNlMmYwXCIsXCIjYTZiZGRiXCIsXCIjMWM5MDk5XCJdLFxuNDogW1wiI2Y2ZWZmN1wiLFwiI2JkYzllMVwiLFwiIzY3YTljZlwiLFwiIzAyODE4YVwiXSxcbjU6IFtcIiNmNmVmZjdcIixcIiNiZGM5ZTFcIixcIiM2N2E5Y2ZcIixcIiMxYzkwOTlcIixcIiMwMTZjNTlcIl0sXG42OiBbXCIjZjZlZmY3XCIsXCIjZDBkMWU2XCIsXCIjYTZiZGRiXCIsXCIjNjdhOWNmXCIsXCIjMWM5MDk5XCIsXCIjMDE2YzU5XCJdLFxuNzogW1wiI2Y2ZWZmN1wiLFwiI2QwZDFlNlwiLFwiI2E2YmRkYlwiLFwiIzY3YTljZlwiLFwiIzM2OTBjMFwiLFwiIzAyODE4YVwiLFwiIzAxNjQ1MFwiXSxcbjg6IFtcIiNmZmY3ZmJcIixcIiNlY2UyZjBcIixcIiNkMGQxZTZcIixcIiNhNmJkZGJcIixcIiM2N2E5Y2ZcIixcIiMzNjkwYzBcIixcIiMwMjgxOGFcIixcIiMwMTY0NTBcIl0sXG45OiBbXCIjZmZmN2ZiXCIsXCIjZWNlMmYwXCIsXCIjZDBkMWU2XCIsXCIjYTZiZGRiXCIsXCIjNjdhOWNmXCIsXCIjMzY5MGMwXCIsXCIjMDI4MThhXCIsXCIjMDE2YzU5XCIsXCIjMDE0NjM2XCJdXG59LFB1QnU6IHtcbjM6IFtcIiNlY2U3ZjJcIixcIiNhNmJkZGJcIixcIiMyYjhjYmVcIl0sXG40OiBbXCIjZjFlZWY2XCIsXCIjYmRjOWUxXCIsXCIjNzRhOWNmXCIsXCIjMDU3MGIwXCJdLFxuNTogW1wiI2YxZWVmNlwiLFwiI2JkYzllMVwiLFwiIzc0YTljZlwiLFwiIzJiOGNiZVwiLFwiIzA0NWE4ZFwiXSxcbjY6IFtcIiNmMWVlZjZcIixcIiNkMGQxZTZcIixcIiNhNmJkZGJcIixcIiM3NGE5Y2ZcIixcIiMyYjhjYmVcIixcIiMwNDVhOGRcIl0sXG43OiBbXCIjZjFlZWY2XCIsXCIjZDBkMWU2XCIsXCIjYTZiZGRiXCIsXCIjNzRhOWNmXCIsXCIjMzY5MGMwXCIsXCIjMDU3MGIwXCIsXCIjMDM0ZTdiXCJdLFxuODogW1wiI2ZmZjdmYlwiLFwiI2VjZTdmMlwiLFwiI2QwZDFlNlwiLFwiI2E2YmRkYlwiLFwiIzc0YTljZlwiLFwiIzM2OTBjMFwiLFwiIzA1NzBiMFwiLFwiIzAzNGU3YlwiXSxcbjk6IFtcIiNmZmY3ZmJcIixcIiNlY2U3ZjJcIixcIiNkMGQxZTZcIixcIiNhNmJkZGJcIixcIiM3NGE5Y2ZcIixcIiMzNjkwYzBcIixcIiMwNTcwYjBcIixcIiMwNDVhOGRcIixcIiMwMjM4NThcIl1cbn0sQnVQdToge1xuMzogW1wiI2UwZWNmNFwiLFwiIzllYmNkYVwiLFwiIzg4NTZhN1wiXSxcbjQ6IFtcIiNlZGY4ZmJcIixcIiNiM2NkZTNcIixcIiM4Yzk2YzZcIixcIiM4ODQxOWRcIl0sXG41OiBbXCIjZWRmOGZiXCIsXCIjYjNjZGUzXCIsXCIjOGM5NmM2XCIsXCIjODg1NmE3XCIsXCIjODEwZjdjXCJdLFxuNjogW1wiI2VkZjhmYlwiLFwiI2JmZDNlNlwiLFwiIzllYmNkYVwiLFwiIzhjOTZjNlwiLFwiIzg4NTZhN1wiLFwiIzgxMGY3Y1wiXSxcbjc6IFtcIiNlZGY4ZmJcIixcIiNiZmQzZTZcIixcIiM5ZWJjZGFcIixcIiM4Yzk2YzZcIixcIiM4YzZiYjFcIixcIiM4ODQxOWRcIixcIiM2ZTAxNmJcIl0sXG44OiBbXCIjZjdmY2ZkXCIsXCIjZTBlY2Y0XCIsXCIjYmZkM2U2XCIsXCIjOWViY2RhXCIsXCIjOGM5NmM2XCIsXCIjOGM2YmIxXCIsXCIjODg0MTlkXCIsXCIjNmUwMTZiXCJdLFxuOTogW1wiI2Y3ZmNmZFwiLFwiI2UwZWNmNFwiLFwiI2JmZDNlNlwiLFwiIzllYmNkYVwiLFwiIzhjOTZjNlwiLFwiIzhjNmJiMVwiLFwiIzg4NDE5ZFwiLFwiIzgxMGY3Y1wiLFwiIzRkMDA0YlwiXVxufSxSZFB1OiB7XG4zOiBbXCIjZmRlMGRkXCIsXCIjZmE5ZmI1XCIsXCIjYzUxYjhhXCJdLFxuNDogW1wiI2ZlZWJlMlwiLFwiI2ZiYjRiOVwiLFwiI2Y3NjhhMVwiLFwiI2FlMDE3ZVwiXSxcbjU6IFtcIiNmZWViZTJcIixcIiNmYmI0YjlcIixcIiNmNzY4YTFcIixcIiNjNTFiOGFcIixcIiM3YTAxNzdcIl0sXG42OiBbXCIjZmVlYmUyXCIsXCIjZmNjNWMwXCIsXCIjZmE5ZmI1XCIsXCIjZjc2OGExXCIsXCIjYzUxYjhhXCIsXCIjN2EwMTc3XCJdLFxuNzogW1wiI2ZlZWJlMlwiLFwiI2ZjYzVjMFwiLFwiI2ZhOWZiNVwiLFwiI2Y3NjhhMVwiLFwiI2RkMzQ5N1wiLFwiI2FlMDE3ZVwiLFwiIzdhMDE3N1wiXSxcbjg6IFtcIiNmZmY3ZjNcIixcIiNmZGUwZGRcIixcIiNmY2M1YzBcIixcIiNmYTlmYjVcIixcIiNmNzY4YTFcIixcIiNkZDM0OTdcIixcIiNhZTAxN2VcIixcIiM3YTAxNzdcIl0sXG45OiBbXCIjZmZmN2YzXCIsXCIjZmRlMGRkXCIsXCIjZmNjNWMwXCIsXCIjZmE5ZmI1XCIsXCIjZjc2OGExXCIsXCIjZGQzNDk3XCIsXCIjYWUwMTdlXCIsXCIjN2EwMTc3XCIsXCIjNDkwMDZhXCJdXG59LFB1UmQ6IHtcbjM6IFtcIiNlN2UxZWZcIixcIiNjOTk0YzdcIixcIiNkZDFjNzdcIl0sXG40OiBbXCIjZjFlZWY2XCIsXCIjZDdiNWQ4XCIsXCIjZGY2NWIwXCIsXCIjY2UxMjU2XCJdLFxuNTogW1wiI2YxZWVmNlwiLFwiI2Q3YjVkOFwiLFwiI2RmNjViMFwiLFwiI2RkMWM3N1wiLFwiIzk4MDA0M1wiXSxcbjY6IFtcIiNmMWVlZjZcIixcIiNkNGI5ZGFcIixcIiNjOTk0YzdcIixcIiNkZjY1YjBcIixcIiNkZDFjNzdcIixcIiM5ODAwNDNcIl0sXG43OiBbXCIjZjFlZWY2XCIsXCIjZDRiOWRhXCIsXCIjYzk5NGM3XCIsXCIjZGY2NWIwXCIsXCIjZTcyOThhXCIsXCIjY2UxMjU2XCIsXCIjOTEwMDNmXCJdLFxuODogW1wiI2Y3ZjRmOVwiLFwiI2U3ZTFlZlwiLFwiI2Q0YjlkYVwiLFwiI2M5OTRjN1wiLFwiI2RmNjViMFwiLFwiI2U3Mjk4YVwiLFwiI2NlMTI1NlwiLFwiIzkxMDAzZlwiXSxcbjk6IFtcIiNmN2Y0ZjlcIixcIiNlN2UxZWZcIixcIiNkNGI5ZGFcIixcIiNjOTk0YzdcIixcIiNkZjY1YjBcIixcIiNlNzI5OGFcIixcIiNjZTEyNTZcIixcIiM5ODAwNDNcIixcIiM2NzAwMWZcIl1cbn0sT3JSZDoge1xuMzogW1wiI2ZlZThjOFwiLFwiI2ZkYmI4NFwiLFwiI2UzNGEzM1wiXSxcbjQ6IFtcIiNmZWYwZDlcIixcIiNmZGNjOGFcIixcIiNmYzhkNTlcIixcIiNkNzMwMWZcIl0sXG41OiBbXCIjZmVmMGQ5XCIsXCIjZmRjYzhhXCIsXCIjZmM4ZDU5XCIsXCIjZTM0YTMzXCIsXCIjYjMwMDAwXCJdLFxuNjogW1wiI2ZlZjBkOVwiLFwiI2ZkZDQ5ZVwiLFwiI2ZkYmI4NFwiLFwiI2ZjOGQ1OVwiLFwiI2UzNGEzM1wiLFwiI2IzMDAwMFwiXSxcbjc6IFtcIiNmZWYwZDlcIixcIiNmZGQ0OWVcIixcIiNmZGJiODRcIixcIiNmYzhkNTlcIixcIiNlZjY1NDhcIixcIiNkNzMwMWZcIixcIiM5OTAwMDBcIl0sXG44OiBbXCIjZmZmN2VjXCIsXCIjZmVlOGM4XCIsXCIjZmRkNDllXCIsXCIjZmRiYjg0XCIsXCIjZmM4ZDU5XCIsXCIjZWY2NTQ4XCIsXCIjZDczMDFmXCIsXCIjOTkwMDAwXCJdLFxuOTogW1wiI2ZmZjdlY1wiLFwiI2ZlZThjOFwiLFwiI2ZkZDQ5ZVwiLFwiI2ZkYmI4NFwiLFwiI2ZjOGQ1OVwiLFwiI2VmNjU0OFwiLFwiI2Q3MzAxZlwiLFwiI2IzMDAwMFwiLFwiIzdmMDAwMFwiXVxufSxZbE9yUmQ6IHtcbjM6IFtcIiNmZmVkYTBcIixcIiNmZWIyNGNcIixcIiNmMDNiMjBcIl0sXG40OiBbXCIjZmZmZmIyXCIsXCIjZmVjYzVjXCIsXCIjZmQ4ZDNjXCIsXCIjZTMxYTFjXCJdLFxuNTogW1wiI2ZmZmZiMlwiLFwiI2ZlY2M1Y1wiLFwiI2ZkOGQzY1wiLFwiI2YwM2IyMFwiLFwiI2JkMDAyNlwiXSxcbjY6IFtcIiNmZmZmYjJcIixcIiNmZWQ5NzZcIixcIiNmZWIyNGNcIixcIiNmZDhkM2NcIixcIiNmMDNiMjBcIixcIiNiZDAwMjZcIl0sXG43OiBbXCIjZmZmZmIyXCIsXCIjZmVkOTc2XCIsXCIjZmViMjRjXCIsXCIjZmQ4ZDNjXCIsXCIjZmM0ZTJhXCIsXCIjZTMxYTFjXCIsXCIjYjEwMDI2XCJdLFxuODogW1wiI2ZmZmZjY1wiLFwiI2ZmZWRhMFwiLFwiI2ZlZDk3NlwiLFwiI2ZlYjI0Y1wiLFwiI2ZkOGQzY1wiLFwiI2ZjNGUyYVwiLFwiI2UzMWExY1wiLFwiI2IxMDAyNlwiXSxcbjk6IFtcIiNmZmZmY2NcIixcIiNmZmVkYTBcIixcIiNmZWQ5NzZcIixcIiNmZWIyNGNcIixcIiNmZDhkM2NcIixcIiNmYzRlMmFcIixcIiNlMzFhMWNcIixcIiNiZDAwMjZcIixcIiM4MDAwMjZcIl1cbn0sWWxPckJyOiB7XG4zOiBbXCIjZmZmN2JjXCIsXCIjZmVjNDRmXCIsXCIjZDk1ZjBlXCJdLFxuNDogW1wiI2ZmZmZkNFwiLFwiI2ZlZDk4ZVwiLFwiI2ZlOTkyOVwiLFwiI2NjNGMwMlwiXSxcbjU6IFtcIiNmZmZmZDRcIixcIiNmZWQ5OGVcIixcIiNmZTk5MjlcIixcIiNkOTVmMGVcIixcIiM5OTM0MDRcIl0sXG42OiBbXCIjZmZmZmQ0XCIsXCIjZmVlMzkxXCIsXCIjZmVjNDRmXCIsXCIjZmU5OTI5XCIsXCIjZDk1ZjBlXCIsXCIjOTkzNDA0XCJdLFxuNzogW1wiI2ZmZmZkNFwiLFwiI2ZlZTM5MVwiLFwiI2ZlYzQ0ZlwiLFwiI2ZlOTkyOVwiLFwiI2VjNzAxNFwiLFwiI2NjNGMwMlwiLFwiIzhjMmQwNFwiXSxcbjg6IFtcIiNmZmZmZTVcIixcIiNmZmY3YmNcIixcIiNmZWUzOTFcIixcIiNmZWM0NGZcIixcIiNmZTk5MjlcIixcIiNlYzcwMTRcIixcIiNjYzRjMDJcIixcIiM4YzJkMDRcIl0sXG45OiBbXCIjZmZmZmU1XCIsXCIjZmZmN2JjXCIsXCIjZmVlMzkxXCIsXCIjZmVjNDRmXCIsXCIjZmU5OTI5XCIsXCIjZWM3MDE0XCIsXCIjY2M0YzAyXCIsXCIjOTkzNDA0XCIsXCIjNjYyNTA2XCJdXG59LFB1cnBsZXM6IHtcbjM6IFtcIiNlZmVkZjVcIixcIiNiY2JkZGNcIixcIiM3NTZiYjFcIl0sXG40OiBbXCIjZjJmMGY3XCIsXCIjY2JjOWUyXCIsXCIjOWU5YWM4XCIsXCIjNmE1MWEzXCJdLFxuNTogW1wiI2YyZjBmN1wiLFwiI2NiYzllMlwiLFwiIzllOWFjOFwiLFwiIzc1NmJiMVwiLFwiIzU0Mjc4ZlwiXSxcbjY6IFtcIiNmMmYwZjdcIixcIiNkYWRhZWJcIixcIiNiY2JkZGNcIixcIiM5ZTlhYzhcIixcIiM3NTZiYjFcIixcIiM1NDI3OGZcIl0sXG43OiBbXCIjZjJmMGY3XCIsXCIjZGFkYWViXCIsXCIjYmNiZGRjXCIsXCIjOWU5YWM4XCIsXCIjODA3ZGJhXCIsXCIjNmE1MWEzXCIsXCIjNGExNDg2XCJdLFxuODogW1wiI2ZjZmJmZFwiLFwiI2VmZWRmNVwiLFwiI2RhZGFlYlwiLFwiI2JjYmRkY1wiLFwiIzllOWFjOFwiLFwiIzgwN2RiYVwiLFwiIzZhNTFhM1wiLFwiIzRhMTQ4NlwiXSxcbjk6IFtcIiNmY2ZiZmRcIixcIiNlZmVkZjVcIixcIiNkYWRhZWJcIixcIiNiY2JkZGNcIixcIiM5ZTlhYzhcIixcIiM4MDdkYmFcIixcIiM2YTUxYTNcIixcIiM1NDI3OGZcIixcIiMzZjAwN2RcIl1cbn0sQmx1ZXM6IHtcbjM6IFtcIiNkZWViZjdcIixcIiM5ZWNhZTFcIixcIiMzMTgyYmRcIl0sXG40OiBbXCIjZWZmM2ZmXCIsXCIjYmRkN2U3XCIsXCIjNmJhZWQ2XCIsXCIjMjE3MWI1XCJdLFxuNTogW1wiI2VmZjNmZlwiLFwiI2JkZDdlN1wiLFwiIzZiYWVkNlwiLFwiIzMxODJiZFwiLFwiIzA4NTE5Y1wiXSxcbjY6IFtcIiNlZmYzZmZcIixcIiNjNmRiZWZcIixcIiM5ZWNhZTFcIixcIiM2YmFlZDZcIixcIiMzMTgyYmRcIixcIiMwODUxOWNcIl0sXG43OiBbXCIjZWZmM2ZmXCIsXCIjYzZkYmVmXCIsXCIjOWVjYWUxXCIsXCIjNmJhZWQ2XCIsXCIjNDI5MmM2XCIsXCIjMjE3MWI1XCIsXCIjMDg0NTk0XCJdLFxuODogW1wiI2Y3ZmJmZlwiLFwiI2RlZWJmN1wiLFwiI2M2ZGJlZlwiLFwiIzllY2FlMVwiLFwiIzZiYWVkNlwiLFwiIzQyOTJjNlwiLFwiIzIxNzFiNVwiLFwiIzA4NDU5NFwiXSxcbjk6IFtcIiNmN2ZiZmZcIixcIiNkZWViZjdcIixcIiNjNmRiZWZcIixcIiM5ZWNhZTFcIixcIiM2YmFlZDZcIixcIiM0MjkyYzZcIixcIiMyMTcxYjVcIixcIiMwODUxOWNcIixcIiMwODMwNmJcIl1cbn0sR3JlZW5zOiB7XG4zOiBbXCIjZTVmNWUwXCIsXCIjYTFkOTliXCIsXCIjMzFhMzU0XCJdLFxuNDogW1wiI2VkZjhlOVwiLFwiI2JhZTRiM1wiLFwiIzc0YzQ3NlwiLFwiIzIzOGI0NVwiXSxcbjU6IFtcIiNlZGY4ZTlcIixcIiNiYWU0YjNcIixcIiM3NGM0NzZcIixcIiMzMWEzNTRcIixcIiMwMDZkMmNcIl0sXG42OiBbXCIjZWRmOGU5XCIsXCIjYzdlOWMwXCIsXCIjYTFkOTliXCIsXCIjNzRjNDc2XCIsXCIjMzFhMzU0XCIsXCIjMDA2ZDJjXCJdLFxuNzogW1wiI2VkZjhlOVwiLFwiI2M3ZTljMFwiLFwiI2ExZDk5YlwiLFwiIzc0YzQ3NlwiLFwiIzQxYWI1ZFwiLFwiIzIzOGI0NVwiLFwiIzAwNWEzMlwiXSxcbjg6IFtcIiNmN2ZjZjVcIixcIiNlNWY1ZTBcIixcIiNjN2U5YzBcIixcIiNhMWQ5OWJcIixcIiM3NGM0NzZcIixcIiM0MWFiNWRcIixcIiMyMzhiNDVcIixcIiMwMDVhMzJcIl0sXG45OiBbXCIjZjdmY2Y1XCIsXCIjZTVmNWUwXCIsXCIjYzdlOWMwXCIsXCIjYTFkOTliXCIsXCIjNzRjNDc2XCIsXCIjNDFhYjVkXCIsXCIjMjM4YjQ1XCIsXCIjMDA2ZDJjXCIsXCIjMDA0NDFiXCJdXG59LE9yYW5nZXM6IHtcbjM6IFtcIiNmZWU2Y2VcIixcIiNmZGFlNmJcIixcIiNlNjU1MGRcIl0sXG40OiBbXCIjZmVlZGRlXCIsXCIjZmRiZTg1XCIsXCIjZmQ4ZDNjXCIsXCIjZDk0NzAxXCJdLFxuNTogW1wiI2ZlZWRkZVwiLFwiI2ZkYmU4NVwiLFwiI2ZkOGQzY1wiLFwiI2U2NTUwZFwiLFwiI2E2MzYwM1wiXSxcbjY6IFtcIiNmZWVkZGVcIixcIiNmZGQwYTJcIixcIiNmZGFlNmJcIixcIiNmZDhkM2NcIixcIiNlNjU1MGRcIixcIiNhNjM2MDNcIl0sXG43OiBbXCIjZmVlZGRlXCIsXCIjZmRkMGEyXCIsXCIjZmRhZTZiXCIsXCIjZmQ4ZDNjXCIsXCIjZjE2OTEzXCIsXCIjZDk0ODAxXCIsXCIjOGMyZDA0XCJdLFxuODogW1wiI2ZmZjVlYlwiLFwiI2ZlZTZjZVwiLFwiI2ZkZDBhMlwiLFwiI2ZkYWU2YlwiLFwiI2ZkOGQzY1wiLFwiI2YxNjkxM1wiLFwiI2Q5NDgwMVwiLFwiIzhjMmQwNFwiXSxcbjk6IFtcIiNmZmY1ZWJcIixcIiNmZWU2Y2VcIixcIiNmZGQwYTJcIixcIiNmZGFlNmJcIixcIiNmZDhkM2NcIixcIiNmMTY5MTNcIixcIiNkOTQ4MDFcIixcIiNhNjM2MDNcIixcIiM3ZjI3MDRcIl1cbn0sUmVkczoge1xuMzogW1wiI2ZlZTBkMlwiLFwiI2ZjOTI3MlwiLFwiI2RlMmQyNlwiXSxcbjQ6IFtcIiNmZWU1ZDlcIixcIiNmY2FlOTFcIixcIiNmYjZhNGFcIixcIiNjYjE4MWRcIl0sXG41OiBbXCIjZmVlNWQ5XCIsXCIjZmNhZTkxXCIsXCIjZmI2YTRhXCIsXCIjZGUyZDI2XCIsXCIjYTUwZjE1XCJdLFxuNjogW1wiI2ZlZTVkOVwiLFwiI2ZjYmJhMVwiLFwiI2ZjOTI3MlwiLFwiI2ZiNmE0YVwiLFwiI2RlMmQyNlwiLFwiI2E1MGYxNVwiXSxcbjc6IFtcIiNmZWU1ZDlcIixcIiNmY2JiYTFcIixcIiNmYzkyNzJcIixcIiNmYjZhNGFcIixcIiNlZjNiMmNcIixcIiNjYjE4MWRcIixcIiM5OTAwMGRcIl0sXG44OiBbXCIjZmZmNWYwXCIsXCIjZmVlMGQyXCIsXCIjZmNiYmExXCIsXCIjZmM5MjcyXCIsXCIjZmI2YTRhXCIsXCIjZWYzYjJjXCIsXCIjY2IxODFkXCIsXCIjOTkwMDBkXCJdLFxuOTogW1wiI2ZmZjVmMFwiLFwiI2ZlZTBkMlwiLFwiI2ZjYmJhMVwiLFwiI2ZjOTI3MlwiLFwiI2ZiNmE0YVwiLFwiI2VmM2IyY1wiLFwiI2NiMTgxZFwiLFwiI2E1MGYxNVwiLFwiIzY3MDAwZFwiXVxufSxHcmV5czoge1xuMzogW1wiI2YwZjBmMFwiLFwiI2JkYmRiZFwiLFwiIzYzNjM2M1wiXSxcbjQ6IFtcIiNmN2Y3ZjdcIixcIiNjY2NjY2NcIixcIiM5Njk2OTZcIixcIiM1MjUyNTJcIl0sXG41OiBbXCIjZjdmN2Y3XCIsXCIjY2NjY2NjXCIsXCIjOTY5Njk2XCIsXCIjNjM2MzYzXCIsXCIjMjUyNTI1XCJdLFxuNjogW1wiI2Y3ZjdmN1wiLFwiI2Q5ZDlkOVwiLFwiI2JkYmRiZFwiLFwiIzk2OTY5NlwiLFwiIzYzNjM2M1wiLFwiIzI1MjUyNVwiXSxcbjc6IFtcIiNmN2Y3ZjdcIixcIiNkOWQ5ZDlcIixcIiNiZGJkYmRcIixcIiM5Njk2OTZcIixcIiM3MzczNzNcIixcIiM1MjUyNTJcIixcIiMyNTI1MjVcIl0sXG44OiBbXCIjZmZmZmZmXCIsXCIjZjBmMGYwXCIsXCIjZDlkOWQ5XCIsXCIjYmRiZGJkXCIsXCIjOTY5Njk2XCIsXCIjNzM3MzczXCIsXCIjNTI1MjUyXCIsXCIjMjUyNTI1XCJdLFxuOTogW1wiI2ZmZmZmZlwiLFwiI2YwZjBmMFwiLFwiI2Q5ZDlkOVwiLFwiI2JkYmRiZFwiLFwiIzk2OTY5NlwiLFwiIzczNzM3M1wiLFwiIzUyNTI1MlwiLFwiIzI1MjUyNVwiLFwiIzAwMDAwMFwiXVxufSxQdU9yOiB7XG4zOiBbXCIjZjFhMzQwXCIsXCIjZjdmN2Y3XCIsXCIjOTk4ZWMzXCJdLFxuNDogW1wiI2U2NjEwMVwiLFwiI2ZkYjg2M1wiLFwiI2IyYWJkMlwiLFwiIzVlM2M5OVwiXSxcbjU6IFtcIiNlNjYxMDFcIixcIiNmZGI4NjNcIixcIiNmN2Y3ZjdcIixcIiNiMmFiZDJcIixcIiM1ZTNjOTlcIl0sXG42OiBbXCIjYjM1ODA2XCIsXCIjZjFhMzQwXCIsXCIjZmVlMGI2XCIsXCIjZDhkYWViXCIsXCIjOTk4ZWMzXCIsXCIjNTQyNzg4XCJdLFxuNzogW1wiI2IzNTgwNlwiLFwiI2YxYTM0MFwiLFwiI2ZlZTBiNlwiLFwiI2Y3ZjdmN1wiLFwiI2Q4ZGFlYlwiLFwiIzk5OGVjM1wiLFwiIzU0Mjc4OFwiXSxcbjg6IFtcIiNiMzU4MDZcIixcIiNlMDgyMTRcIixcIiNmZGI4NjNcIixcIiNmZWUwYjZcIixcIiNkOGRhZWJcIixcIiNiMmFiZDJcIixcIiM4MDczYWNcIixcIiM1NDI3ODhcIl0sXG45OiBbXCIjYjM1ODA2XCIsXCIjZTA4MjE0XCIsXCIjZmRiODYzXCIsXCIjZmVlMGI2XCIsXCIjZjdmN2Y3XCIsXCIjZDhkYWViXCIsXCIjYjJhYmQyXCIsXCIjODA3M2FjXCIsXCIjNTQyNzg4XCJdLFxuMTA6IFtcIiM3ZjNiMDhcIixcIiNiMzU4MDZcIixcIiNlMDgyMTRcIixcIiNmZGI4NjNcIixcIiNmZWUwYjZcIixcIiNkOGRhZWJcIixcIiNiMmFiZDJcIixcIiM4MDczYWNcIixcIiM1NDI3ODhcIixcIiMyZDAwNGJcIl0sXG4xMTogW1wiIzdmM2IwOFwiLFwiI2IzNTgwNlwiLFwiI2UwODIxNFwiLFwiI2ZkYjg2M1wiLFwiI2ZlZTBiNlwiLFwiI2Y3ZjdmN1wiLFwiI2Q4ZGFlYlwiLFwiI2IyYWJkMlwiLFwiIzgwNzNhY1wiLFwiIzU0Mjc4OFwiLFwiIzJkMDA0YlwiXVxufSxCckJHOiB7XG4zOiBbXCIjZDhiMzY1XCIsXCIjZjVmNWY1XCIsXCIjNWFiNGFjXCJdLFxuNDogW1wiI2E2NjExYVwiLFwiI2RmYzI3ZFwiLFwiIzgwY2RjMVwiLFwiIzAxODU3MVwiXSxcbjU6IFtcIiNhNjYxMWFcIixcIiNkZmMyN2RcIixcIiNmNWY1ZjVcIixcIiM4MGNkYzFcIixcIiMwMTg1NzFcIl0sXG42OiBbXCIjOGM1MTBhXCIsXCIjZDhiMzY1XCIsXCIjZjZlOGMzXCIsXCIjYzdlYWU1XCIsXCIjNWFiNGFjXCIsXCIjMDE2NjVlXCJdLFxuNzogW1wiIzhjNTEwYVwiLFwiI2Q4YjM2NVwiLFwiI2Y2ZThjM1wiLFwiI2Y1ZjVmNVwiLFwiI2M3ZWFlNVwiLFwiIzVhYjRhY1wiLFwiIzAxNjY1ZVwiXSxcbjg6IFtcIiM4YzUxMGFcIixcIiNiZjgxMmRcIixcIiNkZmMyN2RcIixcIiNmNmU4YzNcIixcIiNjN2VhZTVcIixcIiM4MGNkYzFcIixcIiMzNTk3OGZcIixcIiMwMTY2NWVcIl0sXG45OiBbXCIjOGM1MTBhXCIsXCIjYmY4MTJkXCIsXCIjZGZjMjdkXCIsXCIjZjZlOGMzXCIsXCIjZjVmNWY1XCIsXCIjYzdlYWU1XCIsXCIjODBjZGMxXCIsXCIjMzU5NzhmXCIsXCIjMDE2NjVlXCJdLFxuMTA6IFtcIiM1NDMwMDVcIixcIiM4YzUxMGFcIixcIiNiZjgxMmRcIixcIiNkZmMyN2RcIixcIiNmNmU4YzNcIixcIiNjN2VhZTVcIixcIiM4MGNkYzFcIixcIiMzNTk3OGZcIixcIiMwMTY2NWVcIixcIiMwMDNjMzBcIl0sXG4xMTogW1wiIzU0MzAwNVwiLFwiIzhjNTEwYVwiLFwiI2JmODEyZFwiLFwiI2RmYzI3ZFwiLFwiI2Y2ZThjM1wiLFwiI2Y1ZjVmNVwiLFwiI2M3ZWFlNVwiLFwiIzgwY2RjMVwiLFwiIzM1OTc4ZlwiLFwiIzAxNjY1ZVwiLFwiIzAwM2MzMFwiXVxufSxQUkduOiB7XG4zOiBbXCIjYWY4ZGMzXCIsXCIjZjdmN2Y3XCIsXCIjN2ZiZjdiXCJdLFxuNDogW1wiIzdiMzI5NFwiLFwiI2MyYTVjZlwiLFwiI2E2ZGJhMFwiLFwiIzAwODgzN1wiXSxcbjU6IFtcIiM3YjMyOTRcIixcIiNjMmE1Y2ZcIixcIiNmN2Y3ZjdcIixcIiNhNmRiYTBcIixcIiMwMDg4MzdcIl0sXG42OiBbXCIjNzYyYTgzXCIsXCIjYWY4ZGMzXCIsXCIjZTdkNGU4XCIsXCIjZDlmMGQzXCIsXCIjN2ZiZjdiXCIsXCIjMWI3ODM3XCJdLFxuNzogW1wiIzc2MmE4M1wiLFwiI2FmOGRjM1wiLFwiI2U3ZDRlOFwiLFwiI2Y3ZjdmN1wiLFwiI2Q5ZjBkM1wiLFwiIzdmYmY3YlwiLFwiIzFiNzgzN1wiXSxcbjg6IFtcIiM3NjJhODNcIixcIiM5OTcwYWJcIixcIiNjMmE1Y2ZcIixcIiNlN2Q0ZThcIixcIiNkOWYwZDNcIixcIiNhNmRiYTBcIixcIiM1YWFlNjFcIixcIiMxYjc4MzdcIl0sXG45OiBbXCIjNzYyYTgzXCIsXCIjOTk3MGFiXCIsXCIjYzJhNWNmXCIsXCIjZTdkNGU4XCIsXCIjZjdmN2Y3XCIsXCIjZDlmMGQzXCIsXCIjYTZkYmEwXCIsXCIjNWFhZTYxXCIsXCIjMWI3ODM3XCJdLFxuMTA6IFtcIiM0MDAwNGJcIixcIiM3NjJhODNcIixcIiM5OTcwYWJcIixcIiNjMmE1Y2ZcIixcIiNlN2Q0ZThcIixcIiNkOWYwZDNcIixcIiNhNmRiYTBcIixcIiM1YWFlNjFcIixcIiMxYjc4MzdcIixcIiMwMDQ0MWJcIl0sXG4xMTogW1wiIzQwMDA0YlwiLFwiIzc2MmE4M1wiLFwiIzk5NzBhYlwiLFwiI2MyYTVjZlwiLFwiI2U3ZDRlOFwiLFwiI2Y3ZjdmN1wiLFwiI2Q5ZjBkM1wiLFwiI2E2ZGJhMFwiLFwiIzVhYWU2MVwiLFwiIzFiNzgzN1wiLFwiIzAwNDQxYlwiXVxufSxQaVlHOiB7XG4zOiBbXCIjZTlhM2M5XCIsXCIjZjdmN2Y3XCIsXCIjYTFkNzZhXCJdLFxuNDogW1wiI2QwMWM4YlwiLFwiI2YxYjZkYVwiLFwiI2I4ZTE4NlwiLFwiIzRkYWMyNlwiXSxcbjU6IFtcIiNkMDFjOGJcIixcIiNmMWI2ZGFcIixcIiNmN2Y3ZjdcIixcIiNiOGUxODZcIixcIiM0ZGFjMjZcIl0sXG42OiBbXCIjYzUxYjdkXCIsXCIjZTlhM2M5XCIsXCIjZmRlMGVmXCIsXCIjZTZmNWQwXCIsXCIjYTFkNzZhXCIsXCIjNGQ5MjIxXCJdLFxuNzogW1wiI2M1MWI3ZFwiLFwiI2U5YTNjOVwiLFwiI2ZkZTBlZlwiLFwiI2Y3ZjdmN1wiLFwiI2U2ZjVkMFwiLFwiI2ExZDc2YVwiLFwiIzRkOTIyMVwiXSxcbjg6IFtcIiNjNTFiN2RcIixcIiNkZTc3YWVcIixcIiNmMWI2ZGFcIixcIiNmZGUwZWZcIixcIiNlNmY1ZDBcIixcIiNiOGUxODZcIixcIiM3ZmJjNDFcIixcIiM0ZDkyMjFcIl0sXG45OiBbXCIjYzUxYjdkXCIsXCIjZGU3N2FlXCIsXCIjZjFiNmRhXCIsXCIjZmRlMGVmXCIsXCIjZjdmN2Y3XCIsXCIjZTZmNWQwXCIsXCIjYjhlMTg2XCIsXCIjN2ZiYzQxXCIsXCIjNGQ5MjIxXCJdLFxuMTA6IFtcIiM4ZTAxNTJcIixcIiNjNTFiN2RcIixcIiNkZTc3YWVcIixcIiNmMWI2ZGFcIixcIiNmZGUwZWZcIixcIiNlNmY1ZDBcIixcIiNiOGUxODZcIixcIiM3ZmJjNDFcIixcIiM0ZDkyMjFcIixcIiMyNzY0MTlcIl0sXG4xMTogW1wiIzhlMDE1MlwiLFwiI2M1MWI3ZFwiLFwiI2RlNzdhZVwiLFwiI2YxYjZkYVwiLFwiI2ZkZTBlZlwiLFwiI2Y3ZjdmN1wiLFwiI2U2ZjVkMFwiLFwiI2I4ZTE4NlwiLFwiIzdmYmM0MVwiLFwiIzRkOTIyMVwiLFwiIzI3NjQxOVwiXVxufSxSZEJ1OiB7XG4zOiBbXCIjZWY4YTYyXCIsXCIjZjdmN2Y3XCIsXCIjNjdhOWNmXCJdLFxuNDogW1wiI2NhMDAyMFwiLFwiI2Y0YTU4MlwiLFwiIzkyYzVkZVwiLFwiIzA1NzFiMFwiXSxcbjU6IFtcIiNjYTAwMjBcIixcIiNmNGE1ODJcIixcIiNmN2Y3ZjdcIixcIiM5MmM1ZGVcIixcIiMwNTcxYjBcIl0sXG42OiBbXCIjYjIxODJiXCIsXCIjZWY4YTYyXCIsXCIjZmRkYmM3XCIsXCIjZDFlNWYwXCIsXCIjNjdhOWNmXCIsXCIjMjE2NmFjXCJdLFxuNzogW1wiI2IyMTgyYlwiLFwiI2VmOGE2MlwiLFwiI2ZkZGJjN1wiLFwiI2Y3ZjdmN1wiLFwiI2QxZTVmMFwiLFwiIzY3YTljZlwiLFwiIzIxNjZhY1wiXSxcbjg6IFtcIiNiMjE4MmJcIixcIiNkNjYwNGRcIixcIiNmNGE1ODJcIixcIiNmZGRiYzdcIixcIiNkMWU1ZjBcIixcIiM5MmM1ZGVcIixcIiM0MzkzYzNcIixcIiMyMTY2YWNcIl0sXG45OiBbXCIjYjIxODJiXCIsXCIjZDY2MDRkXCIsXCIjZjRhNTgyXCIsXCIjZmRkYmM3XCIsXCIjZjdmN2Y3XCIsXCIjZDFlNWYwXCIsXCIjOTJjNWRlXCIsXCIjNDM5M2MzXCIsXCIjMjE2NmFjXCJdLFxuMTA6IFtcIiM2NzAwMWZcIixcIiNiMjE4MmJcIixcIiNkNjYwNGRcIixcIiNmNGE1ODJcIixcIiNmZGRiYzdcIixcIiNkMWU1ZjBcIixcIiM5MmM1ZGVcIixcIiM0MzkzYzNcIixcIiMyMTY2YWNcIixcIiMwNTMwNjFcIl0sXG4xMTogW1wiIzY3MDAxZlwiLFwiI2IyMTgyYlwiLFwiI2Q2NjA0ZFwiLFwiI2Y0YTU4MlwiLFwiI2ZkZGJjN1wiLFwiI2Y3ZjdmN1wiLFwiI2QxZTVmMFwiLFwiIzkyYzVkZVwiLFwiIzQzOTNjM1wiLFwiIzIxNjZhY1wiLFwiIzA1MzA2MVwiXVxufSxSZEd5OiB7XG4zOiBbXCIjZWY4YTYyXCIsXCIjZmZmZmZmXCIsXCIjOTk5OTk5XCJdLFxuNDogW1wiI2NhMDAyMFwiLFwiI2Y0YTU4MlwiLFwiI2JhYmFiYVwiLFwiIzQwNDA0MFwiXSxcbjU6IFtcIiNjYTAwMjBcIixcIiNmNGE1ODJcIixcIiNmZmZmZmZcIixcIiNiYWJhYmFcIixcIiM0MDQwNDBcIl0sXG42OiBbXCIjYjIxODJiXCIsXCIjZWY4YTYyXCIsXCIjZmRkYmM3XCIsXCIjZTBlMGUwXCIsXCIjOTk5OTk5XCIsXCIjNGQ0ZDRkXCJdLFxuNzogW1wiI2IyMTgyYlwiLFwiI2VmOGE2MlwiLFwiI2ZkZGJjN1wiLFwiI2ZmZmZmZlwiLFwiI2UwZTBlMFwiLFwiIzk5OTk5OVwiLFwiIzRkNGQ0ZFwiXSxcbjg6IFtcIiNiMjE4MmJcIixcIiNkNjYwNGRcIixcIiNmNGE1ODJcIixcIiNmZGRiYzdcIixcIiNlMGUwZTBcIixcIiNiYWJhYmFcIixcIiM4Nzg3ODdcIixcIiM0ZDRkNGRcIl0sXG45OiBbXCIjYjIxODJiXCIsXCIjZDY2MDRkXCIsXCIjZjRhNTgyXCIsXCIjZmRkYmM3XCIsXCIjZmZmZmZmXCIsXCIjZTBlMGUwXCIsXCIjYmFiYWJhXCIsXCIjODc4Nzg3XCIsXCIjNGQ0ZDRkXCJdLFxuMTA6IFtcIiM2NzAwMWZcIixcIiNiMjE4MmJcIixcIiNkNjYwNGRcIixcIiNmNGE1ODJcIixcIiNmZGRiYzdcIixcIiNlMGUwZTBcIixcIiNiYWJhYmFcIixcIiM4Nzg3ODdcIixcIiM0ZDRkNGRcIixcIiMxYTFhMWFcIl0sXG4xMTogW1wiIzY3MDAxZlwiLFwiI2IyMTgyYlwiLFwiI2Q2NjA0ZFwiLFwiI2Y0YTU4MlwiLFwiI2ZkZGJjN1wiLFwiI2ZmZmZmZlwiLFwiI2UwZTBlMFwiLFwiI2JhYmFiYVwiLFwiIzg3ODc4N1wiLFwiIzRkNGQ0ZFwiLFwiIzFhMWExYVwiXVxufSxSZFlsQnU6IHtcbjM6IFtcIiNmYzhkNTlcIixcIiNmZmZmYmZcIixcIiM5MWJmZGJcIl0sXG40OiBbXCIjZDcxOTFjXCIsXCIjZmRhZTYxXCIsXCIjYWJkOWU5XCIsXCIjMmM3YmI2XCJdLFxuNTogW1wiI2Q3MTkxY1wiLFwiI2ZkYWU2MVwiLFwiI2ZmZmZiZlwiLFwiI2FiZDllOVwiLFwiIzJjN2JiNlwiXSxcbjY6IFtcIiNkNzMwMjdcIixcIiNmYzhkNTlcIixcIiNmZWUwOTBcIixcIiNlMGYzZjhcIixcIiM5MWJmZGJcIixcIiM0NTc1YjRcIl0sXG43OiBbXCIjZDczMDI3XCIsXCIjZmM4ZDU5XCIsXCIjZmVlMDkwXCIsXCIjZmZmZmJmXCIsXCIjZTBmM2Y4XCIsXCIjOTFiZmRiXCIsXCIjNDU3NWI0XCJdLFxuODogW1wiI2Q3MzAyN1wiLFwiI2Y0NmQ0M1wiLFwiI2ZkYWU2MVwiLFwiI2ZlZTA5MFwiLFwiI2UwZjNmOFwiLFwiI2FiZDllOVwiLFwiIzc0YWRkMVwiLFwiIzQ1NzViNFwiXSxcbjk6IFtcIiNkNzMwMjdcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOTBcIixcIiNmZmZmYmZcIixcIiNlMGYzZjhcIixcIiNhYmQ5ZTlcIixcIiM3NGFkZDFcIixcIiM0NTc1YjRcIl0sXG4xMDogW1wiI2E1MDAyNlwiLFwiI2Q3MzAyN1wiLFwiI2Y0NmQ0M1wiLFwiI2ZkYWU2MVwiLFwiI2ZlZTA5MFwiLFwiI2UwZjNmOFwiLFwiI2FiZDllOVwiLFwiIzc0YWRkMVwiLFwiIzQ1NzViNFwiLFwiIzMxMzY5NVwiXSxcbjExOiBbXCIjYTUwMDI2XCIsXCIjZDczMDI3XCIsXCIjZjQ2ZDQzXCIsXCIjZmRhZTYxXCIsXCIjZmVlMDkwXCIsXCIjZmZmZmJmXCIsXCIjZTBmM2Y4XCIsXCIjYWJkOWU5XCIsXCIjNzRhZGQxXCIsXCIjNDU3NWI0XCIsXCIjMzEzNjk1XCJdXG59LFNwZWN0cmFsOiB7XG4zOiBbXCIjZmM4ZDU5XCIsXCIjZmZmZmJmXCIsXCIjOTlkNTk0XCJdLFxuNDogW1wiI2Q3MTkxY1wiLFwiI2ZkYWU2MVwiLFwiI2FiZGRhNFwiLFwiIzJiODNiYVwiXSxcbjU6IFtcIiNkNzE5MWNcIixcIiNmZGFlNjFcIixcIiNmZmZmYmZcIixcIiNhYmRkYTRcIixcIiMyYjgzYmFcIl0sXG42OiBbXCIjZDUzZTRmXCIsXCIjZmM4ZDU5XCIsXCIjZmVlMDhiXCIsXCIjZTZmNTk4XCIsXCIjOTlkNTk0XCIsXCIjMzI4OGJkXCJdLFxuNzogW1wiI2Q1M2U0ZlwiLFwiI2ZjOGQ1OVwiLFwiI2ZlZTA4YlwiLFwiI2ZmZmZiZlwiLFwiI2U2ZjU5OFwiLFwiIzk5ZDU5NFwiLFwiIzMyODhiZFwiXSxcbjg6IFtcIiNkNTNlNGZcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOGJcIixcIiNlNmY1OThcIixcIiNhYmRkYTRcIixcIiM2NmMyYTVcIixcIiMzMjg4YmRcIl0sXG45OiBbXCIjZDUzZTRmXCIsXCIjZjQ2ZDQzXCIsXCIjZmRhZTYxXCIsXCIjZmVlMDhiXCIsXCIjZmZmZmJmXCIsXCIjZTZmNTk4XCIsXCIjYWJkZGE0XCIsXCIjNjZjMmE1XCIsXCIjMzI4OGJkXCJdLFxuMTA6IFtcIiM5ZTAxNDJcIixcIiNkNTNlNGZcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOGJcIixcIiNlNmY1OThcIixcIiNhYmRkYTRcIixcIiM2NmMyYTVcIixcIiMzMjg4YmRcIixcIiM1ZTRmYTJcIl0sXG4xMTogW1wiIzllMDE0MlwiLFwiI2Q1M2U0ZlwiLFwiI2Y0NmQ0M1wiLFwiI2ZkYWU2MVwiLFwiI2ZlZTA4YlwiLFwiI2ZmZmZiZlwiLFwiI2U2ZjU5OFwiLFwiI2FiZGRhNFwiLFwiIzY2YzJhNVwiLFwiIzMyODhiZFwiLFwiIzVlNGZhMlwiXVxufSxSZFlsR246IHtcbjM6IFtcIiNmYzhkNTlcIixcIiNmZmZmYmZcIixcIiM5MWNmNjBcIl0sXG40OiBbXCIjZDcxOTFjXCIsXCIjZmRhZTYxXCIsXCIjYTZkOTZhXCIsXCIjMWE5NjQxXCJdLFxuNTogW1wiI2Q3MTkxY1wiLFwiI2ZkYWU2MVwiLFwiI2ZmZmZiZlwiLFwiI2E2ZDk2YVwiLFwiIzFhOTY0MVwiXSxcbjY6IFtcIiNkNzMwMjdcIixcIiNmYzhkNTlcIixcIiNmZWUwOGJcIixcIiNkOWVmOGJcIixcIiM5MWNmNjBcIixcIiMxYTk4NTBcIl0sXG43OiBbXCIjZDczMDI3XCIsXCIjZmM4ZDU5XCIsXCIjZmVlMDhiXCIsXCIjZmZmZmJmXCIsXCIjZDllZjhiXCIsXCIjOTFjZjYwXCIsXCIjMWE5ODUwXCJdLFxuODogW1wiI2Q3MzAyN1wiLFwiI2Y0NmQ0M1wiLFwiI2ZkYWU2MVwiLFwiI2ZlZTA4YlwiLFwiI2Q5ZWY4YlwiLFwiI2E2ZDk2YVwiLFwiIzY2YmQ2M1wiLFwiIzFhOTg1MFwiXSxcbjk6IFtcIiNkNzMwMjdcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOGJcIixcIiNmZmZmYmZcIixcIiNkOWVmOGJcIixcIiNhNmQ5NmFcIixcIiM2NmJkNjNcIixcIiMxYTk4NTBcIl0sXG4xMDogW1wiI2E1MDAyNlwiLFwiI2Q3MzAyN1wiLFwiI2Y0NmQ0M1wiLFwiI2ZkYWU2MVwiLFwiI2ZlZTA4YlwiLFwiI2Q5ZWY4YlwiLFwiI2E2ZDk2YVwiLFwiIzY2YmQ2M1wiLFwiIzFhOTg1MFwiLFwiIzAwNjgzN1wiXSxcbjExOiBbXCIjYTUwMDI2XCIsXCIjZDczMDI3XCIsXCIjZjQ2ZDQzXCIsXCIjZmRhZTYxXCIsXCIjZmVlMDhiXCIsXCIjZmZmZmJmXCIsXCIjZDllZjhiXCIsXCIjYTZkOTZhXCIsXCIjNjZiZDYzXCIsXCIjMWE5ODUwXCIsXCIjMDA2ODM3XCJdXG59LEFjY2VudDoge1xuMzogW1wiIzdmYzk3ZlwiLFwiI2JlYWVkNFwiLFwiI2ZkYzA4NlwiXSxcbjQ6IFtcIiM3ZmM5N2ZcIixcIiNiZWFlZDRcIixcIiNmZGMwODZcIixcIiNmZmZmOTlcIl0sXG41OiBbXCIjN2ZjOTdmXCIsXCIjYmVhZWQ0XCIsXCIjZmRjMDg2XCIsXCIjZmZmZjk5XCIsXCIjMzg2Y2IwXCJdLFxuNjogW1wiIzdmYzk3ZlwiLFwiI2JlYWVkNFwiLFwiI2ZkYzA4NlwiLFwiI2ZmZmY5OVwiLFwiIzM4NmNiMFwiLFwiI2YwMDI3ZlwiXSxcbjc6IFtcIiM3ZmM5N2ZcIixcIiNiZWFlZDRcIixcIiNmZGMwODZcIixcIiNmZmZmOTlcIixcIiMzODZjYjBcIixcIiNmMDAyN2ZcIixcIiNiZjViMTdcIl0sXG44OiBbXCIjN2ZjOTdmXCIsXCIjYmVhZWQ0XCIsXCIjZmRjMDg2XCIsXCIjZmZmZjk5XCIsXCIjMzg2Y2IwXCIsXCIjZjAwMjdmXCIsXCIjYmY1YjE3XCIsXCIjNjY2NjY2XCJdXG59LERhcmsyOiB7XG4zOiBbXCIjMWI5ZTc3XCIsXCIjZDk1ZjAyXCIsXCIjNzU3MGIzXCJdLFxuNDogW1wiIzFiOWU3N1wiLFwiI2Q5NWYwMlwiLFwiIzc1NzBiM1wiLFwiI2U3Mjk4YVwiXSxcbjU6IFtcIiMxYjllNzdcIixcIiNkOTVmMDJcIixcIiM3NTcwYjNcIixcIiNlNzI5OGFcIixcIiM2NmE2MWVcIl0sXG42OiBbXCIjMWI5ZTc3XCIsXCIjZDk1ZjAyXCIsXCIjNzU3MGIzXCIsXCIjZTcyOThhXCIsXCIjNjZhNjFlXCIsXCIjZTZhYjAyXCJdLFxuNzogW1wiIzFiOWU3N1wiLFwiI2Q5NWYwMlwiLFwiIzc1NzBiM1wiLFwiI2U3Mjk4YVwiLFwiIzY2YTYxZVwiLFwiI2U2YWIwMlwiLFwiI2E2NzYxZFwiXSxcbjg6IFtcIiMxYjllNzdcIixcIiNkOTVmMDJcIixcIiM3NTcwYjNcIixcIiNlNzI5OGFcIixcIiM2NmE2MWVcIixcIiNlNmFiMDJcIixcIiNhNjc2MWRcIixcIiM2NjY2NjZcIl1cbn0sUGFpcmVkOiB7XG4zOiBbXCIjYTZjZWUzXCIsXCIjMWY3OGI0XCIsXCIjYjJkZjhhXCJdLFxuNDogW1wiI2E2Y2VlM1wiLFwiIzFmNzhiNFwiLFwiI2IyZGY4YVwiLFwiIzMzYTAyY1wiXSxcbjU6IFtcIiNhNmNlZTNcIixcIiMxZjc4YjRcIixcIiNiMmRmOGFcIixcIiMzM2EwMmNcIixcIiNmYjlhOTlcIl0sXG42OiBbXCIjYTZjZWUzXCIsXCIjMWY3OGI0XCIsXCIjYjJkZjhhXCIsXCIjMzNhMDJjXCIsXCIjZmI5YTk5XCIsXCIjZTMxYTFjXCJdLFxuNzogW1wiI2E2Y2VlM1wiLFwiIzFmNzhiNFwiLFwiI2IyZGY4YVwiLFwiIzMzYTAyY1wiLFwiI2ZiOWE5OVwiLFwiI2UzMWExY1wiLFwiI2ZkYmY2ZlwiXSxcbjg6IFtcIiNhNmNlZTNcIixcIiMxZjc4YjRcIixcIiNiMmRmOGFcIixcIiMzM2EwMmNcIixcIiNmYjlhOTlcIixcIiNlMzFhMWNcIixcIiNmZGJmNmZcIixcIiNmZjdmMDBcIl0sXG45OiBbXCIjYTZjZWUzXCIsXCIjMWY3OGI0XCIsXCIjYjJkZjhhXCIsXCIjMzNhMDJjXCIsXCIjZmI5YTk5XCIsXCIjZTMxYTFjXCIsXCIjZmRiZjZmXCIsXCIjZmY3ZjAwXCIsXCIjY2FiMmQ2XCJdLFxuMTA6IFtcIiNhNmNlZTNcIixcIiMxZjc4YjRcIixcIiNiMmRmOGFcIixcIiMzM2EwMmNcIixcIiNmYjlhOTlcIixcIiNlMzFhMWNcIixcIiNmZGJmNmZcIixcIiNmZjdmMDBcIixcIiNjYWIyZDZcIixcIiM2YTNkOWFcIl0sXG4xMTogW1wiI2E2Y2VlM1wiLFwiIzFmNzhiNFwiLFwiI2IyZGY4YVwiLFwiIzMzYTAyY1wiLFwiI2ZiOWE5OVwiLFwiI2UzMWExY1wiLFwiI2ZkYmY2ZlwiLFwiI2ZmN2YwMFwiLFwiI2NhYjJkNlwiLFwiIzZhM2Q5YVwiLFwiI2ZmZmY5OVwiXSxcbjEyOiBbXCIjYTZjZWUzXCIsXCIjMWY3OGI0XCIsXCIjYjJkZjhhXCIsXCIjMzNhMDJjXCIsXCIjZmI5YTk5XCIsXCIjZTMxYTFjXCIsXCIjZmRiZjZmXCIsXCIjZmY3ZjAwXCIsXCIjY2FiMmQ2XCIsXCIjNmEzZDlhXCIsXCIjZmZmZjk5XCIsXCIjYjE1OTI4XCJdXG59LFBhc3RlbDE6IHtcbjM6IFtcIiNmYmI0YWVcIixcIiNiM2NkZTNcIixcIiNjY2ViYzVcIl0sXG40OiBbXCIjZmJiNGFlXCIsXCIjYjNjZGUzXCIsXCIjY2NlYmM1XCIsXCIjZGVjYmU0XCJdLFxuNTogW1wiI2ZiYjRhZVwiLFwiI2IzY2RlM1wiLFwiI2NjZWJjNVwiLFwiI2RlY2JlNFwiLFwiI2ZlZDlhNlwiXSxcbjY6IFtcIiNmYmI0YWVcIixcIiNiM2NkZTNcIixcIiNjY2ViYzVcIixcIiNkZWNiZTRcIixcIiNmZWQ5YTZcIixcIiNmZmZmY2NcIl0sXG43OiBbXCIjZmJiNGFlXCIsXCIjYjNjZGUzXCIsXCIjY2NlYmM1XCIsXCIjZGVjYmU0XCIsXCIjZmVkOWE2XCIsXCIjZmZmZmNjXCIsXCIjZTVkOGJkXCJdLFxuODogW1wiI2ZiYjRhZVwiLFwiI2IzY2RlM1wiLFwiI2NjZWJjNVwiLFwiI2RlY2JlNFwiLFwiI2ZlZDlhNlwiLFwiI2ZmZmZjY1wiLFwiI2U1ZDhiZFwiLFwiI2ZkZGFlY1wiXSxcbjk6IFtcIiNmYmI0YWVcIixcIiNiM2NkZTNcIixcIiNjY2ViYzVcIixcIiNkZWNiZTRcIixcIiNmZWQ5YTZcIixcIiNmZmZmY2NcIixcIiNlNWQ4YmRcIixcIiNmZGRhZWNcIixcIiNmMmYyZjJcIl1cbn0sUGFzdGVsMjoge1xuMzogW1wiI2IzZTJjZFwiLFwiI2ZkY2RhY1wiLFwiI2NiZDVlOFwiXSxcbjQ6IFtcIiNiM2UyY2RcIixcIiNmZGNkYWNcIixcIiNjYmQ1ZThcIixcIiNmNGNhZTRcIl0sXG41OiBbXCIjYjNlMmNkXCIsXCIjZmRjZGFjXCIsXCIjY2JkNWU4XCIsXCIjZjRjYWU0XCIsXCIjZTZmNWM5XCJdLFxuNjogW1wiI2IzZTJjZFwiLFwiI2ZkY2RhY1wiLFwiI2NiZDVlOFwiLFwiI2Y0Y2FlNFwiLFwiI2U2ZjVjOVwiLFwiI2ZmZjJhZVwiXSxcbjc6IFtcIiNiM2UyY2RcIixcIiNmZGNkYWNcIixcIiNjYmQ1ZThcIixcIiNmNGNhZTRcIixcIiNlNmY1YzlcIixcIiNmZmYyYWVcIixcIiNmMWUyY2NcIl0sXG44OiBbXCIjYjNlMmNkXCIsXCIjZmRjZGFjXCIsXCIjY2JkNWU4XCIsXCIjZjRjYWU0XCIsXCIjZTZmNWM5XCIsXCIjZmZmMmFlXCIsXCIjZjFlMmNjXCIsXCIjY2NjY2NjXCJdXG59LFNldDE6IHtcbjM6IFtcIiNlNDFhMWNcIixcIiMzNzdlYjhcIixcIiM0ZGFmNGFcIl0sXG40OiBbXCIjZTQxYTFjXCIsXCIjMzc3ZWI4XCIsXCIjNGRhZjRhXCIsXCIjOTg0ZWEzXCJdLFxuNTogW1wiI2U0MWExY1wiLFwiIzM3N2ViOFwiLFwiIzRkYWY0YVwiLFwiIzk4NGVhM1wiLFwiI2ZmN2YwMFwiXSxcbjY6IFtcIiNlNDFhMWNcIixcIiMzNzdlYjhcIixcIiM0ZGFmNGFcIixcIiM5ODRlYTNcIixcIiNmZjdmMDBcIixcIiNmZmZmMzNcIl0sXG43OiBbXCIjZTQxYTFjXCIsXCIjMzc3ZWI4XCIsXCIjNGRhZjRhXCIsXCIjOTg0ZWEzXCIsXCIjZmY3ZjAwXCIsXCIjZmZmZjMzXCIsXCIjYTY1NjI4XCJdLFxuODogW1wiI2U0MWExY1wiLFwiIzM3N2ViOFwiLFwiIzRkYWY0YVwiLFwiIzk4NGVhM1wiLFwiI2ZmN2YwMFwiLFwiI2ZmZmYzM1wiLFwiI2E2NTYyOFwiLFwiI2Y3ODFiZlwiXSxcbjk6IFtcIiNlNDFhMWNcIixcIiMzNzdlYjhcIixcIiM0ZGFmNGFcIixcIiM5ODRlYTNcIixcIiNmZjdmMDBcIixcIiNmZmZmMzNcIixcIiNhNjU2MjhcIixcIiNmNzgxYmZcIixcIiM5OTk5OTlcIl1cbn0sU2V0Mjoge1xuMzogW1wiIzY2YzJhNVwiLFwiI2ZjOGQ2MlwiLFwiIzhkYTBjYlwiXSxcbjQ6IFtcIiM2NmMyYTVcIixcIiNmYzhkNjJcIixcIiM4ZGEwY2JcIixcIiNlNzhhYzNcIl0sXG41OiBbXCIjNjZjMmE1XCIsXCIjZmM4ZDYyXCIsXCIjOGRhMGNiXCIsXCIjZTc4YWMzXCIsXCIjYTZkODU0XCJdLFxuNjogW1wiIzY2YzJhNVwiLFwiI2ZjOGQ2MlwiLFwiIzhkYTBjYlwiLFwiI2U3OGFjM1wiLFwiI2E2ZDg1NFwiLFwiI2ZmZDkyZlwiXSxcbjc6IFtcIiM2NmMyYTVcIixcIiNmYzhkNjJcIixcIiM4ZGEwY2JcIixcIiNlNzhhYzNcIixcIiNhNmQ4NTRcIixcIiNmZmQ5MmZcIixcIiNlNWM0OTRcIl0sXG44OiBbXCIjNjZjMmE1XCIsXCIjZmM4ZDYyXCIsXCIjOGRhMGNiXCIsXCIjZTc4YWMzXCIsXCIjYTZkODU0XCIsXCIjZmZkOTJmXCIsXCIjZTVjNDk0XCIsXCIjYjNiM2IzXCJdXG59LFNldDM6IHtcbjM6IFtcIiM4ZGQzYzdcIixcIiNmZmZmYjNcIixcIiNiZWJhZGFcIl0sXG40OiBbXCIjOGRkM2M3XCIsXCIjZmZmZmIzXCIsXCIjYmViYWRhXCIsXCIjZmI4MDcyXCJdLFxuNTogW1wiIzhkZDNjN1wiLFwiI2ZmZmZiM1wiLFwiI2JlYmFkYVwiLFwiI2ZiODA3MlwiLFwiIzgwYjFkM1wiXSxcbjY6IFtcIiM4ZGQzYzdcIixcIiNmZmZmYjNcIixcIiNiZWJhZGFcIixcIiNmYjgwNzJcIixcIiM4MGIxZDNcIixcIiNmZGI0NjJcIl0sXG43OiBbXCIjOGRkM2M3XCIsXCIjZmZmZmIzXCIsXCIjYmViYWRhXCIsXCIjZmI4MDcyXCIsXCIjODBiMWQzXCIsXCIjZmRiNDYyXCIsXCIjYjNkZTY5XCJdLFxuODogW1wiIzhkZDNjN1wiLFwiI2ZmZmZiM1wiLFwiI2JlYmFkYVwiLFwiI2ZiODA3MlwiLFwiIzgwYjFkM1wiLFwiI2ZkYjQ2MlwiLFwiI2IzZGU2OVwiLFwiI2ZjY2RlNVwiXSxcbjk6IFtcIiM4ZGQzYzdcIixcIiNmZmZmYjNcIixcIiNiZWJhZGFcIixcIiNmYjgwNzJcIixcIiM4MGIxZDNcIixcIiNmZGI0NjJcIixcIiNiM2RlNjlcIixcIiNmY2NkZTVcIixcIiNkOWQ5ZDlcIl0sXG4xMDogW1wiIzhkZDNjN1wiLFwiI2ZmZmZiM1wiLFwiI2JlYmFkYVwiLFwiI2ZiODA3MlwiLFwiIzgwYjFkM1wiLFwiI2ZkYjQ2MlwiLFwiI2IzZGU2OVwiLFwiI2ZjY2RlNVwiLFwiI2Q5ZDlkOVwiLFwiI2JjODBiZFwiXSxcbjExOiBbXCIjOGRkM2M3XCIsXCIjZmZmZmIzXCIsXCIjYmViYWRhXCIsXCIjZmI4MDcyXCIsXCIjODBiMWQzXCIsXCIjZmRiNDYyXCIsXCIjYjNkZTY5XCIsXCIjZmNjZGU1XCIsXCIjZDlkOWQ5XCIsXCIjYmM4MGJkXCIsXCIjY2NlYmM1XCJdLFxuMTI6IFtcIiM4ZGQzYzdcIixcIiNmZmZmYjNcIixcIiNiZWJhZGFcIixcIiNmYjgwNzJcIixcIiM4MGIxZDNcIixcIiNmZGI0NjJcIixcIiNiM2RlNjlcIixcIiNmY2NkZTVcIixcIiNkOWQ5ZDlcIixcIiNiYzgwYmRcIixcIiNjY2ViYzVcIixcIiNmZmVkNmZcIl1cbn19O1xuXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoY29sb3JicmV3ZXIpO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjb2xvcmJyZXdlcjtcbn0gZWxzZSB7XG4gICAgdGhpcy5jb2xvcmJyZXdlciA9IGNvbG9yYnJld2VyO1xufVxuXG59KCk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29sb3JicmV3ZXIuanMnKTtcbiIsImlmICh0eXBlb2YgTWFwID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIE1hcCA9IGZ1bmN0aW9uKCkgeyB0aGlzLmNsZWFyKCk7IH07XG4gIE1hcC5wcm90b3R5cGUgPSB7XG4gICAgc2V0OiBmdW5jdGlvbihrLCB2KSB7IHRoaXMuX1trXSA9IHY7IHJldHVybiB0aGlzOyB9LFxuICAgIGdldDogZnVuY3Rpb24oaykgeyByZXR1cm4gdGhpcy5fW2tdOyB9LFxuICAgIGhhczogZnVuY3Rpb24oaykgeyByZXR1cm4gayBpbiB0aGlzLl87IH0sXG4gICAgZGVsZXRlOiBmdW5jdGlvbihrKSB7IHJldHVybiBrIGluIHRoaXMuXyAmJiBkZWxldGUgdGhpcy5fW2tdOyB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbigpIHsgdGhpcy5fID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfSxcbiAgICBnZXQgc2l6ZSgpIHsgdmFyIG4gPSAwOyBmb3IgKHZhciBrIGluIHRoaXMuXykgKytuOyByZXR1cm4gbjsgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbihjKSB7IGZvciAodmFyIGsgaW4gdGhpcy5fKSBjKHRoaXMuX1trXSwgaywgdGhpcyk7IH1cbiAgfTtcbn0gZWxzZSAoZnVuY3Rpb24oKSB7XG4gIHZhciBtID0gbmV3IE1hcDtcbiAgaWYgKG0uc2V0KDAsIDApICE9PSBtKSB7XG4gICAgbSA9IG0uc2V0O1xuICAgIE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oKSB7IG0uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgcmV0dXJuIHRoaXM7IH07XG4gIH1cbn0pKCk7XG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgZmFjdG9yeSgoZ2xvYmFsLmNvbG9yID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIGRlbHRhSHVlKGgxLCBoMCkge1xuICAgIHZhciBkZWx0YSA9IGgxIC0gaDA7XG4gICAgcmV0dXJuIGRlbHRhID4gMTgwIHx8IGRlbHRhIDwgLTE4MFxuICAgICAgICA/IGRlbHRhIC0gMzYwICogTWF0aC5yb3VuZChkZWx0YSAvIDM2MClcbiAgICAgICAgOiBkZWx0YTtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbG9yKCkge31cblxuICB2YXIgcmVIZXgzID0gL14jKFswLTlhLWZdezN9KSQvO1xuICB2YXIgcmVIZXg2ID0gL14jKFswLTlhLWZdezZ9KSQvO1xuICB2YXIgcmVSZ2JJbnRlZ2VyID0gL15yZ2JcXChcXHMqKFstK10/XFxkKylcXHMqLFxccyooWy0rXT9cXGQrKVxccyosXFxzKihbLStdP1xcZCspXFxzKlxcKSQvO1xuICB2YXIgcmVSZ2JQZXJjZW50ID0gL15yZ2JcXChcXHMqKFstK10/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKFstK10/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKFstK10/XFxkKyg/OlxcLlxcZCspPyklXFxzKlxcKSQvO1xuICB2YXIgcmVIc2xQZXJjZW50ID0gL15oc2xcXChcXHMqKFstK10/XFxkKyg/OlxcLlxcZCspPylcXHMqLFxccyooWy0rXT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqLFxccyooWy0rXT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqXFwpJC87XG5cbiAgY29sb3IucHJvdG90eXBlID0gQ29sb3IucHJvdG90eXBlID0ge1xuICAgIGRpc3BsYXlhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJnYigpLmRpc3BsYXlhYmxlKCk7XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZ2IoKSArIFwiXCI7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNvbG9yKGZvcm1hdCkge1xuICAgIHZhciBtO1xuICAgIGZvcm1hdCA9IChmb3JtYXQgKyBcIlwiKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gKG0gPSByZUhleDMuZXhlYyhmb3JtYXQpKSA/IChtID0gcGFyc2VJbnQobVsxXSwgMTYpLCByZ2IoKG0gPj4gOCAmIDB4ZikgfCAobSA+PiA0ICYgMHgwZjApLCAobSA+PiA0ICYgMHhmKSB8IChtICYgMHhmMCksICgobSAmIDB4ZikgPDwgNCkgfCAobSAmIDB4ZikpKSAvLyAjZjAwXG4gICAgICAgIDogKG0gPSByZUhleDYuZXhlYyhmb3JtYXQpKSA/IHJnYm4ocGFyc2VJbnQobVsxXSwgMTYpKSAvLyAjZmYwMDAwXG4gICAgICAgIDogKG0gPSByZVJnYkludGVnZXIuZXhlYyhmb3JtYXQpKSA/IHJnYihtWzFdLCBtWzJdLCBtWzNdKSAvLyByZ2IoMjU1LDAsMClcbiAgICAgICAgOiAobSA9IHJlUmdiUGVyY2VudC5leGVjKGZvcm1hdCkpID8gcmdiKG1bMV0gKiAyLjU1LCBtWzJdICogMi41NSwgbVszXSAqIDIuNTUpIC8vIHJnYigxMDAlLDAlLDAlKVxuICAgICAgICA6IChtID0gcmVIc2xQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBoc2wobVsxXSwgbVsyXSAqIC4wMSwgbVszXSAqIC4wMSkgLy8gaHNsKDEyMCw1MCUsNTAlKVxuICAgICAgICA6IG5hbWVkLmhhcyhmb3JtYXQpID8gcmdibihuYW1lZC5nZXQoZm9ybWF0KSlcbiAgICAgICAgOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcmdibihuKSB7XG4gICAgcmV0dXJuIHJnYihuID4+IDE2ICYgMHhmZiwgbiA+PiA4ICYgMHhmZiwgbiAmIDB4ZmYpO1xuICB9XG5cbiAgdmFyIG5hbWVkID0gKG5ldyBNYXApXG4gICAgICAuc2V0KFwiYWxpY2VibHVlXCIsIDB4ZjBmOGZmKVxuICAgICAgLnNldChcImFudGlxdWV3aGl0ZVwiLCAweGZhZWJkNylcbiAgICAgIC5zZXQoXCJhcXVhXCIsIDB4MDBmZmZmKVxuICAgICAgLnNldChcImFxdWFtYXJpbmVcIiwgMHg3ZmZmZDQpXG4gICAgICAuc2V0KFwiYXp1cmVcIiwgMHhmMGZmZmYpXG4gICAgICAuc2V0KFwiYmVpZ2VcIiwgMHhmNWY1ZGMpXG4gICAgICAuc2V0KFwiYmlzcXVlXCIsIDB4ZmZlNGM0KVxuICAgICAgLnNldChcImJsYWNrXCIsIDB4MDAwMDAwKVxuICAgICAgLnNldChcImJsYW5jaGVkYWxtb25kXCIsIDB4ZmZlYmNkKVxuICAgICAgLnNldChcImJsdWVcIiwgMHgwMDAwZmYpXG4gICAgICAuc2V0KFwiYmx1ZXZpb2xldFwiLCAweDhhMmJlMilcbiAgICAgIC5zZXQoXCJicm93blwiLCAweGE1MmEyYSlcbiAgICAgIC5zZXQoXCJidXJseXdvb2RcIiwgMHhkZWI4ODcpXG4gICAgICAuc2V0KFwiY2FkZXRibHVlXCIsIDB4NWY5ZWEwKVxuICAgICAgLnNldChcImNoYXJ0cmV1c2VcIiwgMHg3ZmZmMDApXG4gICAgICAuc2V0KFwiY2hvY29sYXRlXCIsIDB4ZDI2OTFlKVxuICAgICAgLnNldChcImNvcmFsXCIsIDB4ZmY3ZjUwKVxuICAgICAgLnNldChcImNvcm5mbG93ZXJibHVlXCIsIDB4NjQ5NWVkKVxuICAgICAgLnNldChcImNvcm5zaWxrXCIsIDB4ZmZmOGRjKVxuICAgICAgLnNldChcImNyaW1zb25cIiwgMHhkYzE0M2MpXG4gICAgICAuc2V0KFwiY3lhblwiLCAweDAwZmZmZilcbiAgICAgIC5zZXQoXCJkYXJrYmx1ZVwiLCAweDAwMDA4YilcbiAgICAgIC5zZXQoXCJkYXJrY3lhblwiLCAweDAwOGI4YilcbiAgICAgIC5zZXQoXCJkYXJrZ29sZGVucm9kXCIsIDB4Yjg4NjBiKVxuICAgICAgLnNldChcImRhcmtncmF5XCIsIDB4YTlhOWE5KVxuICAgICAgLnNldChcImRhcmtncmVlblwiLCAweDAwNjQwMClcbiAgICAgIC5zZXQoXCJkYXJrZ3JleVwiLCAweGE5YTlhOSlcbiAgICAgIC5zZXQoXCJkYXJra2hha2lcIiwgMHhiZGI3NmIpXG4gICAgICAuc2V0KFwiZGFya21hZ2VudGFcIiwgMHg4YjAwOGIpXG4gICAgICAuc2V0KFwiZGFya29saXZlZ3JlZW5cIiwgMHg1NTZiMmYpXG4gICAgICAuc2V0KFwiZGFya29yYW5nZVwiLCAweGZmOGMwMClcbiAgICAgIC5zZXQoXCJkYXJrb3JjaGlkXCIsIDB4OTkzMmNjKVxuICAgICAgLnNldChcImRhcmtyZWRcIiwgMHg4YjAwMDApXG4gICAgICAuc2V0KFwiZGFya3NhbG1vblwiLCAweGU5OTY3YSlcbiAgICAgIC5zZXQoXCJkYXJrc2VhZ3JlZW5cIiwgMHg4ZmJjOGYpXG4gICAgICAuc2V0KFwiZGFya3NsYXRlYmx1ZVwiLCAweDQ4M2Q4YilcbiAgICAgIC5zZXQoXCJkYXJrc2xhdGVncmF5XCIsIDB4MmY0ZjRmKVxuICAgICAgLnNldChcImRhcmtzbGF0ZWdyZXlcIiwgMHgyZjRmNGYpXG4gICAgICAuc2V0KFwiZGFya3R1cnF1b2lzZVwiLCAweDAwY2VkMSlcbiAgICAgIC5zZXQoXCJkYXJrdmlvbGV0XCIsIDB4OTQwMGQzKVxuICAgICAgLnNldChcImRlZXBwaW5rXCIsIDB4ZmYxNDkzKVxuICAgICAgLnNldChcImRlZXBza3libHVlXCIsIDB4MDBiZmZmKVxuICAgICAgLnNldChcImRpbWdyYXlcIiwgMHg2OTY5NjkpXG4gICAgICAuc2V0KFwiZGltZ3JleVwiLCAweDY5Njk2OSlcbiAgICAgIC5zZXQoXCJkb2RnZXJibHVlXCIsIDB4MWU5MGZmKVxuICAgICAgLnNldChcImZpcmVicmlja1wiLCAweGIyMjIyMilcbiAgICAgIC5zZXQoXCJmbG9yYWx3aGl0ZVwiLCAweGZmZmFmMClcbiAgICAgIC5zZXQoXCJmb3Jlc3RncmVlblwiLCAweDIyOGIyMilcbiAgICAgIC5zZXQoXCJmdWNoc2lhXCIsIDB4ZmYwMGZmKVxuICAgICAgLnNldChcImdhaW5zYm9yb1wiLCAweGRjZGNkYylcbiAgICAgIC5zZXQoXCJnaG9zdHdoaXRlXCIsIDB4ZjhmOGZmKVxuICAgICAgLnNldChcImdvbGRcIiwgMHhmZmQ3MDApXG4gICAgICAuc2V0KFwiZ29sZGVucm9kXCIsIDB4ZGFhNTIwKVxuICAgICAgLnNldChcImdyYXlcIiwgMHg4MDgwODApXG4gICAgICAuc2V0KFwiZ3JlZW5cIiwgMHgwMDgwMDApXG4gICAgICAuc2V0KFwiZ3JlZW55ZWxsb3dcIiwgMHhhZGZmMmYpXG4gICAgICAuc2V0KFwiZ3JleVwiLCAweDgwODA4MClcbiAgICAgIC5zZXQoXCJob25leWRld1wiLCAweGYwZmZmMClcbiAgICAgIC5zZXQoXCJob3RwaW5rXCIsIDB4ZmY2OWI0KVxuICAgICAgLnNldChcImluZGlhbnJlZFwiLCAweGNkNWM1YylcbiAgICAgIC5zZXQoXCJpbmRpZ29cIiwgMHg0YjAwODIpXG4gICAgICAuc2V0KFwiaXZvcnlcIiwgMHhmZmZmZjApXG4gICAgICAuc2V0KFwia2hha2lcIiwgMHhmMGU2OGMpXG4gICAgICAuc2V0KFwibGF2ZW5kZXJcIiwgMHhlNmU2ZmEpXG4gICAgICAuc2V0KFwibGF2ZW5kZXJibHVzaFwiLCAweGZmZjBmNSlcbiAgICAgIC5zZXQoXCJsYXduZ3JlZW5cIiwgMHg3Y2ZjMDApXG4gICAgICAuc2V0KFwibGVtb25jaGlmZm9uXCIsIDB4ZmZmYWNkKVxuICAgICAgLnNldChcImxpZ2h0Ymx1ZVwiLCAweGFkZDhlNilcbiAgICAgIC5zZXQoXCJsaWdodGNvcmFsXCIsIDB4ZjA4MDgwKVxuICAgICAgLnNldChcImxpZ2h0Y3lhblwiLCAweGUwZmZmZilcbiAgICAgIC5zZXQoXCJsaWdodGdvbGRlbnJvZHllbGxvd1wiLCAweGZhZmFkMilcbiAgICAgIC5zZXQoXCJsaWdodGdyYXlcIiwgMHhkM2QzZDMpXG4gICAgICAuc2V0KFwibGlnaHRncmVlblwiLCAweDkwZWU5MClcbiAgICAgIC5zZXQoXCJsaWdodGdyZXlcIiwgMHhkM2QzZDMpXG4gICAgICAuc2V0KFwibGlnaHRwaW5rXCIsIDB4ZmZiNmMxKVxuICAgICAgLnNldChcImxpZ2h0c2FsbW9uXCIsIDB4ZmZhMDdhKVxuICAgICAgLnNldChcImxpZ2h0c2VhZ3JlZW5cIiwgMHgyMGIyYWEpXG4gICAgICAuc2V0KFwibGlnaHRza3libHVlXCIsIDB4ODdjZWZhKVxuICAgICAgLnNldChcImxpZ2h0c2xhdGVncmF5XCIsIDB4Nzc4ODk5KVxuICAgICAgLnNldChcImxpZ2h0c2xhdGVncmV5XCIsIDB4Nzc4ODk5KVxuICAgICAgLnNldChcImxpZ2h0c3RlZWxibHVlXCIsIDB4YjBjNGRlKVxuICAgICAgLnNldChcImxpZ2h0eWVsbG93XCIsIDB4ZmZmZmUwKVxuICAgICAgLnNldChcImxpbWVcIiwgMHgwMGZmMDApXG4gICAgICAuc2V0KFwibGltZWdyZWVuXCIsIDB4MzJjZDMyKVxuICAgICAgLnNldChcImxpbmVuXCIsIDB4ZmFmMGU2KVxuICAgICAgLnNldChcIm1hZ2VudGFcIiwgMHhmZjAwZmYpXG4gICAgICAuc2V0KFwibWFyb29uXCIsIDB4ODAwMDAwKVxuICAgICAgLnNldChcIm1lZGl1bWFxdWFtYXJpbmVcIiwgMHg2NmNkYWEpXG4gICAgICAuc2V0KFwibWVkaXVtYmx1ZVwiLCAweDAwMDBjZClcbiAgICAgIC5zZXQoXCJtZWRpdW1vcmNoaWRcIiwgMHhiYTU1ZDMpXG4gICAgICAuc2V0KFwibWVkaXVtcHVycGxlXCIsIDB4OTM3MGRiKVxuICAgICAgLnNldChcIm1lZGl1bXNlYWdyZWVuXCIsIDB4M2NiMzcxKVxuICAgICAgLnNldChcIm1lZGl1bXNsYXRlYmx1ZVwiLCAweDdiNjhlZSlcbiAgICAgIC5zZXQoXCJtZWRpdW1zcHJpbmdncmVlblwiLCAweDAwZmE5YSlcbiAgICAgIC5zZXQoXCJtZWRpdW10dXJxdW9pc2VcIiwgMHg0OGQxY2MpXG4gICAgICAuc2V0KFwibWVkaXVtdmlvbGV0cmVkXCIsIDB4YzcxNTg1KVxuICAgICAgLnNldChcIm1pZG5pZ2h0Ymx1ZVwiLCAweDE5MTk3MClcbiAgICAgIC5zZXQoXCJtaW50Y3JlYW1cIiwgMHhmNWZmZmEpXG4gICAgICAuc2V0KFwibWlzdHlyb3NlXCIsIDB4ZmZlNGUxKVxuICAgICAgLnNldChcIm1vY2Nhc2luXCIsIDB4ZmZlNGI1KVxuICAgICAgLnNldChcIm5hdmFqb3doaXRlXCIsIDB4ZmZkZWFkKVxuICAgICAgLnNldChcIm5hdnlcIiwgMHgwMDAwODApXG4gICAgICAuc2V0KFwib2xkbGFjZVwiLCAweGZkZjVlNilcbiAgICAgIC5zZXQoXCJvbGl2ZVwiLCAweDgwODAwMClcbiAgICAgIC5zZXQoXCJvbGl2ZWRyYWJcIiwgMHg2YjhlMjMpXG4gICAgICAuc2V0KFwib3JhbmdlXCIsIDB4ZmZhNTAwKVxuICAgICAgLnNldChcIm9yYW5nZXJlZFwiLCAweGZmNDUwMClcbiAgICAgIC5zZXQoXCJvcmNoaWRcIiwgMHhkYTcwZDYpXG4gICAgICAuc2V0KFwicGFsZWdvbGRlbnJvZFwiLCAweGVlZThhYSlcbiAgICAgIC5zZXQoXCJwYWxlZ3JlZW5cIiwgMHg5OGZiOTgpXG4gICAgICAuc2V0KFwicGFsZXR1cnF1b2lzZVwiLCAweGFmZWVlZSlcbiAgICAgIC5zZXQoXCJwYWxldmlvbGV0cmVkXCIsIDB4ZGI3MDkzKVxuICAgICAgLnNldChcInBhcGF5YXdoaXBcIiwgMHhmZmVmZDUpXG4gICAgICAuc2V0KFwicGVhY2hwdWZmXCIsIDB4ZmZkYWI5KVxuICAgICAgLnNldChcInBlcnVcIiwgMHhjZDg1M2YpXG4gICAgICAuc2V0KFwicGlua1wiLCAweGZmYzBjYilcbiAgICAgIC5zZXQoXCJwbHVtXCIsIDB4ZGRhMGRkKVxuICAgICAgLnNldChcInBvd2RlcmJsdWVcIiwgMHhiMGUwZTYpXG4gICAgICAuc2V0KFwicHVycGxlXCIsIDB4ODAwMDgwKVxuICAgICAgLnNldChcInJlYmVjY2FwdXJwbGVcIiwgMHg2NjMzOTkpXG4gICAgICAuc2V0KFwicmVkXCIsIDB4ZmYwMDAwKVxuICAgICAgLnNldChcInJvc3licm93blwiLCAweGJjOGY4ZilcbiAgICAgIC5zZXQoXCJyb3lhbGJsdWVcIiwgMHg0MTY5ZTEpXG4gICAgICAuc2V0KFwic2FkZGxlYnJvd25cIiwgMHg4YjQ1MTMpXG4gICAgICAuc2V0KFwic2FsbW9uXCIsIDB4ZmE4MDcyKVxuICAgICAgLnNldChcInNhbmR5YnJvd25cIiwgMHhmNGE0NjApXG4gICAgICAuc2V0KFwic2VhZ3JlZW5cIiwgMHgyZThiNTcpXG4gICAgICAuc2V0KFwic2Vhc2hlbGxcIiwgMHhmZmY1ZWUpXG4gICAgICAuc2V0KFwic2llbm5hXCIsIDB4YTA1MjJkKVxuICAgICAgLnNldChcInNpbHZlclwiLCAweGMwYzBjMClcbiAgICAgIC5zZXQoXCJza3libHVlXCIsIDB4ODdjZWViKVxuICAgICAgLnNldChcInNsYXRlYmx1ZVwiLCAweDZhNWFjZClcbiAgICAgIC5zZXQoXCJzbGF0ZWdyYXlcIiwgMHg3MDgwOTApXG4gICAgICAuc2V0KFwic2xhdGVncmV5XCIsIDB4NzA4MDkwKVxuICAgICAgLnNldChcInNub3dcIiwgMHhmZmZhZmEpXG4gICAgICAuc2V0KFwic3ByaW5nZ3JlZW5cIiwgMHgwMGZmN2YpXG4gICAgICAuc2V0KFwic3RlZWxibHVlXCIsIDB4NDY4MmI0KVxuICAgICAgLnNldChcInRhblwiLCAweGQyYjQ4YylcbiAgICAgIC5zZXQoXCJ0ZWFsXCIsIDB4MDA4MDgwKVxuICAgICAgLnNldChcInRoaXN0bGVcIiwgMHhkOGJmZDgpXG4gICAgICAuc2V0KFwidG9tYXRvXCIsIDB4ZmY2MzQ3KVxuICAgICAgLnNldChcInR1cnF1b2lzZVwiLCAweDQwZTBkMClcbiAgICAgIC5zZXQoXCJ2aW9sZXRcIiwgMHhlZTgyZWUpXG4gICAgICAuc2V0KFwid2hlYXRcIiwgMHhmNWRlYjMpXG4gICAgICAuc2V0KFwid2hpdGVcIiwgMHhmZmZmZmYpXG4gICAgICAuc2V0KFwid2hpdGVzbW9rZVwiLCAweGY1ZjVmNSlcbiAgICAgIC5zZXQoXCJ5ZWxsb3dcIiwgMHhmZmZmMDApXG4gICAgICAuc2V0KFwieWVsbG93Z3JlZW5cIiwgMHg5YWNkMzIpO1xuXG4gIHZhciBkYXJrZXIgPSAuNztcbiAgdmFyIGJyaWdodGVyID0gMSAvIGRhcmtlcjtcblxuICBmdW5jdGlvbiByZ2IociwgZywgYikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoIShyIGluc3RhbmNlb2YgQ29sb3IpKSByID0gY29sb3Iocik7XG4gICAgICBpZiAocikge1xuICAgICAgICByID0gci5yZ2IoKTtcbiAgICAgICAgYiA9IHIuYjtcbiAgICAgICAgZyA9IHIuZztcbiAgICAgICAgciA9IHIucjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgPSBnID0gYiA9IE5hTjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZ2IociwgZywgYik7XG4gIH1cblxuICBmdW5jdGlvbiBSZ2IociwgZywgYikge1xuICAgIHRoaXMuciA9ICtyO1xuICAgIHRoaXMuZyA9ICtnO1xuICAgIHRoaXMuYiA9ICtiO1xuICB9XG5cbiAgdmFyIF9wcm90b3R5cGUgPSByZ2IucHJvdG90eXBlID0gUmdiLnByb3RvdHlwZSA9IG5ldyBDb2xvcjtcblxuICBfcHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrKTtcbiAgfTtcblxuICBfcHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrKTtcbiAgfTtcblxuICBfcHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90b3R5cGUuZGlzcGxheWFibGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKDAgPD0gdGhpcy5yICYmIHRoaXMuciA8PSAyNTUpXG4gICAgICAgICYmICgwIDw9IHRoaXMuZyAmJiB0aGlzLmcgPD0gMjU1KVxuICAgICAgICAmJiAoMCA8PSB0aGlzLmIgJiYgdGhpcy5iIDw9IDI1NSk7XG4gIH07XG5cbiAgX3Byb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmb3JtYXQodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG4gIH07XG5cbiAgZnVuY3Rpb24gZm9ybWF0KHIsIGcsIGIpIHtcbiAgICByZXR1cm4gXCIjXCJcbiAgICAgICAgKyAoaXNOYU4ocikgPyBcIjAwXCIgOiAociA9IE1hdGgucm91bmQocikpIDwgMTYgPyBcIjBcIiArIE1hdGgubWF4KDAsIHIpLnRvU3RyaW5nKDE2KSA6IE1hdGgubWluKDI1NSwgcikudG9TdHJpbmcoMTYpKVxuICAgICAgICArIChpc05hTihnKSA/IFwiMDBcIiA6IChnID0gTWF0aC5yb3VuZChnKSkgPCAxNiA/IFwiMFwiICsgTWF0aC5tYXgoMCwgZykudG9TdHJpbmcoMTYpIDogTWF0aC5taW4oMjU1LCBnKS50b1N0cmluZygxNikpXG4gICAgICAgICsgKGlzTmFOKGIpID8gXCIwMFwiIDogKGIgPSBNYXRoLnJvdW5kKGIpKSA8IDE2ID8gXCIwXCIgKyBNYXRoLm1heCgwLCBiKS50b1N0cmluZygxNikgOiBNYXRoLm1pbigyNTUsIGIpLnRvU3RyaW5nKDE2KSk7XG4gIH1cblxuICBmdW5jdGlvbiBoc2woaCwgcywgbCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoaCBpbnN0YW5jZW9mIEhzbCkge1xuICAgICAgICBsID0gaC5sO1xuICAgICAgICBzID0gaC5zO1xuICAgICAgICBoID0gaC5oO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCEoaCBpbnN0YW5jZW9mIENvbG9yKSkgaCA9IGNvbG9yKGgpO1xuICAgICAgICBpZiAoaCkge1xuICAgICAgICAgIGlmIChoIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gaDtcbiAgICAgICAgICBoID0gaC5yZ2IoKTtcbiAgICAgICAgICB2YXIgciA9IGguciAvIDI1NSxcbiAgICAgICAgICAgICAgZyA9IGguZyAvIDI1NSxcbiAgICAgICAgICAgICAgYiA9IGguYiAvIDI1NSxcbiAgICAgICAgICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgICAgICAgICByYW5nZSA9IG1heCAtIG1pbjtcbiAgICAgICAgICBsID0gKG1heCArIG1pbikgLyAyO1xuICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgcyA9IGwgPCAuNSA/IHJhbmdlIC8gKG1heCArIG1pbikgOiByYW5nZSAvICgyIC0gbWF4IC0gbWluKTtcbiAgICAgICAgICAgIGlmIChyID09PSBtYXgpIGggPSAoZyAtIGIpIC8gcmFuZ2UgKyAoZyA8IGIpICogNjtcbiAgICAgICAgICAgIGVsc2UgaWYgKGcgPT09IG1heCkgaCA9IChiIC0gcikgLyByYW5nZSArIDI7XG4gICAgICAgICAgICBlbHNlIGggPSAociAtIGcpIC8gcmFuZ2UgKyA0O1xuICAgICAgICAgICAgaCAqPSA2MDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaCA9IE5hTjtcbiAgICAgICAgICAgIHMgPSBsID4gMCAmJiBsIDwgMSA/IDAgOiBoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoID0gcyA9IGwgPSBOYU47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBIc2woaCwgcywgbCk7XG4gIH1cblxuICBmdW5jdGlvbiBIc2woaCwgcywgbCkge1xuICAgIHRoaXMuaCA9ICtoO1xuICAgIHRoaXMucyA9ICtzO1xuICAgIHRoaXMubCA9ICtsO1xuICB9XG5cbiAgdmFyIF9fcHJvdG90eXBlID0gaHNsLnByb3RvdHlwZSA9IEhzbC5wcm90b3R5cGUgPSBuZXcgQ29sb3I7XG5cbiAgX19wcm90b3R5cGUuYnJpZ2h0ZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgSHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrKTtcbiAgfTtcblxuICBfX3Byb3RvdHlwZS5kYXJrZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBIc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGspO1xuICB9O1xuXG4gIF9fcHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoID0gdGhpcy5oICUgMzYwICsgKHRoaXMuaCA8IDApICogMzYwLFxuICAgICAgICBzID0gaXNOYU4oaCkgfHwgaXNOYU4odGhpcy5zKSA/IDAgOiB0aGlzLnMsXG4gICAgICAgIGwgPSB0aGlzLmwsXG4gICAgICAgIG0yID0gbCArIChsIDwgLjUgPyBsIDogMSAtIGwpICogcyxcbiAgICAgICAgbTEgPSAyICogbCAtIG0yO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgaHNsMnJnYihoID49IDI0MCA/IGggLSAyNDAgOiBoICsgMTIwLCBtMSwgbTIpLFxuICAgICAgaHNsMnJnYihoLCBtMSwgbTIpLFxuICAgICAgaHNsMnJnYihoIDwgMTIwID8gaCArIDI0MCA6IGggLSAxMjAsIG0xLCBtMilcbiAgICApO1xuICB9O1xuXG4gIF9fcHJvdG90eXBlLmRpc3BsYXlhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICgwIDw9IHRoaXMucyAmJiB0aGlzLnMgPD0gMSB8fCBpc05hTih0aGlzLnMpKVxuICAgICAgICAmJiAoMCA8PSB0aGlzLmwgJiYgdGhpcy5sIDw9IDEpO1xuICB9O1xuXG4gIC8qIEZyb20gRnZEIDEzLjM3LCBDU1MgQ29sb3IgTW9kdWxlIExldmVsIDMgKi9cbiAgZnVuY3Rpb24gaHNsMnJnYihoLCBtMSwgbTIpIHtcbiAgICByZXR1cm4gKGggPCA2MCA/IG0xICsgKG0yIC0gbTEpICogaCAvIDYwXG4gICAgICAgIDogaCA8IDE4MCA/IG0yXG4gICAgICAgIDogaCA8IDI0MCA/IG0xICsgKG0yIC0gbTEpICogKDI0MCAtIGgpIC8gNjBcbiAgICAgICAgOiBtMSkgKiAyNTU7XG4gIH1cblxuICB2YXIgS24gPSAxODtcblxuICB2YXIgWG4gPSAwLjk1MDQ3MDtcbiAgdmFyIFluID0gMTtcbiAgdmFyIFpuID0gMS4wODg4MzA7XG4gIHZhciB0MCA9IDQgLyAyOTtcbiAgdmFyIHQxID0gNiAvIDI5O1xuICB2YXIgdDIgPSAzICogdDEgKiB0MTtcbiAgdmFyIHQzID0gdDEgKiB0MSAqIHQxO1xuXG4gIGZ1bmN0aW9uIGxhYihsLCBhLCBiKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChsIGluc3RhbmNlb2YgTGFiKSB7XG4gICAgICAgIGIgPSBsLmI7XG4gICAgICAgIGEgPSBsLmE7XG4gICAgICAgIGwgPSBsLmw7XG4gICAgICB9IGVsc2UgaWYgKGwgaW5zdGFuY2VvZiBIY2wpIHtcbiAgICAgICAgdmFyIGggPSBsLmggKiBkZWcycmFkO1xuICAgICAgICBiID0gTWF0aC5zaW4oaCkgKiBsLmM7XG4gICAgICAgIGEgPSBNYXRoLmNvcyhoKSAqIGwuYztcbiAgICAgICAgbCA9IGwubDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKGwgaW5zdGFuY2VvZiBSZ2IpKSBsID0gcmdiKGwpO1xuICAgICAgICB2YXIgciA9IHJnYjJ4eXoobC5yKSxcbiAgICAgICAgICAgIGcgPSByZ2IyeHl6KGwuZyksXG4gICAgICAgICAgICBiID0gcmdiMnh5eihsLmIpLFxuICAgICAgICAgICAgeCA9IHh5ejJsYWIoKDAuNDEyNDU2NCAqIHIgKyAwLjM1NzU3NjEgKiBnICsgMC4xODA0Mzc1ICogYikgLyBYbiksXG4gICAgICAgICAgICB5ID0geHl6MmxhYigoMC4yMTI2NzI5ICogciArIDAuNzE1MTUyMiAqIGcgKyAwLjA3MjE3NTAgKiBiKSAvIFluKSxcbiAgICAgICAgICAgIHogPSB4eXoybGFiKCgwLjAxOTMzMzkgKiByICsgMC4xMTkxOTIwICogZyArIDAuOTUwMzA0MSAqIGIpIC8gWm4pO1xuICAgICAgICBiID0gMjAwICogKHkgLSB6KTtcbiAgICAgICAgYSA9IDUwMCAqICh4IC0geSk7XG4gICAgICAgIGwgPSAxMTYgKiB5IC0gMTY7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGFiKGwsIGEsIGIpO1xuICB9XG5cbiAgZnVuY3Rpb24gTGFiKGwsIGEsIGIpIHtcbiAgICB0aGlzLmwgPSArbDtcbiAgICB0aGlzLmEgPSArYTtcbiAgICB0aGlzLmIgPSArYjtcbiAgfVxuXG4gIHZhciBfX19wcm90b3R5cGUgPSBsYWIucHJvdG90eXBlID0gTGFiLnByb3RvdHlwZSA9IG5ldyBDb2xvcjtcblxuICBfX19wcm90b3R5cGUuYnJpZ2h0ZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBMYWIodGhpcy5sICsgS24gKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLmEsIHRoaXMuYik7XG4gIH07XG5cbiAgX19fcHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IExhYih0aGlzLmwgLSBLbiAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMuYSwgdGhpcy5iKTtcbiAgfTtcblxuICBfX19wcm90b3R5cGUucmdiID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHkgPSAodGhpcy5sICsgMTYpIC8gMTE2LFxuICAgICAgICB4ID0gaXNOYU4odGhpcy5hKSA/IHkgOiB5ICsgdGhpcy5hIC8gNTAwLFxuICAgICAgICB6ID0gaXNOYU4odGhpcy5iKSA/IHkgOiB5IC0gdGhpcy5iIC8gMjAwO1xuICAgIHkgPSBZbiAqIGxhYjJ4eXooeSk7XG4gICAgeCA9IFhuICogbGFiMnh5eih4KTtcbiAgICB6ID0gWm4gKiBsYWIyeHl6KHopO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgeHl6MnJnYiggMy4yNDA0NTQyICogeCAtIDEuNTM3MTM4NSAqIHkgLSAwLjQ5ODUzMTQgKiB6KSwgLy8gRDY1IC0+IHNSR0JcbiAgICAgIHh5ejJyZ2IoLTAuOTY5MjY2MCAqIHggKyAxLjg3NjAxMDggKiB5ICsgMC4wNDE1NTYwICogeiksXG4gICAgICB4eXoycmdiKCAwLjA1NTY0MzQgKiB4IC0gMC4yMDQwMjU5ICogeSArIDEuMDU3MjI1MiAqIHopXG4gICAgKTtcbiAgfTtcblxuICBmdW5jdGlvbiB4eXoybGFiKHQpIHtcbiAgICByZXR1cm4gdCA+IHQzID8gTWF0aC5wb3codCwgMSAvIDMpIDogdCAvIHQyICsgdDA7XG4gIH1cblxuICBmdW5jdGlvbiBsYWIyeHl6KHQpIHtcbiAgICByZXR1cm4gdCA+IHQxID8gdCAqIHQgKiB0IDogdDIgKiAodCAtIHQwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHh5ejJyZ2IoeCkge1xuICAgIHJldHVybiAyNTUgKiAoeCA8PSAwLjAwMzEzMDggPyAxMi45MiAqIHggOiAxLjA1NSAqIE1hdGgucG93KHgsIDEgLyAyLjQpIC0gMC4wNTUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmdiMnh5eih4KSB7XG4gICAgcmV0dXJuICh4IC89IDI1NSkgPD0gMC4wNDA0NSA/IHggLyAxMi45MiA6IE1hdGgucG93KCh4ICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG4gIH1cblxuICB2YXIgZGVnMnJhZCA9IE1hdGguUEkgLyAxODA7XG4gIHZhciByYWQyZGVnID0gMTgwIC8gTWF0aC5QSTtcblxuICBmdW5jdGlvbiBoY2woaCwgYywgbCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoaCBpbnN0YW5jZW9mIEhjbCkge1xuICAgICAgICBsID0gaC5sO1xuICAgICAgICBjID0gaC5jO1xuICAgICAgICBoID0gaC5oO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCEoaCBpbnN0YW5jZW9mIExhYikpIGggPSBsYWIoaCk7XG4gICAgICAgIGwgPSBoLmw7XG4gICAgICAgIGMgPSBNYXRoLnNxcnQoaC5hICogaC5hICsgaC5iICogaC5iKTtcbiAgICAgICAgaCA9IE1hdGguYXRhbjIoaC5iLCBoLmEpICogcmFkMmRlZztcbiAgICAgICAgaWYgKGggPCAwKSBoICs9IDM2MDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBIY2woaCwgYywgbCk7XG4gIH1cblxuICBmdW5jdGlvbiBIY2woaCwgYywgbCkge1xuICAgIHRoaXMuaCA9ICtoO1xuICAgIHRoaXMuYyA9ICtjO1xuICAgIHRoaXMubCA9ICtsO1xuICB9XG5cbiAgdmFyIF9fX19wcm90b3R5cGUgPSBoY2wucHJvdG90eXBlID0gSGNsLnByb3RvdHlwZSA9IG5ldyBDb2xvcjtcblxuICBfX19fcHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgKyBLbiAqIChrID09IG51bGwgPyAxIDogaykpO1xuICB9O1xuXG4gIF9fX19wcm90b3R5cGUuZGFya2VyID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgLSBLbiAqIChrID09IG51bGwgPyAxIDogaykpO1xuICB9O1xuXG4gIF9fX19wcm90b3R5cGUucmdiID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxhYih0aGlzKS5yZ2IoKTtcbiAgfTtcblxuICB2YXIgQSA9IC0wLjE0ODYxO1xuICB2YXIgQiA9ICsxLjc4Mjc3O1xuICB2YXIgQyA9IC0wLjI5MjI3O1xuICB2YXIgRCA9IC0wLjkwNjQ5O1xuICB2YXIgRSA9ICsxLjk3Mjk0O1xuICB2YXIgRUQgPSBFICogRDtcbiAgdmFyIEVCID0gRSAqIEI7XG4gIHZhciBCQ19EQSA9IEIgKiBDIC0gRCAqIEE7XG5cbiAgZnVuY3Rpb24gY3ViZWhlbGl4KGgsIHMsIGwpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKGggaW5zdGFuY2VvZiBDdWJlaGVsaXgpIHtcbiAgICAgICAgbCA9IGgubDtcbiAgICAgICAgcyA9IGgucztcbiAgICAgICAgaCA9IGguaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKGggaW5zdGFuY2VvZiBSZ2IpKSBoID0gcmdiKGgpO1xuICAgICAgICB2YXIgciA9IGguciAvIDI1NSwgZyA9IGguZyAvIDI1NSwgYiA9IGguYiAvIDI1NTtcbiAgICAgICAgbCA9IChCQ19EQSAqIGIgKyBFRCAqIHIgLSBFQiAqIGcpIC8gKEJDX0RBICsgRUQgLSBFQik7XG4gICAgICAgIHZhciBibCA9IGIgLSBsLCBrID0gKEUgKiAoZyAtIGwpIC0gQyAqIGJsKSAvIEQ7XG4gICAgICAgIHMgPSBNYXRoLnNxcnQoayAqIGsgKyBibCAqIGJsKSAvIChFICogbCAqICgxIC0gbCkpOyAvLyBOYU4gaWYgbD0wIG9yIGw9MVxuICAgICAgICBoID0gcyA/IE1hdGguYXRhbjIoaywgYmwpICogcmFkMmRlZyAtIDEyMCA6IE5hTjtcbiAgICAgICAgaWYgKGggPCAwKSBoICs9IDM2MDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDdWJlaGVsaXgoaCwgcywgbCk7XG4gIH1cblxuICBmdW5jdGlvbiBDdWJlaGVsaXgoaCwgcywgbCkge1xuICAgIHRoaXMuaCA9ICtoO1xuICAgIHRoaXMucyA9ICtzO1xuICAgIHRoaXMubCA9ICtsO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZSA9IGN1YmVoZWxpeC5wcm90b3R5cGUgPSBDdWJlaGVsaXgucHJvdG90eXBlID0gbmV3IENvbG9yO1xuXG4gIHByb3RvdHlwZS5icmlnaHRlciA9IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBDdWJlaGVsaXgodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGspO1xuICB9O1xuXG4gIHByb3RvdHlwZS5kYXJrZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBDdWJlaGVsaXgodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGspO1xuICB9O1xuXG4gIHByb3RvdHlwZS5yZ2IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaCA9IGlzTmFOKHRoaXMuaCkgPyAwIDogKHRoaXMuaCArIDEyMCkgKiBkZWcycmFkLFxuICAgICAgICBsID0gK3RoaXMubCxcbiAgICAgICAgYSA9IGlzTmFOKHRoaXMucykgPyAwIDogdGhpcy5zICogbCAqICgxIC0gbCksXG4gICAgICAgIGNvc2ggPSBNYXRoLmNvcyhoKSxcbiAgICAgICAgc2luaCA9IE1hdGguc2luKGgpO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgMjU1ICogKGwgKyBhICogKEEgKiBjb3NoICsgQiAqIHNpbmgpKSxcbiAgICAgIDI1NSAqIChsICsgYSAqIChDICogY29zaCArIEQgKiBzaW5oKSksXG4gICAgICAyNTUgKiAobCArIGEgKiAoRSAqIGNvc2gpKVxuICAgICk7XG4gIH07XG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGVDdWJlaGVsaXhHYW1tYShnYW1tYSkge1xuICAgIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICBhID0gY3ViZWhlbGl4KGEpO1xuICAgICAgYiA9IGN1YmVoZWxpeChiKTtcbiAgICAgIHZhciBhaCA9IGlzTmFOKGEuaCkgPyBiLmggOiBhLmgsXG4gICAgICAgICAgYXMgPSBpc05hTihhLnMpID8gYi5zIDogYS5zLFxuICAgICAgICAgIGFsID0gYS5sLFxuICAgICAgICAgIGJoID0gaXNOYU4oYi5oKSA/IDAgOiBkZWx0YUh1ZShiLmgsIGFoKSxcbiAgICAgICAgICBicyA9IGlzTmFOKGIucykgPyAwIDogYi5zIC0gYXMsXG4gICAgICAgICAgYmwgPSBiLmwgLSBhbDtcbiAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGEuaCA9IGFoICsgYmggKiB0O1xuICAgICAgICBhLnMgPSBhcyArIGJzICogdDtcbiAgICAgICAgYS5sID0gYWwgKyBibCAqIE1hdGgucG93KHQsIGdhbW1hKTtcbiAgICAgICAgcmV0dXJuIGEgKyBcIlwiO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGVDdWJlaGVsaXhHYW1tYUxvbmcoZ2FtbWEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgICAgYSA9IGN1YmVoZWxpeChhKTtcbiAgICAgIGIgPSBjdWJlaGVsaXgoYik7XG4gICAgICB2YXIgYWggPSBpc05hTihhLmgpID8gYi5oIDogYS5oLFxuICAgICAgICAgIGFzID0gaXNOYU4oYS5zKSA/IGIucyA6IGEucyxcbiAgICAgICAgICBhbCA9IGEubCxcbiAgICAgICAgICBiaCA9IGlzTmFOKGIuaCkgPyAwIDogYi5oIC0gYWgsXG4gICAgICAgICAgYnMgPSBpc05hTihiLnMpID8gMCA6IGIucyAtIGFzLFxuICAgICAgICAgIGJsID0gYi5sIC0gYWw7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICBhLmggPSBhaCArIGJoICogdDtcbiAgICAgICAgYS5zID0gYXMgKyBicyAqIHQ7XG4gICAgICAgIGEubCA9IGFsICsgYmwgKiBNYXRoLnBvdyh0LCBnYW1tYSk7XG4gICAgICAgIHJldHVybiBhICsgXCJcIjtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlSGNsTG9uZyhhLCBiKSB7XG4gICAgYSA9IGhjbChhKTtcbiAgICBiID0gaGNsKGIpO1xuICAgIHZhciBhaCA9IGlzTmFOKGEuaCkgPyBiLmggOiBhLmgsXG4gICAgICAgIGFjID0gaXNOYU4oYS5jKSA/IGIuYyA6IGEuYyxcbiAgICAgICAgYWwgPSBhLmwsXG4gICAgICAgIGJoID0gaXNOYU4oYi5oKSA/IDAgOiBiLmggLSBhaCxcbiAgICAgICAgYmMgPSBpc05hTihiLmMpID8gMCA6IGIuYyAtIGFjLFxuICAgICAgICBibCA9IGIubCAtIGFsO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBhLmggPSBhaCArIGJoICogdDtcbiAgICAgIGEuYyA9IGFjICsgYmMgKiB0O1xuICAgICAgYS5sID0gYWwgKyBibCAqIHQ7XG4gICAgICByZXR1cm4gYSArIFwiXCI7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlSGNsKGEsIGIpIHtcbiAgICBhID0gaGNsKGEpO1xuICAgIGIgPSBoY2woYik7XG4gICAgdmFyIGFoID0gaXNOYU4oYS5oKSA/IGIuaCA6IGEuaCxcbiAgICAgICAgYWMgPSBpc05hTihhLmMpID8gYi5jIDogYS5jLFxuICAgICAgICBhbCA9IGEubCxcbiAgICAgICAgYmggPSBpc05hTihiLmgpID8gMCA6IGRlbHRhSHVlKGIuaCwgYWgpLFxuICAgICAgICBiYyA9IGlzTmFOKGIuYykgPyAwIDogYi5jIC0gYWMsXG4gICAgICAgIGJsID0gYi5sIC0gYWw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGEuaCA9IGFoICsgYmggKiB0O1xuICAgICAgYS5jID0gYWMgKyBiYyAqIHQ7XG4gICAgICBhLmwgPSBhbCArIGJsICogdDtcbiAgICAgIHJldHVybiBhICsgXCJcIjtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGVMYWIoYSwgYikge1xuICAgIGEgPSBsYWIoYSk7XG4gICAgYiA9IGxhYihiKTtcbiAgICB2YXIgYWwgPSBhLmwsXG4gICAgICAgIGFhID0gYS5hLFxuICAgICAgICBhYiA9IGEuYixcbiAgICAgICAgYmwgPSBiLmwgLSBhbCxcbiAgICAgICAgYmEgPSBiLmEgLSBhYSxcbiAgICAgICAgYmIgPSBiLmIgLSBhYjtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgYS5sID0gYWwgKyBibCAqIHQ7XG4gICAgICBhLmEgPSBhYSArIGJhICogdDtcbiAgICAgIGEuYiA9IGFiICsgYmIgKiB0O1xuICAgICAgcmV0dXJuIGEgKyBcIlwiO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZUhzbExvbmcoYSwgYikge1xuICAgIGEgPSBoc2woYSk7XG4gICAgYiA9IGhzbChiKTtcbiAgICB2YXIgYWggPSBpc05hTihhLmgpID8gYi5oIDogYS5oLFxuICAgICAgICBhcyA9IGlzTmFOKGEucykgPyBiLnMgOiBhLnMsXG4gICAgICAgIGFsID0gYS5sLFxuICAgICAgICBiaCA9IGlzTmFOKGIuaCkgPyAwIDogYi5oIC0gYWgsXG4gICAgICAgIGJzID0gaXNOYU4oYi5zKSA/IDAgOiBiLnMgLSBhcyxcbiAgICAgICAgYmwgPSBiLmwgLSBhbDtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgYS5oID0gYWggKyBiaCAqIHQ7XG4gICAgICBhLnMgPSBhcyArIGJzICogdDtcbiAgICAgIGEubCA9IGFsICsgYmwgKiB0O1xuICAgICAgcmV0dXJuIGEgKyBcIlwiO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZUhzbChhLCBiKSB7XG4gICAgYSA9IGhzbChhKTtcbiAgICBiID0gaHNsKGIpO1xuICAgIHZhciBhaCA9IGlzTmFOKGEuaCkgPyBiLmggOiBhLmgsXG4gICAgICAgIGFzID0gaXNOYU4oYS5zKSA/IGIucyA6IGEucyxcbiAgICAgICAgYWwgPSBhLmwsXG4gICAgICAgIGJoID0gaXNOYU4oYi5oKSA/IDAgOiBkZWx0YUh1ZShiLmgsIGFoKSxcbiAgICAgICAgYnMgPSBpc05hTihiLnMpID8gMCA6IGIucyAtIGFzLFxuICAgICAgICBibCA9IGIubCAtIGFsO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBhLmggPSBhaCArIGJoICogdDtcbiAgICAgIGEucyA9IGFzICsgYnMgKiB0O1xuICAgICAgYS5sID0gYWwgKyBibCAqIHQ7XG4gICAgICByZXR1cm4gYSArIFwiXCI7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlUmdiKGEsIGIpIHtcbiAgICBhID0gcmdiKGEpO1xuICAgIGIgPSByZ2IoYik7XG4gICAgdmFyIGFyID0gYS5yLFxuICAgICAgICBhZyA9IGEuZyxcbiAgICAgICAgYWIgPSBhLmIsXG4gICAgICAgIGJyID0gYi5yIC0gYXIsXG4gICAgICAgIGJnID0gYi5nIC0gYWcsXG4gICAgICAgIGJiID0gYi5iIC0gYWI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBmb3JtYXQoTWF0aC5yb3VuZChhciArIGJyICogdCksIE1hdGgucm91bmQoYWcgKyBiZyAqIHQpLCBNYXRoLnJvdW5kKGFiICsgYmIgKiB0KSk7XG4gICAgfTtcbiAgfVxuXG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVDdWJlaGVsaXggPSBpbnRlcnBvbGF0ZUN1YmVoZWxpeEdhbW1hKDEpO1xuICBleHBvcnRzLmludGVycG9sYXRlQ3ViZWhlbGl4TG9uZyA9IGludGVycG9sYXRlQ3ViZWhlbGl4R2FtbWFMb25nKDEpO1xuXG4gIGV4cG9ydHMuY29sb3IgPSBjb2xvcjtcbiAgZXhwb3J0cy5yZ2IgPSByZ2I7XG4gIGV4cG9ydHMuaHNsID0gaHNsO1xuICBleHBvcnRzLmxhYiA9IGxhYjtcbiAgZXhwb3J0cy5oY2wgPSBoY2w7XG4gIGV4cG9ydHMuY3ViZWhlbGl4ID0gY3ViZWhlbGl4O1xuICBleHBvcnRzLmludGVycG9sYXRlUmdiID0gaW50ZXJwb2xhdGVSZ2I7XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVIc2wgPSBpbnRlcnBvbGF0ZUhzbDtcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZUhzbExvbmcgPSBpbnRlcnBvbGF0ZUhzbExvbmc7XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVMYWIgPSBpbnRlcnBvbGF0ZUxhYjtcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZUhjbCA9IGludGVycG9sYXRlSGNsO1xuICBleHBvcnRzLmludGVycG9sYXRlSGNsTG9uZyA9IGludGVycG9sYXRlSGNsTG9uZztcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZUN1YmVoZWxpeEdhbW1hID0gaW50ZXJwb2xhdGVDdWJlaGVsaXhHYW1tYTtcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZUN1YmVoZWxpeEdhbW1hTG9uZyA9IGludGVycG9sYXRlQ3ViZWhlbGl4R2FtbWFMb25nO1xuXG59KSk7IiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICBmYWN0b3J5KChnbG9iYWwuZm9ybWF0ID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBwcmVmaXhlcyA9IFtcInlcIixcInpcIixcImFcIixcImZcIixcInBcIixcIm5cIixcIsK1XCIsXCJtXCIsXCJcIixcImtcIixcIk1cIixcIkdcIixcIlRcIixcIlBcIixcIkVcIixcIlpcIixcIllcIl07XG5cblxuICAvLyBDb21wdXRlcyB0aGUgZGVjaW1hbCBjb2VmZmljaWVudCBhbmQgZXhwb25lbnQgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgeCB3aXRoXG4gIC8vIHNpZ25pZmljYW50IGRpZ2l0cyBwLCB3aGVyZSB4IGlzIHBvc2l0aXZlIGFuZCBwIGlzIGluIFsxLCAyMV0gb3IgdW5kZWZpbmVkLlxuICAvLyBGb3IgZXhhbXBsZSwgZm9ybWF0RGVjaW1hbCgxLjIzKSByZXR1cm5zIFtcIjEyM1wiLCAwXS5cbiAgZnVuY3Rpb24gZm9ybWF0RGVjaW1hbCh4LCBwKSB7XG4gICAgaWYgKChpID0gKHggPSBwID8geC50b0V4cG9uZW50aWFsKHAgLSAxKSA6IHgudG9FeHBvbmVudGlhbCgpKS5pbmRleE9mKFwiZVwiKSkgPCAwKSByZXR1cm4gbnVsbDsgLy8gTmFOLCDCsUluZmluaXR5XG4gICAgdmFyIGksIGNvZWZmaWNpZW50ID0geC5zbGljZSgwLCBpKTtcblxuICAgIC8vIFRoZSBzdHJpbmcgcmV0dXJuZWQgYnkgdG9FeHBvbmVudGlhbCBlaXRoZXIgaGFzIHRoZSBmb3JtIFxcZFxcLlxcZCtlWy0rXVxcZCtcbiAgICAvLyAoZS5nLiwgMS4yZSszKSBvciB0aGUgZm9ybSBcXGRlWy0rXVxcZCsgKGUuZy4sIDFlKzMpLlxuICAgIHJldHVybiBbXG4gICAgICBjb2VmZmljaWVudC5sZW5ndGggPiAxID8gY29lZmZpY2llbnRbMF0gKyBjb2VmZmljaWVudC5zbGljZSgyKSA6IGNvZWZmaWNpZW50LFxuICAgICAgK3guc2xpY2UoaSArIDEpXG4gICAgXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cG9uZW50KHgpIHtcbiAgICByZXR1cm4geCA9IGZvcm1hdERlY2ltYWwoTWF0aC5hYnMoeCkpLCB4ID8geFsxXSA6IE5hTjtcbiAgfVxuXG4gIHZhciBwcmVmaXhFeHBvbmVudDtcblxuICBmdW5jdGlvbiBmb3JtYXRQcmVmaXhBdXRvKHgsIHApIHtcbiAgICB2YXIgZCA9IGZvcm1hdERlY2ltYWwoeCwgcCk7XG4gICAgaWYgKCFkKSByZXR1cm4geCArIFwiXCI7XG4gICAgdmFyIGNvZWZmaWNpZW50ID0gZFswXSxcbiAgICAgICAgZXhwb25lbnQgPSBkWzFdLFxuICAgICAgICBpID0gZXhwb25lbnQgLSAocHJlZml4RXhwb25lbnQgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCAvIDMpKSkgKiAzKSArIDEsXG4gICAgICAgIG4gPSBjb2VmZmljaWVudC5sZW5ndGg7XG4gICAgcmV0dXJuIGkgPT09IG4gPyBjb2VmZmljaWVudFxuICAgICAgICA6IGkgPiBuID8gY29lZmZpY2llbnQgKyBuZXcgQXJyYXkoaSAtIG4gKyAxKS5qb2luKFwiMFwiKVxuICAgICAgICA6IGkgPiAwID8gY29lZmZpY2llbnQuc2xpY2UoMCwgaSkgKyBcIi5cIiArIGNvZWZmaWNpZW50LnNsaWNlKGkpXG4gICAgICAgIDogXCIwLlwiICsgbmV3IEFycmF5KDEgLSBpKS5qb2luKFwiMFwiKSArIGZvcm1hdERlY2ltYWwoeCwgcCArIGkgLSAxKVswXTsgLy8gbGVzcyB0aGFuIDF5IVxuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0Um91bmRlZCh4LCBwKSB7XG4gICAgdmFyIGQgPSBmb3JtYXREZWNpbWFsKHgsIHApO1xuICAgIGlmICghZCkgcmV0dXJuIHggKyBcIlwiO1xuICAgIHZhciBjb2VmZmljaWVudCA9IGRbMF0sXG4gICAgICAgIGV4cG9uZW50ID0gZFsxXTtcbiAgICByZXR1cm4gZXhwb25lbnQgPCAwID8gXCIwLlwiICsgbmV3IEFycmF5KC1leHBvbmVudCkuam9pbihcIjBcIikgKyBjb2VmZmljaWVudFxuICAgICAgICA6IGNvZWZmaWNpZW50Lmxlbmd0aCA+IGV4cG9uZW50ICsgMSA/IGNvZWZmaWNpZW50LnNsaWNlKDAsIGV4cG9uZW50ICsgMSkgKyBcIi5cIiArIGNvZWZmaWNpZW50LnNsaWNlKGV4cG9uZW50ICsgMSlcbiAgICAgICAgOiBjb2VmZmljaWVudCArIG5ldyBBcnJheShleHBvbmVudCAtIGNvZWZmaWNpZW50Lmxlbmd0aCArIDIpLmpvaW4oXCIwXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0RGVmYXVsdCh4LCBwKSB7XG4gICAgeCA9IHgudG9QcmVjaXNpb24ocCk7XG5cbiAgICBvdXQ6IGZvciAodmFyIG4gPSB4Lmxlbmd0aCwgaSA9IDEsIGkwID0gLTEsIGkxOyBpIDwgbjsgKytpKSB7XG4gICAgICBzd2l0Y2ggKHhbaV0pIHtcbiAgICAgICAgY2FzZSBcIi5cIjogaTAgPSBpMSA9IGk7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiMFwiOiBpZiAoaTAgPT09IDApIGkwID0gaTsgaTEgPSBpOyBicmVhaztcbiAgICAgICAgY2FzZSBcImVcIjogYnJlYWsgb3V0O1xuICAgICAgICBkZWZhdWx0OiBpZiAoaTAgPiAwKSBpMCA9IDA7IGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpMCA+IDAgPyB4LnNsaWNlKDAsIGkwKSArIHguc2xpY2UoaTEgKyAxKSA6IHg7XG4gIH1cblxuICB2YXIgZm9ybWF0VHlwZXMgPSB7XG4gICAgXCJcIjogZm9ybWF0RGVmYXVsdCxcbiAgICBcIiVcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4gKHggKiAxMDApLnRvRml4ZWQocCk7IH0sXG4gICAgXCJiXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMik7IH0sXG4gICAgXCJjXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggKyBcIlwiOyB9LFxuICAgIFwiZFwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDEwKTsgfSxcbiAgICBcImVcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4geC50b0V4cG9uZW50aWFsKHApOyB9LFxuICAgIFwiZlwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvRml4ZWQocCk7IH0sXG4gICAgXCJnXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIHgudG9QcmVjaXNpb24ocCk7IH0sXG4gICAgXCJvXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoOCk7IH0sXG4gICAgXCJwXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIGZvcm1hdFJvdW5kZWQoeCAqIDEwMCwgcCk7IH0sXG4gICAgXCJyXCI6IGZvcm1hdFJvdW5kZWQsXG4gICAgXCJzXCI6IGZvcm1hdFByZWZpeEF1dG8sXG4gICAgXCJYXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IH0sXG4gICAgXCJ4XCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTYpOyB9XG4gIH07XG5cblxuICAvLyBbW2ZpbGxdYWxpZ25dW3NpZ25dW3N5bWJvbF1bMF1bd2lkdGhdWyxdWy5wcmVjaXNpb25dW3R5cGVdXG4gIHZhciByZSA9IC9eKD86KC4pPyhbPD49Xl0pKT8oWytcXC1cXCggXSk/KFskI10pPygwKT8oXFxkKyk/KCwpPyhcXC5cXGQrKT8oW2EteiVdKT8kL2k7XG5cbiAgZnVuY3Rpb24gRm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikge1xuICAgIGlmICghKG1hdGNoID0gcmUuZXhlYyhzcGVjaWZpZXIpKSkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmb3JtYXQ6IFwiICsgc3BlY2lmaWVyKTtcblxuICAgIHZhciBtYXRjaCxcbiAgICAgICAgZmlsbCA9IG1hdGNoWzFdIHx8IFwiIFwiLFxuICAgICAgICBhbGlnbiA9IG1hdGNoWzJdIHx8IFwiPlwiLFxuICAgICAgICBzaWduID0gbWF0Y2hbM10gfHwgXCItXCIsXG4gICAgICAgIHN5bWJvbCA9IG1hdGNoWzRdIHx8IFwiXCIsXG4gICAgICAgIHplcm8gPSAhIW1hdGNoWzVdLFxuICAgICAgICB3aWR0aCA9IG1hdGNoWzZdICYmICttYXRjaFs2XSxcbiAgICAgICAgY29tbWEgPSAhIW1hdGNoWzddLFxuICAgICAgICBwcmVjaXNpb24gPSBtYXRjaFs4XSAmJiArbWF0Y2hbOF0uc2xpY2UoMSksXG4gICAgICAgIHR5cGUgPSBtYXRjaFs5XSB8fCBcIlwiO1xuXG4gICAgLy8gVGhlIFwiblwiIHR5cGUgaXMgYW4gYWxpYXMgZm9yIFwiLGdcIi5cbiAgICBpZiAodHlwZSA9PT0gXCJuXCIpIGNvbW1hID0gdHJ1ZSwgdHlwZSA9IFwiZ1wiO1xuXG4gICAgLy8gTWFwIGludmFsaWQgdHlwZXMgdG8gdGhlIGRlZmF1bHQgZm9ybWF0LlxuICAgIGVsc2UgaWYgKCFmb3JtYXRUeXBlc1t0eXBlXSkgdHlwZSA9IFwiXCI7XG5cbiAgICAvLyBJZiB6ZXJvIGZpbGwgaXMgc3BlY2lmaWVkLCBwYWRkaW5nIGdvZXMgYWZ0ZXIgc2lnbiBhbmQgYmVmb3JlIGRpZ2l0cy5cbiAgICBpZiAoemVybyB8fCAoZmlsbCA9PT0gXCIwXCIgJiYgYWxpZ24gPT09IFwiPVwiKSkgemVybyA9IHRydWUsIGZpbGwgPSBcIjBcIiwgYWxpZ24gPSBcIj1cIjtcblxuICAgIHRoaXMuZmlsbCA9IGZpbGw7XG4gICAgdGhpcy5hbGlnbiA9IGFsaWduO1xuICAgIHRoaXMuc2lnbiA9IHNpZ247XG4gICAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XG4gICAgdGhpcy56ZXJvID0gemVybztcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5jb21tYSA9IGNvbW1hO1xuICAgIHRoaXMucHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gIH1cblxuICBGb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsbFxuICAgICAgICArIHRoaXMuYWxpZ25cbiAgICAgICAgKyB0aGlzLnNpZ25cbiAgICAgICAgKyB0aGlzLnN5bWJvbFxuICAgICAgICArICh0aGlzLnplcm8gPyBcIjBcIiA6IFwiXCIpXG4gICAgICAgICsgKHRoaXMud2lkdGggPT0gbnVsbCA/IFwiXCIgOiBNYXRoLm1heCgxLCB0aGlzLndpZHRoIHwgMCkpXG4gICAgICAgICsgKHRoaXMuY29tbWEgPyBcIixcIiA6IFwiXCIpXG4gICAgICAgICsgKHRoaXMucHJlY2lzaW9uID09IG51bGwgPyBcIlwiIDogXCIuXCIgKyBNYXRoLm1heCgwLCB0aGlzLnByZWNpc2lvbiB8IDApKVxuICAgICAgICArIHRoaXMudHlwZTtcbiAgfTtcblxuICBmdW5jdGlvbiBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSB7XG4gICAgcmV0dXJuIG5ldyBGb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgICByZXR1cm4geDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdEdyb3VwKGdyb3VwaW5nLCB0aG91c2FuZHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIHdpZHRoKSB7XG4gICAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICB0ID0gW10sXG4gICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgZyA9IGdyb3VwaW5nWzBdLFxuICAgICAgICAgIGxlbmd0aCA9IDA7XG5cbiAgICAgIHdoaWxlIChpID4gMCAmJiBnID4gMCkge1xuICAgICAgICBpZiAobGVuZ3RoICsgZyArIDEgPiB3aWR0aCkgZyA9IE1hdGgubWF4KDEsIHdpZHRoIC0gbGVuZ3RoKTtcbiAgICAgICAgdC5wdXNoKHZhbHVlLnN1YnN0cmluZyhpIC09IGcsIGkgKyBnKSk7XG4gICAgICAgIGlmICgobGVuZ3RoICs9IGcgKyAxKSA+IHdpZHRoKSBicmVhaztcbiAgICAgICAgZyA9IGdyb3VwaW5nW2ogPSAoaiArIDEpICUgZ3JvdXBpbmcubGVuZ3RoXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQucmV2ZXJzZSgpLmpvaW4odGhvdXNhbmRzKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbG9jYWxlRm9ybWF0KGxvY2FsZSkge1xuICAgIHZhciBncm91cCA9IGxvY2FsZS5ncm91cGluZyAmJiBsb2NhbGUudGhvdXNhbmRzID8gZm9ybWF0R3JvdXAobG9jYWxlLmdyb3VwaW5nLCBsb2NhbGUudGhvdXNhbmRzKSA6IGlkZW50aXR5LFxuICAgICAgICBjdXJyZW5jeSA9IGxvY2FsZS5jdXJyZW5jeSxcbiAgICAgICAgZGVjaW1hbCA9IGxvY2FsZS5kZWNpbWFsO1xuXG4gICAgZnVuY3Rpb24gZm9ybWF0KHNwZWNpZmllcikge1xuICAgICAgc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcik7XG5cbiAgICAgIHZhciBmaWxsID0gc3BlY2lmaWVyLmZpbGwsXG4gICAgICAgICAgYWxpZ24gPSBzcGVjaWZpZXIuYWxpZ24sXG4gICAgICAgICAgc2lnbiA9IHNwZWNpZmllci5zaWduLFxuICAgICAgICAgIHN5bWJvbCA9IHNwZWNpZmllci5zeW1ib2wsXG4gICAgICAgICAgemVybyA9IHNwZWNpZmllci56ZXJvLFxuICAgICAgICAgIHdpZHRoID0gc3BlY2lmaWVyLndpZHRoLFxuICAgICAgICAgIGNvbW1hID0gc3BlY2lmaWVyLmNvbW1hLFxuICAgICAgICAgIHByZWNpc2lvbiA9IHNwZWNpZmllci5wcmVjaXNpb24sXG4gICAgICAgICAgdHlwZSA9IHNwZWNpZmllci50eXBlO1xuXG4gICAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAgIC8vIEZvciBTSS1wcmVmaXgsIHRoZSBzdWZmaXggaXMgbGF6aWx5IGNvbXB1dGVkLlxuICAgICAgdmFyIHByZWZpeCA9IHN5bWJvbCA9PT0gXCIkXCIgPyBjdXJyZW5jeVswXSA6IHN5bWJvbCA9PT0gXCIjXCIgJiYgL1tib3hYXS8udGVzdCh0eXBlKSA/IFwiMFwiICsgdHlwZS50b0xvd2VyQ2FzZSgpIDogXCJcIixcbiAgICAgICAgICBzdWZmaXggPSBzeW1ib2wgPT09IFwiJFwiID8gY3VycmVuY3lbMV0gOiAvWyVwXS8udGVzdCh0eXBlKSA/IFwiJVwiIDogXCJcIjtcblxuICAgICAgLy8gV2hhdCBmb3JtYXQgZnVuY3Rpb24gc2hvdWxkIHdlIHVzZT9cbiAgICAgIC8vIElzIHRoaXMgYW4gaW50ZWdlciB0eXBlP1xuICAgICAgLy8gQ2FuIHRoaXMgdHlwZSBnZW5lcmF0ZSBleHBvbmVudGlhbCBub3RhdGlvbj9cbiAgICAgIHZhciBmb3JtYXRUeXBlID0gZm9ybWF0VHlwZXNbdHlwZV0sXG4gICAgICAgICAgbWF5YmVTdWZmaXggPSAhdHlwZSB8fCAvW2RlZmdwcnMlXS8udGVzdCh0eXBlKTtcblxuICAgICAgLy8gU2V0IHRoZSBkZWZhdWx0IHByZWNpc2lvbiBpZiBub3Qgc3BlY2lmaWVkLFxuICAgICAgLy8gb3IgY2xhbXAgdGhlIHNwZWNpZmllZCBwcmVjaXNpb24gdG8gdGhlIHN1cHBvcnRlZCByYW5nZS5cbiAgICAgIC8vIEZvciBzaWduaWZpY2FudCBwcmVjaXNpb24sIGl0IG11c3QgYmUgaW4gWzEsIDIxXS5cbiAgICAgIC8vIEZvciBmaXhlZCBwcmVjaXNpb24sIGl0IG11c3QgYmUgaW4gWzAsIDIwXS5cbiAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PSBudWxsID8gKHR5cGUgPyA2IDogMTIpXG4gICAgICAgICAgOiAvW2dwcnNdLy50ZXN0KHR5cGUpID8gTWF0aC5tYXgoMSwgTWF0aC5taW4oMjEsIHByZWNpc2lvbikpXG4gICAgICAgICAgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigyMCwgcHJlY2lzaW9uKSk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgdmFsdWVQcmVmaXggPSBwcmVmaXgsXG4gICAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IHN1ZmZpeDtcblxuICAgICAgICBpZiAodHlwZSA9PT0gXCJjXCIpIHtcbiAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IGZvcm1hdFR5cGUodmFsdWUpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gK3ZhbHVlO1xuXG4gICAgICAgICAgLy8gQ29udmVydCBuZWdhdGl2ZSB0byBwb3NpdGl2ZSwgYW5kIGNvbXB1dGUgdGhlIHByZWZpeC5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgLTAgaXMgbm90IGxlc3MgdGhhbiAwLCBidXQgMSAvIC0wIGlzIVxuICAgICAgICAgIHZhciB2YWx1ZU5lZ2F0aXZlID0gKHZhbHVlIDwgMCB8fCAxIC8gdmFsdWUgPCAwKSAmJiAodmFsdWUgKj0gLTEsIHRydWUpO1xuXG4gICAgICAgICAgLy8gUGVyZm9ybSB0aGUgaW5pdGlhbCBmb3JtYXR0aW5nLlxuICAgICAgICAgIHZhbHVlID0gZm9ybWF0VHlwZSh2YWx1ZSwgcHJlY2lzaW9uKTtcblxuICAgICAgICAgIC8vIENvbXB1dGUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxuICAgICAgICAgIHZhbHVlUHJlZml4ID0gKHZhbHVlTmVnYXRpdmUgPyAoc2lnbiA9PT0gXCIoXCIgPyBzaWduIDogXCItXCIpIDogc2lnbiA9PT0gXCItXCIgfHwgc2lnbiA9PT0gXCIoXCIgPyBcIlwiIDogc2lnbikgKyB2YWx1ZVByZWZpeDtcbiAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IHZhbHVlU3VmZml4ICsgKHR5cGUgPT09IFwic1wiID8gcHJlZml4ZXNbOCArIHByZWZpeEV4cG9uZW50IC8gM10gOiBcIlwiKSArICh2YWx1ZU5lZ2F0aXZlICYmIHNpZ24gPT09IFwiKFwiID8gXCIpXCIgOiBcIlwiKTtcblxuICAgICAgICAgIC8vIEJyZWFrIHRoZSBmb3JtYXR0ZWQgdmFsdWUgaW50byB0aGUgaW50ZWdlciDigJx2YWx1ZeKAnSBwYXJ0IHRoYXQgY2FuIGJlXG4gICAgICAgICAgLy8gZ3JvdXBlZCwgYW5kIGZyYWN0aW9uYWwgb3IgZXhwb25lbnRpYWwg4oCcc3VmZml44oCdIHBhcnQgdGhhdCBpcyBub3QuXG4gICAgICAgICAgaWYgKG1heWJlU3VmZml4KSB7XG4gICAgICAgICAgICB2YXIgaSA9IC0xLCBuID0gdmFsdWUubGVuZ3RoLCBjO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgaWYgKGMgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpLCA0OCA+IGMgfHwgYyA+IDU3KSB7XG4gICAgICAgICAgICAgICAgdmFsdWVTdWZmaXggPSAoYyA9PT0gNDYgPyBkZWNpbWFsICsgdmFsdWUuc2xpY2UoaSArIDEpIDogdmFsdWUuc2xpY2UoaSkpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBmaWxsIGNoYXJhY3RlciBpcyBub3QgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYmVmb3JlIHBhZGRpbmcuXG4gICAgICAgIGlmIChjb21tYSAmJiAhemVybykgdmFsdWUgPSBncm91cCh2YWx1ZSwgSW5maW5pdHkpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHBhZGRpbmcuXG4gICAgICAgIHZhciBsZW5ndGggPSB2YWx1ZVByZWZpeC5sZW5ndGggKyB2YWx1ZS5sZW5ndGggKyB2YWx1ZVN1ZmZpeC5sZW5ndGgsXG4gICAgICAgICAgICBwYWRkaW5nID0gbGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpIDogXCJcIjtcblxuICAgICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYWZ0ZXIgcGFkZGluZy5cbiAgICAgICAgaWYgKGNvbW1hICYmIHplcm8pIHZhbHVlID0gZ3JvdXAocGFkZGluZyArIHZhbHVlLCBwYWRkaW5nLmxlbmd0aCA/IHdpZHRoIC0gdmFsdWVTdWZmaXgubGVuZ3RoIDogSW5maW5pdHkpLCBwYWRkaW5nID0gXCJcIjtcblxuICAgICAgICAvLyBSZWNvbnN0cnVjdCB0aGUgZmluYWwgb3V0cHV0IGJhc2VkIG9uIHRoZSBkZXNpcmVkIGFsaWdubWVudC5cbiAgICAgICAgc3dpdGNoIChhbGlnbikge1xuICAgICAgICAgIGNhc2UgXCI8XCI6IHJldHVybiB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXggKyBwYWRkaW5nO1xuICAgICAgICAgIGNhc2UgXCI9XCI6IHJldHVybiB2YWx1ZVByZWZpeCArIHBhZGRpbmcgKyB2YWx1ZSArIHZhbHVlU3VmZml4O1xuICAgICAgICAgIGNhc2UgXCJeXCI6IHJldHVybiBwYWRkaW5nLnNsaWNlKDAsIGxlbmd0aCA9IHBhZGRpbmcubGVuZ3RoID4+IDEpICsgdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4ICsgcGFkZGluZy5zbGljZShsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWRkaW5nICsgdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSkge1xuICAgICAgdmFyIGYgPSBmb3JtYXQoKHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpLCBzcGVjaWZpZXIudHlwZSA9IFwiZlwiLCBzcGVjaWZpZXIpKSxcbiAgICAgICAgICBlID0gTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQodmFsdWUpIC8gMykpKSAqIDMsXG4gICAgICAgICAgayA9IE1hdGgucG93KDEwLCAtZSksXG4gICAgICAgICAgcHJlZml4ID0gcHJlZml4ZXNbOCArIGUgLyAzXTtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZihrICogdmFsdWUpICsgcHJlZml4O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgICBmb3JtYXRQcmVmaXg6IGZvcm1hdFByZWZpeFxuICAgIH07XG4gIH1cblxuICB2YXIgbG9jYWxlID0gbG9jYWxlRm9ybWF0KHtcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB0aG91c2FuZHM6IFwiLFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIiRcIiwgXCJcIl1cbiAgfSk7XG5cbiAgZXhwb3J0cy5mb3JtYXQgPSBsb2NhbGUuZm9ybWF0O1xuICBleHBvcnRzLmZvcm1hdFByZWZpeCA9IGxvY2FsZS5mb3JtYXRQcmVmaXg7XG5cbiAgZnVuY3Rpb24gcHJlY2lzaW9uUm91bmQoc3RlcCwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIGV4cG9uZW50KE1hdGguYWJzKG1heCkpIC0gZXhwb25lbnQoTWF0aC5hYnMoc3RlcCkpKSArIDE7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVjaXNpb25QcmVmaXgoc3RlcCwgdmFsdWUpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQodmFsdWUpIC8gMykpKSAqIDMgLSBleHBvbmVudChNYXRoLmFicyhzdGVwKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlY2lzaW9uRml4ZWQoc3RlcCkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCAtZXhwb25lbnQoTWF0aC5hYnMoc3RlcCkpKTtcbiAgfVxuXG4gIGV4cG9ydHMuZm9ybWF0U3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyO1xuICBleHBvcnRzLmxvY2FsZUZvcm1hdCA9IGxvY2FsZUZvcm1hdDtcbiAgZXhwb3J0cy5wcmVjaXNpb25GaXhlZCA9IHByZWNpc2lvbkZpeGVkO1xuICBleHBvcnRzLnByZWNpc2lvblByZWZpeCA9IHByZWNpc2lvblByZWZpeDtcbiAgZXhwb3J0cy5wcmVjaXNpb25Sb3VuZCA9IHByZWNpc2lvblJvdW5kO1xuXG59KSk7IiwiaWYgKHR5cGVvZiBNYXAgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgTWFwID0gZnVuY3Rpb24oKSB7IHRoaXMuY2xlYXIoKTsgfTtcbiAgTWFwLnByb3RvdHlwZSA9IHtcbiAgICBzZXQ6IGZ1bmN0aW9uKGssIHYpIHsgdGhpcy5fW2tdID0gdjsgcmV0dXJuIHRoaXM7IH0sXG4gICAgZ2V0OiBmdW5jdGlvbihrKSB7IHJldHVybiB0aGlzLl9ba107IH0sXG4gICAgaGFzOiBmdW5jdGlvbihrKSB7IHJldHVybiBrIGluIHRoaXMuXzsgfSxcbiAgICBkZWxldGU6IGZ1bmN0aW9uKGspIHsgcmV0dXJuIGsgaW4gdGhpcy5fICYmIGRlbGV0ZSB0aGlzLl9ba107IH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkgeyB0aGlzLl8gPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9LFxuICAgIGdldCBzaXplKCkgeyB2YXIgbiA9IDA7IGZvciAodmFyIGsgaW4gdGhpcy5fKSArK247IHJldHVybiBuOyB9LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uKGMpIHsgZm9yICh2YXIgayBpbiB0aGlzLl8pIGModGhpcy5fW2tdLCBrLCB0aGlzKTsgfVxuICB9O1xufSBlbHNlIChmdW5jdGlvbigpIHtcbiAgdmFyIG0gPSBuZXcgTWFwO1xuICBpZiAobS5zZXQoMCwgMCkgIT09IG0pIHtcbiAgICBtID0gbS5zZXQ7XG4gICAgTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbigpIHsgbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gdGhpczsgfTtcbiAgfVxufSkoKTtcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICBmYWN0b3J5KChnbG9iYWwudGltZUZvcm1hdCA9IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiB1dGNEYXRlKGQpIHtcbiAgICBpZiAoMCA8PSBkLnkgJiYgZC55IDwgMTAwKSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKC0xLCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKSk7XG4gICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGQueSk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKGQueSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gbG9jYWxEYXRlKGQpIHtcbiAgICBpZiAoMCA8PSBkLnkgJiYgZC55IDwgMTAwKSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKC0xLCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKTtcbiAgICAgIGRhdGUuc2V0RnVsbFllYXIoZC55KTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoZC55LCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKTtcbiAgfVxuXG4gIHZhciBwYWRzID0ge1wiLVwiOiBcIlwiLCBcIl9cIjogXCIgXCIsIFwiMFwiOiBcIjBcIn07XG5cbiAgZnVuY3Rpb24gbmV3WWVhcih5KSB7XG4gICAgcmV0dXJuIHt5OiB5LCBtOiAwLCBkOiAxLCBIOiAwLCBNOiAwLCBTOiAwLCBMOiAwfTtcbiAgfVxuXG4gIHZhciBwZXJjZW50UmUgPSAvXiUvO1xuXG4gIGZ1bmN0aW9uIHBhcnNlTGl0ZXJhbFBlcmNlbnQoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBwZXJjZW50UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgICByZXR1cm4gbiA/IGkgKyBuWzBdLmxlbmd0aCA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2Vab25lKGQsIHN0cmluZywgaSkge1xuICAgIHJldHVybiAvXlsrLV1cXGR7NH0kLy50ZXN0KHN0cmluZyA9IHN0cmluZy5zbGljZShpLCBpICsgNSkpXG4gICAgICAgID8gKGQuWiA9IC1zdHJpbmcsIGkgKyA1KSAvLyBzaWduIGRpZmZlcnMgZnJvbSBnZXRUaW1lem9uZU9mZnNldCFcbiAgICAgICAgOiAtMTtcbiAgfVxuXG4gIHZhciBudW1iZXJSZSA9IC9eXFxzKlxcZCsvO1xuXG4gIGZ1bmN0aW9uIHBhcnNlV2Vla2RheU51bWJlcihkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gICAgcmV0dXJuIG4gPyAoZC53ID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlV2Vla051bWJlclN1bmRheShkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLlUgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VXZWVrTnVtYmVyTW9uZGF5KGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQuVyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVllYXIoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGQueSA9ICtuWzBdICsgKCtuWzBdID4gNjggPyAxOTAwIDogMjAwMCksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTW9udGhOdW1iZXIoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGQubSA9IG5bMF0gLSAxLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZURheU9mTW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGQuZCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZURheU9mWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAzKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5tID0gMCwgZC5kID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSG91cjI0KGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkLkggPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNaW51dGVzKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkLk0gPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTZWNvbmRzKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkLlMgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNaWxsaXNlY29uZHMoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMykpO1xuICAgIHJldHVybiBuID8gKGQuTCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUZ1bGxZZWFyKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDQpKTtcbiAgICByZXR1cm4gbiA/IChkLnkgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0TGl0ZXJhbFBlcmNlbnQoKSB7XG4gICAgcmV0dXJuIFwiJVwiO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDWm9uZSgpIHtcbiAgICByZXR1cm4gXCIrMDAwMFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFkKHZhbHVlLCBmaWxsLCB3aWR0aCkge1xuICAgIHZhciBzaWduID0gdmFsdWUgPCAwID8gXCItXCIgOiBcIlwiLFxuICAgICAgICBzdHJpbmcgPSAoc2lnbiA/IC12YWx1ZSA6IHZhbHVlKSArIFwiXCIsXG4gICAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgcmV0dXJuIHNpZ24gKyAobGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpICsgc3RyaW5nIDogc3RyaW5nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ0Z1bGxZZWFyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMDAwLCBwLCA0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1llYXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENGdWxsWWVhcigpICUgMTAwLCBwLCAyKTtcbiAgfVxuXG4gIHZhciB0MSA9IG5ldyBEYXRlO1xuXG4gIHZhciB0MCA9IG5ldyBEYXRlO1xuXG4gIGZ1bmN0aW9uIG5ld0ludGVydmFsKGZsb29yaSwgb2Zmc2V0aSwgY291bnQpIHtcblxuICAgIGZ1bmN0aW9uIGludGVydmFsKGRhdGUpIHtcbiAgICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSksIGRhdGU7XG4gICAgfVxuXG4gICAgaW50ZXJ2YWwuZmxvb3IgPSBpbnRlcnZhbDtcblxuICAgIGludGVydmFsLnJvdW5kID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgdmFyIGQwID0gbmV3IERhdGUoK2RhdGUpLFxuICAgICAgICAgIGQxID0gbmV3IERhdGUoZGF0ZSAtIDEpO1xuICAgICAgZmxvb3JpKGQwKSwgZmxvb3JpKGQxKSwgb2Zmc2V0aShkMSwgMSk7XG4gICAgICByZXR1cm4gZGF0ZSAtIGQwIDwgZDEgLSBkYXRlID8gZDAgOiBkMTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwuY2VpbCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKGRhdGUgLSAxKSksIG9mZnNldGkoZGF0ZSwgMSksIGRhdGU7XG4gICAgfTtcblxuICAgIGludGVydmFsLm9mZnNldCA9IGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgIHJldHVybiBvZmZzZXRpKGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSksIHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApKSwgZGF0ZTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgICAgdmFyIHJhbmdlID0gW107XG4gICAgICBzdGFydCA9IG5ldyBEYXRlKHN0YXJ0IC0gMSk7XG4gICAgICBzdG9wID0gbmV3IERhdGUoK3N0b3ApO1xuICAgICAgc3RlcCA9IHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApO1xuICAgICAgaWYgKCEoc3RhcnQgPCBzdG9wKSB8fCAhKHN0ZXAgPiAwKSkgcmV0dXJuIHJhbmdlOyAvLyBhbHNvIGhhbmRsZXMgSW52YWxpZCBEYXRlXG4gICAgICBvZmZzZXRpKHN0YXJ0LCAxKSwgZmxvb3JpKHN0YXJ0KTtcbiAgICAgIGlmIChzdGFydCA8IHN0b3ApIHJhbmdlLnB1c2gobmV3IERhdGUoK3N0YXJ0KSk7XG4gICAgICB3aGlsZSAob2Zmc2V0aShzdGFydCwgc3RlcCksIGZsb29yaShzdGFydCksIHN0YXJ0IDwgc3RvcCkgcmFuZ2UucHVzaChuZXcgRGF0ZSgrc3RhcnQpKTtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwuZmlsdGVyID0gZnVuY3Rpb24odGVzdCkge1xuICAgICAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgd2hpbGUgKGZsb29yaShkYXRlKSwgIXRlc3QoZGF0ZSkpIGRhdGUuc2V0VGltZShkYXRlIC0gMSk7XG4gICAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICAgIHdoaWxlICgtLXN0ZXAgPj0gMCkgd2hpbGUgKG9mZnNldGkoZGF0ZSwgMSksICF0ZXN0KGRhdGUpKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoY291bnQpIGludGVydmFsLmNvdW50ID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgdDAuc2V0VGltZSgrc3RhcnQpLCB0MS5zZXRUaW1lKCtlbmQpO1xuICAgICAgZmxvb3JpKHQwKSwgZmxvb3JpKHQxKTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGNvdW50KHQwLCB0MSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gaW50ZXJ2YWw7XG4gIH1cblxuICB2YXIgdXRjWWVhciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgIGRhdGUuc2V0VVRDTW9udGgoMCwgMSk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpICsgb2Zmc2V0KTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBlbmQuZ2V0VVRDRnVsbFllYXIoKSAtIHN0YXJ0LmdldFVUQ0Z1bGxZZWFyKCk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHV0Y1dlZWtkYXkoaSkge1xuICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gKGRhdGUuZ2V0VVRDRGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICB9LCBmdW5jdGlvbihkYXRlLCBvZmZzZXQpIHtcbiAgICAgIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIG9mZnNldCAqIDcpO1xuICAgIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gNjA0OGU1O1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHV0Y01vbmRheSA9IHV0Y1dlZWtkYXkoMSk7XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDV2Vla051bWJlck1vbmRheShkLCBwKSB7XG4gICAgcmV0dXJuIHBhZCh1dGNNb25kYXkuY291bnQodXRjWWVhcihkKSwgZCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDV2Vla2RheU51bWJlcihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDRGF5KCk7XG4gIH1cblxuICB2YXIgdXRjU3VuZGF5ID0gdXRjV2Vla2RheSgwKTtcblxuICBmdW5jdGlvbiBmb3JtYXRVVENXZWVrTnVtYmVyU3VuZGF5KGQsIHApIHtcbiAgICByZXR1cm4gcGFkKHV0Y1N1bmRheS5jb3VudCh1dGNZZWFyKGQpLCBkKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENTZWNvbmRzKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDU2Vjb25kcygpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ01pbnV0ZXMoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENNaW51dGVzKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDTW9udGhOdW1iZXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENNb250aCgpICsgMSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENNaWxsaXNlY29uZHMoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENNaWxsaXNlY29uZHMoKSwgcCwgMyk7XG4gIH1cblxuICB2YXIgdXRjRGF5ID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIG9mZnNldCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIDg2NGU1O1xuICB9KTtcblxuICBmdW5jdGlvbiBmb3JtYXRVVENEYXlPZlllYXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoMSArIHV0Y0RheS5jb3VudCh1dGNZZWFyKGQpLCBkKSwgcCwgMyk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENIb3VyMTIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENIb3VycygpICUgMTIgfHwgMTIsIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDSG91cjI0KGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDSG91cnMoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENEYXlPZk1vbnRoKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDRGF0ZSgpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFpvbmUoZCkge1xuICAgIHZhciB6ID0gZC5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgIHJldHVybiAoeiA+IDAgPyBcIi1cIiA6ICh6ICo9IC0xLCBcIitcIikpXG4gICAgICAgICsgcGFkKHogLyA2MCB8IDAsIFwiMFwiLCAyKVxuICAgICAgICArIHBhZCh6ICUgNjAsIFwiMFwiLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdEZ1bGxZZWFyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMDAwLCBwLCA0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFllYXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRGdWxsWWVhcigpICUgMTAwLCBwLCAyKTtcbiAgfVxuXG4gIHZhciB5ZWFyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgZGF0ZS5zZXRNb250aCgwLCAxKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkgKyBvZmZzZXQpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGVuZC5nZXRGdWxsWWVhcigpIC0gc3RhcnQuZ2V0RnVsbFllYXIoKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gd2Vla2RheShpKSB7XG4gICAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSAoZGF0ZS5nZXREYXkoKSArIDcgLSBpKSAlIDcpO1xuICAgIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgb2Zmc2V0ICogNyk7XG4gICAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIChlbmQgLSBzdGFydCAtIChlbmQuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogNmU0KSAvIDYwNDhlNTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBtb25kYXkgPSB3ZWVrZGF5KDEpO1xuXG4gIGZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXJNb25kYXkoZCwgcCkge1xuICAgIHJldHVybiBwYWQobW9uZGF5LmNvdW50KHllYXIoZCksIGQpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFdlZWtkYXlOdW1iZXIoZCkge1xuICAgIHJldHVybiBkLmdldERheSgpO1xuICB9XG5cbiAgdmFyIHN1bmRheSA9IHdlZWtkYXkoMCk7XG5cbiAgZnVuY3Rpb24gZm9ybWF0V2Vla051bWJlclN1bmRheShkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChzdW5kYXkuY291bnQoeWVhcihkKSwgZCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0U2Vjb25kcyhkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFNlY29uZHMoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRNaW51dGVzKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0TWludXRlcygpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdE1vbnRoTnVtYmVyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0TW9udGgoKSArIDEsIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0TWlsbGlzZWNvbmRzKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0TWlsbGlzZWNvbmRzKCksIHAsIDMpO1xuICB9XG5cbiAgdmFyIGRheSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBvZmZzZXQpIHtcbiAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBvZmZzZXQpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCAtIChlbmQuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogNmU0KSAvIDg2NGU1O1xuICB9KTtcblxuICBmdW5jdGlvbiBmb3JtYXREYXlPZlllYXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoMSArIGRheS5jb3VudCh5ZWFyKGQpLCBkKSwgcCwgMyk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRIb3VyMTIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRIb3VycygpICUgMTIgfHwgMTIsIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0SG91cjI0KGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0SG91cnMoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXREYXlPZk1vbnRoKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0RGF0ZSgpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdExvb2t1cChuYW1lcykge1xuICAgIHZhciBtYXAgPSBuZXcgTWFwLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIG1hcC5zZXQobmFtZXNbaV0udG9Mb3dlckNhc2UoKSwgaSk7XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIHZhciByZXF1b3RlUmUgPSAvW1xcXFxcXF5cXCRcXCpcXCtcXD9cXHxcXFtcXF1cXChcXClcXC5cXHtcXH1dL2c7XG5cbiAgZnVuY3Rpb24gcmVxdW90ZShzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZShyZXF1b3RlUmUsIFwiXFxcXCQmXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0UmUobmFtZXMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIG5hbWVzLm1hcChyZXF1b3RlKS5qb2luKFwifFwiKSArIFwiKVwiLCBcImlcIik7XG4gIH1cblxuICBmdW5jdGlvbiBsb2NhbGVGb3JtYXQobG9jYWxlKSB7XG4gICAgdmFyIGxvY2FsZV9kYXRlVGltZSA9IGxvY2FsZS5kYXRlVGltZSxcbiAgICAgICAgbG9jYWxlX2RhdGUgPSBsb2NhbGUuZGF0ZSxcbiAgICAgICAgbG9jYWxlX3RpbWUgPSBsb2NhbGUudGltZSxcbiAgICAgICAgbG9jYWxlX3BlcmlvZHMgPSBsb2NhbGUucGVyaW9kcyxcbiAgICAgICAgbG9jYWxlX3dlZWtkYXlzID0gbG9jYWxlLmRheXMsXG4gICAgICAgIGxvY2FsZV9zaG9ydFdlZWtkYXlzID0gbG9jYWxlLnNob3J0RGF5cyxcbiAgICAgICAgbG9jYWxlX21vbnRocyA9IGxvY2FsZS5tb250aHMsXG4gICAgICAgIGxvY2FsZV9zaG9ydE1vbnRocyA9IGxvY2FsZS5zaG9ydE1vbnRocztcblxuICAgIHZhciBwZXJpb2RMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3BlcmlvZHMpLFxuICAgICAgICB3ZWVrZGF5UmUgPSBmb3JtYXRSZShsb2NhbGVfd2Vla2RheXMpLFxuICAgICAgICB3ZWVrZGF5TG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV93ZWVrZGF5cyksXG4gICAgICAgIHNob3J0V2Vla2RheVJlID0gZm9ybWF0UmUobG9jYWxlX3Nob3J0V2Vla2RheXMpLFxuICAgICAgICBzaG9ydFdlZWtkYXlMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0V2Vla2RheXMpLFxuICAgICAgICBtb250aFJlID0gZm9ybWF0UmUobG9jYWxlX21vbnRocyksXG4gICAgICAgIG1vbnRoTG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9tb250aHMpLFxuICAgICAgICBzaG9ydE1vbnRoUmUgPSBmb3JtYXRSZShsb2NhbGVfc2hvcnRNb250aHMpLFxuICAgICAgICBzaG9ydE1vbnRoTG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9zaG9ydE1vbnRocyk7XG5cbiAgICB2YXIgZm9ybWF0cyA9IHtcbiAgICAgIFwiYVwiOiBmb3JtYXRTaG9ydFdlZWtkYXksXG4gICAgICBcIkFcIjogZm9ybWF0V2Vla2RheSxcbiAgICAgIFwiYlwiOiBmb3JtYXRTaG9ydE1vbnRoLFxuICAgICAgXCJCXCI6IGZvcm1hdE1vbnRoLFxuICAgICAgXCJjXCI6IG51bGwsXG4gICAgICBcImRcIjogZm9ybWF0RGF5T2ZNb250aCxcbiAgICAgIFwiZVwiOiBmb3JtYXREYXlPZk1vbnRoLFxuICAgICAgXCJIXCI6IGZvcm1hdEhvdXIyNCxcbiAgICAgIFwiSVwiOiBmb3JtYXRIb3VyMTIsXG4gICAgICBcImpcIjogZm9ybWF0RGF5T2ZZZWFyLFxuICAgICAgXCJMXCI6IGZvcm1hdE1pbGxpc2Vjb25kcyxcbiAgICAgIFwibVwiOiBmb3JtYXRNb250aE51bWJlcixcbiAgICAgIFwiTVwiOiBmb3JtYXRNaW51dGVzLFxuICAgICAgXCJwXCI6IGZvcm1hdFBlcmlvZCxcbiAgICAgIFwiU1wiOiBmb3JtYXRTZWNvbmRzLFxuICAgICAgXCJVXCI6IGZvcm1hdFdlZWtOdW1iZXJTdW5kYXksXG4gICAgICBcIndcIjogZm9ybWF0V2Vla2RheU51bWJlcixcbiAgICAgIFwiV1wiOiBmb3JtYXRXZWVrTnVtYmVyTW9uZGF5LFxuICAgICAgXCJ4XCI6IG51bGwsXG4gICAgICBcIlhcIjogbnVsbCxcbiAgICAgIFwieVwiOiBmb3JtYXRZZWFyLFxuICAgICAgXCJZXCI6IGZvcm1hdEZ1bGxZZWFyLFxuICAgICAgXCJaXCI6IGZvcm1hdFpvbmUsXG4gICAgICBcIiVcIjogZm9ybWF0TGl0ZXJhbFBlcmNlbnRcbiAgICB9O1xuXG4gICAgdmFyIHV0Y0Zvcm1hdHMgPSB7XG4gICAgICBcImFcIjogZm9ybWF0VVRDU2hvcnRXZWVrZGF5LFxuICAgICAgXCJBXCI6IGZvcm1hdFVUQ1dlZWtkYXksXG4gICAgICBcImJcIjogZm9ybWF0VVRDU2hvcnRNb250aCxcbiAgICAgIFwiQlwiOiBmb3JtYXRVVENNb250aCxcbiAgICAgIFwiY1wiOiBudWxsLFxuICAgICAgXCJkXCI6IGZvcm1hdFVUQ0RheU9mTW9udGgsXG4gICAgICBcImVcIjogZm9ybWF0VVRDRGF5T2ZNb250aCxcbiAgICAgIFwiSFwiOiBmb3JtYXRVVENIb3VyMjQsXG4gICAgICBcIklcIjogZm9ybWF0VVRDSG91cjEyLFxuICAgICAgXCJqXCI6IGZvcm1hdFVUQ0RheU9mWWVhcixcbiAgICAgIFwiTFwiOiBmb3JtYXRVVENNaWxsaXNlY29uZHMsXG4gICAgICBcIm1cIjogZm9ybWF0VVRDTW9udGhOdW1iZXIsXG4gICAgICBcIk1cIjogZm9ybWF0VVRDTWludXRlcyxcbiAgICAgIFwicFwiOiBmb3JtYXRVVENQZXJpb2QsXG4gICAgICBcIlNcIjogZm9ybWF0VVRDU2Vjb25kcyxcbiAgICAgIFwiVVwiOiBmb3JtYXRVVENXZWVrTnVtYmVyU3VuZGF5LFxuICAgICAgXCJ3XCI6IGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXIsXG4gICAgICBcIldcIjogZm9ybWF0VVRDV2Vla051bWJlck1vbmRheSxcbiAgICAgIFwieFwiOiBudWxsLFxuICAgICAgXCJYXCI6IG51bGwsXG4gICAgICBcInlcIjogZm9ybWF0VVRDWWVhcixcbiAgICAgIFwiWVwiOiBmb3JtYXRVVENGdWxsWWVhcixcbiAgICAgIFwiWlwiOiBmb3JtYXRVVENab25lLFxuICAgICAgXCIlXCI6IGZvcm1hdExpdGVyYWxQZXJjZW50XG4gICAgfTtcblxuICAgIHZhciBwYXJzZXMgPSB7XG4gICAgICBcImFcIjogcGFyc2VTaG9ydFdlZWtkYXksXG4gICAgICBcIkFcIjogcGFyc2VXZWVrZGF5LFxuICAgICAgXCJiXCI6IHBhcnNlU2hvcnRNb250aCxcbiAgICAgIFwiQlwiOiBwYXJzZU1vbnRoLFxuICAgICAgXCJjXCI6IHBhcnNlTG9jYWxlRGF0ZVRpbWUsXG4gICAgICBcImRcIjogcGFyc2VEYXlPZk1vbnRoLFxuICAgICAgXCJlXCI6IHBhcnNlRGF5T2ZNb250aCxcbiAgICAgIFwiSFwiOiBwYXJzZUhvdXIyNCxcbiAgICAgIFwiSVwiOiBwYXJzZUhvdXIyNCxcbiAgICAgIFwialwiOiBwYXJzZURheU9mWWVhcixcbiAgICAgIFwiTFwiOiBwYXJzZU1pbGxpc2Vjb25kcyxcbiAgICAgIFwibVwiOiBwYXJzZU1vbnRoTnVtYmVyLFxuICAgICAgXCJNXCI6IHBhcnNlTWludXRlcyxcbiAgICAgIFwicFwiOiBwYXJzZVBlcmlvZCxcbiAgICAgIFwiU1wiOiBwYXJzZVNlY29uZHMsXG4gICAgICBcIlVcIjogcGFyc2VXZWVrTnVtYmVyU3VuZGF5LFxuICAgICAgXCJ3XCI6IHBhcnNlV2Vla2RheU51bWJlcixcbiAgICAgIFwiV1wiOiBwYXJzZVdlZWtOdW1iZXJNb25kYXksXG4gICAgICBcInhcIjogcGFyc2VMb2NhbGVEYXRlLFxuICAgICAgXCJYXCI6IHBhcnNlTG9jYWxlVGltZSxcbiAgICAgIFwieVwiOiBwYXJzZVllYXIsXG4gICAgICBcIllcIjogcGFyc2VGdWxsWWVhcixcbiAgICAgIFwiWlwiOiBwYXJzZVpvbmUsXG4gICAgICBcIiVcIjogcGFyc2VMaXRlcmFsUGVyY2VudFxuICAgIH07XG5cbiAgICAvLyBUaGVzZSByZWN1cnNpdmUgZGlyZWN0aXZlIGRlZmluaXRpb25zIG11c3QgYmUgZGVmZXJyZWQuXG4gICAgZm9ybWF0cy54ID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlLCBmb3JtYXRzKTtcbiAgICBmb3JtYXRzLlggPSBuZXdGb3JtYXQobG9jYWxlX3RpbWUsIGZvcm1hdHMpO1xuICAgIGZvcm1hdHMuYyA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZVRpbWUsIGZvcm1hdHMpO1xuICAgIHV0Y0Zvcm1hdHMueCA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZSwgdXRjRm9ybWF0cyk7XG4gICAgdXRjRm9ybWF0cy5YID0gbmV3Rm9ybWF0KGxvY2FsZV90aW1lLCB1dGNGb3JtYXRzKTtcbiAgICB1dGNGb3JtYXRzLmMgPSBuZXdGb3JtYXQobG9jYWxlX2RhdGVUaW1lLCB1dGNGb3JtYXRzKTtcblxuICAgIGZ1bmN0aW9uIG5ld0Zvcm1hdChzcGVjaWZpZXIsIGZvcm1hdHMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSBbXSxcbiAgICAgICAgICAgIGkgPSAtMSxcbiAgICAgICAgICAgIGogPSAwLFxuICAgICAgICAgICAgbiA9IHNwZWNpZmllci5sZW5ndGgsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgcGFkLFxuICAgICAgICAgICAgZm9ybWF0O1xuXG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgaWYgKHNwZWNpZmllci5jaGFyQ29kZUF0KGkpID09PSAzNykge1xuICAgICAgICAgICAgc3RyaW5nLnB1c2goc3BlY2lmaWVyLnNsaWNlKGosIGkpKTtcbiAgICAgICAgICAgIGlmICgocGFkID0gcGFkc1tjID0gc3BlY2lmaWVyLmNoYXJBdCgrK2kpXSkgIT0gbnVsbCkgYyA9IHNwZWNpZmllci5jaGFyQXQoKytpKTtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPSBmb3JtYXRzW2NdKSBjID0gZm9ybWF0KGRhdGUsIHBhZCA9PSBudWxsID8gKGMgPT09IFwiZVwiID8gXCIgXCIgOiBcIjBcIikgOiBwYWQpO1xuICAgICAgICAgICAgc3RyaW5nLnB1c2goYyk7XG4gICAgICAgICAgICBqID0gaSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RyaW5nLnB1c2goc3BlY2lmaWVyLnNsaWNlKGosIGkpKTtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5qb2luKFwiXCIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZXdQYXJzZShzcGVjaWZpZXIsIG5ld0RhdGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgdmFyIGQgPSBuZXdZZWFyKDE5MDApLFxuICAgICAgICAgICAgaSA9IHBhcnNlU3BlY2lmaWVyKGQsIHNwZWNpZmllciwgc3RyaW5nLCAwKTtcbiAgICAgICAgaWYgKGkgIT0gc3RyaW5nLmxlbmd0aCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgLy8gVGhlIGFtLXBtIGZsYWcgaXMgMCBmb3IgQU0sIGFuZCAxIGZvciBQTS5cbiAgICAgICAgaWYgKFwicFwiIGluIGQpIGQuSCA9IGQuSCAlIDEyICsgZC5wICogMTI7XG5cbiAgICAgICAgLy8gSWYgYSB0aW1lIHpvbmUgaXMgc3BlY2lmaWVkLCBhbGwgZmllbGRzIGFyZSBpbnRlcnByZXRlZCBhcyBVVEMgYW5kIHRoZW5cbiAgICAgICAgLy8gb2Zmc2V0IGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIHRpbWUgem9uZS5cbiAgICAgICAgaWYgKFwiWlwiIGluIGQpIHtcbiAgICAgICAgICBpZiAoXCJ3XCIgaW4gZCAmJiAoXCJXXCIgaW4gZCB8fCBcIlVcIiBpbiBkKSkge1xuICAgICAgICAgICAgdmFyIGRheSA9IHV0Y0RhdGUobmV3WWVhcihkLnkpKS5nZXRVVENEYXkoKTtcbiAgICAgICAgICAgIGlmIChcIldcIiBpbiBkKSBkLlUgPSBkLlcsIGQudyA9IChkLncgKyA2KSAlIDcsIC0tZGF5O1xuICAgICAgICAgICAgZC5tID0gMDtcbiAgICAgICAgICAgIGQuZCA9IGQudyArIGQuVSAqIDcgLSAoZGF5ICsgNikgJSA3O1xuICAgICAgICAgIH1cbiAgICAgICAgICBkLkggKz0gZC5aIC8gMTAwIHwgMDtcbiAgICAgICAgICBkLk0gKz0gZC5aICUgMTAwO1xuICAgICAgICAgIHJldHVybiB1dGNEYXRlKGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBhbGwgZmllbGRzIGFyZSBpbiBsb2NhbCB0aW1lLlxuICAgICAgICBpZiAoXCJ3XCIgaW4gZCAmJiAoXCJXXCIgaW4gZCB8fCBcIlVcIiBpbiBkKSkge1xuICAgICAgICAgIHZhciBkYXkgPSBuZXdEYXRlKG5ld1llYXIoZC55KSkuZ2V0RGF5KCk7XG4gICAgICAgICAgaWYgKFwiV1wiIGluIGQpIGQuVSA9IGQuVywgZC53ID0gKGQudyArIDYpICUgNywgLS1kYXk7XG4gICAgICAgICAgZC5tID0gMDtcbiAgICAgICAgICBkLmQgPSBkLncgKyBkLlUgKiA3IC0gKGRheSArIDYpICUgNztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RGF0ZShkKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTcGVjaWZpZXIoZCwgc3BlY2lmaWVyLCBzdHJpbmcsIGopIHtcbiAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICBuID0gc3BlY2lmaWVyLmxlbmd0aCxcbiAgICAgICAgICBtID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICBjLFxuICAgICAgICAgIHBhcnNlO1xuXG4gICAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgICAgaWYgKGogPj0gbSkgcmV0dXJuIC0xO1xuICAgICAgICBjID0gc3BlY2lmaWVyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgaWYgKGMgPT09IDM3KSB7XG4gICAgICAgICAgYyA9IHNwZWNpZmllci5jaGFyQXQoaSsrKTtcbiAgICAgICAgICBwYXJzZSA9IHBhcnNlc1tjIGluIHBhZHMgPyBzcGVjaWZpZXIuY2hhckF0KGkrKykgOiBjXTtcbiAgICAgICAgICBpZiAoIXBhcnNlIHx8ICgoaiA9IHBhcnNlKGQsIHN0cmluZywgaikpIDwgMCkpIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChjICE9IHN0cmluZy5jaGFyQ29kZUF0KGorKykpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGo7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTaG9ydFdlZWtkYXkoZCwgc3RyaW5nLCBpKSB7XG4gICAgICB2YXIgbiA9IHNob3J0V2Vla2RheVJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGQudyA9IHNob3J0V2Vla2RheUxvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHZhciBuID0gd2Vla2RheVJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGQudyA9IHdlZWtkYXlMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVNob3J0TW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gICAgICB2YXIgbiA9IHNob3J0TW9udGhSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgICByZXR1cm4gbiA/IChkLm0gPSBzaG9ydE1vbnRoTG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNb250aChkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHZhciBuID0gbW9udGhSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgICByZXR1cm4gbiA/IChkLm0gPSBtb250aExvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTG9jYWxlRGF0ZVRpbWUoZCwgc3RyaW5nLCBpKSB7XG4gICAgICByZXR1cm4gcGFyc2VTcGVjaWZpZXIoZCwgbG9jYWxlX2RhdGVUaW1lLCBzdHJpbmcsIGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTG9jYWxlRGF0ZShkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfZGF0ZSwgc3RyaW5nLCBpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUxvY2FsZVRpbWUoZCwgc3RyaW5nLCBpKSB7XG4gICAgICByZXR1cm4gcGFyc2VTcGVjaWZpZXIoZCwgbG9jYWxlX3RpbWUsIHN0cmluZywgaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQZXJpb2QoZCwgc3RyaW5nLCBpKSB7XG4gICAgICB2YXIgbiA9IHBlcmlvZExvb2t1cC5nZXQoc3RyaW5nLnNsaWNlKGksIGkgKz0gMikudG9Mb3dlckNhc2UoKSk7XG4gICAgICByZXR1cm4gbiA9PSBudWxsID8gLTEgOiAoZC5wID0gbiwgaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0U2hvcnRXZWVrZGF5KGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfc2hvcnRXZWVrZGF5c1tkLmdldERheSgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRXZWVrZGF5KGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfd2Vla2RheXNbZC5nZXREYXkoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0U2hvcnRNb250aChkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3Nob3J0TW9udGhzW2QuZ2V0TW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0TW9udGgoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV9tb250aHNbZC5nZXRNb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRQZXJpb2QoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV9wZXJpb2RzWysoZC5nZXRIb3VycygpID49IDEyKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0VVRDU2hvcnRXZWVrZGF5KGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfc2hvcnRXZWVrZGF5c1tkLmdldFVUQ0RheSgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRVVENXZWVrZGF5KGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfd2Vla2RheXNbZC5nZXRVVENEYXkoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0VVRDU2hvcnRNb250aChkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3Nob3J0TW9udGhzW2QuZ2V0VVRDTW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0VVRDTW9udGgoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV9tb250aHNbZC5nZXRVVENNb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRVVENQZXJpb2QoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV9wZXJpb2RzWysoZC5nZXRVVENIb3VycygpID49IDEyKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICAgIHZhciBmID0gbmV3Rm9ybWF0KHNwZWNpZmllciArPSBcIlwiLCBmb3JtYXRzKTtcbiAgICAgICAgZi5wYXJzZSA9IG5ld1BhcnNlKHNwZWNpZmllciwgbG9jYWxEYXRlKTtcbiAgICAgICAgZi50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH0sXG4gICAgICB1dGNGb3JtYXQ6IGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgICB2YXIgZiA9IG5ld0Zvcm1hdChzcGVjaWZpZXIgKz0gXCJcIiwgdXRjRm9ybWF0cyk7XG4gICAgICAgIGYucGFyc2UgPSBuZXdQYXJzZShzcGVjaWZpZXIsIHV0Y0RhdGUpO1xuICAgICAgICBmLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgbG9jYWxlID0gbG9jYWxlRm9ybWF0KHtcbiAgICBkYXRlVGltZTogXCIlYSAlYiAlZSAlWCAlWVwiLFxuICAgIGRhdGU6IFwiJW0vJWQvJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgICBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcbiAgICBzaG9ydERheXM6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcbiAgICBtb250aHM6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl1cbiAgfSk7XG5cbiAgZXhwb3J0cy5mb3JtYXQgPSBsb2NhbGUuZm9ybWF0O1xuICBleHBvcnRzLnV0Y0Zvcm1hdCA9IGxvY2FsZS51dGNGb3JtYXQ7XG5cbiAgdmFyIGlzb1NwZWNpZmllciA9IFwiJVktJW0tJWRUJUg6JU06JVMuJUxaXCI7XG5cbiAgZnVuY3Rpb24gZm9ybWF0SXNvTmF0aXZlKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpO1xuICB9XG5cbiAgZm9ybWF0SXNvTmF0aXZlLnBhcnNlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShzdHJpbmcpO1xuICAgIHJldHVybiBpc05hTihkYXRlKSA/IG51bGwgOiBkYXRlO1xuICB9O1xuXG4gIGZvcm1hdElzb05hdGl2ZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc29TcGVjaWZpZXI7XG4gIH07XG5cbiAgdmFyIGZvcm1hdElzbyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nICYmICtuZXcgRGF0ZShcIjIwMDAtMDEtMDFUMDA6MDA6MDAuMDAwWlwiKVxuICAgICAgPyBmb3JtYXRJc29OYXRpdmVcbiAgICAgIDogbG9jYWxlLnV0Y0Zvcm1hdChpc29TcGVjaWZpZXIpO1xuXG4gIHZhciBpc29Gb3JtYXQgPSBmb3JtYXRJc287XG5cbiAgZXhwb3J0cy5pc29Gb3JtYXQgPSBpc29Gb3JtYXQ7XG4gIGV4cG9ydHMubG9jYWxlRm9ybWF0ID0gbG9jYWxlRm9ybWF0O1xuXG59KSk7IiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICBmYWN0b3J5KChnbG9iYWwudGltZSA9IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgdDEgPSBuZXcgRGF0ZTtcblxuICB2YXIgdDAgPSBuZXcgRGF0ZTtcblxuICBmdW5jdGlvbiBuZXdJbnRlcnZhbChmbG9vcmksIG9mZnNldGksIGNvdW50KSB7XG5cbiAgICBmdW5jdGlvbiBpbnRlcnZhbChkYXRlKSB7XG4gICAgICByZXR1cm4gZmxvb3JpKGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSkpLCBkYXRlO1xuICAgIH1cblxuICAgIGludGVydmFsLmZsb29yID0gaW50ZXJ2YWw7XG5cbiAgICBpbnRlcnZhbC5yb3VuZCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHZhciBkMCA9IG5ldyBEYXRlKCtkYXRlKSxcbiAgICAgICAgICBkMSA9IG5ldyBEYXRlKGRhdGUgLSAxKTtcbiAgICAgIGZsb29yaShkMCksIGZsb29yaShkMSksIG9mZnNldGkoZDEsIDEpO1xuICAgICAgcmV0dXJuIGRhdGUgLSBkMCA8IGQxIC0gZGF0ZSA/IGQwIDogZDE7XG4gICAgfTtcblxuICAgIGludGVydmFsLmNlaWwgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgICByZXR1cm4gZmxvb3JpKGRhdGUgPSBuZXcgRGF0ZShkYXRlIC0gMSkpLCBvZmZzZXRpKGRhdGUsIDEpLCBkYXRlO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5vZmZzZXQgPSBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICByZXR1cm4gb2Zmc2V0aShkYXRlID0gbmV3IERhdGUoK2RhdGUpLCBzdGVwID09IG51bGwgPyAxIDogTWF0aC5mbG9vcihzdGVwKSksIGRhdGU7XG4gICAgfTtcblxuICAgIGludGVydmFsLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICAgIHZhciByYW5nZSA9IFtdO1xuICAgICAgc3RhcnQgPSBuZXcgRGF0ZShzdGFydCAtIDEpO1xuICAgICAgc3RvcCA9IG5ldyBEYXRlKCtzdG9wKTtcbiAgICAgIHN0ZXAgPSBzdGVwID09IG51bGwgPyAxIDogTWF0aC5mbG9vcihzdGVwKTtcbiAgICAgIGlmICghKHN0YXJ0IDwgc3RvcCkgfHwgIShzdGVwID4gMCkpIHJldHVybiByYW5nZTsgLy8gYWxzbyBoYW5kbGVzIEludmFsaWQgRGF0ZVxuICAgICAgb2Zmc2V0aShzdGFydCwgMSksIGZsb29yaShzdGFydCk7XG4gICAgICBpZiAoc3RhcnQgPCBzdG9wKSByYW5nZS5wdXNoKG5ldyBEYXRlKCtzdGFydCkpO1xuICAgICAgd2hpbGUgKG9mZnNldGkoc3RhcnQsIHN0ZXApLCBmbG9vcmkoc3RhcnQpLCBzdGFydCA8IHN0b3ApIHJhbmdlLnB1c2gobmV3IERhdGUoK3N0YXJ0KSk7XG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfTtcblxuICAgIGludGVydmFsLmZpbHRlciA9IGZ1bmN0aW9uKHRlc3QpIHtcbiAgICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHdoaWxlIChmbG9vcmkoZGF0ZSksICF0ZXN0KGRhdGUpKSBkYXRlLnNldFRpbWUoZGF0ZSAtIDEpO1xuICAgICAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgICAgICB3aGlsZSAoLS1zdGVwID49IDApIHdoaWxlIChvZmZzZXRpKGRhdGUsIDEpLCAhdGVzdChkYXRlKSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKGNvdW50KSBpbnRlcnZhbC5jb3VudCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHQwLnNldFRpbWUoK3N0YXJ0KSwgdDEuc2V0VGltZSgrZW5kKTtcbiAgICAgIGZsb29yaSh0MCksIGZsb29yaSh0MSk7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihjb3VudCh0MCwgdDEpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGludGVydmFsO1xuICB9XG5cbiAgdmFyIHNlY29uZCA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldE1pbGxpc2Vjb25kcygwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiAxZTMpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyAxZTM7XG4gIH0pO1xuXG4gIGV4cG9ydHMuc2Vjb25kcyA9IHNlY29uZC5yYW5nZTtcblxuICB2YXIgbWludXRlID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0U2Vjb25kcygwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiA2ZTQpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyA2ZTQ7XG4gIH0pO1xuXG4gIGV4cG9ydHMubWludXRlcyA9IG1pbnV0ZS5yYW5nZTtcblxuICB2YXIgaG91ciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldE1pbnV0ZXMoMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogMzZlNSk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIDM2ZTU7XG4gIH0pO1xuXG4gIGV4cG9ydHMuaG91cnMgPSBob3VyLnJhbmdlO1xuXG4gIHZhciBkYXkgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCAtIChlbmQuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogNmU0KSAvIDg2NGU1O1xuICB9KTtcblxuICBleHBvcnRzLmRheXMgPSBkYXkucmFuZ2U7XG5cbiAgZnVuY3Rpb24gd2Vla2RheShpKSB7XG4gICAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSAoZGF0ZS5nZXREYXkoKSArIDcgLSBpKSAlIDcpO1xuICAgIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0ZXAgKiA3KTtcbiAgICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gKGVuZCAtIHN0YXJ0IC0gKGVuZC5nZXRUaW1lem9uZU9mZnNldCgpIC0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiA2ZTQpIC8gNjA0OGU1O1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5zdW5kYXkgPSB3ZWVrZGF5KDApO1xuXG4gIGV4cG9ydHMuc3VuZGF5cyA9IGV4cG9ydHMuc3VuZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMubW9uZGF5ID0gd2Vla2RheSgxKTtcblxuICBleHBvcnRzLm1vbmRheXMgPSBleHBvcnRzLm1vbmRheS5yYW5nZTtcblxuICBleHBvcnRzLnR1ZXNkYXkgPSB3ZWVrZGF5KDIpO1xuXG4gIGV4cG9ydHMudHVlc2RheXMgPSBleHBvcnRzLnR1ZXNkYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy53ZWRuZXNkYXkgPSB3ZWVrZGF5KDMpO1xuXG4gIGV4cG9ydHMud2VkbmVzZGF5cyA9IGV4cG9ydHMud2VkbmVzZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMudGh1cnNkYXkgPSB3ZWVrZGF5KDQpO1xuXG4gIGV4cG9ydHMudGh1cnNkYXlzID0gZXhwb3J0cy50aHVyc2RheS5yYW5nZTtcblxuICBleHBvcnRzLmZyaWRheSA9IHdlZWtkYXkoNSk7XG5cbiAgZXhwb3J0cy5mcmlkYXlzID0gZXhwb3J0cy5mcmlkYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy5zYXR1cmRheSA9IHdlZWtkYXkoNik7XG5cbiAgZXhwb3J0cy5zYXR1cmRheXMgPSBleHBvcnRzLnNhdHVyZGF5LnJhbmdlO1xuXG4gIHZhciB3ZWVrID0gZXhwb3J0cy5zdW5kYXk7XG5cbiAgZXhwb3J0cy53ZWVrcyA9IHdlZWsucmFuZ2U7XG5cbiAgdmFyIG1vbnRoID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgZGF0ZS5zZXREYXRlKDEpO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRNb250aChkYXRlLmdldE1vbnRoKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBlbmQuZ2V0TW9udGgoKSAtIHN0YXJ0LmdldE1vbnRoKCkgKyAoZW5kLmdldEZ1bGxZZWFyKCkgLSBzdGFydC5nZXRGdWxsWWVhcigpKSAqIDEyO1xuICB9KTtcblxuICBleHBvcnRzLm1vbnRocyA9IG1vbnRoLnJhbmdlO1xuXG4gIHZhciB5ZWFyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgZGF0ZS5zZXRNb250aCgwLCAxKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpICsgc3RlcCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZW5kLmdldEZ1bGxZZWFyKCkgLSBzdGFydC5nZXRGdWxsWWVhcigpO1xuICB9KTtcblxuICBleHBvcnRzLnllYXJzID0geWVhci5yYW5nZTtcblxuICB2YXIgdXRjU2Vjb25kID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDTWlsbGlzZWNvbmRzKDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIDFlMyk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIDFlMztcbiAgfSk7XG5cbiAgZXhwb3J0cy51dGNTZWNvbmRzID0gdXRjU2Vjb25kLnJhbmdlO1xuXG4gIHZhciB1dGNNaW51dGUgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENTZWNvbmRzKDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIDZlNCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIDZlNDtcbiAgfSk7XG5cbiAgZXhwb3J0cy51dGNNaW51dGVzID0gdXRjTWludXRlLnJhbmdlO1xuXG4gIHZhciB1dGNIb3VyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDTWludXRlcygwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiAzNmU1KTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gMzZlNTtcbiAgfSk7XG5cbiAgZXhwb3J0cy51dGNIb3VycyA9IHV0Y0hvdXIucmFuZ2U7XG5cbiAgdmFyIHV0Y0RheSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgc3RlcCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIDg2NGU1O1xuICB9KTtcblxuICBleHBvcnRzLnV0Y0RheXMgPSB1dGNEYXkucmFuZ2U7XG5cbiAgZnVuY3Rpb24gdXRjV2Vla2RheShpKSB7XG4gICAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSAoZGF0ZS5nZXRVVENEYXkoKSArIDcgLSBpKSAlIDcpO1xuICAgIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIHN0ZXAgKiA3KTtcbiAgICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIDYwNDhlNTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMudXRjU3VuZGF5ID0gdXRjV2Vla2RheSgwKTtcblxuICBleHBvcnRzLnV0Y1N1bmRheXMgPSBleHBvcnRzLnV0Y1N1bmRheS5yYW5nZTtcblxuICBleHBvcnRzLnV0Y01vbmRheSA9IHV0Y1dlZWtkYXkoMSk7XG5cbiAgZXhwb3J0cy51dGNNb25kYXlzID0gZXhwb3J0cy51dGNNb25kYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy51dGNUdWVzZGF5ID0gdXRjV2Vla2RheSgyKTtcblxuICBleHBvcnRzLnV0Y1R1ZXNkYXlzID0gZXhwb3J0cy51dGNUdWVzZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMudXRjV2VkbmVzZGF5ID0gdXRjV2Vla2RheSgzKTtcblxuICBleHBvcnRzLnV0Y1dlZG5lc2RheXMgPSBleHBvcnRzLnV0Y1dlZG5lc2RheS5yYW5nZTtcblxuICBleHBvcnRzLnV0Y1RodXJzZGF5ID0gdXRjV2Vla2RheSg0KTtcblxuICBleHBvcnRzLnV0Y1RodXJzZGF5cyA9IGV4cG9ydHMudXRjVGh1cnNkYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy51dGNGcmlkYXkgPSB1dGNXZWVrZGF5KDUpO1xuXG4gIGV4cG9ydHMudXRjRnJpZGF5cyA9IGV4cG9ydHMudXRjRnJpZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMudXRjU2F0dXJkYXkgPSB1dGNXZWVrZGF5KDYpO1xuXG4gIGV4cG9ydHMudXRjU2F0dXJkYXlzID0gZXhwb3J0cy51dGNTYXR1cmRheS5yYW5nZTtcblxuICB2YXIgdXRjV2VlayA9IGV4cG9ydHMudXRjU3VuZGF5O1xuXG4gIGV4cG9ydHMudXRjV2Vla3MgPSB1dGNXZWVrLnJhbmdlO1xuXG4gIHZhciB1dGNNb250aCA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgIGRhdGUuc2V0VVRDRGF0ZSgxKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VVRDTW9udGgoZGF0ZS5nZXRVVENNb250aCgpICsgc3RlcCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZW5kLmdldFVUQ01vbnRoKCkgLSBzdGFydC5nZXRVVENNb250aCgpICsgKGVuZC5nZXRVVENGdWxsWWVhcigpIC0gc3RhcnQuZ2V0VVRDRnVsbFllYXIoKSkgKiAxMjtcbiAgfSk7XG5cbiAgZXhwb3J0cy51dGNNb250aHMgPSB1dGNNb250aC5yYW5nZTtcblxuICB2YXIgdXRjWWVhciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgIGRhdGUuc2V0VVRDTW9udGgoMCwgMSk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGVuZC5nZXRVVENGdWxsWWVhcigpIC0gc3RhcnQuZ2V0VVRDRnVsbFllYXIoKTtcbiAgfSk7XG5cbiAgZXhwb3J0cy51dGNZZWFycyA9IHV0Y1llYXIucmFuZ2U7XG5cbiAgZXhwb3J0cy5pbnRlcnZhbCA9IG5ld0ludGVydmFsO1xuICBleHBvcnRzLnNlY29uZCA9IHNlY29uZDtcbiAgZXhwb3J0cy5taW51dGUgPSBtaW51dGU7XG4gIGV4cG9ydHMuaG91ciA9IGhvdXI7XG4gIGV4cG9ydHMuZGF5ID0gZGF5O1xuICBleHBvcnRzLndlZWsgPSB3ZWVrO1xuICBleHBvcnRzLm1vbnRoID0gbW9udGg7XG4gIGV4cG9ydHMueWVhciA9IHllYXI7XG4gIGV4cG9ydHMudXRjU2Vjb25kID0gdXRjU2Vjb25kO1xuICBleHBvcnRzLnV0Y01pbnV0ZSA9IHV0Y01pbnV0ZTtcbiAgZXhwb3J0cy51dGNIb3VyID0gdXRjSG91cjtcbiAgZXhwb3J0cy51dGNEYXkgPSB1dGNEYXk7XG4gIGV4cG9ydHMudXRjV2VlayA9IHV0Y1dlZWs7XG4gIGV4cG9ydHMudXRjTW9udGggPSB1dGNNb250aDtcbiAgZXhwb3J0cy51dGNZZWFyID0gdXRjWWVhcjtcblxufSkpOyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICAgIHRpbWUgPSByZXF1aXJlKCcuLi90aW1lJyksXG4gICAgRVBTSUxPTiA9IDFlLTE1O1xuXG5mdW5jdGlvbiBiaW5zKG9wdCkge1xuICBpZiAoIW9wdCkgeyB0aHJvdyBFcnJvcihcIk1pc3NpbmcgYmlubmluZyBvcHRpb25zLlwiKTsgfVxuXG4gIC8vIGRldGVybWluZSByYW5nZVxuICB2YXIgbWF4YiA9IG9wdC5tYXhiaW5zIHx8IDE1LFxuICAgICAgYmFzZSA9IG9wdC5iYXNlIHx8IDEwLFxuICAgICAgbG9nYiA9IE1hdGgubG9nKGJhc2UpLFxuICAgICAgZGl2ID0gb3B0LmRpdiB8fCBbNSwgMl0sICAgICAgXG4gICAgICBtaW4gPSBvcHQubWluLFxuICAgICAgbWF4ID0gb3B0Lm1heCxcbiAgICAgIHNwYW4gPSBtYXggLSBtaW4sXG4gICAgICBzdGVwLCBsZXZlbCwgbWluc3RlcCwgcHJlY2lzaW9uLCB2LCBpLCBlcHM7XG5cbiAgaWYgKG9wdC5zdGVwKSB7XG4gICAgLy8gaWYgc3RlcCBzaXplIGlzIGV4cGxpY2l0bHkgZ2l2ZW4sIHVzZSB0aGF0XG4gICAgc3RlcCA9IG9wdC5zdGVwO1xuICB9IGVsc2UgaWYgKG9wdC5zdGVwcykge1xuICAgIC8vIGlmIHByb3ZpZGVkLCBsaW1pdCBjaG9pY2UgdG8gYWNjZXB0YWJsZSBzdGVwIHNpemVzXG4gICAgc3RlcCA9IG9wdC5zdGVwc1tNYXRoLm1pbihcbiAgICAgIG9wdC5zdGVwcy5sZW5ndGggLSAxLFxuICAgICAgYmlzZWN0KG9wdC5zdGVwcywgc3Bhbi9tYXhiLCAwLCBvcHQuc3RlcHMubGVuZ3RoKVxuICAgICldO1xuICB9IGVsc2Uge1xuICAgIC8vIGVsc2UgdXNlIHNwYW4gdG8gZGV0ZXJtaW5lIHN0ZXAgc2l6ZVxuICAgIGxldmVsID0gTWF0aC5jZWlsKE1hdGgubG9nKG1heGIpIC8gbG9nYik7XG4gICAgbWluc3RlcCA9IG9wdC5taW5zdGVwIHx8IDA7XG4gICAgc3RlcCA9IE1hdGgubWF4KFxuICAgICAgbWluc3RlcCxcbiAgICAgIE1hdGgucG93KGJhc2UsIE1hdGgucm91bmQoTWF0aC5sb2coc3BhbikgLyBsb2diKSAtIGxldmVsKVxuICAgICk7XG4gICAgXG4gICAgLy8gaW5jcmVhc2Ugc3RlcCBzaXplIGlmIHRvbyBtYW55IGJpbnNcbiAgICBkbyB7IHN0ZXAgKj0gYmFzZTsgfSB3aGlsZSAoTWF0aC5jZWlsKHNwYW4vc3RlcCkgPiBtYXhiKTtcblxuICAgIC8vIGRlY3JlYXNlIHN0ZXAgc2l6ZSBpZiBhbGxvd2VkXG4gICAgZm9yIChpPTA7IGk8ZGl2Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2ID0gc3RlcCAvIGRpdltpXTtcbiAgICAgIGlmICh2ID49IG1pbnN0ZXAgJiYgc3BhbiAvIHYgPD0gbWF4Yikgc3RlcCA9IHY7XG4gICAgfVxuICB9XG5cbiAgLy8gdXBkYXRlIHByZWNpc2lvbiwgbWluIGFuZCBtYXhcbiAgdiA9IE1hdGgubG9nKHN0ZXApO1xuICBwcmVjaXNpb24gPSB2ID49IDAgPyAwIDogfn4oLXYgLyBsb2diKSArIDE7XG4gIGVwcyA9IE1hdGgucG93KGJhc2UsIC1wcmVjaXNpb24gLSAxKTtcbiAgbWluID0gTWF0aC5taW4obWluLCBNYXRoLmZsb29yKG1pbiAvIHN0ZXAgKyBlcHMpICogc3RlcCk7XG4gIG1heCA9IE1hdGguY2VpbChtYXggLyBzdGVwKSAqIHN0ZXA7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogbWluLFxuICAgIHN0b3A6ICBtYXgsXG4gICAgc3RlcDogIHN0ZXAsXG4gICAgdW5pdDogIHtwcmVjaXNpb246IHByZWNpc2lvbn0sXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGluZGV4OiBpbmRleFxuICB9O1xufVxuXG5mdW5jdGlvbiBiaXNlY3QoYSwgeCwgbG8sIGhpKSB7XG4gIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgaWYgKHV0aWwuY21wKGFbbWlkXSwgeCkgPCAwKSB7IGxvID0gbWlkICsgMTsgfVxuICAgIGVsc2UgeyBoaSA9IG1pZDsgfVxuICB9XG4gIHJldHVybiBsbztcbn1cblxuZnVuY3Rpb24gdmFsdWUodikge1xuICByZXR1cm4gdGhpcy5zdGVwICogTWF0aC5mbG9vcih2IC8gdGhpcy5zdGVwICsgRVBTSUxPTik7XG59XG5cbmZ1bmN0aW9uIGluZGV4KHYpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoKHYgLSB0aGlzLnN0YXJ0KSAvIHRoaXMuc3RlcCArIEVQU0lMT04pO1xufVxuXG5mdW5jdGlvbiBkYXRlX3ZhbHVlKHYpIHtcbiAgcmV0dXJuIHRoaXMudW5pdC5kYXRlKHZhbHVlLmNhbGwodGhpcywgdikpO1xufVxuXG5mdW5jdGlvbiBkYXRlX2luZGV4KHYpIHtcbiAgcmV0dXJuIGluZGV4LmNhbGwodGhpcywgdGhpcy51bml0LnVuaXQodikpO1xufVxuXG5iaW5zLmRhdGUgPSBmdW5jdGlvbihvcHQpIHtcbiAgaWYgKCFvcHQpIHsgdGhyb3cgRXJyb3IoXCJNaXNzaW5nIGRhdGUgYmlubmluZyBvcHRpb25zLlwiKTsgfVxuXG4gIC8vIGZpbmQgdGltZSBzdGVwLCB0aGVuIGJpblxuICB2YXIgdW5pdHMgPSBvcHQudXRjID8gdGltZS51dGMgOiB0aW1lLFxuICAgICAgZG1pbiA9IG9wdC5taW4sXG4gICAgICBkbWF4ID0gb3B0Lm1heCxcbiAgICAgIG1heGIgPSBvcHQubWF4YmlucyB8fCAyMCxcbiAgICAgIG1pbmIgPSBvcHQubWluYmlucyB8fCA0LFxuICAgICAgc3BhbiA9ICgrZG1heCkgLSAoK2RtaW4pLFxuICAgICAgdW5pdCA9IG9wdC51bml0ID8gdW5pdHNbb3B0LnVuaXRdIDogdW5pdHMuZmluZChzcGFuLCBtaW5iLCBtYXhiKSxcbiAgICAgIHNwZWMgPSBiaW5zKHtcbiAgICAgICAgbWluOiAgICAgdW5pdC5taW4gIT0gbnVsbCA/IHVuaXQubWluIDogdW5pdC51bml0KGRtaW4pLFxuICAgICAgICBtYXg6ICAgICB1bml0Lm1heCAhPSBudWxsID8gdW5pdC5tYXggOiB1bml0LnVuaXQoZG1heCksXG4gICAgICAgIG1heGJpbnM6IG1heGIsXG4gICAgICAgIG1pbnN0ZXA6IHVuaXQubWluc3RlcCxcbiAgICAgICAgc3RlcHM6ICAgdW5pdC5zdGVwXG4gICAgICB9KTtcblxuICBzcGVjLnVuaXQgPSB1bml0O1xuICBzcGVjLmluZGV4ID0gZGF0ZV9pbmRleDtcbiAgaWYgKCFvcHQucmF3KSBzcGVjLnZhbHVlID0gZGF0ZV92YWx1ZTtcbiAgcmV0dXJuIHNwZWM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbnM7XG4iLCJ2YXIgZ2VuID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuZ2VuLnJlcGVhdCA9IGZ1bmN0aW9uKHZhbCwgbikge1xuICB2YXIgYSA9IEFycmF5KG4pLCBpO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIGFbaV0gPSB2YWw7XG4gIHJldHVybiBhO1xufTtcblxuZ2VuLnplcm9zID0gZnVuY3Rpb24obikge1xuICByZXR1cm4gZ2VuLnJlcGVhdCgwLCBuKTtcbn07XG5cbmdlbi5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgIHN0ZXAgPSAxO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgc3RvcCA9IHN0YXJ0O1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgfVxuICBpZiAoKHN0b3AgLSBzdGFydCkgLyBzdGVwID09IEluZmluaXR5KSB0aHJvdyBuZXcgRXJyb3IoJ0luZmluaXRlIHJhbmdlJyk7XG4gIHZhciByYW5nZSA9IFtdLCBpID0gLTEsIGo7XG4gIGlmIChzdGVwIDwgMCkgd2hpbGUgKChqID0gc3RhcnQgKyBzdGVwICogKytpKSA+IHN0b3ApIHJhbmdlLnB1c2goaik7XG4gIGVsc2Ugd2hpbGUgKChqID0gc3RhcnQgKyBzdGVwICogKytpKSA8IHN0b3ApIHJhbmdlLnB1c2goaik7XG4gIHJldHVybiByYW5nZTtcbn07XG5cbmdlbi5yYW5kb20gPSB7fTtcblxuZ2VuLnJhbmRvbS51bmlmb3JtID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWF4ID0gbWluID09PSB1bmRlZmluZWQgPyAxIDogbWluO1xuICAgIG1pbiA9IDA7XG4gIH1cbiAgdmFyIGQgPSBtYXggLSBtaW47XG4gIHZhciBmID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG1pbiArIGQgKiBNYXRoLnJhbmRvbSgpO1xuICB9O1xuICBmLnNhbXBsZXMgPSBmdW5jdGlvbihuKSB7IHJldHVybiBnZW4uemVyb3MobikubWFwKGYpOyB9O1xuICByZXR1cm4gZjtcbn07XG5cbmdlbi5yYW5kb20uaW50ZWdlciA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgIGIgPSBhO1xuICAgIGEgPSAwO1xuICB9XG4gIHZhciBkID0gYiAtIGE7XG4gIHZhciBmID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGEgKyBNYXRoLmZsb29yKGQgKiBNYXRoLnJhbmRvbSgpKTtcbiAgfTtcbiAgZi5zYW1wbGVzID0gZnVuY3Rpb24obikgeyByZXR1cm4gZ2VuLnplcm9zKG4pLm1hcChmKTsgfTtcbiAgcmV0dXJuIGY7XG59O1xuXG5nZW4ucmFuZG9tLm5vcm1hbCA9IGZ1bmN0aW9uKG1lYW4sIHN0ZGV2KSB7XG4gIG1lYW4gPSBtZWFuIHx8IDA7XG4gIHN0ZGV2ID0gc3RkZXYgfHwgMTtcbiAgdmFyIG5leHQ7XG4gIHZhciBmID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHggPSAwLCB5ID0gMCwgcmRzLCBjO1xuICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHggPSBuZXh0O1xuICAgICAgbmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBkbyB7XG4gICAgICB4ID0gTWF0aC5yYW5kb20oKSoyLTE7XG4gICAgICB5ID0gTWF0aC5yYW5kb20oKSoyLTE7XG4gICAgICByZHMgPSB4KnggKyB5Knk7XG4gICAgfSB3aGlsZSAocmRzID09PSAwIHx8IHJkcyA+IDEpO1xuICAgIGMgPSBNYXRoLnNxcnQoLTIqTWF0aC5sb2cocmRzKS9yZHMpOyAvLyBCb3gtTXVsbGVyIHRyYW5zZm9ybVxuICAgIG5leHQgPSBtZWFuICsgeSpjKnN0ZGV2O1xuICAgIHJldHVybiBtZWFuICsgeCpjKnN0ZGV2O1xuICB9O1xuICBmLnNhbXBsZXMgPSBmdW5jdGlvbihuKSB7IHJldHVybiBnZW4uemVyb3MobikubWFwKGYpOyB9O1xuICByZXR1cm4gZjtcbn07IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbnZhciBUWVBFUyA9ICdfX3R5cGVzX18nO1xuXG52YXIgUEFSU0VSUyA9IHtcbiAgYm9vbGVhbjogdXRpbC5ib29sZWFuLFxuICBpbnRlZ2VyOiB1dGlsLm51bWJlcixcbiAgbnVtYmVyOiAgdXRpbC5udW1iZXIsXG4gIGRhdGU6ICAgIHV0aWwuZGF0ZSxcbiAgc3RyaW5nOiAgZnVuY3Rpb24oeCkgeyByZXR1cm4geD09PScnID8gbnVsbCA6IHg7IH1cbn07XG5cbnZhciBURVNUUyA9IHtcbiAgYm9vbGVhbjogZnVuY3Rpb24oeCkgeyByZXR1cm4geD09PSd0cnVlJyB8fCB4PT09J2ZhbHNlJyB8fCB1dGlsLmlzQm9vbGVhbih4KTsgfSxcbiAgaW50ZWdlcjogZnVuY3Rpb24oeCkgeyByZXR1cm4gVEVTVFMubnVtYmVyKHgpICYmICh4PSt4KSA9PT0gfn54OyB9LFxuICBudW1iZXI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuICFpc05hTigreCkgJiYgIXV0aWwuaXNEYXRlKHgpOyB9LFxuICBkYXRlOiBmdW5jdGlvbih4KSB7IHJldHVybiAhaXNOYU4oRGF0ZS5wYXJzZSh4KSk7IH1cbn07XG5cbmZ1bmN0aW9uIGFubm90YXRpb24oZGF0YSwgdHlwZXMpIHtcbiAgaWYgKCF0eXBlcykgcmV0dXJuIGRhdGEgJiYgZGF0YVtUWVBFU10gfHwgbnVsbDtcbiAgZGF0YVtUWVBFU10gPSB0eXBlcztcbn1cblxuZnVuY3Rpb24gdHlwZSh2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIHYsIGksIG47XG5cbiAgLy8gaWYgZGF0YSBhcnJheSBoYXMgdHlwZSBhbm5vdGF0aW9ucywgdXNlIHRoZW1cbiAgaWYgKHZhbHVlc1tUWVBFU10pIHtcbiAgICB2ID0gZih2YWx1ZXNbVFlQRVNdKTtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2KSkgcmV0dXJuIHY7XG4gIH1cblxuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyAhdXRpbC5pc1ZhbGlkKHYpICYmIGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gIH1cblxuICByZXR1cm4gdXRpbC5pc0RhdGUodikgPyAnZGF0ZScgOlxuICAgIHV0aWwuaXNOdW1iZXIodikgICAgPyAnbnVtYmVyJyA6XG4gICAgdXRpbC5pc0Jvb2xlYW4odikgICA/ICdib29sZWFuJyA6XG4gICAgdXRpbC5pc1N0cmluZyh2KSAgICA/ICdzdHJpbmcnIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gdHlwZUFsbChkYXRhLCBmaWVsZHMpIHtcbiAgaWYgKCFkYXRhLmxlbmd0aCkgcmV0dXJuO1xuICBmaWVsZHMgPSBmaWVsZHMgfHwgdXRpbC5rZXlzKGRhdGFbMF0pO1xuICByZXR1cm4gZmllbGRzLnJlZHVjZShmdW5jdGlvbih0eXBlcywgZikge1xuICAgIHJldHVybiAodHlwZXNbZl0gPSB0eXBlKGRhdGEsIGYpLCB0eXBlcyk7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gaW5mZXIodmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBpLCBqLCB2O1xuXG4gIC8vIHR5cGVzIHRvIHRlc3QgZm9yLCBpbiBwcmVjZWRlbmNlIG9yZGVyXG4gIHZhciB0eXBlcyA9IFsnYm9vbGVhbicsICdpbnRlZ2VyJywgJ251bWJlcicsICdkYXRlJ107XG5cbiAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gZ2V0IG5leHQgdmFsdWUgdG8gdGVzdFxuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIC8vIHRlc3QgdmFsdWUgYWdhaW5zdCByZW1haW5pbmcgdHlwZXNcbiAgICBmb3IgKGo9MDsgajx0eXBlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKHV0aWwuaXNWYWxpZCh2KSAmJiAhVEVTVFNbdHlwZXNbal1dKHYpKSB7XG4gICAgICAgIHR5cGVzLnNwbGljZShqLCAxKTtcbiAgICAgICAgaiAtPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBubyB0eXBlcyBsZWZ0LCByZXR1cm4gJ3N0cmluZydcbiAgICBpZiAodHlwZXMubGVuZ3RoID09PSAwKSByZXR1cm4gJ3N0cmluZyc7XG4gIH1cblxuICByZXR1cm4gdHlwZXNbMF07XG59XG5cbmZ1bmN0aW9uIGluZmVyQWxsKGRhdGEsIGZpZWxkcykge1xuICBmaWVsZHMgPSBmaWVsZHMgfHwgdXRpbC5rZXlzKGRhdGFbMF0pO1xuICByZXR1cm4gZmllbGRzLnJlZHVjZShmdW5jdGlvbih0eXBlcywgZikge1xuICAgIHR5cGVzW2ZdID0gaW5mZXIoZGF0YSwgZik7XG4gICAgcmV0dXJuIHR5cGVzO1xuICB9LCB7fSk7XG59XG5cbnR5cGUuYW5ub3RhdGlvbiA9IGFubm90YXRpb247XG50eXBlLmFsbCA9IHR5cGVBbGw7XG50eXBlLmluZmVyID0gaW5mZXI7XG50eXBlLmluZmVyQWxsID0gaW5mZXJBbGw7XG50eXBlLnBhcnNlcnMgPSBQQVJTRVJTO1xubW9kdWxlLmV4cG9ydHMgPSB0eXBlOyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJy4vaW1wb3J0L3R5cGUnKTtcbnZhciBnZW4gPSByZXF1aXJlKCcuL2dlbmVyYXRlJyk7XG52YXIgc3RhdHMgPSB7fTtcblxuLy8gQ29sbGVjdCB1bmlxdWUgdmFsdWVzLlxuLy8gT3V0cHV0OiBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBmaXJzdC1vYnNlcnZlZCBvcmRlclxuc3RhdHMudW5pcXVlID0gZnVuY3Rpb24odmFsdWVzLCBmLCByZXN1bHRzKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuICB2YXIgdSA9IHt9LCB2LCBpLCBuO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2IGluIHUpIGNvbnRpbnVlO1xuICAgIHVbdl0gPSAxO1xuICAgIHJlc3VsdHMucHVzaCh2KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnB1dCBhcnJheS5cbnN0YXRzLmNvdW50ID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aCB8fCAwO1xufTtcblxuLy8gQ291bnQgdGhlIG51bWJlciBvZiBub24tbnVsbCwgbm9uLXVuZGVmaW5lZCwgbm9uLU5hTiB2YWx1ZXMuXG5zdGF0cy5jb3VudC52YWxpZCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgdiwgaSwgbiwgdmFsaWQgPSAwO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHZhbGlkICs9IDE7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufTtcblxuLy8gQ291bnQgdGhlIG51bWJlciBvZiBudWxsIG9yIHVuZGVmaW5lZCB2YWx1ZXMuXG5zdGF0cy5jb3VudC5taXNzaW5nID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciB2LCBpLCBuLCBjb3VudCA9IDA7XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgPT0gbnVsbCkgY291bnQgKz0gMTtcbiAgfVxuICByZXR1cm4gY291bnQ7XG59O1xuXG4vLyBDb3VudCB0aGUgbnVtYmVyIG9mIGRpc3RpbmN0IHZhbHVlcy5cbi8vIE51bGwsIHVuZGVmaW5lZCBhbmQgTmFOIGFyZSBlYWNoIGNvbnNpZGVyZWQgZGlzdGluY3QgdmFsdWVzLlxuc3RhdHMuY291bnQuZGlzdGluY3QgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIHUgPSB7fSwgdiwgaSwgbiwgY291bnQgPSAwO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2IGluIHUpIGNvbnRpbnVlO1xuICAgIHVbdl0gPSAxO1xuICAgIGNvdW50ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxuLy8gQ29uc3RydWN0IGEgbWFwIGZyb20gZGlzdGluY3QgdmFsdWVzIHRvIG9jY3VycmVuY2UgY291bnRzLlxuc3RhdHMuY291bnQubWFwID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBtYXAgPSB7fSwgdiwgaSwgbjtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBtYXBbdl0gPSAodiBpbiBtYXApID8gbWFwW3ZdICsgMSA6IDE7XG4gIH1cbiAgcmV0dXJuIG1hcDtcbn07XG5cbi8vIENvbXB1dGUgdGhlIG1lZGlhbiBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMubWVkaWFuID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGlmIChmKSB2YWx1ZXMgPSB2YWx1ZXMubWFwKHV0aWwuJChmKSk7XG4gIHZhbHVlcyA9IHZhbHVlcy5maWx0ZXIodXRpbC5pc1ZhbGlkKS5zb3J0KHV0aWwuY21wKTtcbiAgcmV0dXJuIHN0YXRzLnF1YW50aWxlKHZhbHVlcywgMC41KTtcbn07XG5cbi8vIENvbXB1dGVzIHRoZSBxdWFydGlsZSBib3VuZGFyaWVzIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5xdWFydGlsZSA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBpZiAoZikgdmFsdWVzID0gdmFsdWVzLm1hcCh1dGlsLiQoZikpO1xuICB2YWx1ZXMgPSB2YWx1ZXMuZmlsdGVyKHV0aWwuaXNWYWxpZCkuc29ydCh1dGlsLmNtcCk7XG4gIHZhciBxID0gc3RhdHMucXVhbnRpbGU7XG4gIHJldHVybiBbcSh2YWx1ZXMsIDAuMjUpLCBxKHZhbHVlcywgMC41MCksIHEodmFsdWVzLCAwLjc1KV07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBxdWFudGlsZSBvZiBhIHNvcnRlZCBhcnJheSBvZiBudW1iZXJzLlxuLy8gQWRhcHRlZCBmcm9tIHRoZSBEMy5qcyBpbXBsZW1lbnRhdGlvbi5cbnN0YXRzLnF1YW50aWxlID0gZnVuY3Rpb24odmFsdWVzLCBmLCBwKSB7XG4gIGlmIChwID09PSB1bmRlZmluZWQpIHsgcCA9IGY7IGYgPSB1dGlsLmlkZW50aXR5OyB9XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBIID0gKHZhbHVlcy5sZW5ndGggLSAxKSAqIHAgKyAxLFxuICAgICAgaCA9IE1hdGguZmxvb3IoSCksXG4gICAgICB2ID0gK2YodmFsdWVzW2ggLSAxXSksXG4gICAgICBlID0gSCAtIGg7XG4gIHJldHVybiBlID8gdiArIGUgKiAoZih2YWx1ZXNbaF0pIC0gdikgOiB2O1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc3VtIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5zdW0gPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgZm9yICh2YXIgc3VtPTAsIGk9MCwgbj12YWx1ZXMubGVuZ3RoLCB2OyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHN1bSArPSB2O1xuICB9XG4gIHJldHVybiBzdW07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtZWFuIChhdmVyYWdlKSBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMubWVhbiA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgbWVhbiA9IDAsIGRlbHRhLCBpLCBuLCBjLCB2O1xuICBmb3IgKGk9MCwgYz0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkge1xuICAgICAgZGVsdGEgPSB2IC0gbWVhbjtcbiAgICAgIG1lYW4gPSBtZWFuICsgZGVsdGEgLyAoKytjKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lYW47XG59O1xuXG4vLyBDb21wdXRlIHRoZSBzYW1wbGUgdmFyaWFuY2Ugb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLnZhcmlhbmNlID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIGlmICghdXRpbC5pc0FycmF5KHZhbHVlcykgfHwgdmFsdWVzLmxlbmd0aCA8IDIpIHJldHVybiAwO1xuICB2YXIgbWVhbiA9IDAsIE0yID0gMCwgZGVsdGEsIGksIGMsIHY7XG4gIGZvciAoaT0wLCBjPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkge1xuICAgICAgZGVsdGEgPSB2IC0gbWVhbjtcbiAgICAgIG1lYW4gPSBtZWFuICsgZGVsdGEgLyAoKytjKTtcbiAgICAgIE0yID0gTTIgKyBkZWx0YSAqICh2IC0gbWVhbik7XG4gICAgfVxuICB9XG4gIE0yID0gTTIgLyAoYyAtIDEpO1xuICByZXR1cm4gTTI7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBzYW1wbGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5zdGRldiA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICByZXR1cm4gTWF0aC5zcXJ0KHN0YXRzLnZhcmlhbmNlKHZhbHVlcywgZikpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgUGVhcnNvbiBtb2RlIHNrZXduZXNzICgobWVkaWFuLW1lYW4pL3N0ZGV2KSBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMubW9kZXNrZXcgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgdmFyIGF2ZyA9IHN0YXRzLm1lYW4odmFsdWVzLCBmKSxcbiAgICAgIG1lZCA9IHN0YXRzLm1lZGlhbih2YWx1ZXMsIGYpLFxuICAgICAgc3RkID0gc3RhdHMuc3RkZXYodmFsdWVzLCBmKTtcbiAgcmV0dXJuIHN0ZCA9PT0gMCA/IDAgOiAoYXZnIC0gbWVkKSAvIHN0ZDtcbn07XG5cbi8vIEZpbmQgdGhlIG1pbmltdW0gdmFsdWUgaW4gYW4gYXJyYXkuXG5zdGF0cy5taW4gPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgcmV0dXJuIHN0YXRzLmV4dGVudCh2YWx1ZXMsIGYpWzBdO1xufTtcblxuLy8gRmluZCB0aGUgbWF4aW11bSB2YWx1ZSBpbiBhbiBhcnJheS5cbnN0YXRzLm1heCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICByZXR1cm4gc3RhdHMuZXh0ZW50KHZhbHVlcywgZilbMV07XG59O1xuXG4vLyBGaW5kIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG9mIGFuIGFycmF5IG9mIHZhbHVlcy5cbnN0YXRzLmV4dGVudCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgYSwgYiwgdiwgaSwgbiA9IHZhbHVlcy5sZW5ndGg7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHsgYSA9IGIgPSB2OyBicmVhazsgfVxuICB9XG4gIGZvciAoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIGlmICh2IDwgYSkgYSA9IHY7XG4gICAgICBpZiAodiA+IGIpIGIgPSB2O1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2EsIGJdO1xufTtcblxuLy8gRmluZCB0aGUgaW50ZWdlciBpbmRpY2VzIG9mIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlcy5cbnN0YXRzLmV4dGVudC5pbmRleCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgeCA9IC0xLCB5ID0gLTEsIGEsIGIsIHYsIGksIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7IGEgPSBiID0gdjsgeCA9IHkgPSBpOyBicmVhazsgfVxuICB9XG4gIGZvciAoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIGlmICh2IDwgYSkgeyBhID0gdjsgeCA9IGk7IH1cbiAgICAgIGlmICh2ID4gYikgeyBiID0gdjsgeSA9IGk7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFt4LCB5XTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBhcnJheXMgb2YgbnVtYmVycy5cbnN0YXRzLmRvdCA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYikge1xuICB2YXIgc3VtID0gMCwgaSwgdjtcbiAgaWYgKCFiKSB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggIT09IGEubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBFcnJvcignQXJyYXkgbGVuZ3RocyBtdXN0IG1hdGNoLicpO1xuICAgIH1cbiAgICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHYgPSB2YWx1ZXNbaV0gKiBhW2ldO1xuICAgICAgaWYgKHYgPT09IHYpIHN1bSArPSB2O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhID0gdXRpbC4kKGEpO1xuICAgIGIgPSB1dGlsLiQoYik7XG4gICAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2ID0gYSh2YWx1ZXNbaV0pICogYih2YWx1ZXNbaV0pO1xuICAgICAgaWYgKHYgPT09IHYpIHN1bSArPSB2O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3VtO1xufTtcblxuLy8gQ29tcHV0ZSBhc2NlbmRpbmcgcmFuayBzY29yZXMgZm9yIGFuIGFycmF5IG9mIHZhbHVlcy5cbi8vIFRpZXMgYXJlIGFzc2lnbmVkIHRoZWlyIGNvbGxlY3RpdmUgbWVhbiByYW5rLlxuc3RhdHMucmFuayA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpIHx8IHV0aWwuaWRlbnRpdHk7XG4gIHZhciBhID0gdmFsdWVzLm1hcChmdW5jdGlvbih2LCBpKSB7XG4gICAgICByZXR1cm4ge2lkeDogaSwgdmFsOiBmKHYpfTtcbiAgICB9KVxuICAgIC5zb3J0KHV0aWwuY29tcGFyYXRvcigndmFsJykpO1xuXG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIHIgPSBBcnJheShuKSxcbiAgICAgIHRpZSA9IC0xLCBwID0ge30sIGksIHYsIG11O1xuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHYgPSBhW2ldLnZhbDtcbiAgICBpZiAodGllIDwgMCAmJiBwID09PSB2KSB7XG4gICAgICB0aWUgPSBpIC0gMTtcbiAgICB9IGVsc2UgaWYgKHRpZSA+IC0xICYmIHAgIT09IHYpIHtcbiAgICAgIG11ID0gMSArIChpLTEgKyB0aWUpIC8gMjtcbiAgICAgIGZvciAoOyB0aWU8aTsgKyt0aWUpIHJbYVt0aWVdLmlkeF0gPSBtdTtcbiAgICAgIHRpZSA9IC0xO1xuICAgIH1cbiAgICByW2FbaV0uaWR4XSA9IGkgKyAxO1xuICAgIHAgPSB2O1xuICB9XG5cbiAgaWYgKHRpZSA+IC0xKSB7XG4gICAgbXUgPSAxICsgKG4tMSArIHRpZSkgLyAyO1xuICAgIGZvciAoOyB0aWU8bjsgKyt0aWUpIHJbYVt0aWVdLmlkeF0gPSBtdTtcbiAgfVxuXG4gIHJldHVybiByO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2FtcGxlIFBlYXJzb24gcHJvZHVjdC1tb21lbnQgY29ycmVsYXRpb24gb2YgdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuc3RhdHMuY29yID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciBmbiA9IGI7XG4gIGIgPSBmbiA/IHZhbHVlcy5tYXAodXRpbC4kKGIpKSA6IGE7XG4gIGEgPSBmbiA/IHZhbHVlcy5tYXAodXRpbC4kKGEpKSA6IHZhbHVlcztcblxuICB2YXIgZG90ID0gc3RhdHMuZG90KGEsIGIpLFxuICAgICAgbXVhID0gc3RhdHMubWVhbihhKSxcbiAgICAgIG11YiA9IHN0YXRzLm1lYW4oYiksXG4gICAgICBzZGEgPSBzdGF0cy5zdGRldihhKSxcbiAgICAgIHNkYiA9IHN0YXRzLnN0ZGV2KGIpLFxuICAgICAgbiA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgcmV0dXJuIChkb3QgLSBuKm11YSptdWIpIC8gKChuLTEpICogc2RhICogc2RiKTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIFNwZWFybWFuIHJhbmsgY29ycmVsYXRpb24gb2YgdHdvIGFycmF5cyBvZiB2YWx1ZXMuXG5zdGF0cy5jb3IucmFuayA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYikge1xuICB2YXIgcmEgPSBiID8gc3RhdHMucmFuayh2YWx1ZXMsIHV0aWwuJChhKSkgOiBzdGF0cy5yYW5rKHZhbHVlcyksXG4gICAgICByYiA9IGIgPyBzdGF0cy5yYW5rKHZhbHVlcywgdXRpbC4kKGIpKSA6IHN0YXRzLnJhbmsoYSksXG4gICAgICBuID0gdmFsdWVzLmxlbmd0aCwgaSwgcywgZDtcblxuICBmb3IgKGk9MCwgcz0wOyBpPG47ICsraSkge1xuICAgIGQgPSByYVtpXSAtIHJiW2ldO1xuICAgIHMgKz0gZCAqIGQ7XG4gIH1cblxuICByZXR1cm4gMSAtIDYqcyAvIChuICogKG4qbi0xKSk7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBkaXN0YW5jZSBjb3JyZWxhdGlvbiBvZiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rpc3RhbmNlX2NvcnJlbGF0aW9uXG5zdGF0cy5jb3IuZGlzdCA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYikge1xuICB2YXIgWCA9IGIgPyB2YWx1ZXMubWFwKHV0aWwuJChhKSkgOiB2YWx1ZXMsXG4gICAgICBZID0gYiA/IHZhbHVlcy5tYXAodXRpbC4kKGIpKSA6IGE7XG5cbiAgdmFyIEEgPSBzdGF0cy5kaXN0Lm1hdChYKSxcbiAgICAgIEIgPSBzdGF0cy5kaXN0Lm1hdChZKSxcbiAgICAgIG4gPSBBLmxlbmd0aCxcbiAgICAgIGksIGFhLCBiYiwgYWI7XG5cbiAgZm9yIChpPTAsIGFhPTAsIGJiPTAsIGFiPTA7IGk8bjsgKytpKSB7XG4gICAgYWEgKz0gQVtpXSpBW2ldO1xuICAgIGJiICs9IEJbaV0qQltpXTtcbiAgICBhYiArPSBBW2ldKkJbaV07XG4gIH1cblxuICByZXR1cm4gTWF0aC5zcXJ0KGFiIC8gTWF0aC5zcXJ0KGFhKmJiKSk7XG59O1xuXG4vLyBDb21wdXRlIHRoZSB2ZWN0b3IgZGlzdGFuY2UgYmV0d2VlbiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXG4vLyBEZWZhdWx0IGlzIEV1Y2xpZGVhbiAoZXhwPTIpIGRpc3RhbmNlLCBjb25maWd1cmFibGUgdmlhIGV4cCBhcmd1bWVudC5cbnN0YXRzLmRpc3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIGV4cCkge1xuICB2YXIgZiA9IHV0aWwuaXNGdW5jdGlvbihiKSB8fCB1dGlsLmlzU3RyaW5nKGIpLFxuICAgICAgWCA9IHZhbHVlcyxcbiAgICAgIFkgPSBmID8gdmFsdWVzIDogYSxcbiAgICAgIGUgPSBmID8gZXhwIDogYixcbiAgICAgIEwyID0gZSA9PT0gMiB8fCBlID09IG51bGwsXG4gICAgICBuID0gdmFsdWVzLmxlbmd0aCwgcyA9IDAsIGQsIGk7XG4gIGlmIChmKSB7XG4gICAgYSA9IHV0aWwuJChhKTtcbiAgICBiID0gdXRpbC4kKGIpO1xuICB9XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIGQgPSBmID8gKGEoWFtpXSktYihZW2ldKSkgOiAoWFtpXS1ZW2ldKTtcbiAgICBzICs9IEwyID8gZCpkIDogTWF0aC5wb3coTWF0aC5hYnMoZCksIGUpO1xuICB9XG4gIHJldHVybiBMMiA/IE1hdGguc3FydChzKSA6IE1hdGgucG93KHMsIDEvZSk7XG59O1xuXG4vLyBDb25zdHJ1Y3QgYSBtZWFuLWNlbnRlcmVkIGRpc3RhbmNlIG1hdHJpeCBmb3IgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLmRpc3QubWF0ID0gZnVuY3Rpb24oWCkge1xuICB2YXIgbiA9IFgubGVuZ3RoLFxuICAgICAgbSA9IG4qbixcbiAgICAgIEEgPSBBcnJheShtKSxcbiAgICAgIFIgPSBnZW4uemVyb3MobiksXG4gICAgICBNID0gMCwgdiwgaSwgajtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBBW2kqbitpXSA9IDA7XG4gICAgZm9yIChqPWkrMTsgajxuOyArK2opIHtcbiAgICAgIEFbaSpuK2pdID0gKHYgPSBNYXRoLmFicyhYW2ldIC0gWFtqXSkpO1xuICAgICAgQVtqKm4raV0gPSB2O1xuICAgICAgUltpXSArPSB2O1xuICAgICAgUltqXSArPSB2O1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIE0gKz0gUltpXTtcbiAgICBSW2ldIC89IG47XG4gIH1cbiAgTSAvPSBtO1xuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIGZvciAoaj1pOyBqPG47ICsraikge1xuICAgICAgQVtpKm4ral0gKz0gTSAtIFJbaV0gLSBSW2pdO1xuICAgICAgQVtqKm4raV0gPSBBW2kqbitqXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gQTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIFNoYW5ub24gZW50cm9weSAobG9nIGJhc2UgMikgb2YgYW4gYXJyYXkgb2YgY291bnRzLlxuc3RhdHMuZW50cm9weSA9IGZ1bmN0aW9uKGNvdW50cywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgaSwgcCwgcyA9IDAsIEggPSAwLCBuID0gY291bnRzLmxlbmd0aDtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgcyArPSAoZiA/IGYoY291bnRzW2ldKSA6IGNvdW50c1tpXSk7XG4gIH1cbiAgaWYgKHMgPT09IDApIHJldHVybiAwO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBwID0gKGYgPyBmKGNvdW50c1tpXSkgOiBjb3VudHNbaV0pIC8gcztcbiAgICBpZiAocCkgSCArPSBwICogTWF0aC5sb2cocCk7XG4gIH1cbiAgcmV0dXJuIC1IIC8gTWF0aC5MTjI7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtdXR1YWwgaW5mb3JtYXRpb24gYmV0d2VlbiB0d28gZGlzY3JldGUgdmFyaWFibGVzLlxuLy8gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgZm9ybSBbTUksIE1JX2Rpc3RhbmNlXSBcbi8vIE1JX2Rpc3RhbmNlIGlzIGRlZmluZWQgYXMgMSAtIEkoYSxiKSAvIEgoYSxiKS5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTXV0dWFsX2luZm9ybWF0aW9uXG5zdGF0cy5tdXR1YWwgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIGNvdW50cykge1xuICB2YXIgeCA9IGNvdW50cyA/IHZhbHVlcy5tYXAodXRpbC4kKGEpKSA6IHZhbHVlcyxcbiAgICAgIHkgPSBjb3VudHMgPyB2YWx1ZXMubWFwKHV0aWwuJChiKSkgOiBhLFxuICAgICAgeiA9IGNvdW50cyA/IHZhbHVlcy5tYXAodXRpbC4kKGNvdW50cykpIDogYjtcblxuICB2YXIgcHggPSB7fSxcbiAgICAgIHB5ID0ge30sXG4gICAgICBuID0gei5sZW5ndGgsXG4gICAgICBzID0gMCwgSSA9IDAsIEggPSAwLCBwLCB0LCBpO1xuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHB4W3hbaV1dID0gMDtcbiAgICBweVt5W2ldXSA9IDA7XG4gIH1cblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBweFt4W2ldXSArPSB6W2ldO1xuICAgIHB5W3lbaV1dICs9IHpbaV07XG4gICAgcyArPSB6W2ldO1xuICB9XG5cbiAgdCA9IDEgLyAocyAqIE1hdGguTE4yKTtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgaWYgKHpbaV0gPT09IDApIGNvbnRpbnVlO1xuICAgIHAgPSAocyAqIHpbaV0pIC8gKHB4W3hbaV1dICogcHlbeVtpXV0pO1xuICAgIEkgKz0geltpXSAqIHQgKiBNYXRoLmxvZyhwKTtcbiAgICBIICs9IHpbaV0gKiB0ICogTWF0aC5sb2coeltpXS9zKTtcbiAgfVxuXG4gIHJldHVybiBbSSwgMSArIEkvSF07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtdXR1YWwgaW5mb3JtYXRpb24gYmV0d2VlbiB0d28gZGlzY3JldGUgdmFyaWFibGVzLlxuc3RhdHMubXV0dWFsLmluZm8gPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIGNvdW50cykge1xuICByZXR1cm4gc3RhdHMubXV0dWFsKHZhbHVlcywgYSwgYiwgY291bnRzKVswXTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIG11dHVhbCBpbmZvcm1hdGlvbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byBkaXNjcmV0ZSB2YXJpYWJsZXMuXG4vLyBNSV9kaXN0YW5jZSBpcyBkZWZpbmVkIGFzIDEgLSBJKGEsYikgLyBIKGEsYikuXG5zdGF0cy5tdXR1YWwuZGlzdCA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYiwgY291bnRzKSB7XG4gIHJldHVybiBzdGF0cy5tdXR1YWwodmFsdWVzLCBhLCBiLCBjb3VudHMpWzFdO1xufTtcblxuLy8gQ29tcHV0ZSBhIHByb2ZpbGUgb2Ygc3VtbWFyeSBzdGF0aXN0aWNzIGZvciBhIHZhcmlhYmxlLlxuc3RhdHMucHJvZmlsZSA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICB2YXIgbWVhbiA9IDAsXG4gICAgICB2YWxpZCA9IDAsXG4gICAgICBtaXNzaW5nID0gMCxcbiAgICAgIGRpc3RpbmN0ID0gMCxcbiAgICAgIG1pbiA9IG51bGwsXG4gICAgICBtYXggPSBudWxsLFxuICAgICAgTTIgPSAwLFxuICAgICAgdmFscyA9IFtdLFxuICAgICAgdSA9IHt9LCBkZWx0YSwgc2QsIGksIHYsIHg7XG5cbiAgLy8gY29tcHV0ZSBzdW1tYXJ5IHN0YXRzXG4gIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuXG4gICAgLy8gdXBkYXRlIHVuaXF1ZSB2YWx1ZXNcbiAgICB1W3ZdID0gKHYgaW4gdSkgPyB1W3ZdICsgMSA6IChkaXN0aW5jdCArPSAxLCAxKTtcblxuICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICsrbWlzc2luZztcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNWYWxpZCh2KSkge1xuICAgICAgLy8gdXBkYXRlIHN0YXRzXG4gICAgICB4ID0gKHR5cGVvZiB2ID09PSAnc3RyaW5nJykgPyB2Lmxlbmd0aCA6IHY7XG4gICAgICBpZiAobWluPT09bnVsbCB8fCB4IDwgbWluKSBtaW4gPSB4O1xuICAgICAgaWYgKG1heD09PW51bGwgfHwgeCA+IG1heCkgbWF4ID0geDtcbiAgICAgIGRlbHRhID0geCAtIG1lYW47XG4gICAgICBtZWFuID0gbWVhbiArIGRlbHRhIC8gKCsrdmFsaWQpO1xuICAgICAgTTIgPSBNMiArIGRlbHRhICogKHggLSBtZWFuKTtcbiAgICAgIHZhbHMucHVzaCh4KTtcbiAgICB9XG4gIH1cbiAgTTIgPSBNMiAvICh2YWxpZCAtIDEpO1xuICBzZCA9IE1hdGguc3FydChNMik7XG5cbiAgLy8gc29ydCB2YWx1ZXMgZm9yIG1lZGlhbiBhbmQgaXFyXG4gIHZhbHMuc29ydCh1dGlsLmNtcCk7XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAgICAgdHlwZSh2YWx1ZXMsIGYpLFxuICAgIHVuaXF1ZTogICB1LFxuICAgIGNvdW50OiAgICB2YWx1ZXMubGVuZ3RoLFxuICAgIHZhbGlkOiAgICB2YWxpZCxcbiAgICBtaXNzaW5nOiAgbWlzc2luZyxcbiAgICBkaXN0aW5jdDogZGlzdGluY3QsXG4gICAgbWluOiAgICAgIG1pbixcbiAgICBtYXg6ICAgICAgbWF4LFxuICAgIG1lYW46ICAgICBtZWFuLFxuICAgIHN0ZGV2OiAgICBzZCxcbiAgICBtZWRpYW46ICAgKHYgPSBzdGF0cy5xdWFudGlsZSh2YWxzLCAwLjUpKSxcbiAgICBxMTogICAgICAgc3RhdHMucXVhbnRpbGUodmFscywgMC4yNSksXG4gICAgcTM6ICAgICAgIHN0YXRzLnF1YW50aWxlKHZhbHMsIDAuNzUpLFxuICAgIG1vZGVza2V3OiBzZCA9PT0gMCA/IDAgOiAobWVhbiAtIHYpIC8gc2RcbiAgfTtcbn07XG5cbi8vIENvbXB1dGUgcHJvZmlsZXMgZm9yIGFsbCB2YXJpYWJsZXMgaW4gYSBkYXRhIHNldC5cbnN0YXRzLnN1bW1hcnkgPSBmdW5jdGlvbihkYXRhLCBmaWVsZHMpIHtcbiAgZmllbGRzID0gZmllbGRzIHx8IHV0aWwua2V5cyhkYXRhWzBdKTtcbiAgdmFyIHMgPSBmaWVsZHMubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICB2YXIgcCA9IHN0YXRzLnByb2ZpbGUoZGF0YSwgdXRpbC4kKGYpKTtcbiAgICByZXR1cm4gKHAuZmllbGQgPSBmLCBwKTtcbiAgfSk7XG4gIHJldHVybiAocy5fX3N1bW1hcnlfXyA9IHRydWUsIHMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdGF0czsiLCJ2YXIgZDNfdGltZSA9IHJlcXVpcmUoJ2QzLXRpbWUnKTtcblxudmFyIHRlbXBEYXRlID0gbmV3IERhdGUoKSxcbiAgICBiYXNlRGF0ZSA9IG5ldyBEYXRlKDAsIDAsIDEpLnNldEZ1bGxZZWFyKDApLCAvLyBKYW4gMSwgMCBBRFxuICAgIHV0Y0Jhc2VEYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoMCwgMCwgMSkpLnNldFVUQ0Z1bGxZZWFyKDApO1xuXG5mdW5jdGlvbiBkYXRlKGQpIHtcbiAgcmV0dXJuICh0ZW1wRGF0ZS5zZXRUaW1lKCtkKSwgdGVtcERhdGUpO1xufVxuXG4vLyBjcmVhdGUgYSB0aW1lIHVuaXQgZW50cnlcbmZ1bmN0aW9uIGVudHJ5KHR5cGUsIGRhdGUsIHVuaXQsIHN0ZXAsIG1pbiwgbWF4KSB7XG4gIHZhciBlID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgZGF0ZTogZGF0ZSxcbiAgICB1bml0OiB1bml0XG4gIH07XG4gIGlmIChzdGVwKSB7XG4gICAgZS5zdGVwID0gc3RlcDtcbiAgfSBlbHNlIHtcbiAgICBlLm1pbnN0ZXAgPSAxO1xuICB9XG4gIGlmIChtaW4gIT0gbnVsbCkgZS5taW4gPSBtaW47XG4gIGlmIChtYXggIT0gbnVsbCkgZS5tYXggPSBtYXg7XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUodHlwZSwgdW5pdCwgYmFzZSwgc3RlcCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIGVudHJ5KHR5cGUsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gdW5pdC5vZmZzZXQoYmFzZSwgZCk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gdW5pdC5jb3VudChiYXNlLCBkKTsgfSxcbiAgICBzdGVwLCBtaW4sIG1heCk7XG59XG5cbnZhciBsb2NhbGUgPSBbXG4gIGNyZWF0ZSgnc2Vjb25kJywgZDNfdGltZS5zZWNvbmQsIGJhc2VEYXRlKSxcbiAgY3JlYXRlKCdtaW51dGUnLCBkM190aW1lLm1pbnV0ZSwgYmFzZURhdGUpLFxuICBjcmVhdGUoJ2hvdXInLCAgIGQzX3RpbWUuaG91ciwgICBiYXNlRGF0ZSksXG4gIGNyZWF0ZSgnZGF5JywgICAgZDNfdGltZS5kYXksICAgIGJhc2VEYXRlLCBbMSwgN10pLFxuICBjcmVhdGUoJ21vbnRoJywgIGQzX3RpbWUubW9udGgsICBiYXNlRGF0ZSwgWzEsIDMsIDZdKSxcbiAgY3JlYXRlKCd5ZWFyJywgICBkM190aW1lLnllYXIsICAgYmFzZURhdGUpLFxuXG4gIC8vIHBlcmlvZGljIHVuaXRzXG4gIGVudHJ5KCdzZWNvbmRzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZSgxOTcwLCAwLCAxLCAwLCAwLCBkKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldFNlY29uZHMoKTsgfSxcbiAgICBudWxsLCAwLCA1OVxuICApLFxuICBlbnRyeSgnbWludXRlcycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoMTk3MCwgMCwgMSwgMCwgZCk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXRNaW51dGVzKCk7IH0sXG4gICAgbnVsbCwgMCwgNTlcbiAgKSxcbiAgZW50cnkoJ2hvdXJzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZSgxOTcwLCAwLCAxLCBkKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldEhvdXJzKCk7IH0sXG4gICAgbnVsbCwgMCwgMjNcbiAgKSxcbiAgZW50cnkoJ3dlZWtkYXlzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZSgxOTcwLCAwLCA0K2QpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0RGF5KCk7IH0sXG4gICAgWzFdLCAwLCA2XG4gICksXG4gIGVudHJ5KCdkYXRlcycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoMTk3MCwgMCwgZCk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXREYXRlKCk7IH0sXG4gICAgWzFdLCAxLCAzMVxuICApLFxuICBlbnRyeSgnbW9udGhzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZSgxOTcwLCBkICUgMTIsIDEpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0TW9udGgoKTsgfSxcbiAgICBbMV0sIDAsIDExXG4gIClcbl07XG5cbnZhciB1dGMgPSBbXG4gIGNyZWF0ZSgnc2Vjb25kJywgZDNfdGltZS51dGNTZWNvbmQsIHV0Y0Jhc2VEYXRlKSxcbiAgY3JlYXRlKCdtaW51dGUnLCBkM190aW1lLnV0Y01pbnV0ZSwgdXRjQmFzZURhdGUpLFxuICBjcmVhdGUoJ2hvdXInLCAgIGQzX3RpbWUudXRjSG91ciwgICB1dGNCYXNlRGF0ZSksXG4gIGNyZWF0ZSgnZGF5JywgICAgZDNfdGltZS51dGNEYXksICAgIHV0Y0Jhc2VEYXRlLCBbMSwgN10pLFxuICBjcmVhdGUoJ21vbnRoJywgIGQzX3RpbWUudXRjTW9udGgsICB1dGNCYXNlRGF0ZSwgWzEsIDMsIDZdKSxcbiAgY3JlYXRlKCd5ZWFyJywgICBkM190aW1lLnV0Y1llYXIsICAgdXRjQmFzZURhdGUpLFxuXG4gIC8vIHBlcmlvZGljIHVuaXRzXG4gIGVudHJ5KCdzZWNvbmRzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCAwLCAxLCAwLCAwLCBkKSk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXRVVENTZWNvbmRzKCk7IH0sXG4gICAgbnVsbCwgMCwgNTlcbiAgKSxcbiAgZW50cnkoJ21pbnV0ZXMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIDEsIDAsIGQpKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldFVUQ01pbnV0ZXMoKTsgfSxcbiAgICBudWxsLCAwLCA1OVxuICApLFxuICBlbnRyeSgnaG91cnMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIDEsIGQpKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldFVUQ0hvdXJzKCk7IH0sXG4gICAgbnVsbCwgMCwgMjNcbiAgKSxcbiAgZW50cnkoJ3dlZWtkYXlzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCAwLCA0K2QpKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldFVUQ0RheSgpOyB9LFxuICAgIFsxXSwgMCwgNlxuICApLFxuICBlbnRyeSgnZGF0ZXMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIGQpKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldFVUQ0RhdGUoKTsgfSxcbiAgICBbMV0sIDEsIDMxXG4gICksXG4gIGVudHJ5KCdtb250aHMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIGQgJSAxMiwgMSkpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0VVRDTW9udGgoKTsgfSxcbiAgICBbMV0sIDAsIDExXG4gIClcbl07XG5cbnZhciBTVEVQUyA9IFtcbiAgWzMxNTM2ZTYsIDVdLCAgLy8gMS15ZWFyXG4gIFs3Nzc2ZTYsIDRdLCAgIC8vIDMtbW9udGhcbiAgWzI1OTJlNiwgNF0sICAgLy8gMS1tb250aFxuICBbMTIwOTZlNSwgM10sICAvLyAyLXdlZWtcbiAgWzYwNDhlNSwgM10sICAgLy8gMS13ZWVrXG4gIFsxNzI4ZTUsIDNdLCAgIC8vIDItZGF5XG4gIFs4NjRlNSwgM10sICAgIC8vIDEtZGF5XG4gIFs0MzJlNSwgMl0sICAgIC8vIDEyLWhvdXJcbiAgWzIxNmU1LCAyXSwgICAgLy8gNi1ob3VyXG4gIFsxMDhlNSwgMl0sICAgIC8vIDMtaG91clxuICBbMzZlNSwgMl0sICAgICAvLyAxLWhvdXJcbiAgWzE4ZTUsIDFdLCAgICAgLy8gMzAtbWludXRlXG4gIFs5ZTUsIDFdLCAgICAgIC8vIDE1LW1pbnV0ZVxuICBbM2U1LCAxXSwgICAgICAvLyA1LW1pbnV0ZVxuICBbNmU0LCAxXSwgICAgICAvLyAxLW1pbnV0ZVxuICBbM2U0LCAwXSwgICAgICAvLyAzMC1zZWNvbmRcbiAgWzE1ZTMsIDBdLCAgICAgLy8gMTUtc2Vjb25kXG4gIFs1ZTMsIDBdLCAgICAgIC8vIDUtc2Vjb25kXG4gIFsxZTMsIDBdICAgICAgIC8vIDEtc2Vjb25kXG5dO1xuXG5mdW5jdGlvbiBmaW5kKHVuaXRzLCBzcGFuLCBtaW5iLCBtYXhiKSB7XG4gIHZhciBzdGVwID0gU1RFUFNbMF0sIGksIG4sIGJpbnM7XG5cbiAgZm9yIChpPTEsIG49U1RFUFMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHN0ZXAgPSBTVEVQU1tpXTtcbiAgICBpZiAoc3BhbiA+IHN0ZXBbMF0pIHtcbiAgICAgIGJpbnMgPSBzcGFuIC8gc3RlcFswXTtcbiAgICAgIGlmIChiaW5zID4gbWF4Yikge1xuICAgICAgICByZXR1cm4gdW5pdHNbU1RFUFNbaS0xXVsxXV07XG4gICAgICB9XG4gICAgICBpZiAoYmlucyA+PSBtaW5iKSB7XG4gICAgICAgIHJldHVybiB1bml0c1tzdGVwWzFdXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuaXRzW1NURVBTW24tMV1bMV1dO1xufVxuXG5mdW5jdGlvbiB0b1VuaXRNYXAodW5pdHMpIHtcbiAgdmFyIG1hcCA9IHt9LCBpLCBuO1xuICBmb3IgKGk9MCwgbj11bml0cy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgbWFwW3VuaXRzW2ldLnR5cGVdID0gdW5pdHNbaV07XG4gIH1cbiAgbWFwLmZpbmQgPSBmdW5jdGlvbihzcGFuLCBtaW5iLCBtYXhiKSB7XG4gICAgcmV0dXJuIGZpbmQodW5pdHMsIHNwYW4sIG1pbmIsIG1heGIpO1xuICB9O1xuICByZXR1cm4gbWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvVW5pdE1hcChsb2NhbGUpO1xubW9kdWxlLmV4cG9ydHMudXRjID0gdG9Vbml0TWFwKHV0Yyk7XG4iLCJ2YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJyksXG4gICAgdGltZSA9IHJlcXVpcmUoJy4vdGltZScpLFxuICAgIHV0YyA9IHRpbWUudXRjO1xuXG52YXIgdSA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIHV0aWxpdHkgZnVuY3Rpb25zXG5cbnZhciBGTkFNRSA9ICdfX25hbWVfXyc7XG5cbnUubmFtZWRmdW5jID0gZnVuY3Rpb24obmFtZSwgZikgeyByZXR1cm4gKGZbRk5BTUVdID0gbmFtZSwgZik7IH07XG5cbnUubmFtZSA9IGZ1bmN0aW9uKGYpIHsgcmV0dXJuIGY9PW51bGwgPyBudWxsIDogZltGTkFNRV07IH07XG5cbnUuaWRlbnRpdHkgPSBmdW5jdGlvbih4KSB7IHJldHVybiB4OyB9O1xuXG51LnRydWUgPSB1Lm5hbWVkZnVuYygndHJ1ZScsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG5cbnUuZmFsc2UgPSB1Lm5hbWVkZnVuYygnZmFsc2UnLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9KTtcblxudS5kdXBsaWNhdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59O1xuXG51LmVxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpO1xufTtcblxudS5leHRlbmQgPSBmdW5jdGlvbihvYmopIHtcbiAgZm9yICh2YXIgeCwgbmFtZSwgaT0xLCBsZW49YXJndW1lbnRzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIHggPSBhcmd1bWVudHNbaV07XG4gICAgZm9yIChuYW1lIGluIHgpIHsgb2JqW25hbWVdID0geFtuYW1lXTsgfVxuICB9XG4gIHJldHVybiBvYmo7XG59O1xuXG51Lmxlbmd0aCA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggIT0gbnVsbCAmJiB4Lmxlbmd0aCAhPSBudWxsID8geC5sZW5ndGggOiBudWxsO1xufTtcblxudS5rZXlzID0gZnVuY3Rpb24oeCkge1xuICB2YXIga2V5cyA9IFtdLCBrO1xuICBmb3IgKGsgaW4geCkga2V5cy5wdXNoKGspO1xuICByZXR1cm4ga2V5cztcbn07XG5cbnUudmFscyA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIHZhbHMgPSBbXSwgaztcbiAgZm9yIChrIGluIHgpIHZhbHMucHVzaCh4W2tdKTtcbiAgcmV0dXJuIHZhbHM7XG59O1xuXG51LnRvTWFwID0gZnVuY3Rpb24obGlzdCwgZikge1xuICByZXR1cm4gKGYgPSB1LiQoZikpID9cbiAgICBsaXN0LnJlZHVjZShmdW5jdGlvbihvYmosIHgpIHsgcmV0dXJuIChvYmpbZih4KV0gPSAxLCBvYmopOyB9LCB7fSkgOlxuICAgIGxpc3QucmVkdWNlKGZ1bmN0aW9uKG9iaiwgeCkgeyByZXR1cm4gKG9ialt4XSA9IDEsIG9iaik7IH0sIHt9KTtcbn07XG5cbnUua2V5c3RyID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIC8vIHVzZSB0byBlbnN1cmUgY29uc2lzdGVudCBrZXkgZ2VuZXJhdGlvbiBhY3Jvc3MgbW9kdWxlc1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGg7XG4gIGlmICghbikgcmV0dXJuICcnO1xuICBmb3IgKHZhciBzPVN0cmluZyh2YWx1ZXNbMF0pLCBpPTE7IGk8bjsgKytpKSB7XG4gICAgcyArPSAnfCcgKyBTdHJpbmcodmFsdWVzW2ldKTtcbiAgfVxuICByZXR1cm4gcztcbn07XG5cbi8vIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbnUuaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG59O1xuXG51LmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnUuaXNTdHJpbmcgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbn07XG5cbnUuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG51LmlzTnVtYmVyID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAnbnVtYmVyJyB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE51bWJlcl0nO1xufTtcblxudS5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBCb29sZWFuXSc7XG59O1xuXG51LmlzRGF0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBEYXRlXSc7XG59O1xuXG51LmlzVmFsaWQgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqO1xufTtcblxudS5pc0J1ZmZlciA9IChidWZmZXIuQnVmZmVyICYmIGJ1ZmZlci5CdWZmZXIuaXNCdWZmZXIpIHx8IHUuZmFsc2U7XG5cbi8vIHR5cGUgY29lcmNpb24gZnVuY3Rpb25zXG5cbnUubnVtYmVyID0gZnVuY3Rpb24ocykge1xuICByZXR1cm4gcyA9PSBudWxsIHx8IHMgPT09ICcnID8gbnVsbCA6ICtzO1xufTtcblxudS5ib29sZWFuID0gZnVuY3Rpb24ocykge1xuICByZXR1cm4gcyA9PSBudWxsIHx8IHMgPT09ICcnID8gbnVsbCA6IHM9PT0nZmFsc2UnID8gZmFsc2UgOiAhIXM7XG59O1xuXG51LmRhdGUgPSBmdW5jdGlvbihzKSB7XG4gIHJldHVybiBzID09IG51bGwgfHwgcyA9PT0gJycgPyBudWxsIDogRGF0ZS5wYXJzZShzKTtcbn07XG5cbnUuYXJyYXkgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4ICE9IG51bGwgPyAodS5pc0FycmF5KHgpID8geCA6IFt4XSkgOiBbXTtcbn07XG5cbnUuc3RyID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gdS5pc0FycmF5KHgpID8gJ1snICsgeC5tYXAodS5zdHIpICsgJ10nXG4gICAgOiB1LmlzT2JqZWN0KHgpID8gSlNPTi5zdHJpbmdpZnkoeClcbiAgICA6IHUuaXNTdHJpbmcoeCkgPyAoJ1xcJycrdXRpbF9lc2NhcGVfc3RyKHgpKydcXCcnKSA6IHg7XG59O1xuXG52YXIgZXNjYXBlX3N0cl9yZSA9IC8oXnxbXlxcXFxdKScvZztcblxuZnVuY3Rpb24gdXRpbF9lc2NhcGVfc3RyKHgpIHtcbiAgcmV0dXJuIHgucmVwbGFjZShlc2NhcGVfc3RyX3JlLCAnJDFcXFxcXFwnJyk7XG59XG5cbi8vIGRhdGEgYWNjZXNzIGZ1bmN0aW9uc1xuXG51LmZpZWxkID0gZnVuY3Rpb24oZikge1xuICByZXR1cm4gU3RyaW5nKGYpLnNwbGl0KCdcXFxcLicpXG4gICAgLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiBkLnNwbGl0KCcuJyk7IH0pXG4gICAgLnJlZHVjZShmdW5jdGlvbihhLCBiKSB7XG4gICAgICBpZiAoYS5sZW5ndGgpIHsgYVthLmxlbmd0aC0xXSArPSAnLicgKyBiLnNoaWZ0KCk7IH1cbiAgICAgIGEucHVzaC5hcHBseShhLCBiKTtcbiAgICAgIHJldHVybiBhO1xuICAgIH0sIFtdKTtcbn07XG5cbnUuYWNjZXNzb3IgPSBmdW5jdGlvbihmKSB7XG4gIHZhciBzO1xuICByZXR1cm4gZj09bnVsbCB8fCB1LmlzRnVuY3Rpb24oZikgPyBmIDpcbiAgICB1Lm5hbWVkZnVuYyhmLCAocyA9IHUuZmllbGQoZikpLmxlbmd0aCA+IDEgP1xuICAgICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gcy5yZWR1Y2UoZnVuY3Rpb24oeCxmKSB7IHJldHVybiB4W2ZdOyB9LCB4KTsgfSA6XG4gICAgICBmdW5jdGlvbih4KSB7IHJldHVybiB4W2ZdOyB9XG4gICAgKTtcbn07XG5cbi8vIHNob3J0LWN1dCBmb3IgYWNjZXNzb3JcbnUuJCA9IHUuYWNjZXNzb3I7XG5cbnUubXV0YXRvciA9IGZ1bmN0aW9uKGYpIHtcbiAgdmFyIHM7XG4gIHJldHVybiB1LmlzU3RyaW5nKGYpICYmIChzPXUuZmllbGQoZikpLmxlbmd0aCA+IDEgP1xuICAgIGZ1bmN0aW9uKHgsIHYpIHtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxzLmxlbmd0aC0xOyArK2kpIHggPSB4W3NbaV1dO1xuICAgICAgeFtzW2ldXSA9IHY7XG4gICAgfSA6XG4gICAgZnVuY3Rpb24oeCwgdikgeyB4W2ZdID0gdjsgfTtcbn07XG5cblxudS4kZnVuYyA9IGZ1bmN0aW9uKG5hbWUsIG9wKSB7XG4gIHJldHVybiBmdW5jdGlvbihmKSB7XG4gICAgZiA9IHUuJChmKSB8fCB1LmlkZW50aXR5O1xuICAgIHZhciBuID0gbmFtZSArICh1Lm5hbWUoZikgPyAnXycrdS5uYW1lKGYpIDogJycpO1xuICAgIHJldHVybiB1Lm5hbWVkZnVuYyhuLCBmdW5jdGlvbihkKSB7IHJldHVybiBvcChmKGQpKTsgfSk7XG4gIH07XG59O1xuXG51LiR2YWxpZCAgPSB1LiRmdW5jKCd2YWxpZCcsIHUuaXNWYWxpZCk7XG51LiRsZW5ndGggPSB1LiRmdW5jKCdsZW5ndGgnLCB1Lmxlbmd0aCk7XG5cbnUuJGluID0gZnVuY3Rpb24oZiwgdmFsdWVzKSB7XG4gIGYgPSB1LiQoZik7XG4gIHZhciBtYXAgPSB1LmlzQXJyYXkodmFsdWVzKSA/IHUudG9NYXAodmFsdWVzKSA6IHZhbHVlcztcbiAgcmV0dXJuIGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhbWFwW2YoZCldOyB9O1xufTtcblxudS4keWVhciAgID0gdS4kZnVuYygneWVhcicsIHRpbWUueWVhci51bml0KTtcbnUuJG1vbnRoICA9IHUuJGZ1bmMoJ21vbnRoJywgdGltZS5tb250aHMudW5pdCk7XG51LiRkYXRlICAgPSB1LiRmdW5jKCdkYXRlJywgdGltZS5kYXRlcy51bml0KTtcbnUuJGRheSAgICA9IHUuJGZ1bmMoJ2RheScsIHRpbWUud2Vla2RheXMudW5pdCk7XG51LiRob3VyICAgPSB1LiRmdW5jKCdob3VyJywgdGltZS5ob3Vycy51bml0KTtcbnUuJG1pbnV0ZSA9IHUuJGZ1bmMoJ21pbnV0ZScsIHRpbWUubWludXRlcy51bml0KTtcbnUuJHNlY29uZCA9IHUuJGZ1bmMoJ3NlY29uZCcsIHRpbWUuc2Vjb25kcy51bml0KTtcblxudS4kdXRjWWVhciAgID0gdS4kZnVuYygndXRjWWVhcicsIHV0Yy55ZWFyLnVuaXQpO1xudS4kdXRjTW9udGggID0gdS4kZnVuYygndXRjTW9udGgnLCB1dGMubW9udGhzLnVuaXQpO1xudS4kdXRjRGF0ZSAgID0gdS4kZnVuYygndXRjRGF0ZScsIHV0Yy5kYXRlcy51bml0KTtcbnUuJHV0Y0RheSAgICA9IHUuJGZ1bmMoJ3V0Y0RheScsIHV0Yy53ZWVrZGF5cy51bml0KTtcbnUuJHV0Y0hvdXIgICA9IHUuJGZ1bmMoJ3V0Y0hvdXInLCB1dGMuaG91cnMudW5pdCk7XG51LiR1dGNNaW51dGUgPSB1LiRmdW5jKCd1dGNNaW51dGUnLCB1dGMubWludXRlcy51bml0KTtcbnUuJHV0Y1NlY29uZCA9IHUuJGZ1bmMoJ3V0Y1NlY29uZCcsIHV0Yy5zZWNvbmRzLnVuaXQpO1xuXG4vLyBjb21wYXJpc29uIC8gc29ydGluZyBmdW5jdGlvbnNcblxudS5jb21wYXJhdG9yID0gZnVuY3Rpb24oc29ydCkge1xuICB2YXIgc2lnbiA9IFtdO1xuICBpZiAoc29ydCA9PT0gdW5kZWZpbmVkKSBzb3J0ID0gW107XG4gIHNvcnQgPSB1LmFycmF5KHNvcnQpLm1hcChmdW5jdGlvbihmKSB7XG4gICAgdmFyIHMgPSAxO1xuICAgIGlmICAgICAgKGZbMF0gPT09ICctJykgeyBzID0gLTE7IGYgPSBmLnNsaWNlKDEpOyB9XG4gICAgZWxzZSBpZiAoZlswXSA9PT0gJysnKSB7IHMgPSArMTsgZiA9IGYuc2xpY2UoMSk7IH1cbiAgICBzaWduLnB1c2gocyk7XG4gICAgcmV0dXJuIHUuYWNjZXNzb3IoZik7XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24oYSxiKSB7XG4gICAgdmFyIGksIG4sIGYsIHgsIHk7XG4gICAgZm9yIChpPTAsIG49c29ydC5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBmID0gc29ydFtpXTsgeCA9IGYoYSk7IHkgPSBmKGIpO1xuICAgICAgaWYgKHggPCB5KSByZXR1cm4gLTEgKiBzaWduW2ldO1xuICAgICAgaWYgKHggPiB5KSByZXR1cm4gc2lnbltpXTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG59O1xuXG51LmNtcCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoYSA+PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoYSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChiID09PSBudWxsKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIE5hTjtcbn07XG5cbnUubnVtY21wID0gZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSAtIGI7IH07XG5cbnUuc3RhYmxlc29ydCA9IGZ1bmN0aW9uKGFycmF5LCBzb3J0QnksIGtleUZuKSB7XG4gIHZhciBpbmRpY2VzID0gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKGlkeCwgdiwgaSkge1xuICAgIHJldHVybiAoaWR4W2tleUZuKHYpXSA9IGksIGlkeCk7XG4gIH0sIHt9KTtcblxuICBhcnJheS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgc2EgPSBzb3J0QnkoYSksXG4gICAgICAgIHNiID0gc29ydEJ5KGIpO1xuICAgIHJldHVybiBzYSA8IHNiID8gLTEgOiBzYSA+IHNiID8gMVxuICAgICAgICAgOiAoaW5kaWNlc1trZXlGbihhKV0gLSBpbmRpY2VzW2tleUZuKGIpXSk7XG4gIH0pO1xuXG4gIHJldHVybiBhcnJheTtcbn07XG5cblxuLy8gc3RyaW5nIGZ1bmN0aW9uc1xuXG51LnBhZCA9IGZ1bmN0aW9uKHMsIGxlbmd0aCwgcG9zLCBwYWRjaGFyKSB7XG4gIHBhZGNoYXIgPSBwYWRjaGFyIHx8IFwiIFwiO1xuICB2YXIgZCA9IGxlbmd0aCAtIHMubGVuZ3RoO1xuICBpZiAoZCA8PSAwKSByZXR1cm4gcztcbiAgc3dpdGNoIChwb3MpIHtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHJldHVybiBzdHJyZXAoZCwgcGFkY2hhcikgKyBzO1xuICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIHJldHVybiBzdHJyZXAoTWF0aC5mbG9vcihkLzIpLCBwYWRjaGFyKSArXG4gICAgICAgICBzICsgc3RycmVwKE1hdGguY2VpbChkLzIpLCBwYWRjaGFyKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHMgKyBzdHJyZXAoZCwgcGFkY2hhcik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHN0cnJlcChuLCBzdHIpIHtcbiAgdmFyIHMgPSBcIlwiLCBpO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHMgKz0gc3RyO1xuICByZXR1cm4gcztcbn1cblxudS50cnVuY2F0ZSA9IGZ1bmN0aW9uKHMsIGxlbmd0aCwgcG9zLCB3b3JkLCBlbGxpcHNpcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGg7XG4gIGlmIChsZW4gPD0gbGVuZ3RoKSByZXR1cm4gcztcbiAgZWxsaXBzaXMgPSBlbGxpcHNpcyAhPT0gdW5kZWZpbmVkID8gU3RyaW5nKGVsbGlwc2lzKSA6ICdcXHUyMDI2JztcbiAgdmFyIGwgPSBNYXRoLm1heCgwLCBsZW5ndGggLSBlbGxpcHNpcy5sZW5ndGgpO1xuXG4gIHN3aXRjaCAocG9zKSB7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICByZXR1cm4gZWxsaXBzaXMgKyAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbCwxKSA6IHMuc2xpY2UobGVuLWwpKTtcbiAgICBjYXNlICdtaWRkbGUnOlxuICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICB2YXIgbDEgPSBNYXRoLmNlaWwobC8yKSwgbDIgPSBNYXRoLmZsb29yKGwvMik7XG4gICAgICByZXR1cm4gKHdvcmQgPyB0cnVuY2F0ZU9uV29yZChzLGwxKSA6IHMuc2xpY2UoMCxsMSkpICtcbiAgICAgICAgZWxsaXBzaXMgKyAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbDIsMSkgOiBzLnNsaWNlKGxlbi1sMikpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gKHdvcmQgPyB0cnVuY2F0ZU9uV29yZChzLGwpIDogcy5zbGljZSgwLGwpKSArIGVsbGlwc2lzO1xuICB9XG59O1xuXG5mdW5jdGlvbiB0cnVuY2F0ZU9uV29yZChzLCBsZW4sIHJldikge1xuICB2YXIgY250ID0gMCwgdG9rID0gcy5zcGxpdCh0cnVuY2F0ZV93b3JkX3JlKTtcbiAgaWYgKHJldikge1xuICAgIHMgPSAodG9rID0gdG9rLnJldmVyc2UoKSlcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24odykgeyBjbnQgKz0gdy5sZW5ndGg7IHJldHVybiBjbnQgPD0gbGVuOyB9KVxuICAgICAgLnJldmVyc2UoKTtcbiAgfSBlbHNlIHtcbiAgICBzID0gdG9rLmZpbHRlcihmdW5jdGlvbih3KSB7IGNudCArPSB3Lmxlbmd0aDsgcmV0dXJuIGNudCA8PSBsZW47IH0pO1xuICB9XG4gIHJldHVybiBzLmxlbmd0aCA/IHMuam9pbignJykudHJpbSgpIDogdG9rWzBdLnNsaWNlKDAsIGxlbik7XG59XG5cbnZhciB0cnVuY2F0ZV93b3JkX3JlID0gLyhbXFx1MDAwOVxcdTAwMEFcXHUwMDBCXFx1MDAwQ1xcdTAwMERcXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTIwMjhcXHUyMDI5XFx1MzAwMFxcdUZFRkZdKS87XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vZ2xvYmFscycpO1xuXG52YXIgY29uc3RzID0gcmVxdWlyZSgnLi9jb25zdHMnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICB2bGZpZWxkID0gcmVxdWlyZSgnLi9maWVsZCcpLFxuICB2bGVuYyA9IHJlcXVpcmUoJy4vZW5jJyksXG4gIHNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hL3NjaGVtYScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gRW5jb2Rpbmcoc3BlYywgdGhlbWUpIHtcbiAgICB2YXIgZGVmYXVsdHMgPSBzY2hlbWEuaW5zdGFudGlhdGUoKSxcbiAgICAgIHNwZWNFeHRlbmRlZCA9IHNjaGVtYS51dGlsLm1lcmdlKGRlZmF1bHRzLCB0aGVtZSB8fCB7fSwgc3BlYykgO1xuXG4gICAgdGhpcy5fZGF0YSA9IHNwZWNFeHRlbmRlZC5kYXRhO1xuICAgIHRoaXMuX21hcmt0eXBlID0gc3BlY0V4dGVuZGVkLm1hcmt0eXBlO1xuICAgIHRoaXMuX2VuYyA9IHNwZWNFeHRlbmRlZC5lbmNvZGluZztcbiAgICB0aGlzLl9jb25maWcgPSBzcGVjRXh0ZW5kZWQuY29uZmlnO1xuICAgIHRoaXMuX2ZpbHRlciA9IHNwZWNFeHRlbmRlZC5maWx0ZXI7XG4gICAgLy8gdGhpcy5fdmVnYTIgPSB0cnVlO1xuICB9XG5cbiAgdmFyIHByb3RvID0gRW5jb2RpbmcucHJvdG90eXBlO1xuXG4gIEVuY29kaW5nLmZyb21TaG9ydGhhbmQgPSBmdW5jdGlvbihzaG9ydGhhbmQsIGRhdGEsIGNvbmZpZywgdGhlbWUpIHtcbiAgICB2YXIgYyA9IGNvbnN0cy5zaG9ydGhhbmQsXG4gICAgICAgIHNwbGl0ID0gc2hvcnRoYW5kLnNwbGl0KGMuZGVsaW0pLFxuICAgICAgICBtYXJrdHlwZSA9IHNwbGl0LnNoaWZ0KCkuc3BsaXQoYy5hc3NpZ24pWzFdLnRyaW0oKSxcbiAgICAgICAgZW5jID0gdmxlbmMuZnJvbVNob3J0aGFuZChzcGxpdCk7XG5cbiAgICByZXR1cm4gbmV3IEVuY29kaW5nKHtcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBtYXJrdHlwZTogbWFya3R5cGUsXG4gICAgICBlbmNvZGluZzogZW5jLFxuICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICBmaWx0ZXI6IFtdXG4gICAgfSwgdGhlbWUpO1xuICB9O1xuXG4gIEVuY29kaW5nLmZyb21TcGVjID0gZnVuY3Rpb24oc3BlYywgdGhlbWUpIHtcbiAgICByZXR1cm4gbmV3IEVuY29kaW5nKHNwZWMsIHRoZW1lKTtcbiAgfTtcblxuICBwcm90by50b1Nob3J0aGFuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjID0gY29uc3RzLnNob3J0aGFuZDtcbiAgICByZXR1cm4gJ21hcmsnICsgYy5hc3NpZ24gKyB0aGlzLl9tYXJrdHlwZSArXG4gICAgICBjLmRlbGltICsgdmxlbmMuc2hvcnRoYW5kKHRoaXMuX2VuYyk7XG4gIH07XG5cbiAgRW5jb2Rpbmcuc2hvcnRoYW5kID0gZnVuY3Rpb24gKHNwZWMpIHtcbiAgICB2YXIgYyA9IGNvbnN0cy5zaG9ydGhhbmQ7XG4gICAgcmV0dXJuICdtYXJrJyArIGMuYXNzaWduICsgc3BlYy5tYXJrdHlwZSArXG4gICAgICBjLmRlbGltICsgdmxlbmMuc2hvcnRoYW5kKHNwZWMuZW5jb2RpbmcpO1xuICB9O1xuXG4gIEVuY29kaW5nLnNwZWNGcm9tU2hvcnRoYW5kID0gZnVuY3Rpb24oc2hvcnRoYW5kLCBkYXRhLCBjb25maWcsIGV4Y2x1ZGVDb25maWcpIHtcbiAgICByZXR1cm4gRW5jb2RpbmcuZnJvbVNob3J0aGFuZChzaG9ydGhhbmQsIGRhdGEsIGNvbmZpZykudG9TcGVjKGV4Y2x1ZGVDb25maWcpO1xuICB9O1xuXG4gIHByb3RvLnRvU3BlYyA9IGZ1bmN0aW9uKGV4Y2x1ZGVDb25maWcsIGV4Y2x1ZGVEYXRhKSB7XG4gICAgdmFyIGVuYyA9IHV0aWwuZHVwbGljYXRlKHRoaXMuX2VuYyksXG4gICAgICBzcGVjO1xuXG4gICAgc3BlYyA9IHtcbiAgICAgIG1hcmt0eXBlOiB0aGlzLl9tYXJrdHlwZSxcbiAgICAgIGVuY29kaW5nOiBlbmMsXG4gICAgICBmaWx0ZXI6IHRoaXMuX2ZpbHRlclxuICAgIH07XG5cbiAgICBpZiAoIWV4Y2x1ZGVDb25maWcpIHtcbiAgICAgIHNwZWMuY29uZmlnID0gdXRpbC5kdXBsaWNhdGUodGhpcy5fY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAoIWV4Y2x1ZGVEYXRhKSB7XG4gICAgICBzcGVjLmRhdGEgPSB1dGlsLmR1cGxpY2F0ZSh0aGlzLl9kYXRhKTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgZGVmYXVsdHNcbiAgICB2YXIgZGVmYXVsdHMgPSBzY2hlbWEuaW5zdGFudGlhdGUoKTtcbiAgICByZXR1cm4gc2NoZW1hLnV0aWwuc3VidHJhY3Qoc3BlYywgZGVmYXVsdHMpO1xuICB9O1xuXG5cbiAgcHJvdG8ubWFya3R5cGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFya3R5cGU7XG4gIH07XG5cbiAgcHJvdG8uaXMgPSBmdW5jdGlvbihtKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcmt0eXBlID09PSBtO1xuICB9O1xuXG4gIHByb3RvLmhhcyA9IGZ1bmN0aW9uKGVuY1R5cGUpIHtcbiAgICAvLyBlcXVpdmFsZW50IHRvIGNhbGxpbmcgdmxlbmMuaGFzKHRoaXMuX2VuYywgZW5jVHlwZSlcbiAgICByZXR1cm4gdGhpcy5fZW5jW2VuY1R5cGVdLm5hbWUgIT09IHVuZGVmaW5lZDtcbiAgfTtcblxuICBwcm90by5maWVsZCA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF07XG4gIH07XG5cbiAgcHJvdG8uZmlsdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZpbHRlck51bGwgPSBbXSxcbiAgICAgIGZpZWxkcyA9IHRoaXMuZmllbGRzKCksXG4gICAgICBzZWxmID0gdGhpcztcblxuICAgIHV0aWwuZm9yRWFjaChmaWVsZHMsIGZ1bmN0aW9uKGZpZWxkTGlzdCwgZmllbGROYW1lKSB7XG4gICAgICBpZiAoZmllbGROYW1lID09PSAnKicpIHJldHVybjsgLy9jb3VudFxuXG4gICAgICBpZiAoKHNlbGYuY29uZmlnKCdmaWx0ZXJOdWxsJykuUSAmJiBmaWVsZExpc3QuY29udGFpbnNUeXBlW1FdKSB8fFxuICAgICAgICAgIChzZWxmLmNvbmZpZygnZmlsdGVyTnVsbCcpLlQgJiYgZmllbGRMaXN0LmNvbnRhaW5zVHlwZVtUXSkgfHxcbiAgICAgICAgICAoc2VsZi5jb25maWcoJ2ZpbHRlck51bGwnKS5PICYmIGZpZWxkTGlzdC5jb250YWluc1R5cGVbT10pIHx8XG4gICAgICAgICAgKHNlbGYuY29uZmlnKCdmaWx0ZXJOdWxsJykuTiAmJiBmaWVsZExpc3QuY29udGFpbnNUeXBlW05dKSkge1xuICAgICAgICBmaWx0ZXJOdWxsLnB1c2goe1xuICAgICAgICAgIG9wZXJhbmRzOiBbZmllbGROYW1lXSxcbiAgICAgICAgICBvcGVyYXRvcjogJ25vdE51bGwnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZpbHRlck51bGwuY29uY2F0KHRoaXMuX2ZpbHRlcik7XG4gIH07XG5cbiAgLy8gZ2V0IFwiZmllbGRcIiByZWZlcmVuY2UgZm9yIHZlZ2FcbiAgcHJvdG8uZmllbGRSZWYgPSBmdW5jdGlvbihldCwgb3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgIG9wdC5kYXRhID0gIXRoaXMuX3ZlZ2EyICYmIChvcHQuZGF0YSAhPT0gZmFsc2UpO1xuICAgIHJldHVybiB2bGZpZWxkLmZpZWxkUmVmKHRoaXMuX2VuY1tldF0sIG9wdCk7XG4gIH07XG5cbiAgcHJvdG8uZmllbGROYW1lID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5uYW1lO1xuICB9O1xuXG4gIC8qXG4gICAqIHJldHVybiBrZXktdmFsdWUgcGFpcnMgb2YgZmllbGQgbmFtZSBhbmQgbGlzdCBvZiBmaWVsZHMgb2YgdGhhdCBmaWVsZCBuYW1lXG4gICAqL1xuICBwcm90by5maWVsZHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmxlbmMuZmllbGRzKHRoaXMuX2VuYyk7XG4gIH07XG5cbiAgcHJvdG8uZmllbGRUaXRsZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgaWYgKHZsZmllbGQuaXNDb3VudCh0aGlzLl9lbmNbZXRdKSkge1xuICAgICAgcmV0dXJuIHZsZmllbGQuY291bnQuZGlzcGxheU5hbWU7XG4gICAgfVxuICAgIHZhciBmbiA9IHRoaXMuX2VuY1tldF0uYWdncmVnYXRlIHx8IHRoaXMuX2VuY1tldF0udGltZVVuaXQgfHwgKHRoaXMuX2VuY1tldF0uYmluICYmICdiaW4nKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHJldHVybiBmbi50b1VwcGVyQ2FzZSgpICsgJygnICsgdGhpcy5fZW5jW2V0XS5uYW1lICsgJyknO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5uYW1lO1xuICAgIH1cbiAgfTtcblxuICBwcm90by5zY2FsZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0uc2NhbGUgfHwge307XG4gIH07XG5cbiAgcHJvdG8uYXhpcyA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0uYXhpcyB8fCB7fTtcbiAgfTtcblxuICBwcm90by5iYW5kU2l6ZSA9IGZ1bmN0aW9uKGVuY1R5cGUsIHVzZVNtYWxsQmFuZCkge1xuICAgIHVzZVNtYWxsQmFuZCA9IHVzZVNtYWxsQmFuZCB8fFxuICAgICAgLy9pc0JhbmRJblNtYWxsTXVsdGlwbGVzXG4gICAgICAoZW5jVHlwZSA9PT0gWSAmJiB0aGlzLmhhcyhST1cpICYmIHRoaXMuaGFzKFkpKSB8fFxuICAgICAgKGVuY1R5cGUgPT09IFggJiYgdGhpcy5oYXMoQ09MKSAmJiB0aGlzLmhhcyhYKSk7XG5cbiAgICAvLyBpZiBiYW5kLnNpemUgaXMgZXhwbGljaXRseSBzcGVjaWZpZWQsIGZvbGxvdyB0aGUgc3BlY2lmaWNhdGlvbiwgb3RoZXJ3aXNlIGRyYXcgdmFsdWUgZnJvbSBjb25maWcuXG4gICAgcmV0dXJuIHRoaXMuZmllbGQoZW5jVHlwZSkuYmFuZC5zaXplIHx8XG4gICAgICB0aGlzLmNvbmZpZyh1c2VTbWFsbEJhbmQgPyAnc21hbGxCYW5kU2l6ZScgOiAnbGFyZ2VCYW5kU2l6ZScpO1xuICB9O1xuXG4gIHByb3RvLmFnZ3JlZ2F0ZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0uYWdncmVnYXRlO1xuICB9O1xuXG4gIC8vIHJldHVybnMgZmFsc2UgaWYgYmlubmluZyBpcyBkaXNhYmxlZCwgb3RoZXJ3aXNlIGFuIG9iamVjdCB3aXRoIGJpbm5pbmcgcHJvcGVydGllc1xuICBwcm90by5iaW4gPSBmdW5jdGlvbihldCkge1xuICAgIHZhciBiaW4gPSB0aGlzLl9lbmNbZXRdLmJpbjtcbiAgICBpZiAoYmluID09PSB7fSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYmluID09PSB0cnVlKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF4Ymluczogc2NoZW1hLk1BWEJJTlNfREVGQVVMVFxuICAgICAgfTtcbiAgICByZXR1cm4gYmluO1xuICB9O1xuXG4gIHByb3RvLnZhbHVlID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS52YWx1ZTtcbiAgfTtcblxuICBwcm90by5udW1iZXJGb3JtYXQgPSBmdW5jdGlvbihmaWVsZFN0YXRzKSB7XG4gICAgdmFyIGZvcm1hdENvbmZpZyA9IGZpZWxkU3RhdHMubWF4ID4gdGhpcy5jb25maWcoJ21heFNtYWxsTnVtYmVyJykgP1xuICAgICAgJ2xhcmdlTnVtYmVyRm9ybWF0JzogJ3NtYWxsTnVtYmVyRm9ybWF0JztcbiAgICByZXR1cm4gdGhpcy5jb25maWcoZm9ybWF0Q29uZmlnKTtcbiAgfTtcblxuICBwcm90by5zb3J0ID0gZnVuY3Rpb24oZXQsIHN0YXRzKSB7XG4gICAgdmFyIHNvcnQgPSB0aGlzLl9lbmNbZXRdLnNvcnQsXG4gICAgICBlbmMgPSB0aGlzLl9lbmMsXG4gICAgICBpc1R5cGVzID0gdmxmaWVsZC5pc1R5cGVzO1xuXG4gICAgaWYgKCghc29ydCB8fCBzb3J0Lmxlbmd0aD09PTApICYmXG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIEVuY29kaW5nLnRvZ2dsZVNvcnQuc3VwcG9ydCh7ZW5jb2Rpbmc6dGhpcy5fZW5jfSwgc3RhdHMsIHRydWUpICYmIC8vSEFDS1xuICAgICAgICB0aGlzLmNvbmZpZygndG9nZ2xlU29ydCcpID09PSBRXG4gICAgICApIHtcbiAgICAgIHZhciBxRmllbGQgPSBpc1R5cGVzKGVuYy54LCBbTiwgT10pID8gZW5jLnkgOiBlbmMueDtcblxuICAgICAgaWYgKGlzVHlwZXMoZW5jW2V0XSwgW04sIE9dKSkge1xuICAgICAgICBzb3J0ID0gW3tcbiAgICAgICAgICBuYW1lOiBxRmllbGQubmFtZSxcbiAgICAgICAgICBhZ2dyZWdhdGU6IHFGaWVsZC5hZ2dyZWdhdGUsXG4gICAgICAgICAgdHlwZTogcUZpZWxkLnR5cGUsXG4gICAgICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgICAgICB9XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc29ydDtcbiAgfTtcblxuICBwcm90by5tYXAgPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIHZsZW5jLm1hcCh0aGlzLl9lbmMsIGYpO1xuICB9O1xuXG4gIHByb3RvLnJlZHVjZSA9IGZ1bmN0aW9uKGYsIGluaXQpIHtcbiAgICByZXR1cm4gdmxlbmMucmVkdWNlKHRoaXMuX2VuYywgZiwgaW5pdCk7XG4gIH07XG5cbiAgcHJvdG8uZm9yRWFjaCA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gdmxlbmMuZm9yRWFjaCh0aGlzLl9lbmMsIGYpO1xuICB9O1xuXG4gIHByb3RvLnR5cGUgPSBmdW5jdGlvbihldCkge1xuICAgIHJldHVybiB0aGlzLmhhcyhldCkgPyB0aGlzLl9lbmNbZXRdLnR5cGUgOiBudWxsO1xuICB9O1xuXG4gIHByb3RvLmlzVHlwZSA9IGZ1bmN0aW9uKGV0LCB0eXBlKSB7XG4gICAgdmFyIGZpZWxkID0gdGhpcy5maWVsZChldCk7XG4gICAgcmV0dXJuIGZpZWxkICYmIHZsZmllbGQuaXNUeXBlKGZpZWxkLCB0eXBlKTtcbiAgfTtcblxuICBwcm90by5pc1R5cGVzID0gZnVuY3Rpb24oZXQsIHR5cGUpIHtcbiAgICB2YXIgZmllbGQgPSB0aGlzLmZpZWxkKGV0KTtcbiAgICByZXR1cm4gZmllbGQgJiYgdmxmaWVsZC5pc1R5cGVzKGZpZWxkLCB0eXBlKTtcbiAgfTtcblxuICBFbmNvZGluZy5pc09yZGluYWxTY2FsZSA9IGZ1bmN0aW9uKGVuY29kaW5nLCBlbmNUeXBlKSB7XG4gICAgcmV0dXJuIHZsZmllbGQuaXNPcmRpbmFsU2NhbGUoZW5jb2RpbmcuZmllbGQoZW5jVHlwZSkpO1xuICB9O1xuXG4gIEVuY29kaW5nLmlzRGltZW5zaW9uID0gZnVuY3Rpb24oZW5jb2RpbmcsIGVuY1R5cGUpIHtcbiAgICByZXR1cm4gdmxmaWVsZC5pc0RpbWVuc2lvbihlbmNvZGluZy5maWVsZChlbmNUeXBlKSk7XG4gIH07XG5cbiAgRW5jb2RpbmcuaXNNZWFzdXJlID0gZnVuY3Rpb24oZW5jb2RpbmcsIGVuY1R5cGUpIHtcbiAgICByZXR1cm4gdmxmaWVsZC5pc01lYXN1cmUoZW5jb2RpbmcuZmllbGQoZW5jVHlwZSkpO1xuICB9O1xuXG4gIHByb3RvLmlzT3JkaW5hbFNjYWxlID0gZnVuY3Rpb24oZW5jVHlwZSkge1xuICAgIHJldHVybiB0aGlzLmhhcyhlbmNUeXBlKSAmJiBFbmNvZGluZy5pc09yZGluYWxTY2FsZSh0aGlzLCBlbmNUeXBlKTtcbiAgfTtcblxuICBwcm90by5pc0RpbWVuc2lvbiA9IGZ1bmN0aW9uKGVuY1R5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoZW5jVHlwZSkgJiYgRW5jb2RpbmcuaXNEaW1lbnNpb24odGhpcywgZW5jVHlwZSk7XG4gIH07XG5cbiAgcHJvdG8uaXNNZWFzdXJlID0gZnVuY3Rpb24oZW5jVHlwZSkge1xuICAgIHJldHVybiB0aGlzLmhhcyhlbmNUeXBlKSAmJiBFbmNvZGluZy5pc01lYXN1cmUodGhpcywgZW5jVHlwZSk7XG4gIH07XG5cbiAgcHJvdG8uaXNBZ2dyZWdhdGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmxlbmMuaXNBZ2dyZWdhdGUodGhpcy5fZW5jKTtcbiAgfTtcblxuICBFbmNvZGluZy5pc0FnZ3JlZ2F0ZSA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICByZXR1cm4gdmxlbmMuaXNBZ2dyZWdhdGUoc3BlYy5lbmNvZGluZyk7XG4gIH07XG5cbiAgRW5jb2RpbmcuYWx3YXlzTm9PY2NsdXNpb24gPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgLy8gRklYTUUgcmF3IE94USB3aXRoICMgb2Ygcm93cyA9ICMgb2YgT1xuICAgIHJldHVybiB2bGVuYy5pc0FnZ3JlZ2F0ZShzcGVjLmVuY29kaW5nKTtcbiAgfTtcblxuICBFbmNvZGluZy5pc1N0YWNrID0gZnVuY3Rpb24oc3BlYykge1xuICAgIC8vIEZJWE1FIHVwZGF0ZSB0aGlzIG9uY2Ugd2UgaGF2ZSBjb250cm9sIGZvciBzdGFjayAuLi5cbiAgICByZXR1cm4gKHNwZWMubWFya3R5cGUgPT09ICdiYXInIHx8IHNwZWMubWFya3R5cGUgPT09ICdhcmVhJykgJiZcbiAgICAgIHNwZWMuZW5jb2RpbmcuY29sb3I7XG4gIH07XG5cbiAgcHJvdG8uaXNTdGFjayA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIEZJWE1FIHVwZGF0ZSB0aGlzIG9uY2Ugd2UgaGF2ZSBjb250cm9sIGZvciBzdGFjayAuLi5cbiAgICByZXR1cm4gKHRoaXMuaXMoJ2JhcicpIHx8IHRoaXMuaXMoJ2FyZWEnKSkgJiYgdGhpcy5oYXMoJ2NvbG9yJyk7XG4gIH07XG5cbiAgcHJvdG8uY2FyZGluYWxpdHkgPSBmdW5jdGlvbihlbmNUeXBlLCBzdGF0cykge1xuICAgIHJldHVybiB2bGZpZWxkLmNhcmRpbmFsaXR5KHRoaXMuZmllbGQoZW5jVHlwZSksIHN0YXRzLCB0aGlzLmNvbmZpZygnZmlsdGVyTnVsbCcpKTtcbiAgfTtcblxuICBwcm90by5pc1JhdyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy5pc0FnZ3JlZ2F0ZSgpO1xuICB9O1xuXG4gIHByb3RvLmRhdGEgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgPyB0aGlzLl9kYXRhW25hbWVdIDogdGhpcy5fZGF0YTtcbiAgfTtcblxuICAgLy8gcmV0dXJucyB3aGV0aGVyIHRoZSBlbmNvZGluZyBoYXMgdmFsdWVzIGVtYmVkZGVkXG4gIHByb3RvLmhhc1ZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWxzID0gdGhpcy5kYXRhKCd2YWx1ZXMnKTtcbiAgICByZXR1cm4gdmFscyAmJiB2YWxzLmxlbmd0aDtcbiAgfTtcblxuICBwcm90by5jb25maWcgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZ1tuYW1lXTtcbiAgfTtcblxuICBFbmNvZGluZy50cmFuc3Bvc2UgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgdmFyIG9sZGVuYyA9IHNwZWMuZW5jb2RpbmcsXG4gICAgICBlbmMgPSB1dGlsLmR1cGxpY2F0ZShzcGVjLmVuY29kaW5nKTtcbiAgICBlbmMueCA9IG9sZGVuYy55O1xuICAgIGVuYy55ID0gb2xkZW5jLng7XG4gICAgZW5jLnJvdyA9IG9sZGVuYy5jb2w7XG4gICAgZW5jLmNvbCA9IG9sZGVuYy5yb3c7XG4gICAgc3BlYy5lbmNvZGluZyA9IGVuYztcbiAgICByZXR1cm4gc3BlYztcbiAgfTtcblxuICAvLyBGSVhNRTogUkVNT1ZFIGV2ZXJ5dGhpbmcgYmVsb3cgaGVyZVxuXG4gIEVuY29kaW5nLnRvZ2dsZVNvcnQgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgc3BlYy5jb25maWcgPSBzcGVjLmNvbmZpZyB8fCB7fTtcbiAgICBzcGVjLmNvbmZpZy50b2dnbGVTb3J0ID0gc3BlYy5jb25maWcudG9nZ2xlU29ydCA9PT0gUSA/IE4gOiBRO1xuICAgIHJldHVybiBzcGVjO1xuICB9O1xuXG5cbiAgRW5jb2RpbmcudG9nZ2xlU29ydC5kaXJlY3Rpb24gPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgaWYgKCFFbmNvZGluZy50b2dnbGVTb3J0LnN1cHBvcnQoc3BlYykpIHsgcmV0dXJuOyB9XG4gICAgdmFyIGVuYyA9IHNwZWMuZW5jb2Rpbmc7XG4gICAgcmV0dXJuIGVuYy54LnR5cGUgPT09IE4gPyAneCcgOiAneSc7XG4gIH07XG5cbiAgRW5jb2RpbmcudG9nZ2xlU29ydC5tb2RlID0gZnVuY3Rpb24oc3BlYykge1xuICAgIHJldHVybiBzcGVjLmNvbmZpZy50b2dnbGVTb3J0O1xuICB9O1xuXG4gIEVuY29kaW5nLnRvZ2dsZVNvcnQuc3VwcG9ydCA9IGZ1bmN0aW9uKHNwZWMsIHN0YXRzKSB7XG4gICAgdmFyIGVuYyA9IHNwZWMuZW5jb2RpbmcsXG4gICAgICBpc1R5cGVzID0gdmxmaWVsZC5pc1R5cGVzO1xuXG4gICAgaWYgKHZsZW5jLmhhcyhlbmMsIFJPVykgfHwgdmxlbmMuaGFzKGVuYywgQ09MKSB8fFxuICAgICAgIXZsZW5jLmhhcyhlbmMsIFgpIHx8ICF2bGVuYy5oYXMoZW5jLCBZKSB8fFxuICAgICAgIUVuY29kaW5nLmFsd2F5c05vT2NjbHVzaW9uKHNwZWMsIHN0YXRzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAoIGlzVHlwZXMoZW5jLngsIFtOLE9dKSAmJiB2bGZpZWxkLmlzTWVhc3VyZShlbmMueSkpID8gJ3gnIDpcbiAgICAgICggaXNUeXBlcyhlbmMueSwgW04sT10pICYmIHZsZmllbGQuaXNNZWFzdXJlKGVuYy54KSkgPyAneScgOiBmYWxzZTtcbiAgfTtcblxuICBFbmNvZGluZy50b2dnbGVGaWx0ZXJOdWxsTyA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICBzcGVjLmNvbmZpZyA9IHNwZWMuY29uZmlnIHx8IHt9O1xuICAgIHNwZWMuY29uZmlnLmZpbHRlck51bGwgPSBzcGVjLmNvbmZpZy5maWx0ZXJOdWxsIHx8IHsgLy9GSVhNRVxuICAgICAgVDogdHJ1ZSxcbiAgICAgIFE6IHRydWVcbiAgICB9O1xuICAgIHNwZWMuY29uZmlnLmZpbHRlck51bGwuTyA9ICFzcGVjLmNvbmZpZy5maWx0ZXJOdWxsLk87XG4gICAgcmV0dXJuIHNwZWM7XG4gIH07XG5cbiAgRW5jb2RpbmcudG9nZ2xlRmlsdGVyTnVsbE8uc3VwcG9ydCA9IGZ1bmN0aW9uKHNwZWMsIHN0YXRzKSB7XG4gICAgdmFyIGZpZWxkcyA9IHZsZW5jLmZpZWxkcyhzcGVjLmVuY29kaW5nKTtcbiAgICBmb3IgKHZhciBmaWVsZE5hbWUgaW4gZmllbGRzKSB7XG4gICAgICB2YXIgZmllbGRMaXN0ID0gZmllbGRzW2ZpZWxkTmFtZV07XG4gICAgICBpZiAoZmllbGRMaXN0LmNvbnRhaW5zVHlwZS5PICYmIGZpZWxkTmFtZSBpbiBzdGF0cyAmJiBzdGF0c1tmaWVsZE5hbWVdLm51bGxzID4gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHJldHVybiBFbmNvZGluZztcbn0pKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYWdncmVnYXRlcztcblxuZnVuY3Rpb24gYWdncmVnYXRlcyhkYXRhVGFibGUsIGVuY29kaW5nLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gIHZhciBkaW1zID0ge30sIG1lYXMgPSB7fSwgZGV0YWlsID0ge30sIGZhY2V0cyA9IHt9O1xuXG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICBpZiAoZmllbGQuYWdncmVnYXRlKSB7XG4gICAgICBpZiAoZmllbGQuYWdncmVnYXRlID09PSAnY291bnQnKSB7XG4gICAgICAgIG1lYXMuY291bnQgPSB7b3A6ICdjb3VudCcsIGZpZWxkOiAnKid9O1xuICAgICAgfWVsc2Uge1xuICAgICAgICBtZWFzW2ZpZWxkLmFnZ3JlZ2F0ZSArICd8JysgZmllbGQubmFtZV0gPSB7XG4gICAgICAgICAgb3A6IGZpZWxkLmFnZ3JlZ2F0ZSxcbiAgICAgICAgICBmaWVsZDogZW5jb2RpbmcuZmllbGRSZWYoZW5jVHlwZSwge25vZm46IHRydWV9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkaW1zW2ZpZWxkLm5hbWVdID0gZW5jb2RpbmcuZmllbGRSZWYoZW5jVHlwZSk7XG4gICAgICBpZiAoZW5jVHlwZSA9PSBST1cgfHwgZW5jVHlwZSA9PSBDT0wpIHtcbiAgICAgICAgZmFjZXRzW2ZpZWxkLm5hbWVdID0gZGltc1tmaWVsZC5uYW1lXTtcbiAgICAgIH1lbHNlIGlmIChlbmNUeXBlICE9PSBYICYmIGVuY1R5cGUgIT09IFkpIHtcbiAgICAgICAgZGV0YWlsW2ZpZWxkLm5hbWVdID0gZGltc1tmaWVsZC5uYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBkaW1zID0gdXRpbC52YWxzKGRpbXMpO1xuICBtZWFzID0gdXRpbC52YWxzKG1lYXMpO1xuXG4gIGlmIChtZWFzLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoIWRhdGFUYWJsZS50cmFuc2Zvcm0pIGRhdGFUYWJsZS50cmFuc2Zvcm0gPSBbXTtcbiAgICBkYXRhVGFibGUudHJhbnNmb3JtLnB1c2goe1xuICAgICAgdHlwZTogJ2FnZ3JlZ2F0ZScsXG4gICAgICBncm91cGJ5OiBkaW1zLFxuICAgICAgZmllbGRzOiBtZWFzXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkZXRhaWxzOiB1dGlsLnZhbHMoZGV0YWlsKSxcbiAgICBkaW1zOiBkaW1zLFxuICAgIGZhY2V0czogdXRpbC52YWxzKGZhY2V0cyksXG4gICAgYWdncmVnYXRlZDogbWVhcy5sZW5ndGggPiAwXG4gIH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIHNldHRlciA9IHV0aWwuc2V0dGVyLFxuICBnZXR0ZXIgPSB1dGlsLmdldHRlcixcbiAgdGltZSA9IHJlcXVpcmUoJy4vdGltZScpO1xuXG52YXIgYXhpcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmF4aXMubmFtZXMgPSBmdW5jdGlvbihwcm9wcykge1xuICByZXR1cm4gdXRpbC5rZXlzKHV0aWwua2V5cyhwcm9wcykucmVkdWNlKGZ1bmN0aW9uKGEsIHgpIHtcbiAgICB2YXIgcyA9IHByb3BzW3hdLnNjYWxlO1xuICAgIGlmIChzID09PSBYIHx8IHMgPT09IFkpIGFbcHJvcHNbeF0uc2NhbGVdID0gMTtcbiAgICByZXR1cm4gYTtcbiAgfSwge30pKTtcbn07XG5cbmF4aXMuZGVmcyA9IGZ1bmN0aW9uKG5hbWVzLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cywgb3B0KSB7XG4gIHJldHVybiBuYW1lcy5yZWR1Y2UoZnVuY3Rpb24oYSwgbmFtZSkge1xuICAgIGEucHVzaChheGlzLmRlZihuYW1lLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cywgb3B0KSk7XG4gICAgcmV0dXJuIGE7XG4gIH0sIFtdKTtcbn07XG5cbmF4aXMuZGVmID0gZnVuY3Rpb24obmFtZSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMsIG9wdCkge1xuICB2YXIgaXNDb2wgPSBuYW1lID09IENPTCxcbiAgICBpc1JvdyA9IG5hbWUgPT0gUk9XLFxuICAgIHR5cGUgPSBpc0NvbCA/ICd4JyA6IGlzUm93ID8gJ3knIDogbmFtZTtcblxuICB2YXIgZGVmID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgc2NhbGU6IG5hbWUsXG4gICAgcHJvcGVydGllczoge30sXG4gICAgbGF5ZXI6IGVuY29kaW5nLmZpZWxkKG5hbWUpLmF4aXMubGF5ZXIsXG4gICAgb3JpZW50OiBheGlzLm9yaWVudChuYW1lLCBlbmNvZGluZywgc3RhdHMpXG4gIH07XG5cbiAgLy8gQWRkIGF4aXMgbGFiZWwgY3VzdG9tIHNjYWxlIChmb3IgYmluIC8gdGltZSlcbiAgZGVmID0gYXhpcy5sYWJlbHMuc2NhbGUoZGVmLCBlbmNvZGluZywgbmFtZSk7XG4gIGRlZiA9IGF4aXMubGFiZWxzLmZvcm1hdChkZWYsIG5hbWUsIGVuY29kaW5nLCBzdGF0cyk7XG5cbiAgLy8gZm9yIHgtYXhpcywgc2V0IHRpY2tzIGZvciBRIG9yIHJvdGF0ZSBzY2FsZSBmb3Igb3JkaW5hbCBzY2FsZVxuICBpZiAobmFtZSA9PSBYKSB7XG4gICAgaWYgKGVuY29kaW5nLmlzRGltZW5zaW9uKFgpIHx8IGVuY29kaW5nLmlzVHlwZShYLCBUKSkge1xuICAgICAgLy8gVE9ETyhrYW5pdHcpOiBKdWwgMTksIDIwMTUgLSAjNTA2IGFkZCBjb25kaXRpb24gZm9yIHJvdGF0aW9uXG4gICAgICBkZWYgPSBheGlzLmxhYmVscy5yb3RhdGUoZGVmKTtcbiAgICB9IGVsc2UgeyAvLyBRXG4gICAgICBkZWYudGlja3MgPSBlbmNvZGluZy5maWVsZChuYW1lKS5heGlzLnRpY2tzO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRpdGxlT2Zmc2V0IGRlcGVuZHMgb24gbGFiZWxzIHJvdGF0aW9uXG4gIGRlZi50aXRsZU9mZnNldCA9IGF4aXMudGl0bGVPZmZzZXQoZW5jb2RpbmcsIGxheW91dCwgbmFtZSk7XG5cbiAgLy9kZWYub2Zmc2V0IGlzIHVzZWQgaW4gYXhpcy5ncmlkXG4gIGlmKGlzUm93KSBkZWYub2Zmc2V0ID0gYXhpcy50aXRsZU9mZnNldChlbmNvZGluZywgbGF5b3V0LCBZKSArIDIwO1xuICAvLyBGSVhNRShrYW5pdHcpOiBKdWwgMTksIDIwMTUgLSBvZmZzZXQgZm9yIGNvbHVtbiB3aGVuIHggaXMgcHV0IG9uIHRvcFxuXG4gIGRlZiA9IGF4aXMuZ3JpZChkZWYsIG5hbWUsIGVuY29kaW5nLCBsYXlvdXQpO1xuICBkZWYgPSBheGlzLnRpdGxlKGRlZiwgbmFtZSwgZW5jb2RpbmcsIGxheW91dCwgb3B0KTtcblxuICBpZiAoaXNSb3cgfHwgaXNDb2wpIGRlZiA9IGF4aXMuaGlkZVRpY2tzKGRlZik7XG5cbiAgcmV0dXJuIGRlZjtcbn07XG5cbmF4aXMub3JpZW50ID0gZnVuY3Rpb24obmFtZSwgZW5jb2RpbmcsIHN0YXRzKSB7XG4gIHZhciBvcmllbnQgPSBlbmNvZGluZy5maWVsZChuYW1lKS5heGlzLm9yaWVudDtcbiAgaWYgKG9yaWVudCkgcmV0dXJuIG9yaWVudDtcblxuICBpZiAobmFtZT09PUNPTCkgcmV0dXJuICd0b3AnO1xuXG4gIC8vIHgtYXhpcyBmb3IgbG9uZyB5IC0gcHV0IG9uIHRvcFxuICBpZiAobmFtZT09PVggJiYgZW5jb2RpbmcuaGFzKFkpICYmIGVuY29kaW5nLmlzT3JkaW5hbFNjYWxlKFkpICYmIGVuY29kaW5nLmNhcmRpbmFsaXR5KFksIHN0YXRzKSA+IDMwKSB7XG4gICAgcmV0dXJuICd0b3AnO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmF4aXMuZ3JpZCA9IGZ1bmN0aW9uKGRlZiwgbmFtZSwgZW5jb2RpbmcsIGxheW91dCkge1xuICB2YXIgY2VsbFBhZGRpbmcgPSBsYXlvdXQuY2VsbFBhZGRpbmcsXG4gICAgaXNDb2wgPSBuYW1lID09IENPTCxcbiAgICBpc1JvdyA9IG5hbWUgPT0gUk9XO1xuXG4gIGlmIChlbmNvZGluZy5heGlzKG5hbWUpLmdyaWQpIHtcbiAgICBkZWYuZ3JpZCA9IHRydWU7XG5cbiAgICBpZiAoaXNDb2wpIHtcbiAgICAgIC8vIHNldCBncmlkIHByb3BlcnR5IC0tIHB1dCB0aGUgbGluZXMgb24gdGhlIHJpZ2h0IHRoZSBjZWxsXG4gICAgICBkZWYucHJvcGVydGllcy5ncmlkID0ge1xuICAgICAgICB4OiB7XG4gICAgICAgICAgb2Zmc2V0OiBsYXlvdXQuY2VsbFdpZHRoICogKDErIGNlbGxQYWRkaW5nLzIuMCksXG4gICAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZShzKSAtLSB2ZWdhIGRvZXNuJ3QgZG8gcmVjdXJzaXZlIG1lcmdlXG4gICAgICAgICAgc2NhbGU6ICdjb2wnXG4gICAgICAgIH0sXG4gICAgICAgIHk6IHtcbiAgICAgICAgICB2YWx1ZTogLWxheW91dC5jZWxsSGVpZ2h0ICogKGNlbGxQYWRkaW5nLzIpLFxuICAgICAgICB9LFxuICAgICAgICBzdHJva2U6IHsgdmFsdWU6IGVuY29kaW5nLmNvbmZpZygnY2VsbEdyaWRDb2xvcicpIH0sXG4gICAgICAgIG9wYWNpdHk6IHsgdmFsdWU6IGVuY29kaW5nLmNvbmZpZygnY2VsbEdyaWRPcGFjaXR5JykgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGlzUm93KSB7XG4gICAgICAvLyBzZXQgZ3JpZCBwcm9wZXJ0eSAtLSBwdXQgdGhlIGxpbmVzIG9uIHRoZSB0b3BcbiAgICAgIGRlZi5wcm9wZXJ0aWVzLmdyaWQgPSB7XG4gICAgICAgIHk6IHtcbiAgICAgICAgICBvZmZzZXQ6IC1sYXlvdXQuY2VsbEhlaWdodCAqIChjZWxsUGFkZGluZy8yKSxcbiAgICAgICAgICAvLyBkZWZhdWx0IHZhbHVlKHMpIC0tIHZlZ2EgZG9lc24ndCBkbyByZWN1cnNpdmUgbWVyZ2VcbiAgICAgICAgICBzY2FsZTogJ3JvdydcbiAgICAgICAgfSxcbiAgICAgICAgeDoge1xuICAgICAgICAgIHZhbHVlOiBkZWYub2Zmc2V0XG4gICAgICAgIH0sXG4gICAgICAgIHgyOiB7XG4gICAgICAgICAgb2Zmc2V0OiBkZWYub2Zmc2V0ICsgKGxheW91dC5jZWxsV2lkdGggKiAwLjA1KSxcbiAgICAgICAgICAvLyBkZWZhdWx0IHZhbHVlKHMpIC0tIHZlZ2EgZG9lc24ndCBkbyByZWN1cnNpdmUgbWVyZ2VcbiAgICAgICAgICBncm91cDogJ21hcmsuZ3JvdXAud2lkdGgnLFxuICAgICAgICAgIG11bHQ6IDFcbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlOiB7IHZhbHVlOiBlbmNvZGluZy5jb25maWcoJ2NlbGxHcmlkQ29sb3InKSB9LFxuICAgICAgICBvcGFjaXR5OiB7IHZhbHVlOiBlbmNvZGluZy5jb25maWcoJ2NlbGxHcmlkT3BhY2l0eScpIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZi5wcm9wZXJ0aWVzLmdyaWQgPSB7XG4gICAgICAgIHN0cm9rZTogeyB2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdncmlkQ29sb3InKSB9LFxuICAgICAgICBvcGFjaXR5OiB7IHZhbHVlOiBlbmNvZGluZy5jb25maWcoJ2dyaWRPcGFjaXR5JykgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlZjtcbn07XG5cbmF4aXMuaGlkZVRpY2tzID0gZnVuY3Rpb24oZGVmKSB7XG4gIGRlZi5wcm9wZXJ0aWVzLnRpY2tzID0ge29wYWNpdHk6IHt2YWx1ZTogMH19O1xuICBkZWYucHJvcGVydGllcy5tYWpvclRpY2tzID0ge29wYWNpdHk6IHt2YWx1ZTogMH19O1xuICBkZWYucHJvcGVydGllcy5heGlzID0ge29wYWNpdHk6IHt2YWx1ZTogMH19O1xuICByZXR1cm4gZGVmO1xufTtcblxuYXhpcy50aXRsZSA9IGZ1bmN0aW9uIChkZWYsIG5hbWUsIGVuY29kaW5nLCBsYXlvdXQpIHtcbiAgdmFyIGF4ID0gZW5jb2RpbmcuZmllbGQobmFtZSkuYXhpcztcblxuICBpZiAoYXgudGl0bGUpIHtcbiAgICBkZWYudGl0bGUgPSBheC50aXRsZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBub3QgZGVmaW5lZCwgYXV0b21hdGljYWxseSBkZXRlcm1pbmUgYXhpcyB0aXRsZSBmcm9tIGZpZWxkIGRlZlxuICAgIHZhciBmaWVsZFRpdGxlID0gZW5jb2RpbmcuZmllbGRUaXRsZShuYW1lKSxcbiAgICAgIG1heExlbmd0aDtcblxuICAgIGlmIChheC50aXRsZU1heExlbmd0aCkge1xuICAgICAgbWF4TGVuZ3RoID0gYXgudGl0bGVNYXhMZW5ndGg7XG4gICAgfSBlbHNlIGlmIChuYW1lPT09WCkge1xuICAgICAgbWF4TGVuZ3RoID0gbGF5b3V0LmNlbGxXaWR0aCAvIGVuY29kaW5nLmNvbmZpZygnY2hhcmFjdGVyV2lkdGgnKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFkpIHtcbiAgICAgIG1heExlbmd0aCA9IGxheW91dC5jZWxsSGVpZ2h0IC8gZW5jb2RpbmcuY29uZmlnKCdjaGFyYWN0ZXJXaWR0aCcpO1xuICAgIH1cblxuICAgIGRlZi50aXRsZSA9IG1heExlbmd0aCA/IHV0aWwudHJ1bmNhdGUoZmllbGRUaXRsZSwgbWF4TGVuZ3RoKSA6IGZpZWxkVGl0bGU7XG4gIH1cblxuICBpZiAobmFtZSA9PT0gUk9XKSB7XG4gICAgZGVmLnByb3BlcnRpZXMudGl0bGUgPSB7XG4gICAgICBhbmdsZToge3ZhbHVlOiAwfSxcbiAgICAgIGFsaWduOiB7dmFsdWU6ICdyaWdodCd9LFxuICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogJ21pZGRsZSd9LFxuICAgICAgZHk6IHt2YWx1ZTogKC1sYXlvdXQuaGVpZ2h0LzIpIC0yMH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGRlZjtcbn07XG5cbmF4aXMubGFiZWxzID0ge307XG5cbi8qKiBhZGQgY3VzdG9tIGxhYmVsIGZvciB0aW1lIHR5cGUgYW5kIGJpbiAqL1xuYXhpcy5sYWJlbHMuc2NhbGUgPSBmdW5jdGlvbihkZWYsIGVuY29kaW5nLCBuYW1lKSB7XG4gIC8vIHRpbWVcbiAgdmFyIHRpbWVVbml0ID0gZW5jb2RpbmcuZmllbGQobmFtZSkudGltZVVuaXQ7XG4gIGlmIChlbmNvZGluZy5pc1R5cGUobmFtZSwgVCkgJiYgdGltZVVuaXQgJiYgKHRpbWUuaGFzU2NhbGUodGltZVVuaXQpKSkge1xuICAgIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsJ2xhYmVscycsJ3RleHQnLCdzY2FsZSddLCAndGltZS0nKyB0aW1lVW5pdCk7XG4gIH1cbiAgLy8gRklYTUUgYmluXG4gIHJldHVybiBkZWY7XG59O1xuXG4vKipcbiAqIERldGVybWluZSBudW1iZXIgZm9ybWF0IG9yIHRydW5jYXRlIGlmIG1heExhYmVsIGxlbmd0aCBpcyBwcmVzZW50ZWQuXG4gKi9cbmF4aXMubGFiZWxzLmZvcm1hdCA9IGZ1bmN0aW9uIChkZWYsIG5hbWUsIGVuY29kaW5nLCBzdGF0cykge1xuICB2YXIgZmllbGRTdGF0cyA9IHN0YXRzW2VuY29kaW5nLmZpZWxkKG5hbWUpLm5hbWVdO1xuXG4gIGlmIChlbmNvZGluZy5heGlzKG5hbWUpLmZvcm1hdCkge1xuICAgIGRlZi5mb3JtYXQgPSBlbmNvZGluZy5heGlzKG5hbWUpLmZvcm1hdDtcbiAgfSBlbHNlIGlmIChlbmNvZGluZy5pc1R5cGUobmFtZSwgUSkgfHwgZmllbGRTdGF0cy50eXBlID09PSAnbnVtYmVyJykge1xuICAgIGRlZi5mb3JtYXQgPSBlbmNvZGluZy5udW1iZXJGb3JtYXQoZmllbGRTdGF0cyk7XG4gIH0gZWxzZSBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFQpKSB7XG4gICAgdmFyIHRpbWVVbml0ID0gZW5jb2RpbmcuZmllbGQobmFtZSkudGltZVVuaXQ7XG4gICAgaWYgKCF0aW1lVW5pdCkge1xuICAgICAgZGVmLmZvcm1hdCA9IGVuY29kaW5nLmNvbmZpZygndGltZUZvcm1hdCcpO1xuICAgIH0gZWxzZSBpZiAodGltZVVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgZGVmLmZvcm1hdCA9ICdkJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoZW5jb2RpbmcuaXNUeXBlcyhuYW1lLCBbTiwgT10pICYmIGVuY29kaW5nLmF4aXMobmFtZSkubWF4TGFiZWxMZW5ndGgpIHtcbiAgICBzZXR0ZXIoZGVmLFxuICAgICAgWydwcm9wZXJ0aWVzJywnbGFiZWxzJywndGV4dCcsJ3RlbXBsYXRlJ10sXG4gICAgICAne3tkYXRhIHwgdHJ1bmNhdGU6JyArIGVuY29kaW5nLmF4aXMobmFtZSkubWF4TGFiZWxMZW5ndGggKyAnfX0nXG4gICAgICApO1xuICB9XG5cbiAgcmV0dXJuIGRlZjtcbn07XG5cbmF4aXMubGFiZWxzLnJvdGF0ZSA9IGZ1bmN0aW9uKGRlZikge1xuIHZhciBhbGlnbiA9IGRlZi5vcmllbnQgPT09J3RvcCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsJ2xhYmVscycsICdhbmdsZScsICd2YWx1ZSddLCAyNzApO1xuIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsJ2xhYmVscycsICdhbGlnbicsICd2YWx1ZSddLCBhbGlnbik7XG4gc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywnbGFiZWxzJywgJ2Jhc2VsaW5lJywgJ3ZhbHVlJ10sICdtaWRkbGUnKTtcbiByZXR1cm4gZGVmO1xufTtcblxuYXhpcy50aXRsZU9mZnNldCA9IGZ1bmN0aW9uIChlbmNvZGluZywgbGF5b3V0LCBuYW1lKSB7XG4gIC8vIHJldHVybiBzcGVjaWZpZWQgdmFsdWUgaWYgc3BlY2lmaWVkXG4gIHZhciB2YWx1ZSA9IGVuY29kaW5nLmF4aXMobmFtZSkudGl0bGVPZmZzZXQ7XG4gIGlmICh2YWx1ZSkgIHJldHVybiB2YWx1ZTtcblxuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAvL0ZJWE1FIG1ha2UgdGhpcyBhZGp1c3RhYmxlXG4gICAgY2FzZSBST1c6IHJldHVybiAwO1xuICAgIGNhc2UgQ09MOiByZXR1cm4gMzU7XG4gIH1cbiAgcmV0dXJuIGdldHRlcihsYXlvdXQsIFtuYW1lLCAnYXhpc1RpdGxlT2Zmc2V0J10pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbm5pbmc7XG5cbmZ1bmN0aW9uIGJpbm5pbmcoZGF0YVRhYmxlLCBlbmNvZGluZywgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcblxuICBpZiAoIWRhdGFUYWJsZS50cmFuc2Zvcm0pIGRhdGFUYWJsZS50cmFuc2Zvcm0gPSBbXTtcblxuICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBlbmNUeXBlKSB7XG4gICAgaWYgKGVuY29kaW5nLmJpbihlbmNUeXBlKSkge1xuICAgICAgZGF0YVRhYmxlLnRyYW5zZm9ybS5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2JpbicsXG4gICAgICAgIGZpZWxkOiBlbmNvZGluZy5maWVsZFJlZihlbmNUeXBlLCB7bm9mbjogdHJ1ZX0pLFxuICAgICAgICBvdXRwdXQ6IGVuY29kaW5nLmZpZWxkUmVmKGVuY1R5cGUpLFxuICAgICAgICBtYXhiaW5zOiBlbmNvZGluZy5iaW4oZW5jVHlwZSkubWF4Ymluc1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGF0YVRhYmxlO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3VtbWFyeSA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZGF0YWxpYi9zcmMvc3RhdHMnKS5zdW1tYXJ5O1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciBjb21waWxlciA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnZhciBFbmNvZGluZyA9IHJlcXVpcmUoJy4uL0VuY29kaW5nJyksXG4gIGF4aXMgPSBjb21waWxlci5heGlzID0gcmVxdWlyZSgnLi9heGlzJyksXG4gIGZpbHRlciA9IGNvbXBpbGVyLmZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyksXG4gIGxlZ2VuZCA9IGNvbXBpbGVyLmxlZ2VuZCA9IHJlcXVpcmUoJy4vbGVnZW5kJyksXG4gIG1hcmtzID0gY29tcGlsZXIubWFya3MgPSByZXF1aXJlKCcuL21hcmtzJyksXG4gIHNjYWxlID0gY29tcGlsZXIuc2NhbGUgPSByZXF1aXJlKCcuL3NjYWxlJyk7XG5cbmNvbXBpbGVyLmFnZ3JlZ2F0ZSA9IHJlcXVpcmUoJy4vYWdncmVnYXRlJyk7XG5jb21waWxlci5iaW4gPSByZXF1aXJlKCcuL2JpbicpO1xuY29tcGlsZXIuZmFjZXQgPSByZXF1aXJlKCcuL2ZhY2V0Jyk7XG5jb21waWxlci5ncm91cCA9IHJlcXVpcmUoJy4vZ3JvdXAnKTtcbmNvbXBpbGVyLmxheW91dCA9IHJlcXVpcmUoJy4vbGF5b3V0Jyk7XG5jb21waWxlci5zb3J0ID0gcmVxdWlyZSgnLi9zb3J0Jyk7XG5jb21waWxlci5zdGFjayA9IHJlcXVpcmUoJy4vc3RhY2snKTtcbmNvbXBpbGVyLnN0eWxlID0gcmVxdWlyZSgnLi9zdHlsZScpO1xuY29tcGlsZXIuc3ViZmFjZXQgPSByZXF1aXJlKCcuL3N1YmZhY2V0Jyk7XG5jb21waWxlci50ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcbmNvbXBpbGVyLnRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKTtcblxuY29tcGlsZXIuY29tcGlsZSA9IGZ1bmN0aW9uIChzcGVjLCBzdGF0cywgdGhlbWUpIHtcbiAgcmV0dXJuIGNvbXBpbGVyLmNvbXBpbGVFbmNvZGluZyhFbmNvZGluZy5mcm9tU3BlYyhzcGVjLCB0aGVtZSksIHN0YXRzKTtcbn07XG5cbmNvbXBpbGVyLnNob3J0aGFuZCA9IGZ1bmN0aW9uIChzaG9ydGhhbmQsIHN0YXRzLCBjb25maWcsIHRoZW1lKSB7XG4gIHJldHVybiBjb21waWxlci5jb21waWxlRW5jb2RpbmcoRW5jb2RpbmcuZnJvbVNob3J0aGFuZChzaG9ydGhhbmQsIGNvbmZpZywgdGhlbWUpLCBzdGF0cyk7XG59O1xuXG5jb21waWxlci5jb21waWxlRW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXRzKSB7XG4gIC8vIG5vIG5lZWQgdG8gcGFzcyBzdGF0cyBpZiB5b3UgcGFzcyBpbiB0aGUgZGF0YVxuICBpZiAoIXN0YXRzICYmIGVuY29kaW5nLmhhc1ZhbHVlcygpKSB7XG4gICAgc3RhdHMgPSBzdW1tYXJ5KGVuY29kaW5nLmRhdGEoJ3ZhbHVlcycpKS5yZWR1Y2UoZnVuY3Rpb24ocywgcCkge1xuICAgICAgc1twLmZpZWxkXSA9IHA7XG4gICAgICByZXR1cm4gcztcbiAgICB9LCB7fSk7XG4gIH1cblxuICB2YXIgbGF5b3V0ID0gY29tcGlsZXIubGF5b3V0KGVuY29kaW5nLCBzdGF0cyksXG4gICAgc3BlYyA9IGNvbXBpbGVyLnRlbXBsYXRlKGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKTtcblxuICAvLyAuZGF0YSByZWxhdGVkIHN0dWZmXG4gIHZhciByYXdUYWJsZSA9IHNwZWMuZGF0YVswXSxcbiAgICBkYXRhVGFibGUgPSBzcGVjLmRhdGFbMV07XG5cbiAgcmF3VGFibGUgPSBmaWx0ZXIuYWRkRmlsdGVycyhyYXdUYWJsZSwgZW5jb2RpbmcpOyAvLyBtb2RpZnkgcmF3VGFibGVcbiAgc3BlYyA9IGNvbXBpbGVyLnRpbWUoc3BlYywgZW5jb2RpbmcpOyAgICAgICAgICAgICAgLy8gbW9kaWZ5IHJhd1RhYmxlLCBhZGQgc2NhbGVzXG4gIGRhdGFUYWJsZSA9IGNvbXBpbGVyLmJpbihkYXRhVGFibGUsIGVuY29kaW5nKTsgICAgIC8vIG1vZGlmeSBkYXRhVGFibGVcbiAgdmFyIGFnZ1Jlc3VsdCA9IGNvbXBpbGVyLmFnZ3JlZ2F0ZShkYXRhVGFibGUsIGVuY29kaW5nKTsgLy8gbW9kaWZ5IGRhdGFUYWJsZVxuICB2YXIgc29ydGluZyA9IGNvbXBpbGVyLnNvcnQoc3BlYy5kYXRhLCBlbmNvZGluZywgc3RhdHMpOyAvLyBhcHBlbmQgbmV3IGRhdGFcblxuICAvLyBtYXJrc1xuICB2YXIgc3R5bGUgPSBjb21waWxlci5zdHlsZShlbmNvZGluZywgc3RhdHMpLFxuICAgIGdyb3VwID0gc3BlYy5tYXJrc1swXSxcbiAgICBtYXJrID0gbWFya3NbZW5jb2RpbmcubWFya3R5cGUoKV0sXG4gICAgbWRlZnMgPSBtYXJrcy5kZWYobWFyaywgZW5jb2RpbmcsIGxheW91dCwgc3R5bGUsIHN0YXRzKSxcbiAgICBtZGVmID0gbWRlZnNbMF07ICAvLyBUT0RPOiByZW1vdmUgdGhpcyBkaXJ0eSBoYWNrIGJ5IHJlZmFjdG9yaW5nIHRoZSB3aG9sZSBmbG93XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZGVmcy5sZW5ndGg7IGkrKykge1xuICAgIGdyb3VwLm1hcmtzLnB1c2gobWRlZnNbaV0pO1xuICB9XG5cbiAgdmFyIGxpbmVUeXBlID0gbWFya3NbZW5jb2RpbmcubWFya3R5cGUoKV0ubGluZTtcblxuICAvLyBoYW5kbGUgc3ViZmFjZXRzXG5cbiAgdmFyIGRldGFpbHMgPSBhZ2dSZXN1bHQuZGV0YWlscyxcbiAgICBoYXNEZXRhaWxzID0gZGV0YWlscyAmJiBkZXRhaWxzLmxlbmd0aCA+IDAsXG4gICAgc3RhY2sgPSBoYXNEZXRhaWxzICYmIGNvbXBpbGVyLnN0YWNrKHNwZWMuZGF0YSwgZW5jb2RpbmcsIG1kZWYsIGFnZ1Jlc3VsdC5mYWNldHMpOyAvLyBtb2RpZnkgc3BlYy5kYXRhLCBtZGVmLntmcm9tLHByb3BlcnRpZXN9XG5cbiAgaWYgKGhhc0RldGFpbHMgJiYgKHN0YWNrIHx8IGxpbmVUeXBlKSkge1xuICAgIC8vc3ViZmFjZXQgdG8gZ3JvdXAgc3RhY2sgLyBsaW5lIHRvZ2V0aGVyIGluIG9uZSBncm91cFxuICAgIGNvbXBpbGVyLnN1YmZhY2V0KGdyb3VwLCBtZGVmLCBkZXRhaWxzLCBzdGFjaywgZW5jb2RpbmcpO1xuICB9XG5cbiAgLy8gYXV0by1zb3J0IGxpbmUvYXJlYSB2YWx1ZXNcbiAgLy9UT0RPKGthbml0dyk6IGhhdmUgc29tZSBjb25maWcgdG8gdHVybiBvZmYgYXV0by1zb3J0IGZvciBsaW5lIChmb3IgbGluZSBjaGFydCB0aGF0IGVuY29kZXMgdGVtcG9yYWwgaW5mb3JtYXRpb24pXG4gIGlmIChsaW5lVHlwZSkge1xuICAgIHZhciBmID0gKGVuY29kaW5nLmlzTWVhc3VyZShYKSAmJiBlbmNvZGluZy5pc0RpbWVuc2lvbihZKSkgPyBZIDogWDtcbiAgICBpZiAoIW1kZWYuZnJvbSkgbWRlZi5mcm9tID0ge307XG4gICAgLy8gVE9ETzogd2h5IC0gP1xuICAgIG1kZWYuZnJvbS50cmFuc2Zvcm0gPSBbe3R5cGU6ICdzb3J0JywgYnk6ICctJyArIGVuY29kaW5nLmZpZWxkUmVmKGYpfV07XG4gIH1cblxuICAvLyBTbWFsbCBNdWx0aXBsZXNcbiAgaWYgKGVuY29kaW5nLmhhcyhST1cpIHx8IGVuY29kaW5nLmhhcyhDT0wpKSB7XG4gICAgc3BlYyA9IGNvbXBpbGVyLmZhY2V0KGdyb3VwLCBlbmNvZGluZywgbGF5b3V0LCBzdHlsZSwgc29ydGluZywgc3BlYywgbWRlZiwgc3RhY2ssIHN0YXRzKTtcbiAgICBzcGVjLmxlZ2VuZHMgPSBsZWdlbmQuZGVmcyhlbmNvZGluZyk7XG4gIH0gZWxzZSB7XG4gICAgZ3JvdXAuc2NhbGVzID0gc2NhbGUuZGVmcyhzY2FsZS5uYW1lcyhtZGVmLnByb3BlcnRpZXMudXBkYXRlKSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMsIHN0eWxlLCBzb3J0aW5nLCB7c3RhY2s6IHN0YWNrfSk7XG4gICAgZ3JvdXAuYXhlcyA9IGF4aXMuZGVmcyhheGlzLm5hbWVzKG1kZWYucHJvcGVydGllcy51cGRhdGUpLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cyk7XG4gICAgZ3JvdXAubGVnZW5kcyA9IGxlZ2VuZC5kZWZzKGVuY29kaW5nKTtcbiAgfVxuXG4gIGZpbHRlci5maWx0ZXJMZXNzVGhhblplcm8oZGF0YVRhYmxlLCBlbmNvZGluZyk7XG5cbiAgcmV0dXJuIHNwZWM7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbnZhciBheGlzID0gcmVxdWlyZSgnLi9heGlzJyksXG4gIGdyb3VwZGVmID0gcmVxdWlyZSgnLi9ncm91cCcpLmRlZixcbiAgc2NhbGUgPSByZXF1aXJlKCcuL3NjYWxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZmFjZXRpbmc7XG5cbmZ1bmN0aW9uIGZhY2V0aW5nKGdyb3VwLCBlbmNvZGluZywgbGF5b3V0LCBzdHlsZSwgc29ydGluZywgc3BlYywgbWRlZiwgc3RhY2ssIHN0YXRzKSB7XG4gIHZhciBlbnRlciA9IGdyb3VwLnByb3BlcnRpZXMuZW50ZXI7XG4gIHZhciBmYWNldEtleXMgPSBbXSwgY2VsbEF4ZXMgPSBbXSwgZnJvbSwgYXhlc0dycDtcblxuICB2YXIgaGFzUm93ID0gZW5jb2RpbmcuaGFzKFJPVyksIGhhc0NvbCA9IGVuY29kaW5nLmhhcyhDT0wpO1xuXG4gIGVudGVyLmZpbGwgPSB7dmFsdWU6IGVuY29kaW5nLmNvbmZpZygnY2VsbEJhY2tncm91bmRDb2xvcicpfTtcblxuICAvL21vdmUgXCJmcm9tXCIgdG8gY2VsbCBsZXZlbCBhbmQgYWRkIGZhY2V0IHRyYW5zZm9ybVxuICBncm91cC5mcm9tID0ge2RhdGE6IGdyb3VwLm1hcmtzWzBdLmZyb20uZGF0YX07XG5cbiAgLy8gSGFjaywgdGhpcyBuZWVkcyB0byBiZSByZWZhY3RvcmVkXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWFyayA9IGdyb3VwLm1hcmtzW2ldO1xuICAgIGlmIChtYXJrLmZyb20udHJhbnNmb3JtKSB7XG4gICAgICBkZWxldGUgbWFyay5mcm9tLmRhdGE7IC8vbmVlZCB0byBrZWVwIHRyYW5zZm9ybSBmb3Igc3ViZmFjZXR0aW5nIGNhc2VcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIG1hcmsuZnJvbTtcbiAgICB9XG4gIH1cblxuICBpZiAoaGFzUm93KSB7XG4gICAgaWYgKCFlbmNvZGluZy5pc0RpbWVuc2lvbihST1cpKSB7XG4gICAgICB1dGlsLmVycm9yKCdSb3cgZW5jb2Rpbmcgc2hvdWxkIGJlIG9yZGluYWwuJyk7XG4gICAgfVxuICAgIGVudGVyLnkgPSB7c2NhbGU6IFJPVywgZmllbGQ6ICdrZXlzLicgKyBmYWNldEtleXMubGVuZ3RofTtcbiAgICBlbnRlci5oZWlnaHQgPSB7J3ZhbHVlJzogbGF5b3V0LmNlbGxIZWlnaHR9OyAvLyBIQUNLXG5cbiAgICBmYWNldEtleXMucHVzaChlbmNvZGluZy5maWVsZFJlZihST1cpKTtcblxuICAgIGlmIChoYXNDb2wpIHtcbiAgICAgIGZyb20gPSB1dGlsLmR1cGxpY2F0ZShncm91cC5mcm9tKTtcbiAgICAgIGZyb20udHJhbnNmb3JtID0gZnJvbS50cmFuc2Zvcm0gfHwgW107XG4gICAgICBmcm9tLnRyYW5zZm9ybS51bnNoaWZ0KHt0eXBlOiAnZmFjZXQnLCBrZXlzOiBbZW5jb2RpbmcuZmllbGRSZWYoQ09MKV19KTtcbiAgICB9XG5cbiAgICBheGVzR3JwID0gZ3JvdXBkZWYoJ3gtYXhlcycsIHtcbiAgICAgICAgYXhlczogZW5jb2RpbmcuaGFzKFgpID8gYXhpcy5kZWZzKFsneCddLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cykgOiB1bmRlZmluZWQsXG4gICAgICAgIHg6IGhhc0NvbCA/IHtzY2FsZTogQ09MLCBmaWVsZDogJ2tleXMuMCd9IDoge3ZhbHVlOiAwfSxcbiAgICAgICAgd2lkdGg6IGhhc0NvbCAmJiB7J3ZhbHVlJzogbGF5b3V0LmNlbGxXaWR0aH0sIC8vSEFDSz9cbiAgICAgICAgZnJvbTogZnJvbVxuICAgICAgfSk7XG5cbiAgICBzcGVjLm1hcmtzLnVuc2hpZnQoYXhlc0dycCk7IC8vIG5lZWQgdG8gcHJlcGVuZCBzbyBpdCBhcHBlYXJzIHVuZGVyIHRoZSBwbG90c1xuICAgIChzcGVjLmF4ZXMgPSBzcGVjLmF4ZXMgfHwgW10pO1xuICAgIHNwZWMuYXhlcy5wdXNoLmFwcGx5KHNwZWMuYXhlcywgYXhpcy5kZWZzKFsncm93J10sIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSk7XG4gIH0gZWxzZSB7IC8vIGRvZXNuJ3QgaGF2ZSByb3dcbiAgICBpZiAoZW5jb2RpbmcuaGFzKFgpKSB7XG4gICAgICAvL2tlZXAgeCBheGlzIGluIHRoZSBjZWxsXG4gICAgICBjZWxsQXhlcy5wdXNoLmFwcGx5KGNlbGxBeGVzLCBheGlzLmRlZnMoWyd4J10sIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhc0NvbCkge1xuICAgIGlmICghZW5jb2RpbmcuaXNEaW1lbnNpb24oQ09MKSkge1xuICAgICAgdXRpbC5lcnJvcignQ29sIGVuY29kaW5nIHNob3VsZCBiZSBvcmRpbmFsLicpO1xuICAgIH1cbiAgICBlbnRlci54ID0ge3NjYWxlOiBDT0wsIGZpZWxkOiAna2V5cy4nICsgZmFjZXRLZXlzLmxlbmd0aH07XG4gICAgZW50ZXIud2lkdGggPSB7J3ZhbHVlJzogbGF5b3V0LmNlbGxXaWR0aH07IC8vIEhBQ0tcblxuICAgIGZhY2V0S2V5cy5wdXNoKGVuY29kaW5nLmZpZWxkUmVmKENPTCkpO1xuXG4gICAgaWYgKGhhc1Jvdykge1xuICAgICAgZnJvbSA9IHV0aWwuZHVwbGljYXRlKGdyb3VwLmZyb20pO1xuICAgICAgZnJvbS50cmFuc2Zvcm0gPSBmcm9tLnRyYW5zZm9ybSB8fCBbXTtcbiAgICAgIGZyb20udHJhbnNmb3JtLnVuc2hpZnQoe3R5cGU6ICdmYWNldCcsIGtleXM6IFtlbmNvZGluZy5maWVsZFJlZihST1cpXX0pO1xuICAgIH1cblxuICAgIGF4ZXNHcnAgPSBncm91cGRlZigneS1heGVzJywge1xuICAgICAgYXhlczogZW5jb2RpbmcuaGFzKFkpID8gYXhpcy5kZWZzKFsneSddLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cykgOiB1bmRlZmluZWQsXG4gICAgICB5OiBoYXNSb3cgJiYge3NjYWxlOiBST1csIGZpZWxkOiAna2V5cy4wJ30sXG4gICAgICB4OiBoYXNSb3cgJiYge3ZhbHVlOiAwfSxcbiAgICAgIGhlaWdodDogaGFzUm93ICYmIHsndmFsdWUnOiBsYXlvdXQuY2VsbEhlaWdodH0sIC8vSEFDSz9cbiAgICAgIGZyb206IGZyb21cbiAgICB9KTtcblxuICAgIHNwZWMubWFya3MudW5zaGlmdChheGVzR3JwKTsgLy8gbmVlZCB0byBwcmVwZW5kIHNvIGl0IGFwcGVhcnMgdW5kZXIgdGhlIHBsb3RzXG4gICAgKHNwZWMuYXhlcyA9IHNwZWMuYXhlcyB8fCBbXSk7XG4gICAgc3BlYy5heGVzLnB1c2guYXBwbHkoc3BlYy5heGVzLCBheGlzLmRlZnMoWydjb2wnXSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpKTtcbiAgfSBlbHNlIHsgLy8gZG9lc24ndCBoYXZlIGNvbFxuICAgIGlmIChlbmNvZGluZy5oYXMoWSkpIHtcbiAgICAgIGNlbGxBeGVzLnB1c2guYXBwbHkoY2VsbEF4ZXMsIGF4aXMuZGVmcyhbJ3knXSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpKTtcbiAgICB9XG4gIH1cblxuICAvLyBhc3N1bWluZyBlcXVhbCBjZWxsV2lkdGggaGVyZVxuICAvLyBUT0RPOiBzdXBwb3J0IGhldGVyb2dlbm91cyBjZWxsV2lkdGggKG1heWJlIGJ5IHVzaW5nIG11bHRpcGxlIHNjYWxlcz8pXG4gIHNwZWMuc2NhbGVzID0gKHNwZWMuc2NhbGVzIHx8IFtdKS5jb25jYXQoc2NhbGUuZGVmcyhcbiAgICBzY2FsZS5uYW1lcyhlbnRlcikuY29uY2F0KHNjYWxlLm5hbWVzKG1kZWYucHJvcGVydGllcy51cGRhdGUpKSxcbiAgICBlbmNvZGluZyxcbiAgICBsYXlvdXQsXG4gICAgc3RhdHMsXG4gICAgc3R5bGUsXG4gICAgc29ydGluZyxcbiAgICB7c3RhY2s6IHN0YWNrLCBmYWNldDogdHJ1ZX1cbiAgKSk7IC8vIHJvdy9jb2wgc2NhbGVzICsgY2VsbCBzY2FsZXNcblxuICBpZiAoY2VsbEF4ZXMubGVuZ3RoID4gMCkge1xuICAgIGdyb3VwLmF4ZXMgPSBjZWxsQXhlcztcbiAgfVxuXG4gIC8vIGFkZCBmYWNldCB0cmFuc2Zvcm1cbiAgdmFyIHRyYW5zID0gKGdyb3VwLmZyb20udHJhbnNmb3JtIHx8IChncm91cC5mcm9tLnRyYW5zZm9ybSA9IFtdKSk7XG4gIHRyYW5zLnVuc2hpZnQoe3R5cGU6ICdmYWNldCcsIGtleXM6IGZhY2V0S2V5c30pO1xuXG4gIHJldHVybiBzcGVjO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciBmaWx0ZXIgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG52YXIgQklOQVJZID0ge1xuICAnPic6ICB0cnVlLFxuICAnPj0nOiB0cnVlLFxuICAnPSc6ICB0cnVlLFxuICAnIT0nOiB0cnVlLFxuICAnPCc6ICB0cnVlLFxuICAnPD0nOiB0cnVlXG59O1xuXG5maWx0ZXIuYWRkRmlsdGVycyA9IGZ1bmN0aW9uKHJhd1RhYmxlLCBlbmNvZGluZykge1xuICB2YXIgZmlsdGVycyA9IGVuY29kaW5nLmZpbHRlcigpOyAgLy8gYXBwbHkgZmlsdGVycyB0byByYXcgZGF0YSBiZWZvcmUgYWdncmVnYXRpb25cblxuICBpZiAoIXJhd1RhYmxlLnRyYW5zZm9ybSlcbiAgICByYXdUYWJsZS50cmFuc2Zvcm0gPSBbXTtcblxuICAvLyBhZGQgY3VzdG9tIGZpbHRlcnNcbiAgZm9yICh2YXIgaT0wLCBsPWZpbHRlcnMubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgIHZhciBmaWx0ZXIgPSBmaWx0ZXJzW2ldO1xuXG4gICAgdmFyIGNvbmRpdGlvbiA9ICcnO1xuICAgIHZhciBvcGVyYXRvciA9IGZpbHRlci5vcGVyYXRvcjtcbiAgICB2YXIgb3BlcmFuZHMgPSBmaWx0ZXIub3BlcmFuZHM7XG5cbiAgICB2YXIgZCA9ICdkLicgKyAoZW5jb2RpbmcuX3ZlZ2EyID8gJycgOiAnZGF0YS4nKTtcblxuICAgIGlmIChCSU5BUllbb3BlcmF0b3JdKSB7XG4gICAgICAvLyBleHBlY3RzIGEgZmllbGQgYW5kIGEgdmFsdWVcbiAgICAgIGlmIChvcGVyYXRvciA9PT0gJz0nKSB7XG4gICAgICAgIG9wZXJhdG9yID0gJz09JztcbiAgICAgIH1cblxuICAgICAgdmFyIG9wMSA9IG9wZXJhbmRzWzBdO1xuICAgICAgdmFyIG9wMiA9IG9wZXJhbmRzWzFdO1xuICAgICAgY29uZGl0aW9uID0gZCArIG9wMSArIG9wZXJhdG9yICsgb3AyO1xuICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09ICdub3ROdWxsJykge1xuICAgICAgLy8gZXhwZWN0cyBhIG51bWJlciBvZiBmaWVsZHNcbiAgICAgIGZvciAodmFyIGo9MDsgajxvcGVyYW5kcy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25kaXRpb24gKz0gZCArIG9wZXJhbmRzW2pdICsgJyE9PW51bGwnO1xuICAgICAgICBpZiAoaiA8IG9wZXJhbmRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjb25kaXRpb24gKz0gJyAmJiAnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgb3BlcmF0b3I6ICcsIG9wZXJhdG9yKTtcbiAgICB9XG5cbiAgICByYXdUYWJsZS50cmFuc2Zvcm0ucHVzaCh7XG4gICAgICB0eXBlOiAnZmlsdGVyJyxcbiAgICAgIHRlc3Q6IGNvbmRpdGlvblxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJhd1RhYmxlO1xufTtcblxuLy8gcmVtb3ZlIGxlc3MgdGhhbiAwIHZhbHVlcyBpZiB3ZSB1c2UgbG9nIGZ1bmN0aW9uXG5maWx0ZXIuZmlsdGVyTGVzc1RoYW5aZXJvID0gZnVuY3Rpb24oZGF0YVRhYmxlLCBlbmNvZGluZykge1xuICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBlbmNUeXBlKSB7XG4gICAgaWYgKGVuY29kaW5nLnNjYWxlKGVuY1R5cGUpLnR5cGUgPT09ICdsb2cnKSB7XG4gICAgICBkYXRhVGFibGUudHJhbnNmb3JtLnB1c2goe1xuICAgICAgICB0eXBlOiAnZmlsdGVyJyxcbiAgICAgICAgdGVzdDogJ2QuJyArIGVuY29kaW5nLmZpZWxkUmVmKGVuY1R5cGUpICsgJz4wJ1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZWY6IGdyb3VwZGVmXG59O1xuXG5mdW5jdGlvbiBncm91cGRlZihuYW1lLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuICByZXR1cm4ge1xuICAgIF9uYW1lOiBuYW1lIHx8IHVuZGVmaW5lZCxcbiAgICB0eXBlOiAnZ3JvdXAnLFxuICAgIGZyb206IG9wdC5mcm9tLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIHg6IG9wdC54IHx8IHVuZGVmaW5lZCxcbiAgICAgICAgeTogb3B0LnkgfHwgdW5kZWZpbmVkLFxuICAgICAgICB3aWR0aDogb3B0LndpZHRoIHx8IHtncm91cDogJ3dpZHRoJ30sXG4gICAgICAgIGhlaWdodDogb3B0LmhlaWdodCB8fCB7Z3JvdXA6ICdoZWlnaHQnfVxuICAgICAgfVxuICAgIH0sXG4gICAgc2NhbGVzOiBvcHQuc2NhbGVzIHx8IHVuZGVmaW5lZCxcbiAgICBheGVzOiBvcHQuYXhlcyB8fCB1bmRlZmluZWQsXG4gICAgbWFya3M6IG9wdC5tYXJrcyB8fCBbXVxuICB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICBzZXR0ZXIgPSB1dGlsLnNldHRlcixcbiAgdGltZSA9IHJlcXVpcmUoJy4vdGltZScpLFxuICBkM19mb3JtYXQgPSByZXF1aXJlKCdkMy1mb3JtYXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB2bGxheW91dDtcblxuZnVuY3Rpb24gdmxsYXlvdXQoZW5jb2RpbmcsIHN0YXRzKSB7XG4gIHZhciBsYXlvdXQgPSBib3goZW5jb2RpbmcsIHN0YXRzKTtcbiAgbGF5b3V0ID0gb2Zmc2V0KGVuY29kaW5nLCBzdGF0cywgbGF5b3V0KTtcbiAgcmV0dXJuIGxheW91dDtcbn1cblxuLypcbiAgSEFDSyB0byBzZXQgY2hhcnQgc2l6ZVxuICBOT1RFOiB0aGlzIGZhaWxzIGZvciBwbG90cyBkcml2ZW4gYnkgZGVyaXZlZCB2YWx1ZXMgKGUuZy4sIGFnZ3JlZ2F0ZXMpXG4gIE9uZSBzb2x1dGlvbiBpcyB0byB1cGRhdGUgVmVnYSB0byBzdXBwb3J0IGF1dG8tc2l6aW5nXG4gIEluIHRoZSBtZWFudGltZSwgYXV0by1wYWRkaW5nIChtb3N0bHkpIGRvZXMgdGhlIHRyaWNrXG4gKi9cbmZ1bmN0aW9uIGJveChlbmNvZGluZywgc3RhdHMpIHtcbiAgdmFyIGhhc1JvdyA9IGVuY29kaW5nLmhhcyhST1cpLFxuICAgICAgaGFzQ29sID0gZW5jb2RpbmcuaGFzKENPTCksXG4gICAgICBoYXNYID0gZW5jb2RpbmcuaGFzKFgpLFxuICAgICAgaGFzWSA9IGVuY29kaW5nLmhhcyhZKSxcbiAgICAgIG1hcmt0eXBlID0gZW5jb2RpbmcubWFya3R5cGUoKTtcblxuICAvLyBGSVhNRS9IQUNLIHdlIG5lZWQgdG8gdGFrZSBmaWx0ZXIgaW50byBhY2NvdW50XG4gIHZhciB4Q2FyZGluYWxpdHkgPSBoYXNYICYmIGVuY29kaW5nLmlzRGltZW5zaW9uKFgpID8gZW5jb2RpbmcuY2FyZGluYWxpdHkoWCwgc3RhdHMpIDogMSxcbiAgICB5Q2FyZGluYWxpdHkgPSBoYXNZICYmIGVuY29kaW5nLmlzRGltZW5zaW9uKFkpID8gZW5jb2RpbmcuY2FyZGluYWxpdHkoWSwgc3RhdHMpIDogMTtcblxuICB2YXIgdXNlU21hbGxCYW5kID0geENhcmRpbmFsaXR5ID4gZW5jb2RpbmcuY29uZmlnKCdsYXJnZUJhbmRNYXhDYXJkaW5hbGl0eScpIHx8XG4gICAgeUNhcmRpbmFsaXR5ID4gZW5jb2RpbmcuY29uZmlnKCdsYXJnZUJhbmRNYXhDYXJkaW5hbGl0eScpO1xuXG4gIHZhciBjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIGNlbGxQYWRkaW5nID0gZW5jb2RpbmcuY29uZmlnKCdjZWxsUGFkZGluZycpO1xuXG4gIC8vIHNldCBjZWxsV2lkdGhcbiAgaWYgKGhhc1gpIHtcbiAgICBpZiAoZW5jb2RpbmcuaXNPcmRpbmFsU2NhbGUoWCkpIHtcbiAgICAgIC8vIGZvciBvcmRpbmFsLCBoYXNDb2wgb3Igbm90IGRvZXNuJ3QgbWF0dGVyIC0tIHdlIHNjYWxlIGJhc2VkIG9uIGNhcmRpbmFsaXR5XG4gICAgICBjZWxsV2lkdGggPSAoeENhcmRpbmFsaXR5ICsgZW5jb2RpbmcuZmllbGQoWCkuYmFuZC5wYWRkaW5nKSAqIGVuY29kaW5nLmJhbmRTaXplKFgsIHVzZVNtYWxsQmFuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbGxXaWR0aCA9IGhhc0NvbCB8fCBoYXNSb3cgPyBlbmNvZGluZy5maWVsZChDT0wpLndpZHRoIDogIGVuY29kaW5nLmNvbmZpZygnc2luZ2xlV2lkdGgnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKG1hcmt0eXBlID09PSBURVhUKSB7XG4gICAgICBjZWxsV2lkdGggPSBlbmNvZGluZy5jb25maWcoJ3RleHRDZWxsV2lkdGgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VsbFdpZHRoID0gZW5jb2RpbmcuYmFuZFNpemUoWCk7XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IGNlbGxIZWlnaHRcbiAgaWYgKGhhc1kpIHtcbiAgICBpZiAoZW5jb2RpbmcuaXNPcmRpbmFsU2NhbGUoWSkpIHtcbiAgICAgIC8vIGZvciBvcmRpbmFsLCBoYXNDb2wgb3Igbm90IGRvZXNuJ3QgbWF0dGVyIC0tIHdlIHNjYWxlIGJhc2VkIG9uIGNhcmRpbmFsaXR5XG4gICAgICBjZWxsSGVpZ2h0ID0gKHlDYXJkaW5hbGl0eSArIGVuY29kaW5nLmZpZWxkKFkpLmJhbmQucGFkZGluZykgKiBlbmNvZGluZy5iYW5kU2l6ZShZLCB1c2VTbWFsbEJhbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZWxsSGVpZ2h0ID0gaGFzQ29sIHx8IGhhc1JvdyA/IGVuY29kaW5nLmZpZWxkKFJPVykuaGVpZ2h0IDogIGVuY29kaW5nLmNvbmZpZygnc2luZ2xlSGVpZ2h0Jyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNlbGxIZWlnaHQgPSBlbmNvZGluZy5iYW5kU2l6ZShZKTtcbiAgfVxuXG4gIC8vIENlbGwgYmFuZHMgdXNlIHJhbmdlQmFuZHMoKS4gVGhlcmUgYXJlIG4tMSBwYWRkaW5nLiAgT3V0ZXJwYWRkaW5nID0gMCBmb3IgY2VsbHNcblxuICB2YXIgd2lkdGggPSBjZWxsV2lkdGgsIGhlaWdodCA9IGNlbGxIZWlnaHQ7XG4gIGlmIChoYXNDb2wpIHtcbiAgICB2YXIgY29sQ2FyZGluYWxpdHkgPSBlbmNvZGluZy5jYXJkaW5hbGl0eShDT0wsIHN0YXRzKTtcbiAgICB3aWR0aCA9IGNlbGxXaWR0aCAqICgoMSArIGNlbGxQYWRkaW5nKSAqIChjb2xDYXJkaW5hbGl0eSAtIDEpICsgMSk7XG4gIH1cbiAgaWYgKGhhc1Jvdykge1xuICAgIHZhciByb3dDYXJkaW5hbGl0eSA9ICBlbmNvZGluZy5jYXJkaW5hbGl0eShST1csIHN0YXRzKTtcbiAgICBoZWlnaHQgPSBjZWxsSGVpZ2h0ICogKCgxICsgY2VsbFBhZGRpbmcpICogKHJvd0NhcmRpbmFsaXR5IC0gMSkgKyAxKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgd2hvbGUgY2VsbFxuICAgIGNlbGxXaWR0aDogY2VsbFdpZHRoLFxuICAgIGNlbGxIZWlnaHQ6IGNlbGxIZWlnaHQsXG4gICAgY2VsbFBhZGRpbmc6IGNlbGxQYWRkaW5nLFxuICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGNoYXJ0XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIC8vIGluZm9ybWF0aW9uIGFib3V0IHggYW5kIHksIHN1Y2ggYXMgYmFuZCBzaXplXG4gICAgeDoge3VzZVNtYWxsQmFuZDogdXNlU21hbGxCYW5kfSxcbiAgICB5OiB7dXNlU21hbGxCYW5kOiB1c2VTbWFsbEJhbmR9XG4gIH07XG59XG5cblxuLy8gRklYTUUgZmllbGRTdGF0cy5tYXggaXNuJ3QgYWx3YXlzIHRoZSBsb25nZXN0XG5mdW5jdGlvbiBnZXRNYXhOdW1iZXJMZW5ndGgoZW5jb2RpbmcsIGV0LCBmaWVsZFN0YXRzKSB7XG4gIHZhciBmb3JtYXQgPSBlbmNvZGluZy5udW1iZXJGb3JtYXQoZXQsIGZpZWxkU3RhdHMpO1xuXG4gIHJldHVybiBkM19mb3JtYXQuZm9ybWF0KGZvcm1hdCkoZmllbGRTdGF0cy5tYXgpLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gZ2V0TWF4TGVuZ3RoKGVuY29kaW5nLCBzdGF0cywgZXQpIHtcbiAgdmFyIGZpZWxkID0gZW5jb2RpbmcuZmllbGQoZXQpLFxuICAgIGZpZWxkU3RhdHMgPSBzdGF0c1tmaWVsZC5uYW1lXTtcblxuICBpZiAoZmllbGQuYmluKSB7XG4gICAgLy8gVE9ETyBvbmNlIGJpbiBzdXBwb3J0IHJhbmdlLCBuZWVkIHRvIHVwZGF0ZSB0aGlzXG4gICAgcmV0dXJuIGdldE1heE51bWJlckxlbmd0aChlbmNvZGluZywgZXQsIGZpZWxkU3RhdHMpO1xuICB9IGlmIChlbmNvZGluZy5pc1R5cGUoZXQsIFEpKSB7XG4gICAgcmV0dXJuIGdldE1heE51bWJlckxlbmd0aChlbmNvZGluZywgZXQsIGZpZWxkU3RhdHMpO1xuICB9IGVsc2UgaWYgKGVuY29kaW5nLmlzVHlwZShldCwgVCkpIHtcbiAgICByZXR1cm4gdGltZS5tYXhMZW5ndGgoZW5jb2RpbmcuZmllbGQoZXQpLnRpbWVVbml0LCBlbmNvZGluZyk7XG4gIH0gZWxzZSBpZiAoZW5jb2RpbmcuaXNUeXBlcyhldCwgW04sIE9dKSkge1xuICAgIGlmKGZpZWxkU3RhdHMudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBnZXRNYXhOdW1iZXJMZW5ndGgoZW5jb2RpbmcsIGV0LCBmaWVsZFN0YXRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGgubWluKGZpZWxkU3RhdHMubWF4LCBlbmNvZGluZy5heGlzKGV0KS5tYXhMYWJlbExlbmd0aCB8fCBJbmZpbml0eSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9mZnNldChlbmNvZGluZywgc3RhdHMsIGxheW91dCkge1xuICBbWCwgWV0uZm9yRWFjaChmdW5jdGlvbiAoZXQpIHtcbiAgICAvLyBUT0RPKGthbml0dyk6IEp1bCAxOSwgMjAxNSAtIGNyZWF0ZSBhIHNldCBvZiB2aXN1YWwgdGVzdCBmb3IgZXh0cmFPZmZzZXRcbiAgICB2YXIgZXh0cmFPZmZzZXQgPSBldCA9PT0gWCA/IDIwIDogMjIsXG4gICAgICBtYXhMZW5ndGg7XG4gICAgaWYgKGVuY29kaW5nLmlzRGltZW5zaW9uKGV0KSB8fCBlbmNvZGluZy5pc1R5cGUoZXQsIFQpKSB7XG4gICAgICBtYXhMZW5ndGggPSBnZXRNYXhMZW5ndGgoZW5jb2RpbmcsIHN0YXRzLCBldCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIC8vIFRPRE8gb25jZSB3ZSBoYXZlICM1MTIgKGFsbG93IHVzaW5nIGluZmVycmVkIHR5cGUpXG4gICAgICAvLyBOZWVkIHRvIGFkanVzdCBjb25kaXRpb24gaGVyZS5cbiAgICAgIGVuY29kaW5nLmlzVHlwZShldCwgUSkgfHxcbiAgICAgIGVuY29kaW5nLmFnZ3JlZ2F0ZShldCkgPT09ICdjb3VudCdcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgZXQ9PT1ZXG4gICAgICAgIC8vIHx8IChldD09PVggJiYgZmFsc2UpXG4gICAgICAgIC8vIEZJWE1FIGRldGVybWluZSB3aGVuIFggd291bGQgcm90YXRlLCBidXQgc2hvdWxkIG1vdmUgdGhpcyB0byBheGlzLmpzIGZpcnN0ICM1MDZcbiAgICAgICkge1xuICAgICAgICBtYXhMZW5ndGggPSBnZXRNYXhMZW5ndGgoZW5jb2RpbmcsIHN0YXRzLCBldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vdGhpbmdcbiAgICB9XG5cbiAgICBpZiAobWF4TGVuZ3RoKSB7XG4gICAgICBzZXR0ZXIobGF5b3V0LFtldCwgJ2F4aXNUaXRsZU9mZnNldCddLCBlbmNvZGluZy5jb25maWcoJ2NoYXJhY3RlcldpZHRoJykgKiAgbWF4TGVuZ3RoICsgZXh0cmFPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBubyBtYXggbGVuZ3RoIChubyByb3RhdGlvbiBjYXNlKSwgdXNlIG1heExlbmd0aCA9IDNcbiAgICAgIHNldHRlcihsYXlvdXQsW2V0LCAnYXhpc1RpdGxlT2Zmc2V0J10sIGVuY29kaW5nLmNvbmZpZygnY2hhcmFjdGVyV2lkdGgnKSAqIDMgKyBleHRyYU9mZnNldCk7XG4gICAgfVxuXG4gIH0pO1xuICByZXR1cm4gbGF5b3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciB0aW1lID0gcmVxdWlyZSgnLi90aW1lJyk7XG5cbnZhciBsZWdlbmQgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5sZWdlbmQuZGVmcyA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHZhciBkZWZzID0gW107XG4gIC8vIFRPRE86IHN1cHBvcnQgYWxwaGFcblxuICBpZiAoZW5jb2RpbmcuaGFzKENPTE9SKSAmJiBlbmNvZGluZy5maWVsZChDT0xPUikubGVnZW5kKSB7XG4gICAgZGVmcy5wdXNoKGxlZ2VuZC5kZWYoQ09MT1IsIGVuY29kaW5nLCB7XG4gICAgICBmaWxsOiBDT0xPUixcbiAgICAgIG9yaWVudDogJ3JpZ2h0J1xuICAgIH0pKTtcbiAgfVxuXG4gIGlmIChlbmNvZGluZy5oYXMoU0laRSkgJiYgZW5jb2RpbmcuZmllbGQoU0laRSkubGVnZW5kKSB7XG4gICAgZGVmcy5wdXNoKGxlZ2VuZC5kZWYoU0laRSwgZW5jb2RpbmcsIHtcbiAgICAgIHNpemU6IFNJWkUsXG4gICAgICBvcmllbnQ6IGRlZnMubGVuZ3RoID09PSAxID8gJ2xlZnQnIDogJ3JpZ2h0J1xuICAgIH0pKTtcbiAgfVxuXG4gIGlmIChlbmNvZGluZy5oYXMoU0hBUEUpICYmIGVuY29kaW5nLmZpZWxkKFNIQVBFKS5sZWdlbmQpIHtcbiAgICBpZiAoZGVmcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIC8vIFRPRE86IGZpeCB0aGlzXG4gICAgICBjb25zb2xlLmVycm9yKCdWZWdhLWxpdGUgY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgdHdvIGxlZ2VuZHMnKTtcbiAgICAgIHJldHVybiBkZWZzO1xuICAgIH1cbiAgICBkZWZzLnB1c2gobGVnZW5kLmRlZihTSEFQRSwgZW5jb2RpbmcsIHtcbiAgICAgIHNoYXBlOiBTSEFQRSxcbiAgICAgIG9yaWVudDogZGVmcy5sZW5ndGggPT09IDEgPyAnbGVmdCcgOiAncmlnaHQnXG4gICAgfSkpO1xuICB9XG5cbiAgcmV0dXJuIGRlZnM7XG59O1xuXG5sZWdlbmQuZGVmID0gZnVuY3Rpb24obmFtZSwgZW5jb2RpbmcsIHByb3BzKSB7XG4gIHZhciBkZWYgPSBwcm9wcyxcbiAgICB0aW1lVW5pdCA9IGVuY29kaW5nLmZpZWxkKG5hbWUpLnRpbWVVbml0O1xuXG4gIGRlZi50aXRsZSA9IGVuY29kaW5nLmZpZWxkVGl0bGUobmFtZSk7XG5cbiAgaWYgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBUKSAmJlxuICAgIHRpbWVVbml0ICYmXG4gICAgdGltZS5oYXNTY2FsZSh0aW1lVW5pdClcbiAgKSB7XG4gICAgdmFyIHByb3BlcnRpZXMgPSBkZWYucHJvcGVydGllcyA9IGRlZi5wcm9wZXJ0aWVzIHx8IHt9LFxuICAgICAgbGFiZWxzID0gcHJvcGVydGllcy5sYWJlbHMgPSBwcm9wZXJ0aWVzLmxhYmVscyB8fCB7fSxcbiAgICAgIHRleHQgPSBsYWJlbHMudGV4dCA9IGxhYmVscy50ZXh0IHx8IHt9O1xuXG4gICAgdGV4dC5zY2FsZSA9ICd0aW1lLScrIHRpbWVVbml0O1xuICB9XG5cbiAgcmV0dXJuIGRlZjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIG1hcmtzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxubWFya3MuZGVmID0gZnVuY3Rpb24obWFyaywgZW5jb2RpbmcsIGxheW91dCwgc3R5bGUsIHN0YXRzKSB7XG4gIHZhciBkZWZzID0gW107XG5cbiAgLy8gdG8gYWRkIGEgYmFja2dyb3VuZCB0byB0ZXh0LCB3ZSBuZWVkIHRvIGFkZCBpdCBiZWZvcmUgdGhlIHRleHRcbiAgaWYgKGVuY29kaW5nLm1hcmt0eXBlKCkgPT09IFRFWFQgJiYgZW5jb2RpbmcuaGFzKENPTE9SKSkge1xuICAgIHZhciBiZyA9IHtcbiAgICAgIHg6IHt2YWx1ZTogMH0sXG4gICAgICB5OiB7dmFsdWU6IDB9LFxuICAgICAgeDI6IHt2YWx1ZTogbGF5b3V0LmNlbGxXaWR0aH0sXG4gICAgICB5Mjoge3ZhbHVlOiBsYXlvdXQuY2VsbEhlaWdodH0sXG4gICAgICBmaWxsOiB7c2NhbGU6IENPTE9SLCBmaWVsZDogZW5jb2RpbmcuZmllbGRSZWYoQ09MT1IpfVxuICAgIH07XG4gICAgZGVmcy5wdXNoKHtcbiAgICAgIHR5cGU6ICdyZWN0JyxcbiAgICAgIGZyb206IHtkYXRhOiBUQUJMRX0sXG4gICAgICBwcm9wZXJ0aWVzOiB7ZW50ZXI6IGJnLCB1cGRhdGU6IGJnfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gYWRkIHRoZSBtYXJrIGRlZiBmb3IgdGhlIG1haW4gdGhpbmdcbiAgdmFyIHAgPSBtYXJrLnByb3AoZW5jb2RpbmcsIGxheW91dCwgc3R5bGUsIHN0YXRzKTtcbiAgZGVmcy5wdXNoKHtcbiAgICB0eXBlOiBtYXJrLnR5cGUsXG4gICAgZnJvbToge2RhdGE6IFRBQkxFfSxcbiAgICBwcm9wZXJ0aWVzOiB7ZW50ZXI6IHAsIHVwZGF0ZTogcH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRlZnM7XG59O1xuXG5tYXJrcy5iYXIgPSB7XG4gIHR5cGU6ICdyZWN0JyxcbiAgc3RhY2s6IHRydWUsXG4gIHByb3A6IGJhcl9wcm9wcyxcbiAgcmVxdWlyZWRFbmNvZGluZzogWyd4JywgJ3knXSxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgeDogMSwgeTogMSwgc2l6ZTogMSwgY29sb3I6IDF9XG59O1xuXG5tYXJrcy5saW5lID0ge1xuICB0eXBlOiAnbGluZScsXG4gIGxpbmU6IHRydWUsXG4gIHByb3A6IGxpbmVfcHJvcHMsXG4gIHJlcXVpcmVkRW5jb2Rpbmc6IFsneCcsICd5J10sXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OiAxLCBjb2w6IDEsIHg6IDEsIHk6IDEsIGNvbG9yOiAxLCBkZXRhaWw6MX1cbn07XG5cbm1hcmtzLmFyZWEgPSB7XG4gIHR5cGU6ICdhcmVhJyxcbiAgc3RhY2s6IHRydWUsXG4gIGxpbmU6IHRydWUsXG4gIHJlcXVpcmVkRW5jb2Rpbmc6IFsneCcsICd5J10sXG4gIHByb3A6IGFyZWFfcHJvcHMsXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OiAxLCBjb2w6IDEsIHg6IDEsIHk6IDEsIGNvbG9yOiAxfVxufTtcblxubWFya3MudGljayA9IHtcbiAgdHlwZTogJ3JlY3QnLFxuICBwcm9wOiB0aWNrX3Byb3BzLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCB4OiAxLCB5OiAxLCBjb2xvcjogMSwgZGV0YWlsOiAxfVxufTtcblxubWFya3MuY2lyY2xlID0ge1xuICB0eXBlOiAnc3ltYm9sJyxcbiAgcHJvcDogZmlsbGVkX3BvaW50X3Byb3BzKCdjaXJjbGUnKSxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgeDogMSwgeTogMSwgc2l6ZTogMSwgY29sb3I6IDEsIGRldGFpbDogMX1cbn07XG5cbm1hcmtzLnNxdWFyZSA9IHtcbiAgdHlwZTogJ3N5bWJvbCcsXG4gIHByb3A6IGZpbGxlZF9wb2ludF9wcm9wcygnc3F1YXJlJyksXG4gIHN1cHBvcnRlZEVuY29kaW5nOiBtYXJrcy5jaXJjbGUuc3VwcG9ydGVkRW5jb2Rpbmdcbn07XG5cbm1hcmtzLnBvaW50ID0ge1xuICB0eXBlOiAnc3ltYm9sJyxcbiAgcHJvcDogcG9pbnRfcHJvcHMsXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OiAxLCBjb2w6IDEsIHg6IDEsIHk6IDEsIHNpemU6IDEsIGNvbG9yOiAxLCBzaGFwZTogMSwgZGV0YWlsOiAxfVxufTtcblxubWFya3MudGV4dCA9IHtcbiAgdHlwZTogJ3RleHQnLFxuICBwcm9wOiB0ZXh0X3Byb3BzLFxuICByZXF1aXJlZEVuY29kaW5nOiBbJ3RleHQnXSxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgc2l6ZTogMSwgY29sb3I6IDEsIHRleHQ6IDF9XG59O1xuXG5mdW5jdGlvbiBiYXJfcHJvcHMoZSwgbGF5b3V0LCBzdHlsZSkge1xuICAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG5cbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4J3MgYW5kIHdpZHRoXG4gIGlmIChlLmlzTWVhc3VyZShYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGRSZWYoWCl9O1xuICAgIGlmICghZS5oYXMoWSkgfHwgZS5pc0RpbWVuc2lvbihZKSkge1xuICAgICAgcC54MiA9IHt2YWx1ZTogMH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChlLmhhcyhYKSkgeyAvLyBpcyBvcmRpbmFsXG4gICAgICAgcC54YyA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGRSZWYoWCl9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgcC54ID0ge3ZhbHVlOiAwLCBvZmZzZXQ6IGUuY29uZmlnKCdzaW5nbGVCYXJPZmZzZXQnKX07XG4gICAgfVxuICB9XG5cbiAgLy8gd2lkdGhcbiAgaWYgKCFwLngyKSB7XG4gICAgaWYgKCFlLmhhcyhYKSB8fCBlLmlzT3JkaW5hbFNjYWxlKFgpKSB7IC8vIG5vIFggb3IgWCBpcyBvcmRpbmFsXG4gICAgICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICAgICAgcC53aWR0aCA9IHtzY2FsZTogU0laRSwgZmllbGQ6IGUuZmllbGRSZWYoU0laRSl9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcC53aWR0aCA9IHtcbiAgICAgICAgICB2YWx1ZTogZS5iYW5kU2l6ZShYLCBsYXlvdXQueC51c2VTbWFsbEJhbmQpLFxuICAgICAgICAgIG9mZnNldDogLTFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBYIGlzIFF1YW50IG9yIFRpbWUgU2NhbGVcbiAgICAgIHAud2lkdGggPSB7dmFsdWU6IDJ9O1xuICAgIH1cbiAgfVxuXG4gIC8vIHkncyAmIGhlaWdodFxuICBpZiAoZS5pc01lYXN1cmUoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkUmVmKFkpfTtcbiAgICBwLnkyID0ge2dyb3VwOiAnaGVpZ2h0J307XG4gIH0gZWxzZSB7XG4gICAgaWYgKGUuaGFzKFkpKSB7IC8vIGlzIG9yZGluYWxcbiAgICAgIHAueWMgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkUmVmKFkpfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcC55MiA9IHtncm91cDogJ2hlaWdodCcsIG9mZnNldDogLWUuY29uZmlnKCdzaW5nbGVCYXJPZmZzZXQnKX07XG4gICAgfVxuXG4gICAgaWYgKGUuaGFzKFNJWkUpKSB7XG4gICAgICBwLmhlaWdodCA9IHtzY2FsZTogU0laRSwgZmllbGQ6IGUuZmllbGRSZWYoU0laRSl9O1xuICAgIH0gZWxzZSB7XG4gICAgICBwLmhlaWdodCA9IHtcbiAgICAgICAgdmFsdWU6IGUuYmFuZFNpemUoWSwgbGF5b3V0LnkudXNlU21hbGxCYW5kKSxcbiAgICAgICAgb2Zmc2V0OiAtMVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBmaWxsXG4gIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZFJlZihDT0xPUil9O1xuICB9IGVsc2Uge1xuICAgIHAuZmlsbCA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICB9XG5cbiAgLy8gb3BhY2l0eVxuICB2YXIgb3BhY2l0eSA9IGUuZmllbGQoQ09MT1IpLm9wYWNpdHk7XG4gIGlmIChvcGFjaXR5KSBwLm9wYWNpdHkgPSB7dmFsdWU6IG9wYWNpdHl9O1xuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBwb2ludF9wcm9wcyhlLCBsYXlvdXQsIHN0eWxlKSB7XG4gIHZhciBwID0ge307XG5cbiAgLy8geFxuICBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkUmVmKFgpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7dmFsdWU6IGUuYmFuZFNpemUoWCwgbGF5b3V0LngudXNlU21hbGxCYW5kKSAvIDJ9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkUmVmKFkpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7dmFsdWU6IGUuYmFuZFNpemUoWSwgbGF5b3V0LnkudXNlU21hbGxCYW5kKSAvIDJ9O1xuICB9XG5cbiAgLy8gc2l6ZVxuICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICBwLnNpemUgPSB7c2NhbGU6IFNJWkUsIGZpZWxkOiBlLmZpZWxkUmVmKFNJWkUpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoU0laRSkpIHtcbiAgICBwLnNpemUgPSB7dmFsdWU6IGUudmFsdWUoU0laRSl9O1xuICB9XG5cbiAgLy8gc2hhcGVcbiAgaWYgKGUuaGFzKFNIQVBFKSkge1xuICAgIHAuc2hhcGUgPSB7c2NhbGU6IFNIQVBFLCBmaWVsZDogZS5maWVsZFJlZihTSEFQRSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhTSEFQRSkpIHtcbiAgICBwLnNoYXBlID0ge3ZhbHVlOiBlLnZhbHVlKFNIQVBFKX07XG4gIH1cblxuICAvLyBzdHJva2VcbiAgaWYgKGUuZmllbGQoU0hBUEUpLmZpbGxlZCkge1xuICAgIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICAgIHAuZmlsbCA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkUmVmKENPTE9SKX07XG4gICAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgICBwLmZpbGwgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGUuaGFzKENPTE9SKSkge1xuICAgICAgcC5zdHJva2UgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZFJlZihDT0xPUil9O1xuICAgIH0gZWxzZSBpZiAoIWUuaGFzKENPTE9SKSkge1xuICAgICAgcC5zdHJva2UgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgICB9XG4gICAgcC5zdHJva2VXaWR0aCA9IHt2YWx1ZTogZS5jb25maWcoJ3N0cm9rZVdpZHRoJyl9O1xuICB9XG5cbiAgLy8gb3BhY2l0eVxuICB2YXIgb3BhY2l0eSA9IGUuZmllbGQoQ09MT1IpLm9wYWNpdHkgIHx8IHN0eWxlLm9wYWNpdHk7XG4gIGlmIChvcGFjaXR5KSBwLm9wYWNpdHkgPSB7dmFsdWU6IG9wYWNpdHl9O1xuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBsaW5lX3Byb3BzKGUsbGF5b3V0LCBzdHlsZSkge1xuICAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHZhciBwID0ge307XG5cbiAgLy8geFxuICBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkUmVmKFgpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkUmVmKFkpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7Z3JvdXA6ICdoZWlnaHQnfTtcbiAgfVxuXG4gIC8vIHN0cm9rZVxuICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5zdHJva2UgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZFJlZihDT0xPUil9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICBwLnN0cm9rZSA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICB9XG5cbiAgdmFyIG9wYWNpdHkgPSBlLmZpZWxkKENPTE9SKS5vcGFjaXR5O1xuICBpZiAob3BhY2l0eSkgcC5vcGFjaXR5ID0ge3ZhbHVlOiBvcGFjaXR5fTtcblxuICBwLnN0cm9rZVdpZHRoID0ge3ZhbHVlOiBlLmNvbmZpZygnc3Ryb2tlV2lkdGgnKX07XG5cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIGFyZWFfcHJvcHMoZSwgbGF5b3V0LCBzdHlsZSkge1xuICAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHZhciBwID0ge307XG5cbiAgLy8geFxuICBpZiAoZS5pc01lYXN1cmUoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkUmVmKFgpfTtcbiAgICBpZiAoZS5pc0RpbWVuc2lvbihZKSkge1xuICAgICAgcC54MiA9IHtzY2FsZTogWCwgdmFsdWU6IDB9O1xuICAgICAgcC5vcmllbnQgPSB7dmFsdWU6ICdob3Jpem9udGFsJ307XG4gICAgfVxuICB9IGVsc2UgaWYgKGUuaGFzKFgpKSB7XG4gICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZFJlZihYKX07XG4gIH0gZWxzZSB7XG4gICAgcC54ID0ge3ZhbHVlOiAwfTtcbiAgfVxuXG4gIC8vIHlcbiAgaWYgKGUuaXNNZWFzdXJlKFkpKSB7XG4gICAgcC55ID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZFJlZihZKX07XG4gICAgcC55MiA9IHtzY2FsZTogWSwgdmFsdWU6IDB9O1xuICB9IGVsc2UgaWYgKGUuaGFzKFkpKSB7XG4gICAgcC55ID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZFJlZihZKX07XG4gIH0gZWxzZSB7XG4gICAgcC55ID0ge2dyb3VwOiAnaGVpZ2h0J307XG4gIH1cblxuICAvLyBmaWxsXG4gIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZFJlZihDT0xPUil9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgfVxuXG4gIHZhciBvcGFjaXR5ID0gZS5maWVsZChDT0xPUikub3BhY2l0eTtcbiAgaWYgKG9wYWNpdHkpIHAub3BhY2l0eSA9IHt2YWx1ZTogb3BhY2l0eX07XG5cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHRpY2tfcHJvcHMoZSwgbGF5b3V0LCBzdHlsZSkge1xuICB2YXIgcCA9IHt9O1xuXG4gIC8vIHhcbiAgaWYgKGUuaGFzKFgpKSB7XG4gICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZFJlZihYKX07XG4gICAgaWYgKGUuaXNEaW1lbnNpb24oWCkpIHtcbiAgICAgIHAueC5vZmZzZXQgPSAtZS5iYW5kU2l6ZShYLCBsYXlvdXQueC51c2VTbWFsbEJhbmQpIC8gMztcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFgpKSB7XG4gICAgcC54ID0ge3ZhbHVlOiAwfTtcbiAgfVxuXG4gIC8vIHlcbiAgaWYgKGUuaGFzKFkpKSB7XG4gICAgcC55ID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZFJlZihZKX07XG4gICAgaWYgKGUuaXNEaW1lbnNpb24oWSkpIHtcbiAgICAgIHAueS5vZmZzZXQgPSAtZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMztcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFkpKSB7XG4gICAgcC55ID0ge3ZhbHVlOiAwfTtcbiAgfVxuXG4gIC8vIHdpZHRoXG4gIGlmICghZS5oYXMoWCkgfHwgZS5pc0RpbWVuc2lvbihYKSkge1xuICAgIHAud2lkdGggPSB7dmFsdWU6IGUuYmFuZFNpemUoWCwgbGF5b3V0LnkudXNlU21hbGxCYW5kKSAvIDEuNX07XG4gIH0gZWxzZSB7XG4gICAgcC53aWR0aCA9IHt2YWx1ZTogMX07XG4gIH1cblxuICAvLyBoZWlnaHRcbiAgaWYgKCFlLmhhcyhZKSB8fCBlLmlzRGltZW5zaW9uKFkpKSB7XG4gICAgcC5oZWlnaHQgPSB7dmFsdWU6IGUuYmFuZFNpemUoWSwgbGF5b3V0LnkudXNlU21hbGxCYW5kKSAvIDEuNX07XG4gIH0gZWxzZSB7XG4gICAgcC5oZWlnaHQgPSB7dmFsdWU6IDF9O1xuICB9XG5cbiAgLy8gZmlsbFxuICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5maWxsID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGRSZWYoQ09MT1IpfTtcbiAgfSBlbHNlIHtcbiAgICBwLmZpbGwgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgfVxuXG4gIHZhciBvcGFjaXR5ID0gZS5maWVsZChDT0xPUikub3BhY2l0eSAgfHwgc3R5bGUub3BhY2l0eTtcbiAgaWYob3BhY2l0eSkgcC5vcGFjaXR5ID0ge3ZhbHVlOiBvcGFjaXR5fTtcblxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gZmlsbGVkX3BvaW50X3Byb3BzKHNoYXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbihlLCBsYXlvdXQsIHN0eWxlKSB7XG4gICAgdmFyIHAgPSB7fTtcblxuICAgIC8vIHhcbiAgICBpZiAoZS5oYXMoWCkpIHtcbiAgICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGRSZWYoWCl9O1xuICAgIH0gZWxzZSBpZiAoIWUuaGFzKFgpKSB7XG4gICAgICBwLnggPSB7dmFsdWU6IGUuYmFuZFNpemUoWCwgbGF5b3V0LngudXNlU21hbGxCYW5kKSAvIDJ9O1xuICAgIH1cblxuICAgIC8vIHlcbiAgICBpZiAoZS5oYXMoWSkpIHtcbiAgICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGRSZWYoWSl9O1xuICAgIH0gZWxzZSBpZiAoIWUuaGFzKFkpKSB7XG4gICAgICBwLnkgPSB7dmFsdWU6IGUuYmFuZFNpemUoWSwgbGF5b3V0LnkudXNlU21hbGxCYW5kKSAvIDJ9O1xuICAgIH1cblxuICAgIC8vIHNpemVcbiAgICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICAgIHAuc2l6ZSA9IHtzY2FsZTogU0laRSwgZmllbGQ6IGUuZmllbGRSZWYoU0laRSl9O1xuICAgIH0gZWxzZSBpZiAoIWUuaGFzKFgpKSB7XG4gICAgICBwLnNpemUgPSB7dmFsdWU6IGUudmFsdWUoU0laRSl9O1xuICAgIH1cblxuICAgIC8vIHNoYXBlXG4gICAgcC5zaGFwZSA9IHt2YWx1ZTogc2hhcGV9O1xuXG4gICAgLy8gZmlsbFxuICAgIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICAgIHAuZmlsbCA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkUmVmKENPTE9SKX07XG4gICAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgICBwLmZpbGwgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgICB9XG5cbiAgICB2YXIgb3BhY2l0eSA9IGUuZmllbGQoQ09MT1IpLm9wYWNpdHkgIHx8IHN0eWxlLm9wYWNpdHk7XG4gICAgaWYob3BhY2l0eSkgcC5vcGFjaXR5ID0ge3ZhbHVlOiBvcGFjaXR5fTtcblxuICAgIHJldHVybiBwO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0X3Byb3BzKGUsIGxheW91dCwgc3R5bGUsIHN0YXRzKSB7XG4gIHZhciBwID0ge30sXG4gICAgZmllbGQgPSBlLmZpZWxkKFRFWFQpO1xuXG4gIC8vIHhcbiAgaWYgKGUuaGFzKFgpKSB7XG4gICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZFJlZihYKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFgpKSB7XG4gICAgaWYgKGUuaGFzKFRFWFQpICYmIGUuaXNUeXBlKFRFWFQsIFEpKSB7XG4gICAgICBwLnggPSB7dmFsdWU6IGxheW91dC5jZWxsV2lkdGgtNX07XG4gICAgfSBlbHNlIHtcbiAgICAgIHAueCA9IHt2YWx1ZTogZS5iYW5kU2l6ZShYLCBsYXlvdXQueC51c2VTbWFsbEJhbmQpIC8gMn07XG4gICAgfVxuICB9XG5cbiAgLy8geVxuICBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkUmVmKFkpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7dmFsdWU6IGUuYmFuZFNpemUoWSwgbGF5b3V0LnkudXNlU21hbGxCYW5kKSAvIDJ9O1xuICB9XG5cbiAgLy8gc2l6ZVxuICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICBwLmZvbnRTaXplID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZFJlZihTSVpFKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFNJWkUpKSB7XG4gICAgcC5mb250U2l6ZSA9IHt2YWx1ZTogZmllbGQuZm9udC5zaXplfTtcbiAgfVxuXG4gIC8vIGZpbGxcbiAgLy8gY29sb3Igc2hvdWxkIGJlIHNldCB0byBiYWNrZ3JvdW5kXG4gIHAuZmlsbCA9IHt2YWx1ZTogZmllbGQudGV4dC5jb2xvcn07XG5cbiAgdmFyIG9wYWNpdHkgPSBlLmZpZWxkKENPTE9SKS5vcGFjaXR5ICB8fCBzdHlsZS5vcGFjaXR5O1xuICBpZihvcGFjaXR5KSBwLm9wYWNpdHkgPSB7dmFsdWU6IG9wYWNpdHl9O1xuXG4gIC8vIHRleHRcbiAgaWYgKGUuaGFzKFRFWFQpKSB7XG4gICAgaWYgKGUuaXNUeXBlKFRFWFQsIFEpKSB7XG4gICAgICB2YXIgZmllbGRTdGF0cyA9IHN0YXRzW2UuZmllbGROYW1lKG5hbWUpXSxcbiAgICAgICAgbnVtYmVyRm9ybWF0ID0gZmllbGQuZm9ybWF0IHx8IGUubnVtYmVyRm9ybWF0KGZpZWxkU3RhdHMpO1xuXG4gICAgICBwLnRleHQgPSB7dGVtcGxhdGU6ICd7eycgKyBlLmZpZWxkUmVmKFRFWFQpICsgJyB8IG51bWJlcjpcXCcnICtcbiAgICAgICAgbnVtYmVyRm9ybWF0ICsnXFwnfX0nfTtcbiAgICAgIHAuYWxpZ24gPSB7dmFsdWU6IGZpZWxkLmFsaWdufTtcbiAgICB9IGVsc2Uge1xuICAgICAgcC50ZXh0ID0ge2ZpZWxkOiBlLmZpZWxkUmVmKFRFWFQpfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcC50ZXh0ID0ge3ZhbHVlOiBmaWVsZC5wbGFjZWhvbGRlcn07XG4gIH1cblxuICBwLmZvbnQgPSB7dmFsdWU6IGZpZWxkLmZvbnQuZmFtaWx5fTtcbiAgcC5mb250V2VpZ2h0ID0ge3ZhbHVlOiBmaWVsZC5mb250LndlaWdodH07XG4gIHAuZm9udFN0eWxlID0ge3ZhbHVlOiBmaWVsZC5mb250LnN0eWxlfTtcbiAgcC5iYXNlbGluZSA9IHt2YWx1ZTogZmllbGQuYmFzZWxpbmV9O1xuXG4gIHJldHVybiBwO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIHRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKSxcbiAgY29sb3JicmV3ZXIgPSByZXF1aXJlKCdjb2xvcmJyZXdlcicpLFxuICBpbnRlcnBvbGF0ZUxhYiA9IHJlcXVpcmUoJ2QzLWNvbG9yJykuaW50ZXJwb2xhdGVMYWIsXG4gIHNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYS9zY2hlbWEnKTtcblxudmFyIHNjYWxlID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuc2NhbGUubmFtZXMgPSBmdW5jdGlvbihwcm9wcykge1xuICByZXR1cm4gdXRpbC5rZXlzKHV0aWwua2V5cyhwcm9wcykucmVkdWNlKGZ1bmN0aW9uKGEsIHgpIHtcbiAgICBpZiAocHJvcHNbeF0gJiYgcHJvcHNbeF0uc2NhbGUpIGFbcHJvcHNbeF0uc2NhbGVdID0gMTtcbiAgICByZXR1cm4gYTtcbiAgfSwge30pKTtcbn07XG5cbnNjYWxlLmRlZnMgPSBmdW5jdGlvbihuYW1lcywgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMsIHN0eWxlLCBzb3J0aW5nLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gIHJldHVybiBuYW1lcy5yZWR1Y2UoZnVuY3Rpb24oYSwgbmFtZSkge1xuICAgIHZhciBzID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHR5cGU6IHNjYWxlLnR5cGUobmFtZSwgZW5jb2RpbmcpLFxuICAgICAgZG9tYWluOiBzY2FsZS5kb21haW4obmFtZSwgZW5jb2RpbmcsIHN0YXRzLCBzb3J0aW5nLCBvcHQpXG4gICAgfTtcblxuICAgIHMuc29ydCA9IHNjYWxlLnNvcnQocywgZW5jb2RpbmcsIG5hbWUpIHx8IHVuZGVmaW5lZDtcblxuICAgIHNjYWxlLnJhbmdlKHMsIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzLCBvcHQpO1xuXG4gICAgcmV0dXJuIChhLnB1c2gocyksIGEpO1xuICB9LCBbXSk7XG59O1xuXG5zY2FsZS5zb3J0ID0gZnVuY3Rpb24ocywgZW5jb2RpbmcsIG5hbWUpIHtcbiAgcmV0dXJuIHMudHlwZSA9PT0gJ29yZGluYWwnICYmIChcbiAgICAhIWVuY29kaW5nLmJpbihuYW1lKSB8fFxuICAgIGVuY29kaW5nLnNvcnQobmFtZSkubGVuZ3RoID09PSAwXG4gICk7XG59O1xuXG5zY2FsZS50eXBlID0gZnVuY3Rpb24obmFtZSwgZW5jb2RpbmcpIHtcblxuICBzd2l0Y2ggKGVuY29kaW5nLnR5cGUobmFtZSkpIHtcbiAgICBjYXNlIE46IC8vZmFsbCB0aHJvdWdoXG4gICAgY2FzZSBPOiByZXR1cm4gJ29yZGluYWwnO1xuICAgIGNhc2UgVDpcbiAgICAgIHZhciB0aW1lVW5pdCA9IGVuY29kaW5nLmZpZWxkKG5hbWUpLnRpbWVVbml0O1xuICAgICAgcmV0dXJuIHRpbWVVbml0ID8gdGltZS5zY2FsZS50eXBlKHRpbWVVbml0LCBuYW1lKSA6ICd0aW1lJztcbiAgICBjYXNlIFE6XG4gICAgICBpZiAoZW5jb2RpbmcuYmluKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBuYW1lID09PSBDT0xPUiA/ICdsaW5lYXInIDogJ29yZGluYWwnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVuY29kaW5nLnNjYWxlKG5hbWUpLnR5cGU7XG4gIH1cbn07XG5cbnNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uIChuYW1lLCBlbmNvZGluZywgc3RhdHMsIHNvcnRpbmcsIG9wdCkge1xuICB2YXIgZmllbGQgPSBlbmNvZGluZy5maWVsZChuYW1lKTtcblxuICBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFQpKSB7XG4gICAgdmFyIHJhbmdlID0gdGltZS5zY2FsZS5kb21haW4oZmllbGQudGltZVVuaXQsIG5hbWUpO1xuICAgIGlmKHJhbmdlKSByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICBpZiAoZmllbGQuYmluKSB7XG4gICAgLy8gVE9ETyhrYW5pdHcpOiB0aGlzIG11c3QgYmUgY2hhbmdlZCBpbiB2ZzJcbiAgICB2YXIgZmllbGRTdGF0ID0gc3RhdHNbZmllbGQubmFtZV0sXG4gICAgICBiaW5zID0gdXRpbC5nZXRiaW5zKGZpZWxkU3RhdCwgZmllbGQuYmluLm1heGJpbnMgfHwgc2NoZW1hLk1BWEJJTlNfREVGQVVMVCksXG4gICAgICBudW1iaW5zID0gKGJpbnMuc3RvcCAtIGJpbnMuc3RhcnQpIC8gYmlucy5zdGVwO1xuICAgIHJldHVybiB1dGlsLnJhbmdlKG51bWJpbnMpLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gYmlucy5zdGFydCArIGJpbnMuc3RlcCAqIGk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAobmFtZSA9PSBvcHQuc3RhY2spIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogU1RBQ0tFRCxcbiAgICAgIGZpZWxkOiBlbmNvZGluZy5maWVsZFJlZihuYW1lLCB7XG4gICAgICAgIGRhdGE6ICFlbmNvZGluZy5fdmVnYTIsXG4gICAgICAgIHByZWZuOiAob3B0LmZhY2V0ID8gJ21heF8nIDogJycpICsgJ3N1bV8nXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgdmFyIGFnZ3JlZ2F0ZSA9IGVuY29kaW5nLmFnZ3JlZ2F0ZShuYW1lKSxcbiAgICB0aW1lVW5pdCA9IGZpZWxkLnRpbWVVbml0LFxuICAgIHNjYWxlVXNlUmF3RG9tYWluID0gZW5jb2Rpbmcuc2NhbGUobmFtZSkudXNlUmF3RG9tYWluLFxuICAgIHVzZVJhd0RvbWFpbiA9IHNjYWxlVXNlUmF3RG9tYWluICE9PSB1bmRlZmluZWQgP1xuICAgICAgc2NhbGVVc2VSYXdEb21haW4gOiBlbmNvZGluZy5jb25maWcoJ3VzZVJhd0RvbWFpbicpLFxuICAgIG5vdENvdW50T3JTdW0gPSAhYWdncmVnYXRlIHx8IChhZ2dyZWdhdGUgIT09J2NvdW50JyAmJiBhZ2dyZWdhdGUgIT09ICdzdW0nKTtcblxuICBpZiAoIHVzZVJhd0RvbWFpbiAmJiBub3RDb3VudE9yU3VtICYmIChcbiAgICAgIC8vIFEgYWx3YXlzIHVzZXMgbm9uLW9yZGluYWwgc2NhbGUgZXhjZXB0IHdoZW4gaXQncyBiaW5uZWQgYW5kIHRodXMgdXNlcyBvcmRpbmFsIHNjYWxlLlxuICAgICAgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBRKSAmJiAhZmllbGQuYmluKSB8fFxuICAgICAgLy8gVCB1c2VzIG5vbi1vcmRpbmFsIHNjYWxlIHdoZW4gdGhlcmUncyBubyB1bml0IG9yIHdoZW4gdGhlIHVuaXQgaXMgbm90IG9yZGluYWwuXG4gICAgICAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFQpICYmICghdGltZVVuaXQgfHwgIXRpbWUuaXNPcmRpbmFsRm4odGltZVVuaXQpKSlcbiAgICApXG4gICkge1xuICAgIHJldHVybiB7ZGF0YTogUkFXLCBmaWVsZDogZW5jb2RpbmcuZmllbGRSZWYobmFtZSwge25vZm46ICF0aW1lVW5pdH0pfTtcbiAgfVxuXG4gIHJldHVybiB7ZGF0YTogc29ydGluZy5nZXREYXRhc2V0KG5hbWUpLCBmaWVsZDogZW5jb2RpbmcuZmllbGRSZWYobmFtZSl9O1xufTtcblxuXG5zY2FsZS5yYW5nZSA9IGZ1bmN0aW9uIChzLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cykge1xuICB2YXIgc3BlYyA9IGVuY29kaW5nLnNjYWxlKHMubmFtZSksXG4gICAgZmllbGQgPSBlbmNvZGluZy5maWVsZChzLm5hbWUpLFxuICAgIHRpbWVVbml0ID0gZmllbGQudGltZVVuaXQ7XG5cbiAgc3dpdGNoIChzLm5hbWUpIHtcbiAgICBjYXNlIFg6XG4gICAgICBzLnJhbmdlID0gbGF5b3V0LmNlbGxXaWR0aCA/IFswLCBsYXlvdXQuY2VsbFdpZHRoXSA6ICd3aWR0aCc7XG4gICAgICBpZiAocy50eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgcy5iYW5kV2lkdGggPSBlbmNvZGluZy5iYW5kU2l6ZShYLCBsYXlvdXQueC51c2VTbWFsbEJhbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVuY29kaW5nLmlzVHlwZShzLm5hbWUsVCkgJiYgdGltZVVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgICAgIHMuemVybyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMuemVybyA9IHNwZWMuemVybyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHNwZWMuemVybztcbiAgICAgICAgfVxuXG4gICAgICAgIHMucmV2ZXJzZSA9IHNwZWMucmV2ZXJzZTtcbiAgICAgIH1cbiAgICAgIHMucm91bmQgPSB0cnVlO1xuICAgICAgaWYgKHMudHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgIHMubmljZSA9IHRpbWVVbml0IHx8IGVuY29kaW5nLmNvbmZpZygndGltZVNjYWxlTmljZScpO1xuICAgICAgfWVsc2Uge1xuICAgICAgICBzLm5pY2UgPSB0cnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBZOlxuICAgICAgaWYgKHMudHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgIHMucmFuZ2UgPSBsYXlvdXQuY2VsbEhlaWdodCA/XG4gICAgICAgICAgKGZpZWxkLmJpbiA/IFtsYXlvdXQuY2VsbEhlaWdodCwgMF0gOiBbMCwgbGF5b3V0LmNlbGxIZWlnaHRdKSA6XG4gICAgICAgICAgJ2hlaWdodCc7XG4gICAgICAgIHMuYmFuZFdpZHRoID0gZW5jb2RpbmcuYmFuZFNpemUoWSwgbGF5b3V0LnkudXNlU21hbGxCYW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMucmFuZ2UgPSBsYXlvdXQuY2VsbEhlaWdodCA/IFtsYXlvdXQuY2VsbEhlaWdodCwgMF0gOiAnaGVpZ2h0JztcbiAgICAgICAgaWYgKGVuY29kaW5nLmlzVHlwZShzLm5hbWUsVCkgJiYgdGltZVVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgICAgIHMuemVybyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMuemVybyA9IHNwZWMuemVybyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHNwZWMuemVybztcbiAgICAgICAgfVxuXG4gICAgICAgIHMucmV2ZXJzZSA9IHNwZWMucmV2ZXJzZTtcbiAgICAgIH1cblxuICAgICAgcy5yb3VuZCA9IHRydWU7XG5cbiAgICAgIGlmIChzLnR5cGUgPT09ICd0aW1lJykge1xuICAgICAgICBzLm5pY2UgPSB0aW1lVW5pdCB8fCBlbmNvZGluZy5jb25maWcoJ3RpbWVTY2FsZU5pY2UnKTtcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgcy5uaWNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUk9XOiAvLyBzdXBwb3J0IG9ubHkgb3JkaW5hbFxuICAgICAgcy5iYW5kV2lkdGggPSBsYXlvdXQuY2VsbEhlaWdodDtcbiAgICAgIHMucm91bmQgPSB0cnVlO1xuICAgICAgcy5uaWNlID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ09MOiAvLyBzdXBwb3J0IG9ubHkgb3JkaW5hbFxuICAgICAgcy5iYW5kV2lkdGggPSBsYXlvdXQuY2VsbFdpZHRoO1xuICAgICAgcy5yb3VuZCA9IHRydWU7XG4gICAgICBzLm5pY2UgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTSVpFOlxuICAgICAgaWYgKGVuY29kaW5nLmlzKCdiYXInKSkge1xuICAgICAgICAvLyBGSVhNRSB0aGlzIGlzIGRlZmluaXRlbHkgaW5jb3JyZWN0XG4gICAgICAgIC8vIGJ1dCBsZXQncyBmaXggaXQgbGF0ZXIgc2luY2UgYmFyIHNpemUgaXMgYSBiYWQgZW5jb2RpbmcgYW55d2F5XG4gICAgICAgIHMucmFuZ2UgPSBbMywgTWF0aC5tYXgoZW5jb2RpbmcuYmFuZFNpemUoWCksIGVuY29kaW5nLmJhbmRTaXplKFkpKV07XG4gICAgICB9IGVsc2UgaWYgKGVuY29kaW5nLmlzKFRFWFQpKSB7XG4gICAgICAgIHMucmFuZ2UgPSBbOCwgNDBdO1xuICAgICAgfSBlbHNlIHsgLy9wb2ludFxuICAgICAgICB2YXIgYmFuZFNpemUgPSBNYXRoLm1pbihlbmNvZGluZy5iYW5kU2l6ZShYKSwgZW5jb2RpbmcuYmFuZFNpemUoWSkpIC0gMTtcbiAgICAgICAgcy5yYW5nZSA9IFsxMCwgMC44ICogYmFuZFNpemUqYmFuZFNpemVdO1xuICAgICAgfVxuICAgICAgcy5yb3VuZCA9IHRydWU7XG4gICAgICBzLnplcm8gPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0hBUEU6XG4gICAgICBzLnJhbmdlID0gJ3NoYXBlcyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENPTE9SOlxuICAgICAgcy5yYW5nZSA9IHNjYWxlLmNvbG9yKHMsIGVuY29kaW5nLCBzdGF0cyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nIG5hbWU6ICcrIHMubmFtZSk7XG4gIH1cblxuICBzd2l0Y2ggKHMubmFtZSkge1xuICAgIGNhc2UgUk9XOlxuICAgIGNhc2UgQ09MOlxuICAgICAgcy5wYWRkaW5nID0gZW5jb2RpbmcuY29uZmlnKCdjZWxsUGFkZGluZycpO1xuICAgICAgcy5vdXRlclBhZGRpbmcgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBYOlxuICAgIGNhc2UgWTpcbiAgICAgIGlmIChzLnR5cGUgPT09ICdvcmRpbmFsJykgeyAvLyYmICFzLmJhbmRXaWR0aFxuICAgICAgICBzLnBvaW50cyA9IHRydWU7XG4gICAgICAgIHMucGFkZGluZyA9IGVuY29kaW5nLmZpZWxkKHMubmFtZSkuYmFuZC5wYWRkaW5nO1xuICAgICAgfVxuICB9XG59O1xuXG5zY2FsZS5jb2xvciA9IGZ1bmN0aW9uKHMsIGVuY29kaW5nLCBzdGF0cykge1xuICB2YXIgY29sb3JTY2FsZSA9IGVuY29kaW5nLnNjYWxlKENPTE9SKSxcbiAgICByYW5nZSA9IGNvbG9yU2NhbGUucmFuZ2UsXG4gICAgY2FyZGluYWxpdHkgPSBlbmNvZGluZy5jYXJkaW5hbGl0eShDT0xPUiwgc3RhdHMpLFxuICAgIHR5cGUgPSBlbmNvZGluZy50eXBlKENPTE9SKTtcblxuICBpZiAocmFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBvcmRpbmFsUGFsZXR0ZSA9IGNvbG9yU2NhbGUub3JkaW5hbFBhbGV0dGU7XG4gICAgaWYgKHMudHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICBpZiAodHlwZSA9PT0gTikge1xuICAgICAgICAvLyB1c2UgY2F0ZWdvcmljYWwgY29sb3Igc2NhbGVcbiAgICAgICAgaWYgKGNhcmRpbmFsaXR5IDw9IDEwKSB7XG4gICAgICAgICAgcmFuZ2UgPSBjb2xvclNjYWxlLmMxMHBhbGV0dGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmFuZ2UgPSBjb2xvclNjYWxlLmMyMHBhbGV0dGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjYXJkaW5hbGl0eSA8PSAyKSB7XG4gICAgICAgICAgcmFuZ2UgPSBbY29sb3JicmV3ZXJbb3JkaW5hbFBhbGV0dGVdWzNdWzBdLCBjb2xvcmJyZXdlcltvcmRpbmFsUGFsZXR0ZV1bM11bMl1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJhbmdlID0gb3JkaW5hbFBhbGV0dGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvL3RpbWUgb3IgcXVhbnRpdGF0aXZlXG4gICAgICB2YXIgcGFsZXR0ZSA9IGNvbG9yYnJld2VyW29yZGluYWxQYWxldHRlXVs5XTtcbiAgICAgIHJhbmdlID0gW3BhbGV0dGVbMF0sIHBhbGV0dGVbOF1dO1xuICAgICAgcy56ZXJvID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBzY2FsZS5jb2xvci5wYWxldHRlKHJhbmdlLCBjYXJkaW5hbGl0eSwgdHlwZSk7XG59O1xuXG5zY2FsZS5jb2xvci5wYWxldHRlID0gZnVuY3Rpb24ocmFuZ2UsIGNhcmRpbmFsaXR5LCB0eXBlKSB7XG4gIHN3aXRjaCAocmFuZ2UpIHtcbiAgICBjYXNlICdjYXRlZ29yeTEwayc6XG4gICAgICAvLyB0YWJsZWF1J3MgY2F0ZWdvcnkgMTAsIG9yZGVyZWQgYnkgcGVyY2VwdHVhbCBrZXJuZWwgc3R1ZHkgcmVzdWx0c1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3V3ZGF0YS9wZXJjZXB0dWFsLWtlcm5lbHNcbiAgICAgIHJldHVybiBbJyMyY2EwMmMnLCAnI2UzNzdjMicsICcjN2Y3ZjdmJywgJyMxN2JlY2YnLCAnIzhjNTY0YicsICcjZDYyNzI4JywgJyNiY2JkMjInLCAnIzk0NjdiZCcsICcjZmY3ZjBlJywgJyMxZjc3YjQnXTtcblxuICAgIC8vIGQzL3RhYmxlYXUgY2F0ZWdvcnkxMC8yMC8yMGIvMjBjXG4gICAgY2FzZSAnY2F0ZWdvcnkxMCc6XG4gICAgICByZXR1cm4gWycjMWY3N2I0JywgJyNmZjdmMGUnLCAnIzJjYTAyYycsICcjZDYyNzI4JywgJyM5NDY3YmQnLCAnIzhjNTY0YicsICcjZTM3N2MyJywgJyM3ZjdmN2YnLCAnI2JjYmQyMicsICcjMTdiZWNmJ107XG5cbiAgICBjYXNlICdjYXRlZ29yeTIwJzpcbiAgICAgIHJldHVybiBbJyMxZjc3YjQnLCAnI2FlYzdlOCcsICcjZmY3ZjBlJywgJyNmZmJiNzgnLCAnIzJjYTAyYycsICcjOThkZjhhJywgJyNkNjI3MjgnLCAnI2ZmOTg5NicsICcjOTQ2N2JkJywgJyNjNWIwZDUnLCAnIzhjNTY0YicsICcjYzQ5Yzk0JywgJyNlMzc3YzInLCAnI2Y3YjZkMicsICcjN2Y3ZjdmJywgJyNjN2M3YzcnLCAnI2JjYmQyMicsICcjZGJkYjhkJywgJyMxN2JlY2YnLCAnIzllZGFlNSddO1xuXG4gICAgY2FzZSAnY2F0ZWdvcnkyMGInOlxuICAgICAgcmV0dXJuIFsnIzM5M2I3OScsICcjNTI1NGEzJywgJyM2YjZlY2YnLCAnIzljOWVkZScsICcjNjM3OTM5JywgJyM4Y2EyNTInLCAnI2I1Y2Y2YicsICcjY2VkYjljJywgJyM4YzZkMzEnLCAnI2JkOWUzOScsICcjZTdiYTUyJywgJyNlN2NiOTQnLCAnIzg0M2MzOScsICcjYWQ0OTRhJywgJyNkNjYxNmInLCAnI2U3OTY5YycsICcjN2I0MTczJywgJyNhNTUxOTQnLCAnI2NlNmRiZCcsICcjZGU5ZWQ2J107XG5cbiAgICBjYXNlICdjYXRlZ29yeTIwYyc6XG4gICAgICByZXR1cm4gWycjMzE4MmJkJywgJyM2YmFlZDYnLCAnIzllY2FlMScsICcjYzZkYmVmJywgJyNlNjU1MGQnLCAnI2ZkOGQzYycsICcjZmRhZTZiJywgJyNmZGQwYTInLCAnIzMxYTM1NCcsICcjNzRjNDc2JywgJyNhMWQ5OWInLCAnI2M3ZTljMCcsICcjNzU2YmIxJywgJyM5ZTlhYzgnLCAnI2JjYmRkYycsICcjZGFkYWViJywgJyM2MzYzNjMnLCAnIzk2OTY5NicsICcjYmRiZGJkJywgJyNkOWQ5ZDknXTtcbiAgfVxuXG4gIGlmIChyYW5nZSBpbiBjb2xvcmJyZXdlcikge1xuICAgIHZhciBwYWxldHRlID0gY29sb3JicmV3ZXJbcmFuZ2VdLFxuICAgICAgcHMgPSA1O1xuXG4gICAgLy8gaWYgY2FyZGluYWxpdHkgcHJlLWRlZmluZWQsIHVzZSBpdC5cbiAgICBpZiAoY2FyZGluYWxpdHkgaW4gcGFsZXR0ZSkgcmV0dXJuIHBhbGV0dGVbY2FyZGluYWxpdHldO1xuXG4gICAgLy8gaWYgbm90LCB1c2UgdGhlIGhpZ2hlc3QgY2FyZGluYWxpdHkgb25lIGZvciBub21pbmFsXG4gICAgaWYgKHR5cGUgPT09IE4pIHtcbiAgICAgIHJldHVybiBwYWxldHRlW01hdGgubWF4LmFwcGx5KG51bGwsIHV0aWwua2V5cyhwYWxldHRlKSldO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSwgaW50ZXJwb2xhdGVcbiAgICByZXR1cm4gc2NhbGUuY29sb3IuaW50ZXJwb2xhdGUocGFsZXR0ZVtwc11bMF0sIHBhbGV0dGVbcHNdW3BzLTFdLCBjYXJkaW5hbGl0eSk7XG4gIH1cblxuICByZXR1cm4gcmFuZ2U7XG59O1xuXG5zY2FsZS5jb2xvci5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBjYXJkaW5hbGl0eSkge1xuICB2YXIgaW50ZXJwb2xhdG9yID0gaW50ZXJwb2xhdGVMYWIoc3RhcnQsIGVuZCk7XG4gIHJldHVybiB1dGlsLnJhbmdlKGNhcmRpbmFsaXR5KS5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gaW50ZXJwb2xhdG9yKGkqMS4wLyhjYXJkaW5hbGl0eS0xKSk7IH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgdmxmaWVsZCA9IHJlcXVpcmUoJy4uL2ZpZWxkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYWRkU29ydFRyYW5zZm9ybXM7XG5cbi8vIGFkZHMgbmV3IHRyYW5zZm9ybXMgdGhhdCBwcm9kdWNlIHNvcnRlZCBmaWVsZHNcbmZ1bmN0aW9uIGFkZFNvcnRUcmFuc2Zvcm1zKGRhdGEsIGVuY29kaW5nLCBzdGF0cywgb3B0KSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcblxuICB2YXIgZGF0YXNldE1hcHBpbmcgPSB7fTtcbiAgdmFyIGNvdW50ZXIgPSAwO1xuXG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICB2YXIgc29ydEJ5ID0gZW5jb2Rpbmcuc29ydChlbmNUeXBlLCBzdGF0cyk7XG4gICAgaWYgKHNvcnRCeS5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgZmllbGRzID0gc29ydEJ5Lm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb3A6IGQuYWdncmVnYXRlLFxuICAgICAgICAgIGZpZWxkOiB2bGZpZWxkLmZpZWxkUmVmKGQsIHtub2ZuOiB0cnVlLCBkYXRhOiAhZW5jb2RpbmcuX3ZlZ2EyfSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgYnlDbGF1c2UgPSBzb3J0QnkubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdmFyIHJldmVyc2UgPSAoZC5yZXZlcnNlID8gJy0nIDogJycpO1xuICAgICAgICByZXR1cm4gcmV2ZXJzZSArIHZsZmllbGQuZmllbGRSZWYoZCwge2RhdGE6ICFlbmNvZGluZy5fdmVnYTJ9KTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZGF0YU5hbWUgPSAnc29ydGVkJyArIGNvdW50ZXIrKztcblxuICAgICAgdmFyIHRyYW5zZm9ybXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgICAgICBncm91cGJ5OiBbIGVuY29kaW5nLmZpZWxkUmVmKGVuY1R5cGUpIF0sXG4gICAgICAgICAgZmllbGRzOiBmaWVsZHNcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICdzb3J0JyxcbiAgICAgICAgICBieTogYnlDbGF1c2VcbiAgICAgICAgfVxuICAgICAgXTtcblxuICAgICAgZGF0YS5wdXNoKHtcbiAgICAgICAgbmFtZTogZGF0YU5hbWUsXG4gICAgICAgIHNvdXJjZTogUkFXLFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybXNcbiAgICAgIH0pO1xuXG4gICAgICBkYXRhc2V0TWFwcGluZ1tlbmNUeXBlXSA9IGRhdGFOYW1lO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBnZXREYXRhc2V0OiBmdW5jdGlvbihlbmNUeXBlKSB7XG4gICAgICB2YXIgZGF0YSA9IGRhdGFzZXRNYXBwaW5nW2VuY1R5cGVdO1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBUQUJMRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfTtcbn1cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciAgbWFya3MgPSByZXF1aXJlKCcuL21hcmtzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tpbmc7XG5cbmZ1bmN0aW9uIHN0YWNraW5nKGRhdGEsIGVuY29kaW5nLCBtZGVmLCBmYWNldHMpIHtcbiAgaWYgKCFtYXJrc1tlbmNvZGluZy5tYXJrdHlwZSgpXS5zdGFjaykgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIFRPRE86IGFkZCB8fCBlbmNvZGluZy5oYXMoTE9EKSBoZXJlIG9uY2UgTE9EIGlzIGltcGxlbWVudGVkXG4gIGlmICghZW5jb2RpbmcuaGFzKENPTE9SKSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBkaW09bnVsbCwgdmFsPW51bGwsIGlkeCA9bnVsbCxcbiAgICBpc1hNZWFzdXJlID0gZW5jb2RpbmcuaXNNZWFzdXJlKFgpLFxuICAgIGlzWU1lYXN1cmUgPSBlbmNvZGluZy5pc01lYXN1cmUoWSk7XG5cbiAgaWYgKGlzWE1lYXN1cmUgJiYgIWlzWU1lYXN1cmUpIHtcbiAgICBkaW0gPSBZO1xuICAgIHZhbCA9IFg7XG4gICAgaWR4ID0gMDtcbiAgfSBlbHNlIGlmIChpc1lNZWFzdXJlICYmICFpc1hNZWFzdXJlKSB7XG4gICAgZGltID0gWDtcbiAgICB2YWwgPSBZO1xuICAgIGlkeCA9IDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7IC8vIG5vIHN0YWNrIGVuY29kaW5nXG4gIH1cblxuICAvLyBhZGQgdHJhbnNmb3JtIHRvIGNvbXB1dGUgc3VtcyBmb3Igc2NhbGVcbiAgdmFyIHN0YWNrZWQgPSB7XG4gICAgbmFtZTogU1RBQ0tFRCxcbiAgICBzb3VyY2U6IFRBQkxFLFxuICAgIHRyYW5zZm9ybTogW3tcbiAgICAgIHR5cGU6ICdhZ2dyZWdhdGUnLFxuICAgICAgZ3JvdXBieTogW2VuY29kaW5nLmZpZWxkUmVmKGRpbSldLmNvbmNhdChmYWNldHMpLCAvLyBkaW0gYW5kIG90aGVyIGZhY2V0c1xuICAgICAgZmllbGRzOiBbe29wOiAnc3VtJywgZmllbGQ6IGVuY29kaW5nLmZpZWxkUmVmKHZhbCl9XSAvLyBUT0RPIGNoZWNrIGlmIGZpZWxkIHdpdGggYWdncmVnYXRlIGlzIGNvcnJlY3Q/XG4gICAgfV1cbiAgfTtcblxuICBpZiAoZmFjZXRzICYmIGZhY2V0cy5sZW5ndGggPiAwKSB7XG4gICAgc3RhY2tlZC50cmFuc2Zvcm0ucHVzaCh7IC8vY2FsY3VsYXRlIG1heCBmb3IgZWFjaCBmYWNldFxuICAgICAgdHlwZTogJ2FnZ3JlZ2F0ZScsXG4gICAgICBncm91cGJ5OiBmYWNldHMsXG4gICAgICBmaWVsZHM6IFt7XG4gICAgICAgIG9wOiAnbWF4JyxcbiAgICAgICAgZmllbGQ6IGVuY29kaW5nLmZpZWxkTmFtZSh2YWwsIHtmbjogJ3N1bSd9KVxuICAgICAgfV1cbiAgICB9KTtcbiAgfVxuXG4gIGRhdGEucHVzaChzdGFja2VkKTtcblxuICAvLyBhZGQgc3RhY2sgdHJhbnNmb3JtIHRvIG1hcmtcbiAgbWRlZi5mcm9tLnRyYW5zZm9ybSA9IFt7XG4gICAgdHlwZTogJ3N0YWNrJyxcbiAgICBwb2ludDogZW5jb2RpbmcuZmllbGRSZWYoZGltKSxcbiAgICBoZWlnaHQ6IGVuY29kaW5nLmZpZWxkUmVmKHZhbCksXG4gICAgb3V0cHV0OiB7eTE6IHZhbCwgeTA6IHZhbCArICcyJ31cbiAgfV07XG5cbiAgLy8gVE9ETzogVGhpcyBpcyBzdXBlciBoYWNrLWlzaCAtLSBjb25zb2xpZGF0ZSBpbnRvIG1vZHVsYXIgbWFyayBwcm9wZXJ0aWVzP1xuICBtZGVmLnByb3BlcnRpZXMudXBkYXRlW3ZhbF0gPSBtZGVmLnByb3BlcnRpZXMuZW50ZXJbdmFsXSA9IHtzY2FsZTogdmFsLCBmaWVsZDogdmFsfTtcbiAgbWRlZi5wcm9wZXJ0aWVzLnVwZGF0ZVt2YWwgKyAnMiddID0gbWRlZi5wcm9wZXJ0aWVzLmVudGVyW3ZhbCArICcyJ10gPSB7c2NhbGU6IHZhbCwgZmllbGQ6IHZhbCArICcyJ307XG5cbiAgcmV0dXJuIHZhbDsgLy9yZXR1cm4gc3RhY2sgZW5jb2Rpbmdcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgdmxmaWVsZCA9IHJlcXVpcmUoJy4uL2ZpZWxkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZW5jb2RpbmcsIHN0YXRzKSB7XG4gIHJldHVybiB7XG4gICAgb3BhY2l0eTogZXN0aW1hdGVPcGFjaXR5KGVuY29kaW5nLCBzdGF0cyksXG4gIH07XG59O1xuXG5mdW5jdGlvbiBlc3RpbWF0ZU9wYWNpdHkoZW5jb2Rpbmcsc3RhdHMpIHtcbiAgaWYgKCFzdGF0cykge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIG51bVBvaW50cyA9IDA7XG5cbiAgaWYgKGVuY29kaW5nLmlzQWdncmVnYXRlKCkpIHsgLy8gYWdncmVnYXRlIHBsb3RcbiAgICBudW1Qb2ludHMgPSAxO1xuXG4gICAgLy8gIGdldCBudW1iZXIgb2YgcG9pbnRzIGluIGVhY2ggXCJjZWxsXCJcbiAgICAvLyAgYnkgY2FsY3VsYXRpbmcgcHJvZHVjdCBvZiBjYXJkaW5hbGl0eVxuICAgIC8vICBmb3IgZWFjaCBub24gZmFjZXRpbmcgYW5kIG5vbi1vcmRpbmFsIFggLyBZIGZpZWxkc1xuICAgIC8vICBub3RlIHRoYXQgb3JkaW5hbCB4LHkgYXJlIG5vdCBpbmNsdWRlIHNpbmNlIHdlIGNhblxuICAgIC8vICBjb25zaWRlciB0aGF0IG9yZGluYWwgeCBhcmUgc3ViZGl2aWRpbmcgdGhlIGNlbGwgaW50byBzdWJjZWxscyBhbnl3YXlcbiAgICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBlbmNUeXBlKSB7XG5cbiAgICAgIGlmIChlbmNUeXBlICE9PSBST1cgJiYgZW5jVHlwZSAhPT0gQ09MICYmXG4gICAgICAgICAgISgoZW5jVHlwZSA9PT0gWCB8fCBlbmNUeXBlID09PSBZKSAmJlxuICAgICAgICAgIHZsZmllbGQuaXNPcmRpbmFsU2NhbGUoZmllbGQpKVxuICAgICAgICApIHtcbiAgICAgICAgbnVtUG9pbnRzICo9IGVuY29kaW5nLmNhcmRpbmFsaXR5KGVuY1R5cGUsIHN0YXRzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9IGVsc2UgeyAvLyByYXcgcGxvdFxuICAgIG51bVBvaW50cyA9IHN0YXRzLmNvdW50O1xuXG4gICAgLy8gc21hbGwgbXVsdGlwbGVzIGRpdmlkZSBudW1iZXIgb2YgcG9pbnRzXG4gICAgdmFyIG51bU11bHRpcGxlcyA9IDE7XG4gICAgaWYgKGVuY29kaW5nLmhhcyhST1cpKSB7XG4gICAgICBudW1NdWx0aXBsZXMgKj0gZW5jb2RpbmcuY2FyZGluYWxpdHkoUk9XLCBzdGF0cyk7XG4gICAgfVxuICAgIGlmIChlbmNvZGluZy5oYXMoQ09MKSkge1xuICAgICAgbnVtTXVsdGlwbGVzICo9IGVuY29kaW5nLmNhcmRpbmFsaXR5KENPTCwgc3RhdHMpO1xuICAgIH1cbiAgICBudW1Qb2ludHMgLz0gbnVtTXVsdGlwbGVzO1xuICB9XG5cbiAgdmFyIG9wYWNpdHkgPSAwO1xuICBpZiAobnVtUG9pbnRzIDwgMjApIHtcbiAgICBvcGFjaXR5ID0gMTtcbiAgfSBlbHNlIGlmIChudW1Qb2ludHMgPCAyMDApIHtcbiAgICBvcGFjaXR5ID0gMC43O1xuICB9IGVsc2UgaWYgKG51bVBvaW50cyA8IDEwMDAgfHwgZW5jb2RpbmcuaXMoJ3RpY2snKSkge1xuICAgIG9wYWNpdHkgPSAwLjY7XG4gIH0gZWxzZSB7XG4gICAgb3BhY2l0eSA9IDAuMztcbiAgfVxuXG4gIHJldHVybiBvcGFjaXR5O1xufVxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIGdyb3VwZGVmID0gcmVxdWlyZSgnLi9ncm91cCcpLmRlZjtcblxubW9kdWxlLmV4cG9ydHMgPSBzdWJmYWNldGluZztcblxuZnVuY3Rpb24gc3ViZmFjZXRpbmcoZ3JvdXAsIG1kZWYsIGRldGFpbHMsIHN0YWNrLCBlbmNvZGluZykge1xuICB2YXIgbSA9IGdyb3VwLm1hcmtzLFxuICAgIGcgPSBncm91cGRlZignc3ViZmFjZXQnLCB7bWFya3M6IG19KTtcblxuICBncm91cC5tYXJrcyA9IFtnXTtcbiAgZy5mcm9tID0gbWRlZi5mcm9tO1xuICBkZWxldGUgbWRlZi5mcm9tO1xuXG4gIC8vVE9ETyB0ZXN0IExPRCAtLSB3ZSBzaG91bGQgc3VwcG9ydCBzdGFjayAvIGxpbmUgd2l0aG91dCBjb2xvciAoTE9EKSBmaWVsZFxuICB2YXIgdHJhbnMgPSAoZy5mcm9tLnRyYW5zZm9ybSB8fCAoZy5mcm9tLnRyYW5zZm9ybSA9IFtdKSk7XG4gIHRyYW5zLnVuc2hpZnQoe3R5cGU6ICdmYWNldCcsIGtleXM6IGRldGFpbHN9KTtcblxuICBpZiAoc3RhY2sgJiYgZW5jb2RpbmcuaGFzKENPTE9SKSkge1xuICAgIHRyYW5zLnVuc2hpZnQoe3R5cGU6ICdzb3J0JywgYnk6IGVuY29kaW5nLmZpZWxkUmVmKENPTE9SKX0pO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIGdyb3VwZGVmID0gcmVxdWlyZSgnLi9ncm91cCcpLmRlZixcbiAgdmxmaWVsZCA9IHJlcXVpcmUoJy4uL2ZpZWxkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdGVtcGxhdGU7XG5cbmZ1bmN0aW9uIHRlbXBsYXRlKGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcblxuICB2YXIgZGF0YSA9IHtuYW1lOiBSQVcsIGZvcm1hdDoge319LFxuICAgIHRhYmxlID0ge25hbWU6IFRBQkxFLCBzb3VyY2U6IFJBV30sXG4gICAgZGF0YVVybCA9IGVuY29kaW5nLmRhdGEoJ3VybCcpLFxuICAgIGRhdGFUeXBlID0gZW5jb2RpbmcuZGF0YSgnZm9ybWF0VHlwZScpLFxuICAgIHZhbHVlcyA9IGVuY29kaW5nLmRhdGEoJ3ZhbHVlcycpO1xuXG4gIGlmIChlbmNvZGluZy5oYXNWYWx1ZXMoKSkge1xuICAgIGRhdGEudmFsdWVzID0gdmFsdWVzO1xuICB9IGVsc2Uge1xuICAgIGRhdGEudXJsID0gZGF0YVVybDtcbiAgICBkYXRhLmZvcm1hdC50eXBlID0gZGF0YVR5cGU7XG4gIH1cblxuICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBlbmNUeXBlKSB7XG4gICAgdmFyIG5hbWU7XG4gICAgaWYgKGZpZWxkLnR5cGUgPT0gVCkge1xuICAgICAgZGF0YS5mb3JtYXQucGFyc2UgPSBkYXRhLmZvcm1hdC5wYXJzZSB8fCB7fTtcbiAgICAgIGRhdGEuZm9ybWF0LnBhcnNlW2ZpZWxkLm5hbWVdID0gJ2RhdGUnO1xuICAgIH0gZWxzZSBpZiAoZmllbGQudHlwZSA9PSBRKSB7XG4gICAgICBkYXRhLmZvcm1hdC5wYXJzZSA9IGRhdGEuZm9ybWF0LnBhcnNlIHx8IHt9O1xuICAgICAgaWYgKHZsZmllbGQuaXNDb3VudChmaWVsZCkpIHtcbiAgICAgICAgbmFtZSA9ICdjb3VudCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lID0gZmllbGQubmFtZTtcbiAgICAgIH1cbiAgICAgIGRhdGEuZm9ybWF0LnBhcnNlW25hbWVdID0gJ251bWJlcic7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiBsYXlvdXQud2lkdGgsXG4gICAgaGVpZ2h0OiBsYXlvdXQuaGVpZ2h0LFxuICAgIHBhZGRpbmc6ICdhdXRvJyxcbiAgICBkYXRhOiBbZGF0YSwgdGFibGVdLFxuICAgIG1hcmtzOiBbZ3JvdXBkZWYoJ2NlbGwnLCB7XG4gICAgICB3aWR0aDogbGF5b3V0LmNlbGxXaWR0aCA/IHt2YWx1ZTogbGF5b3V0LmNlbGxXaWR0aH0gOiB1bmRlZmluZWQsXG4gICAgICBoZWlnaHQ6IGxheW91dC5jZWxsSGVpZ2h0ID8ge3ZhbHVlOiBsYXlvdXQuY2VsbEhlaWdodH0gOiB1bmRlZmluZWRcbiAgICB9KV1cbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIGQzX3RpbWVfZm9ybWF0ID0gcmVxdWlyZSgnZDMtdGltZS1mb3JtYXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0aW1lO1xuXG52YXIgTE9OR19EQVRFID0gbmV3IERhdGUoMjAxNCwgOCwgMTcpO1xuXG5mdW5jdGlvbiB0aW1lKHNwZWMsIGVuY29kaW5nKSB7IC8vIEZJWE1FIHJlZmFjdG9yIHRvIHJlZHVjZSBzaWRlIGVmZmVjdCAjMjc2XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIHRpbWVGaWVsZHMgPSB7fSwgdGltZVVuaXRzID0ge307XG5cbiAgLy8gZmluZCB1bmlxdWUgZm9ybXVsYSB0cmFuc2Zvcm1hdGlvbiBhbmQgYmluIGZ1bmN0aW9uXG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICBpZiAoZmllbGQudHlwZSA9PT0gVCAmJiBmaWVsZC50aW1lVW5pdCkge1xuICAgICAgdGltZUZpZWxkc1tlbmNvZGluZy5maWVsZFJlZihlbmNUeXBlKV0gPSB7XG4gICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgZW5jVHlwZTogZW5jVHlwZVxuICAgICAgfTtcbiAgICAgIHRpbWVVbml0c1tmaWVsZC50aW1lVW5pdF0gPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYWRkIGZvcm11bGEgdHJhbnNmb3JtXG4gIHZhciBkYXRhID0gc3BlYy5kYXRhWzBdLFxuICAgIHRyYW5zZm9ybSA9IGRhdGEudHJhbnNmb3JtID0gZGF0YS50cmFuc2Zvcm0gfHwgW107XG5cbiAgZm9yICh2YXIgZiBpbiB0aW1lRmllbGRzKSB7XG4gICAgdmFyIHRmID0gdGltZUZpZWxkc1tmXTtcbiAgICB0aW1lLnRyYW5zZm9ybSh0cmFuc2Zvcm0sIGVuY29kaW5nLCB0Zi5lbmNUeXBlLCB0Zi5maWVsZCk7XG4gIH1cblxuICAvLyBhZGQgc2NhbGVzXG4gIHZhciBzY2FsZXMgPSBzcGVjLnNjYWxlcyA9IHNwZWMuc2NhbGVzIHx8IFtdO1xuICBmb3IgKHZhciB0aW1lVW5pdCBpbiB0aW1lVW5pdHMpIHtcbiAgICB2YXIgc2NhbGUgPSB0aW1lLnNjYWxlLmRlZih0aW1lVW5pdCwgZW5jb2RpbmcpO1xuICAgIGlmIChzY2FsZSkgc2NhbGVzLnB1c2goc2NhbGUpO1xuICB9XG4gIHJldHVybiBzcGVjO1xufVxuXG50aW1lLmNhcmRpbmFsaXR5ID0gZnVuY3Rpb24oZmllbGQsIHN0YXRzLCBmaWx0ZXJOdWxsLCB0eXBlKSB7XG4gIHZhciB0aW1lVW5pdCA9IGZpZWxkLnRpbWVVbml0O1xuICBzd2l0Y2ggKHRpbWVVbml0KSB7XG4gICAgY2FzZSAnc2Vjb25kcyc6IHJldHVybiA2MDtcbiAgICBjYXNlICdtaW51dGVzJzogcmV0dXJuIDYwO1xuICAgIGNhc2UgJ2hvdXJzJzogcmV0dXJuIDI0O1xuICAgIGNhc2UgJ2RheSc6IHJldHVybiA3O1xuICAgIGNhc2UgJ2RhdGUnOiByZXR1cm4gMzE7XG4gICAgY2FzZSAnbW9udGgnOiByZXR1cm4gMTI7XG4gICAgY2FzZSAneWVhcic6XG4gICAgICB2YXIgc3RhdCA9IHN0YXRzW2ZpZWxkLm5hbWVdLFxuICAgICAgICB5ZWFyc3RhdCA9IHN0YXRzWyd5ZWFyXycrZmllbGQubmFtZV07XG5cbiAgICAgIGlmICgheWVhcnN0YXQpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgICAgcmV0dXJuIHllYXJzdGF0LmRpc3RpbmN0IC1cbiAgICAgICAgKHN0YXQubnVsbHMgPiAwICYmIGZpbHRlck51bGxbdHlwZV0gPyAxIDogMCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbnRpbWUubWF4TGVuZ3RoID0gZnVuY3Rpb24odGltZVVuaXQsIGVuY29kaW5nKSB7XG4gIHN3aXRjaCAodGltZVVuaXQpIHtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlICdtb250aCc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICAgIHZhciByYW5nZSA9IHRpbWUucmFuZ2UodGltZVVuaXQsIGVuY29kaW5nKTtcbiAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAvLyByZXR1cm4gdGhlIGxvbmdlc3QgbmFtZSBpbiB0aGUgcmFuZ2VcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIHJhbmdlLm1hcChmdW5jdGlvbihyKSB7cmV0dXJuIHIubGVuZ3RoO30pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgJ3llYXInOlxuICAgICAgcmV0dXJuIDQ7IC8vJzE5OTgnXG4gIH1cbiAgLy8gbm8gdGltZSB1bml0XG4gIHZhciB0aW1lRm9ybWF0ID0gZW5jb2RpbmcuY29uZmlnKCd0aW1lRm9ybWF0Jyk7XG4gIHJldHVybiBkM190aW1lX2Zvcm1hdC51dGNGb3JtYXQodGltZUZvcm1hdCkoTE9OR19EQVRFKS5sZW5ndGg7XG59O1xuXG5mdW5jdGlvbiBmaWVsZEZuKGZ1bmMsIGZpZWxkKSB7XG4gIHJldHVybiAndXRjJyArIGZ1bmMgKyAnKGQuZGF0YS4nKyBmaWVsZC5uYW1lICsnKSc7XG59XG5cbi8qKlxuICogQHJldHVybiB7U3RyaW5nfSBkYXRlIGJpbm5pbmcgZm9ybXVsYSBvZiB0aGUgZ2l2ZW4gZmllbGRcbiAqL1xudGltZS5mb3JtdWxhID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuIGZpZWxkRm4oZmllbGQudGltZVVuaXQsIGZpZWxkKTtcbn07XG5cbi8qKiBhZGQgZm9ybXVsYSB0cmFuc2Zvcm1zIHRvIGRhdGEgKi9cbnRpbWUudHJhbnNmb3JtID0gZnVuY3Rpb24odHJhbnNmb3JtLCBlbmNvZGluZywgZW5jVHlwZSwgZmllbGQpIHtcbiAgdHJhbnNmb3JtLnB1c2goe1xuICAgIHR5cGU6ICdmb3JtdWxhJyxcbiAgICBmaWVsZDogZW5jb2RpbmcuZmllbGRSZWYoZW5jVHlwZSksXG4gICAgZXhwcjogdGltZS5mb3JtdWxhKGZpZWxkKVxuICB9KTtcbn07XG5cbnRpbWUucmFuZ2UgPSBmdW5jdGlvbih0aW1lVW5pdCwgZW5jb2RpbmcpIHtcbiAgdmFyIGxhYmVsTGVuZ3RoID0gZW5jb2RpbmcuY29uZmlnKCd0aW1lU2NhbGVMYWJlbExlbmd0aCcpLFxuICAgIHNjYWxlTGFiZWw7XG4gIHN3aXRjaCAodGltZVVuaXQpIHtcbiAgICBjYXNlICdkYXknOlxuICAgICAgc2NhbGVMYWJlbCA9IGVuY29kaW5nLmNvbmZpZygnZGF5U2NhbGVMYWJlbCcpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbW9udGgnOlxuICAgICAgc2NhbGVMYWJlbCA9IGVuY29kaW5nLmNvbmZpZygnbW9udGhTY2FsZUxhYmVsJyk7XG4gICAgICBicmVhaztcbiAgfVxuICBpZiAoc2NhbGVMYWJlbCkge1xuICAgIHJldHVybiBsYWJlbExlbmd0aCA/IHNjYWxlTGFiZWwubWFwKFxuICAgICAgICBmdW5jdGlvbihzKSB7IHJldHVybiBzLnN1YnN0cigwLCBsYWJlbExlbmd0aCk7fVxuICAgICAgKSA6IHNjYWxlTGFiZWw7XG4gIH1cbiAgcmV0dXJuO1xufTtcblxuXG50aW1lLnNjYWxlID0ge307XG5cbi8qKiBhcHBlbmQgY3VzdG9tIHRpbWUgc2NhbGVzIGZvciBheGlzIGxhYmVsICovXG50aW1lLnNjYWxlLmRlZiA9IGZ1bmN0aW9uKHRpbWVVbml0LCBlbmNvZGluZykge1xuICB2YXIgcmFuZ2UgPSB0aW1lLnJhbmdlKHRpbWVVbml0LCBlbmNvZGluZyk7XG5cbiAgaWYgKHJhbmdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6ICd0aW1lLScrdGltZVVuaXQsXG4gICAgICB0eXBlOiAnb3JkaW5hbCcsXG4gICAgICBkb21haW46IHRpbWUuc2NhbGUuZG9tYWluKHRpbWVVbml0KSxcbiAgICAgIHJhbmdlOiByYW5nZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG50aW1lLmlzT3JkaW5hbEZuID0gZnVuY3Rpb24odGltZVVuaXQpIHtcbiAgc3dpdGNoICh0aW1lVW5pdCkge1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2RhdGUnOlxuICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnRpbWUuc2NhbGUudHlwZSA9IGZ1bmN0aW9uKHRpbWVVbml0LCBuYW1lKSB7XG4gIGlmIChuYW1lID09PSBDT0xPUikge1xuICAgIHJldHVybiAnbGluZWFyJzsgLy8gdGltZSBoYXMgb3JkZXIsIHNvIHVzZSBpbnRlcnBvbGF0ZWQgb3JkaW5hbCBjb2xvciBzY2FsZS5cbiAgfVxuXG4gIHJldHVybiB0aW1lLmlzT3JkaW5hbEZuKHRpbWVVbml0KSB8fCBuYW1lID09PSBDT0wgfHwgbmFtZSA9PT0gUk9XID8gJ29yZGluYWwnIDogJ2xpbmVhcic7XG59O1xuXG50aW1lLnNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKHRpbWVVbml0LCBuYW1lKSB7XG4gIHZhciBpc0NvbG9yID0gbmFtZSA9PT0gQ09MT1I7XG4gIHN3aXRjaCAodGltZVVuaXQpIHtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdtaW51dGVzJzogcmV0dXJuIGlzQ29sb3IgPyBbMCw1OV0gOiB1dGlsLnJhbmdlKDAsIDYwKTtcbiAgICBjYXNlICdob3Vycyc6IHJldHVybiBpc0NvbG9yID8gWzAsMjNdIDogdXRpbC5yYW5nZSgwLCAyNCk7XG4gICAgY2FzZSAnZGF5JzogcmV0dXJuIGlzQ29sb3IgPyBbMCw2XSA6IHV0aWwucmFuZ2UoMCwgNyk7XG4gICAgY2FzZSAnZGF0ZSc6IHJldHVybiBpc0NvbG9yID8gWzEsMzFdIDogdXRpbC5yYW5nZSgxLCAzMik7XG4gICAgY2FzZSAnbW9udGgnOiByZXR1cm4gaXNDb2xvciA/IFswLDExXSA6IHV0aWwucmFuZ2UoMCwgMTIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqIHdoZXRoZXIgYSBwYXJ0aWN1bGFyIHRpbWUgZnVuY3Rpb24gaGFzIGN1c3RvbSBzY2FsZSBmb3IgbGFiZWxzIGltcGxlbWVudGVkIGluIHRpbWUuc2NhbGUgKi9cbnRpbWUuaGFzU2NhbGUgPSBmdW5jdGlvbih0aW1lVW5pdCkge1xuICBzd2l0Y2ggKHRpbWVVbml0KSB7XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdtb250aCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL2dsb2JhbHMnKTtcblxudmFyIGNvbnN0cyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmNvbnN0cy5lbmNvZGluZ1R5cGVzID0gW1gsIFksIFJPVywgQ09MLCBTSVpFLCBTSEFQRSwgQ09MT1IsIFRFWFQsIERFVEFJTF07XG5cbmNvbnN0cy5zaG9ydGhhbmQgPSB7XG4gIGRlbGltOiAgJ3wnLFxuICBhc3NpZ246ICc9JyxcbiAgdHlwZTogICAnLCcsXG4gIGZ1bmM6ICAgJ18nXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL2dsb2JhbHMnKTtcblxudmFyIHN0YXRzID0gcmVxdWlyZSgnZGF0YWxpYi9zcmMvc3RhdHMnKTtcblxudmFyIHZsZGF0YSA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKiBNYXBwaW5nIGZyb20gZGF0YWxpYidzIGluZmVycmVkIHR5cGUgdG8gVmVnYS1saXRlJ3MgdHlwZSAqL1xudmxkYXRhLnR5cGVzID0ge1xuICAnYm9vbGVhbic6IE4sXG4gICdudW1iZXInOiBRLFxuICAnaW50ZWdlcic6IFEsXG4gICdkYXRlJzogVCxcbiAgJ3N0cmluZyc6IE5cbn07XG5cbnZsZGF0YS5zdGF0cyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIHN1bW1hcnkgPSBzdGF0cy5zdW1tYXJ5KGRhdGEpO1xuXG4gIHJldHVybiBzdW1tYXJ5LnJlZHVjZShmdW5jdGlvbihzLCBwcm9maWxlKSB7XG4gICAgc1twcm9maWxlLmZpZWxkXSA9IHByb2ZpbGU7XG4gICAgcmV0dXJuIHM7XG4gIH0sIHtcbiAgICAnKic6IHtcbiAgICAgIG1heDogZGF0YS5sZW5ndGgsXG4gICAgICBtaW46IDBcbiAgICB9XG4gIH0pO1xufTsiLCIvLyB1dGlsaXR5IGZvciBlbmNcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29uc3RzID0gcmVxdWlyZSgnLi9jb25zdHMnKSxcbiAgYyA9IGNvbnN0cy5zaG9ydGhhbmQsXG4gIHZsZmllbGQgPSByZXF1aXJlKCcuL2ZpZWxkJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgc2NoZW1hID0gcmVxdWlyZSgnLi9zY2hlbWEvc2NoZW1hJyksXG4gIGVuY1R5cGVzID0gc2NoZW1hLmVuY1R5cGVzO1xuXG52YXIgdmxlbmMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG52bGVuYy5jb3VudFJldGluYWwgPSBmdW5jdGlvbihlbmMpIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgaWYgKGVuYy5jb2xvcikgY291bnQrKztcbiAgaWYgKGVuYy5zaXplKSBjb3VudCsrO1xuICBpZiAoZW5jLnNoYXBlKSBjb3VudCsrO1xuICByZXR1cm4gY291bnQ7XG59O1xuXG52bGVuYy5oYXMgPSBmdW5jdGlvbihlbmMsIGVuY1R5cGUpIHtcbiAgdmFyIGZpZWxkRGVmID0gZW5jICYmIGVuY1tlbmNUeXBlXTtcbiAgcmV0dXJuIGZpZWxkRGVmICYmIGZpZWxkRGVmLm5hbWU7XG59O1xuXG52bGVuYy5pc0FnZ3JlZ2F0ZSA9IGZ1bmN0aW9uKGVuYykge1xuICBmb3IgKHZhciBrIGluIGVuYykge1xuICAgIGlmICh2bGVuYy5oYXMoZW5jLCBrKSAmJiBlbmNba10uYWdncmVnYXRlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmxlbmMuZm9yRWFjaCA9IGZ1bmN0aW9uKGVuYywgZikge1xuICB2YXIgaSA9IDA7XG4gIGVuY1R5cGVzLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIGlmICh2bGVuYy5oYXMoZW5jLCBrKSkge1xuICAgICAgZihlbmNba10sIGssIGkrKyk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZsZW5jLm1hcCA9IGZ1bmN0aW9uKGVuYywgZikge1xuICB2YXIgYXJyID0gW107XG4gIGVuY1R5cGVzLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIGlmICh2bGVuYy5oYXMoZW5jLCBrKSkge1xuICAgICAgYXJyLnB1c2goZihlbmNba10sIGssIGVuYykpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhcnI7XG59O1xuXG52bGVuYy5yZWR1Y2UgPSBmdW5jdGlvbihlbmMsIGYsIGluaXQpIHtcbiAgdmFyIHIgPSBpbml0O1xuICBlbmNUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICBpZiAodmxlbmMuaGFzKGVuYywgaykpIHtcbiAgICAgIHIgPSBmKHIsIGVuY1trXSwgaywgIGVuYyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHI7XG59O1xuXG4vKlxuICogcmV0dXJuIGtleS12YWx1ZSBwYWlycyBvZiBmaWVsZCBuYW1lIGFuZCBsaXN0IG9mIGZpZWxkcyBvZiB0aGF0IGZpZWxkIG5hbWVcbiAqL1xudmxlbmMuZmllbGRzID0gZnVuY3Rpb24oZW5jKSB7XG4gIHJldHVybiB2bGVuYy5yZWR1Y2UoZW5jLCBmdW5jdGlvbiAobSwgZmllbGQpIHtcbiAgICB2YXIgZmllbGRMaXN0ID0gbVtmaWVsZC5uYW1lXSA9IG1bZmllbGQubmFtZV0gfHwgW10sXG4gICAgICBjb250YWluc1R5cGUgPSBmaWVsZExpc3QuY29udGFpbnNUeXBlID0gZmllbGRMaXN0LmNvbnRhaW5zVHlwZSB8fCB7fTtcblxuICAgIGlmIChmaWVsZExpc3QuaW5kZXhPZihmaWVsZCkgPT09IC0xKSB7XG4gICAgICBmaWVsZExpc3QucHVzaChmaWVsZCk7XG4gICAgICAvLyBhdWdtZW50IHRoZSBhcnJheSB3aXRoIGNvbnRhaW5zVHlwZS5RIC8gTyAvIE4gLyBUXG4gICAgICBjb250YWluc1R5cGVbZmllbGQudHlwZV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbTtcbiAgfSwge30pO1xufTtcblxudmxlbmMuc2hvcnRoYW5kID0gZnVuY3Rpb24oZW5jKSB7XG4gIHJldHVybiB2bGVuYy5tYXAoZW5jLCBmdW5jdGlvbihmaWVsZCwgZXQpIHtcbiAgICByZXR1cm4gZXQgKyBjLmFzc2lnbiArIHZsZmllbGQuc2hvcnRoYW5kKGZpZWxkKTtcbiAgfSkuam9pbihjLmRlbGltKTtcbn07XG5cbnZsZW5jLmZyb21TaG9ydGhhbmQgPSBmdW5jdGlvbihzaG9ydGhhbmQpIHtcbiAgdmFyIGVuYyA9IHV0aWwuaXNBcnJheShzaG9ydGhhbmQpID8gc2hvcnRoYW5kIDogc2hvcnRoYW5kLnNwbGl0KGMuZGVsaW0pO1xuICByZXR1cm4gZW5jLnJlZHVjZShmdW5jdGlvbihtLCBlKSB7XG4gICAgdmFyIHNwbGl0ID0gZS5zcGxpdChjLmFzc2lnbiksXG4gICAgICAgIGVuY3R5cGUgPSBzcGxpdFswXS50cmltKCksXG4gICAgICAgIGZpZWxkID0gc3BsaXRbMV07XG5cbiAgICBtW2VuY3R5cGVdID0gdmxmaWVsZC5mcm9tU2hvcnRoYW5kKGZpZWxkKTtcbiAgICByZXR1cm4gbTtcbiAgfSwge30pO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbi8vIHV0aWxpdHkgZm9yIGZpZWxkXG5cbnJlcXVpcmUoJy4vZ2xvYmFscycpO1xuXG52YXIgY29uc3RzID0gcmVxdWlyZSgnLi9jb25zdHMnKSxcbiAgYyA9IGNvbnN0cy5zaG9ydGhhbmQsXG4gIHRpbWUgPSByZXF1aXJlKCcuL2NvbXBpbGVyL3RpbWUnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICBzY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYS9zY2hlbWEnKTtcblxudmFyIHZsZmllbGQgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSBmaWVsZFxuICogQHBhcmFtIG9wdFxuICogICBvcHQubm9mbiAtLSBleGNsdWRlIGJpbiwgYWdncmVnYXRlLCB0aW1lVW5pdFxuICogICBvcHQuZGF0YSAtIGluY2x1ZGUgJ2RhdGEuJ1xuICogICBvcHQuZm4gLSByZXBsYWNlIGZuIHdpdGggY3VzdG9tIGZ1bmN0aW9uIHByZWZpeFxuICogICBvcHQucHJlZm4gLSBwcmVwZW5kIGZuIHdpdGggY3VzdG9tIGZ1bmN0aW9uIHByZWZpeFxuXG4gKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xudmxmaWVsZC5maWVsZFJlZiA9IGZ1bmN0aW9uKGZpZWxkLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gIHZhciBmID0gKG9wdC5kYXRhID8gJ2RhdGEuJyA6ICcnKSArIChvcHQucHJlZm4gfHwgJycpLFxuICAgIG5vZm4gPSBvcHQubm9mbiB8fCBvcHQuZm4sXG4gICAgbmFtZSA9IGZpZWxkLm5hbWU7XG5cbiAgaWYgKHZsZmllbGQuaXNDb3VudChmaWVsZCkpIHtcbiAgICByZXR1cm4gZiArICdjb3VudCc7XG4gIH0gZWxzZSBpZiAoIW5vZm4gJiYgZmllbGQuYmluKSB7XG4gICAgcmV0dXJuIGYgKyAnYmluXycgKyBuYW1lO1xuICB9IGVsc2UgaWYgKCFub2ZuICYmIGZpZWxkLmFnZ3JlZ2F0ZSkge1xuICAgIHJldHVybiBmICsgZmllbGQuYWdncmVnYXRlICsgJ18nICsgbmFtZTtcbiAgfSBlbHNlIGlmICghbm9mbiAmJiBmaWVsZC50aW1lVW5pdCkge1xuICAgIHJldHVybiBmICsgZmllbGQudGltZVVuaXQgKyAnXycgKyBuYW1lO1xuICB9IGVsc2UgaWYgKG9wdC5mbikge1xuICAgIHJldHVybiBmICsgb3B0LmZuICsgJ18nICsgbmFtZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZiArIG5hbWU7XG4gIH1cbn07XG5cbnZsZmllbGQuc2hvcnRoYW5kID0gZnVuY3Rpb24oZikge1xuICB2YXIgYyA9IGNvbnN0cy5zaG9ydGhhbmQ7XG4gIHJldHVybiAoZi5hZ2dyZWdhdGUgPyBmLmFnZ3JlZ2F0ZSArIGMuZnVuYyA6ICcnKSArXG4gICAgKGYudGltZVVuaXQgPyBmLnRpbWVVbml0ICsgYy5mdW5jIDogJycpICtcbiAgICAoZi5iaW4gPyAnYmluJyArIGMuZnVuYyA6ICcnKSArXG4gICAgKGYubmFtZSB8fCAnJykgKyBjLnR5cGUgKyBmLnR5cGU7XG59O1xuXG52bGZpZWxkLnNob3J0aGFuZHMgPSBmdW5jdGlvbihmaWVsZHMsIGRlbGltKSB7XG4gIGRlbGltID0gZGVsaW0gfHwgYy5kZWxpbTtcbiAgcmV0dXJuIGZpZWxkcy5tYXAodmxmaWVsZC5zaG9ydGhhbmQpLmpvaW4oZGVsaW0pO1xufTtcblxudmxmaWVsZC5mcm9tU2hvcnRoYW5kID0gZnVuY3Rpb24oc2hvcnRoYW5kKSB7XG4gIHZhciBzcGxpdCA9IHNob3J0aGFuZC5zcGxpdChjLnR5cGUpLCBpO1xuICB2YXIgbyA9IHtcbiAgICBuYW1lOiBzcGxpdFswXS50cmltKCksXG4gICAgdHlwZTogc3BsaXRbMV0udHJpbSgpXG4gIH07XG5cbiAgLy8gY2hlY2sgYWdncmVnYXRlIHR5cGVcbiAgZm9yIChpIGluIHNjaGVtYS5hZ2dyZWdhdGUuZW51bSkge1xuICAgIHZhciBhID0gc2NoZW1hLmFnZ3JlZ2F0ZS5lbnVtW2ldO1xuICAgIGlmIChvLm5hbWUuaW5kZXhPZihhICsgJ18nKSA9PT0gMCkge1xuICAgICAgby5uYW1lID0gby5uYW1lLnN1YnN0cihhLmxlbmd0aCArIDEpO1xuICAgICAgaWYgKGEgPT0gJ2NvdW50JyAmJiBvLm5hbWUubGVuZ3RoID09PSAwKSBvLm5hbWUgPSAnKic7XG4gICAgICBvLmFnZ3JlZ2F0ZSA9IGE7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayB0aW1lIHRpbWVVbml0XG4gIGZvciAoaSBpbiBzY2hlbWEudGltZWZucykge1xuICAgIHZhciB0dSA9IHNjaGVtYS50aW1lZm5zW2ldO1xuICAgIGlmIChvLm5hbWUgJiYgby5uYW1lLmluZGV4T2YodHUgKyAnXycpID09PSAwKSB7XG4gICAgICBvLm5hbWUgPSBvLm5hbWUuc3Vic3RyKG8ubGVuZ3RoICsgMSk7XG4gICAgICBvLnRpbWVVbml0ID0gdHU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayBiaW5cbiAgaWYgKG8ubmFtZSAmJiBvLm5hbWUuaW5kZXhPZignYmluXycpID09PSAwKSB7XG4gICAgby5uYW1lID0gby5uYW1lLnN1YnN0cig0KTtcbiAgICBvLmJpbiA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gbztcbn07XG5cbnZhciBpc1R5cGUgPSB2bGZpZWxkLmlzVHlwZSA9IGZ1bmN0aW9uIChmaWVsZERlZiwgdHlwZSkge1xuICByZXR1cm4gZmllbGREZWYudHlwZSA9PT0gdHlwZTtcbn07XG5cbnZhciBpc1R5cGVzID0gdmxmaWVsZC5pc1R5cGVzID0gZnVuY3Rpb24gKGZpZWxkRGVmLCB0eXBlcykge1xuICBmb3IgKHZhciB0PTA7IHQ8dHlwZXMubGVuZ3RoOyB0KyspIHtcbiAgICBpZihmaWVsZERlZi50eXBlID09PSB0eXBlc1t0XSkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLypcbiAqIE1vc3QgZmllbGRzIHRoYXQgdXNlIG9yZGluYWwgc2NhbGUgYXJlIGRpbWVuc2lvbnMuXG4gKiBIb3dldmVyLCBZRUFSKFQpLCBZRUFSTU9OVEgoVCkgdXNlIHRpbWUgc2NhbGUsIG5vdCBvcmRpbmFsIGJ1dCBhcmUgZGltZW5zaW9ucyB0b28uXG4gKi9cbnZsZmllbGQuaXNPcmRpbmFsU2NhbGUgPSBmdW5jdGlvbihmaWVsZCkge1xuICByZXR1cm4gIGlzVHlwZXMoZmllbGQsIFtOLCBPXSkgfHwgZmllbGQuYmluIHx8XG4gICAgKCBpc1R5cGUoZmllbGQsIFQpICYmIGZpZWxkLnRpbWVVbml0ICYmIHRpbWUuaXNPcmRpbmFsRm4oZmllbGQudGltZVVuaXQpICk7XG59O1xuXG5mdW5jdGlvbiBpc0RpbWVuc2lvbihmaWVsZCkge1xuICByZXR1cm4gIGlzVHlwZXMoZmllbGQsIFtOLCBPXSkgfHwgISFmaWVsZC5iaW4gfHxcbiAgICAoIGlzVHlwZShmaWVsZCwgVCkgJiYgISFmaWVsZC50aW1lVW5pdCApO1xufVxuXG4vKipcbiAqIEZvciBlbmNvZGluZywgdXNlIGVuY29kaW5nLmlzRGltZW5zaW9uKCkgdG8gYXZvaWQgY29uZnVzaW9uLlxuICogT3IgdXNlIEVuY29kaW5nLmlzVHlwZSBpZiB5b3VyIGZpZWxkIGlzIGZyb20gRW5jb2RpbmcgKGFuZCB0aHVzIGhhdmUgbnVtZXJpYyBkYXRhIHR5cGUpLlxuICogb3RoZXJ3aXNlLCBkbyBub3Qgc3BlY2lmaWMgaXNUeXBlIHNvIHdlIGNhbiB1c2UgdGhlIGRlZmF1bHQgaXNUeXBlTmFtZSBoZXJlLlxuICovXG52bGZpZWxkLmlzRGltZW5zaW9uID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuIGZpZWxkICYmIGlzRGltZW5zaW9uKGZpZWxkKTtcbn07XG5cbnZsZmllbGQuaXNNZWFzdXJlID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuIGZpZWxkICYmICFpc0RpbWVuc2lvbihmaWVsZCk7XG59O1xuXG52bGZpZWxkLmNvdW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7bmFtZTonKicsIGFnZ3JlZ2F0ZTogJ2NvdW50JywgdHlwZTogUSwgZGlzcGxheU5hbWU6IHZsZmllbGQuY291bnQuZGlzcGxheU5hbWV9O1xufTtcblxudmxmaWVsZC5jb3VudC5kaXNwbGF5TmFtZSA9ICdOdW1iZXIgb2YgUmVjb3Jkcyc7XG5cbnZsZmllbGQuaXNDb3VudCA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiBmaWVsZC5hZ2dyZWdhdGUgPT09ICdjb3VudCc7XG59O1xuXG4vKipcbiAqIEZvciBlbmNvZGluZywgdXNlIGVuY29kaW5nLmNhcmRpbmFsaXR5KCkgdG8gYXZvaWQgY29uZnVzaW9uLiAgT3IgdXNlIEVuY29kaW5nLmlzVHlwZSBpZiB5b3VyIGZpZWxkIGlzIGZyb20gRW5jb2RpbmcgKGFuZCB0aHVzIGhhdmUgbnVtZXJpYyBkYXRhIHR5cGUpLlxuICogb3RoZXJ3aXNlLCBkbyBub3Qgc3BlY2lmaWMgaXNUeXBlIHNvIHdlIGNhbiB1c2UgdGhlIGRlZmF1bHQgaXNUeXBlTmFtZSBoZXJlLlxuICovXG52bGZpZWxkLmNhcmRpbmFsaXR5ID0gZnVuY3Rpb24oZmllbGQsIHN0YXRzLCBmaWx0ZXJOdWxsKSB7XG4gIC8vIEZJWE1FIG5lZWQgdG8gdGFrZSBmaWx0ZXIgaW50byBhY2NvdW50XG5cbiAgdmFyIHN0YXQgPSBzdGF0c1tmaWVsZC5uYW1lXTtcbiAgdmFyIHR5cGUgPSBmaWVsZC50eXBlO1xuXG4gIGZpbHRlck51bGwgPSBmaWx0ZXJOdWxsIHx8IHt9O1xuXG4gIGlmIChmaWVsZC5iaW4pIHtcbiAgICB2YXIgYmlucyA9IHV0aWwuZ2V0YmlucyhzdGF0LCBmaWVsZC5iaW4ubWF4YmlucyB8fCBzY2hlbWEuTUFYQklOU19ERUZBVUxUKTtcbiAgICByZXR1cm4gKGJpbnMuc3RvcCAtIGJpbnMuc3RhcnQpIC8gYmlucy5zdGVwO1xuICB9XG4gIGlmIChpc1R5cGUoZmllbGQsIFQpKSB7XG4gICAgdmFyIGNhcmRpbmFsaXR5ID0gdGltZS5jYXJkaW5hbGl0eShmaWVsZCwgc3RhdHMsIGZpbHRlck51bGwsIHR5cGUpO1xuICAgIGlmKGNhcmRpbmFsaXR5ICE9PSBudWxsKSByZXR1cm4gY2FyZGluYWxpdHk7XG4gICAgLy9vdGhlcndpc2UgdXNlIGNhbGN1bGF0aW9uIGJlbG93XG4gIH1cbiAgaWYgKGZpZWxkLmFnZ3JlZ2F0ZSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLy8gcmVtb3ZlIG51bGxcbiAgcmV0dXJuIHN0YXQuZGlzdGluY3QgLVxuICAgIChzdGF0Lm51bGxzID4gMCAmJiBmaWx0ZXJOdWxsW3R5cGVdID8gMSA6IDApO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gZGVjbGFyZSBnbG9iYWwgY29uc3RhbnRcbnZhciBnID0gZ2xvYmFsIHx8IHdpbmRvdztcblxuZy5UQUJMRSA9ICd0YWJsZSc7XG5nLlJBVyA9ICdyYXcnO1xuZy5TVEFDS0VEID0gJ3N0YWNrZWQnO1xuZy5JTkRFWCA9ICdpbmRleCc7XG5cbmcuWCA9ICd4JztcbmcuWSA9ICd5JztcbmcuUk9XID0gJ3Jvdyc7XG5nLkNPTCA9ICdjb2wnO1xuZy5TSVpFID0gJ3NpemUnO1xuZy5TSEFQRSA9ICdzaGFwZSc7XG5nLkNPTE9SID0gJ2NvbG9yJztcbmcuVEVYVCA9ICd0ZXh0JztcbmcuREVUQUlMID0gJ2RldGFpbCc7XG5cbmcuTiA9ICdOJztcbmcuTyA9ICdPJztcbmcuUSA9ICdRJztcbmcuVCA9ICdUJztcbiIsIi8vIFBhY2thZ2Ugb2YgZGVmaW5pbmcgVmVnYS1saXRlIFNwZWNpZmljYXRpb24ncyBqc29uIHNjaGVtYVxuJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciBzY2hlbWEgPSBtb2R1bGUuZXhwb3J0cyA9IHt9LFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICB0b01hcCA9IHV0aWwudG9NYXAsXG4gIGNvbG9yYnJld2VyID0gcmVxdWlyZSgnY29sb3JicmV3ZXInKTtcblxuc2NoZW1hLnV0aWwgPSByZXF1aXJlKCcuL3NjaGVtYXV0aWwnKTtcblxuc2NoZW1hLm1hcmt0eXBlID0ge1xuICB0eXBlOiAnc3RyaW5nJyxcbiAgZW51bTogWydwb2ludCcsICd0aWNrJywgJ2JhcicsICdsaW5lJywgJ2FyZWEnLCAnY2lyY2xlJywgJ3NxdWFyZScsICd0ZXh0J11cbn07XG5cbnNjaGVtYS5hZ2dyZWdhdGUgPSB7XG4gIHR5cGU6ICdzdHJpbmcnLFxuICBlbnVtOiBbJ2F2ZycsICdzdW0nLCAnbWVkaWFuJywgJ21pbicsICdtYXgnLCAnY291bnQnXSxcbiAgc3VwcG9ydGVkRW51bXM6IHtcbiAgICBROiBbJ2F2ZycsICdtZWRpYW4nLCAnc3VtJywgJ21pbicsICdtYXgnLCAnY291bnQnXSxcbiAgICBPOiBbJ21lZGlhbicsJ21pbicsJ21heCddLFxuICAgIE46IFtdLFxuICAgIFQ6IFsnYXZnJywgJ21lZGlhbicsICdtaW4nLCAnbWF4J10sXG4gICAgJyc6IFsnY291bnQnXVxuICB9LFxuICBzdXBwb3J0ZWRUeXBlczogdG9NYXAoW1EsIE4sIE8sIFQsICcnXSlcbn07XG5cbnNjaGVtYS5nZXRTdXBwb3J0ZWRSb2xlID0gZnVuY3Rpb24oZW5jVHlwZSkge1xuICByZXR1cm4gc2NoZW1hLnNjaGVtYS5wcm9wZXJ0aWVzLmVuY29kaW5nLnByb3BlcnRpZXNbZW5jVHlwZV0uc3VwcG9ydGVkUm9sZTtcbn07XG5cbnNjaGVtYS50aW1lVW5pdHMgPSBbJ3llYXInLCAnbW9udGgnLCAnZGF5JywgJ2RhdGUnLCAnaG91cnMnLCAnbWludXRlcycsICdzZWNvbmRzJ107XG5cbnNjaGVtYS5kZWZhdWx0VGltZUZuID0gJ21vbnRoJztcblxuc2NoZW1hLnRpbWVVbml0ID0ge1xuICB0eXBlOiAnc3RyaW5nJyxcbiAgZW51bTogc2NoZW1hLnRpbWVVbml0cyxcbiAgc3VwcG9ydGVkVHlwZXM6IHRvTWFwKFtUXSlcbn07XG5cbnNjaGVtYS5zY2FsZV90eXBlID0ge1xuICB0eXBlOiAnc3RyaW5nJyxcbiAgLy8gVE9ETyhrYW5pdHcpIHJlYWQgdmVnYSdzIHNjaGVtYSBoZXJlLCBhZGQgZGVzY3JpcHRpb25cbiAgZW51bTogWydsaW5lYXInLCAnbG9nJywgJ3BvdycsICdzcXJ0JywgJ3F1YW50aWxlJ10sXG4gIGRlZmF1bHQ6ICdsaW5lYXInLFxuICBzdXBwb3J0ZWRUeXBlczogdG9NYXAoW1FdKVxufTtcblxuc2NoZW1hLmZpZWxkID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfVxuICB9XG59O1xuXG52YXIgY2xvbmUgPSB1dGlsLmR1cGxpY2F0ZTtcbnZhciBtZXJnZSA9IHNjaGVtYS51dGlsLm1lcmdlO1xuXG5zY2hlbWEuTUFYQklOU19ERUZBVUxUID0gMTU7XG5cbnZhciBiaW4gPSB7XG4gIHR5cGU6IFsnYm9vbGVhbicsICdvYmplY3QnXSxcbiAgZGVmYXVsdDogZmFsc2UsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBtYXhiaW5zOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiBzY2hlbWEuTUFYQklOU19ERUZBVUxULFxuICAgICAgbWluaW11bTogMixcbiAgICAgIGRlc2NyaXB0aW9uOiAnTWF4aW11bSBudW1iZXIgb2YgYmlucy4nXG4gICAgfVxuICB9LFxuICBzdXBwb3J0ZWRUeXBlczogdG9NYXAoW1FdKSAvLyBUT0RPOiBhZGQgTyBhZnRlciBmaW5pc2hpbmcgIzgxXG59O1xuXG52YXIgdHlwaWNhbEZpZWxkID0gbWVyZ2UoY2xvbmUoc2NoZW1hLmZpZWxkKSwge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogW04sIE8sIFEsIFRdXG4gICAgfSxcbiAgICBhZ2dyZWdhdGU6IHNjaGVtYS5hZ2dyZWdhdGUsXG4gICAgdGltZVVuaXQ6IHNjaGVtYS50aW1lVW5pdCxcbiAgICBiaW46IGJpbixcbiAgICBzY2FsZToge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHR5cGU6IHNjaGVtYS5zY2FsZV90eXBlLFxuICAgICAgICByZXZlcnNlOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgIHN1cHBvcnRlZFR5cGVzOiB0b01hcChbUSwgVF0pXG4gICAgICAgIH0sXG4gICAgICAgIHplcm86IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdJbmNsdWRlIHplcm8nLFxuICAgICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgICAgc3VwcG9ydGVkVHlwZXM6IHRvTWFwKFtRLCBUXSlcbiAgICAgICAgfSxcbiAgICAgICAgbmljZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGVudW06IFsnc2Vjb25kJywgJ21pbnV0ZScsICdob3VyJywgJ2RheScsICd3ZWVrJywgJ21vbnRoJywgJ3llYXInXSxcbiAgICAgICAgICBzdXBwb3J0ZWRUeXBlczogdG9NYXAoW1RdKVxuICAgICAgICB9LFxuICAgICAgICB1c2VSYXdEb21haW46IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVXNlIHRoZSByYXcgZGF0YSByYW5nZSBhcyBzY2FsZSBkb21haW4gaW5zdGVhZCBvZiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgJ2FnZ3JlZ2F0ZWQgZGF0YSBmb3IgYWdncmVnYXRlIGF4aXMuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAnVGhpcyBvcHRpb24gZG9lcyBub3Qgd29yayB3aXRoIHN1bSBvciBjb3VudCBhZ2dyZWdhdGUnICtcbiAgICAgICAgICAgICAgICAgICAgICAgJ2FzIHRoZXkgbWlnaHQgaGF2ZSBhIHN1YnN0YW50aWFsbHkgbGFyZ2VyIHNjYWxlIHJhbmdlLicgK1xuICAgICAgICAgICAgICAgICAgICAgICAnQnkgZGVmYXVsdCwgdXNlIHZhbHVlIGZyb20gY29uZmlnLnVzZVJhd0RvbWFpbi4nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgb25seU9yZGluYWxGaWVsZCA9IG1lcmdlKGNsb25lKHNjaGVtYS5maWVsZCksIHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZFJvbGU6IHtcbiAgICBkaW1lbnNpb246IHRydWVcbiAgfSxcbiAgcHJvcGVydGllczoge1xuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogW04sIE8sIFEsIFRdIC8vIG9yZGluYWwtb25seSBmaWVsZCBzdXBwb3J0cyBRIHdoZW4gYmluIGlzIGFwcGxpZWQgYW5kIFQgd2hlbiB0aW1lIHVuaXQgaXMgYXBwbGllZC5cbiAgICB9LFxuICAgIHRpbWVVbml0OiBzY2hlbWEudGltZVVuaXQsXG4gICAgYmluOiBiaW4sXG4gICAgYWdncmVnYXRlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGVudW06IFsnY291bnQnXSxcbiAgICAgIHN1cHBvcnRlZFR5cGVzOiB0b01hcChbTiwgT10pIC8vIEZJWE1FIHRoaXMgbG9va3Mgd2VpcmQgdG8gbWVcbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgYXhpc01peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7cG9pbnQ6IHRydWUsIHRpY2s6IHRydWUsIGJhcjogdHJ1ZSwgbGluZTogdHJ1ZSwgYXJlYTogdHJ1ZSwgY2lyY2xlOiB0cnVlLCBzcXVhcmU6IHRydWV9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgYXhpczoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0EgZmxhZyBpbmRpY2F0ZSBpZiBncmlkbGluZXMgc2hvdWxkIGJlIGNyZWF0ZWQgaW4gYWRkaXRpb24gdG8gdGlja3MuJ1xuICAgICAgICB9LFxuICAgICAgICBsYXllcjoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6ICdiYWNrJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0Egc3RyaW5nIGluZGljYXRpbmcgaWYgdGhlIGF4aXMgKGFuZCBhbnkgZ3JpZGxpbmVzKSBzaG91bGQgYmUgcGxhY2VkIGFib3ZlIG9yIGJlbG93IHRoZSBkYXRhIG1hcmtzLidcbiAgICAgICAgfSxcbiAgICAgICAgb3JpZW50OiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgICAgICAgIGVudW06IFsndG9wJywgJ3JpZ2h0JywgJ2xlZnQnLCAnYm90dG9tJ10sXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdUaGUgb3JpZW50YXRpb24gb2YgdGhlIGF4aXMuIE9uZSBvZiB0b3AsIGJvdHRvbSwgbGVmdCBvciByaWdodC4gVGhlIG9yaWVudGF0aW9uIGNhbiBiZSB1c2VkIHRvIGZ1cnRoZXIgc3BlY2lhbGl6ZSB0aGUgYXhpcyB0eXBlIChlLmcuLCBhIHkgYXhpcyBvcmllbnRlZCBmb3IgdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIGNoYXJ0KS4nXG4gICAgICAgIH0sXG4gICAgICAgIHRpY2tzIDp7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIGRlZmF1bHQ6IDUsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdBIGRlc2lyZWQgbnVtYmVyIG9mIHRpY2tzLCBmb3IgYXhlcyB2aXN1YWxpemluZyBxdWFudGl0YXRpdmUgc2NhbGVzLiBUaGUgcmVzdWx0aW5nIG51bWJlciBtYXkgYmUgZGlmZmVyZW50IHNvIHRoYXQgdmFsdWVzIGFyZSBcIm5pY2VcIiAobXVsdGlwbGVzIG9mIDIsIDUsIDEwKSBhbmQgbGllIHdpdGhpbiB0aGUgdW5kZXJseWluZyBzY2FsZVxcJ3MgcmFuZ2UuJ1xuICAgICAgICB9LFxuICAgICAgICB0aXRsZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0EgdGl0bGUgZm9yIHRoZSBheGlzLiAoU2hvd3MgZmllbGQgbmFtZSBhbmQgaXRzIGZ1bmN0aW9uIGJ5IGRlZmF1bHQuKSdcbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGVNYXhMZW5ndGg6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnTWF4IGxlbmd0aCBmb3IgYXhpcyB0aXRsZSBpZiB0aGUgdGl0bGUgaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgZnJvbSB0aGUgZmllbGRcXCdzIGRlc2NyaXB0aW9uJ1xuICAgICAgICB9LFxuICAgICAgICB0aXRsZU9mZnNldDoge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsICAvLyBhdXRvXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdBIHRpdGxlIG9mZnNldCB2YWx1ZSBmb3IgdGhlIGF4aXMuJ1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXQ6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsICAvLyBhdXRvXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdUaGUgZm9ybWF0dGluZyBwYXR0ZXJuIGZvciBheGlzIGxhYmVscy4gJytcbiAgICAgICAgICAgICAgICAgICAgICAgJ0lmIG5vdCB1bmRlZmluZWQsIHRoaXMgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAnc21hbGwvbGFyZ2VOdW1iZXJGb3JtYXQgYW5kIHRoZSBtYXggdmFsdWUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICdvZiB0aGUgZmllbGQuJ1xuICAgICAgICB9LFxuICAgICAgICBtYXhMYWJlbExlbmd0aDoge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBkZWZhdWx0OiAyNSxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVHJ1bmNhdGUgbGFiZWxzIHRoYXQgYXJlIHRvbyBsb25nLidcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHNvcnRNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBzb3J0OiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgZGVmYXVsdDogW10sXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgc3VwcG9ydGVkVHlwZXM6IHRvTWFwKFtOLCBPXSksXG4gICAgICAgIHJlcXVpcmVkOiBbJ25hbWUnLCAnYWdncmVnYXRlJ10sXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWdncmVnYXRlOiB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGVudW06IFsnYXZnJywgJ3N1bScsICdtaW4nLCAnbWF4JywgJ2NvdW50J11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHJldmVyc2U6IHtcbiAgICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgYmFuZE1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIGJhbmQ6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBkZWZhdWx0OiAxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBsZWdlbmRNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBsZWdlbmQ6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0ZXh0TWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHsndGV4dCc6IHRydWV9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgYWxpZ246IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogJ3JpZ2h0J1xuICAgIH0sXG4gICAgYmFzZWxpbmU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogJ21pZGRsZSdcbiAgICB9LFxuICAgIGNvbG9yOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJvbGU6ICdjb2xvcicsXG4gICAgICBkZWZhdWx0OiAnIzAwMDAwMCdcbiAgICB9LFxuICAgIG1hcmdpbjoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogNCxcbiAgICAgIG1pbmltdW06IDBcbiAgICB9LFxuICAgIHBsYWNlaG9sZGVyOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlZmF1bHQ6ICdBYmMnXG4gICAgfSxcbiAgICBmb250OiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgd2VpZ2h0OiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZW51bTogWydub3JtYWwnLCAnYm9sZCddLFxuICAgICAgICAgIGRlZmF1bHQ6ICdub3JtYWwnXG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgZGVmYXVsdDogMTAsXG4gICAgICAgICAgbWluaW11bTogMFxuICAgICAgICB9LFxuICAgICAgICBmYW1pbHk6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiAnSGVsdmV0aWNhIE5ldWUnXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogJ25vcm1hbCcsXG4gICAgICAgICAgZW51bTogWydub3JtYWwnLCAnaXRhbGljJ11cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZm9ybWF0OiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCwgIC8vIGF1dG9cbiAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIGZvcm1hdHRpbmcgcGF0dGVybiBmb3IgdGV4dCB2YWx1ZS4gJytcbiAgICAgICAgICAgICAgICAgICAnSWYgbm90IHVuZGVmaW5lZCwgdGhpcyB3aWxsIGJlIGRldGVybWluZWQgYnkgJyArXG4gICAgICAgICAgICAgICAgICAgJ3NtYWxsL2xhcmdlTnVtYmVyRm9ybWF0IGFuZCB0aGUgbWF4IHZhbHVlICcgK1xuICAgICAgICAgICAgICAgICAgICdvZiB0aGUgZmllbGQuJ1xuICAgIH0sXG4gIH1cbn07XG5cbnZhciBzaXplTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgYmFyOiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZSwgdGV4dDogdHJ1ZX0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMzAsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfVxuICB9XG59O1xuXG52YXIgY29sb3JNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczoge3BvaW50OiB0cnVlLCB0aWNrOiB0cnVlLCBiYXI6IHRydWUsIGxpbmU6IHRydWUsIGFyZWE6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlLCAndGV4dCc6IHRydWV9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcm9sZTogJ2NvbG9yJyxcbiAgICAgIGRlZmF1bHQ6ICdzdGVlbGJsdWUnXG4gICAgfSxcbiAgICBvcGFjaXR5OiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCwgIC8vIGF1dG9cbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBtYXhpbXVtOiAxXG4gICAgfSxcbiAgICBzY2FsZToge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgdHlwZTogWydzdHJpbmcnLCAnYXJyYXknXSxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgICAnY29sb3IgcGFsZXR0ZSwgaWYgdW5kZWZpbmVkIHZlZ2EtbGl0ZSB3aWxsIHVzZSBkYXRhIHByb3BlcnR5JyArXG4gICAgICAgICAgICAndG8gcGljayBvbmUgZnJvbSBjMTBwYWxldHRlLCBjMjBwYWxldHRlLCBvciBvcmRpbmFsUGFsZXR0ZSdcbiAgICAgICAgfSxcbiAgICAgICAgYzEwcGFsZXR0ZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6ICdjYXRlZ29yeTEwJyxcbiAgICAgICAgICBlbnVtOiBbXG4gICAgICAgICAgICAvLyBUYWJsZWF1XG4gICAgICAgICAgICAnY2F0ZWdvcnkxMCcsICdjYXRlZ29yeTEwaycsXG4gICAgICAgICAgICAvLyBDb2xvciBCcmV3ZXJcbiAgICAgICAgICAgICdQYXN0ZWwxJywgJ1Bhc3RlbDInLCAnU2V0MScsICdTZXQyJywgJ1NldDMnXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBjMjBwYWxldHRlOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogJ2NhdGVnb3J5MjAnLFxuICAgICAgICAgIGVudW06IFsnY2F0ZWdvcnkyMCcsICdjYXRlZ29yeTIwYicsICdjYXRlZ29yeTIwYyddXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYWxldHRlOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogJ0J1R24nLFxuICAgICAgICAgIGVudW06IHV0aWwua2V5cyhjb2xvcmJyZXdlcilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHNoYXBlTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgY2lyY2xlOiB0cnVlLCBzcXVhcmU6IHRydWV9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogWydjaXJjbGUnLCAnc3F1YXJlJywgJ2Nyb3NzJywgJ2RpYW1vbmQnLCAndHJpYW5nbGUtdXAnLCAndHJpYW5nbGUtZG93biddLFxuICAgICAgZGVmYXVsdDogJ2NpcmNsZSdcbiAgICB9LFxuICAgIGZpbGxlZDoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICBkZXNjcmlwdGlvbjogJ3doZXRoZXIgdGhlIHNoYXBlXFwncyBjb2xvciBzaG91bGQgYmUgdXNlZCBhcyBmaWxsIGNvbG9yIGluc3RlYWQgb2Ygc3Ryb2tlIGNvbG9yJ1xuICAgIH1cbiAgfVxufTtcblxudmFyIGRldGFpbE1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7cG9pbnQ6IHRydWUsIHRpY2s6IHRydWUsIGxpbmU6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlfVxufTtcblxudmFyIHJvd01peGluID0ge1xuICBwcm9wZXJ0aWVzOiB7XG4gICAgaGVpZ2h0OiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBkZWZhdWx0OiAxNTBcbiAgICB9XG4gIH1cbn07XG5cbnZhciBjb2xNaXhpbiA9IHtcbiAgcHJvcGVydGllczoge1xuICAgIHdpZHRoOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBkZWZhdWx0OiAxNTBcbiAgICB9LFxuICAgIGF4aXM6IHtcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgbWF4TGFiZWxMZW5ndGg6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgZGVmYXVsdDogMTIsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RydW5jYXRlIGxhYmVscyB0aGF0IGFyZSB0b28gbG9uZy4nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBmYWNldE1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7cG9pbnQ6IHRydWUsIHRpY2s6IHRydWUsIGJhcjogdHJ1ZSwgbGluZTogdHJ1ZSwgYXJlYTogdHJ1ZSwgY2lyY2xlOiB0cnVlLCBzcXVhcmU6IHRydWUsIHRleHQ6IHRydWV9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgcGFkZGluZzoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgbWF4aW11bTogMSxcbiAgICAgIGRlZmF1bHQ6IDAuMVxuICAgIH1cbiAgfVxufTtcblxudmFyIHJlcXVpcmVkTmFtZVR5cGUgPSB7XG4gIHJlcXVpcmVkOiBbJ25hbWUnLCAndHlwZSddXG59O1xuXG52YXIgbXVsdGlSb2xlRmllbGQgPSBtZXJnZShjbG9uZSh0eXBpY2FsRmllbGQpLCB7XG4gIHN1cHBvcnRlZFJvbGU6IHtcbiAgICBtZWFzdXJlOiB0cnVlLFxuICAgIGRpbWVuc2lvbjogdHJ1ZVxuICB9XG59KTtcblxudmFyIHF1YW50aXRhdGl2ZUZpZWxkID0gbWVyZ2UoY2xvbmUodHlwaWNhbEZpZWxkKSwge1xuICBzdXBwb3J0ZWRSb2xlOiB7XG4gICAgbWVhc3VyZTogdHJ1ZSxcbiAgICBkaW1lbnNpb246ICdvcmRpbmFsLW9ubHknIC8vIHVzaW5nIHNpemUgdG8gZW5jb2RpbmcgY2F0ZWdvcnkgbGVhZCB0byBvcmRlciBpbnRlcnByZXRhdGlvblxuICB9XG59KTtcblxudmFyIG9ubHlRdWFudGl0YXRpdmVGaWVsZCA9IG1lcmdlKGNsb25lKHR5cGljYWxGaWVsZCksIHtcbiAgc3VwcG9ydGVkUm9sZToge1xuICAgIG1lYXN1cmU6IHRydWVcbiAgfVxufSk7XG5cbnZhciB4ID0gbWVyZ2UoY2xvbmUobXVsdGlSb2xlRmllbGQpLCBheGlzTWl4aW4sIGJhbmRNaXhpbiwgcmVxdWlyZWROYW1lVHlwZSwgc29ydE1peGluKTtcbnZhciB5ID0gY2xvbmUoeCk7XG5cbnZhciBmYWNldCA9IG1lcmdlKGNsb25lKG9ubHlPcmRpbmFsRmllbGQpLCByZXF1aXJlZE5hbWVUeXBlLCBmYWNldE1peGluLCBzb3J0TWl4aW4pO1xudmFyIHJvdyA9IG1lcmdlKGNsb25lKGZhY2V0KSwgYXhpc01peGluLCByb3dNaXhpbik7XG52YXIgY29sID0gbWVyZ2UoY2xvbmUoZmFjZXQpLCBheGlzTWl4aW4sIGNvbE1peGluKTtcblxudmFyIHNpemUgPSBtZXJnZShjbG9uZShxdWFudGl0YXRpdmVGaWVsZCksIGxlZ2VuZE1peGluLCBzaXplTWl4aW4sIHNvcnRNaXhpbik7XG52YXIgY29sb3IgPSBtZXJnZShjbG9uZShtdWx0aVJvbGVGaWVsZCksIGxlZ2VuZE1peGluLCBjb2xvck1peGluLCBzb3J0TWl4aW4pO1xuXG52YXIgc2hhcGUgPSBtZXJnZShjbG9uZShvbmx5T3JkaW5hbEZpZWxkKSwgbGVnZW5kTWl4aW4sIHNoYXBlTWl4aW4sIHNvcnRNaXhpbik7XG52YXIgZGV0YWlsID0gbWVyZ2UoY2xvbmUob25seU9yZGluYWxGaWVsZCksIGRldGFpbE1peGluLCBzb3J0TWl4aW4pO1xuXG4vLyB3ZSBvbmx5IHB1dCBhZ2dyZWdhdGVkIG1lYXN1cmUgaW4gcGl2b3QgdGFibGVcbnZhciB0ZXh0ID0gbWVyZ2UoY2xvbmUob25seVF1YW50aXRhdGl2ZUZpZWxkKSwgdGV4dE1peGluLCBzb3J0TWl4aW4pO1xuXG4vLyBUT0RPIGFkZCBsYWJlbFxuXG52YXIgZmlsdGVyID0ge1xuICB0eXBlOiAnYXJyYXknLFxuICBpdGVtczoge1xuICAgIHR5cGU6ICdvYmplY3QnLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIG9wZXJhbmRzOiB7XG4gICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgdHlwZTogWydzdHJpbmcnLCAnYm9vbGVhbicsICdpbnRlZ2VyJywgJ251bWJlciddXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvcGVyYXRvcjoge1xuICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgZW51bTogWyc+JywgJz49JywgJz0nLCAnIT0nLCAnPCcsICc8PScsICdub3ROdWxsJ11cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBkYXRhID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIC8vIGRhdGEgc291cmNlXG4gICAgZm9ybWF0VHlwZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbJ2pzb24nLCAnY3N2J10sXG4gICAgICBkZWZhdWx0OiAnanNvbidcbiAgICB9LFxuICAgIHVybDoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICB9LFxuICAgIHZhbHVlczoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgIGRlc2NyaXB0aW9uOiAnUGFzcyBhcnJheSBvZiBvYmplY3RzIGluc3RlYWQgb2YgYSB1cmwgdG8gYSBmaWxlLicsXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBjb25maWcgPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLy8gdGVtcGxhdGVcbiAgICB3aWR0aDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICBoZWlnaHQ6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgdmlld3BvcnQ6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiAnaW50ZWdlcidcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICB9LFxuICAgIGdyaWRDb2xvcjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByb2xlOiAnY29sb3InLFxuICAgICAgZGVmYXVsdDogJ2JsYWNrJ1xuICAgIH0sXG4gICAgZ3JpZE9wYWNpdHk6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgbWluaW11bTogMCxcbiAgICAgIG1heGltdW06IDEsXG4gICAgICBkZWZhdWx0OiAwLjA4XG4gICAgfSxcblxuICAgIC8vIGZpbHRlciBudWxsXG4gICAgZmlsdGVyTnVsbDoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIE86IHt0eXBlOidib29sZWFuJywgZGVmYXVsdDogZmFsc2V9LFxuICAgICAgICBROiB7dHlwZTonYm9vbGVhbicsIGRlZmF1bHQ6IHRydWV9LFxuICAgICAgICBUOiB7dHlwZTonYm9vbGVhbicsIGRlZmF1bHQ6IHRydWV9XG4gICAgICB9XG4gICAgfSxcbiAgICB0b2dnbGVTb3J0OiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlZmF1bHQ6IE9cbiAgICB9LFxuXG4gICAgLy8gc2luZ2xlIHBsb3RcbiAgICBzaW5nbGVIZWlnaHQ6IHtcbiAgICAgIC8vIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgYmFuZFdpZHRoICogKGNhcmRpbmFsaXR5ICsgcGFkZGluZylcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDIwMCxcbiAgICAgIG1pbmltdW06IDBcbiAgICB9LFxuICAgIHNpbmdsZVdpZHRoOiB7XG4gICAgICAvLyB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IGJhbmRXaWR0aCAqIChjYXJkaW5hbGl0eSArIHBhZGRpbmcpXG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAyMDAsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICAvLyBiYW5kIHNpemVcbiAgICBsYXJnZUJhbmRTaXplOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAyMSxcbiAgICAgIG1pbmltdW06IDBcbiAgICB9LFxuICAgIHNtYWxsQmFuZFNpemU6IHtcbiAgICAgIC8vc21hbGwgbXVsdGlwbGVzIG9yIHNpbmdsZSBwbG90IHdpdGggaGlnaCBjYXJkaW5hbGl0eVxuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMTIsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICBsYXJnZUJhbmRNYXhDYXJkaW5hbGl0eToge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMTBcbiAgICB9LFxuICAgIC8vIHNtYWxsIG11bHRpcGxlc1xuICAgIGNlbGxQYWRkaW5nOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIGRlZmF1bHQ6IDAuMVxuICAgIH0sXG4gICAgY2VsbEdyaWRDb2xvcjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByb2xlOiAnY29sb3InLFxuICAgICAgZGVmYXVsdDogJ2JsYWNrJ1xuICAgIH0sXG4gICAgY2VsbEdyaWRPcGFjaXR5OiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBtYXhpbXVtOiAxLFxuICAgICAgZGVmYXVsdDogMC4xNVxuICAgIH0sXG4gICAgY2VsbEJhY2tncm91bmRDb2xvcjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByb2xlOiAnY29sb3InLFxuICAgICAgZGVmYXVsdDogJ3RyYW5zcGFyZW50J1xuICAgIH0sXG4gICAgdGV4dENlbGxXaWR0aDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogOTAsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcblxuICAgIC8vIG1hcmtzXG4gICAgc3Ryb2tlV2lkdGg6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDIsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICBzaW5nbGVCYXJPZmZzZXQ6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDUsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICAvLyBzY2FsZXNcbiAgICB0aW1lU2NhbGVMYWJlbExlbmd0aDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMyxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBkZXNjcmlwdGlvbjogJ01heCBsZW5ndGggZm9yIHZhbHVlcyBpbiBkYXlTY2FsZUxhYmVsIGFuZCBtb250aFNjYWxlTGFiZWwuICBaZXJvIG1lYW5zIHVzaW5nIGZ1bGwgbmFtZXMgaW4gZGF5U2NhbGVMYWJlbC9tb250aFNjYWxlTGFiZWwuJ1xuICAgIH0sXG4gICAgZGF5U2NhbGVMYWJlbDoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgICB9LFxuICAgICAgZGVmYXVsdDogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddLFxuICAgICAgZGVzY3JpcHRpb246ICdBeGlzIGxhYmVscyBmb3IgZGF5IG9mIHdlZWssIHN0YXJ0aW5nIGZyb20gU3VuZGF5LicgK1xuICAgICAgICAnKENvbnNpc3RlbnQgd2l0aCBKYXZhc2NyaXB0IC0tIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL2dldERheS4nXG4gICAgfSxcbiAgICBtb250aFNjYWxlTGFiZWw6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgICAgfSxcbiAgICAgIGRlZmF1bHQ6IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddLFxuICAgICAgZGVzY3JpcHRpb246ICdBeGlzIGxhYmVscyBmb3IgbW9udGguJ1xuICAgIH0sXG4gICAgLy8gb3RoZXJcbiAgICBjaGFyYWN0ZXJXaWR0aDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogNlxuICAgIH0sXG4gICAgbWF4U21hbGxOdW1iZXI6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgZGVmYXVsdDogMTAwMDAsXG4gICAgICBkZXNjcmlwdGlvbjogJ21heGltdW0gbnVtYmVyIHRoYXQgYSBmaWVsZCB3aWxsIGJlIGNvbnNpZGVyZWQgc21hbGxOdW1iZXIuJytcbiAgICAgICAgICAgICAgICAgICAnVXNlZCBmb3IgYXhpcyBsYWJlbGxpbmcuJ1xuICAgIH0sXG4gICAgc21hbGxOdW1iZXJGb3JtYXQ6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogJycsXG4gICAgICBkZXNjcmlwdGlvbjogJ0QzIE51bWJlciBmb3JtYXQgZm9yIGF4aXMgbGFiZWxzIGFuZCB0ZXh0IHRhYmxlcyAnK1xuICAgICAgICAgICAgICAgICAgICdmb3IgbnVtYmVyIDw9IG1heFNtYWxsTnVtYmVyLiBVc2VkIGZvciBheGlzIGxhYmVsbGluZy4nXG4gICAgfSxcbiAgICBsYXJnZU51bWJlckZvcm1hdDoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBkZWZhdWx0OiAnLjNzJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnRDMgTnVtYmVyIGZvcm1hdCBmb3IgYXhpcyBsYWJlbHMgYW5kIHRleHQgdGFibGVzICcgK1xuICAgICAgICAgICAgICAgICAgICdmb3IgbnVtYmVyID4gbWF4U21hbGxOdW1iZXIuJ1xuICAgIH0sXG4gICAgdGltZUZvcm1hdDoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBkZWZhdWx0OiAnJVktJW0tJWQnLFxuICAgICAgZGVzY3JpcHRpb246ICdEYXRlIGZvcm1hdCBmb3IgYXhpcyBsYWJlbHMuJ1xuICAgIH0sXG4gICAgdXNlUmF3RG9tYWluOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnVXNlIHRoZSByYXcgZGF0YSByYW5nZSBhcyBzY2FsZSBkb21haW4gaW5zdGVhZCBvZiAnICtcbiAgICAgICAgICAgICAgICAgICAnYWdncmVnYXRlZCBkYXRhIGZvciBhZ2dyZWdhdGUgYXhpcy4gJyArXG4gICAgICAgICAgICAgICAgICAgJ1RoaXMgb3B0aW9uIGRvZXMgbm90IHdvcmsgd2l0aCBzdW0gb3IgY291bnQgYWdncmVnYXRlJyArXG4gICAgICAgICAgICAgICAgICAgJ2FzIHRoZXkgbWlnaHQgaGF2ZSBhIHN1YnN0YW50aWFsbHkgbGFyZ2VyIHNjYWxlIHJhbmdlLicgK1xuICAgICAgICAgICAgICAgICAgICdCeSBkZWZhdWx0LCB1c2UgdmFsdWUgZnJvbSBjb25maWcudXNlUmF3RG9tYWluLidcbiAgICB9XG4gIH1cbn07XG5cbi8qKiBAdHlwZSBPYmplY3QgU2NoZW1hIG9mIGEgdmVnYS1saXRlIHNwZWNpZmljYXRpb24gKi9cbnNjaGVtYS5zY2hlbWEgPSB7XG4gICRzY2hlbWE6ICdodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSMnLFxuICBkZXNjcmlwdGlvbjogJ1NjaGVtYSBmb3IgVmVnYS1saXRlIHNwZWNpZmljYXRpb24nLFxuICB0eXBlOiAnb2JqZWN0JyxcbiAgcmVxdWlyZWQ6IFsnbWFya3R5cGUnLCAnZW5jb2RpbmcnLCAnZGF0YSddLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgZGF0YTogZGF0YSxcbiAgICBtYXJrdHlwZTogc2NoZW1hLm1hcmt0eXBlLFxuICAgIGVuY29kaW5nOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgcm93OiByb3csXG4gICAgICAgIGNvbDogY29sLFxuICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgIHNoYXBlOiBzaGFwZSxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICAgIH1cbiAgICB9LFxuICAgIGZpbHRlcjogZmlsdGVyLFxuICAgIGNvbmZpZzogY29uZmlnXG4gIH1cbn07XG5cbnNjaGVtYS5lbmNUeXBlcyA9IHV0aWwua2V5cyhzY2hlbWEuc2NoZW1hLnByb3BlcnRpZXMuZW5jb2RpbmcucHJvcGVydGllcyk7XG5cbi8qKiBJbnN0YW50aWF0ZSBhIHZlcmJvc2Ugdmwgc3BlYyBmcm9tIHRoZSBzY2hlbWEgKi9cbnNjaGVtYS5pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gc2NoZW1hLnV0aWwuaW5zdGFudGlhdGUoc2NoZW1hLnNjaGVtYSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2NoZW1hdXRpbCA9IG1vZHVsZS5leHBvcnRzID0ge30sXG4gIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbnZhciBpc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbn07XG5cbnNjaGVtYXV0aWwuZXh0ZW5kID0gZnVuY3Rpb24oaW5zdGFuY2UsIHNjaGVtYSkge1xuICByZXR1cm4gc2NoZW1hdXRpbC5tZXJnZShzY2hlbWF1dGlsLmluc3RhbnRpYXRlKHNjaGVtYSksIGluc3RhbmNlKTtcbn07XG5cbi8vIGluc3RhbnRpYXRlIGEgc2NoZW1hXG5zY2hlbWF1dGlsLmluc3RhbnRpYXRlID0gZnVuY3Rpb24oc2NoZW1hKSB7XG4gIHZhciB2YWw7XG4gIGlmIChzY2hlbWEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoJ2RlZmF1bHQnIGluIHNjaGVtYSkge1xuICAgIHZhbCA9IHNjaGVtYS5kZWZhdWx0O1xuICAgIHJldHVybiB1dGlsLmlzT2JqZWN0KHZhbCkgPyB1dGlsLmR1cGxpY2F0ZSh2YWwpIDogdmFsO1xuICB9IGVsc2UgaWYgKHNjaGVtYS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBpbnN0YW5jZSA9IHt9O1xuICAgIGZvciAodmFyIG5hbWUgaW4gc2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgIHZhbCA9IHNjaGVtYXV0aWwuaW5zdGFudGlhdGUoc2NoZW1hLnByb3BlcnRpZXNbbmFtZV0pO1xuICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluc3RhbmNlW25hbWVdID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSBpZiAoc2NoZW1hLnR5cGUgPT09ICdhcnJheScpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8vIHJlbW92ZSBhbGwgZGVmYXVsdHMgZnJvbSBhbiBpbnN0YW5jZVxuc2NoZW1hdXRpbC5zdWJ0cmFjdCA9IGZ1bmN0aW9uKGluc3RhbmNlLCBkZWZhdWx0cykge1xuICB2YXIgY2hhbmdlcyA9IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIGluc3RhbmNlKSB7XG4gICAgdmFyIGRlZiA9IGRlZmF1bHRzW3Byb3BdO1xuICAgIHZhciBpbnMgPSBpbnN0YW5jZVtwcm9wXTtcbiAgICAvLyBOb3RlOiBkb2VzIG5vdCBwcm9wZXJseSBzdWJ0cmFjdCBhcnJheXNcbiAgICBpZiAoIWRlZmF1bHRzIHx8IGRlZiAhPT0gaW5zKSB7XG4gICAgICBpZiAodHlwZW9mIGlucyA9PT0gJ29iamVjdCcgJiYgIXV0aWwuaXNBcnJheShpbnMpICYmIGRlZikge1xuICAgICAgICB2YXIgYyA9IHNjaGVtYXV0aWwuc3VidHJhY3QoaW5zLCBkZWYpO1xuICAgICAgICBpZiAoIWlzRW1wdHkoYykpXG4gICAgICAgICAgY2hhbmdlc1twcm9wXSA9IGM7XG4gICAgICB9IGVsc2UgaWYgKCF1dGlsLmlzQXJyYXkoaW5zKSB8fCBpbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjaGFuZ2VzW3Byb3BdID0gaW5zO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hhbmdlcztcbn07XG5cbnNjaGVtYXV0aWwubWVyZ2UgPSBmdW5jdGlvbigvKmRlc3QqLCBzcmMwLCBzcmMxLCAuLi4qLyl7XG4gIHZhciBkZXN0ID0gYXJndW1lbnRzWzBdO1xuICBmb3IgKHZhciBpPTEgOyBpPGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGRlc3QgPSBtZXJnZShkZXN0LCBhcmd1bWVudHNbaV0pO1xuICB9XG4gIHJldHVybiBkZXN0O1xufTtcblxuLy8gcmVjdXJzaXZlbHkgbWVyZ2VzIHNyYyBpbnRvIGRlc3RcbmZ1bmN0aW9uIG1lcmdlKGRlc3QsIHNyYykge1xuICBpZiAodHlwZW9mIHNyYyAhPT0gJ29iamVjdCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cblxuICBmb3IgKHZhciBwIGluIHNyYykge1xuICAgIGlmICghc3JjLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHNyY1twXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzcmNbcF0gIT09ICdvYmplY3QnIHx8IHNyY1twXSA9PT0gbnVsbCkge1xuICAgICAgZGVzdFtwXSA9IHNyY1twXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXN0W3BdICE9PSAnb2JqZWN0JyB8fCBkZXN0W3BdID09PSBudWxsKSB7XG4gICAgICBkZXN0W3BdID0gbWVyZ2Uoc3JjW3BdLmNvbnN0cnVjdG9yID09PSBBcnJheSA/IFtdIDoge30sIHNyY1twXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlKGRlc3RbcF0sIHNyY1twXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZXN0O1xufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2RhdGFsaWIvc3JjL3V0aWwnKTtcblxudXRpbC5leHRlbmQodXRpbCwgcmVxdWlyZSgnZGF0YWxpYi9zcmMvZ2VuZXJhdGUnKSk7XG51dGlsLmV4dGVuZCh1dGlsLCByZXF1aXJlKCdkYXRhbGliL3NyYy9zdGF0cycpKTtcbnV0aWwuYmluID0gcmVxdWlyZSgnZGF0YWxpYi9zcmMvYmlucy9iaW5zJyk7XG5cbnV0aWwuaXNpbiA9IGZ1bmN0aW9uKGl0ZW0sIGFycmF5KSB7XG4gIHJldHVybiBhcnJheS5pbmRleE9mKGl0ZW0pICE9PSAtMTtcbn07XG5cbnV0aWwuZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgZiwgdGhpc0FyZykge1xuICBpZiAob2JqLmZvckVhY2gpIHtcbiAgICBvYmouZm9yRWFjaC5jYWxsKHRoaXNBcmcsIGYpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICBmLmNhbGwodGhpc0FyZywgb2JqW2tdLCBrICwgb2JqKTtcbiAgICB9XG4gIH1cbn07XG5cbnV0aWwucmVkdWNlID0gZnVuY3Rpb24ob2JqLCBmLCBpbml0LCB0aGlzQXJnKSB7XG4gIGlmIChvYmoucmVkdWNlKSB7XG4gICAgcmV0dXJuIG9iai5yZWR1Y2UuY2FsbCh0aGlzQXJnLCBmLCBpbml0KTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgaW5pdCA9IGYuY2FsbCh0aGlzQXJnLCBpbml0LCBvYmpba10sIGssIG9iaik7XG4gICAgfVxuICAgIHJldHVybiBpbml0O1xuICB9XG59O1xuXG51dGlsLm1hcCA9IGZ1bmN0aW9uKG9iaiwgZiwgdGhpc0FyZykge1xuICBpZiAob2JqLm1hcCkge1xuICAgIHJldHVybiBvYmoubWFwLmNhbGwodGhpc0FyZywgZik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICBvdXRwdXQucHVzaCggZi5jYWxsKHRoaXNBcmcsIG9ialtrXSwgaywgb2JqKSk7XG4gICAgfVxuICB9XG59O1xuXG51dGlsLmFueSA9IGZ1bmN0aW9uKGFyciwgZikge1xuICB2YXIgaSA9IDAsIGs7XG4gIGZvciAoayBpbiBhcnIpIHtcbiAgICBpZiAoZihhcnJba10sIGssIGkrKykpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnV0aWwuYWxsID0gZnVuY3Rpb24oYXJyLCBmKSB7XG4gIHZhciBpID0gMCwgaztcbiAgZm9yIChrIGluIGFycikge1xuICAgIGlmICghZihhcnJba10sIGssIGkrKykpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnV0aWwuZ2V0YmlucyA9IGZ1bmN0aW9uKHN0YXRzLCBtYXhiaW5zKSB7XG4gIHJldHVybiB1dGlsLmJpbih7XG4gICAgbWluOiBzdGF0cy5taW4sXG4gICAgbWF4OiBzdGF0cy5tYXgsXG4gICAgbWF4YmluczogbWF4Ymluc1xuICB9KTtcbn07XG5cbi8qKlxuICogeFtwWzBdXS4uLltwW25dXSA9IHZhbFxuICogQHBhcmFtIG5vYXVnbWVudCBkZXRlcm1pbmUgd2hldGhlciBuZXcgb2JqZWN0IHNob3VsZCBiZSBhZGRlZCBmXG4gKiBvciBub24tZXhpc3RpbmcgcHJvcGVydGllcyBhbG9uZyB0aGUgcGF0aFxuICovXG51dGlsLnNldHRlciA9IGZ1bmN0aW9uKHgsIHAsIHZhbCwgbm9hdWdtZW50KSB7XG4gIGZvciAodmFyIGk9MDsgaTxwLmxlbmd0aC0xOyArK2kpIHtcbiAgICBpZiAoIW5vYXVnbWVudCAmJiAhKHBbaV0gaW4geCkpe1xuICAgICAgeCA9IHhbcFtpXV0gPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHhbcFtpXV07XG4gICAgfVxuICB9XG4gIHhbcFtpXV0gPSB2YWw7XG59O1xuXG5cbi8qKlxuICogcmV0dXJucyB4W3BbMF1dLi4uW3Bbbl1dXG4gKiBAcGFyYW0gYXVnbWVudCBkZXRlcm1pbmUgd2hldGhlciBuZXcgb2JqZWN0IHNob3VsZCBiZSBhZGRlZCBmXG4gKiBvciBub24tZXhpc3RpbmcgcHJvcGVydGllcyBhbG9uZyB0aGUgcGF0aFxuICovXG51dGlsLmdldHRlciA9IGZ1bmN0aW9uKHgsIHAsIG5vYXVnbWVudCkge1xuICBmb3IgKHZhciBpPTA7IGk8cC5sZW5ndGg7ICsraSkge1xuICAgIGlmICghbm9hdWdtZW50ICYmICEocFtpXSBpbiB4KSl7XG4gICAgICB4ID0geFtwW2ldXSA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geFtwW2ldXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHg7XG59O1xuXG51dGlsLmVycm9yID0gZnVuY3Rpb24obXNnKSB7XG4gIGNvbnNvbGUuZXJyb3IoJ1tWTCBFcnJvcl0nLCBtc2cpO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL2dsb2JhbHMnKTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgICBjb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0cycpO1xuXG52YXIgdmwgPSB7fTtcblxudXRpbC5leHRlbmQodmwsIGNvbnN0cywgdXRpbCk7XG5cbnZsLkVuY29kaW5nID0gcmVxdWlyZSgnLi9FbmNvZGluZycpO1xudmwuY29tcGlsZXIgPSByZXF1aXJlKCcuL2NvbXBpbGVyL2NvbXBpbGVyJyk7XG52bC5jb21waWxlID0gdmwuY29tcGlsZXIuY29tcGlsZTtcbnZsLmRhdGEgPSByZXF1aXJlKCcuL2RhdGEnKTtcbnZsLmVuYyA9IHJlcXVpcmUoJy4vZW5jJyk7XG52bC5maWVsZCA9IHJlcXVpcmUoJy4vZmllbGQnKTtcbnZsLnNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hL3NjaGVtYScpO1xudmwudG9TaG9ydGhhbmQgPSB2bC5FbmNvZGluZy5zaG9ydGhhbmQ7XG5cbm1vZHVsZS5leHBvcnRzID0gdmw7Il19\n","// This product includes color specifications and designs developed by Cynthia Brewer (http://colorbrewer.org/).\n// JavaScript specs as packaged in the D3 library (d3js.org). Please see license at http://colorbrewer.org/export/LICENSE.txt\n!function() {\n\nvar colorbrewer = {YlGn: {\n3: [\"#f7fcb9\",\"#addd8e\",\"#31a354\"],\n4: [\"#ffffcc\",\"#c2e699\",\"#78c679\",\"#238443\"],\n5: [\"#ffffcc\",\"#c2e699\",\"#78c679\",\"#31a354\",\"#006837\"],\n6: [\"#ffffcc\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#31a354\",\"#006837\"],\n7: [\"#ffffcc\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#005a32\"],\n8: [\"#ffffe5\",\"#f7fcb9\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#005a32\"],\n9: [\"#ffffe5\",\"#f7fcb9\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#006837\",\"#004529\"]\n},YlGnBu: {\n3: [\"#edf8b1\",\"#7fcdbb\",\"#2c7fb8\"],\n4: [\"#ffffcc\",\"#a1dab4\",\"#41b6c4\",\"#225ea8\"],\n5: [\"#ffffcc\",\"#a1dab4\",\"#41b6c4\",\"#2c7fb8\",\"#253494\"],\n6: [\"#ffffcc\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#2c7fb8\",\"#253494\"],\n7: [\"#ffffcc\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#0c2c84\"],\n8: [\"#ffffd9\",\"#edf8b1\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#0c2c84\"],\n9: [\"#ffffd9\",\"#edf8b1\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#253494\",\"#081d58\"]\n},GnBu: {\n3: [\"#e0f3db\",\"#a8ddb5\",\"#43a2ca\"],\n4: [\"#f0f9e8\",\"#bae4bc\",\"#7bccc4\",\"#2b8cbe\"],\n5: [\"#f0f9e8\",\"#bae4bc\",\"#7bccc4\",\"#43a2ca\",\"#0868ac\"],\n6: [\"#f0f9e8\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#43a2ca\",\"#0868ac\"],\n7: [\"#f0f9e8\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#08589e\"],\n8: [\"#f7fcf0\",\"#e0f3db\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#08589e\"],\n9: [\"#f7fcf0\",\"#e0f3db\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#0868ac\",\"#084081\"]\n},BuGn: {\n3: [\"#e5f5f9\",\"#99d8c9\",\"#2ca25f\"],\n4: [\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#238b45\"],\n5: [\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\"],\n6: [\"#edf8fb\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\"],\n7: [\"#edf8fb\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#005824\"],\n8: [\"#f7fcfd\",\"#e5f5f9\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#005824\"],\n9: [\"#f7fcfd\",\"#e5f5f9\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#006d2c\",\"#00441b\"]\n},PuBuGn: {\n3: [\"#ece2f0\",\"#a6bddb\",\"#1c9099\"],\n4: [\"#f6eff7\",\"#bdc9e1\",\"#67a9cf\",\"#02818a\"],\n5: [\"#f6eff7\",\"#bdc9e1\",\"#67a9cf\",\"#1c9099\",\"#016c59\"],\n6: [\"#f6eff7\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#1c9099\",\"#016c59\"],\n7: [\"#f6eff7\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016450\"],\n8: [\"#fff7fb\",\"#ece2f0\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016450\"],\n9: [\"#fff7fb\",\"#ece2f0\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016c59\",\"#014636\"]\n},PuBu: {\n3: [\"#ece7f2\",\"#a6bddb\",\"#2b8cbe\"],\n4: [\"#f1eef6\",\"#bdc9e1\",\"#74a9cf\",\"#0570b0\"],\n5: [\"#f1eef6\",\"#bdc9e1\",\"#74a9cf\",\"#2b8cbe\",\"#045a8d\"],\n6: [\"#f1eef6\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#2b8cbe\",\"#045a8d\"],\n7: [\"#f1eef6\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#034e7b\"],\n8: [\"#fff7fb\",\"#ece7f2\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#034e7b\"],\n9: [\"#fff7fb\",\"#ece7f2\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#045a8d\",\"#023858\"]\n},BuPu: {\n3: [\"#e0ecf4\",\"#9ebcda\",\"#8856a7\"],\n4: [\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#88419d\"],\n5: [\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#8856a7\",\"#810f7c\"],\n6: [\"#edf8fb\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8856a7\",\"#810f7c\"],\n7: [\"#edf8fb\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#6e016b\"],\n8: [\"#f7fcfd\",\"#e0ecf4\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#6e016b\"],\n9: [\"#f7fcfd\",\"#e0ecf4\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#810f7c\",\"#4d004b\"]\n},RdPu: {\n3: [\"#fde0dd\",\"#fa9fb5\",\"#c51b8a\"],\n4: [\"#feebe2\",\"#fbb4b9\",\"#f768a1\",\"#ae017e\"],\n5: [\"#feebe2\",\"#fbb4b9\",\"#f768a1\",\"#c51b8a\",\"#7a0177\"],\n6: [\"#feebe2\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#c51b8a\",\"#7a0177\"],\n7: [\"#feebe2\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\"],\n8: [\"#fff7f3\",\"#fde0dd\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\"],\n9: [\"#fff7f3\",\"#fde0dd\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\",\"#49006a\"]\n},PuRd: {\n3: [\"#e7e1ef\",\"#c994c7\",\"#dd1c77\"],\n4: [\"#f1eef6\",\"#d7b5d8\",\"#df65b0\",\"#ce1256\"],\n5: [\"#f1eef6\",\"#d7b5d8\",\"#df65b0\",\"#dd1c77\",\"#980043\"],\n6: [\"#f1eef6\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#dd1c77\",\"#980043\"],\n7: [\"#f1eef6\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#91003f\"],\n8: [\"#f7f4f9\",\"#e7e1ef\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#91003f\"],\n9: [\"#f7f4f9\",\"#e7e1ef\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#980043\",\"#67001f\"]\n},OrRd: {\n3: [\"#fee8c8\",\"#fdbb84\",\"#e34a33\"],\n4: [\"#fef0d9\",\"#fdcc8a\",\"#fc8d59\",\"#d7301f\"],\n5: [\"#fef0d9\",\"#fdcc8a\",\"#fc8d59\",\"#e34a33\",\"#b30000\"],\n6: [\"#fef0d9\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#e34a33\",\"#b30000\"],\n7: [\"#fef0d9\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#990000\"],\n8: [\"#fff7ec\",\"#fee8c8\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#990000\"],\n9: [\"#fff7ec\",\"#fee8c8\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#b30000\",\"#7f0000\"]\n},YlOrRd: {\n3: [\"#ffeda0\",\"#feb24c\",\"#f03b20\"],\n4: [\"#ffffb2\",\"#fecc5c\",\"#fd8d3c\",\"#e31a1c\"],\n5: [\"#ffffb2\",\"#fecc5c\",\"#fd8d3c\",\"#f03b20\",\"#bd0026\"],\n6: [\"#ffffb2\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#f03b20\",\"#bd0026\"],\n7: [\"#ffffb2\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#b10026\"],\n8: [\"#ffffcc\",\"#ffeda0\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#b10026\"],\n9: [\"#ffffcc\",\"#ffeda0\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#bd0026\",\"#800026\"]\n},YlOrBr: {\n3: [\"#fff7bc\",\"#fec44f\",\"#d95f0e\"],\n4: [\"#ffffd4\",\"#fed98e\",\"#fe9929\",\"#cc4c02\"],\n5: [\"#ffffd4\",\"#fed98e\",\"#fe9929\",\"#d95f0e\",\"#993404\"],\n6: [\"#ffffd4\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#d95f0e\",\"#993404\"],\n7: [\"#ffffd4\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#8c2d04\"],\n8: [\"#ffffe5\",\"#fff7bc\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#8c2d04\"],\n9: [\"#ffffe5\",\"#fff7bc\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#993404\",\"#662506\"]\n},Purples: {\n3: [\"#efedf5\",\"#bcbddc\",\"#756bb1\"],\n4: [\"#f2f0f7\",\"#cbc9e2\",\"#9e9ac8\",\"#6a51a3\"],\n5: [\"#f2f0f7\",\"#cbc9e2\",\"#9e9ac8\",\"#756bb1\",\"#54278f\"],\n6: [\"#f2f0f7\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#756bb1\",\"#54278f\"],\n7: [\"#f2f0f7\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#4a1486\"],\n8: [\"#fcfbfd\",\"#efedf5\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#4a1486\"],\n9: [\"#fcfbfd\",\"#efedf5\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#54278f\",\"#3f007d\"]\n},Blues: {\n3: [\"#deebf7\",\"#9ecae1\",\"#3182bd\"],\n4: [\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#2171b5\"],\n5: [\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#3182bd\",\"#08519c\"],\n6: [\"#eff3ff\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#3182bd\",\"#08519c\"],\n7: [\"#eff3ff\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#084594\"],\n8: [\"#f7fbff\",\"#deebf7\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#084594\"],\n9: [\"#f7fbff\",\"#deebf7\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#08519c\",\"#08306b\"]\n},Greens: {\n3: [\"#e5f5e0\",\"#a1d99b\",\"#31a354\"],\n4: [\"#edf8e9\",\"#bae4b3\",\"#74c476\",\"#238b45\"],\n5: [\"#edf8e9\",\"#bae4b3\",\"#74c476\",\"#31a354\",\"#006d2c\"],\n6: [\"#edf8e9\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#31a354\",\"#006d2c\"],\n7: [\"#edf8e9\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#005a32\"],\n8: [\"#f7fcf5\",\"#e5f5e0\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#005a32\"],\n9: [\"#f7fcf5\",\"#e5f5e0\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#006d2c\",\"#00441b\"]\n},Oranges: {\n3: [\"#fee6ce\",\"#fdae6b\",\"#e6550d\"],\n4: [\"#feedde\",\"#fdbe85\",\"#fd8d3c\",\"#d94701\"],\n5: [\"#feedde\",\"#fdbe85\",\"#fd8d3c\",\"#e6550d\",\"#a63603\"],\n6: [\"#feedde\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#e6550d\",\"#a63603\"],\n7: [\"#feedde\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#8c2d04\"],\n8: [\"#fff5eb\",\"#fee6ce\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#8c2d04\"],\n9: [\"#fff5eb\",\"#fee6ce\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#a63603\",\"#7f2704\"]\n},Reds: {\n3: [\"#fee0d2\",\"#fc9272\",\"#de2d26\"],\n4: [\"#fee5d9\",\"#fcae91\",\"#fb6a4a\",\"#cb181d\"],\n5: [\"#fee5d9\",\"#fcae91\",\"#fb6a4a\",\"#de2d26\",\"#a50f15\"],\n6: [\"#fee5d9\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#de2d26\",\"#a50f15\"],\n7: [\"#fee5d9\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#99000d\"],\n8: [\"#fff5f0\",\"#fee0d2\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#99000d\"],\n9: [\"#fff5f0\",\"#fee0d2\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#a50f15\",\"#67000d\"]\n},Greys: {\n3: [\"#f0f0f0\",\"#bdbdbd\",\"#636363\"],\n4: [\"#f7f7f7\",\"#cccccc\",\"#969696\",\"#525252\"],\n5: [\"#f7f7f7\",\"#cccccc\",\"#969696\",\"#636363\",\"#252525\"],\n6: [\"#f7f7f7\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#636363\",\"#252525\"],\n7: [\"#f7f7f7\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\"],\n8: [\"#ffffff\",\"#f0f0f0\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\"],\n9: [\"#ffffff\",\"#f0f0f0\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\",\"#000000\"]\n},PuOr: {\n3: [\"#f1a340\",\"#f7f7f7\",\"#998ec3\"],\n4: [\"#e66101\",\"#fdb863\",\"#b2abd2\",\"#5e3c99\"],\n5: [\"#e66101\",\"#fdb863\",\"#f7f7f7\",\"#b2abd2\",\"#5e3c99\"],\n6: [\"#b35806\",\"#f1a340\",\"#fee0b6\",\"#d8daeb\",\"#998ec3\",\"#542788\"],\n7: [\"#b35806\",\"#f1a340\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#998ec3\",\"#542788\"],\n8: [\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\"],\n9: [\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\"],\n10: [\"#7f3b08\",\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\",\"#2d004b\"],\n11: [\"#7f3b08\",\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\",\"#2d004b\"]\n},BrBG: {\n3: [\"#d8b365\",\"#f5f5f5\",\"#5ab4ac\"],\n4: [\"#a6611a\",\"#dfc27d\",\"#80cdc1\",\"#018571\"],\n5: [\"#a6611a\",\"#dfc27d\",\"#f5f5f5\",\"#80cdc1\",\"#018571\"],\n6: [\"#8c510a\",\"#d8b365\",\"#f6e8c3\",\"#c7eae5\",\"#5ab4ac\",\"#01665e\"],\n7: [\"#8c510a\",\"#d8b365\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#5ab4ac\",\"#01665e\"],\n8: [\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\"],\n9: [\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\"],\n10: [\"#543005\",\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\",\"#003c30\"],\n11: [\"#543005\",\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\",\"#003c30\"]\n},PRGn: {\n3: [\"#af8dc3\",\"#f7f7f7\",\"#7fbf7b\"],\n4: [\"#7b3294\",\"#c2a5cf\",\"#a6dba0\",\"#008837\"],\n5: [\"#7b3294\",\"#c2a5cf\",\"#f7f7f7\",\"#a6dba0\",\"#008837\"],\n6: [\"#762a83\",\"#af8dc3\",\"#e7d4e8\",\"#d9f0d3\",\"#7fbf7b\",\"#1b7837\"],\n7: [\"#762a83\",\"#af8dc3\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#7fbf7b\",\"#1b7837\"],\n8: [\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\"],\n9: [\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\"],\n10: [\"#40004b\",\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\",\"#00441b\"],\n11: [\"#40004b\",\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\",\"#00441b\"]\n},PiYG: {\n3: [\"#e9a3c9\",\"#f7f7f7\",\"#a1d76a\"],\n4: [\"#d01c8b\",\"#f1b6da\",\"#b8e186\",\"#4dac26\"],\n5: [\"#d01c8b\",\"#f1b6da\",\"#f7f7f7\",\"#b8e186\",\"#4dac26\"],\n6: [\"#c51b7d\",\"#e9a3c9\",\"#fde0ef\",\"#e6f5d0\",\"#a1d76a\",\"#4d9221\"],\n7: [\"#c51b7d\",\"#e9a3c9\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#a1d76a\",\"#4d9221\"],\n8: [\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\"],\n9: [\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\"],\n10: [\"#8e0152\",\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\",\"#276419\"],\n11: [\"#8e0152\",\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\",\"#276419\"]\n},RdBu: {\n3: [\"#ef8a62\",\"#f7f7f7\",\"#67a9cf\"],\n4: [\"#ca0020\",\"#f4a582\",\"#92c5de\",\"#0571b0\"],\n5: [\"#ca0020\",\"#f4a582\",\"#f7f7f7\",\"#92c5de\",\"#0571b0\"],\n6: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#d1e5f0\",\"#67a9cf\",\"#2166ac\"],\n7: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#67a9cf\",\"#2166ac\"],\n8: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\"],\n9: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\"],\n10: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\",\"#053061\"],\n11: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\",\"#053061\"]\n},RdGy: {\n3: [\"#ef8a62\",\"#ffffff\",\"#999999\"],\n4: [\"#ca0020\",\"#f4a582\",\"#bababa\",\"#404040\"],\n5: [\"#ca0020\",\"#f4a582\",\"#ffffff\",\"#bababa\",\"#404040\"],\n6: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#e0e0e0\",\"#999999\",\"#4d4d4d\"],\n7: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#999999\",\"#4d4d4d\"],\n8: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\"],\n9: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\"],\n10: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\",\"#1a1a1a\"],\n11: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\",\"#1a1a1a\"]\n},RdYlBu: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#91bfdb\"],\n4: [\"#d7191c\",\"#fdae61\",\"#abd9e9\",\"#2c7bb6\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#abd9e9\",\"#2c7bb6\"],\n6: [\"#d73027\",\"#fc8d59\",\"#fee090\",\"#e0f3f8\",\"#91bfdb\",\"#4575b4\"],\n7: [\"#d73027\",\"#fc8d59\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#91bfdb\",\"#4575b4\"],\n8: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\"],\n9: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\"],\n10: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\",\"#313695\"],\n11: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\",\"#313695\"]\n},Spectral: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#99d594\"],\n4: [\"#d7191c\",\"#fdae61\",\"#abdda4\",\"#2b83ba\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#abdda4\",\"#2b83ba\"],\n6: [\"#d53e4f\",\"#fc8d59\",\"#fee08b\",\"#e6f598\",\"#99d594\",\"#3288bd\"],\n7: [\"#d53e4f\",\"#fc8d59\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#99d594\",\"#3288bd\"],\n8: [\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\"],\n9: [\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\"],\n10: [\"#9e0142\",\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\",\"#5e4fa2\"],\n11: [\"#9e0142\",\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\",\"#5e4fa2\"]\n},RdYlGn: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#91cf60\"],\n4: [\"#d7191c\",\"#fdae61\",\"#a6d96a\",\"#1a9641\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#a6d96a\",\"#1a9641\"],\n6: [\"#d73027\",\"#fc8d59\",\"#fee08b\",\"#d9ef8b\",\"#91cf60\",\"#1a9850\"],\n7: [\"#d73027\",\"#fc8d59\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#91cf60\",\"#1a9850\"],\n8: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\"],\n9: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\"],\n10: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\",\"#006837\"],\n11: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\",\"#006837\"]\n},Accent: {\n3: [\"#7fc97f\",\"#beaed4\",\"#fdc086\"],\n4: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\"],\n5: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\"],\n6: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\"],\n7: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\",\"#bf5b17\"],\n8: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\",\"#bf5b17\",\"#666666\"]\n},Dark2: {\n3: [\"#1b9e77\",\"#d95f02\",\"#7570b3\"],\n4: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\"],\n5: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\"],\n6: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\"],\n7: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\",\"#a6761d\"],\n8: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\",\"#a6761d\",\"#666666\"]\n},Paired: {\n3: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\"],\n4: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\"],\n5: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\"],\n6: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\"],\n7: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\"],\n8: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\"],\n9: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\"],\n10: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\"],\n11: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\",\"#ffff99\"],\n12: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\",\"#ffff99\",\"#b15928\"]\n},Pastel1: {\n3: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\"],\n4: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\"],\n5: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\"],\n6: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\"],\n7: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\"],\n8: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\"#fddaec\"],\n9: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\"#fddaec\",\"#f2f2f2\"]\n},Pastel2: {\n3: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\"],\n4: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\"],\n5: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\"],\n6: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\"],\n7: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\",\"#f1e2cc\"],\n8: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\",\"#f1e2cc\",\"#cccccc\"]\n},Set1: {\n3: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\"],\n4: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\"],\n5: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\"],\n6: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\"],\n7: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\"],\n8: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\",\"#f781bf\"],\n9: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\",\"#f781bf\",\"#999999\"]\n},Set2: {\n3: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\"],\n4: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\"],\n5: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\"],\n6: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\"],\n7: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\",\"#e5c494\"],\n8: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\",\"#e5c494\",\"#b3b3b3\"]\n},Set3: {\n3: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\"],\n4: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\"],\n5: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\"],\n6: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\"],\n7: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\"],\n8: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\"],\n9: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\"],\n10: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\"],\n11: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\",\"#ccebc5\"],\n12: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\",\"#ccebc5\",\"#ffed6f\"]\n}};\n\nif (typeof define === \"function\" && define.amd) {\n    define(colorbrewer);\n} else if (typeof module === \"object\" && module.exports) {\n    module.exports = colorbrewer;\n} else {\n    this.colorbrewer = colorbrewer;\n}\n\n}();\n","module.exports = require('./colorbrewer.js');\n","if (typeof Map === \"undefined\") {\n  Map = function() { this.clear(); };\n  Map.prototype = {\n    set: function(k, v) { this._[k] = v; return this; },\n    get: function(k) { return this._[k]; },\n    has: function(k) { return k in this._; },\n    delete: function(k) { return k in this._ && delete this._[k]; },\n    clear: function() { this._ = Object.create(null); },\n    get size() { var n = 0; for (var k in this._) ++n; return n; },\n    forEach: function(c) { for (var k in this._) c(this._[k], k, this); }\n  };\n} else (function() {\n  var m = new Map;\n  if (m.set(0, 0) !== m) {\n    m = m.set;\n    Map.prototype.set = function() { m.apply(this, arguments); return this; };\n  }\n})();\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.color = {}));\n}(this, function (exports) { 'use strict';\n\n  function deltaHue(h1, h0) {\n    var delta = h1 - h0;\n    return delta > 180 || delta < -180\n        ? delta - 360 * Math.round(delta / 360)\n        : delta;\n  }\n\n  function Color() {}\n\n  var reHex3 = /^#([0-9a-f]{3})$/;\n  var reHex6 = /^#([0-9a-f]{6})$/;\n  var reRgbInteger = /^rgb\\(\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*\\)$/;\n  var reRgbPercent = /^rgb\\(\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n  var reHslPercent = /^hsl\\(\\s*([-+]?\\d+(?:\\.\\d+)?)\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n\n  color.prototype = Color.prototype = {\n    displayable: function() {\n      return this.rgb().displayable();\n    },\n    toString: function() {\n      return this.rgb() + \"\";\n    }\n  };\n\n  function color(format) {\n    var m;\n    format = (format + \"\").trim().toLowerCase();\n    return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf))) // #f00\n        : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000\n        : (m = reRgbInteger.exec(format)) ? rgb(m[1], m[2], m[3]) // rgb(255,0,0)\n        : (m = reRgbPercent.exec(format)) ? rgb(m[1] * 2.55, m[2] * 2.55, m[3] * 2.55) // rgb(100%,0%,0%)\n        : (m = reHslPercent.exec(format)) ? hsl(m[1], m[2] * .01, m[3] * .01) // hsl(120,50%,50%)\n        : named.has(format) ? rgbn(named.get(format))\n        : null;\n  }\n\n  function rgbn(n) {\n    return rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff);\n  }\n\n  var named = (new Map)\n      .set(\"aliceblue\", 0xf0f8ff)\n      .set(\"antiquewhite\", 0xfaebd7)\n      .set(\"aqua\", 0x00ffff)\n      .set(\"aquamarine\", 0x7fffd4)\n      .set(\"azure\", 0xf0ffff)\n      .set(\"beige\", 0xf5f5dc)\n      .set(\"bisque\", 0xffe4c4)\n      .set(\"black\", 0x000000)\n      .set(\"blanchedalmond\", 0xffebcd)\n      .set(\"blue\", 0x0000ff)\n      .set(\"blueviolet\", 0x8a2be2)\n      .set(\"brown\", 0xa52a2a)\n      .set(\"burlywood\", 0xdeb887)\n      .set(\"cadetblue\", 0x5f9ea0)\n      .set(\"chartreuse\", 0x7fff00)\n      .set(\"chocolate\", 0xd2691e)\n      .set(\"coral\", 0xff7f50)\n      .set(\"cornflowerblue\", 0x6495ed)\n      .set(\"cornsilk\", 0xfff8dc)\n      .set(\"crimson\", 0xdc143c)\n      .set(\"cyan\", 0x00ffff)\n      .set(\"darkblue\", 0x00008b)\n      .set(\"darkcyan\", 0x008b8b)\n      .set(\"darkgoldenrod\", 0xb8860b)\n      .set(\"darkgray\", 0xa9a9a9)\n      .set(\"darkgreen\", 0x006400)\n      .set(\"darkgrey\", 0xa9a9a9)\n      .set(\"darkkhaki\", 0xbdb76b)\n      .set(\"darkmagenta\", 0x8b008b)\n      .set(\"darkolivegreen\", 0x556b2f)\n      .set(\"darkorange\", 0xff8c00)\n      .set(\"darkorchid\", 0x9932cc)\n      .set(\"darkred\", 0x8b0000)\n      .set(\"darksalmon\", 0xe9967a)\n      .set(\"darkseagreen\", 0x8fbc8f)\n      .set(\"darkslateblue\", 0x483d8b)\n      .set(\"darkslategray\", 0x2f4f4f)\n      .set(\"darkslategrey\", 0x2f4f4f)\n      .set(\"darkturquoise\", 0x00ced1)\n      .set(\"darkviolet\", 0x9400d3)\n      .set(\"deeppink\", 0xff1493)\n      .set(\"deepskyblue\", 0x00bfff)\n      .set(\"dimgray\", 0x696969)\n      .set(\"dimgrey\", 0x696969)\n      .set(\"dodgerblue\", 0x1e90ff)\n      .set(\"firebrick\", 0xb22222)\n      .set(\"floralwhite\", 0xfffaf0)\n      .set(\"forestgreen\", 0x228b22)\n      .set(\"fuchsia\", 0xff00ff)\n      .set(\"gainsboro\", 0xdcdcdc)\n      .set(\"ghostwhite\", 0xf8f8ff)\n      .set(\"gold\", 0xffd700)\n      .set(\"goldenrod\", 0xdaa520)\n      .set(\"gray\", 0x808080)\n      .set(\"green\", 0x008000)\n      .set(\"greenyellow\", 0xadff2f)\n      .set(\"grey\", 0x808080)\n      .set(\"honeydew\", 0xf0fff0)\n      .set(\"hotpink\", 0xff69b4)\n      .set(\"indianred\", 0xcd5c5c)\n      .set(\"indigo\", 0x4b0082)\n      .set(\"ivory\", 0xfffff0)\n      .set(\"khaki\", 0xf0e68c)\n      .set(\"lavender\", 0xe6e6fa)\n      .set(\"lavenderblush\", 0xfff0f5)\n      .set(\"lawngreen\", 0x7cfc00)\n      .set(\"lemonchiffon\", 0xfffacd)\n      .set(\"lightblue\", 0xadd8e6)\n      .set(\"lightcoral\", 0xf08080)\n      .set(\"lightcyan\", 0xe0ffff)\n      .set(\"lightgoldenrodyellow\", 0xfafad2)\n      .set(\"lightgray\", 0xd3d3d3)\n      .set(\"lightgreen\", 0x90ee90)\n      .set(\"lightgrey\", 0xd3d3d3)\n      .set(\"lightpink\", 0xffb6c1)\n      .set(\"lightsalmon\", 0xffa07a)\n      .set(\"lightseagreen\", 0x20b2aa)\n      .set(\"lightskyblue\", 0x87cefa)\n      .set(\"lightslategray\", 0x778899)\n      .set(\"lightslategrey\", 0x778899)\n      .set(\"lightsteelblue\", 0xb0c4de)\n      .set(\"lightyellow\", 0xffffe0)\n      .set(\"lime\", 0x00ff00)\n      .set(\"limegreen\", 0x32cd32)\n      .set(\"linen\", 0xfaf0e6)\n      .set(\"magenta\", 0xff00ff)\n      .set(\"maroon\", 0x800000)\n      .set(\"mediumaquamarine\", 0x66cdaa)\n      .set(\"mediumblue\", 0x0000cd)\n      .set(\"mediumorchid\", 0xba55d3)\n      .set(\"mediumpurple\", 0x9370db)\n      .set(\"mediumseagreen\", 0x3cb371)\n      .set(\"mediumslateblue\", 0x7b68ee)\n      .set(\"mediumspringgreen\", 0x00fa9a)\n      .set(\"mediumturquoise\", 0x48d1cc)\n      .set(\"mediumvioletred\", 0xc71585)\n      .set(\"midnightblue\", 0x191970)\n      .set(\"mintcream\", 0xf5fffa)\n      .set(\"mistyrose\", 0xffe4e1)\n      .set(\"moccasin\", 0xffe4b5)\n      .set(\"navajowhite\", 0xffdead)\n      .set(\"navy\", 0x000080)\n      .set(\"oldlace\", 0xfdf5e6)\n      .set(\"olive\", 0x808000)\n      .set(\"olivedrab\", 0x6b8e23)\n      .set(\"orange\", 0xffa500)\n      .set(\"orangered\", 0xff4500)\n      .set(\"orchid\", 0xda70d6)\n      .set(\"palegoldenrod\", 0xeee8aa)\n      .set(\"palegreen\", 0x98fb98)\n      .set(\"paleturquoise\", 0xafeeee)\n      .set(\"palevioletred\", 0xdb7093)\n      .set(\"papayawhip\", 0xffefd5)\n      .set(\"peachpuff\", 0xffdab9)\n      .set(\"peru\", 0xcd853f)\n      .set(\"pink\", 0xffc0cb)\n      .set(\"plum\", 0xdda0dd)\n      .set(\"powderblue\", 0xb0e0e6)\n      .set(\"purple\", 0x800080)\n      .set(\"rebeccapurple\", 0x663399)\n      .set(\"red\", 0xff0000)\n      .set(\"rosybrown\", 0xbc8f8f)\n      .set(\"royalblue\", 0x4169e1)\n      .set(\"saddlebrown\", 0x8b4513)\n      .set(\"salmon\", 0xfa8072)\n      .set(\"sandybrown\", 0xf4a460)\n      .set(\"seagreen\", 0x2e8b57)\n      .set(\"seashell\", 0xfff5ee)\n      .set(\"sienna\", 0xa0522d)\n      .set(\"silver\", 0xc0c0c0)\n      .set(\"skyblue\", 0x87ceeb)\n      .set(\"slateblue\", 0x6a5acd)\n      .set(\"slategray\", 0x708090)\n      .set(\"slategrey\", 0x708090)\n      .set(\"snow\", 0xfffafa)\n      .set(\"springgreen\", 0x00ff7f)\n      .set(\"steelblue\", 0x4682b4)\n      .set(\"tan\", 0xd2b48c)\n      .set(\"teal\", 0x008080)\n      .set(\"thistle\", 0xd8bfd8)\n      .set(\"tomato\", 0xff6347)\n      .set(\"turquoise\", 0x40e0d0)\n      .set(\"violet\", 0xee82ee)\n      .set(\"wheat\", 0xf5deb3)\n      .set(\"white\", 0xffffff)\n      .set(\"whitesmoke\", 0xf5f5f5)\n      .set(\"yellow\", 0xffff00)\n      .set(\"yellowgreen\", 0x9acd32);\n\n  var darker = .7;\n  var brighter = 1 / darker;\n\n  function rgb(r, g, b) {\n    if (arguments.length === 1) {\n      if (!(r instanceof Color)) r = color(r);\n      if (r) {\n        r = r.rgb();\n        b = r.b;\n        g = r.g;\n        r = r.r;\n      } else {\n        r = g = b = NaN;\n      }\n    }\n    return new Rgb(r, g, b);\n  }\n\n  function Rgb(r, g, b) {\n    this.r = +r;\n    this.g = +g;\n    this.b = +b;\n  }\n\n  var _prototype = rgb.prototype = Rgb.prototype = new Color;\n\n  _prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k);\n  };\n\n  _prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k);\n  };\n\n  _prototype.rgb = function() {\n    return this;\n  };\n\n  _prototype.displayable = function() {\n    return (0 <= this.r && this.r <= 255)\n        && (0 <= this.g && this.g <= 255)\n        && (0 <= this.b && this.b <= 255);\n  };\n\n  _prototype.toString = function() {\n    return format(this.r, this.g, this.b);\n  };\n\n  function format(r, g, b) {\n    return \"#\"\n        + (isNaN(r) ? \"00\" : (r = Math.round(r)) < 16 ? \"0\" + Math.max(0, r).toString(16) : Math.min(255, r).toString(16))\n        + (isNaN(g) ? \"00\" : (g = Math.round(g)) < 16 ? \"0\" + Math.max(0, g).toString(16) : Math.min(255, g).toString(16))\n        + (isNaN(b) ? \"00\" : (b = Math.round(b)) < 16 ? \"0\" + Math.max(0, b).toString(16) : Math.min(255, b).toString(16));\n  }\n\n  function hsl(h, s, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Hsl) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n      } else {\n        if (!(h instanceof Color)) h = color(h);\n        if (h) {\n          if (h instanceof Hsl) return h;\n          h = h.rgb();\n          var r = h.r / 255,\n              g = h.g / 255,\n              b = h.b / 255,\n              min = Math.min(r, g, b),\n              max = Math.max(r, g, b),\n              range = max - min;\n          l = (max + min) / 2;\n          if (range) {\n            s = l < .5 ? range / (max + min) : range / (2 - max - min);\n            if (r === max) h = (g - b) / range + (g < b) * 6;\n            else if (g === max) h = (b - r) / range + 2;\n            else h = (r - g) / range + 4;\n            h *= 60;\n          } else {\n            h = NaN;\n            s = l > 0 && l < 1 ? 0 : h;\n          }\n        } else {\n          h = s = l = NaN;\n        }\n      }\n    }\n    return new Hsl(h, s, l);\n  }\n\n  function Hsl(h, s, l) {\n    this.h = +h;\n    this.s = +s;\n    this.l = +l;\n  }\n\n  var __prototype = hsl.prototype = Hsl.prototype = new Color;\n\n  __prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Hsl(this.h, this.s, this.l * k);\n  };\n\n  __prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Hsl(this.h, this.s, this.l * k);\n  };\n\n  __prototype.rgb = function() {\n    var h = this.h % 360 + (this.h < 0) * 360,\n        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,\n        l = this.l,\n        m2 = l + (l < .5 ? l : 1 - l) * s,\n        m1 = 2 * l - m2;\n    return new Rgb(\n      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),\n      hsl2rgb(h, m1, m2),\n      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2)\n    );\n  };\n\n  __prototype.displayable = function() {\n    return (0 <= this.s && this.s <= 1 || isNaN(this.s))\n        && (0 <= this.l && this.l <= 1);\n  };\n\n  /* From FvD 13.37, CSS Color Module Level 3 */\n  function hsl2rgb(h, m1, m2) {\n    return (h < 60 ? m1 + (m2 - m1) * h / 60\n        : h < 180 ? m2\n        : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60\n        : m1) * 255;\n  }\n\n  var Kn = 18;\n\n  var Xn = 0.950470;\n  var Yn = 1;\n  var Zn = 1.088830;\n  var t0 = 4 / 29;\n  var t1 = 6 / 29;\n  var t2 = 3 * t1 * t1;\n  var t3 = t1 * t1 * t1;\n\n  function lab(l, a, b) {\n    if (arguments.length === 1) {\n      if (l instanceof Lab) {\n        b = l.b;\n        a = l.a;\n        l = l.l;\n      } else if (l instanceof Hcl) {\n        var h = l.h * deg2rad;\n        b = Math.sin(h) * l.c;\n        a = Math.cos(h) * l.c;\n        l = l.l;\n      } else {\n        if (!(l instanceof Rgb)) l = rgb(l);\n        var r = rgb2xyz(l.r),\n            g = rgb2xyz(l.g),\n            b = rgb2xyz(l.b),\n            x = xyz2lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / Xn),\n            y = xyz2lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / Yn),\n            z = xyz2lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / Zn);\n        b = 200 * (y - z);\n        a = 500 * (x - y);\n        l = 116 * y - 16;\n      }\n    }\n    return new Lab(l, a, b);\n  }\n\n  function Lab(l, a, b) {\n    this.l = +l;\n    this.a = +a;\n    this.b = +b;\n  }\n\n  var ___prototype = lab.prototype = Lab.prototype = new Color;\n\n  ___prototype.brighter = function(k) {\n    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b);\n  };\n\n  ___prototype.darker = function(k) {\n    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b);\n  };\n\n  ___prototype.rgb = function() {\n    var y = (this.l + 16) / 116,\n        x = isNaN(this.a) ? y : y + this.a / 500,\n        z = isNaN(this.b) ? y : y - this.b / 200;\n    y = Yn * lab2xyz(y);\n    x = Xn * lab2xyz(x);\n    z = Zn * lab2xyz(z);\n    return new Rgb(\n      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB\n      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),\n      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z)\n    );\n  };\n\n  function xyz2lab(t) {\n    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n  }\n\n  function lab2xyz(t) {\n    return t > t1 ? t * t * t : t2 * (t - t0);\n  }\n\n  function xyz2rgb(x) {\n    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n  }\n\n  function rgb2xyz(x) {\n    return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n  }\n\n  var deg2rad = Math.PI / 180;\n  var rad2deg = 180 / Math.PI;\n\n  function hcl(h, c, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Hcl) {\n        l = h.l;\n        c = h.c;\n        h = h.h;\n      } else {\n        if (!(h instanceof Lab)) h = lab(h);\n        l = h.l;\n        c = Math.sqrt(h.a * h.a + h.b * h.b);\n        h = Math.atan2(h.b, h.a) * rad2deg;\n        if (h < 0) h += 360;\n      }\n    }\n    return new Hcl(h, c, l);\n  }\n\n  function Hcl(h, c, l) {\n    this.h = +h;\n    this.c = +c;\n    this.l = +l;\n  }\n\n  var ____prototype = hcl.prototype = Hcl.prototype = new Color;\n\n  ____prototype.brighter = function(k) {\n    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k));\n  };\n\n  ____prototype.darker = function(k) {\n    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k));\n  };\n\n  ____prototype.rgb = function() {\n    return lab(this).rgb();\n  };\n\n  var A = -0.14861;\n  var B = +1.78277;\n  var C = -0.29227;\n  var D = -0.90649;\n  var E = +1.97294;\n  var ED = E * D;\n  var EB = E * B;\n  var BC_DA = B * C - D * A;\n\n  function cubehelix(h, s, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Cubehelix) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n      } else {\n        if (!(h instanceof Rgb)) h = rgb(h);\n        var r = h.r / 255, g = h.g / 255, b = h.b / 255;\n        l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB);\n        var bl = b - l, k = (E * (g - l) - C * bl) / D;\n        s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)); // NaN if l=0 or l=1\n        h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;\n        if (h < 0) h += 360;\n      }\n    }\n    return new Cubehelix(h, s, l);\n  }\n\n  function Cubehelix(h, s, l) {\n    this.h = +h;\n    this.s = +s;\n    this.l = +l;\n  }\n\n  var prototype = cubehelix.prototype = Cubehelix.prototype = new Color;\n\n  prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Cubehelix(this.h, this.s, this.l * k);\n  };\n\n  prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Cubehelix(this.h, this.s, this.l * k);\n  };\n\n  prototype.rgb = function() {\n    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,\n        l = +this.l,\n        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),\n        cosh = Math.cos(h),\n        sinh = Math.sin(h);\n    return new Rgb(\n      255 * (l + a * (A * cosh + B * sinh)),\n      255 * (l + a * (C * cosh + D * sinh)),\n      255 * (l + a * (E * cosh))\n    );\n  };\n\n  function interpolateCubehelixGamma(gamma) {\n    return function(a, b) {\n      a = cubehelix(a);\n      b = cubehelix(b);\n      var ah = isNaN(a.h) ? b.h : a.h,\n          as = isNaN(a.s) ? b.s : a.s,\n          al = a.l,\n          bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n          bs = isNaN(b.s) ? 0 : b.s - as,\n          bl = b.l - al;\n      return function(t) {\n        a.h = ah + bh * t;\n        a.s = as + bs * t;\n        a.l = al + bl * Math.pow(t, gamma);\n        return a + \"\";\n      };\n    };\n  }\n\n  function interpolateCubehelixGammaLong(gamma) {\n    return function(a, b) {\n      a = cubehelix(a);\n      b = cubehelix(b);\n      var ah = isNaN(a.h) ? b.h : a.h,\n          as = isNaN(a.s) ? b.s : a.s,\n          al = a.l,\n          bh = isNaN(b.h) ? 0 : b.h - ah,\n          bs = isNaN(b.s) ? 0 : b.s - as,\n          bl = b.l - al;\n      return function(t) {\n        a.h = ah + bh * t;\n        a.s = as + bs * t;\n        a.l = al + bl * Math.pow(t, gamma);\n        return a + \"\";\n      };\n    };\n  }\n\n  function interpolateHclLong(a, b) {\n    a = hcl(a);\n    b = hcl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        ac = isNaN(a.c) ? b.c : a.c,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : b.h - ah,\n        bc = isNaN(b.c) ? 0 : b.c - ac,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.c = ac + bc * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHcl(a, b) {\n    a = hcl(a);\n    b = hcl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        ac = isNaN(a.c) ? b.c : a.c,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n        bc = isNaN(b.c) ? 0 : b.c - ac,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.c = ac + bc * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateLab(a, b) {\n    a = lab(a);\n    b = lab(b);\n    var al = a.l,\n        aa = a.a,\n        ab = a.b,\n        bl = b.l - al,\n        ba = b.a - aa,\n        bb = b.b - ab;\n    return function(t) {\n      a.l = al + bl * t;\n      a.a = aa + ba * t;\n      a.b = ab + bb * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHslLong(a, b) {\n    a = hsl(a);\n    b = hsl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : b.h - ah,\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHsl(a, b) {\n    a = hsl(a);\n    b = hsl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateRgb(a, b) {\n    a = rgb(a);\n    b = rgb(b);\n    var ar = a.r,\n        ag = a.g,\n        ab = a.b,\n        br = b.r - ar,\n        bg = b.g - ag,\n        bb = b.b - ab;\n    return function(t) {\n      return format(Math.round(ar + br * t), Math.round(ag + bg * t), Math.round(ab + bb * t));\n    };\n  }\n\n  exports.interpolateCubehelix = interpolateCubehelixGamma(1);\n  exports.interpolateCubehelixLong = interpolateCubehelixGammaLong(1);\n\n  exports.color = color;\n  exports.rgb = rgb;\n  exports.hsl = hsl;\n  exports.lab = lab;\n  exports.hcl = hcl;\n  exports.cubehelix = cubehelix;\n  exports.interpolateRgb = interpolateRgb;\n  exports.interpolateHsl = interpolateHsl;\n  exports.interpolateHslLong = interpolateHslLong;\n  exports.interpolateLab = interpolateLab;\n  exports.interpolateHcl = interpolateHcl;\n  exports.interpolateHclLong = interpolateHclLong;\n  exports.interpolateCubehelixGamma = interpolateCubehelixGamma;\n  exports.interpolateCubehelixGammaLong = interpolateCubehelixGammaLong;\n\n}));","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.format = {}));\n}(this, function (exports) { 'use strict';\n\n  var prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\n\n  // Computes the decimal coefficient and exponent of the specified number x with\n  // significant digits p, where x is positive and p is in [1, 21] or undefined.\n  // For example, formatDecimal(1.23) returns [\"123\", 0].\n  function formatDecimal(x, p) {\n    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, Infinity\n    var i, coefficient = x.slice(0, i);\n\n    // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n    // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n    return [\n      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n      +x.slice(i + 1)\n    ];\n  }\n\n  function exponent(x) {\n    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;\n  }\n\n  var prefixExponent;\n\n  function formatPrefixAuto(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1],\n        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n        n = coefficient.length;\n    return i === n ? coefficient\n        : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n        : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n        : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimal(x, p + i - 1)[0]; // less than 1y!\n  }\n\n  function formatRounded(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1];\n    return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n        : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n  }\n\n  function formatDefault(x, p) {\n    x = x.toPrecision(p);\n\n    out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {\n      switch (x[i]) {\n        case \".\": i0 = i1 = i; break;\n        case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n        case \"e\": break out;\n        default: if (i0 > 0) i0 = 0; break;\n      }\n    }\n\n    return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;\n  }\n\n  var formatTypes = {\n    \"\": formatDefault,\n    \"%\": function(x, p) { return (x * 100).toFixed(p); },\n    \"b\": function(x) { return Math.round(x).toString(2); },\n    \"c\": function(x) { return x + \"\"; },\n    \"d\": function(x) { return Math.round(x).toString(10); },\n    \"e\": function(x, p) { return x.toExponential(p); },\n    \"f\": function(x, p) { return x.toFixed(p); },\n    \"g\": function(x, p) { return x.toPrecision(p); },\n    \"o\": function(x) { return Math.round(x).toString(8); },\n    \"p\": function(x, p) { return formatRounded(x * 100, p); },\n    \"r\": formatRounded,\n    \"s\": formatPrefixAuto,\n    \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n    \"x\": function(x) { return Math.round(x).toString(16); }\n  };\n\n\n  // [[fill]align][sign][symbol][0][width][,][.precision][type]\n  var re = /^(?:(.)?([<>=^]))?([+\\-\\( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?([a-z%])?$/i;\n\n  function FormatSpecifier(specifier) {\n    if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n\n    var match,\n        fill = match[1] || \" \",\n        align = match[2] || \">\",\n        sign = match[3] || \"-\",\n        symbol = match[4] || \"\",\n        zero = !!match[5],\n        width = match[6] && +match[6],\n        comma = !!match[7],\n        precision = match[8] && +match[8].slice(1),\n        type = match[9] || \"\";\n\n    // The \"n\" type is an alias for \",g\".\n    if (type === \"n\") comma = true, type = \"g\";\n\n    // Map invalid types to the default format.\n    else if (!formatTypes[type]) type = \"\";\n\n    // If zero fill is specified, padding goes after sign and before digits.\n    if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n    this.fill = fill;\n    this.align = align;\n    this.sign = sign;\n    this.symbol = symbol;\n    this.zero = zero;\n    this.width = width;\n    this.comma = comma;\n    this.precision = precision;\n    this.type = type;\n  }\n\n  FormatSpecifier.prototype.toString = function() {\n    return this.fill\n        + this.align\n        + this.sign\n        + this.symbol\n        + (this.zero ? \"0\" : \"\")\n        + (this.width == null ? \"\" : Math.max(1, this.width | 0))\n        + (this.comma ? \",\" : \"\")\n        + (this.precision == null ? \"\" : \".\" + Math.max(0, this.precision | 0))\n        + this.type;\n  };\n\n  function formatSpecifier(specifier) {\n    return new FormatSpecifier(specifier);\n  }\n\n  function identity(x) {\n    return x;\n  }\n\n  function formatGroup(grouping, thousands) {\n    return function(value, width) {\n      var i = value.length,\n          t = [],\n          j = 0,\n          g = grouping[0],\n          length = 0;\n\n      while (i > 0 && g > 0) {\n        if (length + g + 1 > width) g = Math.max(1, width - length);\n        t.push(value.substring(i -= g, i + g));\n        if ((length += g + 1) > width) break;\n        g = grouping[j = (j + 1) % grouping.length];\n      }\n\n      return t.reverse().join(thousands);\n    };\n  }\n\n  function localeFormat(locale) {\n    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,\n        currency = locale.currency,\n        decimal = locale.decimal;\n\n    function format(specifier) {\n      specifier = formatSpecifier(specifier);\n\n      var fill = specifier.fill,\n          align = specifier.align,\n          sign = specifier.sign,\n          symbol = specifier.symbol,\n          zero = specifier.zero,\n          width = specifier.width,\n          comma = specifier.comma,\n          precision = specifier.precision,\n          type = specifier.type;\n\n      // Compute the prefix and suffix.\n      // For SI-prefix, the suffix is lazily computed.\n      var prefix = symbol === \"$\" ? currency[0] : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n          suffix = symbol === \"$\" ? currency[1] : /[%p]/.test(type) ? \"%\" : \"\";\n\n      // What format function should we use?\n      // Is this an integer type?\n      // Can this type generate exponential notation?\n      var formatType = formatTypes[type],\n          maybeSuffix = !type || /[defgprs%]/.test(type);\n\n      // Set the default precision if not specified,\n      // or clamp the specified precision to the supported range.\n      // For significant precision, it must be in [1, 21].\n      // For fixed precision, it must be in [0, 20].\n      precision = precision == null ? (type ? 6 : 12)\n          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n          : Math.max(0, Math.min(20, precision));\n\n      return function(value) {\n        var valuePrefix = prefix,\n            valueSuffix = suffix;\n\n        if (type === \"c\") {\n          valueSuffix = formatType(value) + valueSuffix;\n          value = \"\";\n        } else {\n          value = +value;\n\n          // Convert negative to positive, and compute the prefix.\n          // Note that -0 is not less than 0, but 1 / -0 is!\n          var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);\n\n          // Perform the initial formatting.\n          value = formatType(value, precision);\n\n          // Compute the prefix and suffix.\n          valuePrefix = (valueNegative ? (sign === \"(\" ? sign : \"-\") : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n          valueSuffix = valueSuffix + (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n          // Break the formatted value into the integer value part that can be\n          // grouped, and fractional or exponential suffix part that is not.\n          if (maybeSuffix) {\n            var i = -1, n = value.length, c;\n            while (++i < n) {\n              if (c = value.charCodeAt(i), 48 > c || c > 57) {\n                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n                value = value.slice(0, i);\n                break;\n              }\n            }\n          }\n        }\n\n        // If the fill character is not \"0\", grouping is applied before padding.\n        if (comma && !zero) value = group(value, Infinity);\n\n        // Compute the padding.\n        var length = valuePrefix.length + value.length + valueSuffix.length,\n            padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n        // If the fill character is \"0\", grouping is applied after padding.\n        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n        // Reconstruct the final output based on the desired alignment.\n        switch (align) {\n          case \"<\": return valuePrefix + value + valueSuffix + padding;\n          case \"=\": return valuePrefix + padding + value + valueSuffix;\n          case \"^\": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);\n        }\n        return padding + valuePrefix + value + valueSuffix;\n      };\n    }\n\n    function formatPrefix(specifier, value) {\n      var f = format((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,\n          k = Math.pow(10, -e),\n          prefix = prefixes[8 + e / 3];\n      return function(value) {\n        return f(k * value) + prefix;\n      };\n    }\n\n    return {\n      format: format,\n      formatPrefix: formatPrefix\n    };\n  }\n\n  var locale = localeFormat({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"$\", \"\"]\n  });\n\n  exports.format = locale.format;\n  exports.formatPrefix = locale.formatPrefix;\n\n  function precisionRound(step, max) {\n    return Math.max(0, exponent(Math.abs(max)) - exponent(Math.abs(step))) + 1;\n  }\n\n  function precisionPrefix(step, value) {\n    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));\n  }\n\n  function precisionFixed(step) {\n    return Math.max(0, -exponent(Math.abs(step)));\n  }\n\n  exports.formatSpecifier = formatSpecifier;\n  exports.localeFormat = localeFormat;\n  exports.precisionFixed = precisionFixed;\n  exports.precisionPrefix = precisionPrefix;\n  exports.precisionRound = precisionRound;\n\n}));","if (typeof Map === \"undefined\") {\n  Map = function() { this.clear(); };\n  Map.prototype = {\n    set: function(k, v) { this._[k] = v; return this; },\n    get: function(k) { return this._[k]; },\n    has: function(k) { return k in this._; },\n    delete: function(k) { return k in this._ && delete this._[k]; },\n    clear: function() { this._ = Object.create(null); },\n    get size() { var n = 0; for (var k in this._) ++n; return n; },\n    forEach: function(c) { for (var k in this._) c(this._[k], k, this); }\n  };\n} else (function() {\n  var m = new Map;\n  if (m.set(0, 0) !== m) {\n    m = m.set;\n    Map.prototype.set = function() { m.apply(this, arguments); return this; };\n  }\n})();\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.timeFormat = {}));\n}(this, function (exports) { 'use strict';\n\n  function utcDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n      date.setUTCFullYear(d.y);\n      return date;\n    }\n    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n  }\n\n  function localDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n      date.setFullYear(d.y);\n      return date;\n    }\n    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n  }\n\n  var pads = {\"-\": \"\", \"_\": \" \", \"0\": \"0\"};\n\n  function newYear(y) {\n    return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};\n  }\n\n  var percentRe = /^%/;\n\n  function parseLiteralPercent(d, string, i) {\n    var n = percentRe.exec(string.slice(i, i + 1));\n    return n ? i + n[0].length : -1;\n  }\n\n  function parseZone(d, string, i) {\n    return /^[+-]\\d{4}$/.test(string = string.slice(i, i + 5))\n        ? (d.Z = -string, i + 5) // sign differs from getTimezoneOffset!\n        : -1;\n  }\n\n  var numberRe = /^\\s*\\d+/;\n\n  function parseWeekdayNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 1));\n    return n ? (d.w = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberSunday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.U = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberMonday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.W = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n  }\n\n  function parseMonthNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n  }\n\n  function parseDayOfMonth(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseDayOfYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseHour24(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.H = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMinutes(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.M = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseSeconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.S = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMilliseconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.L = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseFullYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 4));\n    return n ? (d.y = +n[0], i + n[0].length) : -1;\n  }\n\n  function formatLiteralPercent() {\n    return \"%\";\n  }\n\n  function formatUTCZone() {\n    return \"+0000\";\n  }\n\n  function pad(value, fill, width) {\n    var sign = value < 0 ? \"-\" : \"\",\n        string = (sign ? -value : value) + \"\",\n        length = string.length;\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n  }\n\n  function formatUTCFullYear(d, p) {\n    return pad(d.getUTCFullYear() % 10000, p, 4);\n  }\n\n  function formatUTCYear(d, p) {\n    return pad(d.getUTCFullYear() % 100, p, 2);\n  }\n\n  var t1 = new Date;\n\n  var t0 = new Date;\n\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  }\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, offset) {\n    date.setUTCFullYear(date.getUTCFullYear() + offset);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, offset) {\n      date.setUTCDate(date.getUTCDate() + offset * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcMonday = utcWeekday(1);\n\n  function formatUTCWeekNumberMonday(d, p) {\n    return pad(utcMonday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCWeekdayNumber(d) {\n    return d.getUTCDay();\n  }\n\n  var utcSunday = utcWeekday(0);\n\n  function formatUTCWeekNumberSunday(d, p) {\n    return pad(utcSunday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCSeconds(d, p) {\n    return pad(d.getUTCSeconds(), p, 2);\n  }\n\n  function formatUTCMinutes(d, p) {\n    return pad(d.getUTCMinutes(), p, 2);\n  }\n\n  function formatUTCMonthNumber(d, p) {\n    return pad(d.getUTCMonth() + 1, p, 2);\n  }\n\n  function formatUTCMilliseconds(d, p) {\n    return pad(d.getUTCMilliseconds(), p, 3);\n  }\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, offset) {\n    date.setUTCDate(date.getUTCDate() + offset);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  function formatUTCDayOfYear(d, p) {\n    return pad(1 + utcDay.count(utcYear(d), d), p, 3);\n  }\n\n  function formatUTCHour12(d, p) {\n    return pad(d.getUTCHours() % 12 || 12, p, 2);\n  }\n\n  function formatUTCHour24(d, p) {\n    return pad(d.getUTCHours(), p, 2);\n  }\n\n  function formatUTCDayOfMonth(d, p) {\n    return pad(d.getUTCDate(), p, 2);\n  }\n\n  function formatZone(d) {\n    var z = d.getTimezoneOffset();\n    return (z > 0 ? \"-\" : (z *= -1, \"+\"))\n        + pad(z / 60 | 0, \"0\", 2)\n        + pad(z % 60, \"0\", 2);\n  }\n\n  function formatFullYear(d, p) {\n    return pad(d.getFullYear() % 10000, p, 4);\n  }\n\n  function formatYear(d, p) {\n    return pad(d.getFullYear() % 100, p, 2);\n  }\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, offset) {\n    date.setFullYear(date.getFullYear() + offset);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, offset) {\n      date.setDate(date.getDate() + offset * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var monday = weekday(1);\n\n  function formatWeekNumberMonday(d, p) {\n    return pad(monday.count(year(d), d), p, 2);\n  }\n\n  function formatWeekdayNumber(d) {\n    return d.getDay();\n  }\n\n  var sunday = weekday(0);\n\n  function formatWeekNumberSunday(d, p) {\n    return pad(sunday.count(year(d), d), p, 2);\n  }\n\n  function formatSeconds(d, p) {\n    return pad(d.getSeconds(), p, 2);\n  }\n\n  function formatMinutes(d, p) {\n    return pad(d.getMinutes(), p, 2);\n  }\n\n  function formatMonthNumber(d, p) {\n    return pad(d.getMonth() + 1, p, 2);\n  }\n\n  function formatMilliseconds(d, p) {\n    return pad(d.getMilliseconds(), p, 3);\n  }\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, offset) {\n    date.setDate(date.getDate() + offset);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  function formatDayOfYear(d, p) {\n    return pad(1 + day.count(year(d), d), p, 3);\n  }\n\n  function formatHour12(d, p) {\n    return pad(d.getHours() % 12 || 12, p, 2);\n  }\n\n  function formatHour24(d, p) {\n    return pad(d.getHours(), p, 2);\n  }\n\n  function formatDayOfMonth(d, p) {\n    return pad(d.getDate(), p, 2);\n  }\n\n  function formatLookup(names) {\n    var map = new Map, i = -1, n = names.length;\n    while (++i < n) map.set(names[i].toLowerCase(), i);\n    return map;\n  }\n\n  var requoteRe = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\n  function requote(s) {\n    return s.replace(requoteRe, \"\\\\$&\");\n  }\n\n  function formatRe(names) {\n    return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n  }\n\n  function localeFormat(locale) {\n    var locale_dateTime = locale.dateTime,\n        locale_date = locale.date,\n        locale_time = locale.time,\n        locale_periods = locale.periods,\n        locale_weekdays = locale.days,\n        locale_shortWeekdays = locale.shortDays,\n        locale_months = locale.months,\n        locale_shortMonths = locale.shortMonths;\n\n    var periodLookup = formatLookup(locale_periods),\n        weekdayRe = formatRe(locale_weekdays),\n        weekdayLookup = formatLookup(locale_weekdays),\n        shortWeekdayRe = formatRe(locale_shortWeekdays),\n        shortWeekdayLookup = formatLookup(locale_shortWeekdays),\n        monthRe = formatRe(locale_months),\n        monthLookup = formatLookup(locale_months),\n        shortMonthRe = formatRe(locale_shortMonths),\n        shortMonthLookup = formatLookup(locale_shortMonths);\n\n    var formats = {\n      \"a\": formatShortWeekday,\n      \"A\": formatWeekday,\n      \"b\": formatShortMonth,\n      \"B\": formatMonth,\n      \"c\": null,\n      \"d\": formatDayOfMonth,\n      \"e\": formatDayOfMonth,\n      \"H\": formatHour24,\n      \"I\": formatHour12,\n      \"j\": formatDayOfYear,\n      \"L\": formatMilliseconds,\n      \"m\": formatMonthNumber,\n      \"M\": formatMinutes,\n      \"p\": formatPeriod,\n      \"S\": formatSeconds,\n      \"U\": formatWeekNumberSunday,\n      \"w\": formatWeekdayNumber,\n      \"W\": formatWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatYear,\n      \"Y\": formatFullYear,\n      \"Z\": formatZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var utcFormats = {\n      \"a\": formatUTCShortWeekday,\n      \"A\": formatUTCWeekday,\n      \"b\": formatUTCShortMonth,\n      \"B\": formatUTCMonth,\n      \"c\": null,\n      \"d\": formatUTCDayOfMonth,\n      \"e\": formatUTCDayOfMonth,\n      \"H\": formatUTCHour24,\n      \"I\": formatUTCHour12,\n      \"j\": formatUTCDayOfYear,\n      \"L\": formatUTCMilliseconds,\n      \"m\": formatUTCMonthNumber,\n      \"M\": formatUTCMinutes,\n      \"p\": formatUTCPeriod,\n      \"S\": formatUTCSeconds,\n      \"U\": formatUTCWeekNumberSunday,\n      \"w\": formatUTCWeekdayNumber,\n      \"W\": formatUTCWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatUTCYear,\n      \"Y\": formatUTCFullYear,\n      \"Z\": formatUTCZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var parses = {\n      \"a\": parseShortWeekday,\n      \"A\": parseWeekday,\n      \"b\": parseShortMonth,\n      \"B\": parseMonth,\n      \"c\": parseLocaleDateTime,\n      \"d\": parseDayOfMonth,\n      \"e\": parseDayOfMonth,\n      \"H\": parseHour24,\n      \"I\": parseHour24,\n      \"j\": parseDayOfYear,\n      \"L\": parseMilliseconds,\n      \"m\": parseMonthNumber,\n      \"M\": parseMinutes,\n      \"p\": parsePeriod,\n      \"S\": parseSeconds,\n      \"U\": parseWeekNumberSunday,\n      \"w\": parseWeekdayNumber,\n      \"W\": parseWeekNumberMonday,\n      \"x\": parseLocaleDate,\n      \"X\": parseLocaleTime,\n      \"y\": parseYear,\n      \"Y\": parseFullYear,\n      \"Z\": parseZone,\n      \"%\": parseLiteralPercent\n    };\n\n    // These recursive directive definitions must be deferred.\n    formats.x = newFormat(locale_date, formats);\n    formats.X = newFormat(locale_time, formats);\n    formats.c = newFormat(locale_dateTime, formats);\n    utcFormats.x = newFormat(locale_date, utcFormats);\n    utcFormats.X = newFormat(locale_time, utcFormats);\n    utcFormats.c = newFormat(locale_dateTime, utcFormats);\n\n    function newFormat(specifier, formats) {\n      return function(date) {\n        var string = [],\n            i = -1,\n            j = 0,\n            n = specifier.length,\n            c,\n            pad,\n            format;\n\n        while (++i < n) {\n          if (specifier.charCodeAt(i) === 37) {\n            string.push(specifier.slice(j, i));\n            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);\n            if (format = formats[c]) c = format(date, pad == null ? (c === \"e\" ? \" \" : \"0\") : pad);\n            string.push(c);\n            j = i + 1;\n          }\n        }\n\n        string.push(specifier.slice(j, i));\n        return string.join(\"\");\n      };\n    }\n\n    function newParse(specifier, newDate) {\n      return function(string) {\n        var d = newYear(1900),\n            i = parseSpecifier(d, specifier, string, 0);\n        if (i != string.length) return null;\n\n        // The am-pm flag is 0 for AM, and 1 for PM.\n        if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\n        // If a time zone is specified, all fields are interpreted as UTC and then\n        // offset according to the specified time zone.\n        if (\"Z\" in d) {\n          if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n            var day = utcDate(newYear(d.y)).getUTCDay();\n            if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n            d.m = 0;\n            d.d = d.w + d.U * 7 - (day + 6) % 7;\n          }\n          d.H += d.Z / 100 | 0;\n          d.M += d.Z % 100;\n          return utcDate(d);\n        }\n\n        // Otherwise, all fields are in local time.\n        if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n          var day = newDate(newYear(d.y)).getDay();\n          if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n          d.m = 0;\n          d.d = d.w + d.U * 7 - (day + 6) % 7;\n        }\n        return newDate(d);\n      };\n    }\n\n    function parseSpecifier(d, specifier, string, j) {\n      var i = 0,\n          n = specifier.length,\n          m = string.length,\n          c,\n          parse;\n\n      while (i < n) {\n        if (j >= m) return -1;\n        c = specifier.charCodeAt(i++);\n        if (c === 37) {\n          c = specifier.charAt(i++);\n          parse = parses[c in pads ? specifier.charAt(i++) : c];\n          if (!parse || ((j = parse(d, string, j)) < 0)) return -1;\n        } else if (c != string.charCodeAt(j++)) {\n          return -1;\n        }\n      }\n\n      return j;\n    }\n\n    function parseShortWeekday(d, string, i) {\n      var n = shortWeekdayRe.exec(string.slice(i));\n      return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseWeekday(d, string, i) {\n      var n = weekdayRe.exec(string.slice(i));\n      return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseShortMonth(d, string, i) {\n      var n = shortMonthRe.exec(string.slice(i));\n      return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseMonth(d, string, i) {\n      var n = monthRe.exec(string.slice(i));\n      return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseLocaleDateTime(d, string, i) {\n      return parseSpecifier(d, locale_dateTime, string, i);\n    }\n\n    function parseLocaleDate(d, string, i) {\n      return parseSpecifier(d, locale_date, string, i);\n    }\n\n    function parseLocaleTime(d, string, i) {\n      return parseSpecifier(d, locale_time, string, i);\n    }\n\n    function parsePeriod(d, string, i) {\n      var n = periodLookup.get(string.slice(i, i += 2).toLowerCase());\n      return n == null ? -1 : (d.p = n, i);\n    }\n\n    function formatShortWeekday(d) {\n      return locale_shortWeekdays[d.getDay()];\n    }\n\n    function formatWeekday(d) {\n      return locale_weekdays[d.getDay()];\n    }\n\n    function formatShortMonth(d) {\n      return locale_shortMonths[d.getMonth()];\n    }\n\n    function formatMonth(d) {\n      return locale_months[d.getMonth()];\n    }\n\n    function formatPeriod(d) {\n      return locale_periods[+(d.getHours() >= 12)];\n    }\n\n    function formatUTCShortWeekday(d) {\n      return locale_shortWeekdays[d.getUTCDay()];\n    }\n\n    function formatUTCWeekday(d) {\n      return locale_weekdays[d.getUTCDay()];\n    }\n\n    function formatUTCShortMonth(d) {\n      return locale_shortMonths[d.getUTCMonth()];\n    }\n\n    function formatUTCMonth(d) {\n      return locale_months[d.getUTCMonth()];\n    }\n\n    function formatUTCPeriod(d) {\n      return locale_periods[+(d.getUTCHours() >= 12)];\n    }\n\n    return {\n      format: function(specifier) {\n        var f = newFormat(specifier += \"\", formats);\n        f.parse = newParse(specifier, localDate);\n        f.toString = function() { return specifier; };\n        return f;\n      },\n      utcFormat: function(specifier) {\n        var f = newFormat(specifier += \"\", utcFormats);\n        f.parse = newParse(specifier, utcDate);\n        f.toString = function() { return specifier; };\n        return f;\n      }\n    };\n  }\n\n  var locale = localeFormat({\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%m/%d/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  });\n\n  exports.format = locale.format;\n  exports.utcFormat = locale.utcFormat;\n\n  var isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\n\n  function formatIsoNative(date) {\n    return date.toISOString();\n  }\n\n  formatIsoNative.parse = function(string) {\n    var date = new Date(string);\n    return isNaN(date) ? null : date;\n  };\n\n  formatIsoNative.toString = function() {\n    return isoSpecifier;\n  };\n\n  var formatIso = Date.prototype.toISOString && +new Date(\"2000-01-01T00:00:00.000Z\")\n      ? formatIsoNative\n      : locale.utcFormat(isoSpecifier);\n\n  var isoFormat = formatIso;\n\n  exports.isoFormat = isoFormat;\n  exports.localeFormat = localeFormat;\n\n}));","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t1 = new Date;\n\n  var t0 = new Date;\n\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  }\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  exports.seconds = second.range;\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  exports.minutes = minute.range;\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  exports.hours = hour.range;\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  exports.days = day.range;\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  exports.sunday = weekday(0);\n\n  exports.sundays = exports.sunday.range;\n\n  exports.monday = weekday(1);\n\n  exports.mondays = exports.monday.range;\n\n  exports.tuesday = weekday(2);\n\n  exports.tuesdays = exports.tuesday.range;\n\n  exports.wednesday = weekday(3);\n\n  exports.wednesdays = exports.wednesday.range;\n\n  exports.thursday = weekday(4);\n\n  exports.thursdays = exports.thursday.range;\n\n  exports.friday = weekday(5);\n\n  exports.fridays = exports.friday.range;\n\n  exports.saturday = weekday(6);\n\n  exports.saturdays = exports.saturday.range;\n\n  var week = exports.sunday;\n\n  exports.weeks = week.range;\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  });\n\n  exports.months = month.range;\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  exports.years = year.range;\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  exports.utcSeconds = utcSecond.range;\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  exports.utcMinutes = utcMinute.range;\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  exports.utcHours = utcHour.range;\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  exports.utcDays = utcDay.range;\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  exports.utcSunday = utcWeekday(0);\n\n  exports.utcSundays = exports.utcSunday.range;\n\n  exports.utcMonday = utcWeekday(1);\n\n  exports.utcMondays = exports.utcMonday.range;\n\n  exports.utcTuesday = utcWeekday(2);\n\n  exports.utcTuesdays = exports.utcTuesday.range;\n\n  exports.utcWednesday = utcWeekday(3);\n\n  exports.utcWednesdays = exports.utcWednesday.range;\n\n  exports.utcThursday = utcWeekday(4);\n\n  exports.utcThursdays = exports.utcThursday.range;\n\n  exports.utcFriday = utcWeekday(5);\n\n  exports.utcFridays = exports.utcFriday.range;\n\n  exports.utcSaturday = utcWeekday(6);\n\n  exports.utcSaturdays = exports.utcSaturday.range;\n\n  var utcWeek = exports.utcSunday;\n\n  exports.utcWeeks = utcWeek.range;\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  });\n\n  exports.utcMonths = utcMonth.range;\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  exports.utcYears = utcYear.range;\n\n  exports.interval = newInterval;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.week = week;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcWeek = utcWeek;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n\n}));","var util = require('../util'),\n    time = require('../time'),\n    EPSILON = 1e-15;\n\nfunction bins(opt) {\n  if (!opt) { throw Error(\"Missing binning options.\"); }\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  if (!opt) { throw Error(\"Missing date binning options.\"); }\n\n  // find time step, then bin\n  var units = opt.utc ? time.utc : time,\n      dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n","var gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};","var util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    types[f] = infer(data, f);\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;","var util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length < 2) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (v === v) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (v === v) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance] \n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;","var d3_time = require('d3-time');\n\nvar tempDate = new Date(),\n    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD\n    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);\n\nfunction date(d) {\n  return (tempDate.setTime(+d), tempDate);\n}\n\n// create a time unit entry\nfunction entry(type, date, unit, step, min, max) {\n  var e = {\n    type: type,\n    date: date,\n    unit: unit\n  };\n  if (step) {\n    e.step = step;\n  } else {\n    e.minstep = 1;\n  }\n  if (min != null) e.min = min;\n  if (max != null) e.max = max;\n  return e;\n}\n\nfunction create(type, unit, base, step, min, max) {\n  return entry(type,\n    function(d) { return unit.offset(base, d); },\n    function(d) { return unit.count(base, d); },\n    step, min, max);\n}\n\nvar locale = [\n  create('second', d3_time.second, baseDate),\n  create('minute', d3_time.minute, baseDate),\n  create('hour',   d3_time.hour,   baseDate),\n  create('day',    d3_time.day,    baseDate, [1, 7]),\n  create('month',  d3_time.month,  baseDate, [1, 3, 6]),\n  create('year',   d3_time.year,   baseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(1970, 0, 1, 0, 0, d); },\n    function(d) { return date(d).getSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(1970, 0, 1, 0, d); },\n    function(d) { return date(d).getMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(1970, 0, 1, d); },\n    function(d) { return date(d).getHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(1970, 0, 4+d); },\n    function(d) { return date(d).getDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(1970, 0, d); },\n    function(d) { return date(d).getDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(1970, d % 12, 1); },\n    function(d) { return date(d).getMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar utc = [\n  create('second', d3_time.utcSecond, utcBaseDate),\n  create('minute', d3_time.utcMinute, utcBaseDate),\n  create('hour',   d3_time.utcHour,   utcBaseDate),\n  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),\n  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),\n  create('year',   d3_time.utcYear,   utcBaseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },\n    function(d) { return date(d).getUTCSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },\n    function(d) { return date(d).getUTCMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },\n    function(d) { return date(d).getUTCHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },\n    function(d) { return date(d).getUTCDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(Date.UTC(1970, 0, d)); },\n    function(d) { return date(d).getUTCDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },\n    function(d) { return date(d).getUTCMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction find(units, span, minb, maxb) {\n  var step = STEPS[0], i, n, bins;\n\n  for (i=1, n=STEPS.length; i<n; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return units[STEPS[i-1][1]];\n      }\n      if (bins >= minb) {\n        return units[step[1]];\n      }\n    }\n  }\n  return units[STEPS[n-1][1]];\n}\n\nfunction toUnitMap(units) {\n  var map = {}, i, n;\n  for (i=0, n=units.length; i<n; ++i) {\n    map[units[i].type] = units[i];\n  }\n  map.find = function(span, minb, maxb) {\n    return find(units, span, minb, maxb);\n  };\n  return map;\n}\n\nmodule.exports = toUnitMap(locale);\nmodule.exports.utc = toUnitMap(utc);\n","var buffer = require('buffer'),\n    time = require('./time'),\n    utc = time.utc;\n\nvar u = module.exports = {};\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (buffer.Buffer && buffer.Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\nu.date = function(s) {\n  return s == null || s === '' ? null : Date.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nu.field = function(f) {\n  return String(f).split('\\\\.')\n    .map(function(d) { return d.split('.'); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += '.' + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\nu.$year   = u.$func('year', time.year.unit);\nu.$month  = u.$func('month', time.months.unit);\nu.$date   = u.$func('date', time.dates.unit);\nu.$day    = u.$func('day', time.weekdays.unit);\nu.$hour   = u.$func('hour', time.hours.unit);\nu.$minute = u.$func('minute', time.minutes.unit);\nu.$second = u.$func('second', time.seconds.unit);\n\nu.$utcYear   = u.$func('utcYear', utc.year.unit);\nu.$utcMonth  = u.$func('utcMonth', utc.months.unit);\nu.$utcDate   = u.$func('utcDate', utc.dates.unit);\nu.$utcDay    = u.$func('utcDay', utc.weekdays.unit);\nu.$utcHour   = u.$func('utcHour', utc.hours.unit);\nu.$utcMinute = u.$func('utcMinute', utc.minutes.unit);\nu.$utcSecond = u.$func('utcSecond', utc.seconds.unit);\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n","'use strict';\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  util = require('./util'),\n  vlfield = require('./field'),\n  vlenc = require('./enc'),\n  schema = require('./schema/schema');\n\nmodule.exports = (function() {\n  function Encoding(spec, theme) {\n    var defaults = schema.instantiate(),\n      specExtended = schema.util.merge(defaults, theme || {}, spec) ;\n\n    this._data = specExtended.data;\n    this._marktype = specExtended.marktype;\n    this._enc = specExtended.encoding;\n    this._config = specExtended.config;\n    this._filter = specExtended.filter;\n    // this._vega2 = true;\n  }\n\n  var proto = Encoding.prototype;\n\n  Encoding.fromShorthand = function(shorthand, data, config, theme) {\n    var c = consts.shorthand,\n        split = shorthand.split(c.delim),\n        marktype = split.shift().split(c.assign)[1].trim(),\n        enc = vlenc.fromShorthand(split);\n\n    return new Encoding({\n      data: data,\n      marktype: marktype,\n      encoding: enc,\n      config: config,\n      filter: []\n    }, theme);\n  };\n\n  Encoding.fromSpec = function(spec, theme) {\n    return new Encoding(spec, theme);\n  };\n\n  proto.toShorthand = function() {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + this._marktype +\n      c.delim + vlenc.shorthand(this._enc);\n  };\n\n  Encoding.shorthand = function (spec) {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + spec.marktype +\n      c.delim + vlenc.shorthand(spec.encoding);\n  };\n\n  Encoding.specFromShorthand = function(shorthand, data, config, excludeConfig) {\n    return Encoding.fromShorthand(shorthand, data, config).toSpec(excludeConfig);\n  };\n\n  proto.toSpec = function(excludeConfig, excludeData) {\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    spec = {\n      marktype: this._marktype,\n      encoding: enc,\n      filter: this._filter\n    };\n\n    if (!excludeConfig) {\n      spec.config = util.duplicate(this._config);\n    }\n\n    if (!excludeData) {\n      spec.data = util.duplicate(this._data);\n    }\n\n    // remove defaults\n    var defaults = schema.instantiate();\n    return schema.util.subtract(spec, defaults);\n  };\n\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(encType) {\n    // equivalent to calling vlenc.has(this._enc, encType)\n    return this._enc[encType].name !== undefined;\n  };\n\n  proto.field = function(et) {\n    return this._enc[et];\n  };\n\n  proto.filter = function() {\n    var filterNull = [],\n      fields = this.fields(),\n      self = this;\n\n    util.forEach(fields, function(fieldList, fieldName) {\n      if (fieldName === '*') return; //count\n\n      if ((self.config('filterNull').Q && fieldList.containsType[Q]) ||\n          (self.config('filterNull').T && fieldList.containsType[T]) ||\n          (self.config('filterNull').O && fieldList.containsType[O]) ||\n          (self.config('filterNull').N && fieldList.containsType[N])) {\n        filterNull.push({\n          operands: [fieldName],\n          operator: 'notNull'\n        });\n      }\n    });\n\n    return filterNull.concat(this._filter);\n  };\n\n  // get \"field\" reference for vega\n  proto.fieldRef = function(et, opt) {\n    opt = opt || {};\n    opt.data = !this._vega2 && (opt.data !== false);\n    return vlfield.fieldRef(this._enc[et], opt);\n  };\n\n  proto.fieldName = function(et) {\n    return this._enc[et].name;\n  };\n\n  /*\n   * return key-value pairs of field name and list of fields of that field name\n   */\n  proto.fields = function() {\n    return vlenc.fields(this._enc);\n  };\n\n  proto.fieldTitle = function(et) {\n    if (vlfield.isCount(this._enc[et])) {\n      return vlfield.count.displayName;\n    }\n    var fn = this._enc[et].aggregate || this._enc[et].timeUnit || (this._enc[et].bin && 'bin');\n    if (fn) {\n      return fn.toUpperCase() + '(' + this._enc[et].name + ')';\n    } else {\n      return this._enc[et].name;\n    }\n  };\n\n  proto.scale = function(et) {\n    return this._enc[et].scale || {};\n  };\n\n  proto.axis = function(et) {\n    return this._enc[et].axis || {};\n  };\n\n  proto.bandSize = function(encType, useSmallBand) {\n    useSmallBand = useSmallBand ||\n      //isBandInSmallMultiples\n      (encType === Y && this.has(ROW) && this.has(Y)) ||\n      (encType === X && this.has(COL) && this.has(X));\n\n    // if band.size is explicitly specified, follow the specification, otherwise draw value from config.\n    return this.field(encType).band.size ||\n      this.config(useSmallBand ? 'smallBandSize' : 'largeBandSize');\n  };\n\n  proto.aggregate = function(et) {\n    return this._enc[et].aggregate;\n  };\n\n  // returns false if binning is disabled, otherwise an object with binning properties\n  proto.bin = function(et) {\n    var bin = this._enc[et].bin;\n    if (bin === {})\n      return false;\n    if (bin === true)\n      return {\n        maxbins: schema.MAXBINS_DEFAULT\n      };\n    return bin;\n  };\n\n  proto.value = function(et) {\n    return this._enc[et].value;\n  };\n\n  proto.numberFormat = function(fieldStats) {\n    var formatConfig = fieldStats.max > this.config('maxSmallNumber') ?\n      'largeNumberFormat': 'smallNumberFormat';\n    return this.config(formatConfig);\n  };\n\n  proto.sort = function(et, stats) {\n    var sort = this._enc[et].sort,\n      enc = this._enc,\n      isTypes = vlfield.isTypes;\n\n    if ((!sort || sort.length===0) &&\n        // FIXME\n        Encoding.toggleSort.support({encoding:this._enc}, stats, true) && //HACK\n        this.config('toggleSort') === Q\n      ) {\n      var qField = isTypes(enc.x, [N, O]) ? enc.y : enc.x;\n\n      if (isTypes(enc[et], [N, O])) {\n        sort = [{\n          name: qField.name,\n          aggregate: qField.aggregate,\n          type: qField.type,\n          reverse: true\n        }];\n      }\n    }\n\n    return sort;\n  };\n\n  proto.map = function(f) {\n    return vlenc.map(this._enc, f);\n  };\n\n  proto.reduce = function(f, init) {\n    return vlenc.reduce(this._enc, f, init);\n  };\n\n  proto.forEach = function(f) {\n    return vlenc.forEach(this._enc, f);\n  };\n\n  proto.type = function(et) {\n    return this.has(et) ? this._enc[et].type : null;\n  };\n\n  proto.isType = function(et, type) {\n    var field = this.field(et);\n    return field && vlfield.isType(field, type);\n  };\n\n  proto.isTypes = function(et, type) {\n    var field = this.field(et);\n    return field && vlfield.isTypes(field, type);\n  };\n\n  Encoding.isOrdinalScale = function(encoding, encType) {\n    return vlfield.isOrdinalScale(encoding.field(encType));\n  };\n\n  Encoding.isDimension = function(encoding, encType) {\n    return vlfield.isDimension(encoding.field(encType));\n  };\n\n  Encoding.isMeasure = function(encoding, encType) {\n    return vlfield.isMeasure(encoding.field(encType));\n  };\n\n  proto.isOrdinalScale = function(encType) {\n    return this.has(encType) && Encoding.isOrdinalScale(this, encType);\n  };\n\n  proto.isDimension = function(encType) {\n    return this.has(encType) && Encoding.isDimension(this, encType);\n  };\n\n  proto.isMeasure = function(encType) {\n    return this.has(encType) && Encoding.isMeasure(this, encType);\n  };\n\n  proto.isAggregate = function() {\n    return vlenc.isAggregate(this._enc);\n  };\n\n  Encoding.isAggregate = function(spec) {\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.alwaysNoOcclusion = function(spec) {\n    // FIXME raw OxQ with # of rows = # of O\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.isStack = function(spec) {\n    // FIXME update this once we have control for stack ...\n    return (spec.marktype === 'bar' || spec.marktype === 'area') &&\n      spec.encoding.color;\n  };\n\n  proto.isStack = function() {\n    // FIXME update this once we have control for stack ...\n    return (this.is('bar') || this.is('area')) && this.has('color');\n  };\n\n  proto.cardinality = function(encType, stats) {\n    return vlfield.cardinality(this.field(encType), stats, this.config('filterNull'));\n  };\n\n  proto.isRaw = function() {\n    return !this.isAggregate();\n  };\n\n  proto.data = function(name) {\n    return name ? this._data[name] : this._data;\n  };\n\n   // returns whether the encoding has values embedded\n  proto.hasValues = function() {\n    var vals = this.data('values');\n    return vals && vals.length;\n  };\n\n  proto.config = function(name) {\n    return this._config[name];\n  };\n\n  Encoding.transpose = function(spec) {\n    var oldenc = spec.encoding,\n      enc = util.duplicate(spec.encoding);\n    enc.x = oldenc.y;\n    enc.y = oldenc.x;\n    enc.row = oldenc.col;\n    enc.col = oldenc.row;\n    spec.encoding = enc;\n    return spec;\n  };\n\n  // FIXME: REMOVE everything below here\n\n  Encoding.toggleSort = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.toggleSort = spec.config.toggleSort === Q ? N : Q;\n    return spec;\n  };\n\n\n  Encoding.toggleSort.direction = function(spec) {\n    if (!Encoding.toggleSort.support(spec)) { return; }\n    var enc = spec.encoding;\n    return enc.x.type === N ? 'x' : 'y';\n  };\n\n  Encoding.toggleSort.mode = function(spec) {\n    return spec.config.toggleSort;\n  };\n\n  Encoding.toggleSort.support = function(spec, stats) {\n    var enc = spec.encoding,\n      isTypes = vlfield.isTypes;\n\n    if (vlenc.has(enc, ROW) || vlenc.has(enc, COL) ||\n      !vlenc.has(enc, X) || !vlenc.has(enc, Y) ||\n      !Encoding.alwaysNoOcclusion(spec, stats)) {\n      return false;\n    }\n\n    return ( isTypes(enc.x, [N,O]) && vlfield.isMeasure(enc.y)) ? 'x' :\n      ( isTypes(enc.y, [N,O]) && vlfield.isMeasure(enc.x)) ? 'y' : false;\n  };\n\n  Encoding.toggleFilterNullO = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.filterNull = spec.config.filterNull || { //FIXME\n      T: true,\n      Q: true\n    };\n    spec.config.filterNull.O = !spec.config.filterNull.O;\n    return spec;\n  };\n\n  Encoding.toggleFilterNullO.support = function(spec, stats) {\n    var fields = vlenc.fields(spec.encoding);\n    for (var fieldName in fields) {\n      var fieldList = fields[fieldName];\n      if (fieldList.containsType.O && fieldName in stats && stats[fieldName].nulls > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  return Encoding;\n})();\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util');\n\nmodule.exports = aggregates;\n\nfunction aggregates(dataTable, encoding, opt) {\n  opt = opt || {};\n\n  var dims = {}, meas = {}, detail = {}, facets = {};\n\n  encoding.forEach(function(field, encType) {\n    if (field.aggregate) {\n      if (field.aggregate === 'count') {\n        meas.count = {op: 'count', field: '*'};\n      }else {\n        meas[field.aggregate + '|'+ field.name] = {\n          op: field.aggregate,\n          field: encoding.fieldRef(encType, {nofn: true})\n        };\n      }\n    } else {\n      dims[field.name] = encoding.fieldRef(encType);\n      if (encType == ROW || encType == COL) {\n        facets[field.name] = dims[field.name];\n      }else if (encType !== X && encType !== Y) {\n        detail[field.name] = dims[field.name];\n      }\n    }\n  });\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0) {\n    if (!dataTable.transform) dataTable.transform = [];\n    dataTable.transform.push({\n      type: 'aggregate',\n      groupby: dims,\n      fields: meas\n    });\n  }\n  return {\n    details: util.vals(detail),\n    dims: dims,\n    facets: util.vals(facets),\n    aggregated: meas.length > 0\n  };\n}\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  getter = util.getter,\n  time = require('./time');\n\nvar axis = module.exports = {};\n\naxis.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    var s = props[x].scale;\n    if (s === X || s === Y) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\naxis.defs = function(names, encoding, layout, stats, opt) {\n  return names.reduce(function(a, name) {\n    a.push(axis.def(name, encoding, layout, stats, opt));\n    return a;\n  }, []);\n};\n\naxis.def = function(name, encoding, layout, stats, opt) {\n  var isCol = name == COL,\n    isRow = name == ROW,\n    type = isCol ? 'x' : isRow ? 'y' : name;\n\n  var def = {\n    type: type,\n    scale: name,\n    properties: {},\n    layer: encoding.field(name).axis.layer,\n    orient: axis.orient(name, encoding, stats)\n  };\n\n  // Add axis label custom scale (for bin / time)\n  def = axis.labels.scale(def, encoding, name);\n  def = axis.labels.format(def, name, encoding, stats);\n\n  // for x-axis, set ticks for Q or rotate scale for ordinal scale\n  if (name == X) {\n    if (encoding.isDimension(X) || encoding.isType(X, T)) {\n      // TODO(kanitw): Jul 19, 2015 - #506 add condition for rotation\n      def = axis.labels.rotate(def);\n    } else { // Q\n      def.ticks = encoding.field(name).axis.ticks;\n    }\n  }\n\n  // TitleOffset depends on labels rotation\n  def.titleOffset = axis.titleOffset(encoding, layout, name);\n\n  //def.offset is used in axis.grid\n  if(isRow) def.offset = axis.titleOffset(encoding, layout, Y) + 20;\n  // FIXME(kanitw): Jul 19, 2015 - offset for column when x is put on top\n\n  def = axis.grid(def, name, encoding, layout);\n  def = axis.title(def, name, encoding, layout, opt);\n\n  if (isRow || isCol) def = axis.hideTicks(def);\n\n  return def;\n};\n\naxis.orient = function(name, encoding, stats) {\n  var orient = encoding.field(name).axis.orient;\n  if (orient) return orient;\n\n  if (name===COL) return 'top';\n\n  // x-axis for long y - put on top\n  if (name===X && encoding.has(Y) && encoding.isOrdinalScale(Y) && encoding.cardinality(Y, stats) > 30) {\n    return 'top';\n  }\n\n  return undefined;\n};\n\naxis.grid = function(def, name, encoding, layout) {\n  var cellPadding = layout.cellPadding,\n    isCol = name == COL,\n    isRow = name == ROW;\n\n  if (encoding.axis(name).grid) {\n    def.grid = true;\n\n    if (isCol) {\n      // set grid property -- put the lines on the right the cell\n      def.properties.grid = {\n        x: {\n          offset: layout.cellWidth * (1+ cellPadding/2.0),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'col'\n        },\n        y: {\n          value: -layout.cellHeight * (cellPadding/2),\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      };\n    } else if (isRow) {\n      // set grid property -- put the lines on the top\n      def.properties.grid = {\n        y: {\n          offset: -layout.cellHeight * (cellPadding/2),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'row'\n        },\n        x: {\n          value: def.offset\n        },\n        x2: {\n          offset: def.offset + (layout.cellWidth * 0.05),\n          // default value(s) -- vega doesn't do recursive merge\n          group: 'mark.group.width',\n          mult: 1\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      };\n    } else {\n      def.properties.grid = {\n        stroke: { value: encoding.config('gridColor') },\n        opacity: { value: encoding.config('gridOpacity') }\n      };\n    }\n  }\n  return def;\n};\n\naxis.hideTicks = function(def) {\n  def.properties.ticks = {opacity: {value: 0}};\n  def.properties.majorTicks = {opacity: {value: 0}};\n  def.properties.axis = {opacity: {value: 0}};\n  return def;\n};\n\naxis.title = function (def, name, encoding, layout) {\n  var ax = encoding.field(name).axis;\n\n  if (ax.title) {\n    def.title = ax.title;\n  } else {\n    // if not defined, automatically determine axis title from field def\n    var fieldTitle = encoding.fieldTitle(name),\n      maxLength;\n\n    if (ax.titleMaxLength) {\n      maxLength = ax.titleMaxLength;\n    } else if (name===X) {\n      maxLength = layout.cellWidth / encoding.config('characterWidth');\n    } else if (name === Y) {\n      maxLength = layout.cellHeight / encoding.config('characterWidth');\n    }\n\n    def.title = maxLength ? util.truncate(fieldTitle, maxLength) : fieldTitle;\n  }\n\n  if (name === ROW) {\n    def.properties.title = {\n      angle: {value: 0},\n      align: {value: 'right'},\n      baseline: {value: 'middle'},\n      dy: {value: (-layout.height/2) -20}\n    };\n  }\n\n  return def;\n};\n\naxis.labels = {};\n\n/** add custom label for time type and bin */\naxis.labels.scale = function(def, encoding, name) {\n  // time\n  var timeUnit = encoding.field(name).timeUnit;\n  if (encoding.isType(name, T) && timeUnit && (time.hasScale(timeUnit))) {\n    setter(def, ['properties','labels','text','scale'], 'time-'+ timeUnit);\n  }\n  // FIXME bin\n  return def;\n};\n\n/**\n * Determine number format or truncate if maxLabel length is presented.\n */\naxis.labels.format = function (def, name, encoding, stats) {\n  var fieldStats = stats[encoding.field(name).name];\n\n  if (encoding.axis(name).format) {\n    def.format = encoding.axis(name).format;\n  } else if (encoding.isType(name, Q) || fieldStats.type === 'number') {\n    def.format = encoding.numberFormat(fieldStats);\n  } else if (encoding.isType(name, T)) {\n    var timeUnit = encoding.field(name).timeUnit;\n    if (!timeUnit) {\n      def.format = encoding.config('timeFormat');\n    } else if (timeUnit === 'year') {\n      def.format = 'd';\n    }\n  } else if (encoding.isTypes(name, [N, O]) && encoding.axis(name).maxLabelLength) {\n    setter(def,\n      ['properties','labels','text','template'],\n      '{{data | truncate:' + encoding.axis(name).maxLabelLength + '}}'\n      );\n  }\n\n  return def;\n};\n\naxis.labels.rotate = function(def) {\n var align = def.orient ==='top' ? 'left' : 'right';\n setter(def, ['properties','labels', 'angle', 'value'], 270);\n setter(def, ['properties','labels', 'align', 'value'], align);\n setter(def, ['properties','labels', 'baseline', 'value'], 'middle');\n return def;\n};\n\naxis.titleOffset = function (encoding, layout, name) {\n  // return specified value if specified\n  var value = encoding.axis(name).titleOffset;\n  if (value)  return value;\n\n  switch (name) {\n    //FIXME make this adjustable\n    case ROW: return 0;\n    case COL: return 35;\n  }\n  return getter(layout, [name, 'axisTitleOffset']);\n};\n","'use strict';\n\nrequire('../globals');\n\nmodule.exports = binning;\n\nfunction binning(dataTable, encoding, opt) {\n  opt = opt || {};\n\n  if (!dataTable.transform) dataTable.transform = [];\n\n  encoding.forEach(function(field, encType) {\n    if (encoding.bin(encType)) {\n      dataTable.transform.push({\n        type: 'bin',\n        field: encoding.fieldRef(encType, {nofn: true}),\n        output: encoding.fieldRef(encType),\n        maxbins: encoding.bin(encType).maxbins\n      });\n    }\n  });\n\n  return dataTable;\n}\n","'use strict';\n\nvar summary = module.exports = require('datalib/src/stats').summary;\n\nrequire('../globals');\n\nvar compiler = module.exports = {};\n\nvar Encoding = require('../Encoding'),\n  axis = compiler.axis = require('./axis'),\n  filter = compiler.filter = require('./filter'),\n  legend = compiler.legend = require('./legend'),\n  marks = compiler.marks = require('./marks'),\n  scale = compiler.scale = require('./scale');\n\ncompiler.aggregate = require('./aggregate');\ncompiler.bin = require('./bin');\ncompiler.facet = require('./facet');\ncompiler.group = require('./group');\ncompiler.layout = require('./layout');\ncompiler.sort = require('./sort');\ncompiler.stack = require('./stack');\ncompiler.style = require('./style');\ncompiler.subfacet = require('./subfacet');\ncompiler.template = require('./template');\ncompiler.time = require('./time');\n\ncompiler.compile = function (spec, stats, theme) {\n  return compiler.compileEncoding(Encoding.fromSpec(spec, theme), stats);\n};\n\ncompiler.shorthand = function (shorthand, stats, config, theme) {\n  return compiler.compileEncoding(Encoding.fromShorthand(shorthand, config, theme), stats);\n};\n\ncompiler.compileEncoding = function (encoding, stats) {\n  // no need to pass stats if you pass in the data\n  if (!stats && encoding.hasValues()) {\n    stats = summary(encoding.data('values')).reduce(function(s, p) {\n      s[p.field] = p;\n      return s;\n    }, {});\n  }\n\n  var layout = compiler.layout(encoding, stats),\n    spec = compiler.template(encoding, layout, stats);\n\n  // .data related stuff\n  var rawTable = spec.data[0],\n    dataTable = spec.data[1];\n\n  rawTable = filter.addFilters(rawTable, encoding); // modify rawTable\n  spec = compiler.time(spec, encoding);              // modify rawTable, add scales\n  dataTable = compiler.bin(dataTable, encoding);     // modify dataTable\n  var aggResult = compiler.aggregate(dataTable, encoding); // modify dataTable\n  var sorting = compiler.sort(spec.data, encoding, stats); // append new data\n\n  // marks\n  var style = compiler.style(encoding, stats),\n    group = spec.marks[0],\n    mark = marks[encoding.marktype()],\n    mdefs = marks.def(mark, encoding, layout, style, stats),\n    mdef = mdefs[0];  // TODO: remove this dirty hack by refactoring the whole flow\n\n  for (var i = 0; i < mdefs.length; i++) {\n    group.marks.push(mdefs[i]);\n  }\n\n  var lineType = marks[encoding.marktype()].line;\n\n  // handle subfacets\n\n  var details = aggResult.details,\n    hasDetails = details && details.length > 0,\n    stack = hasDetails && compiler.stack(spec.data, encoding, mdef, aggResult.facets); // modify spec.data, mdef.{from,properties}\n\n  if (hasDetails && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    compiler.subfacet(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  //TODO(kanitw): have some config to turn off auto-sort for line (for line chart that encodes temporal information)\n  if (lineType) {\n    var f = (encoding.isMeasure(X) && encoding.isDimension(Y)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    // TODO: why - ?\n    mdef.from.transform = [{type: 'sort', by: '-' + encoding.fieldRef(f)}];\n  }\n\n  // Small Multiples\n  if (encoding.has(ROW) || encoding.has(COL)) {\n    spec = compiler.facet(group, encoding, layout, style, sorting, spec, mdef, stack, stats);\n    spec.legends = legend.defs(encoding);\n  } else {\n    group.scales = scale.defs(scale.names(mdef.properties.update), encoding, layout, stats, style, sorting, {stack: stack});\n    group.axes = axis.defs(axis.names(mdef.properties.update), encoding, layout, stats);\n    group.legends = legend.defs(encoding);\n  }\n\n  filter.filterLessThanZero(dataTable, encoding);\n\n  return spec;\n};\n\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util');\n\nvar axis = require('./axis'),\n  groupdef = require('./group').def,\n  scale = require('./scale');\n\nmodule.exports = faceting;\n\nfunction faceting(group, encoding, layout, style, sorting, spec, mdef, stack, stats) {\n  var enter = group.properties.enter;\n  var facetKeys = [], cellAxes = [], from, axesGrp;\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  enter.fill = {value: encoding.config('cellBackgroundColor')};\n\n  //move \"from\" to cell level and add facet transform\n  group.from = {data: group.marks[0].from.data};\n\n  // Hack, this needs to be refactored\n  for (var i = 0; i < group.marks.length; i++) {\n    var mark = group.marks[i];\n    if (mark.from.transform) {\n      delete mark.from.data; //need to keep transform for subfacetting case\n    } else {\n      delete mark.from;\n    }\n  }\n\n  if (hasRow) {\n    if (!encoding.isDimension(ROW)) {\n      util.error('Row encoding should be ordinal.');\n    }\n    enter.y = {scale: ROW, field: 'keys.' + facetKeys.length};\n    enter.height = {'value': layout.cellHeight}; // HACK\n\n    facetKeys.push(encoding.fieldRef(ROW));\n\n    if (hasCol) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.fieldRef(COL)]});\n    }\n\n    axesGrp = groupdef('x-axes', {\n        axes: encoding.has(X) ? axis.defs(['x'], encoding, layout, stats) : undefined,\n        x: hasCol ? {scale: COL, field: 'keys.0'} : {value: 0},\n        width: hasCol && {'value': layout.cellWidth}, //HACK?\n        from: from\n      });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['row'], encoding, layout, stats));\n  } else { // doesn't have row\n    if (encoding.has(X)) {\n      //keep x axis in the cell\n      cellAxes.push.apply(cellAxes, axis.defs(['x'], encoding, layout, stats));\n    }\n  }\n\n  if (hasCol) {\n    if (!encoding.isDimension(COL)) {\n      util.error('Col encoding should be ordinal.');\n    }\n    enter.x = {scale: COL, field: 'keys.' + facetKeys.length};\n    enter.width = {'value': layout.cellWidth}; // HACK\n\n    facetKeys.push(encoding.fieldRef(COL));\n\n    if (hasRow) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.fieldRef(ROW)]});\n    }\n\n    axesGrp = groupdef('y-axes', {\n      axes: encoding.has(Y) ? axis.defs(['y'], encoding, layout, stats) : undefined,\n      y: hasRow && {scale: ROW, field: 'keys.0'},\n      x: hasRow && {value: 0},\n      height: hasRow && {'value': layout.cellHeight}, //HACK?\n      from: from\n    });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['col'], encoding, layout, stats));\n  } else { // doesn't have col\n    if (encoding.has(Y)) {\n      cellAxes.push.apply(cellAxes, axis.defs(['y'], encoding, layout, stats));\n    }\n  }\n\n  // assuming equal cellWidth here\n  // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n  spec.scales = (spec.scales || []).concat(scale.defs(\n    scale.names(enter).concat(scale.names(mdef.properties.update)),\n    encoding,\n    layout,\n    stats,\n    style,\n    sorting,\n    {stack: stack, facet: true}\n  )); // row/col scales + cell scales\n\n  if (cellAxes.length > 0) {\n    group.axes = cellAxes;\n  }\n\n  // add facet transform\n  var trans = (group.from.transform || (group.from.transform = []));\n  trans.unshift({type: 'facet', keys: facetKeys});\n\n  return spec;\n}\n","'use strict';\n\nrequire('../globals');\n\nvar filter = module.exports = {};\n\nvar BINARY = {\n  '>':  true,\n  '>=': true,\n  '=':  true,\n  '!=': true,\n  '<':  true,\n  '<=': true\n};\n\nfilter.addFilters = function(rawTable, encoding) {\n  var filters = encoding.filter();  // apply filters to raw data before aggregation\n\n  if (!rawTable.transform)\n    rawTable.transform = [];\n\n  // add custom filters\n  for (var i=0, l=filters.length; i<l; i++) {\n    var filter = filters[i];\n\n    var condition = '';\n    var operator = filter.operator;\n    var operands = filter.operands;\n\n    var d = 'd.' + (encoding._vega2 ? '' : 'data.');\n\n    if (BINARY[operator]) {\n      // expects a field and a value\n      if (operator === '=') {\n        operator = '==';\n      }\n\n      var op1 = operands[0];\n      var op2 = operands[1];\n      condition = d + op1 + operator + op2;\n    } else if (operator === 'notNull') {\n      // expects a number of fields\n      for (var j=0; j<operands.length; j++) {\n        condition += d + operands[j] + '!==null';\n        if (j < operands.length - 1) {\n          condition += ' && ';\n        }\n      }\n    } else {\n      console.warn('Unsupported operator: ', operator);\n    }\n\n    rawTable.transform.push({\n      type: 'filter',\n      test: condition\n    });\n  }\n\n  return rawTable;\n};\n\n// remove less than 0 values if we use log function\nfilter.filterLessThanZero = function(dataTable, encoding) {\n  encoding.forEach(function(field, encType) {\n    if (encoding.scale(encType).type === 'log') {\n      dataTable.transform.push({\n        type: 'filter',\n        test: 'd.' + encoding.fieldRef(encType) + '>0'\n      });\n    }\n  });\n};\n","'use strict';\n\nmodule.exports = {\n  def: groupdef\n};\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: 'group',\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: 'width'},\n        height: opt.height || {group: 'height'}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  time = require('./time'),\n  d3_format = require('d3-format');\n\nmodule.exports = vllayout;\n\nfunction vllayout(encoding, stats) {\n  var layout = box(encoding, stats);\n  layout = offset(encoding, stats, layout);\n  return layout;\n}\n\n/*\n  HACK to set chart size\n  NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  One solution is to update Vega to support auto-sizing\n  In the meantime, auto-padding (mostly) does the trick\n */\nfunction box(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y),\n      marktype = encoding.marktype();\n\n  // FIXME/HACK we need to take filter into account\n  var xCardinality = hasX && encoding.isDimension(X) ? encoding.cardinality(X, stats) : 1,\n    yCardinality = hasY && encoding.isDimension(Y) ? encoding.cardinality(Y, stats) : 1;\n\n  var useSmallBand = xCardinality > encoding.config('largeBandMaxCardinality') ||\n    yCardinality > encoding.config('largeBandMaxCardinality');\n\n  var cellWidth, cellHeight, cellPadding = encoding.config('cellPadding');\n\n  // set cellWidth\n  if (hasX) {\n    if (encoding.isOrdinalScale(X)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellWidth = (xCardinality + encoding.field(X).band.padding) * encoding.bandSize(X, useSmallBand);\n    } else {\n      cellWidth = hasCol || hasRow ? encoding.field(COL).width :  encoding.config('singleWidth');\n    }\n  } else {\n    if (marktype === TEXT) {\n      cellWidth = encoding.config('textCellWidth');\n    } else {\n      cellWidth = encoding.bandSize(X);\n    }\n  }\n\n  // set cellHeight\n  if (hasY) {\n    if (encoding.isOrdinalScale(Y)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellHeight = (yCardinality + encoding.field(Y).band.padding) * encoding.bandSize(Y, useSmallBand);\n    } else {\n      cellHeight = hasCol || hasRow ? encoding.field(ROW).height :  encoding.config('singleHeight');\n    }\n  } else {\n    cellHeight = encoding.bandSize(Y);\n  }\n\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n\n  var width = cellWidth, height = cellHeight;\n  if (hasCol) {\n    var colCardinality = encoding.cardinality(COL, stats);\n    width = cellWidth * ((1 + cellPadding) * (colCardinality - 1) + 1);\n  }\n  if (hasRow) {\n    var rowCardinality =  encoding.cardinality(ROW, stats);\n    height = cellHeight * ((1 + cellPadding) * (rowCardinality - 1) + 1);\n  }\n\n  return {\n    // width and height of the whole cell\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    cellPadding: cellPadding,\n    // width and height of the chart\n    width: width,\n    height: height,\n    // information about x and y, such as band size\n    x: {useSmallBand: useSmallBand},\n    y: {useSmallBand: useSmallBand}\n  };\n}\n\n\n// FIXME fieldStats.max isn't always the longest\nfunction getMaxNumberLength(encoding, et, fieldStats) {\n  var format = encoding.numberFormat(et, fieldStats);\n\n  return d3_format.format(format)(fieldStats.max).length;\n}\n\nfunction getMaxLength(encoding, stats, et) {\n  var field = encoding.field(et),\n    fieldStats = stats[field.name];\n\n  if (field.bin) {\n    // TODO once bin support range, need to update this\n    return getMaxNumberLength(encoding, et, fieldStats);\n  } if (encoding.isType(et, Q)) {\n    return getMaxNumberLength(encoding, et, fieldStats);\n  } else if (encoding.isType(et, T)) {\n    return time.maxLength(encoding.field(et).timeUnit, encoding);\n  } else if (encoding.isTypes(et, [N, O])) {\n    if(fieldStats.type === 'number') {\n      return getMaxNumberLength(encoding, et, fieldStats);\n    } else {\n      return Math.min(fieldStats.max, encoding.axis(et).maxLabelLength || Infinity);\n    }\n  }\n}\n\nfunction offset(encoding, stats, layout) {\n  [X, Y].forEach(function (et) {\n    // TODO(kanitw): Jul 19, 2015 - create a set of visual test for extraOffset\n    var extraOffset = et === X ? 20 : 22,\n      maxLength;\n    if (encoding.isDimension(et) || encoding.isType(et, T)) {\n      maxLength = getMaxLength(encoding, stats, et);\n    } else if (\n      // TODO once we have #512 (allow using inferred type)\n      // Need to adjust condition here.\n      encoding.isType(et, Q) ||\n      encoding.aggregate(et) === 'count'\n    ) {\n      if (\n        et===Y\n        // || (et===X && false)\n        // FIXME determine when X would rotate, but should move this to axis.js first #506\n      ) {\n        maxLength = getMaxLength(encoding, stats, et);\n      }\n    } else {\n      // nothing\n    }\n\n    if (maxLength) {\n      setter(layout,[et, 'axisTitleOffset'], encoding.config('characterWidth') *  maxLength + extraOffset);\n    } else {\n      // if no max length (no rotation case), use maxLength = 3\n      setter(layout,[et, 'axisTitleOffset'], encoding.config('characterWidth') * 3 + extraOffset);\n    }\n\n  });\n  return layout;\n}\n","'use strict';\n\nrequire('../globals');\n\nvar time = require('./time');\n\nvar legend = module.exports = {};\n\nlegend.defs = function(encoding) {\n  var defs = [];\n  // TODO: support alpha\n\n  if (encoding.has(COLOR) && encoding.field(COLOR).legend) {\n    defs.push(legend.def(COLOR, encoding, {\n      fill: COLOR,\n      orient: 'right'\n    }));\n  }\n\n  if (encoding.has(SIZE) && encoding.field(SIZE).legend) {\n    defs.push(legend.def(SIZE, encoding, {\n      size: SIZE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  if (encoding.has(SHAPE) && encoding.field(SHAPE).legend) {\n    if (defs.length === 2) {\n      // TODO: fix this\n      console.error('Vega-lite currently only supports two legends');\n      return defs;\n    }\n    defs.push(legend.def(SHAPE, encoding, {\n      shape: SHAPE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  return defs;\n};\n\nlegend.def = function(name, encoding, props) {\n  var def = props,\n    timeUnit = encoding.field(name).timeUnit;\n\n  def.title = encoding.fieldTitle(name);\n\n  if (encoding.isType(name, T) &&\n    timeUnit &&\n    time.hasScale(timeUnit)\n  ) {\n    var properties = def.properties = def.properties || {},\n      labels = properties.labels = properties.labels || {},\n      text = labels.text = labels.text || {};\n\n    text.scale = 'time-'+ timeUnit;\n  }\n\n  return def;\n};\n","'use strict';\n\nrequire('../globals');\n\nvar marks = module.exports = {};\n\nmarks.def = function(mark, encoding, layout, style, stats) {\n  var defs = [];\n\n  // to add a background to text, we need to add it before the text\n  if (encoding.marktype() === TEXT && encoding.has(COLOR)) {\n    var bg = {\n      x: {value: 0},\n      y: {value: 0},\n      x2: {value: layout.cellWidth},\n      y2: {value: layout.cellHeight},\n      fill: {scale: COLOR, field: encoding.fieldRef(COLOR)}\n    };\n    defs.push({\n      type: 'rect',\n      from: {data: TABLE},\n      properties: {enter: bg, update: bg}\n    });\n  }\n\n  // add the mark def for the main thing\n  var p = mark.prop(encoding, layout, style, stats);\n  defs.push({\n    type: mark.type,\n    from: {data: TABLE},\n    properties: {enter: p, update: p}\n  });\n\n  return defs;\n};\n\nmarks.bar = {\n  type: 'rect',\n  stack: true,\n  prop: bar_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1}\n};\n\nmarks.line = {\n  type: 'line',\n  line: true,\n  prop: line_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, detail:1}\n};\n\nmarks.area = {\n  type: 'area',\n  stack: true,\n  line: true,\n  requiredEncoding: ['x', 'y'],\n  prop: area_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1}\n};\n\nmarks.tick = {\n  type: 'rect',\n  prop: tick_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, detail: 1}\n};\n\nmarks.circle = {\n  type: 'symbol',\n  prop: filled_point_props('circle'),\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, detail: 1}\n};\n\nmarks.square = {\n  type: 'symbol',\n  prop: filled_point_props('square'),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: 'symbol',\n  prop: point_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, shape: 1, detail: 1}\n};\n\nmarks.text = {\n  type: 'text',\n  prop: text_props,\n  requiredEncoding: ['text'],\n  supportedEncoding: {row: 1, col: 1, size: 1, color: 1, text: 1}\n};\n\nfunction bar_props(e, layout, style) {\n  // jshint unused:false\n\n  var p = {};\n\n  // x's and width\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (!e.has(Y) || e.isDimension(Y)) {\n      p.x2 = {value: 0};\n    }\n  } else {\n    if (e.has(X)) { // is ordinal\n       p.xc = {scale: X, field: e.fieldRef(X)};\n    } else {\n       p.x = {value: 0, offset: e.config('singleBarOffset')};\n    }\n  }\n\n  // width\n  if (!p.x2) {\n    if (!e.has(X) || e.isOrdinalScale(X)) { // no X or X is ordinal\n      if (e.has(SIZE)) {\n        p.width = {scale: SIZE, field: e.fieldRef(SIZE)};\n      } else {\n        p.width = {\n          value: e.bandSize(X, layout.x.useSmallBand),\n          offset: -1\n        };\n      }\n    } else { // X is Quant or Time Scale\n      p.width = {value: 2};\n    }\n  }\n\n  // y's & height\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    p.y2 = {group: 'height'};\n  } else {\n    if (e.has(Y)) { // is ordinal\n      p.yc = {scale: Y, field: e.fieldRef(Y)};\n    } else {\n      p.y2 = {group: 'height', offset: -e.config('singleBarOffset')};\n    }\n\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.fieldRef(SIZE)};\n    } else {\n      p.height = {\n        value: e.bandSize(Y, layout.y.useSmallBand),\n        offset: -1\n      };\n    }\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // opacity\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction point_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.fieldRef(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.value(SIZE)};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.fieldRef(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.value(SHAPE)};\n  }\n\n  // stroke\n  if (e.field(SHAPE).filled) {\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n  } else {\n    if (e.has(COLOR)) {\n      p.stroke = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.stroke = {value: e.value(COLOR)};\n    }\n    p.strokeWidth = {value: e.config('strokeWidth')};\n  }\n\n  // opacity\n  var opacity = e.field(COLOR).opacity  || style.opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction line_props(e,layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction area_props(e, layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: 'horizontal'};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else {\n    p.y = {group: 'height'};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction tick_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (e.isDimension(X)) {\n      p.x.offset = -e.bandSize(X, layout.x.useSmallBand) / 3;\n    }\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    if (e.isDimension(Y)) {\n      p.y.offset = -e.bandSize(Y, layout.y.useSmallBand) / 3;\n    }\n  } else if (!e.has(Y)) {\n    p.y = {value: 0};\n  }\n\n  // width\n  if (!e.has(X) || e.isDimension(X)) {\n    p.width = {value: e.bandSize(X, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.width = {value: 1};\n  }\n\n  // height\n  if (!e.has(Y) || e.isDimension(Y)) {\n    p.height = {value: e.bandSize(Y, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.height = {value: 1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity  || style.opacity;\n  if(opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, layout, style) {\n    var p = {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.fieldRef(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.fieldRef(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.fieldRef(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.value(SIZE)};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n\n    var opacity = e.field(COLOR).opacity  || style.opacity;\n    if(opacity) p.opacity = {value: opacity};\n\n    return p;\n  };\n}\n\nfunction text_props(e, layout, style, stats) {\n  var p = {},\n    field = e.field(TEXT);\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    if (e.has(TEXT) && e.isType(TEXT, Q)) {\n      p.x = {value: layout.cellWidth-5};\n    } else {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.fieldRef(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.fontSize = {value: field.font.size};\n  }\n\n  // fill\n  // color should be set to background\n  p.fill = {value: field.text.color};\n\n  var opacity = e.field(COLOR).opacity  || style.opacity;\n  if(opacity) p.opacity = {value: opacity};\n\n  // text\n  if (e.has(TEXT)) {\n    if (e.isType(TEXT, Q)) {\n      var fieldStats = stats[e.fieldName(name)],\n        numberFormat = field.format || e.numberFormat(fieldStats);\n\n      p.text = {template: '{{' + e.fieldRef(TEXT) + ' | number:\\'' +\n        numberFormat +'\\'}}'};\n      p.align = {value: field.align};\n    } else {\n      p.text = {field: e.fieldRef(TEXT)};\n    }\n  } else {\n    p.text = {value: field.placeholder};\n  }\n\n  p.font = {value: field.font.family};\n  p.fontWeight = {value: field.font.weight};\n  p.fontStyle = {value: field.font.style};\n  p.baseline = {value: field.baseline};\n\n  return p;\n}\n","'use strict';\nrequire('../globals');\nvar util = require('../util'),\n  time = require('./time'),\n  colorbrewer = require('colorbrewer'),\n  interpolateLab = require('d3-color').interpolateLab,\n  schema = require('../schema/schema');\n\nvar scale = module.exports = {};\n\nscale.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\nscale.defs = function(names, encoding, layout, stats, style, sorting, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale.type(name, encoding),\n      domain: scale.domain(name, encoding, stats, sorting, opt)\n    };\n\n    s.sort = scale.sort(s, encoding, name) || undefined;\n\n    scale.range(s, encoding, layout, stats, opt);\n\n    return (a.push(s), a);\n  }, []);\n};\n\nscale.sort = function(s, encoding, name) {\n  return s.type === 'ordinal' && (\n    !!encoding.bin(name) ||\n    encoding.sort(name).length === 0\n  );\n};\n\nscale.type = function(name, encoding) {\n\n  switch (encoding.type(name)) {\n    case N: //fall through\n    case O: return 'ordinal';\n    case T:\n      var timeUnit = encoding.field(name).timeUnit;\n      return timeUnit ? time.scale.type(timeUnit, name) : 'time';\n    case Q:\n      if (encoding.bin(name)) {\n        return name === COLOR ? 'linear' : 'ordinal';\n      }\n      return encoding.scale(name).type;\n  }\n};\n\nscale.domain = function (name, encoding, stats, sorting, opt) {\n  var field = encoding.field(name);\n\n  if (encoding.isType(name, T)) {\n    var range = time.scale.domain(field.timeUnit, name);\n    if(range) return range;\n  }\n\n  if (field.bin) {\n    // TODO(kanitw): this must be changed in vg2\n    var fieldStat = stats[field.name],\n      bins = util.getbins(fieldStat, field.bin.maxbins || schema.MAXBINS_DEFAULT),\n      numbins = (bins.stop - bins.start) / bins.step;\n    return util.range(numbins).map(function(i) {\n      return bins.start + bins.step * i;\n    });\n  }\n\n  if (name == opt.stack) {\n    return {\n      data: STACKED,\n      field: encoding.fieldRef(name, {\n        data: !encoding._vega2,\n        prefn: (opt.facet ? 'max_' : '') + 'sum_'\n      })\n    };\n  }\n  var aggregate = encoding.aggregate(name),\n    timeUnit = field.timeUnit,\n    scaleUseRawDomain = encoding.scale(name).useRawDomain,\n    useRawDomain = scaleUseRawDomain !== undefined ?\n      scaleUseRawDomain : encoding.config('useRawDomain'),\n    notCountOrSum = !aggregate || (aggregate !=='count' && aggregate !== 'sum');\n\n  if ( useRawDomain && notCountOrSum && (\n      // Q always uses non-ordinal scale except when it's binned and thus uses ordinal scale.\n      (encoding.isType(name, Q) && !field.bin) ||\n      // T uses non-ordinal scale when there's no unit or when the unit is not ordinal.\n      (encoding.isType(name, T) && (!timeUnit || !time.isOrdinalFn(timeUnit)))\n    )\n  ) {\n    return {data: RAW, field: encoding.fieldRef(name, {nofn: !timeUnit})};\n  }\n\n  return {data: sorting.getDataset(name), field: encoding.fieldRef(name)};\n};\n\n\nscale.range = function (s, encoding, layout, stats) {\n  var spec = encoding.scale(s.name),\n    field = encoding.field(s.name),\n    timeUnit = field.timeUnit;\n\n  switch (s.name) {\n    case X:\n      s.range = layout.cellWidth ? [0, layout.cellWidth] : 'width';\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(X, layout.x.useSmallBand);\n      } else {\n        if (encoding.isType(s.name,T) && timeUnit === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n      s.round = true;\n      if (s.type === 'time') {\n        s.nice = timeUnit || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (s.type === 'ordinal') {\n        s.range = layout.cellHeight ?\n          (field.bin ? [layout.cellHeight, 0] : [0, layout.cellHeight]) :\n          'height';\n        s.bandWidth = encoding.bandSize(Y, layout.y.useSmallBand);\n      } else {\n        s.range = layout.cellHeight ? [layout.cellHeight, 0] : 'height';\n        if (encoding.isType(s.name,T) && timeUnit === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n\n      s.round = true;\n\n      if (s.type === 'time') {\n        s.nice = timeUnit || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case ROW: // support only ordinal\n      s.bandWidth = layout.cellHeight;\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL: // support only ordinal\n      s.bandWidth = layout.cellWidth;\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is('bar')) {\n        // FIXME this is definitely incorrect\n        // but let's fix it later since bar size is a bad encoding anyway\n        s.range = [3, Math.max(encoding.bandSize(X), encoding.bandSize(Y))];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else { //point\n        var bandSize = Math.min(encoding.bandSize(X), encoding.bandSize(Y)) - 1;\n        s.range = [10, 0.8 * bandSize*bandSize];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = 'shapes';\n      break;\n    case COLOR:\n      s.range = scale.color(s, encoding, stats);\n      break;\n    default:\n      throw new Error('Unknown encoding name: '+ s.name);\n  }\n\n  switch (s.name) {\n    case ROW:\n    case COL:\n      s.padding = encoding.config('cellPadding');\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (s.type === 'ordinal') { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.field(s.name).band.padding;\n      }\n  }\n};\n\nscale.color = function(s, encoding, stats) {\n  var colorScale = encoding.scale(COLOR),\n    range = colorScale.range,\n    cardinality = encoding.cardinality(COLOR, stats),\n    type = encoding.type(COLOR);\n\n  if (range === undefined) {\n    var ordinalPalette = colorScale.ordinalPalette;\n    if (s.type === 'ordinal') {\n      if (type === N) {\n        // use categorical color scale\n        if (cardinality <= 10) {\n          range = colorScale.c10palette;\n        } else {\n          range = colorScale.c20palette;\n        }\n      } else {\n        if (cardinality <= 2) {\n          range = [colorbrewer[ordinalPalette][3][0], colorbrewer[ordinalPalette][3][2]];\n        } else {\n          range = ordinalPalette;\n        }\n      }\n    } else { //time or quantitative\n      var palette = colorbrewer[ordinalPalette][9];\n      range = [palette[0], palette[8]];\n      s.zero = false;\n    }\n  }\n  return scale.color.palette(range, cardinality, type);\n};\n\nscale.color.palette = function(range, cardinality, type) {\n  switch (range) {\n    case 'category10k':\n      // tableau's category 10, ordered by perceptual kernel study results\n      // https://github.com/uwdata/perceptual-kernels\n      return ['#2ca02c', '#e377c2', '#7f7f7f', '#17becf', '#8c564b', '#d62728', '#bcbd22', '#9467bd', '#ff7f0e', '#1f77b4'];\n\n    // d3/tableau category10/20/20b/20c\n    case 'category10':\n      return ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];\n\n    case 'category20':\n      return ['#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'];\n\n    case 'category20b':\n      return ['#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39', '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b', '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'];\n\n    case 'category20c':\n      return ['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#e6550d', '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354', '#74c476', '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc', '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9'];\n  }\n\n  if (range in colorbrewer) {\n    var palette = colorbrewer[range],\n      ps = 5;\n\n    // if cardinality pre-defined, use it.\n    if (cardinality in palette) return palette[cardinality];\n\n    // if not, use the highest cardinality one for nominal\n    if (type === N) {\n      return palette[Math.max.apply(null, util.keys(palette))];\n    }\n\n    // otherwise, interpolate\n    return scale.color.interpolate(palette[ps][0], palette[ps][ps-1], cardinality);\n  }\n\n  return range;\n};\n\nscale.color.interpolate = function (start, end, cardinality) {\n  var interpolator = interpolateLab(start, end);\n  return util.range(cardinality).map(function(i) { return interpolator(i*1.0/(cardinality-1)); });\n};\n","'use strict';\n\nrequire('../globals');\n\nvar vlfield = require('../field');\n\nmodule.exports = addSortTransforms;\n\n// adds new transforms that produce sorted fields\nfunction addSortTransforms(data, encoding, stats, opt) {\n  // jshint unused:false\n\n  var datasetMapping = {};\n  var counter = 0;\n\n  encoding.forEach(function(field, encType) {\n    var sortBy = encoding.sort(encType, stats);\n    if (sortBy.length > 0) {\n      var fields = sortBy.map(function(d) {\n        return {\n          op: d.aggregate,\n          field: vlfield.fieldRef(d, {nofn: true, data: !encoding._vega2})\n        };\n      });\n\n      var byClause = sortBy.map(function(d) {\n        var reverse = (d.reverse ? '-' : '');\n        return reverse + vlfield.fieldRef(d, {data: !encoding._vega2});\n      });\n\n      var dataName = 'sorted' + counter++;\n\n      var transforms = [\n        {\n          type: 'aggregate',\n          groupby: [ encoding.fieldRef(encType) ],\n          fields: fields\n        },\n        {\n          type: 'sort',\n          by: byClause\n        }\n      ];\n\n      data.push({\n        name: dataName,\n        source: RAW,\n        transform: transforms\n      });\n\n      datasetMapping[encType] = dataName;\n    }\n  });\n\n  return {\n    getDataset: function(encType) {\n      var data = datasetMapping[encType];\n      if (!data) {\n        return TABLE;\n      }\n      return data;\n    }\n  };\n}\n\n","'use strict';\n\nrequire('../globals');\n\nvar  marks = require('./marks');\n\nmodule.exports = stacking;\n\nfunction stacking(data, encoding, mdef, facets) {\n  if (!marks[encoding.marktype()].stack) return false;\n\n  // TODO: add || encoding.has(LOD) here once LOD is implemented\n  if (!encoding.has(COLOR)) return false;\n\n  var dim=null, val=null, idx =null,\n    isXMeasure = encoding.isMeasure(X),\n    isYMeasure = encoding.isMeasure(Y);\n\n  if (isXMeasure && !isYMeasure) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  } else if (isYMeasure && !isXMeasure) {\n    dim = X;\n    val = Y;\n    idx = 1;\n  } else {\n    return null; // no stack encoding\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: TABLE,\n    transform: [{\n      type: 'aggregate',\n      groupby: [encoding.fieldRef(dim)].concat(facets), // dim and other facets\n      fields: [{op: 'sum', field: encoding.fieldRef(val)}] // TODO check if field with aggregate is correct?\n    }]\n  };\n\n  if (facets && facets.length > 0) {\n    stacked.transform.push({ //calculate max for each facet\n      type: 'aggregate',\n      groupby: facets,\n      fields: [{\n        op: 'max',\n        field: encoding.fieldName(val, {fn: 'sum'})\n      }]\n    });\n  }\n\n  data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: 'stack',\n    point: encoding.fieldRef(dim),\n    height: encoding.fieldRef(val),\n    output: {y1: val, y0: val + '2'}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val + '2'] = mdef.properties.enter[val + '2'] = {scale: val, field: val + '2'};\n\n  return val; //return stack encoding\n}\n","'use strict';\n\nrequire('../globals');\n\nvar vlfield = require('../field');\n\nmodule.exports = function(encoding, stats) {\n  return {\n    opacity: estimateOpacity(encoding, stats),\n  };\n};\n\nfunction estimateOpacity(encoding,stats) {\n  if (!stats) {\n    return 1;\n  }\n\n  var numPoints = 0;\n\n  if (encoding.isAggregate()) { // aggregate plot\n    numPoints = 1;\n\n    //  get number of points in each \"cell\"\n    //  by calculating product of cardinality\n    //  for each non faceting and non-ordinal X / Y fields\n    //  note that ordinal x,y are not include since we can\n    //  consider that ordinal x are subdividing the cell into subcells anyway\n    encoding.forEach(function(field, encType) {\n\n      if (encType !== ROW && encType !== COL &&\n          !((encType === X || encType === Y) &&\n          vlfield.isOrdinalScale(field))\n        ) {\n        numPoints *= encoding.cardinality(encType, stats);\n      }\n    });\n\n  } else { // raw plot\n    numPoints = stats.count;\n\n    // small multiples divide number of points\n    var numMultiples = 1;\n    if (encoding.has(ROW)) {\n      numMultiples *= encoding.cardinality(ROW, stats);\n    }\n    if (encoding.has(COL)) {\n      numMultiples *= encoding.cardinality(COL, stats);\n    }\n    numPoints /= numMultiples;\n  }\n\n  var opacity = 0;\n  if (numPoints < 20) {\n    opacity = 1;\n  } else if (numPoints < 200) {\n    opacity = 0.7;\n  } else if (numPoints < 1000 || encoding.is('tick')) {\n    opacity = 0.6;\n  } else {\n    opacity = 0.3;\n  }\n\n  return opacity;\n}\n\n","'use strict';\n\nrequire('../globals');\n\nvar groupdef = require('./group').def;\n\nmodule.exports = subfaceting;\n\nfunction subfaceting(group, mdef, details, stack, encoding) {\n  var m = group.marks,\n    g = groupdef('subfacet', {marks: m});\n\n  group.marks = [g];\n  g.from = mdef.from;\n  delete mdef.from;\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: 'facet', keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: 'sort', by: encoding.fieldRef(COLOR)});\n  }\n}\n","'use strict';\n\nrequire('../globals');\n\nvar groupdef = require('./group').def,\n  vlfield = require('../field');\n\nmodule.exports = template;\n\nfunction template(encoding, layout, stats) {\n  // jshint unused:false\n\n  var data = {name: RAW, format: {}},\n    table = {name: TABLE, source: RAW},\n    dataUrl = encoding.data('url'),\n    dataType = encoding.data('formatType'),\n    values = encoding.data('values');\n\n  if (encoding.hasValues()) {\n    data.values = values;\n  } else {\n    data.url = dataUrl;\n    data.format.type = dataType;\n  }\n\n  encoding.forEach(function(field, encType) {\n    var name;\n    if (field.type == T) {\n      data.format.parse = data.format.parse || {};\n      data.format.parse[field.name] = 'date';\n    } else if (field.type == Q) {\n      data.format.parse = data.format.parse || {};\n      if (vlfield.isCount(field)) {\n        name = 'count';\n      } else {\n        name = field.name;\n      }\n      data.format.parse[name] = 'number';\n    }\n  });\n\n  return {\n    width: layout.width,\n    height: layout.height,\n    padding: 'auto',\n    data: [data, table],\n    marks: [groupdef('cell', {\n      width: layout.cellWidth ? {value: layout.cellWidth} : undefined,\n      height: layout.cellHeight ? {value: layout.cellHeight} : undefined\n    })]\n  };\n}\n","'use strict';\n\nvar util = require('../util'),\n  d3_time_format = require('d3-time-format');\n\nmodule.exports = time;\n\nvar LONG_DATE = new Date(2014, 8, 17);\n\nfunction time(spec, encoding) { // FIXME refactor to reduce side effect #276\n  // jshint unused:false\n  var timeFields = {}, timeUnits = {};\n\n  // find unique formula transformation and bin function\n  encoding.forEach(function(field, encType) {\n    if (field.type === T && field.timeUnit) {\n      timeFields[encoding.fieldRef(encType)] = {\n        field: field,\n        encType: encType\n      };\n      timeUnits[field.timeUnit] = true;\n    }\n  });\n\n  // add formula transform\n  var data = spec.data[0],\n    transform = data.transform = data.transform || [];\n\n  for (var f in timeFields) {\n    var tf = timeFields[f];\n    time.transform(transform, encoding, tf.encType, tf.field);\n  }\n\n  // add scales\n  var scales = spec.scales = spec.scales || [];\n  for (var timeUnit in timeUnits) {\n    var scale = time.scale.def(timeUnit, encoding);\n    if (scale) scales.push(scale);\n  }\n  return spec;\n}\n\ntime.cardinality = function(field, stats, filterNull, type) {\n  var timeUnit = field.timeUnit;\n  switch (timeUnit) {\n    case 'seconds': return 60;\n    case 'minutes': return 60;\n    case 'hours': return 24;\n    case 'day': return 7;\n    case 'date': return 31;\n    case 'month': return 12;\n    case 'year':\n      var stat = stats[field.name],\n        yearstat = stats['year_'+field.name];\n\n      if (!yearstat) { return null; }\n\n      return yearstat.distinct -\n        (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n  }\n\n  return null;\n};\n\ntime.maxLength = function(timeUnit, encoding) {\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'date':\n      return 2;\n    case 'month':\n    case 'day':\n      var range = time.range(timeUnit, encoding);\n      if (range) {\n        // return the longest name in the range\n        return Math.max.apply(null, range.map(function(r) {return r.length;}));\n      }\n      return 2;\n    case 'year':\n      return 4; //'1998'\n  }\n  // no time unit\n  var timeFormat = encoding.config('timeFormat');\n  return d3_time_format.utcFormat(timeFormat)(LONG_DATE).length;\n};\n\nfunction fieldFn(func, field) {\n  return 'utc' + func + '(d.data.'+ field.name +')';\n}\n\n/**\n * @return {String} date binning formula of the given field\n */\ntime.formula = function(field) {\n  return fieldFn(field.timeUnit, field);\n};\n\n/** add formula transforms to data */\ntime.transform = function(transform, encoding, encType, field) {\n  transform.push({\n    type: 'formula',\n    field: encoding.fieldRef(encType),\n    expr: time.formula(field)\n  });\n};\n\ntime.range = function(timeUnit, encoding) {\n  var labelLength = encoding.config('timeScaleLabelLength'),\n    scaleLabel;\n  switch (timeUnit) {\n    case 'day':\n      scaleLabel = encoding.config('dayScaleLabel');\n      break;\n    case 'month':\n      scaleLabel = encoding.config('monthScaleLabel');\n      break;\n  }\n  if (scaleLabel) {\n    return labelLength ? scaleLabel.map(\n        function(s) { return s.substr(0, labelLength);}\n      ) : scaleLabel;\n  }\n  return;\n};\n\n\ntime.scale = {};\n\n/** append custom time scales for axis label */\ntime.scale.def = function(timeUnit, encoding) {\n  var range = time.range(timeUnit, encoding);\n\n  if (range) {\n    return {\n      name: 'time-'+timeUnit,\n      type: 'ordinal',\n      domain: time.scale.domain(timeUnit),\n      range: range\n    };\n  }\n  return null;\n};\n\ntime.isOrdinalFn = function(timeUnit) {\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'day':\n    case 'date':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\ntime.scale.type = function(timeUnit, name) {\n  if (name === COLOR) {\n    return 'linear'; // time has order, so use interpolated ordinal color scale.\n  }\n\n  return time.isOrdinalFn(timeUnit) || name === COL || name === ROW ? 'ordinal' : 'linear';\n};\n\ntime.scale.domain = function(timeUnit, name) {\n  var isColor = name === COLOR;\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes': return isColor ? [0,59] : util.range(0, 60);\n    case 'hours': return isColor ? [0,23] : util.range(0, 24);\n    case 'day': return isColor ? [0,6] : util.range(0, 7);\n    case 'date': return isColor ? [1,31] : util.range(1, 32);\n    case 'month': return isColor ? [0,11] : util.range(0, 12);\n  }\n  return null;\n};\n\n/** whether a particular time function has custom scale for labels implemented in time.scale */\ntime.hasScale = function(timeUnit) {\n  switch (timeUnit) {\n    case 'day':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n","'use strict';\n\nrequire('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, TEXT, DETAIL];\n\nconsts.shorthand = {\n  delim:  '|',\n  assign: '=',\n  type:   ',',\n  func:   '_'\n};\n","'use strict';\n\nrequire('./globals');\n\nvar stats = require('datalib/src/stats');\n\nvar vldata = module.exports = {};\n\n/** Mapping from datalib's inferred type to Vega-lite's type */\nvldata.types = {\n  'boolean': N,\n  'number': Q,\n  'integer': Q,\n  'date': T,\n  'string': N\n};\n\nvldata.stats = function(data) {\n  var summary = stats.summary(data);\n\n  return summary.reduce(function(s, profile) {\n    s[profile.field] = profile;\n    return s;\n  }, {\n    '*': {\n      max: data.length,\n      min: 0\n    }\n  });\n};","// utility for enc\n\n'use strict';\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  vlfield = require('./field'),\n  util = require('./util'),\n  schema = require('./schema/schema'),\n  encTypes = schema.encTypes;\n\nvar vlenc = module.exports = {};\n\nvlenc.countRetinal = function(enc) {\n  var count = 0;\n  if (enc.color) count++;\n  if (enc.size) count++;\n  if (enc.shape) count++;\n  return count;\n};\n\nvlenc.has = function(enc, encType) {\n  var fieldDef = enc && enc[encType];\n  return fieldDef && fieldDef.name;\n};\n\nvlenc.isAggregate = function(enc) {\n  for (var k in enc) {\n    if (vlenc.has(enc, k) && enc[k].aggregate) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvlenc.forEach = function(enc, f) {\n  var i = 0;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      f(enc[k], k, i++);\n    }\n  });\n};\n\nvlenc.map = function(enc, f) {\n  var arr = [];\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      arr.push(f(enc[k], k, enc));\n    }\n  });\n  return arr;\n};\n\nvlenc.reduce = function(enc, f, init) {\n  var r = init;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      r = f(r, enc[k], k,  enc);\n    }\n  });\n  return r;\n};\n\n/*\n * return key-value pairs of field name and list of fields of that field name\n */\nvlenc.fields = function(enc) {\n  return vlenc.reduce(enc, function (m, field) {\n    var fieldList = m[field.name] = m[field.name] || [],\n      containsType = fieldList.containsType = fieldList.containsType || {};\n\n    if (fieldList.indexOf(field) === -1) {\n      fieldList.push(field);\n      // augment the array with containsType.Q / O / N / T\n      containsType[field.type] = true;\n    }\n    return m;\n  }, {});\n};\n\nvlenc.shorthand = function(enc) {\n  return vlenc.map(enc, function(field, et) {\n    return et + c.assign + vlfield.shorthand(field);\n  }).join(c.delim);\n};\n\nvlenc.fromShorthand = function(shorthand) {\n  var enc = util.isArray(shorthand) ? shorthand : shorthand.split(c.delim);\n  return enc.reduce(function(m, e) {\n    var split = e.split(c.assign),\n        enctype = split[0].trim(),\n        field = split[1];\n\n    m[enctype] = vlfield.fromShorthand(field);\n    return m;\n  }, {});\n};","'use strict';\n\n// utility for field\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compiler/time'),\n  util = require('./util'),\n  schema = require('./schema/schema');\n\nvar vlfield = module.exports = {};\n\n/**\n * @param field\n * @param opt\n *   opt.nofn -- exclude bin, aggregate, timeUnit\n *   opt.data - include 'data.'\n *   opt.fn - replace fn with custom function prefix\n *   opt.prefn - prepend fn with custom function prefix\n\n * @return {[type]}       [description]\n */\nvlfield.fieldRef = function(field, opt) {\n  opt = opt || {};\n\n  var f = (opt.data ? 'data.' : '') + (opt.prefn || ''),\n    nofn = opt.nofn || opt.fn,\n    name = field.name;\n\n  if (vlfield.isCount(field)) {\n    return f + 'count';\n  } else if (!nofn && field.bin) {\n    return f + 'bin_' + name;\n  } else if (!nofn && field.aggregate) {\n    return f + field.aggregate + '_' + name;\n  } else if (!nofn && field.timeUnit) {\n    return f + field.timeUnit + '_' + name;\n  } else if (opt.fn) {\n    return f + opt.fn + '_' + name;\n  } else {\n    return f + name;\n  }\n};\n\nvlfield.shorthand = function(f) {\n  var c = consts.shorthand;\n  return (f.aggregate ? f.aggregate + c.func : '') +\n    (f.timeUnit ? f.timeUnit + c.func : '') +\n    (f.bin ? 'bin' + c.func : '') +\n    (f.name || '') + c.type + f.type;\n};\n\nvlfield.shorthands = function(fields, delim) {\n  delim = delim || c.delim;\n  return fields.map(vlfield.shorthand).join(delim);\n};\n\nvlfield.fromShorthand = function(shorthand) {\n  var split = shorthand.split(c.type), i;\n  var o = {\n    name: split[0].trim(),\n    type: split[1].trim()\n  };\n\n  // check aggregate type\n  for (i in schema.aggregate.enum) {\n    var a = schema.aggregate.enum[i];\n    if (o.name.indexOf(a + '_') === 0) {\n      o.name = o.name.substr(a.length + 1);\n      if (a == 'count' && o.name.length === 0) o.name = '*';\n      o.aggregate = a;\n      break;\n    }\n  }\n\n  // check time timeUnit\n  for (i in schema.timefns) {\n    var tu = schema.timefns[i];\n    if (o.name && o.name.indexOf(tu + '_') === 0) {\n      o.name = o.name.substr(o.length + 1);\n      o.timeUnit = tu;\n      break;\n    }\n  }\n\n  // check bin\n  if (o.name && o.name.indexOf('bin_') === 0) {\n    o.name = o.name.substr(4);\n    o.bin = true;\n  }\n\n  return o;\n};\n\nvar isType = vlfield.isType = function (fieldDef, type) {\n  return fieldDef.type === type;\n};\n\nvar isTypes = vlfield.isTypes = function (fieldDef, types) {\n  for (var t=0; t<types.length; t++) {\n    if(fieldDef.type === types[t]) return true;\n  }\n  return false;\n};\n\n/*\n * Most fields that use ordinal scale are dimensions.\n * However, YEAR(T), YEARMONTH(T) use time scale, not ordinal but are dimensions too.\n */\nvlfield.isOrdinalScale = function(field) {\n  return  isTypes(field, [N, O]) || field.bin ||\n    ( isType(field, T) && field.timeUnit && time.isOrdinalFn(field.timeUnit) );\n};\n\nfunction isDimension(field) {\n  return  isTypes(field, [N, O]) || !!field.bin ||\n    ( isType(field, T) && !!field.timeUnit );\n}\n\n/**\n * For encoding, use encoding.isDimension() to avoid confusion.\n * Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.isDimension = function(field) {\n  return field && isDimension(field);\n};\n\nvlfield.isMeasure = function(field) {\n  return field && !isDimension(field);\n};\n\nvlfield.count = function() {\n  return {name:'*', aggregate: 'count', type: Q, displayName: vlfield.count.displayName};\n};\n\nvlfield.count.displayName = 'Number of Records';\n\nvlfield.isCount = function(field) {\n  return field.aggregate === 'count';\n};\n\n/**\n * For encoding, use encoding.cardinality() to avoid confusion.  Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.cardinality = function(field, stats, filterNull) {\n  // FIXME need to take filter into account\n\n  var stat = stats[field.name];\n  var type = field.type;\n\n  filterNull = filterNull || {};\n\n  if (field.bin) {\n    var bins = util.getbins(stat, field.bin.maxbins || schema.MAXBINS_DEFAULT);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  if (isType(field, T)) {\n    var cardinality = time.cardinality(field, stats, filterNull, type);\n    if(cardinality !== null) return cardinality;\n    //otherwise use calculation below\n  }\n  if (field.aggregate) {\n    return 1;\n  }\n\n  // remove null\n  return stat.distinct -\n    (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n};\n","'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.TABLE = 'table';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.N = 'N';\ng.O = 'O';\ng.Q = 'Q';\ng.T = 'T';\n","// Package of defining Vega-lite Specification's json schema\n'use strict';\n\nrequire('../globals');\n\nvar schema = module.exports = {},\n  util = require('../util'),\n  toMap = util.toMap,\n  colorbrewer = require('colorbrewer');\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: 'string',\n  enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\n};\n\nschema.aggregate = {\n  type: 'string',\n  enum: ['avg', 'sum', 'median', 'min', 'max', 'count'],\n  supportedEnums: {\n    Q: ['avg', 'median', 'sum', 'min', 'max', 'count'],\n    O: ['median','min','max'],\n    N: [],\n    T: ['avg', 'median', 'min', 'max'],\n    '': ['count']\n  },\n  supportedTypes: toMap([Q, N, O, T, ''])\n};\n\nschema.getSupportedRole = function(encType) {\n  return schema.schema.properties.encoding.properties[encType].supportedRole;\n};\n\nschema.timeUnits = ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'];\n\nschema.defaultTimeFn = 'month';\n\nschema.timeUnit = {\n  type: 'string',\n  enum: schema.timeUnits,\n  supportedTypes: toMap([T])\n};\n\nschema.scale_type = {\n  type: 'string',\n  // TODO(kanitw) read vega's schema here, add description\n  enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\n  default: 'linear',\n  supportedTypes: toMap([Q])\n};\n\nschema.field = {\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string'\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nschema.MAXBINS_DEFAULT = 15;\n\nvar bin = {\n  type: ['boolean', 'object'],\n  default: false,\n  properties: {\n    maxbins: {\n      type: 'integer',\n      default: schema.MAXBINS_DEFAULT,\n      minimum: 2,\n      description: 'Maximum number of bins.'\n    }\n  },\n  supportedTypes: toMap([Q]) // TODO: add O after finishing #81\n};\n\nvar typicalField = merge(clone(schema.field), {\n  type: 'object',\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T]\n    },\n    aggregate: schema.aggregate,\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    scale: {\n      type: 'object',\n      properties: {\n        type: schema.scale_type,\n        reverse: {\n          type: 'boolean',\n          default: false,\n          supportedTypes: toMap([Q, T])\n        },\n        zero: {\n          type: 'boolean',\n          description: 'Include zero',\n          default: true,\n          supportedTypes: toMap([Q, T])\n        },\n        nice: {\n          type: 'string',\n          enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\n          supportedTypes: toMap([T])\n        },\n        useRawDomain: {\n          type: 'boolean',\n          default: undefined,\n          description: 'Use the raw data range as scale domain instead of ' +\n                       'aggregated data for aggregate axis. ' +\n                       'This option does not work with sum or count aggregate' +\n                       'as they might have a substantially larger scale range.' +\n                       'By default, use value from config.useRawDomain.'\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: 'object',\n  supportedRole: {\n    dimension: true\n  },\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T] // ordinal-only field supports Q when bin is applied and T when time unit is applied.\n    },\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    aggregate: {\n      type: 'string',\n      enum: ['count'],\n      supportedTypes: toMap([N, O]) // FIXME this looks weird to me\n    }\n  }\n});\n\nvar axisMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true},\n  properties: {\n    axis: {\n      type: 'object',\n      properties: {\n        grid: {\n          type: 'boolean',\n          default: true,\n          description: 'A flag indicate if gridlines should be created in addition to ticks.'\n        },\n        layer: {\n          type: 'string',\n          default: 'back',\n          description: 'A string indicating if the axis (and any gridlines) should be placed above or below the data marks.'\n        },\n        orient: {\n          type: 'string',\n          default: undefined,\n          enum: ['top', 'right', 'left', 'bottom'],\n          description: 'The orientation of the axis. One of top, bottom, left or right. The orientation can be used to further specialize the axis type (e.g., a y axis oriented for the right edge of the chart).'\n        },\n        ticks :{\n          type: 'integer',\n          default: 5,\n          description: 'A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale\\'s range.'\n        },\n        title: {\n          type: 'string',\n          default: undefined,\n          description: 'A title for the axis. (Shows field name and its function by default.)'\n        },\n        titleMaxLength: {\n          type: 'integer',\n          default: undefined,\n          description: 'Max length for axis title if the title is automatically generated from the field\\'s description'\n        },\n        titleOffset: {\n          type: 'integer',\n          default: undefined,  // auto\n          description: 'A title offset value for the axis.'\n        },\n        format: {\n          type: 'string',\n          default: undefined,  // auto\n          description: 'The formatting pattern for axis labels. '+\n                       'If not undefined, this will be determined by ' +\n                       'small/largeNumberFormat and the max value ' +\n                       'of the field.'\n        },\n        maxLabelLength: {\n          type: 'integer',\n          default: 25,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar sortMixin = {\n  type: 'object',\n  properties: {\n    sort: {\n      type: 'array',\n      default: [],\n      items: {\n        type: 'object',\n        supportedTypes: toMap([N, O]),\n        required: ['name', 'aggregate'],\n        properties: {\n          name: {\n            type: 'string'\n          },\n          aggregate: {\n            type: 'string',\n            enum: ['avg', 'sum', 'min', 'max', 'count']\n          },\n          reverse: {\n            type: 'boolean',\n            default: false\n          }\n        }\n      }\n    }\n  }\n};\n\nvar bandMixin = {\n  type: 'object',\n  properties: {\n    band: {\n      type: 'object',\n      properties: {\n        size: {\n          type: 'integer',\n          minimum: 0,\n          default: undefined\n        },\n        padding: {\n          type: 'integer',\n          minimum: 0,\n          default: 1\n        }\n      }\n    }\n  }\n};\n\nvar legendMixin = {\n  type: 'object',\n  properties: {\n    legend: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nvar textMixin = {\n  type: 'object',\n  supportedMarktypes: {'text': true},\n  properties: {\n    align: {\n      type: 'string',\n      default: 'right'\n    },\n    baseline: {\n      type: 'string',\n      default: 'middle'\n    },\n    color: {\n      type: 'string',\n      role: 'color',\n      default: '#000000'\n    },\n    margin: {\n      type: 'integer',\n      default: 4,\n      minimum: 0\n    },\n    placeholder: {\n      type: 'string',\n      default: 'Abc'\n    },\n    font: {\n      type: 'object',\n      properties: {\n        weight: {\n          type: 'string',\n          enum: ['normal', 'bold'],\n          default: 'normal'\n        },\n        size: {\n          type: 'integer',\n          default: 10,\n          minimum: 0\n        },\n        family: {\n          type: 'string',\n          default: 'Helvetica Neue'\n        },\n        style: {\n          type: 'string',\n          default: 'normal',\n          enum: ['normal', 'italic']\n        }\n      }\n    },\n    format: {\n      type: 'string',\n      default: undefined,  // auto\n      description: 'The formatting pattern for text value. '+\n                   'If not undefined, this will be determined by ' +\n                   'small/largeNumberFormat and the max value ' +\n                   'of the field.'\n    },\n  }\n};\n\nvar sizeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, bar: true, circle: true, square: true, text: true},\n  properties: {\n    value: {\n      type: 'integer',\n      default: 30,\n      minimum: 0\n    }\n  }\n};\n\nvar colorMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'string',\n      role: 'color',\n      default: 'steelblue'\n    },\n    opacity: {\n      type: 'number',\n      default: undefined,  // auto\n      minimum: 0,\n      maximum: 1\n    },\n    scale: {\n      type: 'object',\n      properties: {\n        range: {\n          type: ['string', 'array'],\n          default: undefined,\n          description:\n            'color palette, if undefined vega-lite will use data property' +\n            'to pick one from c10palette, c20palette, or ordinalPalette'\n        },\n        c10palette: {\n          type: 'string',\n          default: 'category10',\n          enum: [\n            // Tableau\n            'category10', 'category10k',\n            // Color Brewer\n            'Pastel1', 'Pastel2', 'Set1', 'Set2', 'Set3'\n          ]\n        },\n        c20palette: {\n          type: 'string',\n          default: 'category20',\n          enum: ['category20', 'category20b', 'category20c']\n        },\n        ordinalPalette: {\n          type: 'string',\n          default: 'BuGn',\n          enum: util.keys(colorbrewer)\n        }\n      }\n    }\n  }\n};\n\nvar shapeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, circle: true, square: true},\n  properties: {\n    value: {\n      type: 'string',\n      enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\n      default: 'circle'\n    },\n    filled: {\n      type: 'boolean',\n      default: false,\n      description: 'whether the shape\\'s color should be used as fill color instead of stroke color'\n    }\n  }\n};\n\nvar detailMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, line: true, circle: true, square: true}\n};\n\nvar rowMixin = {\n  properties: {\n    height: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    }\n  }\n};\n\nvar colMixin = {\n  properties: {\n    width: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    axis: {\n      properties: {\n        maxLabelLength: {\n          type: 'integer',\n          default: 12,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar facetMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, text: true},\n  properties: {\n    padding: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.1\n    }\n  }\n};\n\nvar requiredNameType = {\n  required: ['name', 'type']\n};\n\nvar multiRoleField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: true\n  }\n});\n\nvar quantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: 'ordinal-only' // using size to encoding category lead to order interpretation\n  }\n});\n\nvar onlyQuantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true\n  }\n});\n\nvar x = merge(clone(multiRoleField), axisMixin, bandMixin, requiredNameType, sortMixin);\nvar y = clone(x);\n\nvar facet = merge(clone(onlyOrdinalField), requiredNameType, facetMixin, sortMixin);\nvar row = merge(clone(facet), axisMixin, rowMixin);\nvar col = merge(clone(facet), axisMixin, colMixin);\n\nvar size = merge(clone(quantitativeField), legendMixin, sizeMixin, sortMixin);\nvar color = merge(clone(multiRoleField), legendMixin, colorMixin, sortMixin);\n\nvar shape = merge(clone(onlyOrdinalField), legendMixin, shapeMixin, sortMixin);\nvar detail = merge(clone(onlyOrdinalField), detailMixin, sortMixin);\n\n// we only put aggregated measure in pivot table\nvar text = merge(clone(onlyQuantitativeField), textMixin, sortMixin);\n\n// TODO add label\n\nvar filter = {\n  type: 'array',\n  items: {\n    type: 'object',\n    properties: {\n      operands: {\n        type: 'array',\n        items: {\n          type: ['string', 'boolean', 'integer', 'number']\n        }\n      },\n      operator: {\n        type: 'string',\n        enum: ['>', '>=', '=', '!=', '<', '<=', 'notNull']\n      }\n    }\n  }\n};\n\nvar data = {\n  type: 'object',\n  properties: {\n    // data source\n    formatType: {\n      type: 'string',\n      enum: ['json', 'csv'],\n      default: 'json'\n    },\n    url: {\n      type: 'string',\n      default: undefined\n    },\n    values: {\n      type: 'array',\n      default: undefined,\n      description: 'Pass array of objects instead of a url to a file.',\n      items: {\n        type: 'object',\n        additionalProperties: true\n      }\n    }\n  }\n};\n\nvar config = {\n  type: 'object',\n  properties: {\n    // template\n    width: {\n      type: 'integer',\n      default: undefined\n    },\n    height: {\n      type: 'integer',\n      default: undefined\n    },\n    viewport: {\n      type: 'array',\n      items: {\n        type: 'integer'\n      },\n      default: undefined\n    },\n    gridColor: {\n      type: 'string',\n      role: 'color',\n      default: 'black'\n    },\n    gridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.08\n    },\n\n    // filter null\n    filterNull: {\n      type: 'object',\n      properties: {\n        O: {type:'boolean', default: false},\n        Q: {type:'boolean', default: true},\n        T: {type:'boolean', default: true}\n      }\n    },\n    toggleSort: {\n      type: 'string',\n      default: O\n    },\n\n    // single plot\n    singleHeight: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    singleWidth: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    // band size\n    largeBandSize: {\n      type: 'integer',\n      default: 21,\n      minimum: 0\n    },\n    smallBandSize: {\n      //small multiples or single plot with high cardinality\n      type: 'integer',\n      default: 12,\n      minimum: 0\n    },\n    largeBandMaxCardinality: {\n      type: 'integer',\n      default: 10\n    },\n    // small multiples\n    cellPadding: {\n      type: 'number',\n      default: 0.1\n    },\n    cellGridColor: {\n      type: 'string',\n      role: 'color',\n      default: 'black'\n    },\n    cellGridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.15\n    },\n    cellBackgroundColor: {\n      type: 'string',\n      role: 'color',\n      default: 'transparent'\n    },\n    textCellWidth: {\n      type: 'integer',\n      default: 90,\n      minimum: 0\n    },\n\n    // marks\n    strokeWidth: {\n      type: 'integer',\n      default: 2,\n      minimum: 0\n    },\n    singleBarOffset: {\n      type: 'integer',\n      default: 5,\n      minimum: 0\n    },\n    // scales\n    timeScaleLabelLength: {\n      type: 'integer',\n      default: 3,\n      minimum: 0,\n      description: 'Max length for values in dayScaleLabel and monthScaleLabel.  Zero means using full names in dayScaleLabel/monthScaleLabel.'\n    },\n    dayScaleLabel: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      default: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n      description: 'Axis labels for day of week, starting from Sunday.' +\n        '(Consistent with Javascript -- See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getDay.'\n    },\n    monthScaleLabel: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      default: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n      description: 'Axis labels for month.'\n    },\n    // other\n    characterWidth: {\n      type: 'integer',\n      default: 6\n    },\n    maxSmallNumber: {\n      type: 'number',\n      default: 10000,\n      description: 'maximum number that a field will be considered smallNumber.'+\n                   'Used for axis labelling.'\n    },\n    smallNumberFormat: {\n      type: 'string',\n      default: '',\n      description: 'D3 Number format for axis labels and text tables '+\n                   'for number <= maxSmallNumber. Used for axis labelling.'\n    },\n    largeNumberFormat: {\n      type: 'string',\n      default: '.3s',\n      description: 'D3 Number format for axis labels and text tables ' +\n                   'for number > maxSmallNumber.'\n    },\n    timeFormat: {\n      type: 'string',\n      default: '%Y-%m-%d',\n      description: 'Date format for axis labels.'\n    },\n    useRawDomain: {\n      type: 'boolean',\n      default: false,\n      description: 'Use the raw data range as scale domain instead of ' +\n                   'aggregated data for aggregate axis. ' +\n                   'This option does not work with sum or count aggregate' +\n                   'as they might have a substantially larger scale range.' +\n                   'By default, use value from config.useRawDomain.'\n    }\n  }\n};\n\n/** @type Object Schema of a vega-lite specification */\nschema.schema = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  description: 'Schema for Vega-lite specification',\n  type: 'object',\n  required: ['marktype', 'encoding', 'data'],\n  properties: {\n    data: data,\n    marktype: schema.marktype,\n    encoding: {\n      type: 'object',\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        shape: shape,\n        text: text,\n        detail: detail\n      }\n    },\n    filter: filter,\n    config: config\n  }\n};\n\nschema.encTypes = util.keys(schema.schema.properties.encoding.properties);\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function() {\n  return schema.util.instantiate(schema.schema);\n};\n","'use strict';\n\nvar schemautil = module.exports = {},\n  util = require('../util');\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\nschemautil.extend = function(instance, schema) {\n  return schemautil.merge(schemautil.instantiate(schema), instance);\n};\n\n// instantiate a schema\nschemautil.instantiate = function(schema) {\n  var val;\n  if (schema === undefined) {\n    return undefined;\n  } else if ('default' in schema) {\n    val = schema.default;\n    return util.isObject(val) ? util.duplicate(val) : val;\n  } else if (schema.type === 'object') {\n    var instance = {};\n    for (var name in schema.properties) {\n      val = schemautil.instantiate(schema.properties[name]);\n      if (val !== undefined) {\n        instance[name] = val;\n      }\n    }\n    return instance;\n  } else if (schema.type === 'array') {\n    return [];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nschemautil.subtract = function(instance, defaults) {\n  var changes = {};\n  for (var prop in instance) {\n    var def = defaults[prop];\n    var ins = instance[prop];\n    // Note: does not properly subtract arrays\n    if (!defaults || def !== ins) {\n      if (typeof ins === 'object' && !util.isArray(ins) && def) {\n        var c = schemautil.subtract(ins, def);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else if (!util.isArray(ins) || ins.length > 0) {\n        changes[prop] = ins;\n      }\n    }\n  }\n  return changes;\n};\n\nschemautil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction merge(dest, src) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (var p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      merge(dest[p], src[p]);\n    }\n  }\n  return dest;\n}","'use strict';\n\nvar util = module.exports = require('datalib/src/util');\n\nutil.extend(util, require('datalib/src/generate'));\nutil.extend(util, require('datalib/src/stats'));\nutil.bin = require('datalib/src/bins/bins');\n\nutil.isin = function(item, array) {\n  return array.indexOf(item) !== -1;\n};\n\nutil.forEach = function(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  } else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k , obj);\n    }\n  }\n};\n\nutil.reduce = function(obj, f, init, thisArg) {\n  if (obj.reduce) {\n    return obj.reduce.call(thisArg, f, init);\n  } else {\n    for (var k in obj) {\n      init = f.call(thisArg, init, obj[k], k, obj);\n    }\n    return init;\n  }\n};\n\nutil.map = function(obj, f, thisArg) {\n  if (obj.map) {\n    return obj.map.call(thisArg, f);\n  } else {\n    var output = [];\n    for (var k in obj) {\n      output.push( f.call(thisArg, obj[k], k, obj));\n    }\n  }\n};\n\nutil.any = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (f(arr[k], k, i++)) return true;\n  }\n  return false;\n};\n\nutil.all = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (!f(arr[k], k, i++)) return false;\n  }\n  return true;\n};\n\nutil.getbins = function(stats, maxbins) {\n  return util.bin({\n    min: stats.min,\n    max: stats.max,\n    maxbins: maxbins\n  });\n};\n\n/**\n * x[p[0]]...[p[n]] = val\n * @param noaugment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.setter = function(x, p, val, noaugment) {\n  for (var i=0; i<p.length-1; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  x[p[i]] = val;\n};\n\n\n/**\n * returns x[p[0]]...[p[n]]\n * @param augment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.getter = function(x, p, noaugment) {\n  for (var i=0; i<p.length; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  return x;\n};\n\nutil.error = function(msg) {\n  console.error('[VL Error]', msg);\n};\n\n","'use strict';\n\nrequire('./globals');\n\nvar util = require('./util'),\n    consts = require('./consts');\n\nvar vl = {};\n\nutil.extend(vl, consts, util);\n\nvl.Encoding = require('./Encoding');\nvl.compiler = require('./compiler/compiler');\nvl.compile = vl.compiler.compile;\nvl.data = require('./data');\nvl.enc = require('./enc');\nvl.field = require('./field');\nvl.schema = require('./schema/schema');\nvl.toShorthand = vl.Encoding.shorthand;\n\nmodule.exports = vl;"],"sourceRoot":"/source/"}