{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","vega-lite.js","node_modules/colorbrewer/colorbrewer.js","node_modules/colorbrewer/index.js","node_modules/d3-color/build/color.js","node_modules/d3-format/build/format.js","node_modules/d3-time-format/build/timeFormat.js","src/Encoding.js","src/compiler/axis.js","src/compiler/compiler.js","src/compiler/data.js","src/compiler/facet.js","src/compiler/layout.js","src/compiler/legend.js","src/compiler/marks.js","src/compiler/scale.js","src/compiler/sort.js","src/compiler/stack.js","src/compiler/style.js","src/compiler/subfacet.js","src/compiler/time.js","src/consts.js","src/data.js","src/enc.js","src/field.js","src/globals.js","src/logger.js","src/schema/schema.js","src/schema/schemautil.js","src/util.js","src/vl","../../../../../usr/local/lib/node_modules/datalib/node_modules/d3-time/build/time.js","../../../../../usr/local/lib/node_modules/datalib/src/bins/bins.js","../../../../../usr/local/lib/node_modules/datalib/src/generate.js","../../../../../usr/local/lib/node_modules/datalib/src/import/type.js","../../../../../usr/local/lib/node_modules/datalib/src/stats.js","../../../../../usr/local/lib/node_modules/datalib/src/time.js","../../../../../usr/local/lib/node_modules/datalib/src/util.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","vl","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,2,"colorbrewer","YlGn",3,4,5,6,7,8,9,"YlGnBu","GnBu","BuGn","PuBuGn","PuBu","BuPu","RdPu","PuRd","OrRd","YlOrRd","YlOrBr","Purples","Blues","Greens","Oranges","Reds","Greys","PuOr",10,11,"BrBG","PRGn","PiYG","RdBu","RdGy","RdYlBu","Spectral","RdYlGn","Accent","Dark2","Paired",12,"Pastel1","Pastel2","Set1","Set2","Set3","./colorbrewer.js","factory","color","deltaHue","h1","h0","delta","Math","round","Color","format","m","trim","toLowerCase","reHex3","exec","parseInt","rgb","reHex6","rgbn","reRgbInteger","reRgbPercent","reHslPercent","hsl","named","hasOwnProperty","b","arguments","NaN","Rgb","_format","isNaN","max","toString","min","h","Hsl","range","hsl2rgb","m1","m2","lab","Lab","Hcl","deg2rad","sin","c","cos","rgb2xyz","x","xyz2lab","Xn","y","Yn","z","Zn","t3","pow","t2","t0","lab2xyz","t1","xyz2rgb","hcl","sqrt","atan2","rad2deg","cubehelix","Cubehelix","BC_DA","ED","EB","bl","k","E","C","D","interpolateCubehelixGamma","gamma","ah","as","al","bh","bs","interpolateCubehelixGammaLong","interpolateHclLong","ac","bc","interpolateHcl","interpolateLab","aa","ab","ba","bb","interpolateHslLong","interpolateHsl","interpolateRgb","ar","ag","br","bg","prototype","displayable","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","darker","brighter","____prototype","___prototype","Kn","__prototype","PI","_prototype","A","B","cosh","sinh","interpolateCubehelix","interpolateCubehelixLong","Map","clear","set","v","_","get","has","delete","Object","create",{"end":{"file":"?","comments_before":[],"nlb":false,"endpos":38757,"endcol":12,"endline":980,"pos":38753,"col":8,"line":980,"value":"size","type":"name"},"start":{"file":"?","comments_before":[],"nlb":false,"endpos":38757,"endcol":12,"endline":980,"pos":38753,"col":8,"line":980,"value":"size","type":"name"},"name":"size"},"size","forEach","apply","formatDecimal","p","toExponential","indexOf","coefficient","slice","exponent","abs","formatPrefixAuto","d","prefixExponent","floor","Array","join","formatRounded","formatDefault","toPrecision","out","i1","i0","formatSpecifier","specifier","FormatSpecifier","match","re","fill","align","sign","symbol","zero","width","comma","precision","type","formatTypes","formatGroup","grouping","thousands","value","j","push","substring","reverse","identity","locale","prefix","currency","test","suffix","formatType","maybeSuffix","valuePrefix","valueSuffix","valueNegative","prefixes","charCodeAt","decimal","group","Infinity","padding","formatPrefix","precisionRound","step","precisionPrefix","precisionFixed","localeFormat","definition","localeDefinitions","zhCn","ruRu","ptBr","plPl","nlNl","mkMk","jaJp","itIt","heIl","frFr","frCa","fiFi","esEs","enUs","enGb","enCa","deDe","caEs","%","toFixed","X","toUpperCase","defaultLocale","timeFormat","newInterval","floori","offseti","count","interval","date","Date","d0","d1","ceil","offset","start","stop","filter","setTime","end","weekday","setHours","setDate","getDate","getDay","getTimezoneOffset","utcWeekday","setUTCHours","setUTCDate","getUTCDate","getUTCDay","localDate","H","M","S","L","setFullYear","utcDate","UTC","setUTCFullYear","newYear","newFormat","formats","pad","string","pads","charAt","newParse","newDate","parseSpecifier","day","U","W","w","Z","parse","parses","parseShortWeekday","shortWeekdayRe","shortWeekdayLookup","parseWeekday","weekdayRe","weekdayLookup","parseShortMonth","shortMonthRe","shortMonthLookup","parseMonth","monthRe","monthLookup","parseLocaleDateTime","locale_dateTime","parseLocaleDate","locale_date","parseLocaleTime","locale_time","parsePeriod","periodLookup","formatShortWeekday","locale_shortWeekdays","formatWeekday","locale_weekdays","formatShortMonth","locale_shortMonths","getMonth","formatMonth","locale_months","formatPeriod","locale_periods","getHours","formatUTCShortWeekday","formatUTCWeekday","formatUTCShortMonth","getUTCMonth","formatUTCMonth","formatUTCPeriod","getUTCHours","dateTime","time","periods","days","shortDays","months","shortMonths","formatLookup","formatRe","formatDayOfMonth","formatHour24","I","formatHour12","formatDayOfYear","formatMilliseconds","formatMonthNumber","formatMinutes","formatSeconds","formatWeekNumberSunday","formatWeekdayNumber","formatWeekNumberMonday","formatYear","Y","formatFullYear","formatZone","formatLiteralPercent","utcFormats","formatUTCDayOfMonth","formatUTCHour24","formatUTCHour12","formatUTCDayOfYear","formatUTCMilliseconds","formatUTCMonthNumber","formatUTCMinutes","formatUTCSeconds","formatUTCWeekNumberSunday","formatUTCWeekdayNumber","formatUTCWeekNumberMonday","formatUTCYear","formatUTCFullYear","formatUTCZone","parseDayOfMonth","parseHour24","parseDayOfYear","parseMilliseconds","parseMonthNumber","parseMinutes","parseSeconds","parseWeekNumberSunday","parseWeekdayNumber","parseWeekNumberMonday","parseYear","parseFullYear","parseZone","parseLiteralPercent","utcFormat","requote","replace","requoteRe","names","RegExp","map","numberRe","percentRe","year","getMilliseconds","getMinutes","getSeconds","sunday","monday","getFullYear","utcDay","utcYear","getUTCMilliseconds","getUTCMinutes","getUTCSeconds","utcSunday","utcMonday","getUTCFullYear","formatIsoNative","toISOString","setMonth","setUTCMonth","-","0","isoSpecifier","formatIso","isoFormat","consts","util","vlfield","vlenc","schema","Encoding","spec","theme","defaults","instantiate","specExtended","merge","_data","data","_marktype","marktype","_enc","encoding","_config","config","_filter","proto","fromShorthand","shorthand","split","delim","shift","assign","enc","fromSpec","toShorthand","specFromShorthand","excludeConfig","toSpec","excludeData","duplicate","subtract","is","encType","undefined","name","field","et","filterNull","fields","fieldList","fieldName","Q","containsType","T","O","N","operands","operator","concat","fieldRef","opt","_vega2","fieldTitle","isCount","displayName","fn","aggregate","timeUnit","bin","uppercase","scale","axis","bandSize","useSmallBand","ROW","COL","band","maxbins","MAXBINS_DEFAULT","numberFormat","fieldStats","formatConfig","sort","stats","isTypes","toggleSort","support","qField","reduce","init","isType","isOrdinalScale","isDimension","isMeasure","isAggregate","dataTable","AGGREGATE","RAW","alwaysNoOcclusion","isStack","details","refs","facets","cardinality","isRaw","hasValues","vals","values","transpose","oldenc","row","col","direction","mode","toggleFilterNullO","nulls","./consts","./enc","./field","./globals","./schema/schema","./util","setter","getter","def","layout","isCol","isRow","properties","layer","orient","labels","angle","ticks","rotate","titleOffset","grid","title","hideTicks","cellPadding","cellWidth","cellHeight","stroke","opacity","x2","mult","majorTicks","ax","maxLength","titleMaxLength","truncate","baseline","dy","height","hasScale","maxLabelLength","labelAngle","../globals","../util","./time","summary","compiler","legend","marks","facet","stack","style","subfacet","compile","compileEncoding","console","error","scales","_name","enter","mdefs","mdef","lineType","line","from","transform","by","singleScaleNames","markProps","update","legends","defs","axes","../Encoding","./axis","./data","./facet","./layout","./legend","./marks","./scale","./sort","./stack","./style","./subfacet","datalib/src/stats","raw","filterNonPositive","url","formatParse","BINARY",">",">=","=","!=","<","<=","expr","formula","nofn","output","filters","condition","op1","op2","warn","dims","meas","op","source","groupby","../field","groupdef","faceting","axesGrp","facetKeys","cellAxes","hasRow","hasCol","mark","unshift","keys","trans","vllayout","box","hasX","hasY","xCardinality","yCardinality","TEXT","colCardinality","rowCardinality","getMaxNumberLength","d3_format","getMaxLength","extraOffset","d3-format",13,"COLOR","SIZE","SHAPE","shape","symbols","filled","strokeWidth","leg",14,"bar_props","xc","y2","yc","point_props","line_props","area_props","tick_props","filled_point_props","text_props","fontSize","font","text","template","placeholder","family","fontWeight","weight","fontStyle","prop","bar","supportedEncoding","requiredEncoding","detail","area","tick","circle","square","point",15,"interpolate","vlsort","props","domain","fieldStat","bins","getbins","numbins","STACKED","prefn","scaleUseRawDomain","useRawDomain","notCountOrSum","isOrdinalFn","getDataName","bandWidth","nice","outerPadding","points","colorScale","ordinalPalette","quantitativeRange","c10palette","c20palette","palette","ps","to","interpolator","../schema/schema","d3-color",16,"datasetMapping","sortBy","byClause","dataName","transforms",17,"stacking","dim","val","idx","isXMeasure","isYMeasure","stacked","y1","y0",18,"estimateOpacity","numPoints","numMultiples",19,"subfaceting",20,"d3_time_format","LONG_DATE","stat","yearstat","distinct","scaleLabel","labelLength","substr","isColor","d3-time-format",21,"encodingTypes","DETAIL","func",22,"vldata","types","boolean","number","integer","profile","*",23,"encTypes","countRetinal","fieldDef","arr","isArray","enctype",24,"shorthands","timefns","tu","./compiler/time",25,"INDEX",26,"METHODS","logger","cfn","bind","Function",27,"toMap","enum","supportedEnums","supportedTypes","getSupportedRole","supportedRole","timeUnits","defaultTimeFn","scale_type","default","clone","minimum","description","typicalField","onlyOrdinalField","dimension","axisMixin","supportedMarktypes","maximum","sortMixin","items","required","bandMixin","legendMixin","textMixin","role","margin","sizeMixin","colorMixin","minItems","maxItems","shapeMixin","detailMixin","rowMixin","colMixin","facetMixin","requiredNameType","multiRoleField","measure","quantitativeField","onlyQuantitativeField","additionalProperties","viewport","gridColor","gridOpacity","autoSortLine","singleHeight","singleWidth","largeBandSize","smallBandSize","largeBandMaxCardinality","cellGridColor","cellGridOpacity","cellBackgroundColor","textCellWidth","singleBarOffset","timeScaleLabelLength","dayScaleLabel","monthScaleLabel","characterWidth","maxSmallNumber","smallNumberFormat","largeNumberFormat","$schema","./schemautil",28,"dest","src","constructor","schemautil","isEmpty","obj","extend","instance","isObject","changes","ins",29,"isin","item","array","thisArg","any","all","noaugment","./logger","datalib/src/bins/bins","datalib/src/generate","datalib/src/util",30,"./Encoding","./compiler/compiler",31,"second","setMilliseconds","seconds","minute","setSeconds","minutes","hour","setMinutes","hours","sundays","mondays","tuesday","tuesdays","wednesday","wednesdays","thursday","thursdays","friday","fridays","saturday","saturdays","week","weeks","month","years","utcSecond","setUTCMilliseconds","utcSeconds","utcMinute","setUTCSeconds","utcMinutes","utcHour","setUTCMinutes","utcHours","utcDays","utcSundays","utcMondays","utcTuesday","utcTuesdays","utcWednesday","utcWednesdays","utcThursday","utcThursdays","utcFriday","utcFridays","utcSaturday","utcSaturdays","utcWeek","utcWeeks","utcMonth","utcMonths","utcYears",32,"level","minstep","eps","maxb","base","logb","log","div","span","steps","bisect","unit","index","lo","hi","mid","cmp","EPSILON","date_value","date_index","units","utc","dmin","dmax","minb","minbins","find","../time",33,"gen","repeat","zeros","random","uniform","samples","normal","mean","stdev","next","rds",34,"annotation","TYPES","$","isString","isValid","isDate","isNumber","isBoolean","typeAll","infer","TESTS","splice","inferAll","PARSERS","parsers",35,"unique","results","valid","missing","median","quantile","quartile","q","sum","variance","M2","modeskew","avg","med","std","extent","dot","rank","mu","comparator","tie","cor","mua","mub","sda","sdb","ra","rb","dist","mat","exp","isFunction","L2","R","entropy","counts","LN2","mutual","px","py","info","sd","q1","q3","__summary__","./generate","./import/type",36,"tempDate","entry","STEPS","toUnitMap","d3_time","baseDate","utcBaseDate","d3-time",37,"util_escape_str","escape_str_re","strrep","str","truncateOnWord","len","rev","cnt","tok","truncate_word_re","buffer","FNAME","namedfunc","JSON","stringify","equal","list","keystr","String","isBuffer","Buffer","accessor","mutator","$func","$valid","$length","$in","$year","$month","$date","dates","$day","weekdays","$hour","$minute","$second","$utcYear","$utcMonth","$utcDate","$utcDay","$utcHour","$utcMinute","$utcSecond","numcmp","stablesort","keyFn","indices","sa","sb","pos","padchar","word","ellipsis","l1","l2"],"mappings":"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","file":"vega-lite.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.vl = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\n},{}],2:[function(require,module,exports){\n// This product includes color specifications and designs developed by Cynthia Brewer (http://colorbrewer.org/).\n// JavaScript specs as packaged in the D3 library (d3js.org). Please see license at http://colorbrewer.org/export/LICENSE.txt\n!function() {\n\nvar colorbrewer = {YlGn: {\n3: [\"#f7fcb9\",\"#addd8e\",\"#31a354\"],\n4: [\"#ffffcc\",\"#c2e699\",\"#78c679\",\"#238443\"],\n5: [\"#ffffcc\",\"#c2e699\",\"#78c679\",\"#31a354\",\"#006837\"],\n6: [\"#ffffcc\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#31a354\",\"#006837\"],\n7: [\"#ffffcc\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#005a32\"],\n8: [\"#ffffe5\",\"#f7fcb9\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#005a32\"],\n9: [\"#ffffe5\",\"#f7fcb9\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#006837\",\"#004529\"]\n},YlGnBu: {\n3: [\"#edf8b1\",\"#7fcdbb\",\"#2c7fb8\"],\n4: [\"#ffffcc\",\"#a1dab4\",\"#41b6c4\",\"#225ea8\"],\n5: [\"#ffffcc\",\"#a1dab4\",\"#41b6c4\",\"#2c7fb8\",\"#253494\"],\n6: [\"#ffffcc\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#2c7fb8\",\"#253494\"],\n7: [\"#ffffcc\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#0c2c84\"],\n8: [\"#ffffd9\",\"#edf8b1\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#0c2c84\"],\n9: [\"#ffffd9\",\"#edf8b1\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#253494\",\"#081d58\"]\n},GnBu: {\n3: [\"#e0f3db\",\"#a8ddb5\",\"#43a2ca\"],\n4: [\"#f0f9e8\",\"#bae4bc\",\"#7bccc4\",\"#2b8cbe\"],\n5: [\"#f0f9e8\",\"#bae4bc\",\"#7bccc4\",\"#43a2ca\",\"#0868ac\"],\n6: [\"#f0f9e8\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#43a2ca\",\"#0868ac\"],\n7: [\"#f0f9e8\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#08589e\"],\n8: [\"#f7fcf0\",\"#e0f3db\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#08589e\"],\n9: [\"#f7fcf0\",\"#e0f3db\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#0868ac\",\"#084081\"]\n},BuGn: {\n3: [\"#e5f5f9\",\"#99d8c9\",\"#2ca25f\"],\n4: [\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#238b45\"],\n5: [\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\"],\n6: [\"#edf8fb\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\"],\n7: [\"#edf8fb\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#005824\"],\n8: [\"#f7fcfd\",\"#e5f5f9\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#005824\"],\n9: [\"#f7fcfd\",\"#e5f5f9\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#006d2c\",\"#00441b\"]\n},PuBuGn: {\n3: [\"#ece2f0\",\"#a6bddb\",\"#1c9099\"],\n4: [\"#f6eff7\",\"#bdc9e1\",\"#67a9cf\",\"#02818a\"],\n5: [\"#f6eff7\",\"#bdc9e1\",\"#67a9cf\",\"#1c9099\",\"#016c59\"],\n6: [\"#f6eff7\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#1c9099\",\"#016c59\"],\n7: [\"#f6eff7\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016450\"],\n8: [\"#fff7fb\",\"#ece2f0\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016450\"],\n9: [\"#fff7fb\",\"#ece2f0\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016c59\",\"#014636\"]\n},PuBu: {\n3: [\"#ece7f2\",\"#a6bddb\",\"#2b8cbe\"],\n4: [\"#f1eef6\",\"#bdc9e1\",\"#74a9cf\",\"#0570b0\"],\n5: [\"#f1eef6\",\"#bdc9e1\",\"#74a9cf\",\"#2b8cbe\",\"#045a8d\"],\n6: [\"#f1eef6\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#2b8cbe\",\"#045a8d\"],\n7: [\"#f1eef6\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#034e7b\"],\n8: [\"#fff7fb\",\"#ece7f2\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#034e7b\"],\n9: [\"#fff7fb\",\"#ece7f2\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#045a8d\",\"#023858\"]\n},BuPu: {\n3: [\"#e0ecf4\",\"#9ebcda\",\"#8856a7\"],\n4: [\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#88419d\"],\n5: [\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#8856a7\",\"#810f7c\"],\n6: [\"#edf8fb\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8856a7\",\"#810f7c\"],\n7: [\"#edf8fb\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#6e016b\"],\n8: [\"#f7fcfd\",\"#e0ecf4\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#6e016b\"],\n9: [\"#f7fcfd\",\"#e0ecf4\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#810f7c\",\"#4d004b\"]\n},RdPu: {\n3: [\"#fde0dd\",\"#fa9fb5\",\"#c51b8a\"],\n4: [\"#feebe2\",\"#fbb4b9\",\"#f768a1\",\"#ae017e\"],\n5: [\"#feebe2\",\"#fbb4b9\",\"#f768a1\",\"#c51b8a\",\"#7a0177\"],\n6: [\"#feebe2\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#c51b8a\",\"#7a0177\"],\n7: [\"#feebe2\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\"],\n8: [\"#fff7f3\",\"#fde0dd\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\"],\n9: [\"#fff7f3\",\"#fde0dd\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\",\"#49006a\"]\n},PuRd: {\n3: [\"#e7e1ef\",\"#c994c7\",\"#dd1c77\"],\n4: [\"#f1eef6\",\"#d7b5d8\",\"#df65b0\",\"#ce1256\"],\n5: [\"#f1eef6\",\"#d7b5d8\",\"#df65b0\",\"#dd1c77\",\"#980043\"],\n6: [\"#f1eef6\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#dd1c77\",\"#980043\"],\n7: [\"#f1eef6\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#91003f\"],\n8: [\"#f7f4f9\",\"#e7e1ef\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#91003f\"],\n9: [\"#f7f4f9\",\"#e7e1ef\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#980043\",\"#67001f\"]\n},OrRd: {\n3: [\"#fee8c8\",\"#fdbb84\",\"#e34a33\"],\n4: [\"#fef0d9\",\"#fdcc8a\",\"#fc8d59\",\"#d7301f\"],\n5: [\"#fef0d9\",\"#fdcc8a\",\"#fc8d59\",\"#e34a33\",\"#b30000\"],\n6: [\"#fef0d9\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#e34a33\",\"#b30000\"],\n7: [\"#fef0d9\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#990000\"],\n8: [\"#fff7ec\",\"#fee8c8\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#990000\"],\n9: [\"#fff7ec\",\"#fee8c8\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#b30000\",\"#7f0000\"]\n},YlOrRd: {\n3: [\"#ffeda0\",\"#feb24c\",\"#f03b20\"],\n4: [\"#ffffb2\",\"#fecc5c\",\"#fd8d3c\",\"#e31a1c\"],\n5: [\"#ffffb2\",\"#fecc5c\",\"#fd8d3c\",\"#f03b20\",\"#bd0026\"],\n6: [\"#ffffb2\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#f03b20\",\"#bd0026\"],\n7: [\"#ffffb2\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#b10026\"],\n8: [\"#ffffcc\",\"#ffeda0\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#b10026\"],\n9: [\"#ffffcc\",\"#ffeda0\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#bd0026\",\"#800026\"]\n},YlOrBr: {\n3: [\"#fff7bc\",\"#fec44f\",\"#d95f0e\"],\n4: [\"#ffffd4\",\"#fed98e\",\"#fe9929\",\"#cc4c02\"],\n5: [\"#ffffd4\",\"#fed98e\",\"#fe9929\",\"#d95f0e\",\"#993404\"],\n6: [\"#ffffd4\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#d95f0e\",\"#993404\"],\n7: [\"#ffffd4\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#8c2d04\"],\n8: [\"#ffffe5\",\"#fff7bc\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#8c2d04\"],\n9: [\"#ffffe5\",\"#fff7bc\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#993404\",\"#662506\"]\n},Purples: {\n3: [\"#efedf5\",\"#bcbddc\",\"#756bb1\"],\n4: [\"#f2f0f7\",\"#cbc9e2\",\"#9e9ac8\",\"#6a51a3\"],\n5: [\"#f2f0f7\",\"#cbc9e2\",\"#9e9ac8\",\"#756bb1\",\"#54278f\"],\n6: [\"#f2f0f7\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#756bb1\",\"#54278f\"],\n7: [\"#f2f0f7\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#4a1486\"],\n8: [\"#fcfbfd\",\"#efedf5\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#4a1486\"],\n9: [\"#fcfbfd\",\"#efedf5\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#54278f\",\"#3f007d\"]\n},Blues: {\n3: [\"#deebf7\",\"#9ecae1\",\"#3182bd\"],\n4: [\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#2171b5\"],\n5: [\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#3182bd\",\"#08519c\"],\n6: [\"#eff3ff\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#3182bd\",\"#08519c\"],\n7: [\"#eff3ff\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#084594\"],\n8: [\"#f7fbff\",\"#deebf7\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#084594\"],\n9: [\"#f7fbff\",\"#deebf7\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#08519c\",\"#08306b\"]\n},Greens: {\n3: [\"#e5f5e0\",\"#a1d99b\",\"#31a354\"],\n4: [\"#edf8e9\",\"#bae4b3\",\"#74c476\",\"#238b45\"],\n5: [\"#edf8e9\",\"#bae4b3\",\"#74c476\",\"#31a354\",\"#006d2c\"],\n6: [\"#edf8e9\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#31a354\",\"#006d2c\"],\n7: [\"#edf8e9\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#005a32\"],\n8: [\"#f7fcf5\",\"#e5f5e0\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#005a32\"],\n9: [\"#f7fcf5\",\"#e5f5e0\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#006d2c\",\"#00441b\"]\n},Oranges: {\n3: [\"#fee6ce\",\"#fdae6b\",\"#e6550d\"],\n4: [\"#feedde\",\"#fdbe85\",\"#fd8d3c\",\"#d94701\"],\n5: [\"#feedde\",\"#fdbe85\",\"#fd8d3c\",\"#e6550d\",\"#a63603\"],\n6: [\"#feedde\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#e6550d\",\"#a63603\"],\n7: [\"#feedde\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#8c2d04\"],\n8: [\"#fff5eb\",\"#fee6ce\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#8c2d04\"],\n9: [\"#fff5eb\",\"#fee6ce\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#a63603\",\"#7f2704\"]\n},Reds: {\n3: [\"#fee0d2\",\"#fc9272\",\"#de2d26\"],\n4: [\"#fee5d9\",\"#fcae91\",\"#fb6a4a\",\"#cb181d\"],\n5: [\"#fee5d9\",\"#fcae91\",\"#fb6a4a\",\"#de2d26\",\"#a50f15\"],\n6: [\"#fee5d9\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#de2d26\",\"#a50f15\"],\n7: [\"#fee5d9\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#99000d\"],\n8: [\"#fff5f0\",\"#fee0d2\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#99000d\"],\n9: [\"#fff5f0\",\"#fee0d2\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#a50f15\",\"#67000d\"]\n},Greys: {\n3: [\"#f0f0f0\",\"#bdbdbd\",\"#636363\"],\n4: [\"#f7f7f7\",\"#cccccc\",\"#969696\",\"#525252\"],\n5: [\"#f7f7f7\",\"#cccccc\",\"#969696\",\"#636363\",\"#252525\"],\n6: [\"#f7f7f7\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#636363\",\"#252525\"],\n7: [\"#f7f7f7\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\"],\n8: [\"#ffffff\",\"#f0f0f0\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\"],\n9: [\"#ffffff\",\"#f0f0f0\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\",\"#000000\"]\n},PuOr: {\n3: [\"#f1a340\",\"#f7f7f7\",\"#998ec3\"],\n4: [\"#e66101\",\"#fdb863\",\"#b2abd2\",\"#5e3c99\"],\n5: [\"#e66101\",\"#fdb863\",\"#f7f7f7\",\"#b2abd2\",\"#5e3c99\"],\n6: [\"#b35806\",\"#f1a340\",\"#fee0b6\",\"#d8daeb\",\"#998ec3\",\"#542788\"],\n7: [\"#b35806\",\"#f1a340\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#998ec3\",\"#542788\"],\n8: [\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\"],\n9: [\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\"],\n10: [\"#7f3b08\",\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\",\"#2d004b\"],\n11: [\"#7f3b08\",\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\",\"#2d004b\"]\n},BrBG: {\n3: [\"#d8b365\",\"#f5f5f5\",\"#5ab4ac\"],\n4: [\"#a6611a\",\"#dfc27d\",\"#80cdc1\",\"#018571\"],\n5: [\"#a6611a\",\"#dfc27d\",\"#f5f5f5\",\"#80cdc1\",\"#018571\"],\n6: [\"#8c510a\",\"#d8b365\",\"#f6e8c3\",\"#c7eae5\",\"#5ab4ac\",\"#01665e\"],\n7: [\"#8c510a\",\"#d8b365\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#5ab4ac\",\"#01665e\"],\n8: [\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\"],\n9: [\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\"],\n10: [\"#543005\",\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\",\"#003c30\"],\n11: [\"#543005\",\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\",\"#003c30\"]\n},PRGn: {\n3: [\"#af8dc3\",\"#f7f7f7\",\"#7fbf7b\"],\n4: [\"#7b3294\",\"#c2a5cf\",\"#a6dba0\",\"#008837\"],\n5: [\"#7b3294\",\"#c2a5cf\",\"#f7f7f7\",\"#a6dba0\",\"#008837\"],\n6: [\"#762a83\",\"#af8dc3\",\"#e7d4e8\",\"#d9f0d3\",\"#7fbf7b\",\"#1b7837\"],\n7: [\"#762a83\",\"#af8dc3\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#7fbf7b\",\"#1b7837\"],\n8: [\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\"],\n9: [\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\"],\n10: [\"#40004b\",\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\",\"#00441b\"],\n11: [\"#40004b\",\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\",\"#00441b\"]\n},PiYG: {\n3: [\"#e9a3c9\",\"#f7f7f7\",\"#a1d76a\"],\n4: [\"#d01c8b\",\"#f1b6da\",\"#b8e186\",\"#4dac26\"],\n5: [\"#d01c8b\",\"#f1b6da\",\"#f7f7f7\",\"#b8e186\",\"#4dac26\"],\n6: [\"#c51b7d\",\"#e9a3c9\",\"#fde0ef\",\"#e6f5d0\",\"#a1d76a\",\"#4d9221\"],\n7: [\"#c51b7d\",\"#e9a3c9\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#a1d76a\",\"#4d9221\"],\n8: [\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\"],\n9: [\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\"],\n10: [\"#8e0152\",\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\",\"#276419\"],\n11: [\"#8e0152\",\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\",\"#276419\"]\n},RdBu: {\n3: [\"#ef8a62\",\"#f7f7f7\",\"#67a9cf\"],\n4: [\"#ca0020\",\"#f4a582\",\"#92c5de\",\"#0571b0\"],\n5: [\"#ca0020\",\"#f4a582\",\"#f7f7f7\",\"#92c5de\",\"#0571b0\"],\n6: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#d1e5f0\",\"#67a9cf\",\"#2166ac\"],\n7: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#67a9cf\",\"#2166ac\"],\n8: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\"],\n9: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\"],\n10: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\",\"#053061\"],\n11: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\",\"#053061\"]\n},RdGy: {\n3: [\"#ef8a62\",\"#ffffff\",\"#999999\"],\n4: [\"#ca0020\",\"#f4a582\",\"#bababa\",\"#404040\"],\n5: [\"#ca0020\",\"#f4a582\",\"#ffffff\",\"#bababa\",\"#404040\"],\n6: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#e0e0e0\",\"#999999\",\"#4d4d4d\"],\n7: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#999999\",\"#4d4d4d\"],\n8: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\"],\n9: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\"],\n10: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\",\"#1a1a1a\"],\n11: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\",\"#1a1a1a\"]\n},RdYlBu: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#91bfdb\"],\n4: [\"#d7191c\",\"#fdae61\",\"#abd9e9\",\"#2c7bb6\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#abd9e9\",\"#2c7bb6\"],\n6: [\"#d73027\",\"#fc8d59\",\"#fee090\",\"#e0f3f8\",\"#91bfdb\",\"#4575b4\"],\n7: [\"#d73027\",\"#fc8d59\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#91bfdb\",\"#4575b4\"],\n8: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\"],\n9: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\"],\n10: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\",\"#313695\"],\n11: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\",\"#313695\"]\n},Spectral: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#99d594\"],\n4: [\"#d7191c\",\"#fdae61\",\"#abdda4\",\"#2b83ba\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#abdda4\",\"#2b83ba\"],\n6: [\"#d53e4f\",\"#fc8d59\",\"#fee08b\",\"#e6f598\",\"#99d594\",\"#3288bd\"],\n7: [\"#d53e4f\",\"#fc8d59\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#99d594\",\"#3288bd\"],\n8: [\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\"],\n9: [\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\"],\n10: [\"#9e0142\",\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\",\"#5e4fa2\"],\n11: [\"#9e0142\",\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\",\"#5e4fa2\"]\n},RdYlGn: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#91cf60\"],\n4: [\"#d7191c\",\"#fdae61\",\"#a6d96a\",\"#1a9641\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#a6d96a\",\"#1a9641\"],\n6: [\"#d73027\",\"#fc8d59\",\"#fee08b\",\"#d9ef8b\",\"#91cf60\",\"#1a9850\"],\n7: [\"#d73027\",\"#fc8d59\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#91cf60\",\"#1a9850\"],\n8: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\"],\n9: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\"],\n10: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\",\"#006837\"],\n11: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\",\"#006837\"]\n},Accent: {\n3: [\"#7fc97f\",\"#beaed4\",\"#fdc086\"],\n4: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\"],\n5: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\"],\n6: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\"],\n7: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\",\"#bf5b17\"],\n8: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\",\"#bf5b17\",\"#666666\"]\n},Dark2: {\n3: [\"#1b9e77\",\"#d95f02\",\"#7570b3\"],\n4: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\"],\n5: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\"],\n6: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\"],\n7: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\",\"#a6761d\"],\n8: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\",\"#a6761d\",\"#666666\"]\n},Paired: {\n3: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\"],\n4: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\"],\n5: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\"],\n6: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\"],\n7: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\"],\n8: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\"],\n9: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\"],\n10: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\"],\n11: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\",\"#ffff99\"],\n12: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\",\"#ffff99\",\"#b15928\"]\n},Pastel1: {\n3: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\"],\n4: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\"],\n5: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\"],\n6: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\"],\n7: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\"],\n8: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\"#fddaec\"],\n9: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\"#fddaec\",\"#f2f2f2\"]\n},Pastel2: {\n3: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\"],\n4: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\"],\n5: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\"],\n6: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\"],\n7: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\",\"#f1e2cc\"],\n8: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\",\"#f1e2cc\",\"#cccccc\"]\n},Set1: {\n3: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\"],\n4: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\"],\n5: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\"],\n6: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\"],\n7: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\"],\n8: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\",\"#f781bf\"],\n9: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\",\"#f781bf\",\"#999999\"]\n},Set2: {\n3: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\"],\n4: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\"],\n5: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\"],\n6: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\"],\n7: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\",\"#e5c494\"],\n8: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\",\"#e5c494\",\"#b3b3b3\"]\n},Set3: {\n3: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\"],\n4: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\"],\n5: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\"],\n6: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\"],\n7: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\"],\n8: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\"],\n9: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\"],\n10: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\"],\n11: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\",\"#ccebc5\"],\n12: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\",\"#ccebc5\",\"#ffed6f\"]\n}};\n\nif (typeof define === \"function\" && define.amd) {\n    define(colorbrewer);\n} else if (typeof module === \"object\" && module.exports) {\n    module.exports = colorbrewer;\n} else {\n    this.colorbrewer = colorbrewer;\n}\n\n}();\n\n},{}],3:[function(require,module,exports){\nmodule.exports = require('./colorbrewer.js');\n\n},{\"./colorbrewer.js\":2}],4:[function(require,module,exports){\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.color = {}));\n}(this, function (exports) { 'use strict';\n\n  function deltaHue(h1, h0) {\n    var delta = h1 - h0;\n    return delta > 180 || delta < -180\n        ? delta - 360 * Math.round(delta / 360)\n        : delta;\n  }\n\n  function Color() {}var reHex3 = /^#([0-9a-f]{3})$/;\n  var reHex6 = /^#([0-9a-f]{6})$/;\n  var reRgbInteger = /^rgb\\(\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*\\)$/;\n  var reRgbPercent = /^rgb\\(\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n  var reHslPercent = /^hsl\\(\\s*([-+]?\\d+(?:\\.\\d+)?)\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n  color.prototype = Color.prototype = {\n    displayable: function() {\n      return this.rgb().displayable();\n    },\n    toString: function() {\n      return this.rgb() + \"\";\n    }\n  };\n\n  function color(format) {\n    var m;\n    format = (format + \"\").trim().toLowerCase();\n    return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf))) // #f00\n        : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000\n        : (m = reRgbInteger.exec(format)) ? rgb(m[1], m[2], m[3]) // rgb(255,0,0)\n        : (m = reRgbPercent.exec(format)) ? rgb(m[1] * 2.55, m[2] * 2.55, m[3] * 2.55) // rgb(100%,0%,0%)\n        : (m = reHslPercent.exec(format)) ? hsl(m[1], m[2] * .01, m[3] * .01) // hsl(120,50%,50%)\n        : named.hasOwnProperty(format) ? rgbn(named[format])\n        : null;\n  }function rgbn(n) {\n    return rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff);\n  }\n\n  var named = {\n    aliceblue: 0xf0f8ff,\n    antiquewhite: 0xfaebd7,\n    aqua: 0x00ffff,\n    aquamarine: 0x7fffd4,\n    azure: 0xf0ffff,\n    beige: 0xf5f5dc,\n    bisque: 0xffe4c4,\n    black: 0x000000,\n    blanchedalmond: 0xffebcd,\n    blue: 0x0000ff,\n    blueviolet: 0x8a2be2,\n    brown: 0xa52a2a,\n    burlywood: 0xdeb887,\n    cadetblue: 0x5f9ea0,\n    chartreuse: 0x7fff00,\n    chocolate: 0xd2691e,\n    coral: 0xff7f50,\n    cornflowerblue: 0x6495ed,\n    cornsilk: 0xfff8dc,\n    crimson: 0xdc143c,\n    cyan: 0x00ffff,\n    darkblue: 0x00008b,\n    darkcyan: 0x008b8b,\n    darkgoldenrod: 0xb8860b,\n    darkgray: 0xa9a9a9,\n    darkgreen: 0x006400,\n    darkgrey: 0xa9a9a9,\n    darkkhaki: 0xbdb76b,\n    darkmagenta: 0x8b008b,\n    darkolivegreen: 0x556b2f,\n    darkorange: 0xff8c00,\n    darkorchid: 0x9932cc,\n    darkred: 0x8b0000,\n    darksalmon: 0xe9967a,\n    darkseagreen: 0x8fbc8f,\n    darkslateblue: 0x483d8b,\n    darkslategray: 0x2f4f4f,\n    darkslategrey: 0x2f4f4f,\n    darkturquoise: 0x00ced1,\n    darkviolet: 0x9400d3,\n    deeppink: 0xff1493,\n    deepskyblue: 0x00bfff,\n    dimgray: 0x696969,\n    dimgrey: 0x696969,\n    dodgerblue: 0x1e90ff,\n    firebrick: 0xb22222,\n    floralwhite: 0xfffaf0,\n    forestgreen: 0x228b22,\n    fuchsia: 0xff00ff,\n    gainsboro: 0xdcdcdc,\n    ghostwhite: 0xf8f8ff,\n    gold: 0xffd700,\n    goldenrod: 0xdaa520,\n    gray: 0x808080,\n    green: 0x008000,\n    greenyellow: 0xadff2f,\n    grey: 0x808080,\n    honeydew: 0xf0fff0,\n    hotpink: 0xff69b4,\n    indianred: 0xcd5c5c,\n    indigo: 0x4b0082,\n    ivory: 0xfffff0,\n    khaki: 0xf0e68c,\n    lavender: 0xe6e6fa,\n    lavenderblush: 0xfff0f5,\n    lawngreen: 0x7cfc00,\n    lemonchiffon: 0xfffacd,\n    lightblue: 0xadd8e6,\n    lightcoral: 0xf08080,\n    lightcyan: 0xe0ffff,\n    lightgoldenrodyellow: 0xfafad2,\n    lightgray: 0xd3d3d3,\n    lightgreen: 0x90ee90,\n    lightgrey: 0xd3d3d3,\n    lightpink: 0xffb6c1,\n    lightsalmon: 0xffa07a,\n    lightseagreen: 0x20b2aa,\n    lightskyblue: 0x87cefa,\n    lightslategray: 0x778899,\n    lightslategrey: 0x778899,\n    lightsteelblue: 0xb0c4de,\n    lightyellow: 0xffffe0,\n    lime: 0x00ff00,\n    limegreen: 0x32cd32,\n    linen: 0xfaf0e6,\n    magenta: 0xff00ff,\n    maroon: 0x800000,\n    mediumaquamarine: 0x66cdaa,\n    mediumblue: 0x0000cd,\n    mediumorchid: 0xba55d3,\n    mediumpurple: 0x9370db,\n    mediumseagreen: 0x3cb371,\n    mediumslateblue: 0x7b68ee,\n    mediumspringgreen: 0x00fa9a,\n    mediumturquoise: 0x48d1cc,\n    mediumvioletred: 0xc71585,\n    midnightblue: 0x191970,\n    mintcream: 0xf5fffa,\n    mistyrose: 0xffe4e1,\n    moccasin: 0xffe4b5,\n    navajowhite: 0xffdead,\n    navy: 0x000080,\n    oldlace: 0xfdf5e6,\n    olive: 0x808000,\n    olivedrab: 0x6b8e23,\n    orange: 0xffa500,\n    orangered: 0xff4500,\n    orchid: 0xda70d6,\n    palegoldenrod: 0xeee8aa,\n    palegreen: 0x98fb98,\n    paleturquoise: 0xafeeee,\n    palevioletred: 0xdb7093,\n    papayawhip: 0xffefd5,\n    peachpuff: 0xffdab9,\n    peru: 0xcd853f,\n    pink: 0xffc0cb,\n    plum: 0xdda0dd,\n    powderblue: 0xb0e0e6,\n    purple: 0x800080,\n    rebeccapurple: 0x663399,\n    red: 0xff0000,\n    rosybrown: 0xbc8f8f,\n    royalblue: 0x4169e1,\n    saddlebrown: 0x8b4513,\n    salmon: 0xfa8072,\n    sandybrown: 0xf4a460,\n    seagreen: 0x2e8b57,\n    seashell: 0xfff5ee,\n    sienna: 0xa0522d,\n    silver: 0xc0c0c0,\n    skyblue: 0x87ceeb,\n    slateblue: 0x6a5acd,\n    slategray: 0x708090,\n    slategrey: 0x708090,\n    snow: 0xfffafa,\n    springgreen: 0x00ff7f,\n    steelblue: 0x4682b4,\n    tan: 0xd2b48c,\n    teal: 0x008080,\n    thistle: 0xd8bfd8,\n    tomato: 0xff6347,\n    turquoise: 0x40e0d0,\n    violet: 0xee82ee,\n    wheat: 0xf5deb3,\n    white: 0xffffff,\n    whitesmoke: 0xf5f5f5,\n    yellow: 0xffff00,\n    yellowgreen: 0x9acd32\n  };\n\n  var darker = .7;\n  var brighter = 1 / darker;\n\n  function rgb(r, g, b) {\n    if (arguments.length === 1) {\n      if (!(r instanceof Color)) r = color(r);\n      if (r) {\n        r = r.rgb();\n        b = r.b;\n        g = r.g;\n        r = r.r;\n      } else {\n        r = g = b = NaN;\n      }\n    }\n    return new Rgb(r, g, b);\n  }function Rgb(r, g, b) {\n    this.r = +r;\n    this.g = +g;\n    this.b = +b;\n  }var ____prototype = rgb.prototype = Rgb.prototype = new Color;\n\n  ____prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k);\n  };\n\n  ____prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k);\n  };\n\n  ____prototype.rgb = function() {\n    return this;\n  };\n\n  ____prototype.displayable = function() {\n    return (0 <= this.r && this.r <= 255)\n        && (0 <= this.g && this.g <= 255)\n        && (0 <= this.b && this.b <= 255);\n  };\n\n  ____prototype.toString = function() {\n    return _format(this.r, this.g, this.b);\n  };\n\n  function _format(r, g, b) {\n    return \"#\"\n        + (isNaN(r) ? \"00\" : (r = Math.round(r)) < 16 ? \"0\" + Math.max(0, r).toString(16) : Math.min(255, r).toString(16))\n        + (isNaN(g) ? \"00\" : (g = Math.round(g)) < 16 ? \"0\" + Math.max(0, g).toString(16) : Math.min(255, g).toString(16))\n        + (isNaN(b) ? \"00\" : (b = Math.round(b)) < 16 ? \"0\" + Math.max(0, b).toString(16) : Math.min(255, b).toString(16));\n  }\n\n  function hsl(h, s, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Hsl) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n      } else {\n        if (!(h instanceof Color)) h = color(h);\n        if (h) {\n          if (h instanceof Hsl) return h;\n          h = h.rgb();\n          var r = h.r / 255,\n              g = h.g / 255,\n              b = h.b / 255,\n              min = Math.min(r, g, b),\n              max = Math.max(r, g, b),\n              range = max - min;\n          l = (max + min) / 2;\n          if (range) {\n            s = l < .5 ? range / (max + min) : range / (2 - max - min);\n            if (r === max) h = (g - b) / range + (g < b) * 6;\n            else if (g === max) h = (b - r) / range + 2;\n            else h = (r - g) / range + 4;\n            h *= 60;\n          } else {\n            h = NaN;\n            s = l > 0 && l < 1 ? 0 : h;\n          }\n        } else {\n          h = s = l = NaN;\n        }\n      }\n    }\n    return new Hsl(h, s, l);\n  }function Hsl(h, s, l) {\n    this.h = +h;\n    this.s = +s;\n    this.l = +l;\n  }var ___prototype = hsl.prototype = Hsl.prototype = new Color;\n\n  ___prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Hsl(this.h, this.s, this.l * k);\n  };\n\n  ___prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Hsl(this.h, this.s, this.l * k);\n  };\n\n  ___prototype.rgb = function() {\n    var h = this.h % 360 + (this.h < 0) * 360,\n        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,\n        l = this.l,\n        m2 = l + (l < .5 ? l : 1 - l) * s,\n        m1 = 2 * l - m2;\n    return new Rgb(\n      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),\n      hsl2rgb(h, m1, m2),\n      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2)\n    );\n  };\n\n  ___prototype.displayable = function() {\n    return (0 <= this.s && this.s <= 1 || isNaN(this.s))\n        && (0 <= this.l && this.l <= 1);\n  };\n\n  /* From FvD 13.37, CSS Color Module Level 3 */\n  function hsl2rgb(h, m1, m2) {\n    return (h < 60 ? m1 + (m2 - m1) * h / 60\n        : h < 180 ? m2\n        : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60\n        : m1) * 255;\n  }\n\n  var Kn = 18;\n\n  var Xn = 0.950470;\n  var Yn = 1;\n  var Zn = 1.088830;\n  var t0 = 4 / 29;\n  var t1 = 6 / 29;\n  var t2 = 3 * t1 * t1;\n  var t3 = t1 * t1 * t1;\n  function lab(l, a, b) {\n    if (arguments.length === 1) {\n      if (l instanceof Lab) {\n        b = l.b;\n        a = l.a;\n        l = l.l;\n      } else if (l instanceof Hcl) {\n        var h = l.h * deg2rad;\n        b = Math.sin(h) * l.c;\n        a = Math.cos(h) * l.c;\n        l = l.l;\n      } else {\n        if (!(l instanceof Rgb)) l = rgb(l);\n        var r = rgb2xyz(l.r),\n            g = rgb2xyz(l.g),\n            b = rgb2xyz(l.b),\n            x = xyz2lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / Xn),\n            y = xyz2lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / Yn),\n            z = xyz2lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / Zn);\n        b = 200 * (y - z);\n        a = 500 * (x - y);\n        l = 116 * y - 16;\n      }\n    }\n    return new Lab(l, a, b);\n  }function Lab(l, a, b) {\n    this.l = +l;\n    this.a = +a;\n    this.b = +b;\n  }var __prototype = lab.prototype = Lab.prototype = new Color;\n\n  __prototype.brighter = function(k) {\n    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b);\n  };\n\n  __prototype.darker = function(k) {\n    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b);\n  };\n\n  __prototype.rgb = function() {\n    var y = (this.l + 16) / 116,\n        x = isNaN(this.a) ? y : y + this.a / 500,\n        z = isNaN(this.b) ? y : y - this.b / 200;\n    y = Yn * lab2xyz(y);\n    x = Xn * lab2xyz(x);\n    z = Zn * lab2xyz(z);\n    return new Rgb(\n      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB\n      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),\n      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z)\n    );\n  };\n\n  function xyz2lab(t) {\n    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n  }\n\n  function lab2xyz(t) {\n    return t > t1 ? t * t * t : t2 * (t - t0);\n  }\n\n  function xyz2rgb(x) {\n    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n  }\n\n  function rgb2xyz(x) {\n    return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n  }\n\n  var deg2rad = Math.PI / 180;\n  var rad2deg = 180 / Math.PI;\n\n  function hcl(h, c, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Hcl) {\n        l = h.l;\n        c = h.c;\n        h = h.h;\n      } else {\n        if (!(h instanceof Lab)) h = lab(h);\n        l = h.l;\n        c = Math.sqrt(h.a * h.a + h.b * h.b);\n        h = Math.atan2(h.b, h.a) * rad2deg;\n        if (h < 0) h += 360;\n      }\n    }\n    return new Hcl(h, c, l);\n  }function Hcl(h, c, l) {\n    this.h = +h;\n    this.c = +c;\n    this.l = +l;\n  }var _prototype = hcl.prototype = Hcl.prototype = new Color;\n\n  _prototype.brighter = function(k) {\n    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k));\n  };\n\n  _prototype.darker = function(k) {\n    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k));\n  };\n\n  _prototype.rgb = function() {\n    return lab(this).rgb();\n  };\n\n  var A = -0.14861;\n  var B = +1.78277;\n  var C = -0.29227;\n  var D = -0.90649;\n  var E = +1.97294;\n  var ED = E * D;\n  var EB = E * B;\n  var BC_DA = B * C - D * A;\n  function cubehelix(h, s, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Cubehelix) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n      } else {\n        if (!(h instanceof Rgb)) h = rgb(h);\n        var r = h.r / 255, g = h.g / 255, b = h.b / 255;\n        l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB);\n        var bl = b - l, k = (E * (g - l) - C * bl) / D;\n        s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)); // NaN if l=0 or l=1\n        h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;\n        if (h < 0) h += 360;\n      }\n    }\n    return new Cubehelix(h, s, l);\n  }function Cubehelix(h, s, l) {\n    this.h = +h;\n    this.s = +s;\n    this.l = +l;\n  }var prototype = cubehelix.prototype = Cubehelix.prototype = new Color;\n\n  prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Cubehelix(this.h, this.s, this.l * k);\n  };\n\n  prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Cubehelix(this.h, this.s, this.l * k);\n  };\n\n  prototype.rgb = function() {\n    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,\n        l = +this.l,\n        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),\n        cosh = Math.cos(h),\n        sinh = Math.sin(h);\n    return new Rgb(\n      255 * (l + a * (A * cosh + B * sinh)),\n      255 * (l + a * (C * cosh + D * sinh)),\n      255 * (l + a * (E * cosh))\n    );\n  };\n\n  function interpolateCubehelixGamma(gamma) {\n    return function(a, b) {\n      a = cubehelix(a);\n      b = cubehelix(b);\n      var ah = isNaN(a.h) ? b.h : a.h,\n          as = isNaN(a.s) ? b.s : a.s,\n          al = a.l,\n          bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n          bs = isNaN(b.s) ? 0 : b.s - as,\n          bl = b.l - al;\n      return function(t) {\n        a.h = ah + bh * t;\n        a.s = as + bs * t;\n        a.l = al + bl * Math.pow(t, gamma);\n        return a + \"\";\n      };\n    };\n  }\n\n  function interpolateCubehelixGammaLong(gamma) {\n    return function(a, b) {\n      a = cubehelix(a);\n      b = cubehelix(b);\n      var ah = isNaN(a.h) ? b.h : a.h,\n          as = isNaN(a.s) ? b.s : a.s,\n          al = a.l,\n          bh = isNaN(b.h) ? 0 : b.h - ah,\n          bs = isNaN(b.s) ? 0 : b.s - as,\n          bl = b.l - al;\n      return function(t) {\n        a.h = ah + bh * t;\n        a.s = as + bs * t;\n        a.l = al + bl * Math.pow(t, gamma);\n        return a + \"\";\n      };\n    };\n  }\n\n  function interpolateHclLong(a, b) {\n    a = hcl(a);\n    b = hcl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        ac = isNaN(a.c) ? b.c : a.c,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : b.h - ah,\n        bc = isNaN(b.c) ? 0 : b.c - ac,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.c = ac + bc * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHcl(a, b) {\n    a = hcl(a);\n    b = hcl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        ac = isNaN(a.c) ? b.c : a.c,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n        bc = isNaN(b.c) ? 0 : b.c - ac,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.c = ac + bc * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateLab(a, b) {\n    a = lab(a);\n    b = lab(b);\n    var al = a.l,\n        aa = a.a,\n        ab = a.b,\n        bl = b.l - al,\n        ba = b.a - aa,\n        bb = b.b - ab;\n    return function(t) {\n      a.l = al + bl * t;\n      a.a = aa + ba * t;\n      a.b = ab + bb * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHslLong(a, b) {\n    a = hsl(a);\n    b = hsl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : b.h - ah,\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHsl(a, b) {\n    a = hsl(a);\n    b = hsl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateRgb(a, b) {\n    a = rgb(a);\n    b = rgb(b);\n    var ar = a.r,\n        ag = a.g,\n        ab = a.b,\n        br = b.r - ar,\n        bg = b.g - ag,\n        bb = b.b - ab;\n    return function(t) {\n      return _format(Math.round(ar + br * t), Math.round(ag + bg * t), Math.round(ab + bb * t));\n    };\n  }\n\n  var interpolateCubehelix = interpolateCubehelixGamma(1);\n  var interpolateCubehelixLong = interpolateCubehelixGammaLong(1);\n\n  exports.interpolateCubehelix = interpolateCubehelix;\n  exports.interpolateCubehelixLong = interpolateCubehelixLong;\n  exports.color = color;\n  exports.rgb = rgb;\n  exports.hsl = hsl;\n  exports.lab = lab;\n  exports.hcl = hcl;\n  exports.cubehelix = cubehelix;\n  exports.interpolateRgb = interpolateRgb;\n  exports.interpolateHsl = interpolateHsl;\n  exports.interpolateHslLong = interpolateHslLong;\n  exports.interpolateLab = interpolateLab;\n  exports.interpolateHcl = interpolateHcl;\n  exports.interpolateHclLong = interpolateHclLong;\n  exports.interpolateCubehelixGamma = interpolateCubehelixGamma;\n  exports.interpolateCubehelixGammaLong = interpolateCubehelixGammaLong;\n\n}));\n},{}],5:[function(require,module,exports){\nif (typeof Map === \"undefined\") {\n  Map = function() { this.clear(); };\n  Map.prototype = {\n    set: function(k, v) { this._[k] = v; return this; },\n    get: function(k) { return this._[k]; },\n    has: function(k) { return k in this._; },\n    delete: function(k) { return k in this._ && delete this._[k]; },\n    clear: function() { this._ = Object.create(null); },\n    get size() { var n = 0; for (var k in this._) ++n; return n; },\n    forEach: function(c) { for (var k in this._) c(this._[k], k, this); }\n  };\n} else (function() {\n  var m = new Map;\n  if (m.set(0, 0) !== m) {\n    m = m.set;\n    Map.prototype.set = function() { m.apply(this, arguments); return this; };\n  }\n})();\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.format = {}));\n}(this, function (exports) { 'use strict';\n\n  var zhCn = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  };\n\n  var ruRu = {\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0.\"]\n  };\n\n  var ptBr = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"R$\", \"\"]\n  };\n\n  var plPl = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"z\"]\n  };\n\n  var nlNl = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\\xa0\", \"\"]\n  };\n\n  var mkMk = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0.\"]\n  };\n\n  var jaJp = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  };\n\n  var itIt = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  };\n\n  var heIl = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  };\n\n  var frFr = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  };\n\n  var frCa = {\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"$\"]\n  };\n\n  var fiFi = {\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  };\n\n  var esEs = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  };\n\n  var enUs = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"$\", \"\"]\n  };\n\n  var enGb = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  };\n\n  var enCa = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"$\", \"\"]\n  };\n\n  var deDe = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  };\n\n  var caEs = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  };\n\n\n  // Computes the decimal coefficient and exponent of the specified number x with\n  // significant digits p, where x is positive and p is in [1, 21] or undefined.\n  // For example, formatDecimal(1.23) returns [\"123\", 0].\n  function formatDecimal(x, p) {\n    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, Infinity\n    var i, coefficient = x.slice(0, i);\n\n    // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n    // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n    return [\n      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n      +x.slice(i + 1)\n    ];\n  }\n\n  function exponent(x) {\n    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;\n  }\n\n  var prefixExponent;\n\n  function formatPrefixAuto(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1],\n        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n        n = coefficient.length;\n    return i === n ? coefficient\n        : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n        : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n        : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimal(x, p + i - 1)[0]; // less than 1y!\n  }\n\n  function formatRounded(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1];\n    return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n        : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n  }\n\n  function formatDefault(x, p) {\n    x = x.toPrecision(p);\n\n    out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {\n      switch (x[i]) {\n        case \".\": i0 = i1 = i; break;\n        case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n        case \"e\": break out;\n        default: if (i0 > 0) i0 = 0; break;\n      }\n    }\n\n    return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;\n  }\n\n  var formatTypes = {\n    \"\": formatDefault,\n    \"%\": function(x, p) { return (x * 100).toFixed(p); },\n    \"b\": function(x) { return Math.round(x).toString(2); },\n    \"c\": function(x) { return x + \"\"; },\n    \"d\": function(x) { return Math.round(x).toString(10); },\n    \"e\": function(x, p) { return x.toExponential(p); },\n    \"f\": function(x, p) { return x.toFixed(p); },\n    \"g\": function(x, p) { return x.toPrecision(p); },\n    \"o\": function(x) { return Math.round(x).toString(8); },\n    \"p\": function(x, p) { return formatRounded(x * 100, p); },\n    \"r\": formatRounded,\n    \"s\": formatPrefixAuto,\n    \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n    \"x\": function(x) { return Math.round(x).toString(16); }\n  };\n\n\n  // [[fill]align][sign][symbol][0][width][,][.precision][type]\n  var re = /^(?:(.)?([<>=^]))?([+\\-\\( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?([a-z%])?$/i;\n\n  function formatSpecifier(specifier) {\n    return new FormatSpecifier(specifier);\n  }\n\n  function FormatSpecifier(specifier) {\n    if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n\n    var match,\n        fill = match[1] || \" \",\n        align = match[2] || \">\",\n        sign = match[3] || \"-\",\n        symbol = match[4] || \"\",\n        zero = !!match[5],\n        width = match[6] && +match[6],\n        comma = !!match[7],\n        precision = match[8] && +match[8].slice(1),\n        type = match[9] || \"\";\n\n    // The \"n\" type is an alias for \",g\".\n    if (type === \"n\") comma = true, type = \"g\";\n\n    // Map invalid types to the default format.\n    else if (!formatTypes[type]) type = \"\";\n\n    // If zero fill is specified, padding goes after sign and before digits.\n    if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n    this.fill = fill;\n    this.align = align;\n    this.sign = sign;\n    this.symbol = symbol;\n    this.zero = zero;\n    this.width = width;\n    this.comma = comma;\n    this.precision = precision;\n    this.type = type;\n  }\n\n  FormatSpecifier.prototype.toString = function() {\n    return this.fill\n        + this.align\n        + this.sign\n        + this.symbol\n        + (this.zero ? \"0\" : \"\")\n        + (this.width == null ? \"\" : Math.max(1, this.width | 0))\n        + (this.comma ? \",\" : \"\")\n        + (this.precision == null ? \"\" : \".\" + Math.max(0, this.precision | 0))\n        + this.type;\n  };\n\n  function formatGroup(grouping, thousands) {\n    return function(value, width) {\n      var i = value.length,\n          t = [],\n          j = 0,\n          g = grouping[0],\n          length = 0;\n\n      while (i > 0 && g > 0) {\n        if (length + g + 1 > width) g = Math.max(1, width - length);\n        t.push(value.substring(i -= g, i + g));\n        if ((length += g + 1) > width) break;\n        g = grouping[j = (j + 1) % grouping.length];\n      }\n\n      return t.reverse().join(thousands);\n    };\n  }\n\n  var prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\n  function identity(x) {\n    return x;\n  }\n\n  function locale(locale) {\n    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,\n        currency = locale.currency,\n        decimal = locale.decimal;\n\n    function format(specifier) {\n      specifier = formatSpecifier(specifier);\n\n      var fill = specifier.fill,\n          align = specifier.align,\n          sign = specifier.sign,\n          symbol = specifier.symbol,\n          zero = specifier.zero,\n          width = specifier.width,\n          comma = specifier.comma,\n          precision = specifier.precision,\n          type = specifier.type;\n\n      // Compute the prefix and suffix.\n      // For SI-prefix, the suffix is lazily computed.\n      var prefix = symbol === \"$\" ? currency[0] : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n          suffix = symbol === \"$\" ? currency[1] : /[%p]/.test(type) ? \"%\" : \"\";\n\n      // What format function should we use?\n      // Is this an integer type?\n      // Can this type generate exponential notation?\n      var formatType = formatTypes[type],\n          maybeSuffix = !type || /[defgprs%]/.test(type);\n\n      // Set the default precision if not specified,\n      // or clamp the specified precision to the supported range.\n      // For significant precision, it must be in [1, 21].\n      // For fixed precision, it must be in [0, 20].\n      precision = precision == null ? (type ? 6 : 12)\n          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n          : Math.max(0, Math.min(20, precision));\n\n      return function(value) {\n        var valuePrefix = prefix,\n            valueSuffix = suffix;\n\n        if (type === \"c\") {\n          valueSuffix = formatType(value) + valueSuffix;\n          value = \"\";\n        } else {\n          value = +value;\n\n          // Convert negative to positive, and compute the prefix.\n          // Note that -0 is not less than 0, but 1 / -0 is!\n          var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);\n\n          // Perform the initial formatting.\n          value = formatType(value, precision);\n\n          // Compute the prefix and suffix.\n          valuePrefix = (valueNegative ? (sign === \"(\" ? sign : \"-\") : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n          valueSuffix = valueSuffix + (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n          // Break the formatted value into the integer value part that can be\n          // grouped, and fractional or exponential suffix part that is not.\n          if (maybeSuffix) {\n            var i = -1, n = value.length, c;\n            while (++i < n) {\n              if (c = value.charCodeAt(i), 48 > c || c > 57) {\n                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n                value = value.slice(0, i);\n                break;\n              }\n            }\n          }\n        }\n\n        // If the fill character is not \"0\", grouping is applied before padding.\n        if (comma && !zero) value = group(value, Infinity);\n\n        // Compute the padding.\n        var length = valuePrefix.length + value.length + valueSuffix.length,\n            padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n        // If the fill character is \"0\", grouping is applied after padding.\n        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n        // Reconstruct the final output based on the desired alignment.\n        switch (align) {\n          case \"<\": return valuePrefix + value + valueSuffix + padding;\n          case \"=\": return valuePrefix + padding + value + valueSuffix;\n          case \"^\": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);\n        }\n        return padding + valuePrefix + value + valueSuffix;\n      };\n    }\n\n    function formatPrefix(specifier, value) {\n      var f = format((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,\n          k = Math.pow(10, -e),\n          prefix = prefixes[8 + e / 3];\n      return function(value) {\n        return f(k * value) + prefix;\n      };\n    }\n\n    return {\n      format: format,\n      formatPrefix: formatPrefix\n    };\n  }\n\n  function precisionRound(step, max) {\n    return Math.max(0, exponent(Math.abs(max)) - exponent(Math.abs(step))) + 1;\n  }\n\n  function precisionPrefix(step, value) {\n    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));\n  }\n\n  function precisionFixed(step) {\n    return Math.max(0, -exponent(Math.abs(step)));\n  }\n\n  var localeDefinitions = (new Map)\n      .set(\"ca-ES\", caEs)\n      .set(\"de-DE\", deDe)\n      .set(\"en-CA\", enCa)\n      .set(\"en-GB\", enGb)\n      .set(\"en-US\", enUs)\n      .set(\"es-ES\", esEs)\n      .set(\"fi-FI\", fiFi)\n      .set(\"fr-CA\", frCa)\n      .set(\"fr-FR\", frFr)\n      .set(\"he-IL\", heIl)\n      .set(\"it-IT\", itIt)\n      .set(\"ja-JP\", jaJp)\n      .set(\"mk-MK\", mkMk)\n      .set(\"nl-NL\", nlNl)\n      .set(\"pl-PL\", plPl)\n      .set(\"pt-BR\", ptBr)\n      .set(\"ru-RU\", ruRu)\n      .set(\"zh-CN\", zhCn);\n\n  var defaultLocale = locale(enUs);\n  exports.format = defaultLocale.format;\n  exports.formatPrefix = defaultLocale.formatPrefix;\n\n  function localeFormat(definition) {\n    if (typeof definition === \"string\") {\n      definition = localeDefinitions.get(definition);\n      if (!definition) return null;\n    }\n    return locale(definition);\n  }\n  ;\n\n  exports.localeFormat = localeFormat;\n  exports.formatSpecifier = formatSpecifier;\n  exports.precisionFixed = precisionFixed;\n  exports.precisionPrefix = precisionPrefix;\n  exports.precisionRound = precisionRound;\n\n}));\n},{}],6:[function(require,module,exports){\nif (typeof Map === \"undefined\") {\n  Map = function() { this.clear(); };\n  Map.prototype = {\n    set: function(k, v) { this._[k] = v; return this; },\n    get: function(k) { return this._[k]; },\n    has: function(k) { return k in this._; },\n    delete: function(k) { return k in this._ && delete this._[k]; },\n    clear: function() { this._ = Object.create(null); },\n    get size() { var n = 0; for (var k in this._) ++n; return n; },\n    forEach: function(c) { for (var k in this._) c(this._[k], k, this); }\n  };\n} else (function() {\n  var m = new Map;\n  if (m.set(0, 0) !== m) {\n    m = m.set;\n    Map.prototype.set = function() { m.apply(this, arguments); return this; };\n  }\n})();\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.timeFormat = {}));\n}(this, function (exports) { 'use strict';\n\n  var zhCn = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%Y/%-m/%-d\",\n    time: \"%H:%M:%S\",\n    periods: [\"\", \"\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  };\n\n  var ruRu = {\n    dateTime: \"%A, %e %B %Y . %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  };\n\n  var ptBr = {\n    dateTime: \"%A, %e de %B de %Y. %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Domingo\", \"Segunda\", \"Tera\", \"Quarta\", \"Quinta\", \"Sexta\", \"Sbado\"],\n    shortDays: [\"Dom\", \"Seg\", \"Ter\", \"Qua\", \"Qui\", \"Sex\", \"Sb\"],\n    months: [\"Janeiro\", \"Fevereiro\", \"Maro\", \"Abril\", \"Maio\", \"Junho\", \"Julho\", \"Agosto\", \"Setembro\", \"Outubro\", \"Novembro\", \"Dezembro\"],\n    shortMonths: [\"Jan\", \"Fev\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\"]\n  };\n\n  var plPl = {\n    dateTime: \"%A, %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Niedziela\", \"Poniedziaek\", \"Wtorek\", \"roda\", \"Czwartek\", \"Pitek\", \"Sobota\"],\n    shortDays: [\"Niedz.\", \"Pon.\", \"Wt.\", \"r.\", \"Czw.\", \"Pt.\", \"Sob.\"],\n    months: [\"Stycze\", \"Luty\", \"Marzec\", \"Kwiecie\", \"Maj\", \"Czerwiec\", \"Lipiec\", \"Sierpie\", \"Wrzesie\", \"Padziernik\", \"Listopad\", \"Grudzie\"],\n    shortMonths: [\"Stycz.\", \"Luty\", \"Marz.\", \"Kwie.\", \"Maj\", \"Czerw.\", \"Lipc.\", \"Sierp.\", \"Wrz.\", \"Padz.\", \"Listop.\", \"Grudz.\"]/* In Polish language abbraviated months are not commonly used so there is a dispute about the proper abbraviations. */\n  };\n\n  var nlNl = {\n    dateTime: \"%a %e %B %Y %T\",\n    date: \"%d-%m-%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"zondag\", \"maandag\", \"dinsdag\", \"woensdag\", \"donderdag\", \"vrijdag\", \"zaterdag\"],\n    shortDays: [\"zo\", \"ma\", \"di\", \"wo\", \"do\", \"vr\", \"za\"],\n    months: [\"januari\", \"februari\", \"maart\", \"april\", \"mei\", \"juni\", \"juli\", \"augustus\", \"september\", \"oktober\", \"november\", \"december\"],\n    shortMonths: [\"jan\", \"feb\", \"mrt\", \"apr\", \"mei\", \"jun\", \"jul\", \"aug\", \"sep\", \"okt\", \"nov\", \"dec\"]\n  };\n\n  var mkMk = {\n    dateTime: \"%A, %e %B %Y . %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  };\n\n  var itIt = {\n    dateTime: \"%A %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Domenica\", \"Luned\", \"Marted\", \"Mercoled\", \"Gioved\", \"Venerd\", \"Sabato\"],\n    shortDays: [\"Dom\", \"Lun\", \"Mar\", \"Mer\", \"Gio\", \"Ven\", \"Sab\"],\n    months: [\"Gennaio\", \"Febbraio\", \"Marzo\", \"Aprile\", \"Maggio\", \"Giugno\", \"Luglio\", \"Agosto\", \"Settembre\", \"Ottobre\", \"Novembre\", \"Dicembre\"],\n    shortMonths: [\"Gen\", \"Feb\", \"Mar\", \"Apr\", \"Mag\", \"Giu\", \"Lug\", \"Ago\", \"Set\", \"Ott\", \"Nov\", \"Dic\"]\n  };\n\n  var heIl = {\n    dateTime: \"%A, %e %B %Y %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  };\n\n  var frFr = {\n    dateTime: \"%A, le %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"],\n    shortDays: [\"dim.\", \"lun.\", \"mar.\", \"mer.\", \"jeu.\", \"ven.\", \"sam.\"],\n    months: [\"janvier\", \"fvrier\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"aot\", \"septembre\", \"octobre\", \"novembre\", \"dcembre\"],\n    shortMonths: [\"janv.\", \"fvr.\", \"mars\", \"avr.\", \"mai\", \"juin\", \"juil.\", \"aot\", \"sept.\", \"oct.\", \"nov.\", \"dc.\"]\n  };\n\n  var frCa = {\n    dateTime: \"%a %e %b %Y %X\",\n    date: \"%Y-%m-%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"\", \"\"],\n    days: [\"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"],\n    shortDays: [\"dim\", \"lun\", \"mar\", \"mer\", \"jeu\", \"ven\", \"sam\"],\n    months: [\"janvier\", \"fvrier\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"aot\", \"septembre\", \"octobre\", \"novembre\", \"dcembre\"],\n    shortMonths: [\"jan\", \"fv\", \"mar\", \"avr\", \"mai\", \"jui\", \"jul\", \"ao\", \"sep\", \"oct\", \"nov\", \"dc\"]\n  };\n\n  var fiFi = {\n    dateTime: \"%A, %-d. %Bta %Y klo %X\",\n    date: \"%-d.%-m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"a.m.\", \"p.m.\"],\n    days: [\"sunnuntai\", \"maanantai\", \"tiistai\", \"keskiviikko\", \"torstai\", \"perjantai\", \"lauantai\"],\n    shortDays: [\"Su\", \"Ma\", \"Ti\", \"Ke\", \"To\", \"Pe\", \"La\"],\n    months: [\"tammikuu\", \"helmikuu\", \"maaliskuu\", \"huhtikuu\", \"toukokuu\", \"keskuu\", \"heinkuu\", \"elokuu\", \"syyskuu\", \"lokakuu\", \"marraskuu\", \"joulukuu\"],\n    shortMonths: [\"Tammi\", \"Helmi\", \"Maalis\", \"Huhti\", \"Touko\", \"Kes\", \"Hein\", \"Elo\", \"Syys\", \"Loka\", \"Marras\", \"Joulu\"]\n  };\n\n  var esEs = {\n    dateTime: \"%A, %e de %B de %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"domingo\", \"lunes\", \"martes\", \"mircoles\", \"jueves\", \"viernes\", \"sbado\"],\n    shortDays: [\"dom\", \"lun\", \"mar\", \"mi\", \"jue\", \"vie\", \"sb\"],\n    months: [\"enero\", \"febrero\", \"marzo\", \"abril\", \"mayo\", \"junio\", \"julio\", \"agosto\", \"septiembre\", \"octubre\", \"noviembre\", \"diciembre\"],\n    shortMonths: [\"ene\", \"feb\", \"mar\", \"abr\", \"may\", \"jun\", \"jul\", \"ago\", \"sep\", \"oct\", \"nov\", \"dic\"]\n  };\n\n  var enUs = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%m/%d/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var enGb = {\n    dateTime: \"%a %e %b %X %Y\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var enCa = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%Y-%m-%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var deDe = {\n    dateTime: \"%A, der %e. %B %Y, %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Sonntag\", \"Montag\", \"Dienstag\", \"Mittwoch\", \"Donnerstag\", \"Freitag\", \"Samstag\"],\n    shortDays: [\"So\", \"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\", \"Sa\"],\n    months: [\"Januar\", \"Februar\", \"Mrz\", \"April\", \"Mai\", \"Juni\", \"Juli\", \"August\", \"September\", \"Oktober\", \"November\", \"Dezember\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mrz\", \"Apr\", \"Mai\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dez\"]\n  };\n\n  var caEs = {\n    dateTime: \"%A, %e de %B de %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"diumenge\", \"dilluns\", \"dimarts\", \"dimecres\", \"dijous\", \"divendres\", \"dissabte\"],\n    shortDays: [\"dg.\", \"dl.\", \"dt.\", \"dc.\", \"dj.\", \"dv.\", \"ds.\"],\n    months: [\"gener\", \"febrer\", \"mar\", \"abril\", \"maig\", \"juny\", \"juliol\", \"agost\", \"setembre\", \"octubre\", \"novembre\", \"desembre\"],\n    shortMonths: [\"gen.\", \"febr.\", \"mar\", \"abr.\", \"maig\", \"juny\", \"jul.\", \"ag.\", \"set.\", \"oct.\", \"nov.\", \"des.\"]\n  };\n\n  var t0 = new Date;\n  var t1 = new Date;\n\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  }\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var sunday = weekday(0);\n  var monday = weekday(1);\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcSunday = utcWeekday(0);\n  var utcMonday = utcWeekday(1);\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  function localDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n      date.setFullYear(d.y);\n      return date;\n    }\n    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n  }\n\n  function utcDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n      date.setUTCFullYear(d.y);\n      return date;\n    }\n    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n  }\n\n  function newYear(y) {\n    return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};\n  }\n\n  function locale(locale) {\n    var locale_dateTime = locale.dateTime,\n        locale_date = locale.date,\n        locale_time = locale.time,\n        locale_periods = locale.periods,\n        locale_weekdays = locale.days,\n        locale_shortWeekdays = locale.shortDays,\n        locale_months = locale.months,\n        locale_shortMonths = locale.shortMonths;\n\n    var periodLookup = formatLookup(locale_periods),\n        weekdayRe = formatRe(locale_weekdays),\n        weekdayLookup = formatLookup(locale_weekdays),\n        shortWeekdayRe = formatRe(locale_shortWeekdays),\n        shortWeekdayLookup = formatLookup(locale_shortWeekdays),\n        monthRe = formatRe(locale_months),\n        monthLookup = formatLookup(locale_months),\n        shortMonthRe = formatRe(locale_shortMonths),\n        shortMonthLookup = formatLookup(locale_shortMonths);\n\n    var formats = {\n      \"a\": formatShortWeekday,\n      \"A\": formatWeekday,\n      \"b\": formatShortMonth,\n      \"B\": formatMonth,\n      \"c\": null,\n      \"d\": formatDayOfMonth,\n      \"e\": formatDayOfMonth,\n      \"H\": formatHour24,\n      \"I\": formatHour12,\n      \"j\": formatDayOfYear,\n      \"L\": formatMilliseconds,\n      \"m\": formatMonthNumber,\n      \"M\": formatMinutes,\n      \"p\": formatPeriod,\n      \"S\": formatSeconds,\n      \"U\": formatWeekNumberSunday,\n      \"w\": formatWeekdayNumber,\n      \"W\": formatWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatYear,\n      \"Y\": formatFullYear,\n      \"Z\": formatZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var utcFormats = {\n      \"a\": formatUTCShortWeekday,\n      \"A\": formatUTCWeekday,\n      \"b\": formatUTCShortMonth,\n      \"B\": formatUTCMonth,\n      \"c\": null,\n      \"d\": formatUTCDayOfMonth,\n      \"e\": formatUTCDayOfMonth,\n      \"H\": formatUTCHour24,\n      \"I\": formatUTCHour12,\n      \"j\": formatUTCDayOfYear,\n      \"L\": formatUTCMilliseconds,\n      \"m\": formatUTCMonthNumber,\n      \"M\": formatUTCMinutes,\n      \"p\": formatUTCPeriod,\n      \"S\": formatUTCSeconds,\n      \"U\": formatUTCWeekNumberSunday,\n      \"w\": formatUTCWeekdayNumber,\n      \"W\": formatUTCWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatUTCYear,\n      \"Y\": formatUTCFullYear,\n      \"Z\": formatUTCZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var parses = {\n      \"a\": parseShortWeekday,\n      \"A\": parseWeekday,\n      \"b\": parseShortMonth,\n      \"B\": parseMonth,\n      \"c\": parseLocaleDateTime,\n      \"d\": parseDayOfMonth,\n      \"e\": parseDayOfMonth,\n      \"H\": parseHour24,\n      \"I\": parseHour24,\n      \"j\": parseDayOfYear,\n      \"L\": parseMilliseconds,\n      \"m\": parseMonthNumber,\n      \"M\": parseMinutes,\n      \"p\": parsePeriod,\n      \"S\": parseSeconds,\n      \"U\": parseWeekNumberSunday,\n      \"w\": parseWeekdayNumber,\n      \"W\": parseWeekNumberMonday,\n      \"x\": parseLocaleDate,\n      \"X\": parseLocaleTime,\n      \"y\": parseYear,\n      \"Y\": parseFullYear,\n      \"Z\": parseZone,\n      \"%\": parseLiteralPercent\n    };\n\n    // These recursive directive definitions must be deferred.\n    formats.x = newFormat(locale_date, formats);\n    formats.X = newFormat(locale_time, formats);\n    formats.c = newFormat(locale_dateTime, formats);\n    utcFormats.x = newFormat(locale_date, utcFormats);\n    utcFormats.X = newFormat(locale_time, utcFormats);\n    utcFormats.c = newFormat(locale_dateTime, utcFormats);\n\n    function newFormat(specifier, formats) {\n      return function(date) {\n        var string = [],\n            i = -1,\n            j = 0,\n            n = specifier.length,\n            c,\n            pad,\n            format;\n\n        while (++i < n) {\n          if (specifier.charCodeAt(i) === 37) {\n            string.push(specifier.slice(j, i));\n            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);\n            if (format = formats[c]) c = format(date, pad == null ? (c === \"e\" ? \" \" : \"0\") : pad);\n            string.push(c);\n            j = i + 1;\n          }\n        }\n\n        string.push(specifier.slice(j, i));\n        return string.join(\"\");\n      };\n    }\n\n    function newParse(specifier, newDate) {\n      return function(string) {\n        var d = newYear(1900),\n            i = parseSpecifier(d, specifier, string, 0);\n        if (i != string.length) return null;\n\n        // The am-pm flag is 0 for AM, and 1 for PM.\n        if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\n        // If a time zone is specified, all fields are interpreted as UTC and then\n        // offset according to the specified time zone.\n        if (\"Z\" in d) {\n          if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n            var day = utcDate(newYear(d.y)).getUTCDay();\n            if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n            d.m = 0;\n            d.d = d.w + d.U * 7 - (day + 6) % 7;\n          }\n          d.H += d.Z / 100 | 0;\n          d.M += d.Z % 100;\n          return utcDate(d);\n        }\n\n        // Otherwise, all fields are in local time.\n        if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n          var day = newDate(newYear(d.y)).getDay();\n          if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n          d.m = 0;\n          d.d = d.w + d.U * 7 - (day + 6) % 7;\n        }\n        return newDate(d);\n      };\n    }\n\n    function parseSpecifier(d, specifier, string, j) {\n      var i = 0,\n          n = specifier.length,\n          m = string.length,\n          c,\n          parse;\n\n      while (i < n) {\n        if (j >= m) return -1;\n        c = specifier.charCodeAt(i++);\n        if (c === 37) {\n          c = specifier.charAt(i++);\n          parse = parses[c in pads ? specifier.charAt(i++) : c];\n          if (!parse || ((j = parse(d, string, j)) < 0)) return -1;\n        } else if (c != string.charCodeAt(j++)) {\n          return -1;\n        }\n      }\n\n      return j;\n    }\n\n    function parseShortWeekday(d, string, i) {\n      var n = shortWeekdayRe.exec(string.slice(i));\n      return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseWeekday(d, string, i) {\n      var n = weekdayRe.exec(string.slice(i));\n      return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseShortMonth(d, string, i) {\n      var n = shortMonthRe.exec(string.slice(i));\n      return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseMonth(d, string, i) {\n      var n = monthRe.exec(string.slice(i));\n      return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseLocaleDateTime(d, string, i) {\n      return parseSpecifier(d, locale_dateTime, string, i);\n    }\n\n    function parseLocaleDate(d, string, i) {\n      return parseSpecifier(d, locale_date, string, i);\n    }\n\n    function parseLocaleTime(d, string, i) {\n      return parseSpecifier(d, locale_time, string, i);\n    }\n\n    function parsePeriod(d, string, i) {\n      var n = periodLookup.get(string.slice(i, i += 2).toLowerCase());\n      return n == null ? -1 : (d.p = n, i);\n    }\n\n    function formatShortWeekday(d) {\n      return locale_shortWeekdays[d.getDay()];\n    }\n\n    function formatWeekday(d) {\n      return locale_weekdays[d.getDay()];\n    }\n\n    function formatShortMonth(d) {\n      return locale_shortMonths[d.getMonth()];\n    }\n\n    function formatMonth(d) {\n      return locale_months[d.getMonth()];\n    }\n\n    function formatPeriod(d) {\n      return locale_periods[+(d.getHours() >= 12)];\n    }\n\n    function formatUTCShortWeekday(d) {\n      return locale_shortWeekdays[d.getUTCDay()];\n    }\n\n    function formatUTCWeekday(d) {\n      return locale_weekdays[d.getUTCDay()];\n    }\n\n    function formatUTCShortMonth(d) {\n      return locale_shortMonths[d.getUTCMonth()];\n    }\n\n    function formatUTCMonth(d) {\n      return locale_months[d.getUTCMonth()];\n    }\n\n    function formatUTCPeriod(d) {\n      return locale_periods[+(d.getUTCHours() >= 12)];\n    }\n\n    return {\n      format: function(specifier) {\n        var f = newFormat(specifier += \"\", formats);\n        f.parse = newParse(specifier, localDate);\n        f.toString = function() { return specifier; };\n        return f;\n      },\n      utcFormat: function(specifier) {\n        var f = newFormat(specifier += \"\", utcFormats);\n        f.parse = newParse(specifier, utcDate);\n        f.toString = function() { return specifier; };\n        return f;\n      }\n    };\n  }\n\n  var pads = {\"-\": \"\", \"_\": \" \", \"0\": \"0\"};\n  var numberRe = /^\\s*\\d+/;\n  var percentRe = /^%/;\n  var requoteRe = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\n  function pad(value, fill, width) {\n    var sign = value < 0 ? \"-\" : \"\",\n        string = (sign ? -value : value) + \"\",\n        length = string.length;\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n  }\n\n  function requote(s) {\n    return s.replace(requoteRe, \"\\\\$&\");\n  }\n\n  function formatRe(names) {\n    return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n  }\n\n  function formatLookup(names) {\n    var map = new Map, i = -1, n = names.length;\n    while (++i < n) map.set(names[i].toLowerCase(), i);\n    return map;\n  }\n\n  function parseWeekdayNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 1));\n    return n ? (d.w = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberSunday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.U = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberMonday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.W = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseFullYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 4));\n    return n ? (d.y = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n  }\n\n  function parseZone(d, string, i) {\n    return /^[+-]\\d{4}$/.test(string = string.slice(i, i + 5))\n        ? (d.Z = -string, i + 5) // sign differs from getTimezoneOffset!\n        : -1;\n  }\n\n  function parseMonthNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n  }\n\n  function parseDayOfMonth(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseDayOfYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseHour24(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.H = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMinutes(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.M = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseSeconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.S = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMilliseconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.L = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseLiteralPercent(d, string, i) {\n    var n = percentRe.exec(string.slice(i, i + 1));\n    return n ? i + n[0].length : -1;\n  }\n\n  function formatDayOfMonth(d, p) {\n    return pad(d.getDate(), p, 2);\n  }\n\n  function formatHour24(d, p) {\n    return pad(d.getHours(), p, 2);\n  }\n\n  function formatHour12(d, p) {\n    return pad(d.getHours() % 12 || 12, p, 2);\n  }\n\n  function formatDayOfYear(d, p) {\n    return pad(1 + day.count(year(d), d), p, 3);\n  }\n\n  function formatMilliseconds(d, p) {\n    return pad(d.getMilliseconds(), p, 3);\n  }\n\n  function formatMonthNumber(d, p) {\n    return pad(d.getMonth() + 1, p, 2);\n  }\n\n  function formatMinutes(d, p) {\n    return pad(d.getMinutes(), p, 2);\n  }\n\n  function formatSeconds(d, p) {\n    return pad(d.getSeconds(), p, 2);\n  }\n\n  function formatWeekNumberSunday(d, p) {\n    return pad(sunday.count(year(d), d), p, 2);\n  }\n\n  function formatWeekdayNumber(d) {\n    return d.getDay();\n  }\n\n  function formatWeekNumberMonday(d, p) {\n    return pad(monday.count(year(d), d), p, 2);\n  }\n\n  function formatYear(d, p) {\n    return pad(d.getFullYear() % 100, p, 2);\n  }\n\n  function formatFullYear(d, p) {\n    return pad(d.getFullYear() % 10000, p, 4);\n  }\n\n  function formatZone(d) {\n    var z = d.getTimezoneOffset();\n    return (z > 0 ? \"-\" : (z *= -1, \"+\"))\n        + pad(z / 60 | 0, \"0\", 2)\n        + pad(z % 60, \"0\", 2);\n  }\n\n  function formatUTCDayOfMonth(d, p) {\n    return pad(d.getUTCDate(), p, 2);\n  }\n\n  function formatUTCHour24(d, p) {\n    return pad(d.getUTCHours(), p, 2);\n  }\n\n  function formatUTCHour12(d, p) {\n    return pad(d.getUTCHours() % 12 || 12, p, 2);\n  }\n\n  function formatUTCDayOfYear(d, p) {\n    return pad(1 + utcDay.count(utcYear(d), d), p, 3);\n  }\n\n  function formatUTCMilliseconds(d, p) {\n    return pad(d.getUTCMilliseconds(), p, 3);\n  }\n\n  function formatUTCMonthNumber(d, p) {\n    return pad(d.getUTCMonth() + 1, p, 2);\n  }\n\n  function formatUTCMinutes(d, p) {\n    return pad(d.getUTCMinutes(), p, 2);\n  }\n\n  function formatUTCSeconds(d, p) {\n    return pad(d.getUTCSeconds(), p, 2);\n  }\n\n  function formatUTCWeekNumberSunday(d, p) {\n    return pad(utcSunday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCWeekdayNumber(d) {\n    return d.getUTCDay();\n  }\n\n  function formatUTCWeekNumberMonday(d, p) {\n    return pad(utcMonday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCYear(d, p) {\n    return pad(d.getUTCFullYear() % 100, p, 2);\n  }\n\n  function formatUTCFullYear(d, p) {\n    return pad(d.getUTCFullYear() % 10000, p, 4);\n  }\n\n  function formatUTCZone() {\n    return \"+0000\";\n  }\n\n  function formatLiteralPercent() {\n    return \"%\";\n  }\n\n  var isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\n\n  function formatIsoNative(date) {\n    return date.toISOString();\n  }\n\n  formatIsoNative.parse = function(string) {\n    var date = new Date(string);\n    return isNaN(date) ? null : date;\n  };\n\n  formatIsoNative.toString = function() {\n    return isoSpecifier;\n  };\n\n  var formatIso = Date.prototype.toISOString && +new Date(\"2000-01-01T00:00:00.000Z\")\n      ? formatIsoNative\n      : enUs.utcFormat(isoSpecifier);\n\n  var isoFormat = formatIso;\n\n  var localeDefinitions = (new Map)\n      .set(\"ca-ES\", caEs)\n      .set(\"de-DE\", deDe)\n      .set(\"en-CA\", enCa)\n      .set(\"en-GB\", enGb)\n      .set(\"en-US\", enUs)\n      .set(\"es-ES\", esEs)\n      .set(\"fi-FI\", fiFi)\n      .set(\"fr-CA\", frCa)\n      .set(\"fr-FR\", frFr)\n      .set(\"he-IL\", heIl)\n      .set(\"it-IT\", itIt)\n      .set(\"mk-MK\", mkMk)\n      .set(\"nl-NL\", nlNl)\n      .set(\"pl-PL\", plPl)\n      .set(\"pt-BR\", ptBr)\n      .set(\"ru-RU\", ruRu)\n      .set(\"zh-CN\", zhCn);\n\n  var defaultLocale = locale(enUs);\n  exports.format = defaultLocale.format;\n  exports.utcFormat = defaultLocale.utcFormat;\n\n  function localeFormat(definition) {\n    if (typeof definition === \"string\") {\n      definition = localeDefinitions.get(definition);\n      if (!definition) return null;\n    }\n    return locale(definition);\n  }\n  ;\n\n  exports.localeFormat = localeFormat;\n  exports.isoFormat = isoFormat;\n\n}));\n},{}],7:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  util = require('./util'),\n  vlfield = require('./field'),\n  vlenc = require('./enc'),\n  schema = require('./schema/schema');\n\nmodule.exports = (function() {\n  function Encoding(spec, theme) {\n    var defaults = schema.instantiate(),\n      specExtended = schema.util.merge(defaults, theme || {}, spec) ;\n\n    this._data = specExtended.data;\n    this._marktype = specExtended.marktype;\n    this._enc = specExtended.encoding;\n    this._config = specExtended.config;\n    this._filter = specExtended.filter;\n    // this._vega2 = true;\n  }\n\n  var proto = Encoding.prototype;\n\n  Encoding.fromShorthand = function(shorthand, data, config, theme) {\n    var c = consts.shorthand,\n        split = shorthand.split(c.delim),\n        marktype = split.shift().split(c.assign)[1].trim(),\n        enc = vlenc.fromShorthand(split);\n\n    return new Encoding({\n      data: data,\n      marktype: marktype,\n      encoding: enc,\n      config: config,\n      filter: []\n    }, theme);\n  };\n\n  Encoding.fromSpec = function(spec, theme) {\n    return new Encoding(spec, theme);\n  };\n\n  proto.toShorthand = function() {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + this._marktype +\n      c.delim + vlenc.shorthand(this._enc);\n  };\n\n  Encoding.shorthand = function (spec) {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + spec.marktype +\n      c.delim + vlenc.shorthand(spec.encoding);\n  };\n\n  Encoding.specFromShorthand = function(shorthand, data, config, excludeConfig) {\n    return Encoding.fromShorthand(shorthand, data, config).toSpec(excludeConfig);\n  };\n\n  proto.toSpec = function(excludeConfig, excludeData) {\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    spec = {\n      marktype: this._marktype,\n      encoding: enc,\n      filter: this._filter\n    };\n\n    if (!excludeConfig) {\n      spec.config = util.duplicate(this._config);\n    }\n\n    if (!excludeData) {\n      spec.data = util.duplicate(this._data);\n    }\n\n    // remove defaults\n    var defaults = schema.instantiate();\n    return schema.util.subtract(spec, defaults);\n  };\n\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(encType) {\n    // equivalent to calling vlenc.has(this._enc, encType)\n    return this._enc[encType].name !== undefined;\n  };\n\n  proto.field = function(et) {\n    return this._enc[et];\n  };\n\n  proto.filter = function() {\n    var filterNull = [],\n      fields = this.fields(),\n      self = this;\n\n    util.forEach(fields, function(fieldList, fieldName) {\n      if (fieldName === '*') return; //count\n\n      if ((self.config('filterNull').Q && fieldList.containsType[Q]) ||\n          (self.config('filterNull').T && fieldList.containsType[T]) ||\n          (self.config('filterNull').O && fieldList.containsType[O]) ||\n          (self.config('filterNull').N && fieldList.containsType[N])) {\n        filterNull.push({\n          operands: [fieldName],\n          operator: 'notNull'\n        });\n      }\n    });\n\n    return filterNull.concat(this._filter);\n  };\n\n  // get \"field\" reference for vega\n  proto.fieldRef = function(et, opt) {\n    opt = opt || {};\n    opt.data = !this._vega2 && (opt.data !== false);\n    return vlfield.fieldRef(this._enc[et], opt);\n  };\n\n  proto.fieldName = function(et) {\n    return this._enc[et].name;\n  };\n\n  /*\n   * return key-value pairs of field name and list of fields of that field name\n   */\n  proto.fields = function() {\n    return vlenc.fields(this._enc);\n  };\n\n  proto.fieldTitle = function(et) {\n    if (vlfield.isCount(this._enc[et])) {\n      return vlfield.count.displayName;\n    }\n    var fn = this._enc[et].aggregate || this._enc[et].timeUnit || (this._enc[et].bin && 'bin');\n    if (fn) {\n      var uppercase = fn === 'avg' ? 'MEAN' :fn.toUpperCase();\n      return uppercase + '(' + this._enc[et].name + ')';\n    } else {\n      return this._enc[et].name;\n    }\n  };\n\n  proto.scale = function(et) {\n    return this._enc[et].scale || {};\n  };\n\n  proto.axis = function(et) {\n    return this._enc[et].axis || {};\n  };\n\n  proto.bandSize = function(encType, useSmallBand) {\n    useSmallBand = useSmallBand ||\n      //isBandInSmallMultiples\n      (encType === Y && this.has(ROW) && this.has(Y)) ||\n      (encType === X && this.has(COL) && this.has(X));\n\n    // if band.size is explicitly specified, follow the specification, otherwise draw value from config.\n    return this.field(encType).band.size ||\n      this.config(useSmallBand ? 'smallBandSize' : 'largeBandSize');\n  };\n\n  proto.aggregate = function(et) {\n    return this._enc[et].aggregate;\n  };\n\n  // returns false if binning is disabled, otherwise an object with binning properties\n  proto.bin = function(et) {\n    var bin = this._enc[et].bin;\n    if (bin === {})\n      return false;\n    if (bin === true)\n      return {\n        maxbins: schema.MAXBINS_DEFAULT\n      };\n    return bin;\n  };\n\n  proto.value = function(et) {\n    return this._enc[et].value;\n  };\n\n  proto.numberFormat = function(fieldStats) {\n    var formatConfig = fieldStats.max > this.config('maxSmallNumber') ?\n      'largeNumberFormat': 'smallNumberFormat';\n    return this.config(formatConfig);\n  };\n\n  proto.sort = function(et, stats) {\n    var sort = this._enc[et].sort,\n      enc = this._enc,\n      isTypes = vlfield.isTypes;\n\n    if ((!sort || sort.length===0) &&\n        // FIXME\n        Encoding.toggleSort.support({encoding:this._enc}, stats, true) && //HACK\n        this.config('toggleSort') === Q\n      ) {\n      var qField = isTypes(enc.x, [N, O]) ? enc.y : enc.x;\n\n      if (isTypes(enc[et], [N, O])) {\n        sort = [{\n          name: qField.name,\n          aggregate: qField.aggregate,\n          type: qField.type,\n          reverse: true\n        }];\n      }\n    }\n\n    return sort;\n  };\n\n  proto.map = function(f) {\n    return vlenc.map(this._enc, f);\n  };\n\n  proto.reduce = function(f, init) {\n    return vlenc.reduce(this._enc, f, init);\n  };\n\n  proto.forEach = function(f) {\n    return vlenc.forEach(this._enc, f);\n  };\n\n  proto.type = function(et) {\n    return this.has(et) ? this._enc[et].type : null;\n  };\n\n  proto.isType = function(et, type) {\n    var field = this.field(et);\n    return field && vlfield.isType(field, type);\n  };\n\n\n  proto.isTypes = function(et, type) {\n    var field = this.field(et);\n    return field && vlfield.isTypes(field, type);\n  };\n\n  Encoding.isOrdinalScale = function(encoding, encType) {\n    return vlfield.isOrdinalScale(encoding.field(encType));\n  };\n\n  Encoding.isDimension = function(encoding, encType) {\n    return vlfield.isDimension(encoding.field(encType));\n  };\n\n  Encoding.isMeasure = function(encoding, encType) {\n    return vlfield.isMeasure(encoding.field(encType));\n  };\n\n  proto.isOrdinalScale = function(encType) {\n    return this.has(encType) && Encoding.isOrdinalScale(this, encType);\n  };\n\n  proto.isDimension = function(encType) {\n    return this.has(encType) && Encoding.isDimension(this, encType);\n  };\n\n  proto.isMeasure = function(encType) {\n    return this.has(encType) && Encoding.isMeasure(this, encType);\n  };\n\n  proto.isAggregate = function() {\n    return vlenc.isAggregate(this._enc);\n  };\n\n  proto.dataTable = function() {\n    return this.isAggregate() ? AGGREGATE : RAW;\n  };\n\n  Encoding.isAggregate = function(spec) {\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.alwaysNoOcclusion = function(spec) {\n    // FIXME raw OxQ with # of rows = # of O\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.isStack = function(spec) {\n    // FIXME update this once we have control for stack ...\n    return (spec.marktype === 'bar' || spec.marktype === 'area') &&\n      spec.encoding.color;\n  };\n\n  proto.isStack = function() {\n    // FIXME update this once we have control for stack ...\n    return (this.is('bar') || this.is('area')) && this.has('color');\n  };\n\n  proto.details = function() {\n    var encoding = this;\n    return this.reduce(function(refs, field, encType) {\n      if (!field.aggregate && (encType !== X && encType !== Y)) {\n        refs.push(encoding.fieldRef(encType));\n      }\n      return refs;\n    }, []);\n  };\n\n  proto.facets = function() {\n    var encoding = this;\n    return this.reduce(function(refs, field, encType) {\n      if (!field.aggregate && (encType == ROW || encType == COL)) {\n        refs.push(encoding.fieldRef(encType));\n      }\n      return refs;\n    }, []);\n  };\n\n  proto.cardinality = function(encType, stats) {\n    return vlfield.cardinality(this.field(encType), stats, this.config('filterNull'));\n  };\n\n  proto.isRaw = function() {\n    return !this.isAggregate();\n  };\n\n  proto.data = function() {\n    return this._data;\n  };\n\n   // returns whether the encoding has values embedded\n  proto.hasValues = function() {\n    var vals = this.data().values;\n    return vals && vals.length;\n  };\n\n  proto.config = function(name) {\n    return this._config[name];\n  };\n\n  Encoding.transpose = function(spec) {\n    var oldenc = spec.encoding,\n      enc = util.duplicate(spec.encoding);\n    enc.x = oldenc.y;\n    enc.y = oldenc.x;\n    enc.row = oldenc.col;\n    enc.col = oldenc.row;\n    spec.encoding = enc;\n    return spec;\n  };\n\n  // FIXME: REMOVE everything below here\n\n  Encoding.toggleSort = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.toggleSort = spec.config.toggleSort === Q ? N : Q;\n    return spec;\n  };\n\n\n  Encoding.toggleSort.direction = function(spec) {\n    if (!Encoding.toggleSort.support(spec)) { return; }\n    var enc = spec.encoding;\n    return enc.x.type === N ? 'x' : 'y';\n  };\n\n  Encoding.toggleSort.mode = function(spec) {\n    return spec.config.toggleSort;\n  };\n\n  Encoding.toggleSort.support = function(spec, stats) {\n    var enc = spec.encoding,\n      isTypes = vlfield.isTypes;\n\n    if (vlenc.has(enc, ROW) || vlenc.has(enc, COL) ||\n      !vlenc.has(enc, X) || !vlenc.has(enc, Y) ||\n      !Encoding.alwaysNoOcclusion(spec, stats)) {\n      return false;\n    }\n\n    return ( isTypes(enc.x, [N,O]) && vlfield.isMeasure(enc.y)) ? 'x' :\n      ( isTypes(enc.y, [N,O]) && vlfield.isMeasure(enc.x)) ? 'y' : false;\n  };\n\n  Encoding.toggleFilterNullO = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.filterNull = spec.config.filterNull || { //FIXME\n      T: true,\n      Q: true\n    };\n    spec.config.filterNull.O = !spec.config.filterNull.O;\n    return spec;\n  };\n\n  Encoding.toggleFilterNullO.support = function(spec, stats) {\n    var fields = vlenc.fields(spec.encoding);\n    for (var fieldName in fields) {\n      var fieldList = fields[fieldName];\n      if (fieldList.containsType.O && fieldName in stats && stats[fieldName].nulls > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  return Encoding;\n})();\n\n},{\"./consts\":21,\"./enc\":23,\"./field\":24,\"./globals\":25,\"./schema/schema\":27,\"./util\":29}],8:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  getter = util.getter,\n  time = require('./time');\n\nvar axis = module.exports = {};\n\naxis.def = function(name, encoding, layout, stats, opt) {\n  var isCol = name == COL,\n    isRow = name == ROW,\n    type = isCol ? 'x' : isRow ? 'y' : name;\n\n  var def = {\n    type: type,\n    scale: name,\n    properties: {},\n    layer: encoding.field(name).axis.layer,\n    orient: axis.orient(name, encoding, stats)\n  };\n\n  // Add axis label custom scale (for bin / time)\n  def = axis.labels.scale(def, encoding, name);\n  def = axis.labels.format(def, name, encoding, stats);\n  def = axis.labels.angle(def, encoding, name);\n\n  // for x-axis, set ticks for Q or rotate scale for ordinal scale\n  if (name == X) {\n    if ((encoding.isDimension(X) || encoding.isType(X, T)) &&\n        !('angle' in getter(def, ['properties', 'labels']))) {\n      // TODO(kanitw): Jul 19, 2015 - #506 add condition for rotation\n      def = axis.labels.rotate(def);\n    } else { // Q\n      def.ticks = encoding.field(name).axis.ticks;\n    }\n  }\n\n  // TitleOffset depends on labels rotation\n  def.titleOffset = axis.titleOffset(encoding, layout, name);\n\n  //def.offset is used in axis.grid\n  if(isRow) def.offset = axis.titleOffset(encoding, layout, Y) + 20;\n  // FIXME(kanitw): Jul 19, 2015 - offset for column when x is put on top\n\n  def = axis.grid(def, name, encoding, layout);\n  def = axis.title(def, name, encoding, layout, opt);\n\n  if (isRow || isCol) def = axis.hideTicks(def);\n\n  return def;\n};\n\naxis.orient = function(name, encoding, stats) {\n  var orient = encoding.field(name).axis.orient;\n  if (orient) return orient;\n\n  if (name === COL) return 'top';\n\n  // x-axis for long y - put on top\n  if (name === X && encoding.has(Y) && encoding.isOrdinalScale(Y) && encoding.cardinality(Y, stats) > 30) {\n    return 'top';\n  }\n\n  return undefined;\n};\n\naxis.grid = function(def, name, encoding, layout) {\n  var cellPadding = layout.cellPadding,\n    isCol = name == COL,\n    isRow = name == ROW;\n\n  if (encoding.axis(name).grid) {\n    def.grid = true;\n\n    if (isCol) {\n      // set grid property -- put the lines on the right the cell\n      def.properties.grid = {\n        x: {\n          offset: layout.cellWidth * (1+ cellPadding/2.0),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'col'\n        },\n        y: {\n          value: -layout.cellHeight * (cellPadding/2),\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      };\n    } else if (isRow) {\n      // set grid property -- put the lines on the top\n      def.properties.grid = {\n        y: {\n          offset: -layout.cellHeight * (cellPadding/2),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'row'\n        },\n        x: {\n          value: def.offset\n        },\n        x2: {\n          offset: def.offset + (layout.cellWidth * 0.05),\n          // default value(s) -- vega doesn't do recursive merge\n          group: 'mark.group.width',\n          mult: 1\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      };\n    } else {\n      def.properties.grid = {\n        stroke: { value: encoding.config('gridColor') },\n        opacity: { value: encoding.config('gridOpacity') }\n      };\n    }\n  }\n  return def;\n};\n\naxis.hideTicks = function(def) {\n  def.properties.ticks = {opacity: {value: 0}};\n  def.properties.majorTicks = {opacity: {value: 0}};\n  def.properties.axis = {opacity: {value: 0}};\n  return def;\n};\n\naxis.title = function (def, name, encoding, layout) {\n  var ax = encoding.field(name).axis;\n\n  if (ax.title) {\n    def.title = ax.title;\n  } else {\n    // if not defined, automatically determine axis title from field def\n    var fieldTitle = encoding.fieldTitle(name),\n      maxLength;\n\n    if (ax.titleMaxLength) {\n      maxLength = ax.titleMaxLength;\n    } else if (name===X) {\n      maxLength = layout.cellWidth / encoding.config('characterWidth');\n    } else if (name === Y) {\n      maxLength = layout.cellHeight / encoding.config('characterWidth');\n    }\n\n    def.title = maxLength ? util.truncate(fieldTitle, maxLength) : fieldTitle;\n  }\n\n  if (name === ROW) {\n    def.properties.title = {\n      angle: {value: 0},\n      align: {value: 'right'},\n      baseline: {value: 'middle'},\n      dy: {value: (-layout.height/2) -20}\n    };\n  }\n\n  return def;\n};\n\naxis.labels = {};\n\n/** add custom label for time type and bin */\naxis.labels.scale = function(def, encoding, name) {\n  // time\n  var timeUnit = encoding.field(name).timeUnit;\n  if (encoding.isType(name, T) && timeUnit && (time.hasScale(timeUnit))) {\n    setter(def, ['properties','labels','text','scale'], 'time-'+ timeUnit);\n  }\n  // FIXME bin\n  return def;\n};\n\n/**\n * Determine number format or truncate if maxLabel length is presented.\n */\naxis.labels.format = function (def, name, encoding, stats) {\n  var fieldStats = stats[encoding.field(name).name];\n\n  if (encoding.axis(name).format) {\n    def.format = encoding.axis(name).format;\n  } else if (encoding.isType(name, Q) || fieldStats.type === 'number') {\n    def.format = encoding.numberFormat(fieldStats);\n  } else if (encoding.isType(name, T)) {\n    var timeUnit = encoding.field(name).timeUnit;\n    if (!timeUnit) {\n      def.format = encoding.config('timeFormat');\n    } else if (timeUnit === 'year') {\n      def.format = 'd';\n    }\n  } else if (encoding.isTypes(name, [N, O]) && encoding.axis(name).maxLabelLength) {\n    setter(def,\n      ['properties','labels','text','template'],\n      '{{data | truncate:' + encoding.axis(name).maxLabelLength + '}}'\n      );\n  }\n\n  return def;\n};\n\naxis.labels.angle = function(def, encoding, name) {\n  var angle = encoding.axis(name).labelAngle;\n  if (typeof angle === 'undefined') return def;\n\n  setter(def, ['properties', 'labels', 'angle', 'value'], angle);\n  return def;\n};\n\naxis.labels.rotate = function(def) {\n var align = def.orient ==='top' ? 'left' : 'right';\n setter(def, ['properties','labels', 'angle', 'value'], 270);\n setter(def, ['properties','labels', 'align', 'value'], align);\n setter(def, ['properties','labels', 'baseline', 'value'], 'middle');\n return def;\n};\n\naxis.titleOffset = function (encoding, layout, name) {\n  // return specified value if specified\n  var value = encoding.axis(name).titleOffset;\n  if (value)  return value;\n\n  switch (name) {\n    //FIXME make this adjustable\n    case ROW: return 0;\n    case COL: return 35;\n  }\n  return getter(layout, [name, 'axisTitleOffset']);\n};\n\n},{\"../globals\":25,\"../util\":29,\"./time\":20}],9:[function(require,module,exports){\n'use strict';\n\nvar summary = module.exports = require('datalib/src/stats').summary;\n\nrequire('../globals');\n\n/**\n * Module for compiling Vega-lite spec into Vega spec.\n */\nvar compiler = module.exports = {};\n\nvar Encoding = require('../Encoding'),\n  axis = compiler.axis = require('./axis'),\n  legend = compiler.legend = require('./legend'),\n  marks = compiler.marks = require('./marks'),\n  scale = compiler.scale = require('./scale');\n\ncompiler.data = require('./data');\ncompiler.facet = require('./facet');\ncompiler.layout = require('./layout');\ncompiler.sort = require('./sort');\ncompiler.stack = require('./stack');\ncompiler.style = require('./style');\ncompiler.subfacet = require('./subfacet');\ncompiler.time = require('./time');\n\ncompiler.compile = function (spec, stats, theme) {\n  return compiler.compileEncoding(Encoding.fromSpec(spec, theme), stats);\n};\n\ncompiler.shorthand = function (shorthand, stats, config, theme) {\n  return compiler.compileEncoding(Encoding.fromShorthand(shorthand, config, theme), stats);\n};\n\n/**\n * Create a Vega specification from a Vega-lite Encoding object.\n */\ncompiler.compileEncoding = function (encoding, stats) {\n  // no need to pass stats if you pass in the data\n  if (!stats) {\n    if (encoding.hasValues()) {\n        stats = summary(encoding.data().values).reduce(function(s, p) {\n        s[p.field] = p;\n        return s;\n      }, {});\n    } else {\n      console.error('No stats provided and data is not embedded.');\n    }\n  }\n\n  var layout = compiler.layout(encoding, stats);\n\n  var spec = {\n      width: layout.width,\n      height: layout.height,\n      padding: 'auto',\n      data: compiler.data(encoding),\n      // global scales contains only time unit scales\n      scales: compiler.time.scales(encoding),\n      marks: [{\n        _name: 'cell',\n        type: 'group',\n        properties: {\n          enter: {\n            width: layout.cellWidth ? {value: layout.cellWidth} : {group: 'width'},\n            height: layout.cellHeight ? {value: layout.cellHeight} : {group: 'height'}\n          }\n        }\n      }]\n    };\n\n  var group = spec.marks[0];\n\n  // FIXME remove compiler.sort after migrating to vega 2.\n  spec.data = compiler.sort(spec.data, encoding, stats); // append new data\n\n  // marks\n  var style = compiler.style(encoding, stats),\n    mdefs = group.marks = marks.def(encoding, layout, style, stats),\n    mdef = mdefs[mdefs.length - 1];  // TODO: remove this dirty hack by refactoring the whole flow\n\n  var lineType = marks[encoding.marktype()].line;\n\n  // handle subfacets\n\n  var details = encoding.details(),\n    stack = encoding.isAggregate() && details.length > 0 && compiler.stack(spec.data, encoding, mdef); // modify spec.data, mdef.{from,properties}\n\n  if (details.length > 0 && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    compiler.subfacet(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  if (lineType && encoding.config('autoSortLine')) {\n    var f = (encoding.isMeasure(X) && encoding.isDimension(Y)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    // TODO: why - ?\n    mdef.from.transform = [{type: 'sort', by: '-' + encoding.fieldRef(f)}];\n  }\n\n  // get a flattened list of all scale names that are used in the vl spec\n  var singleScaleNames = [].concat.apply([], mdefs.map(function(markProps) {\n    return scale.names(markProps.properties.update);\n  }));\n\n  // Small Multiples\n  if (encoding.has(ROW) || encoding.has(COL)) {\n    spec = compiler.facet(group, encoding, layout, spec, singleScaleNames, stack, stats);\n    spec.legends = legend.defs(encoding, style);\n  } else {\n    group.scales = scale.defs(singleScaleNames, encoding, layout, stats, {stack: stack});\n\n    group.axes = [];\n    if (encoding.has(X)) group.axes.push(axis.def(X, encoding, layout, stats));\n    if (encoding.has(Y)) group.axes.push(axis.def(Y, encoding, layout, stats));\n\n    group.legends = legend.defs(encoding, style);\n  }\n\n  return spec;\n};\n\n\n},{\"../Encoding\":7,\"../globals\":25,\"./axis\":8,\"./data\":10,\"./facet\":11,\"./layout\":12,\"./legend\":13,\"./marks\":14,\"./scale\":15,\"./sort\":16,\"./stack\":17,\"./style\":18,\"./subfacet\":19,\"./time\":20,\"datalib/src/stats\":35}],10:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nmodule.exports = data;\n\nvar vlfield = require('../field'),\n  util = require('../util'),\n  time = require('./time');\n\n/**\n * Create Vega's data array from a given encoding.\n *\n * @param  {Encoding} encoding\n * @return {Array} Array of Vega data.\n *                 This always includes a \"raw\" data table.\n *                 If the encoding contains aggregate value, this will also create\n *                 aggregate table as well.\n */\nfunction data(encoding) {\n  var def = [data.raw(encoding)];\n\n  var aggregate = data.aggregate(encoding);\n  if (aggregate) def.push(data.aggregate(encoding));\n\n  // TODO add \"having\" filter here\n\n  // append non-positive filter at the end for the data table\n  data.filterNonPositive(def[def.length - 1], encoding);\n\n  return def;\n}\n\ndata.raw = function(encoding) {\n  var raw = {name: RAW};\n\n  // Data source (url or inline)\n  if (encoding.hasValues()) {\n    raw.values = encoding.data().values;\n  } else {\n    raw.url = encoding.data().url;\n    raw.format = {type: encoding.data().formatType};\n  }\n\n  // Set data's format.parse if needed\n  var parse = data.raw.formatParse(encoding);\n  if (parse) {\n    raw.format = raw.format || {};\n    raw.format.parse = parse;\n  }\n\n  raw.transform = data.raw.transform(encoding);\n  return raw;\n};\n\ndata.raw.formatParse = function(encoding) {\n  var parse;\n\n  encoding.forEach(function(field) {\n    if (field.type == T) {\n      parse = parse || {};\n      parse[field.name] = 'date';\n    } else if (field.type == Q) {\n      if (vlfield.isCount(field)) return;\n      parse = parse || {};\n      parse[field.name] = 'number';\n    }\n  });\n\n  return parse;\n};\n\n/**\n * Generate Vega transforms for the raw data table.  This can include\n * transforms for time unit, binning and filtering.\n */\ndata.raw.transform = function(encoding) {\n  // time and bin should come before filter so we can filter by time and bin\n  return data.raw.transform.time(encoding).concat(\n    data.raw.transform.bin(encoding),\n    data.raw.transform.filter(encoding)\n  );\n};\n\nvar BINARY = {\n  '>':  true,\n  '>=': true,\n  '=':  true,\n  '!=': true,\n  '<':  true,\n  '<=': true\n};\n\ndata.raw.transform.time = function(encoding) {\n  return encoding.reduce(function(transform, field, encType) {\n    if (field.type === T && field.timeUnit) {\n      transform.push({\n        type: 'formula',\n        field: encoding.fieldRef(encType),\n        expr: time.formula(field.timeUnit,\n                           encoding.fieldRef(encType, {nofn: true, d: true})\n                          )\n      });\n    }\n    return transform;\n  }, []);\n};\n\ndata.raw.transform.bin = function(encoding) {\n  return encoding.reduce(function(transform, field, encType) {\n    if (encoding.bin(encType)) {\n      transform.push({\n        type: 'bin',\n        field: encoding.fieldRef(encType, {nofn: true}),\n        output: encoding.fieldRef(encType),\n        maxbins: encoding.bin(encType).maxbins\n      });\n    }\n    return transform;\n  }, []);\n};\n\ndata.raw.transform.filter = function(encoding) {\n  var filters = encoding.filter().reduce(function(f, filter) {\n    var condition = '';\n    var operator = filter.operator;\n    var operands = filter.operands;\n\n    var d = 'd.' + (encoding._vega2 ? '' : 'data.');\n\n    if (BINARY[operator]) {\n      // expects a field and a value\n      if (operator === '=') {\n        operator = '==';\n      }\n\n      var op1 = operands[0];\n      var op2 = operands[1];\n      condition = d + op1 + ' ' + operator + ' ' + op2;\n    } else if (operator === 'notNull') {\n      // expects a number of fields\n      for (var j=0; j<operands.length; j++) {\n        condition += d + operands[j] + '!==null';\n        if (j < operands.length - 1) {\n          condition += ' && ';\n        }\n      }\n    } else {\n      util.warn('Unsupported operator: ', operator);\n      return f;\n    }\n    f.push('(' + condition + ')');\n    return f;\n  }, []);\n  if (filters.length === 0) return [];\n\n  return [{\n      type: 'filter',\n      test: filters.join(' && ')\n  }];\n};\n\ndata.aggregate = function(encoding) {\n  var dims = {}, meas = {};\n\n  encoding.forEach(function(field, encType) {\n    if (field.aggregate) {\n      if (field.aggregate === 'count') {\n        meas.count = {op: 'count', field: '*'};\n      }else {\n        meas[field.aggregate + '|' + field.name] = {\n          op: field.aggregate,\n          field: encoding.fieldRef(encType, {nofn: true})\n        };\n      }\n    } else {\n      dims[field.name] = encoding.fieldRef(encType);\n    }\n  });\n\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0) {\n    return {\n      name: AGGREGATE,\n      source: RAW,\n      transform: [{\n        type: 'aggregate',\n        groupby: dims,\n        fields: meas\n      }]\n    };\n  }\n\n  return null;\n};\n\ndata.filterNonPositive = function(dataTable, encoding) {\n  encoding.forEach(function(field, encType) {\n    if (encoding.scale(encType).type === 'log') {\n      dataTable.transform.push({\n        type: 'filter',\n        test: encoding.fieldRef(encType, {d: 1}) + ' > 0'\n      });\n    }\n  });\n};\n\n},{\"../field\":24,\"../globals\":25,\"../util\":29,\"./time\":20}],11:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util');\n\nvar axis = require('./axis'),\n  scale = require('./scale');\n\nmodule.exports = faceting;\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: 'group',\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: 'width'},\n        height: opt.height || {group: 'height'}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n\nfunction faceting(group, encoding, layout, spec, singleScaleNames, stack, stats) {\n  var enter = group.properties.enter;\n  var facetKeys = [], cellAxes = [], from, axesGrp;\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  enter.fill = {value: encoding.config('cellBackgroundColor')};\n\n  //move \"from\" to cell level and add facet transform\n  group.from = {data: group.marks[0].from.data};\n\n  // Hack, this needs to be refactored\n  for (var i = 0; i < group.marks.length; i++) {\n    var mark = group.marks[i];\n    if (mark.from.transform) {\n      delete mark.from.data; //need to keep transform for subfacetting case\n    } else {\n      delete mark.from;\n    }\n  }\n\n  if (hasRow) {\n    if (!encoding.isDimension(ROW)) {\n      util.error('Row encoding should be ordinal.');\n    }\n    enter.y = {scale: ROW, field: 'keys.' + facetKeys.length};\n    enter.height = {'value': layout.cellHeight}; // HACK\n\n    facetKeys.push(encoding.fieldRef(ROW));\n\n    if (hasCol) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.fieldRef(COL)]});\n    }\n\n    axesGrp = groupdef('x-axes', {\n        axes: encoding.has(X) ? [axis.def(X, encoding, layout, stats)] : undefined,\n        x: hasCol ? {scale: COL, field: 'keys.0'} : {value: 0},\n        width: hasCol && {'value': layout.cellWidth}, //HACK?\n        from: from\n      });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push(axis.def(ROW, encoding, layout, stats));\n  } else { // doesn't have row\n    if (encoding.has(X)) {\n      //keep x axis in the cell\n      cellAxes.push(axis.def(X, encoding, layout, stats));\n    }\n  }\n\n  if (hasCol) {\n    if (!encoding.isDimension(COL)) {\n      util.error('Col encoding should be ordinal.');\n    }\n    enter.x = {scale: COL, field: 'keys.' + facetKeys.length};\n    enter.width = {'value': layout.cellWidth}; // HACK\n\n    facetKeys.push(encoding.fieldRef(COL));\n\n    if (hasRow) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.fieldRef(ROW)]});\n    }\n\n    axesGrp = groupdef('y-axes', {\n      axes: encoding.has(Y) ? [axis.def(Y, encoding, layout, stats)] : undefined,\n      y: hasRow && {scale: ROW, field: 'keys.0'},\n      x: hasRow && {value: 0},\n      height: hasRow && {'value': layout.cellHeight}, //HACK?\n      from: from\n    });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push(axis.def(COL, encoding, layout, stats));\n  } else { // doesn't have col\n    if (encoding.has(Y)) {\n      cellAxes.push(axis.def(Y, encoding, layout, stats));\n    }\n  }\n\n  // assuming equal cellWidth here\n  // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n  spec.scales = (spec.scales || []).concat(scale.defs(\n    scale.names(enter).concat(singleScaleNames),\n    encoding,\n    layout,\n    stats,\n    {stack: stack, facet: true}\n  )); // row/col scales + cell scales\n\n  if (cellAxes.length > 0) {\n    group.axes = cellAxes;\n  }\n\n  // add facet transform\n  var trans = (group.from.transform || (group.from.transform = []));\n  trans.unshift({type: 'facet', keys: facetKeys});\n\n  return spec;\n}\n\n},{\"../globals\":25,\"../util\":29,\"./axis\":8,\"./scale\":15}],12:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  time = require('./time'),\n  d3_format = require('d3-format');\n\nmodule.exports = vllayout;\n\nfunction vllayout(encoding, stats) {\n  var layout = box(encoding, stats);\n  layout = offset(encoding, stats, layout);\n  return layout;\n}\n\n/*\n  HACK to set chart size\n  NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  One solution is to update Vega to support auto-sizing\n  In the meantime, auto-padding (mostly) does the trick\n */\nfunction box(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y),\n      marktype = encoding.marktype();\n\n  // FIXME/HACK we need to take filter into account\n  var xCardinality = hasX && encoding.isDimension(X) ? encoding.cardinality(X, stats) : 1,\n    yCardinality = hasY && encoding.isDimension(Y) ? encoding.cardinality(Y, stats) : 1;\n\n  var useSmallBand = xCardinality > encoding.config('largeBandMaxCardinality') ||\n    yCardinality > encoding.config('largeBandMaxCardinality');\n\n  var cellWidth, cellHeight, cellPadding = encoding.config('cellPadding');\n\n  // set cellWidth\n  if (hasX) {\n    if (encoding.isOrdinalScale(X)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellWidth = (xCardinality + encoding.field(X).band.padding) * encoding.bandSize(X, useSmallBand);\n    } else {\n      cellWidth = hasCol || hasRow ? encoding.field(COL).width :  encoding.config('singleWidth');\n    }\n  } else {\n    if (marktype === TEXT) {\n      cellWidth = encoding.config('textCellWidth');\n    } else {\n      cellWidth = encoding.bandSize(X);\n    }\n  }\n\n  // set cellHeight\n  if (hasY) {\n    if (encoding.isOrdinalScale(Y)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellHeight = (yCardinality + encoding.field(Y).band.padding) * encoding.bandSize(Y, useSmallBand);\n    } else {\n      cellHeight = hasCol || hasRow ? encoding.field(ROW).height :  encoding.config('singleHeight');\n    }\n  } else {\n    cellHeight = encoding.bandSize(Y);\n  }\n\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n\n  var width = cellWidth, height = cellHeight;\n  if (hasCol) {\n    var colCardinality = encoding.cardinality(COL, stats);\n    width = cellWidth * ((1 + cellPadding) * (colCardinality - 1) + 1);\n  }\n  if (hasRow) {\n    var rowCardinality =  encoding.cardinality(ROW, stats);\n    height = cellHeight * ((1 + cellPadding) * (rowCardinality - 1) + 1);\n  }\n\n  return {\n    // width and height of the whole cell\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    cellPadding: cellPadding,\n    // width and height of the chart\n    width: width,\n    height: height,\n    // information about x and y, such as band size\n    x: {useSmallBand: useSmallBand},\n    y: {useSmallBand: useSmallBand}\n  };\n}\n\n\n// FIXME fieldStats.max isn't always the longest\nfunction getMaxNumberLength(encoding, et, fieldStats) {\n  var format = encoding.numberFormat(et, fieldStats);\n\n  return d3_format.format(format)(fieldStats.max).length;\n}\n\n// TODO(#600) revise this\nfunction getMaxLength(encoding, stats, et) {\n  var field = encoding.field(et),\n    fieldStats = stats[field.name];\n\n  if (field.bin) {\n    // TODO once bin support range, need to update this\n    return getMaxNumberLength(encoding, et, fieldStats);\n  } if (encoding.isType(et, Q)) {\n    return getMaxNumberLength(encoding, et, fieldStats);\n  } else if (encoding.isType(et, T)) {\n    return time.maxLength(encoding.field(et).timeUnit, encoding);\n  } else if (encoding.isTypes(et, [N, O])) {\n    if(fieldStats.type === 'number') {\n      return getMaxNumberLength(encoding, et, fieldStats);\n    } else {\n      return Math.min(fieldStats.max, encoding.axis(et).maxLabelLength || Infinity);\n    }\n  }\n}\n\nfunction offset(encoding, stats, layout) {\n  [X, Y].forEach(function (et) {\n    // TODO(kanitw): Jul 19, 2015 - create a set of visual test for extraOffset\n    var extraOffset = et === X ? 20 : 22,\n      maxLength;\n    if (encoding.isDimension(et) || encoding.isType(et, T)) {\n      maxLength = getMaxLength(encoding, stats, et);\n    } else if (\n      // TODO once we have #512 (allow using inferred type)\n      // Need to adjust condition here.\n      encoding.isType(et, Q) ||\n      encoding.aggregate(et) === 'count'\n    ) {\n      if (\n        et===Y\n        // || (et===X && false)\n        // FIXME determine when X would rotate, but should move this to axis.js first #506\n      ) {\n        maxLength = getMaxLength(encoding, stats, et);\n      }\n    } else {\n      // nothing\n    }\n\n    if (maxLength) {\n      setter(layout,[et, 'axisTitleOffset'], encoding.config('characterWidth') *  maxLength + extraOffset);\n    } else {\n      // if no max length (no rotation case), use maxLength = 3\n      setter(layout,[et, 'axisTitleOffset'], encoding.config('characterWidth') * 3 + extraOffset);\n    }\n\n  });\n  return layout;\n}\n\n},{\"../globals\":25,\"../util\":29,\"./time\":20,\"d3-format\":5}],13:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar time = require('./time'),\n  util = require('../util'),\n  setter = util.setter,\n  getter = util.getter;\n\nvar legend = module.exports = {};\n\nlegend.defs = function(encoding, style) {\n  var defs = [];\n\n  if (encoding.has(COLOR) && encoding.field(COLOR).legend) {\n    defs.push(legend.def(COLOR, encoding, {\n      fill: COLOR,\n      orient: 'right'\n    }, style));\n  }\n\n  if (encoding.has(SIZE) && encoding.field(SIZE).legend) {\n    defs.push(legend.def(SIZE, encoding, {\n      size: SIZE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }, style));\n  }\n\n  if (encoding.has(SHAPE) && encoding.field(SHAPE).legend) {\n    if (defs.length === 2) {\n      console.error('Vega-lite currently only supports two legends');\n    }\n    defs.push(legend.def(SHAPE, encoding, {\n      shape: SHAPE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }, style));\n  }\n  return defs;\n};\n\nlegend.def = function(name, encoding, def, style) {\n  var timeUnit = encoding.field(name).timeUnit;\n\n  def.title = legend.title(name, encoding);\n  def = legend.style(name, encoding, def, style);\n\n  if (encoding.isType(name, T) &&\n    timeUnit &&\n    time.hasScale(timeUnit)\n  ) {\n    setter(def, ['properties', 'labels', 'text', 'scale'], 'time-'+ timeUnit);\n  }\n\n  return def;\n};\n\nlegend.style = function(name, e, def, style) {\n  var symbols = getter(def, ['properties', 'symbols']),\n    marktype = e.marktype();\n\n  switch (marktype) {\n    case 'bar':\n    case 'tick':\n    case 'text':\n      symbols.stroke = {value: 'transparent'};\n      symbols.shape = {value: 'square'};\n      break;\n\n    case 'circle':\n    case 'square':\n      symbols.shape = {value: marktype};\n      /* fall through */\n    case 'point':\n      // fill or stroke\n      if (e.field(SHAPE).filled) {\n        if (e.has(COLOR) && name === COLOR) {\n          symbols.fill = {scale: COLOR, field: 'data'};\n        } else {\n          symbols.fill = {value: e.value(COLOR)};\n        }\n        symbols.stroke = {value: 'transparent'};\n      } else {\n        if (e.has(COLOR) && name === COLOR) {\n          symbols.stroke = {scale: COLOR, field: 'data'};\n        } else {\n          symbols.stroke = {value: e.value(COLOR)};\n        }\n        symbols.fill = {value: 'transparent'};\n        symbols.strokeWidth = {value: e.config('strokeWidth')};\n      }\n\n      break;\n    case 'line':\n    case 'area':\n      // TODO use shape here after implementing #508\n      break;\n  }\n\n  var opacity = e.field(COLOR).opacity || style.opacity;\n  if (opacity) {\n    symbols.opacity = {value: opacity};\n  }\n  return def;\n};\n\nlegend.title = function(name, encoding) {\n  var leg = encoding.field(name).legend;\n\n  if (leg.title) return leg.title;\n\n  return encoding.fieldTitle(name);\n};\n\n},{\"../globals\":25,\"../util\":29,\"./time\":20}],14:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar marks = module.exports = {};\n\nmarks.def = function(encoding, layout, style, stats) {\n\n  var defs = [],\n    mark = marks[encoding.marktype()],\n    from = encoding.dataTable();\n\n  // to add a background to text, we need to add it before the text\n  if (encoding.marktype() === TEXT && encoding.has(COLOR)) {\n    var bg = {\n      x: {value: 0},\n      y: {value: 0},\n      x2: {value: layout.cellWidth},\n      y2: {value: layout.cellHeight},\n      fill: {scale: COLOR, field: encoding.fieldRef(COLOR)}\n    };\n    defs.push({\n      type: 'rect',\n      from: {data: from},\n      properties: {enter: bg, update: bg}\n    });\n  }\n\n  // add the mark def for the main thing\n  var p = mark.prop(encoding, layout, style, stats);\n  defs.push({\n    type: mark.type,\n    from: {data: from},\n    properties: {enter: p, update: p}\n  });\n\n  return defs;\n};\n\nmarks.bar = {\n  type: 'rect',\n  stack: true,\n  prop: bar_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1}\n};\n\nmarks.line = {\n  type: 'line',\n  line: true,\n  prop: line_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, detail:1}\n};\n\nmarks.area = {\n  type: 'area',\n  stack: true,\n  line: true,\n  requiredEncoding: ['x', 'y'],\n  prop: area_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1}\n};\n\nmarks.tick = {\n  type: 'rect',\n  prop: tick_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, detail: 1}\n};\n\nmarks.circle = {\n  type: 'symbol',\n  prop: filled_point_props('circle'),\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, detail: 1}\n};\n\nmarks.square = {\n  type: 'symbol',\n  prop: filled_point_props('square'),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: 'symbol',\n  prop: point_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, shape: 1, detail: 1}\n};\n\nmarks.text = {\n  type: 'text',\n  prop: text_props,\n  requiredEncoding: ['text'],\n  supportedEncoding: {row: 1, col: 1, size: 1, color: 1, text: 1}\n};\n\nfunction bar_props(e, layout, style) {\n  // jshint unused:false\n\n  var p = {};\n\n  // x's and width\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (!e.has(Y) || e.isDimension(Y)) {\n      p.x2 = {value: 0};\n    }\n  } else {\n    if (e.has(X)) { // is ordinal\n       p.xc = {scale: X, field: e.fieldRef(X)};\n    } else {\n       p.x = {value: 0, offset: e.config('singleBarOffset')};\n    }\n  }\n\n  // width\n  if (!p.x2) {\n    if (!e.has(X) || e.isOrdinalScale(X)) { // no X or X is ordinal\n      if (e.has(SIZE)) {\n        p.width = {scale: SIZE, field: e.fieldRef(SIZE)};\n      } else {\n        p.width = {\n          value: e.bandSize(X, layout.x.useSmallBand),\n          offset: -1\n        };\n      }\n    } else { // X is Quant or Time Scale\n      p.width = {value: 2};\n    }\n  }\n\n  // y's & height\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    p.y2 = {group: 'height'};\n  } else {\n    if (e.has(Y)) { // is ordinal\n      p.yc = {scale: Y, field: e.fieldRef(Y)};\n    } else {\n      p.y2 = {group: 'height', offset: -e.config('singleBarOffset')};\n    }\n\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.fieldRef(SIZE)};\n    } else {\n      p.height = {\n        value: e.bandSize(Y, layout.y.useSmallBand),\n        offset: -1\n      };\n    }\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // opacity\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction point_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.fieldRef(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.value(SIZE)};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.fieldRef(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.value(SHAPE)};\n  }\n\n  // fill or stroke\n  if (e.field(SHAPE).filled) {\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n  } else {\n    if (e.has(COLOR)) {\n      p.stroke = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.stroke = {value: e.value(COLOR)};\n    }\n    p.strokeWidth = {value: e.config('strokeWidth')};\n  }\n\n  // opacity\n  var opacity = e.field(COLOR).opacity || style.opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction line_props(e,layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction area_props(e, layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: 'horizontal'};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else {\n    p.y = {group: 'height'};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction tick_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (e.isDimension(X)) {\n      p.x.offset = -e.bandSize(X, layout.x.useSmallBand) / 3;\n    }\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    if (e.isDimension(Y)) {\n      p.y.offset = -e.bandSize(Y, layout.y.useSmallBand) / 3;\n    }\n  } else if (!e.has(Y)) {\n    p.y = {value: 0};\n  }\n\n  // width\n  if (!e.has(X) || e.isDimension(X)) {\n    p.width = {value: e.bandSize(X, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.width = {value: 1};\n  }\n\n  // height\n  if (!e.has(Y) || e.isDimension(Y)) {\n    p.height = {value: e.bandSize(Y, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.height = {value: 1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity  || style.opacity;\n  if(opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, layout, style) {\n    var p = {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.fieldRef(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.fieldRef(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.fieldRef(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.value(SIZE)};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n\n    var opacity = e.field(COLOR).opacity  || style.opacity;\n    if(opacity) p.opacity = {value: opacity};\n\n    return p;\n  };\n}\n\nfunction text_props(e, layout, style, stats) {\n  var p = {},\n    field = e.field(TEXT);\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    if (e.has(TEXT) && e.isType(TEXT, Q)) {\n      p.x = {value: layout.cellWidth-5};\n    } else {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.fieldRef(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.fontSize = {value: field.font.size};\n  }\n\n  // fill\n  // color should be set to background\n  p.fill = {value: field.color};\n\n  var opacity = e.field(COLOR).opacity  || style.opacity;\n  if(opacity) p.opacity = {value: opacity};\n\n  // text\n  if (e.has(TEXT)) {\n    if (e.isType(TEXT, Q)) {\n      var fieldStats = stats[e.fieldName(TEXT)],\n        numberFormat = field.format || e.numberFormat(fieldStats);\n\n      p.text = {template: '{{' + e.fieldRef(TEXT) + ' | number:\\'' +\n        numberFormat +'\\'}}'};\n      p.align = {value: field.align};\n    } else {\n      p.text = {field: e.fieldRef(TEXT)};\n    }\n  } else {\n    p.text = {value: field.placeholder};\n  }\n\n  p.font = {value: field.font.family};\n  p.fontWeight = {value: field.font.weight};\n  p.fontStyle = {value: field.font.style};\n  p.baseline = {value: field.baseline};\n\n  return p;\n}\n\n},{\"../globals\":25}],15:[function(require,module,exports){\n'use strict';\nrequire('../globals');\nvar util = require('../util'),\n  time = require('./time'),\n  colorbrewer = require('colorbrewer'),\n  interpolate = require('d3-color').interpolateHsl,\n  schema = require('../schema/schema'),\n  vlsort = require('./sort');\n\nvar scale = module.exports = {};\n\nscale.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\nscale.defs = function(names, encoding, layout, stats, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale.type(name, encoding),\n      domain: scale.domain(name, encoding, stats, opt)\n    };\n\n    s.sort = scale.sort(s, encoding, name) || undefined;\n\n    scale.range(s, encoding, layout, stats, opt);\n\n    return (a.push(s), a);\n  }, []);\n};\n\nscale.sort = function(s, encoding, name) {\n  return s.type === 'ordinal' && (\n    !!encoding.bin(name) ||\n    encoding.sort(name).length === 0\n  );\n};\n\nscale.type = function(name, encoding) {\n\n  switch (encoding.type(name)) {\n    case N: //fall through\n    case O: return 'ordinal';\n    case T:\n      var timeUnit = encoding.field(name).timeUnit;\n      return timeUnit ? time.scale.type(timeUnit, name) : 'time';\n    case Q:\n      if (encoding.bin(name)) {\n        return name === COLOR ? 'linear' : 'ordinal';\n      }\n      return encoding.scale(name).type;\n  }\n};\n\nscale.domain = function (name, encoding, stats, opt) {\n  var field = encoding.field(name);\n\n  if (encoding.isType(name, T)) {\n    var range = time.scale.domain(field.timeUnit, name);\n    if(range) return range;\n  }\n\n  if (field.bin) {\n    // TODO(kanitw): this must be changed in vg2\n    var fieldStat = stats[field.name],\n      bins = util.getbins(fieldStat, field.bin.maxbins || schema.MAXBINS_DEFAULT),\n      numbins = (bins.stop - bins.start) / bins.step;\n    return util.range(numbins).map(function(i) {\n      return bins.start + bins.step * i;\n    });\n  }\n\n  if (name == opt.stack) {\n    return {\n      data: STACKED,\n      field: encoding.fieldRef(name, {\n        data: !encoding._vega2,\n        prefn: (opt.facet ? 'max_' : '') + 'sum_'\n      })\n    };\n  }\n  var aggregate = encoding.aggregate(name),\n    timeUnit = field.timeUnit,\n    scaleUseRawDomain = encoding.scale(name).useRawDomain,\n    useRawDomain = scaleUseRawDomain !== undefined ?\n      scaleUseRawDomain : encoding.config('useRawDomain'),\n    notCountOrSum = !aggregate || (aggregate !=='count' && aggregate !== 'sum');\n\n  // FIXME revise this part\n\n  if ( useRawDomain && notCountOrSum && (\n      // Q always uses non-ordinal scale except when it's binned and thus uses ordinal scale.\n      (encoding.isType(name, Q) && !field.bin) ||\n      // T uses non-ordinal scale when there's no unit or when the unit is not ordinal.\n      (encoding.isType(name, T) && (!timeUnit || !time.isOrdinalFn(timeUnit)))\n    )\n  ) {\n    return {data: RAW, field: encoding.fieldRef(name, {nofn: !timeUnit})};\n  }\n\n  var data = encoding.sort(name, stats).length > 0 ?\n    vlsort.getDataName(name):\n    encoding.dataTable();\n\n  return {data: data, field: encoding.fieldRef(name)};\n};\n\n\nscale.range = function (s, encoding, layout, stats) {\n  var spec = encoding.scale(s.name),\n    field = encoding.field(s.name),\n    timeUnit = field.timeUnit;\n\n  switch (s.name) {\n    case X:\n      s.range = layout.cellWidth ? [0, layout.cellWidth] : 'width';\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(X, layout.x.useSmallBand);\n      } else {\n        if (encoding.isType(s.name,T) && timeUnit === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n      s.round = true;\n      if (s.type === 'time') {\n        s.nice = timeUnit || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (s.type === 'ordinal') {\n        s.range = layout.cellHeight ?\n          (field.bin ? [layout.cellHeight, 0] : [0, layout.cellHeight]) :\n          'height';\n        s.bandWidth = encoding.bandSize(Y, layout.y.useSmallBand);\n      } else {\n        s.range = layout.cellHeight ? [layout.cellHeight, 0] : 'height';\n        if (encoding.isType(s.name,T) && timeUnit === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n\n      s.round = true;\n\n      if (s.type === 'time') {\n        s.nice = timeUnit || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case ROW: // support only ordinal\n      s.bandWidth = layout.cellHeight;\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL: // support only ordinal\n      s.bandWidth = layout.cellWidth;\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is('bar')) {\n        // FIXME this is definitely incorrect\n        // but let's fix it later since bar size is a bad encoding anyway\n        s.range = [3, Math.max(encoding.bandSize(X), encoding.bandSize(Y))];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else { //point\n        var bandSize = Math.min(encoding.bandSize(X), encoding.bandSize(Y)) - 1;\n        s.range = [10, 0.8 * bandSize*bandSize];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = 'shapes';\n      break;\n    case COLOR:\n      s.range = scale.color(s, encoding, stats);\n      if (s.type !== 'ordinal') s.zero = false;\n      break;\n    default:\n      throw new Error('Unknown encoding name: '+ s.name);\n  }\n\n  // FIXME(kanitw): Jul 29, 2015 - consolidate this with above\n  switch (s.name) {\n    case ROW:\n    case COL:\n      s.padding = encoding.config('cellPadding');\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (s.type === 'ordinal') { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.field(s.name).band.padding;\n      }\n  }\n};\n\nscale.color = function(s, encoding, stats) {\n  var colorScale = encoding.scale(COLOR),\n    range = colorScale.range,\n    cardinality = encoding.cardinality(COLOR, stats),\n    type = encoding.type(COLOR);\n\n  if (range === undefined) {\n    var ordinalPalette = colorScale.ordinalPalette,\n      quantitativeRange = colorScale.quantitativeRange;\n\n    if (s.type === 'ordinal') {\n      if (type === N) {\n        // use categorical color scale\n        if (cardinality <= 10) {\n          range = colorScale.c10palette;\n        } else {\n          range = colorScale.c20palette;\n        }\n        return scale.color.palette(range, cardinality, type);\n      } else {\n        if (ordinalPalette) {\n          return scale.color.palette(ordinalPalette, cardinality, type);\n        }\n        return scale.color.interpolate(quantitativeRange[0], quantitativeRange[1], cardinality);\n      }\n    } else { //time or quantitative\n      return [quantitativeRange[0], quantitativeRange[1]];\n    }\n  }\n};\n\nscale.color.palette = function(range, cardinality, type) {\n  // FIXME(kanitw): Jul 29, 2015 - check range is string\n  switch (range) {\n    case 'category10k':\n      // tableau's category 10, ordered by perceptual kernel study results\n      // https://github.com/uwdata/perceptual-kernels\n      return ['#2ca02c', '#e377c2', '#7f7f7f', '#17becf', '#8c564b', '#d62728', '#bcbd22', '#9467bd', '#ff7f0e', '#1f77b4'];\n\n    // d3/tableau category10/20/20b/20c\n    case 'category10':\n      return ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];\n\n    case 'category20':\n      return ['#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'];\n\n    case 'category20b':\n      return ['#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39', '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b', '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'];\n\n    case 'category20c':\n      return ['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#e6550d', '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354', '#74c476', '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc', '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9'];\n  }\n\n  // TODO add our own set of custom ordinal color palette\n\n  if (range in colorbrewer) {\n    var palette = colorbrewer[range];\n\n    // if cardinality pre-defined, use it.\n    if (cardinality in palette) return palette[cardinality];\n\n    // if not, use the highest cardinality one for nominal\n    if (type === N) {\n      return palette[Math.max.apply(null, util.keys(palette))];\n    }\n\n    // otherwise, interpolate\n    var ps = cardinality < 3 ? 3 : Math.max.apply(null, util.keys(palette)),\n      from = 0 , to = ps - 1;\n    // FIXME add config for from / to\n\n    return scale.color.interpolate(palette[ps][from], palette[ps][to], cardinality);\n  }\n\n  return range;\n};\n\nscale.color.interpolate = function (start, end, cardinality) {\n\n  var interpolator = interpolate(start, end);\n  return util.range(cardinality).map(function(i) { return interpolator(i*1.0/(cardinality-1)); });\n};\n\n},{\"../globals\":25,\"../schema/schema\":27,\"../util\":29,\"./sort\":16,\"./time\":20,\"colorbrewer\":3,\"d3-color\":4}],16:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar vlfield = require('../field');\n\nmodule.exports = sort;\n\n// adds new transforms that produce sorted fields\nfunction sort(data, encoding, stats, opt) {\n  // jshint unused:false\n\n  var datasetMapping = {};\n\n  encoding.forEach(function(field, encType) {\n    var sortBy = encoding.sort(encType, stats);\n    if (sortBy.length > 0) {\n      var fields = sortBy.map(function(d) {\n        return {\n          op: d.aggregate,\n          field: vlfield.fieldRef(d, {nofn: true, data: !encoding._vega2})\n        };\n      });\n\n      var byClause = sortBy.map(function(d) {\n        var reverse = (d.reverse ? '-' : '');\n        return reverse + vlfield.fieldRef(d, {data: !encoding._vega2});\n      });\n\n      var dataName = sort.getDataName(encType);\n\n      var transforms = [\n        {\n          type: 'aggregate',\n          groupby: [ encoding.fieldRef(encType) ],\n          fields: fields\n        },\n        {\n          type: 'sort',\n          by: byClause\n        }\n      ];\n\n      data.push({\n        name: dataName,\n        source: RAW,\n        transform: transforms\n      });\n\n      datasetMapping[encType] = dataName;\n    }\n  });\n\n  return data;\n}\n\nsort.getDataName = function(encType) {\n  return 'sorted-' + encType;\n};\n\n\n},{\"../field\":24,\"../globals\":25}],17:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar  marks = require('./marks');\n\nmodule.exports = stacking;\n\nfunction stacking(data, encoding, mdef) {\n  if (!marks[encoding.marktype()].stack) return false;\n\n  // TODO: add || encoding.has(LOD) here once LOD is implemented\n  if (!encoding.has(COLOR)) return false;\n\n  var dim=null, val=null, idx =null,\n    isXMeasure = encoding.isMeasure(X),\n    isYMeasure = encoding.isMeasure(Y),\n    facets = encoding.facets();\n\n  if (isXMeasure && !isYMeasure) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  } else if (isYMeasure && !isXMeasure) {\n    dim = X;\n    val = Y;\n    idx = 1;\n  } else {\n    return null; // no stack encoding\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: encoding.dataTable(),\n    transform: [{\n      type: 'aggregate',\n      groupby: [encoding.fieldRef(dim)].concat(facets), // dim and other facets\n      fields: [{op: 'sum', field: encoding.fieldRef(val)}] // TODO check if field with aggregate is correct?\n    }]\n  };\n\n  if (facets && facets.length > 0) {\n    stacked.transform.push({ //calculate max for each facet\n      type: 'aggregate',\n      groupby: facets,\n      fields: [{\n        op: 'max',\n        field: encoding.fieldName(val, {fn: 'sum'})\n      }]\n    });\n  }\n\n  data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: 'stack',\n    point: encoding.fieldRef(dim),\n    height: encoding.fieldRef(val),\n    output: {y1: val, y0: val + '2'}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val + '2'] = mdef.properties.enter[val + '2'] = {scale: val, field: val + '2'};\n\n  return val; //return stack encoding\n}\n\n},{\"../globals\":25,\"./marks\":14}],18:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar vlfield = require('../field');\n\nmodule.exports = function(encoding, stats) {\n  return {\n    opacity: estimateOpacity(encoding, stats),\n  };\n};\n\nfunction estimateOpacity(encoding,stats) {\n  if (!stats) {\n    return 1;\n  }\n\n  var numPoints = 0;\n\n  if (encoding.isAggregate()) { // aggregate plot\n    numPoints = 1;\n\n    //  get number of points in each \"cell\"\n    //  by calculating product of cardinality\n    //  for each non faceting and non-ordinal X / Y fields\n    //  note that ordinal x,y are not include since we can\n    //  consider that ordinal x are subdividing the cell into subcells anyway\n    encoding.forEach(function(field, encType) {\n\n      if (encType !== ROW && encType !== COL &&\n          !((encType === X || encType === Y) &&\n          vlfield.isOrdinalScale(field))\n        ) {\n        numPoints *= encoding.cardinality(encType, stats);\n      }\n    });\n\n  } else { // raw plot\n\n    // TODO: error handling\n    if (!stats['*'])\n      return 1;\n\n    numPoints = stats['*'].max;  // count\n\n    // small multiples divide number of points\n    var numMultiples = 1;\n    if (encoding.has(ROW)) {\n      numMultiples *= encoding.cardinality(ROW, stats);\n    }\n    if (encoding.has(COL)) {\n      numMultiples *= encoding.cardinality(COL, stats);\n    }\n    numPoints /= numMultiples;\n  }\n\n  var opacity = 0;\n  if (numPoints <= 25) {\n    opacity = 1;\n  } else if (numPoints < 200) {\n    opacity = 0.8;\n  } else if (numPoints < 1000 || encoding.is('tick')) {\n    opacity = 0.7;\n  } else {\n    opacity = 0.3;\n  }\n\n  return opacity;\n}\n\n\n},{\"../field\":24,\"../globals\":25}],19:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nmodule.exports = subfaceting;\n\nfunction subfaceting(group, mdef, details, stack, encoding) {\n  var m = group.marks;\n  var g = {\n    _name: 'subfacet',\n    type: 'group',\n    from: mdef.from,\n    properties: {\n      enter: {\n        width: {group: 'width'},\n        height: {group: 'height'}\n      }\n    },\n    marks: m\n  };\n\n  group.marks = [g];\n  delete mdef.from; // (move to the new g)\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: 'facet', keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: 'sort', by: encoding.fieldRef(COLOR)});\n  }\n}\n\n},{\"../globals\":25}],20:[function(require,module,exports){\n'use strict';\n\nvar util = require('../util'),\n  d3_time_format = require('d3-time-format');\n\nvar time = module.exports = {};\n\n// 'Wednesday September 17 04:00:00 2014'\n// Wednesday is the longest date\n// September is the longest month (8 in javascript as it is zero-indexed).\nvar LONG_DATE = new Date(Date.UTC(2014, 8, 17));\n\ntime.cardinality = function(field, stats, filterNull, type) {\n  var timeUnit = field.timeUnit;\n  switch (timeUnit) {\n    case 'seconds': return 60;\n    case 'minutes': return 60;\n    case 'hours': return 24;\n    case 'day': return 7;\n    case 'date': return 31;\n    case 'month': return 12;\n    case 'year':\n      var stat = stats[field.name],\n        yearstat = stats['year_'+field.name];\n\n      if (!yearstat) { return null; }\n\n      return yearstat.distinct -\n        (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n  }\n\n  return null;\n};\n\ntime.formula = function(timeUnit, fieldRef) {\n  // TODO(kanitw): add formula to other time format\n  var fn = 'utc' + timeUnit;\n  return fn + '(' + fieldRef + ')';\n};\n\ntime.maxLength = function(timeUnit, encoding) {\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'date':\n      return 2;\n    case 'month':\n    case 'day':\n      var range = time.range(timeUnit, encoding);\n      if (range) {\n        // return the longest name in the range\n        return Math.max.apply(null, range.map(function(r) {return r.length;}));\n      }\n      return 2;\n    case 'year':\n      return 4; //'1998'\n  }\n  // TODO(#600) revise this\n  // no time unit\n  var timeFormat = encoding.config('timeFormat');\n  return d3_time_format.utcFormat(timeFormat)(LONG_DATE).length;\n};\n\ntime.range = function(timeUnit, encoding) {\n  var labelLength = encoding.config('timeScaleLabelLength'),\n    scaleLabel;\n  switch (timeUnit) {\n    case 'day':\n      scaleLabel = encoding.config('dayScaleLabel');\n      break;\n    case 'month':\n      scaleLabel = encoding.config('monthScaleLabel');\n      break;\n  }\n  if (scaleLabel) {\n    return labelLength ? scaleLabel.map(\n        function(s) { return s.substr(0, labelLength);}\n      ) : scaleLabel;\n  }\n  return;\n};\n\n\n/**\n * @param  {Object} encoding\n * @return {Array}  scales for time unit names\n */\ntime.scales = function(encoding) {\n  var scales = encoding.reduce(function(scales, field) {\n    var timeUnit = field.timeUnit;\n    if (field.type === T && timeUnit && !scales[timeUnit]) {\n      var scale = time.scale.def(field.timeUnit, encoding);\n      if (scale) scales[timeUnit] = scale;\n    }\n    return scales;\n  }, {});\n\n  return util.vals(scales);\n};\n\n\ntime.scale = {};\n\n/** append custom time scales for axis label */\ntime.scale.def = function(timeUnit, encoding) {\n  var range = time.range(timeUnit, encoding);\n\n  if (range) {\n    return {\n      name: 'time-'+timeUnit,\n      type: 'ordinal',\n      domain: time.scale.domain(timeUnit),\n      range: range\n    };\n  }\n  return null;\n};\n\ntime.isOrdinalFn = function(timeUnit) {\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'day':\n    case 'date':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\ntime.scale.type = function(timeUnit, name) {\n  if (name === COLOR) {\n    return 'linear'; // time has order, so use interpolated ordinal color scale.\n  }\n\n  return time.isOrdinalFn(timeUnit) || name === COL || name === ROW ? 'ordinal' : 'linear';\n};\n\ntime.scale.domain = function(timeUnit, name) {\n  var isColor = name === COLOR;\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes': return isColor ? [0,59] : util.range(0, 60);\n    case 'hours': return isColor ? [0,23] : util.range(0, 24);\n    case 'day': return isColor ? [0,6] : util.range(0, 7);\n    case 'date': return isColor ? [1,31] : util.range(1, 32);\n    case 'month': return isColor ? [0,11] : util.range(0, 12);\n  }\n  return null;\n};\n\n/** whether a particular time function has custom scale for labels implemented in time.scale */\ntime.hasScale = function(timeUnit) {\n  switch (timeUnit) {\n    case 'day':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\n},{\"../util\":29,\"d3-time-format\":6}],21:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, TEXT, DETAIL];\n\nconsts.shorthand = {\n  delim:  '|',\n  assign: '=',\n  type:   ',',\n  func:   '_'\n};\n\n},{\"./globals\":25}],22:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar stats = require('datalib/src/stats');\n\nvar vldata = module.exports = {};\n\n/** Mapping from datalib's inferred type to Vega-lite's type */\nvldata.types = {\n  'boolean': N,\n  'number': Q,\n  'integer': Q,\n  'date': T,\n  'string': N\n};\n\nvldata.stats = function(data) {\n  var summary = stats.summary(data);\n\n  return summary.reduce(function(s, profile) {\n    s[profile.field] = profile;\n    return s;\n  }, {\n    '*': {\n      max: data.length,\n      min: 0\n    }\n  });\n};\n},{\"./globals\":25,\"datalib/src/stats\":35}],23:[function(require,module,exports){\n// utility for enc\n\n'use strict';\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  vlfield = require('./field'),\n  util = require('./util'),\n  schema = require('./schema/schema'),\n  encTypes = schema.encTypes;\n\nvar vlenc = module.exports = {};\n\nvlenc.countRetinal = function(enc) {\n  var count = 0;\n  if (enc.color) count++;\n  if (enc.size) count++;\n  if (enc.shape) count++;\n  return count;\n};\n\nvlenc.has = function(enc, encType) {\n  var fieldDef = enc && enc[encType];\n  return fieldDef && fieldDef.name;\n};\n\nvlenc.isAggregate = function(enc) {\n  for (var k in enc) {\n    if (vlenc.has(enc, k) && enc[k].aggregate) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvlenc.forEach = function(enc, f) {\n  var i = 0;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      f(enc[k], k, i++);\n    }\n  });\n};\n\nvlenc.map = function(enc, f) {\n  var arr = [];\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      arr.push(f(enc[k], k, enc));\n    }\n  });\n  return arr;\n};\n\nvlenc.reduce = function(enc, f, init) {\n  var r = init;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      r = f(r, enc[k], k,  enc);\n    }\n  });\n  return r;\n};\n\n/*\n * return key-value pairs of field name and list of fields of that field name\n */\nvlenc.fields = function(enc) {\n  return vlenc.reduce(enc, function (m, field) {\n    var fieldList = m[field.name] = m[field.name] || [],\n      containsType = fieldList.containsType = fieldList.containsType || {};\n\n    if (fieldList.indexOf(field) === -1) {\n      fieldList.push(field);\n      // augment the array with containsType.Q / O / N / T\n      containsType[field.type] = true;\n    }\n    return m;\n  }, {});\n};\n\nvlenc.shorthand = function(enc) {\n  return vlenc.map(enc, function(field, et) {\n    return et + c.assign + vlfield.shorthand(field);\n  }).join(c.delim);\n};\n\nvlenc.fromShorthand = function(shorthand) {\n  var enc = util.isArray(shorthand) ? shorthand : shorthand.split(c.delim);\n  return enc.reduce(function(m, e) {\n    var split = e.split(c.assign),\n        enctype = split[0].trim(),\n        field = split[1];\n\n    m[enctype] = vlfield.fromShorthand(field);\n    return m;\n  }, {});\n};\n\n},{\"./consts\":21,\"./field\":24,\"./schema/schema\":27,\"./util\":29}],24:[function(require,module,exports){\n'use strict';\n\n// utility for field\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compiler/time'),\n  util = require('./util'),\n  schema = require('./schema/schema');\n\nvar vlfield = module.exports = {};\n\n/**\n * @param field\n * @param opt\n *   opt.nofn -- exclude bin, aggregate, timeUnit\n *   opt.data - include 'data.'\n *   opt.d - include 'd.'\n *   opt.fn - replace fn with custom function prefix\n *   opt.prefn - prepend fn with custom function prefix\n\n * @return {[type]}       [description]\n */\nvlfield.fieldRef = function(field, opt) {\n  opt = opt || {};\n\n  var f = (opt.d ? 'd.' : '') +\n          (opt.data ? 'data.' : '') +\n          (opt.prefn || ''),\n    nofn = opt.nofn || opt.fn,\n    name = field.name;\n\n  if (vlfield.isCount(field)) {\n    return f + 'count';\n  } else if (!nofn && field.bin) {\n    return f + 'bin_' + name;\n  } else if (!nofn && field.aggregate) {\n    return f + field.aggregate + '_' + name;\n  } else if (!nofn && field.timeUnit) {\n    return f + field.timeUnit + '_' + name;\n  } else if (opt.fn) {\n    return f + opt.fn + '_' + name;\n  } else {\n    return f + name;\n  }\n};\n\nvlfield.shorthand = function(f) {\n  var c = consts.shorthand;\n  return (f.aggregate ? f.aggregate + c.func : '') +\n    (f.timeUnit ? f.timeUnit + c.func : '') +\n    (f.bin ? 'bin' + c.func : '') +\n    (f.name || '') + c.type + f.type;\n};\n\nvlfield.shorthands = function(fields, delim) {\n  delim = delim || c.delim;\n  return fields.map(vlfield.shorthand).join(delim);\n};\n\nvlfield.fromShorthand = function(shorthand) {\n  var split = shorthand.split(c.type), i;\n  var o = {\n    name: split[0].trim(),\n    type: split[1].trim()\n  };\n\n  // check aggregate type\n  for (i in schema.aggregate.enum) {\n    var a = schema.aggregate.enum[i];\n    if (o.name.indexOf(a + '_') === 0) {\n      o.name = o.name.substr(a.length + 1);\n      if (a == 'count' && o.name.length === 0) o.name = '*';\n      o.aggregate = a;\n      break;\n    }\n  }\n\n  // check time timeUnit\n  for (i in schema.timefns) {\n    var tu = schema.timefns[i];\n    if (o.name && o.name.indexOf(tu + '_') === 0) {\n      o.name = o.name.substr(o.length + 1);\n      o.timeUnit = tu;\n      break;\n    }\n  }\n\n  // check bin\n  if (o.name && o.name.indexOf('bin_') === 0) {\n    o.name = o.name.substr(4);\n    o.bin = true;\n  }\n\n  return o;\n};\n\nvar isType = vlfield.isType = function (fieldDef, type) {\n  return fieldDef.type === type;\n};\n\nvar isTypes = vlfield.isTypes = function (fieldDef, types) {\n  for (var t=0; t<types.length; t++) {\n    if(fieldDef.type === types[t]) return true;\n  }\n  return false;\n};\n\n/*\n * Most fields that use ordinal scale are dimensions.\n * However, YEAR(T), YEARMONTH(T) use time scale, not ordinal but are dimensions too.\n */\nvlfield.isOrdinalScale = function(field) {\n  return  isTypes(field, [N, O]) || field.bin ||\n    ( isType(field, T) && field.timeUnit && time.isOrdinalFn(field.timeUnit) );\n};\n\nfunction isDimension(field) {\n  return  isTypes(field, [N, O]) || !!field.bin ||\n    ( isType(field, T) && !!field.timeUnit );\n}\n\n/**\n * For encoding, use encoding.isDimension() to avoid confusion.\n * Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.isDimension = function(field) {\n  return field && isDimension(field);\n};\n\nvlfield.isMeasure = function(field) {\n  return field && !isDimension(field);\n};\n\nvlfield.count = function() {\n  return {name:'*', aggregate: 'count', type: Q, displayName: vlfield.count.displayName};\n};\n\nvlfield.count.displayName = 'Number of Records';\n\nvlfield.isCount = function(field) {\n  return field.aggregate === 'count';\n};\n\n/**\n * For encoding, use encoding.cardinality() to avoid confusion.  Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.cardinality = function(field, stats, filterNull) {\n  // FIXME need to take filter into account\n\n  var stat = stats[field.name];\n  var type = field.type;\n\n  filterNull = filterNull || {};\n\n  if (field.bin) {\n    var bins = util.getbins(stat, field.bin.maxbins || schema.MAXBINS_DEFAULT);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  if (isType(field, T)) {\n    var cardinality = time.cardinality(field, stats, filterNull, type);\n    if(cardinality !== null) return cardinality;\n    //otherwise use calculation below\n  }\n  if (field.aggregate) {\n    return 1;\n  }\n\n  // remove null\n  return stat.distinct -\n    (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n};\n\n},{\"./compiler/time\":20,\"./consts\":21,\"./globals\":25,\"./schema/schema\":27,\"./util\":29}],25:[function(require,module,exports){\n(function (global){\n'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.AGGREGATE = 'aggregate';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.N = 'N';\ng.O = 'O';\ng.Q = 'Q';\ng.T = 'T';\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],26:[function(require,module,exports){\n'use strict';\n\n// TODO(kanitw): chat with Vega team and possibly move this to vega-logging\nmodule.exports = function(prefix) {\n  // Borrowed some ideas from http://stackoverflow.com/a/15653260/866989\n  // and https://github.com/patik/console.log-wrapper/blob/master/consolelog.js\n  var METHODS = ['error', 'info', 'debug', 'warn', 'log'];\n\n  return METHODS.reduce(function(logger, fn) {\n    var cfn = console[fn] ? fn : 'log';\n    if (console[cfn].bind === 'undefined') { // IE < 10\n        logger[fn] = Function.prototype.bind.call(console[cfn], console, prefix);\n    }\n    else {\n        logger[fn] = console[cfn].bind(console, prefix);\n    }\n    return logger;\n  }, {});\n};\n},{}],27:[function(require,module,exports){\n// Package of defining Vega-lite Specification's json schema\n'use strict';\n\nrequire('../globals');\n\nvar schema = module.exports = {},\n  util = require('../util'),\n  toMap = util.toMap,\n  colorbrewer = require('colorbrewer');\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: 'string',\n  enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\n};\n\nschema.aggregate = {\n  type: 'string',\n  enum: ['avg', 'sum', 'median', 'min', 'max', 'count'],\n  supportedEnums: {\n    Q: ['avg', 'median', 'sum', 'min', 'max', 'count'],\n    O: ['median','min','max'],\n    N: [],\n    T: ['avg', 'median', 'min', 'max'],\n    '': ['count']\n  },\n  supportedTypes: toMap([Q, N, O, T, ''])\n};\n\nschema.getSupportedRole = function(encType) {\n  return schema.schema.properties.encoding.properties[encType].supportedRole;\n};\n\nschema.timeUnits = ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'];\n\nschema.defaultTimeFn = 'month';\n\nschema.timeUnit = {\n  type: 'string',\n  enum: schema.timeUnits,\n  supportedTypes: toMap([T])\n};\n\nschema.scale_type = {\n  type: 'string',\n  // TODO(kanitw) read vega's schema here, add description\n  enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\n  default: 'linear',\n  supportedTypes: toMap([Q])\n};\n\nschema.field = {\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string'\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nschema.MAXBINS_DEFAULT = 15;\n\nvar bin = {\n  type: ['boolean', 'object'],\n  default: false,\n  properties: {\n    maxbins: {\n      type: 'integer',\n      default: schema.MAXBINS_DEFAULT,\n      minimum: 2,\n      description: 'Maximum number of bins.'\n    }\n  },\n  supportedTypes: toMap([Q]) // TODO: add O after finishing #81\n};\n\nvar typicalField = merge(clone(schema.field), {\n  type: 'object',\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T]\n    },\n    aggregate: schema.aggregate,\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    scale: {\n      type: 'object',\n      properties: {\n        /* Common Scale Properties */\n        type: schema.scale_type,\n        reverse: {\n          type: 'boolean',\n          default: false,\n          supportedTypes: toMap([Q, T])\n        },\n\n        /* Quantitative Scale Properties */\n        nice: {\n          type: 'string',\n          enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\n          supportedTypes: toMap([T])\n        },\n        zero: {\n          type: 'boolean',\n          description: 'Include zero',\n          default: true,\n          supportedTypes: toMap([Q, T])\n        },\n\n        /* Vega-lite only Properties */\n        useRawDomain: {\n          type: 'boolean',\n          default: undefined,\n          description: 'Use the raw data range as scale domain instead of ' +\n                       'aggregated data for aggregate axis. ' +\n                       'This option does not work with sum or count aggregate' +\n                       'as they might have a substantially larger scale range.' +\n                       'By default, use value from config.useRawDomain.'\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: 'object',\n  supportedRole: {\n    dimension: true\n  },\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T] // ordinal-only field supports Q when bin is applied and T when time unit is applied.\n    },\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    aggregate: {\n      type: 'string',\n      enum: ['count'],\n      supportedTypes: toMap([N, O]) // FIXME this looks weird to me\n    }\n  }\n});\n\nvar axisMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true},\n  properties: {\n    axis: {\n      type: 'object',\n      properties: {\n        /* Vega Axis Properties */\n        format: {\n          type: 'string',\n          default: undefined,  // auto\n          description: 'The formatting pattern for axis labels. '+\n                       'If not undefined, this will be determined by ' +\n                       'small/largeNumberFormat and the max value ' +\n                       'of the field.'\n        },\n        grid: {\n          type: 'boolean',\n          default: true,\n          description: 'A flag indicate if gridlines should be created in addition to ticks.'\n        },\n        layer: {\n          type: 'string',\n          default: 'back',\n          description: 'A string indicating if the axis (and any gridlines) should be placed above or below the data marks. One of \"front\" (default) or \"back\".'\n        },\n        orient: {\n          type: 'string',\n          default: undefined,\n          enum: ['top', 'right', 'left', 'bottom'],\n          description: 'The orientation of the axis. One of top, bottom, left or right. The orientation can be used to further specialize the axis type (e.g., a y axis oriented for the right edge of the chart).'\n        },\n        ticks: {\n          type: 'integer',\n          default: 5,\n          minimum: 0,\n          description: 'A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale\\'s range.'\n        },\n        /* Vega Axis Properties that are automatically populated by Vega-lite */\n        title: {\n          type: 'string',\n          default: undefined,\n          description: 'A title for the axis. (Shows field name and its function by default.)'\n        },\n        /* Vega-lite only */\n        maxLabelLength: {\n          type: 'integer',\n          default: 25,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        },\n        labelAngle: {\n          type: 'integer',\n          default: undefined, // auto\n          minimum: 0,\n          maximum: 360,\n          description: 'Angle by which to rotate labels. Set to 0 to force horizontal.'\n        },\n        titleMaxLength: {\n          type: 'integer',\n          default: undefined,\n          minimum: 0,\n          description: 'Max length for axis title if the title is automatically generated from the field\\'s description'\n        },\n        titleOffset: {\n          type: 'integer',\n          default: undefined,  // auto\n          description: 'A title offset value for the axis.'\n        },\n      }\n    }\n  }\n};\n\nvar sortMixin = {\n  type: 'object',\n  properties: {\n    sort: {\n      type: 'array',\n      default: [],\n      items: {\n        type: 'object',\n        supportedTypes: toMap([N, O]),\n        required: ['name', 'aggregate'],\n        properties: {\n          name: {\n            type: 'string'\n          },\n          aggregate: {\n            type: 'string',\n            enum: ['avg', 'sum', 'min', 'max', 'count']\n          },\n          reverse: {\n            type: 'boolean',\n            default: false\n          }\n        }\n      }\n    }\n  }\n};\n\nvar bandMixin = {\n  type: 'object',\n  properties: {\n    band: {\n      type: 'object',\n      properties: {\n        size: {\n          type: 'integer',\n          minimum: 0,\n          default: undefined\n        },\n        padding: {\n          type: 'integer',\n          minimum: 0,\n          default: 1\n        }\n      }\n    }\n  }\n};\n\nvar legendMixin = {\n  type: 'object',\n  properties: {\n    legend: {\n      type: 'object',\n      description: 'Properties of a legend.',\n      properties: {\n        title: {\n          type: 'string',\n          default: undefined,\n          description: 'A title for the legend. (Shows field name and its function by default.)'\n        }\n      }\n    }\n  }\n};\n\nvar textMixin = {\n  type: 'object',\n  supportedMarktypes: {'text': true},\n  properties: {\n    align: {\n      type: 'string',\n      default: 'right'\n    },\n    baseline: {\n      type: 'string',\n      default: 'middle'\n    },\n    color: {\n      type: 'string',\n      role: 'color',\n      default: '#000000'\n    },\n    margin: {\n      type: 'integer',\n      default: 4,\n      minimum: 0\n    },\n    placeholder: {\n      type: 'string',\n      default: 'Abc'\n    },\n    font: {\n      type: 'object',\n      properties: {\n        weight: {\n          type: 'string',\n          enum: ['normal', 'bold'],\n          default: 'normal'\n        },\n        size: {\n          type: 'integer',\n          default: 10,\n          minimum: 0\n        },\n        family: {\n          type: 'string',\n          default: 'Helvetica Neue'\n        },\n        style: {\n          type: 'string',\n          default: 'normal',\n          enum: ['normal', 'italic']\n        }\n      }\n    },\n    format: {\n      type: 'string',\n      default: undefined,  // auto\n      description: 'The formatting pattern for text value. '+\n                   'If not undefined, this will be determined by ' +\n                   'small/largeNumberFormat and the max value ' +\n                   'of the field.'\n    },\n  }\n};\n\nvar sizeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, bar: true, circle: true, square: true, text: true},\n  properties: {\n    value: {\n      type: 'integer',\n      default: 30,\n      minimum: 0,\n      description: 'Size of marks.'\n    }\n  }\n};\n\nvar colorMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'string',\n      role: 'color',\n      default: '#4682b4',\n      description: 'Color to be used for marks.'\n    },\n    opacity: {\n      type: 'number',\n      default: undefined,  // auto\n      minimum: 0,\n      maximum: 1\n    },\n    scale: {\n      type: 'object',\n      properties: {\n        range: {\n          type: ['string', 'array'],\n          default: undefined,\n          description:\n            'Color palette, if undefined vega-lite will use data property' +\n            'to pick one from c10palette, c20palette, or ordinalPalette.'\n            //FIXME\n        },\n        c10palette: {\n          type: 'string',\n          default: 'category10',\n          enum: [\n            // Tableau\n            'category10', 'category10k',\n            // Color Brewer\n            'Pastel1', 'Pastel2', 'Set1', 'Set2', 'Set3'\n          ]\n        },\n        c20palette: {\n          type: 'string',\n          default: 'category20',\n          enum: ['category20', 'category20b', 'category20c']\n        },\n        ordinalPalette: {\n          type: 'string',\n          default: undefined,\n          description: 'Color palette to encode ordinal variables.',\n          enum: util.keys(colorbrewer)\n        },\n        quantitativeRange: {\n          type: 'array',\n          default: ['#AFC6A3', '#09622A'], // tableau greens\n          // default: ['#ccece6', '#00441b'], // BuGn.9 [2-8]\n          description: 'Color range to encode quantitative variables.',\n          minItems: 2,\n          maxItems: 2,\n          items: {\n            type: 'string',\n            role: 'color'\n          }\n        }\n      }\n    }\n  }\n};\n\nvar shapeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, circle: true, square: true},\n  properties: {\n    value: {\n      type: 'string',\n      enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\n      default: 'circle',\n      description: 'Mark to be used.'\n    },\n    filled: {\n      type: 'boolean',\n      default: false,\n      description: 'Whether the shape\\'s color should be used as fill color instead of stroke color.'\n    }\n  }\n};\n\nvar detailMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, line: true, circle: true, square: true}\n};\n\nvar rowMixin = {\n  properties: {\n    height: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    }\n  }\n};\n\nvar colMixin = {\n  properties: {\n    width: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    axis: {\n      properties: {\n        maxLabelLength: {\n          type: 'integer',\n          default: 12,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar facetMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, text: true},\n  properties: {\n    padding: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.1\n    }\n  }\n};\n\nvar requiredNameType = {\n  required: ['name', 'type']\n};\n\nvar multiRoleField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: true\n  }\n});\n\nvar quantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: 'ordinal-only' // using size to encoding category lead to order interpretation\n  }\n});\n\nvar onlyQuantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true\n  }\n});\n\nvar x = merge(clone(multiRoleField), axisMixin, bandMixin, requiredNameType, sortMixin);\nvar y = clone(x);\n\nvar facet = merge(clone(onlyOrdinalField), requiredNameType, facetMixin, sortMixin);\nvar row = merge(clone(facet), axisMixin, rowMixin);\nvar col = merge(clone(facet), axisMixin, colMixin);\n\nvar size = merge(clone(quantitativeField), legendMixin, sizeMixin, sortMixin);\nvar color = merge(clone(multiRoleField), legendMixin, colorMixin, sortMixin);\n\nvar shape = merge(clone(onlyOrdinalField), legendMixin, shapeMixin, sortMixin);\nvar detail = merge(clone(onlyOrdinalField), detailMixin, sortMixin);\n\n// we only put aggregated measure in pivot table\nvar text = merge(clone(onlyQuantitativeField), textMixin, sortMixin);\n\n// TODO add label\n\nvar filter = {\n  type: 'array',\n  items: {\n    type: 'object',\n    properties: {\n      operands: {\n        type: 'array',\n        items: {\n          type: ['string', 'boolean', 'integer', 'number']\n        }\n      },\n      operator: {\n        type: 'string',\n        enum: ['>', '>=', '=', '!=', '<', '<=', 'notNull']\n      }\n    }\n  }\n};\n\nvar data = {\n  type: 'object',\n  properties: {\n    // data source\n    formatType: {\n      type: 'string',\n      enum: ['json', 'csv'],\n      default: 'json'\n    },\n    url: {\n      type: 'string',\n      default: undefined\n    },\n    values: {\n      type: 'array',\n      default: undefined,\n      description: 'Pass array of objects instead of a url to a file.',\n      items: {\n        type: 'object',\n        additionalProperties: true\n      }\n    }\n  }\n};\n\nvar config = {\n  type: 'object',\n  properties: {\n    // template\n    width: {\n      type: 'integer',\n      default: undefined\n    },\n    height: {\n      type: 'integer',\n      default: undefined\n    },\n    viewport: {\n      type: 'array',\n      items: {\n        type: 'integer'\n      },\n      default: undefined\n    },\n    gridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#000000'\n    },\n    gridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.08\n    },\n\n    // filter null\n    // TODO(#597) revise this config\n    filterNull: {\n      type: 'object',\n      properties: {\n        O: {type:'boolean', default: false},\n        Q: {type:'boolean', default: true},\n        T: {type:'boolean', default: true}\n      }\n    },\n    toggleSort: {\n      type: 'string',\n      default: O\n    },\n    autoSortLine: {\n      type: 'boolean',\n      default: true\n    },\n\n    // single plot\n    singleHeight: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    singleWidth: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    // band size\n    largeBandSize: {\n      type: 'integer',\n      default: 21,\n      minimum: 0\n    },\n    smallBandSize: {\n      //small multiples or single plot with high cardinality\n      type: 'integer',\n      default: 12,\n      minimum: 0\n    },\n    largeBandMaxCardinality: {\n      type: 'integer',\n      default: 10\n    },\n    // small multiples\n    cellPadding: {\n      type: 'number',\n      default: 0.1\n    },\n    cellGridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#000000'\n    },\n    cellGridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.15\n    },\n    cellBackgroundColor: {\n      type: 'string',\n      role: 'color',\n      default: 'rgba(0,0,0,0)'\n    },\n    textCellWidth: {\n      type: 'integer',\n      default: 90,\n      minimum: 0\n    },\n\n    // marks\n    strokeWidth: {\n      type: 'integer',\n      default: 2,\n      minimum: 0\n    },\n    singleBarOffset: {\n      type: 'integer',\n      default: 5,\n      minimum: 0\n    },\n    // scales\n    timeScaleLabelLength: {\n      type: 'integer',\n      default: 3,\n      minimum: 0,\n      description: 'Max length for values in dayScaleLabel and monthScaleLabel.  Zero means using full names in dayScaleLabel/monthScaleLabel.'\n    },\n    dayScaleLabel: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      default: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n      description: 'Axis labels for day of week, starting from Sunday.' +\n        '(Consistent with Javascript -- See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getDay.'\n    },\n    monthScaleLabel: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      default: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n      description: 'Axis labels for month.'\n    },\n    // other\n    characterWidth: {\n      type: 'integer',\n      default: 6\n    },\n    maxSmallNumber: {\n      type: 'number',\n      default: 10000,\n      description: 'maximum number that a field will be considered smallNumber.'+\n                   'Used for axis labelling.'\n    },\n    smallNumberFormat: {\n      type: 'string',\n      default: '',\n      description: 'D3 Number format for axis labels and text tables '+\n                   'for number <= maxSmallNumber. Used for axis labelling.'\n    },\n    largeNumberFormat: {\n      type: 'string',\n      default: '.3s',\n      description: 'D3 Number format for axis labels and text tables ' +\n                   'for number > maxSmallNumber.'\n    },\n    timeFormat: {\n      type: 'string',\n      default: '%Y-%m-%d',\n      description: 'Date format for axis labels.'\n    },\n    useRawDomain: {\n      type: 'boolean',\n      default: false,\n      description: 'Use the raw data range as scale domain instead of ' +\n                   'aggregated data for aggregate axis. ' +\n                   'This option does not work with sum or count aggregate' +\n                   'as they might have a substantially larger scale range.' +\n                   'By default, use value from config.useRawDomain.'\n    }\n  }\n};\n\n/** @type Object Schema of a vega-lite specification */\nschema.schema = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  description: 'Schema for Vega-lite specification',\n  type: 'object',\n  required: ['marktype', 'encoding', 'data'],\n  properties: {\n    data: data,\n    marktype: schema.marktype,\n    encoding: {\n      type: 'object',\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        shape: shape,\n        text: text,\n        detail: detail\n      }\n    },\n    filter: filter,\n    config: config\n  }\n};\n\nschema.encTypes = util.keys(schema.schema.properties.encoding.properties);\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function() {\n  return schema.util.instantiate(schema.schema);\n};\n\n},{\"../globals\":25,\"../util\":29,\"./schemautil\":28,\"colorbrewer\":3}],28:[function(require,module,exports){\n'use strict';\n\nvar schemautil = module.exports = {},\n  util = require('../util');\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\nschemautil.extend = function(instance, schema) {\n  return schemautil.merge(schemautil.instantiate(schema), instance);\n};\n\n// instantiate a schema\nschemautil.instantiate = function(schema) {\n  var val;\n  if (schema === undefined) {\n    return undefined;\n  } else if ('default' in schema) {\n    val = schema.default;\n    return util.isObject(val) ? util.duplicate(val) : val;\n  } else if (schema.type === 'object') {\n    var instance = {};\n    for (var name in schema.properties) {\n      val = schemautil.instantiate(schema.properties[name]);\n      if (val !== undefined) {\n        instance[name] = val;\n      }\n    }\n    return instance;\n  } else if (schema.type === 'array') {\n    return [];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nschemautil.subtract = function(instance, defaults) {\n  var changes = {};\n  for (var prop in instance) {\n    var def = defaults[prop];\n    var ins = instance[prop];\n    // Note: does not properly subtract arrays\n    if (!defaults || def !== ins) {\n      if (typeof ins === 'object' && !util.isArray(ins) && def) {\n        var c = schemautil.subtract(ins, def);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else if (!util.isArray(ins) || ins.length > 0) {\n        changes[prop] = ins;\n      }\n    }\n  }\n  return changes;\n};\n\nschemautil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction merge(dest, src) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (var p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      merge(dest[p], src[p]);\n    }\n  }\n  return dest;\n}\n},{\"../util\":29}],29:[function(require,module,exports){\n'use strict';\n\nvar util = module.exports = require('datalib/src/util');\n\nutil.extend(util, require('datalib/src/generate'));\nutil.extend(util, require('datalib/src/stats'));\nutil.extend(util, require('./logger')('[VL Error]'));\nutil.bin = require('datalib/src/bins/bins');\n\nutil.isin = function(item, array) {\n  return array.indexOf(item) !== -1;\n};\n\nutil.forEach = function(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  } else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k , obj);\n    }\n  }\n};\n\nutil.reduce = function(obj, f, init, thisArg) {\n  if (obj.reduce) {\n    return obj.reduce.call(thisArg, f, init);\n  } else {\n    for (var k in obj) {\n      init = f.call(thisArg, init, obj[k], k, obj);\n    }\n    return init;\n  }\n};\n\nutil.map = function(obj, f, thisArg) {\n  if (obj.map) {\n    return obj.map.call(thisArg, f);\n  } else {\n    var output = [];\n    for (var k in obj) {\n      output.push( f.call(thisArg, obj[k], k, obj));\n    }\n  }\n};\n\nutil.any = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (f(arr[k], k, i++)) return true;\n  }\n  return false;\n};\n\nutil.all = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (!f(arr[k], k, i++)) return false;\n  }\n  return true;\n};\n\nutil.getbins = function(stats, maxbins) {\n  return util.bin({\n    min: stats.min,\n    max: stats.max,\n    maxbins: maxbins\n  });\n};\n\n/**\n * x[p[0]]...[p[n]] = val\n * @param noaugment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.setter = function(x, p, val, noaugment) {\n  for (var i=0; i<p.length-1; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  x[p[i]] = val;\n};\n\n\n/**\n * returns x[p[0]]...[p[n]]\n * @param augment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.getter = function(x, p, noaugment) {\n  for (var i=0; i<p.length; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  return x;\n};\n\n\n},{\"./logger\":26,\"datalib/src/bins/bins\":32,\"datalib/src/generate\":33,\"datalib/src/stats\":35,\"datalib/src/util\":37}],30:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar util = require('./util'),\n    consts = require('./consts');\n\nvar vl = {};\n\nutil.extend(vl, consts, util);\n\nvl.Encoding = require('./Encoding');\nvl.compiler = require('./compiler/compiler');\nvl.compile = vl.compiler.compile;\nvl.data = require('./data');\nvl.enc = require('./enc');\nvl.field = require('./field');\nvl.schema = require('./schema/schema');\nvl.toShorthand = vl.Encoding.shorthand;\nvl.format = require('d3-format').format;\n\nmodule.exports = vl;\n},{\"./Encoding\":7,\"./compiler/compiler\":9,\"./consts\":21,\"./data\":22,\"./enc\":23,\"./field\":24,\"./globals\":25,\"./schema/schema\":27,\"./util\":29,\"d3-format\":5}],31:[function(require,module,exports){\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t1 = new Date;\n\n  var t0 = new Date;\n\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  }\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  exports.seconds = second.range;\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  exports.minutes = minute.range;\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  exports.hours = hour.range;\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  exports.days = day.range;\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  exports.sunday = weekday(0);\n\n  exports.sundays = exports.sunday.range;\n\n  exports.monday = weekday(1);\n\n  exports.mondays = exports.monday.range;\n\n  exports.tuesday = weekday(2);\n\n  exports.tuesdays = exports.tuesday.range;\n\n  exports.wednesday = weekday(3);\n\n  exports.wednesdays = exports.wednesday.range;\n\n  exports.thursday = weekday(4);\n\n  exports.thursdays = exports.thursday.range;\n\n  exports.friday = weekday(5);\n\n  exports.fridays = exports.friday.range;\n\n  exports.saturday = weekday(6);\n\n  exports.saturdays = exports.saturday.range;\n\n  var week = exports.sunday;\n\n  exports.weeks = week.range;\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  });\n\n  exports.months = month.range;\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  exports.years = year.range;\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  exports.utcSeconds = utcSecond.range;\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  exports.utcMinutes = utcMinute.range;\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  exports.utcHours = utcHour.range;\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  exports.utcDays = utcDay.range;\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  exports.utcSunday = utcWeekday(0);\n\n  exports.utcSundays = exports.utcSunday.range;\n\n  exports.utcMonday = utcWeekday(1);\n\n  exports.utcMondays = exports.utcMonday.range;\n\n  exports.utcTuesday = utcWeekday(2);\n\n  exports.utcTuesdays = exports.utcTuesday.range;\n\n  exports.utcWednesday = utcWeekday(3);\n\n  exports.utcWednesdays = exports.utcWednesday.range;\n\n  exports.utcThursday = utcWeekday(4);\n\n  exports.utcThursdays = exports.utcThursday.range;\n\n  exports.utcFriday = utcWeekday(5);\n\n  exports.utcFridays = exports.utcFriday.range;\n\n  exports.utcSaturday = utcWeekday(6);\n\n  exports.utcSaturdays = exports.utcSaturday.range;\n\n  var utcWeek = exports.utcSunday;\n\n  exports.utcWeeks = utcWeek.range;\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  });\n\n  exports.utcMonths = utcMonth.range;\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  exports.utcYears = utcYear.range;\n\n  exports.interval = newInterval;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.week = week;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcWeek = utcWeek;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n\n}));\n},{}],32:[function(require,module,exports){\nvar util = require('../util'),\n    time = require('../time'),\n    EPSILON = 1e-15;\n\nfunction bins(opt) {\n  if (!opt) { throw Error(\"Missing binning options.\"); }\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  if (!opt) { throw Error(\"Missing date binning options.\"); }\n\n  // find time step, then bin\n  var units = opt.utc ? time.utc : time,\n      dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n\n},{\"../time\":36,\"../util\":37}],33:[function(require,module,exports){\nvar gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n},{}],34:[function(require,module,exports){\nvar util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    types[f] = infer(data, f);\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;\n},{\"../util\":37}],35:[function(require,module,exports){\nvar util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length < 2) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (v === v) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (v === v) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance] \n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;\n},{\"./generate\":33,\"./import/type\":34,\"./util\":37}],36:[function(require,module,exports){\nvar d3_time = require('d3-time');\n\nvar tempDate = new Date(),\n    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD\n    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);\n\nfunction date(d) {\n  return (tempDate.setTime(+d), tempDate);\n}\n\n// create a time unit entry\nfunction entry(type, date, unit, step, min, max) {\n  var e = {\n    type: type,\n    date: date,\n    unit: unit\n  };\n  if (step) {\n    e.step = step;\n  } else {\n    e.minstep = 1;\n  }\n  if (min != null) e.min = min;\n  if (max != null) e.max = max;\n  return e;\n}\n\nfunction create(type, unit, base, step, min, max) {\n  return entry(type,\n    function(d) { return unit.offset(base, d); },\n    function(d) { return unit.count(base, d); },\n    step, min, max);\n}\n\nvar locale = [\n  create('second', d3_time.second, baseDate),\n  create('minute', d3_time.minute, baseDate),\n  create('hour',   d3_time.hour,   baseDate),\n  create('day',    d3_time.day,    baseDate, [1, 7]),\n  create('month',  d3_time.month,  baseDate, [1, 3, 6]),\n  create('year',   d3_time.year,   baseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(1970, 0, 1, 0, 0, d); },\n    function(d) { return date(d).getSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(1970, 0, 1, 0, d); },\n    function(d) { return date(d).getMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(1970, 0, 1, d); },\n    function(d) { return date(d).getHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(1970, 0, 4+d); },\n    function(d) { return date(d).getDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(1970, 0, d); },\n    function(d) { return date(d).getDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(1970, d % 12, 1); },\n    function(d) { return date(d).getMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar utc = [\n  create('second', d3_time.utcSecond, utcBaseDate),\n  create('minute', d3_time.utcMinute, utcBaseDate),\n  create('hour',   d3_time.utcHour,   utcBaseDate),\n  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),\n  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),\n  create('year',   d3_time.utcYear,   utcBaseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },\n    function(d) { return date(d).getUTCSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },\n    function(d) { return date(d).getUTCMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },\n    function(d) { return date(d).getUTCHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },\n    function(d) { return date(d).getUTCDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(Date.UTC(1970, 0, d)); },\n    function(d) { return date(d).getUTCDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },\n    function(d) { return date(d).getUTCMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction find(units, span, minb, maxb) {\n  var step = STEPS[0], i, n, bins;\n\n  for (i=1, n=STEPS.length; i<n; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return units[STEPS[i-1][1]];\n      }\n      if (bins >= minb) {\n        return units[step[1]];\n      }\n    }\n  }\n  return units[STEPS[n-1][1]];\n}\n\nfunction toUnitMap(units) {\n  var map = {}, i, n;\n  for (i=0, n=units.length; i<n; ++i) {\n    map[units[i].type] = units[i];\n  }\n  map.find = function(span, minb, maxb) {\n    return find(units, span, minb, maxb);\n  };\n  return map;\n}\n\nmodule.exports = toUnitMap(locale);\nmodule.exports.utc = toUnitMap(utc);\n\n},{\"d3-time\":31}],37:[function(require,module,exports){\nvar buffer = require('buffer'),\n    time = require('./time'),\n    utc = time.utc;\n\nvar u = module.exports = {};\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (buffer.Buffer && buffer.Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\nu.date = function(s) {\n  return s == null || s === '' ? null : Date.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nu.field = function(f) {\n  return String(f).split('\\\\.')\n    .map(function(d) { return d.split('.'); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += '.' + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\nu.$year   = u.$func('year', time.year.unit);\nu.$month  = u.$func('month', time.months.unit);\nu.$date   = u.$func('date', time.dates.unit);\nu.$day    = u.$func('day', time.weekdays.unit);\nu.$hour   = u.$func('hour', time.hours.unit);\nu.$minute = u.$func('minute', time.minutes.unit);\nu.$second = u.$func('second', time.seconds.unit);\n\nu.$utcYear   = u.$func('utcYear', utc.year.unit);\nu.$utcMonth  = u.$func('utcMonth', utc.months.unit);\nu.$utcDate   = u.$func('utcDate', utc.dates.unit);\nu.$utcDay    = u.$func('utcDay', utc.weekdays.unit);\nu.$utcHour   = u.$func('utcHour', utc.hours.unit);\nu.$utcMinute = u.$func('utcMinute', utc.minutes.unit);\nu.$utcSecond = u.$func('utcSecond', utc.seconds.unit);\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n\n},{\"./time\":36,\"buffer\":1}]},{},[30])(30)\n});\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yYnJld2VyL2NvbG9yYnJld2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yYnJld2VyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2QzLWNvbG9yL2J1aWxkL2NvbG9yLmpzIiwibm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9idWlsZC9mb3JtYXQuanMiLCJub2RlX21vZHVsZXMvZDMtdGltZS1mb3JtYXQvYnVpbGQvdGltZUZvcm1hdC5qcyIsInNyYy9FbmNvZGluZy5qcyIsInNyYy9jb21waWxlci9heGlzLmpzIiwic3JjL2NvbXBpbGVyL2NvbXBpbGVyLmpzIiwic3JjL2NvbXBpbGVyL2RhdGEuanMiLCJzcmMvY29tcGlsZXIvZmFjZXQuanMiLCJzcmMvY29tcGlsZXIvbGF5b3V0LmpzIiwic3JjL2NvbXBpbGVyL2xlZ2VuZC5qcyIsInNyYy9jb21waWxlci9tYXJrcy5qcyIsInNyYy9jb21waWxlci9zY2FsZS5qcyIsInNyYy9jb21waWxlci9zb3J0LmpzIiwic3JjL2NvbXBpbGVyL3N0YWNrLmpzIiwic3JjL2NvbXBpbGVyL3N0eWxlLmpzIiwic3JjL2NvbXBpbGVyL3N1YmZhY2V0LmpzIiwic3JjL2NvbXBpbGVyL3RpbWUuanMiLCJzcmMvY29uc3RzLmpzIiwic3JjL2RhdGEuanMiLCJzcmMvZW5jLmpzIiwic3JjL2ZpZWxkLmpzIiwic3JjL2dsb2JhbHMuanMiLCJzcmMvbG9nZ2VyLmpzIiwic3JjL3NjaGVtYS9zY2hlbWEuanMiLCJzcmMvc2NoZW1hL3NjaGVtYXV0aWwuanMiLCJzcmMvdXRpbC5qcyIsInNyYy92bCIsIi4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2RhdGFsaWIvbm9kZV9tb2R1bGVzL2QzLXRpbWUvYnVpbGQvdGltZS5qcyIsIi4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2JpbnMvYmlucy5qcyIsIi4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2dlbmVyYXRlLmpzIiwiLi4vLi4vLi4vLi4vLi4vdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L3R5cGUuanMiLCIuLi8uLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9zdGF0cy5qcyIsIi4uLy4uLy4uLy4uLy4uL3Vzci9sb2NhbC9saWIvbm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL3RpbWUuanMiLCIuLi8uLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy91dGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0b0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzE0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLG51bGwsIi8vIFRoaXMgcHJvZHVjdCBpbmNsdWRlcyBjb2xvciBzcGVjaWZpY2F0aW9ucyBhbmQgZGVzaWducyBkZXZlbG9wZWQgYnkgQ3ludGhpYSBCcmV3ZXIgKGh0dHA6Ly9jb2xvcmJyZXdlci5vcmcvKS5cbi8vIEphdmFTY3JpcHQgc3BlY3MgYXMgcGFja2FnZWQgaW4gdGhlIEQzIGxpYnJhcnkgKGQzanMub3JnKS4gUGxlYXNlIHNlZSBsaWNlbnNlIGF0IGh0dHA6Ly9jb2xvcmJyZXdlci5vcmcvZXhwb3J0L0xJQ0VOU0UudHh0XG4hZnVuY3Rpb24oKSB7XG5cbnZhciBjb2xvcmJyZXdlciA9IHtZbEduOiB7XG4zOiBbXCIjZjdmY2I5XCIsXCIjYWRkZDhlXCIsXCIjMzFhMzU0XCJdLFxuNDogW1wiI2ZmZmZjY1wiLFwiI2MyZTY5OVwiLFwiIzc4YzY3OVwiLFwiIzIzODQ0M1wiXSxcbjU6IFtcIiNmZmZmY2NcIixcIiNjMmU2OTlcIixcIiM3OGM2NzlcIixcIiMzMWEzNTRcIixcIiMwMDY4MzdcIl0sXG42OiBbXCIjZmZmZmNjXCIsXCIjZDlmMGEzXCIsXCIjYWRkZDhlXCIsXCIjNzhjNjc5XCIsXCIjMzFhMzU0XCIsXCIjMDA2ODM3XCJdLFxuNzogW1wiI2ZmZmZjY1wiLFwiI2Q5ZjBhM1wiLFwiI2FkZGQ4ZVwiLFwiIzc4YzY3OVwiLFwiIzQxYWI1ZFwiLFwiIzIzODQ0M1wiLFwiIzAwNWEzMlwiXSxcbjg6IFtcIiNmZmZmZTVcIixcIiNmN2ZjYjlcIixcIiNkOWYwYTNcIixcIiNhZGRkOGVcIixcIiM3OGM2NzlcIixcIiM0MWFiNWRcIixcIiMyMzg0NDNcIixcIiMwMDVhMzJcIl0sXG45OiBbXCIjZmZmZmU1XCIsXCIjZjdmY2I5XCIsXCIjZDlmMGEzXCIsXCIjYWRkZDhlXCIsXCIjNzhjNjc5XCIsXCIjNDFhYjVkXCIsXCIjMjM4NDQzXCIsXCIjMDA2ODM3XCIsXCIjMDA0NTI5XCJdXG59LFlsR25CdToge1xuMzogW1wiI2VkZjhiMVwiLFwiIzdmY2RiYlwiLFwiIzJjN2ZiOFwiXSxcbjQ6IFtcIiNmZmZmY2NcIixcIiNhMWRhYjRcIixcIiM0MWI2YzRcIixcIiMyMjVlYThcIl0sXG41OiBbXCIjZmZmZmNjXCIsXCIjYTFkYWI0XCIsXCIjNDFiNmM0XCIsXCIjMmM3ZmI4XCIsXCIjMjUzNDk0XCJdLFxuNjogW1wiI2ZmZmZjY1wiLFwiI2M3ZTliNFwiLFwiIzdmY2RiYlwiLFwiIzQxYjZjNFwiLFwiIzJjN2ZiOFwiLFwiIzI1MzQ5NFwiXSxcbjc6IFtcIiNmZmZmY2NcIixcIiNjN2U5YjRcIixcIiM3ZmNkYmJcIixcIiM0MWI2YzRcIixcIiMxZDkxYzBcIixcIiMyMjVlYThcIixcIiMwYzJjODRcIl0sXG44OiBbXCIjZmZmZmQ5XCIsXCIjZWRmOGIxXCIsXCIjYzdlOWI0XCIsXCIjN2ZjZGJiXCIsXCIjNDFiNmM0XCIsXCIjMWQ5MWMwXCIsXCIjMjI1ZWE4XCIsXCIjMGMyYzg0XCJdLFxuOTogW1wiI2ZmZmZkOVwiLFwiI2VkZjhiMVwiLFwiI2M3ZTliNFwiLFwiIzdmY2RiYlwiLFwiIzQxYjZjNFwiLFwiIzFkOTFjMFwiLFwiIzIyNWVhOFwiLFwiIzI1MzQ5NFwiLFwiIzA4MWQ1OFwiXVxufSxHbkJ1OiB7XG4zOiBbXCIjZTBmM2RiXCIsXCIjYThkZGI1XCIsXCIjNDNhMmNhXCJdLFxuNDogW1wiI2YwZjllOFwiLFwiI2JhZTRiY1wiLFwiIzdiY2NjNFwiLFwiIzJiOGNiZVwiXSxcbjU6IFtcIiNmMGY5ZThcIixcIiNiYWU0YmNcIixcIiM3YmNjYzRcIixcIiM0M2EyY2FcIixcIiMwODY4YWNcIl0sXG42OiBbXCIjZjBmOWU4XCIsXCIjY2NlYmM1XCIsXCIjYThkZGI1XCIsXCIjN2JjY2M0XCIsXCIjNDNhMmNhXCIsXCIjMDg2OGFjXCJdLFxuNzogW1wiI2YwZjllOFwiLFwiI2NjZWJjNVwiLFwiI2E4ZGRiNVwiLFwiIzdiY2NjNFwiLFwiIzRlYjNkM1wiLFwiIzJiOGNiZVwiLFwiIzA4NTg5ZVwiXSxcbjg6IFtcIiNmN2ZjZjBcIixcIiNlMGYzZGJcIixcIiNjY2ViYzVcIixcIiNhOGRkYjVcIixcIiM3YmNjYzRcIixcIiM0ZWIzZDNcIixcIiMyYjhjYmVcIixcIiMwODU4OWVcIl0sXG45OiBbXCIjZjdmY2YwXCIsXCIjZTBmM2RiXCIsXCIjY2NlYmM1XCIsXCIjYThkZGI1XCIsXCIjN2JjY2M0XCIsXCIjNGViM2QzXCIsXCIjMmI4Y2JlXCIsXCIjMDg2OGFjXCIsXCIjMDg0MDgxXCJdXG59LEJ1R246IHtcbjM6IFtcIiNlNWY1ZjlcIixcIiM5OWQ4YzlcIixcIiMyY2EyNWZcIl0sXG40OiBbXCIjZWRmOGZiXCIsXCIjYjJlMmUyXCIsXCIjNjZjMmE0XCIsXCIjMjM4YjQ1XCJdLFxuNTogW1wiI2VkZjhmYlwiLFwiI2IyZTJlMlwiLFwiIzY2YzJhNFwiLFwiIzJjYTI1ZlwiLFwiIzAwNmQyY1wiXSxcbjY6IFtcIiNlZGY4ZmJcIixcIiNjY2VjZTZcIixcIiM5OWQ4YzlcIixcIiM2NmMyYTRcIixcIiMyY2EyNWZcIixcIiMwMDZkMmNcIl0sXG43OiBbXCIjZWRmOGZiXCIsXCIjY2NlY2U2XCIsXCIjOTlkOGM5XCIsXCIjNjZjMmE0XCIsXCIjNDFhZTc2XCIsXCIjMjM4YjQ1XCIsXCIjMDA1ODI0XCJdLFxuODogW1wiI2Y3ZmNmZFwiLFwiI2U1ZjVmOVwiLFwiI2NjZWNlNlwiLFwiIzk5ZDhjOVwiLFwiIzY2YzJhNFwiLFwiIzQxYWU3NlwiLFwiIzIzOGI0NVwiLFwiIzAwNTgyNFwiXSxcbjk6IFtcIiNmN2ZjZmRcIixcIiNlNWY1ZjlcIixcIiNjY2VjZTZcIixcIiM5OWQ4YzlcIixcIiM2NmMyYTRcIixcIiM0MWFlNzZcIixcIiMyMzhiNDVcIixcIiMwMDZkMmNcIixcIiMwMDQ0MWJcIl1cbn0sUHVCdUduOiB7XG4zOiBbXCIjZWNlMmYwXCIsXCIjYTZiZGRiXCIsXCIjMWM5MDk5XCJdLFxuNDogW1wiI2Y2ZWZmN1wiLFwiI2JkYzllMVwiLFwiIzY3YTljZlwiLFwiIzAyODE4YVwiXSxcbjU6IFtcIiNmNmVmZjdcIixcIiNiZGM5ZTFcIixcIiM2N2E5Y2ZcIixcIiMxYzkwOTlcIixcIiMwMTZjNTlcIl0sXG42OiBbXCIjZjZlZmY3XCIsXCIjZDBkMWU2XCIsXCIjYTZiZGRiXCIsXCIjNjdhOWNmXCIsXCIjMWM5MDk5XCIsXCIjMDE2YzU5XCJdLFxuNzogW1wiI2Y2ZWZmN1wiLFwiI2QwZDFlNlwiLFwiI2E2YmRkYlwiLFwiIzY3YTljZlwiLFwiIzM2OTBjMFwiLFwiIzAyODE4YVwiLFwiIzAxNjQ1MFwiXSxcbjg6IFtcIiNmZmY3ZmJcIixcIiNlY2UyZjBcIixcIiNkMGQxZTZcIixcIiNhNmJkZGJcIixcIiM2N2E5Y2ZcIixcIiMzNjkwYzBcIixcIiMwMjgxOGFcIixcIiMwMTY0NTBcIl0sXG45OiBbXCIjZmZmN2ZiXCIsXCIjZWNlMmYwXCIsXCIjZDBkMWU2XCIsXCIjYTZiZGRiXCIsXCIjNjdhOWNmXCIsXCIjMzY5MGMwXCIsXCIjMDI4MThhXCIsXCIjMDE2YzU5XCIsXCIjMDE0NjM2XCJdXG59LFB1QnU6IHtcbjM6IFtcIiNlY2U3ZjJcIixcIiNhNmJkZGJcIixcIiMyYjhjYmVcIl0sXG40OiBbXCIjZjFlZWY2XCIsXCIjYmRjOWUxXCIsXCIjNzRhOWNmXCIsXCIjMDU3MGIwXCJdLFxuNTogW1wiI2YxZWVmNlwiLFwiI2JkYzllMVwiLFwiIzc0YTljZlwiLFwiIzJiOGNiZVwiLFwiIzA0NWE4ZFwiXSxcbjY6IFtcIiNmMWVlZjZcIixcIiNkMGQxZTZcIixcIiNhNmJkZGJcIixcIiM3NGE5Y2ZcIixcIiMyYjhjYmVcIixcIiMwNDVhOGRcIl0sXG43OiBbXCIjZjFlZWY2XCIsXCIjZDBkMWU2XCIsXCIjYTZiZGRiXCIsXCIjNzRhOWNmXCIsXCIjMzY5MGMwXCIsXCIjMDU3MGIwXCIsXCIjMDM0ZTdiXCJdLFxuODogW1wiI2ZmZjdmYlwiLFwiI2VjZTdmMlwiLFwiI2QwZDFlNlwiLFwiI2E2YmRkYlwiLFwiIzc0YTljZlwiLFwiIzM2OTBjMFwiLFwiIzA1NzBiMFwiLFwiIzAzNGU3YlwiXSxcbjk6IFtcIiNmZmY3ZmJcIixcIiNlY2U3ZjJcIixcIiNkMGQxZTZcIixcIiNhNmJkZGJcIixcIiM3NGE5Y2ZcIixcIiMzNjkwYzBcIixcIiMwNTcwYjBcIixcIiMwNDVhOGRcIixcIiMwMjM4NThcIl1cbn0sQnVQdToge1xuMzogW1wiI2UwZWNmNFwiLFwiIzllYmNkYVwiLFwiIzg4NTZhN1wiXSxcbjQ6IFtcIiNlZGY4ZmJcIixcIiNiM2NkZTNcIixcIiM4Yzk2YzZcIixcIiM4ODQxOWRcIl0sXG41OiBbXCIjZWRmOGZiXCIsXCIjYjNjZGUzXCIsXCIjOGM5NmM2XCIsXCIjODg1NmE3XCIsXCIjODEwZjdjXCJdLFxuNjogW1wiI2VkZjhmYlwiLFwiI2JmZDNlNlwiLFwiIzllYmNkYVwiLFwiIzhjOTZjNlwiLFwiIzg4NTZhN1wiLFwiIzgxMGY3Y1wiXSxcbjc6IFtcIiNlZGY4ZmJcIixcIiNiZmQzZTZcIixcIiM5ZWJjZGFcIixcIiM4Yzk2YzZcIixcIiM4YzZiYjFcIixcIiM4ODQxOWRcIixcIiM2ZTAxNmJcIl0sXG44OiBbXCIjZjdmY2ZkXCIsXCIjZTBlY2Y0XCIsXCIjYmZkM2U2XCIsXCIjOWViY2RhXCIsXCIjOGM5NmM2XCIsXCIjOGM2YmIxXCIsXCIjODg0MTlkXCIsXCIjNmUwMTZiXCJdLFxuOTogW1wiI2Y3ZmNmZFwiLFwiI2UwZWNmNFwiLFwiI2JmZDNlNlwiLFwiIzllYmNkYVwiLFwiIzhjOTZjNlwiLFwiIzhjNmJiMVwiLFwiIzg4NDE5ZFwiLFwiIzgxMGY3Y1wiLFwiIzRkMDA0YlwiXVxufSxSZFB1OiB7XG4zOiBbXCIjZmRlMGRkXCIsXCIjZmE5ZmI1XCIsXCIjYzUxYjhhXCJdLFxuNDogW1wiI2ZlZWJlMlwiLFwiI2ZiYjRiOVwiLFwiI2Y3NjhhMVwiLFwiI2FlMDE3ZVwiXSxcbjU6IFtcIiNmZWViZTJcIixcIiNmYmI0YjlcIixcIiNmNzY4YTFcIixcIiNjNTFiOGFcIixcIiM3YTAxNzdcIl0sXG42OiBbXCIjZmVlYmUyXCIsXCIjZmNjNWMwXCIsXCIjZmE5ZmI1XCIsXCIjZjc2OGExXCIsXCIjYzUxYjhhXCIsXCIjN2EwMTc3XCJdLFxuNzogW1wiI2ZlZWJlMlwiLFwiI2ZjYzVjMFwiLFwiI2ZhOWZiNVwiLFwiI2Y3NjhhMVwiLFwiI2RkMzQ5N1wiLFwiI2FlMDE3ZVwiLFwiIzdhMDE3N1wiXSxcbjg6IFtcIiNmZmY3ZjNcIixcIiNmZGUwZGRcIixcIiNmY2M1YzBcIixcIiNmYTlmYjVcIixcIiNmNzY4YTFcIixcIiNkZDM0OTdcIixcIiNhZTAxN2VcIixcIiM3YTAxNzdcIl0sXG45OiBbXCIjZmZmN2YzXCIsXCIjZmRlMGRkXCIsXCIjZmNjNWMwXCIsXCIjZmE5ZmI1XCIsXCIjZjc2OGExXCIsXCIjZGQzNDk3XCIsXCIjYWUwMTdlXCIsXCIjN2EwMTc3XCIsXCIjNDkwMDZhXCJdXG59LFB1UmQ6IHtcbjM6IFtcIiNlN2UxZWZcIixcIiNjOTk0YzdcIixcIiNkZDFjNzdcIl0sXG40OiBbXCIjZjFlZWY2XCIsXCIjZDdiNWQ4XCIsXCIjZGY2NWIwXCIsXCIjY2UxMjU2XCJdLFxuNTogW1wiI2YxZWVmNlwiLFwiI2Q3YjVkOFwiLFwiI2RmNjViMFwiLFwiI2RkMWM3N1wiLFwiIzk4MDA0M1wiXSxcbjY6IFtcIiNmMWVlZjZcIixcIiNkNGI5ZGFcIixcIiNjOTk0YzdcIixcIiNkZjY1YjBcIixcIiNkZDFjNzdcIixcIiM5ODAwNDNcIl0sXG43OiBbXCIjZjFlZWY2XCIsXCIjZDRiOWRhXCIsXCIjYzk5NGM3XCIsXCIjZGY2NWIwXCIsXCIjZTcyOThhXCIsXCIjY2UxMjU2XCIsXCIjOTEwMDNmXCJdLFxuODogW1wiI2Y3ZjRmOVwiLFwiI2U3ZTFlZlwiLFwiI2Q0YjlkYVwiLFwiI2M5OTRjN1wiLFwiI2RmNjViMFwiLFwiI2U3Mjk4YVwiLFwiI2NlMTI1NlwiLFwiIzkxMDAzZlwiXSxcbjk6IFtcIiNmN2Y0ZjlcIixcIiNlN2UxZWZcIixcIiNkNGI5ZGFcIixcIiNjOTk0YzdcIixcIiNkZjY1YjBcIixcIiNlNzI5OGFcIixcIiNjZTEyNTZcIixcIiM5ODAwNDNcIixcIiM2NzAwMWZcIl1cbn0sT3JSZDoge1xuMzogW1wiI2ZlZThjOFwiLFwiI2ZkYmI4NFwiLFwiI2UzNGEzM1wiXSxcbjQ6IFtcIiNmZWYwZDlcIixcIiNmZGNjOGFcIixcIiNmYzhkNTlcIixcIiNkNzMwMWZcIl0sXG41OiBbXCIjZmVmMGQ5XCIsXCIjZmRjYzhhXCIsXCIjZmM4ZDU5XCIsXCIjZTM0YTMzXCIsXCIjYjMwMDAwXCJdLFxuNjogW1wiI2ZlZjBkOVwiLFwiI2ZkZDQ5ZVwiLFwiI2ZkYmI4NFwiLFwiI2ZjOGQ1OVwiLFwiI2UzNGEzM1wiLFwiI2IzMDAwMFwiXSxcbjc6IFtcIiNmZWYwZDlcIixcIiNmZGQ0OWVcIixcIiNmZGJiODRcIixcIiNmYzhkNTlcIixcIiNlZjY1NDhcIixcIiNkNzMwMWZcIixcIiM5OTAwMDBcIl0sXG44OiBbXCIjZmZmN2VjXCIsXCIjZmVlOGM4XCIsXCIjZmRkNDllXCIsXCIjZmRiYjg0XCIsXCIjZmM4ZDU5XCIsXCIjZWY2NTQ4XCIsXCIjZDczMDFmXCIsXCIjOTkwMDAwXCJdLFxuOTogW1wiI2ZmZjdlY1wiLFwiI2ZlZThjOFwiLFwiI2ZkZDQ5ZVwiLFwiI2ZkYmI4NFwiLFwiI2ZjOGQ1OVwiLFwiI2VmNjU0OFwiLFwiI2Q3MzAxZlwiLFwiI2IzMDAwMFwiLFwiIzdmMDAwMFwiXVxufSxZbE9yUmQ6IHtcbjM6IFtcIiNmZmVkYTBcIixcIiNmZWIyNGNcIixcIiNmMDNiMjBcIl0sXG40OiBbXCIjZmZmZmIyXCIsXCIjZmVjYzVjXCIsXCIjZmQ4ZDNjXCIsXCIjZTMxYTFjXCJdLFxuNTogW1wiI2ZmZmZiMlwiLFwiI2ZlY2M1Y1wiLFwiI2ZkOGQzY1wiLFwiI2YwM2IyMFwiLFwiI2JkMDAyNlwiXSxcbjY6IFtcIiNmZmZmYjJcIixcIiNmZWQ5NzZcIixcIiNmZWIyNGNcIixcIiNmZDhkM2NcIixcIiNmMDNiMjBcIixcIiNiZDAwMjZcIl0sXG43OiBbXCIjZmZmZmIyXCIsXCIjZmVkOTc2XCIsXCIjZmViMjRjXCIsXCIjZmQ4ZDNjXCIsXCIjZmM0ZTJhXCIsXCIjZTMxYTFjXCIsXCIjYjEwMDI2XCJdLFxuODogW1wiI2ZmZmZjY1wiLFwiI2ZmZWRhMFwiLFwiI2ZlZDk3NlwiLFwiI2ZlYjI0Y1wiLFwiI2ZkOGQzY1wiLFwiI2ZjNGUyYVwiLFwiI2UzMWExY1wiLFwiI2IxMDAyNlwiXSxcbjk6IFtcIiNmZmZmY2NcIixcIiNmZmVkYTBcIixcIiNmZWQ5NzZcIixcIiNmZWIyNGNcIixcIiNmZDhkM2NcIixcIiNmYzRlMmFcIixcIiNlMzFhMWNcIixcIiNiZDAwMjZcIixcIiM4MDAwMjZcIl1cbn0sWWxPckJyOiB7XG4zOiBbXCIjZmZmN2JjXCIsXCIjZmVjNDRmXCIsXCIjZDk1ZjBlXCJdLFxuNDogW1wiI2ZmZmZkNFwiLFwiI2ZlZDk4ZVwiLFwiI2ZlOTkyOVwiLFwiI2NjNGMwMlwiXSxcbjU6IFtcIiNmZmZmZDRcIixcIiNmZWQ5OGVcIixcIiNmZTk5MjlcIixcIiNkOTVmMGVcIixcIiM5OTM0MDRcIl0sXG42OiBbXCIjZmZmZmQ0XCIsXCIjZmVlMzkxXCIsXCIjZmVjNDRmXCIsXCIjZmU5OTI5XCIsXCIjZDk1ZjBlXCIsXCIjOTkzNDA0XCJdLFxuNzogW1wiI2ZmZmZkNFwiLFwiI2ZlZTM5MVwiLFwiI2ZlYzQ0ZlwiLFwiI2ZlOTkyOVwiLFwiI2VjNzAxNFwiLFwiI2NjNGMwMlwiLFwiIzhjMmQwNFwiXSxcbjg6IFtcIiNmZmZmZTVcIixcIiNmZmY3YmNcIixcIiNmZWUzOTFcIixcIiNmZWM0NGZcIixcIiNmZTk5MjlcIixcIiNlYzcwMTRcIixcIiNjYzRjMDJcIixcIiM4YzJkMDRcIl0sXG45OiBbXCIjZmZmZmU1XCIsXCIjZmZmN2JjXCIsXCIjZmVlMzkxXCIsXCIjZmVjNDRmXCIsXCIjZmU5OTI5XCIsXCIjZWM3MDE0XCIsXCIjY2M0YzAyXCIsXCIjOTkzNDA0XCIsXCIjNjYyNTA2XCJdXG59LFB1cnBsZXM6IHtcbjM6IFtcIiNlZmVkZjVcIixcIiNiY2JkZGNcIixcIiM3NTZiYjFcIl0sXG40OiBbXCIjZjJmMGY3XCIsXCIjY2JjOWUyXCIsXCIjOWU5YWM4XCIsXCIjNmE1MWEzXCJdLFxuNTogW1wiI2YyZjBmN1wiLFwiI2NiYzllMlwiLFwiIzllOWFjOFwiLFwiIzc1NmJiMVwiLFwiIzU0Mjc4ZlwiXSxcbjY6IFtcIiNmMmYwZjdcIixcIiNkYWRhZWJcIixcIiNiY2JkZGNcIixcIiM5ZTlhYzhcIixcIiM3NTZiYjFcIixcIiM1NDI3OGZcIl0sXG43OiBbXCIjZjJmMGY3XCIsXCIjZGFkYWViXCIsXCIjYmNiZGRjXCIsXCIjOWU5YWM4XCIsXCIjODA3ZGJhXCIsXCIjNmE1MWEzXCIsXCIjNGExNDg2XCJdLFxuODogW1wiI2ZjZmJmZFwiLFwiI2VmZWRmNVwiLFwiI2RhZGFlYlwiLFwiI2JjYmRkY1wiLFwiIzllOWFjOFwiLFwiIzgwN2RiYVwiLFwiIzZhNTFhM1wiLFwiIzRhMTQ4NlwiXSxcbjk6IFtcIiNmY2ZiZmRcIixcIiNlZmVkZjVcIixcIiNkYWRhZWJcIixcIiNiY2JkZGNcIixcIiM5ZTlhYzhcIixcIiM4MDdkYmFcIixcIiM2YTUxYTNcIixcIiM1NDI3OGZcIixcIiMzZjAwN2RcIl1cbn0sQmx1ZXM6IHtcbjM6IFtcIiNkZWViZjdcIixcIiM5ZWNhZTFcIixcIiMzMTgyYmRcIl0sXG40OiBbXCIjZWZmM2ZmXCIsXCIjYmRkN2U3XCIsXCIjNmJhZWQ2XCIsXCIjMjE3MWI1XCJdLFxuNTogW1wiI2VmZjNmZlwiLFwiI2JkZDdlN1wiLFwiIzZiYWVkNlwiLFwiIzMxODJiZFwiLFwiIzA4NTE5Y1wiXSxcbjY6IFtcIiNlZmYzZmZcIixcIiNjNmRiZWZcIixcIiM5ZWNhZTFcIixcIiM2YmFlZDZcIixcIiMzMTgyYmRcIixcIiMwODUxOWNcIl0sXG43OiBbXCIjZWZmM2ZmXCIsXCIjYzZkYmVmXCIsXCIjOWVjYWUxXCIsXCIjNmJhZWQ2XCIsXCIjNDI5MmM2XCIsXCIjMjE3MWI1XCIsXCIjMDg0NTk0XCJdLFxuODogW1wiI2Y3ZmJmZlwiLFwiI2RlZWJmN1wiLFwiI2M2ZGJlZlwiLFwiIzllY2FlMVwiLFwiIzZiYWVkNlwiLFwiIzQyOTJjNlwiLFwiIzIxNzFiNVwiLFwiIzA4NDU5NFwiXSxcbjk6IFtcIiNmN2ZiZmZcIixcIiNkZWViZjdcIixcIiNjNmRiZWZcIixcIiM5ZWNhZTFcIixcIiM2YmFlZDZcIixcIiM0MjkyYzZcIixcIiMyMTcxYjVcIixcIiMwODUxOWNcIixcIiMwODMwNmJcIl1cbn0sR3JlZW5zOiB7XG4zOiBbXCIjZTVmNWUwXCIsXCIjYTFkOTliXCIsXCIjMzFhMzU0XCJdLFxuNDogW1wiI2VkZjhlOVwiLFwiI2JhZTRiM1wiLFwiIzc0YzQ3NlwiLFwiIzIzOGI0NVwiXSxcbjU6IFtcIiNlZGY4ZTlcIixcIiNiYWU0YjNcIixcIiM3NGM0NzZcIixcIiMzMWEzNTRcIixcIiMwMDZkMmNcIl0sXG42OiBbXCIjZWRmOGU5XCIsXCIjYzdlOWMwXCIsXCIjYTFkOTliXCIsXCIjNzRjNDc2XCIsXCIjMzFhMzU0XCIsXCIjMDA2ZDJjXCJdLFxuNzogW1wiI2VkZjhlOVwiLFwiI2M3ZTljMFwiLFwiI2ExZDk5YlwiLFwiIzc0YzQ3NlwiLFwiIzQxYWI1ZFwiLFwiIzIzOGI0NVwiLFwiIzAwNWEzMlwiXSxcbjg6IFtcIiNmN2ZjZjVcIixcIiNlNWY1ZTBcIixcIiNjN2U5YzBcIixcIiNhMWQ5OWJcIixcIiM3NGM0NzZcIixcIiM0MWFiNWRcIixcIiMyMzhiNDVcIixcIiMwMDVhMzJcIl0sXG45OiBbXCIjZjdmY2Y1XCIsXCIjZTVmNWUwXCIsXCIjYzdlOWMwXCIsXCIjYTFkOTliXCIsXCIjNzRjNDc2XCIsXCIjNDFhYjVkXCIsXCIjMjM4YjQ1XCIsXCIjMDA2ZDJjXCIsXCIjMDA0NDFiXCJdXG59LE9yYW5nZXM6IHtcbjM6IFtcIiNmZWU2Y2VcIixcIiNmZGFlNmJcIixcIiNlNjU1MGRcIl0sXG40OiBbXCIjZmVlZGRlXCIsXCIjZmRiZTg1XCIsXCIjZmQ4ZDNjXCIsXCIjZDk0NzAxXCJdLFxuNTogW1wiI2ZlZWRkZVwiLFwiI2ZkYmU4NVwiLFwiI2ZkOGQzY1wiLFwiI2U2NTUwZFwiLFwiI2E2MzYwM1wiXSxcbjY6IFtcIiNmZWVkZGVcIixcIiNmZGQwYTJcIixcIiNmZGFlNmJcIixcIiNmZDhkM2NcIixcIiNlNjU1MGRcIixcIiNhNjM2MDNcIl0sXG43OiBbXCIjZmVlZGRlXCIsXCIjZmRkMGEyXCIsXCIjZmRhZTZiXCIsXCIjZmQ4ZDNjXCIsXCIjZjE2OTEzXCIsXCIjZDk0ODAxXCIsXCIjOGMyZDA0XCJdLFxuODogW1wiI2ZmZjVlYlwiLFwiI2ZlZTZjZVwiLFwiI2ZkZDBhMlwiLFwiI2ZkYWU2YlwiLFwiI2ZkOGQzY1wiLFwiI2YxNjkxM1wiLFwiI2Q5NDgwMVwiLFwiIzhjMmQwNFwiXSxcbjk6IFtcIiNmZmY1ZWJcIixcIiNmZWU2Y2VcIixcIiNmZGQwYTJcIixcIiNmZGFlNmJcIixcIiNmZDhkM2NcIixcIiNmMTY5MTNcIixcIiNkOTQ4MDFcIixcIiNhNjM2MDNcIixcIiM3ZjI3MDRcIl1cbn0sUmVkczoge1xuMzogW1wiI2ZlZTBkMlwiLFwiI2ZjOTI3MlwiLFwiI2RlMmQyNlwiXSxcbjQ6IFtcIiNmZWU1ZDlcIixcIiNmY2FlOTFcIixcIiNmYjZhNGFcIixcIiNjYjE4MWRcIl0sXG41OiBbXCIjZmVlNWQ5XCIsXCIjZmNhZTkxXCIsXCIjZmI2YTRhXCIsXCIjZGUyZDI2XCIsXCIjYTUwZjE1XCJdLFxuNjogW1wiI2ZlZTVkOVwiLFwiI2ZjYmJhMVwiLFwiI2ZjOTI3MlwiLFwiI2ZiNmE0YVwiLFwiI2RlMmQyNlwiLFwiI2E1MGYxNVwiXSxcbjc6IFtcIiNmZWU1ZDlcIixcIiNmY2JiYTFcIixcIiNmYzkyNzJcIixcIiNmYjZhNGFcIixcIiNlZjNiMmNcIixcIiNjYjE4MWRcIixcIiM5OTAwMGRcIl0sXG44OiBbXCIjZmZmNWYwXCIsXCIjZmVlMGQyXCIsXCIjZmNiYmExXCIsXCIjZmM5MjcyXCIsXCIjZmI2YTRhXCIsXCIjZWYzYjJjXCIsXCIjY2IxODFkXCIsXCIjOTkwMDBkXCJdLFxuOTogW1wiI2ZmZjVmMFwiLFwiI2ZlZTBkMlwiLFwiI2ZjYmJhMVwiLFwiI2ZjOTI3MlwiLFwiI2ZiNmE0YVwiLFwiI2VmM2IyY1wiLFwiI2NiMTgxZFwiLFwiI2E1MGYxNVwiLFwiIzY3MDAwZFwiXVxufSxHcmV5czoge1xuMzogW1wiI2YwZjBmMFwiLFwiI2JkYmRiZFwiLFwiIzYzNjM2M1wiXSxcbjQ6IFtcIiNmN2Y3ZjdcIixcIiNjY2NjY2NcIixcIiM5Njk2OTZcIixcIiM1MjUyNTJcIl0sXG41OiBbXCIjZjdmN2Y3XCIsXCIjY2NjY2NjXCIsXCIjOTY5Njk2XCIsXCIjNjM2MzYzXCIsXCIjMjUyNTI1XCJdLFxuNjogW1wiI2Y3ZjdmN1wiLFwiI2Q5ZDlkOVwiLFwiI2JkYmRiZFwiLFwiIzk2OTY5NlwiLFwiIzYzNjM2M1wiLFwiIzI1MjUyNVwiXSxcbjc6IFtcIiNmN2Y3ZjdcIixcIiNkOWQ5ZDlcIixcIiNiZGJkYmRcIixcIiM5Njk2OTZcIixcIiM3MzczNzNcIixcIiM1MjUyNTJcIixcIiMyNTI1MjVcIl0sXG44OiBbXCIjZmZmZmZmXCIsXCIjZjBmMGYwXCIsXCIjZDlkOWQ5XCIsXCIjYmRiZGJkXCIsXCIjOTY5Njk2XCIsXCIjNzM3MzczXCIsXCIjNTI1MjUyXCIsXCIjMjUyNTI1XCJdLFxuOTogW1wiI2ZmZmZmZlwiLFwiI2YwZjBmMFwiLFwiI2Q5ZDlkOVwiLFwiI2JkYmRiZFwiLFwiIzk2OTY5NlwiLFwiIzczNzM3M1wiLFwiIzUyNTI1MlwiLFwiIzI1MjUyNVwiLFwiIzAwMDAwMFwiXVxufSxQdU9yOiB7XG4zOiBbXCIjZjFhMzQwXCIsXCIjZjdmN2Y3XCIsXCIjOTk4ZWMzXCJdLFxuNDogW1wiI2U2NjEwMVwiLFwiI2ZkYjg2M1wiLFwiI2IyYWJkMlwiLFwiIzVlM2M5OVwiXSxcbjU6IFtcIiNlNjYxMDFcIixcIiNmZGI4NjNcIixcIiNmN2Y3ZjdcIixcIiNiMmFiZDJcIixcIiM1ZTNjOTlcIl0sXG42OiBbXCIjYjM1ODA2XCIsXCIjZjFhMzQwXCIsXCIjZmVlMGI2XCIsXCIjZDhkYWViXCIsXCIjOTk4ZWMzXCIsXCIjNTQyNzg4XCJdLFxuNzogW1wiI2IzNTgwNlwiLFwiI2YxYTM0MFwiLFwiI2ZlZTBiNlwiLFwiI2Y3ZjdmN1wiLFwiI2Q4ZGFlYlwiLFwiIzk5OGVjM1wiLFwiIzU0Mjc4OFwiXSxcbjg6IFtcIiNiMzU4MDZcIixcIiNlMDgyMTRcIixcIiNmZGI4NjNcIixcIiNmZWUwYjZcIixcIiNkOGRhZWJcIixcIiNiMmFiZDJcIixcIiM4MDczYWNcIixcIiM1NDI3ODhcIl0sXG45OiBbXCIjYjM1ODA2XCIsXCIjZTA4MjE0XCIsXCIjZmRiODYzXCIsXCIjZmVlMGI2XCIsXCIjZjdmN2Y3XCIsXCIjZDhkYWViXCIsXCIjYjJhYmQyXCIsXCIjODA3M2FjXCIsXCIjNTQyNzg4XCJdLFxuMTA6IFtcIiM3ZjNiMDhcIixcIiNiMzU4MDZcIixcIiNlMDgyMTRcIixcIiNmZGI4NjNcIixcIiNmZWUwYjZcIixcIiNkOGRhZWJcIixcIiNiMmFiZDJcIixcIiM4MDczYWNcIixcIiM1NDI3ODhcIixcIiMyZDAwNGJcIl0sXG4xMTogW1wiIzdmM2IwOFwiLFwiI2IzNTgwNlwiLFwiI2UwODIxNFwiLFwiI2ZkYjg2M1wiLFwiI2ZlZTBiNlwiLFwiI2Y3ZjdmN1wiLFwiI2Q4ZGFlYlwiLFwiI2IyYWJkMlwiLFwiIzgwNzNhY1wiLFwiIzU0Mjc4OFwiLFwiIzJkMDA0YlwiXVxufSxCckJHOiB7XG4zOiBbXCIjZDhiMzY1XCIsXCIjZjVmNWY1XCIsXCIjNWFiNGFjXCJdLFxuNDogW1wiI2E2NjExYVwiLFwiI2RmYzI3ZFwiLFwiIzgwY2RjMVwiLFwiIzAxODU3MVwiXSxcbjU6IFtcIiNhNjYxMWFcIixcIiNkZmMyN2RcIixcIiNmNWY1ZjVcIixcIiM4MGNkYzFcIixcIiMwMTg1NzFcIl0sXG42OiBbXCIjOGM1MTBhXCIsXCIjZDhiMzY1XCIsXCIjZjZlOGMzXCIsXCIjYzdlYWU1XCIsXCIjNWFiNGFjXCIsXCIjMDE2NjVlXCJdLFxuNzogW1wiIzhjNTEwYVwiLFwiI2Q4YjM2NVwiLFwiI2Y2ZThjM1wiLFwiI2Y1ZjVmNVwiLFwiI2M3ZWFlNVwiLFwiIzVhYjRhY1wiLFwiIzAxNjY1ZVwiXSxcbjg6IFtcIiM4YzUxMGFcIixcIiNiZjgxMmRcIixcIiNkZmMyN2RcIixcIiNmNmU4YzNcIixcIiNjN2VhZTVcIixcIiM4MGNkYzFcIixcIiMzNTk3OGZcIixcIiMwMTY2NWVcIl0sXG45OiBbXCIjOGM1MTBhXCIsXCIjYmY4MTJkXCIsXCIjZGZjMjdkXCIsXCIjZjZlOGMzXCIsXCIjZjVmNWY1XCIsXCIjYzdlYWU1XCIsXCIjODBjZGMxXCIsXCIjMzU5NzhmXCIsXCIjMDE2NjVlXCJdLFxuMTA6IFtcIiM1NDMwMDVcIixcIiM4YzUxMGFcIixcIiNiZjgxMmRcIixcIiNkZmMyN2RcIixcIiNmNmU4YzNcIixcIiNjN2VhZTVcIixcIiM4MGNkYzFcIixcIiMzNTk3OGZcIixcIiMwMTY2NWVcIixcIiMwMDNjMzBcIl0sXG4xMTogW1wiIzU0MzAwNVwiLFwiIzhjNTEwYVwiLFwiI2JmODEyZFwiLFwiI2RmYzI3ZFwiLFwiI2Y2ZThjM1wiLFwiI2Y1ZjVmNVwiLFwiI2M3ZWFlNVwiLFwiIzgwY2RjMVwiLFwiIzM1OTc4ZlwiLFwiIzAxNjY1ZVwiLFwiIzAwM2MzMFwiXVxufSxQUkduOiB7XG4zOiBbXCIjYWY4ZGMzXCIsXCIjZjdmN2Y3XCIsXCIjN2ZiZjdiXCJdLFxuNDogW1wiIzdiMzI5NFwiLFwiI2MyYTVjZlwiLFwiI2E2ZGJhMFwiLFwiIzAwODgzN1wiXSxcbjU6IFtcIiM3YjMyOTRcIixcIiNjMmE1Y2ZcIixcIiNmN2Y3ZjdcIixcIiNhNmRiYTBcIixcIiMwMDg4MzdcIl0sXG42OiBbXCIjNzYyYTgzXCIsXCIjYWY4ZGMzXCIsXCIjZTdkNGU4XCIsXCIjZDlmMGQzXCIsXCIjN2ZiZjdiXCIsXCIjMWI3ODM3XCJdLFxuNzogW1wiIzc2MmE4M1wiLFwiI2FmOGRjM1wiLFwiI2U3ZDRlOFwiLFwiI2Y3ZjdmN1wiLFwiI2Q5ZjBkM1wiLFwiIzdmYmY3YlwiLFwiIzFiNzgzN1wiXSxcbjg6IFtcIiM3NjJhODNcIixcIiM5OTcwYWJcIixcIiNjMmE1Y2ZcIixcIiNlN2Q0ZThcIixcIiNkOWYwZDNcIixcIiNhNmRiYTBcIixcIiM1YWFlNjFcIixcIiMxYjc4MzdcIl0sXG45OiBbXCIjNzYyYTgzXCIsXCIjOTk3MGFiXCIsXCIjYzJhNWNmXCIsXCIjZTdkNGU4XCIsXCIjZjdmN2Y3XCIsXCIjZDlmMGQzXCIsXCIjYTZkYmEwXCIsXCIjNWFhZTYxXCIsXCIjMWI3ODM3XCJdLFxuMTA6IFtcIiM0MDAwNGJcIixcIiM3NjJhODNcIixcIiM5OTcwYWJcIixcIiNjMmE1Y2ZcIixcIiNlN2Q0ZThcIixcIiNkOWYwZDNcIixcIiNhNmRiYTBcIixcIiM1YWFlNjFcIixcIiMxYjc4MzdcIixcIiMwMDQ0MWJcIl0sXG4xMTogW1wiIzQwMDA0YlwiLFwiIzc2MmE4M1wiLFwiIzk5NzBhYlwiLFwiI2MyYTVjZlwiLFwiI2U3ZDRlOFwiLFwiI2Y3ZjdmN1wiLFwiI2Q5ZjBkM1wiLFwiI2E2ZGJhMFwiLFwiIzVhYWU2MVwiLFwiIzFiNzgzN1wiLFwiIzAwNDQxYlwiXVxufSxQaVlHOiB7XG4zOiBbXCIjZTlhM2M5XCIsXCIjZjdmN2Y3XCIsXCIjYTFkNzZhXCJdLFxuNDogW1wiI2QwMWM4YlwiLFwiI2YxYjZkYVwiLFwiI2I4ZTE4NlwiLFwiIzRkYWMyNlwiXSxcbjU6IFtcIiNkMDFjOGJcIixcIiNmMWI2ZGFcIixcIiNmN2Y3ZjdcIixcIiNiOGUxODZcIixcIiM0ZGFjMjZcIl0sXG42OiBbXCIjYzUxYjdkXCIsXCIjZTlhM2M5XCIsXCIjZmRlMGVmXCIsXCIjZTZmNWQwXCIsXCIjYTFkNzZhXCIsXCIjNGQ5MjIxXCJdLFxuNzogW1wiI2M1MWI3ZFwiLFwiI2U5YTNjOVwiLFwiI2ZkZTBlZlwiLFwiI2Y3ZjdmN1wiLFwiI2U2ZjVkMFwiLFwiI2ExZDc2YVwiLFwiIzRkOTIyMVwiXSxcbjg6IFtcIiNjNTFiN2RcIixcIiNkZTc3YWVcIixcIiNmMWI2ZGFcIixcIiNmZGUwZWZcIixcIiNlNmY1ZDBcIixcIiNiOGUxODZcIixcIiM3ZmJjNDFcIixcIiM0ZDkyMjFcIl0sXG45OiBbXCIjYzUxYjdkXCIsXCIjZGU3N2FlXCIsXCIjZjFiNmRhXCIsXCIjZmRlMGVmXCIsXCIjZjdmN2Y3XCIsXCIjZTZmNWQwXCIsXCIjYjhlMTg2XCIsXCIjN2ZiYzQxXCIsXCIjNGQ5MjIxXCJdLFxuMTA6IFtcIiM4ZTAxNTJcIixcIiNjNTFiN2RcIixcIiNkZTc3YWVcIixcIiNmMWI2ZGFcIixcIiNmZGUwZWZcIixcIiNlNmY1ZDBcIixcIiNiOGUxODZcIixcIiM3ZmJjNDFcIixcIiM0ZDkyMjFcIixcIiMyNzY0MTlcIl0sXG4xMTogW1wiIzhlMDE1MlwiLFwiI2M1MWI3ZFwiLFwiI2RlNzdhZVwiLFwiI2YxYjZkYVwiLFwiI2ZkZTBlZlwiLFwiI2Y3ZjdmN1wiLFwiI2U2ZjVkMFwiLFwiI2I4ZTE4NlwiLFwiIzdmYmM0MVwiLFwiIzRkOTIyMVwiLFwiIzI3NjQxOVwiXVxufSxSZEJ1OiB7XG4zOiBbXCIjZWY4YTYyXCIsXCIjZjdmN2Y3XCIsXCIjNjdhOWNmXCJdLFxuNDogW1wiI2NhMDAyMFwiLFwiI2Y0YTU4MlwiLFwiIzkyYzVkZVwiLFwiIzA1NzFiMFwiXSxcbjU6IFtcIiNjYTAwMjBcIixcIiNmNGE1ODJcIixcIiNmN2Y3ZjdcIixcIiM5MmM1ZGVcIixcIiMwNTcxYjBcIl0sXG42OiBbXCIjYjIxODJiXCIsXCIjZWY4YTYyXCIsXCIjZmRkYmM3XCIsXCIjZDFlNWYwXCIsXCIjNjdhOWNmXCIsXCIjMjE2NmFjXCJdLFxuNzogW1wiI2IyMTgyYlwiLFwiI2VmOGE2MlwiLFwiI2ZkZGJjN1wiLFwiI2Y3ZjdmN1wiLFwiI2QxZTVmMFwiLFwiIzY3YTljZlwiLFwiIzIxNjZhY1wiXSxcbjg6IFtcIiNiMjE4MmJcIixcIiNkNjYwNGRcIixcIiNmNGE1ODJcIixcIiNmZGRiYzdcIixcIiNkMWU1ZjBcIixcIiM5MmM1ZGVcIixcIiM0MzkzYzNcIixcIiMyMTY2YWNcIl0sXG45OiBbXCIjYjIxODJiXCIsXCIjZDY2MDRkXCIsXCIjZjRhNTgyXCIsXCIjZmRkYmM3XCIsXCIjZjdmN2Y3XCIsXCIjZDFlNWYwXCIsXCIjOTJjNWRlXCIsXCIjNDM5M2MzXCIsXCIjMjE2NmFjXCJdLFxuMTA6IFtcIiM2NzAwMWZcIixcIiNiMjE4MmJcIixcIiNkNjYwNGRcIixcIiNmNGE1ODJcIixcIiNmZGRiYzdcIixcIiNkMWU1ZjBcIixcIiM5MmM1ZGVcIixcIiM0MzkzYzNcIixcIiMyMTY2YWNcIixcIiMwNTMwNjFcIl0sXG4xMTogW1wiIzY3MDAxZlwiLFwiI2IyMTgyYlwiLFwiI2Q2NjA0ZFwiLFwiI2Y0YTU4MlwiLFwiI2ZkZGJjN1wiLFwiI2Y3ZjdmN1wiLFwiI2QxZTVmMFwiLFwiIzkyYzVkZVwiLFwiIzQzOTNjM1wiLFwiIzIxNjZhY1wiLFwiIzA1MzA2MVwiXVxufSxSZEd5OiB7XG4zOiBbXCIjZWY4YTYyXCIsXCIjZmZmZmZmXCIsXCIjOTk5OTk5XCJdLFxuNDogW1wiI2NhMDAyMFwiLFwiI2Y0YTU4MlwiLFwiI2JhYmFiYVwiLFwiIzQwNDA0MFwiXSxcbjU6IFtcIiNjYTAwMjBcIixcIiNmNGE1ODJcIixcIiNmZmZmZmZcIixcIiNiYWJhYmFcIixcIiM0MDQwNDBcIl0sXG42OiBbXCIjYjIxODJiXCIsXCIjZWY4YTYyXCIsXCIjZmRkYmM3XCIsXCIjZTBlMGUwXCIsXCIjOTk5OTk5XCIsXCIjNGQ0ZDRkXCJdLFxuNzogW1wiI2IyMTgyYlwiLFwiI2VmOGE2MlwiLFwiI2ZkZGJjN1wiLFwiI2ZmZmZmZlwiLFwiI2UwZTBlMFwiLFwiIzk5OTk5OVwiLFwiIzRkNGQ0ZFwiXSxcbjg6IFtcIiNiMjE4MmJcIixcIiNkNjYwNGRcIixcIiNmNGE1ODJcIixcIiNmZGRiYzdcIixcIiNlMGUwZTBcIixcIiNiYWJhYmFcIixcIiM4Nzg3ODdcIixcIiM0ZDRkNGRcIl0sXG45OiBbXCIjYjIxODJiXCIsXCIjZDY2MDRkXCIsXCIjZjRhNTgyXCIsXCIjZmRkYmM3XCIsXCIjZmZmZmZmXCIsXCIjZTBlMGUwXCIsXCIjYmFiYWJhXCIsXCIjODc4Nzg3XCIsXCIjNGQ0ZDRkXCJdLFxuMTA6IFtcIiM2NzAwMWZcIixcIiNiMjE4MmJcIixcIiNkNjYwNGRcIixcIiNmNGE1ODJcIixcIiNmZGRiYzdcIixcIiNlMGUwZTBcIixcIiNiYWJhYmFcIixcIiM4Nzg3ODdcIixcIiM0ZDRkNGRcIixcIiMxYTFhMWFcIl0sXG4xMTogW1wiIzY3MDAxZlwiLFwiI2IyMTgyYlwiLFwiI2Q2NjA0ZFwiLFwiI2Y0YTU4MlwiLFwiI2ZkZGJjN1wiLFwiI2ZmZmZmZlwiLFwiI2UwZTBlMFwiLFwiI2JhYmFiYVwiLFwiIzg3ODc4N1wiLFwiIzRkNGQ0ZFwiLFwiIzFhMWExYVwiXVxufSxSZFlsQnU6IHtcbjM6IFtcIiNmYzhkNTlcIixcIiNmZmZmYmZcIixcIiM5MWJmZGJcIl0sXG40OiBbXCIjZDcxOTFjXCIsXCIjZmRhZTYxXCIsXCIjYWJkOWU5XCIsXCIjMmM3YmI2XCJdLFxuNTogW1wiI2Q3MTkxY1wiLFwiI2ZkYWU2MVwiLFwiI2ZmZmZiZlwiLFwiI2FiZDllOVwiLFwiIzJjN2JiNlwiXSxcbjY6IFtcIiNkNzMwMjdcIixcIiNmYzhkNTlcIixcIiNmZWUwOTBcIixcIiNlMGYzZjhcIixcIiM5MWJmZGJcIixcIiM0NTc1YjRcIl0sXG43OiBbXCIjZDczMDI3XCIsXCIjZmM4ZDU5XCIsXCIjZmVlMDkwXCIsXCIjZmZmZmJmXCIsXCIjZTBmM2Y4XCIsXCIjOTFiZmRiXCIsXCIjNDU3NWI0XCJdLFxuODogW1wiI2Q3MzAyN1wiLFwiI2Y0NmQ0M1wiLFwiI2ZkYWU2MVwiLFwiI2ZlZTA5MFwiLFwiI2UwZjNmOFwiLFwiI2FiZDllOVwiLFwiIzc0YWRkMVwiLFwiIzQ1NzViNFwiXSxcbjk6IFtcIiNkNzMwMjdcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOTBcIixcIiNmZmZmYmZcIixcIiNlMGYzZjhcIixcIiNhYmQ5ZTlcIixcIiM3NGFkZDFcIixcIiM0NTc1YjRcIl0sXG4xMDogW1wiI2E1MDAyNlwiLFwiI2Q3MzAyN1wiLFwiI2Y0NmQ0M1wiLFwiI2ZkYWU2MVwiLFwiI2ZlZTA5MFwiLFwiI2UwZjNmOFwiLFwiI2FiZDllOVwiLFwiIzc0YWRkMVwiLFwiIzQ1NzViNFwiLFwiIzMxMzY5NVwiXSxcbjExOiBbXCIjYTUwMDI2XCIsXCIjZDczMDI3XCIsXCIjZjQ2ZDQzXCIsXCIjZmRhZTYxXCIsXCIjZmVlMDkwXCIsXCIjZmZmZmJmXCIsXCIjZTBmM2Y4XCIsXCIjYWJkOWU5XCIsXCIjNzRhZGQxXCIsXCIjNDU3NWI0XCIsXCIjMzEzNjk1XCJdXG59LFNwZWN0cmFsOiB7XG4zOiBbXCIjZmM4ZDU5XCIsXCIjZmZmZmJmXCIsXCIjOTlkNTk0XCJdLFxuNDogW1wiI2Q3MTkxY1wiLFwiI2ZkYWU2MVwiLFwiI2FiZGRhNFwiLFwiIzJiODNiYVwiXSxcbjU6IFtcIiNkNzE5MWNcIixcIiNmZGFlNjFcIixcIiNmZmZmYmZcIixcIiNhYmRkYTRcIixcIiMyYjgzYmFcIl0sXG42OiBbXCIjZDUzZTRmXCIsXCIjZmM4ZDU5XCIsXCIjZmVlMDhiXCIsXCIjZTZmNTk4XCIsXCIjOTlkNTk0XCIsXCIjMzI4OGJkXCJdLFxuNzogW1wiI2Q1M2U0ZlwiLFwiI2ZjOGQ1OVwiLFwiI2ZlZTA4YlwiLFwiI2ZmZmZiZlwiLFwiI2U2ZjU5OFwiLFwiIzk5ZDU5NFwiLFwiIzMyODhiZFwiXSxcbjg6IFtcIiNkNTNlNGZcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOGJcIixcIiNlNmY1OThcIixcIiNhYmRkYTRcIixcIiM2NmMyYTVcIixcIiMzMjg4YmRcIl0sXG45OiBbXCIjZDUzZTRmXCIsXCIjZjQ2ZDQzXCIsXCIjZmRhZTYxXCIsXCIjZmVlMDhiXCIsXCIjZmZmZmJmXCIsXCIjZTZmNTk4XCIsXCIjYWJkZGE0XCIsXCIjNjZjMmE1XCIsXCIjMzI4OGJkXCJdLFxuMTA6IFtcIiM5ZTAxNDJcIixcIiNkNTNlNGZcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOGJcIixcIiNlNmY1OThcIixcIiNhYmRkYTRcIixcIiM2NmMyYTVcIixcIiMzMjg4YmRcIixcIiM1ZTRmYTJcIl0sXG4xMTogW1wiIzllMDE0MlwiLFwiI2Q1M2U0ZlwiLFwiI2Y0NmQ0M1wiLFwiI2ZkYWU2MVwiLFwiI2ZlZTA4YlwiLFwiI2ZmZmZiZlwiLFwiI2U2ZjU5OFwiLFwiI2FiZGRhNFwiLFwiIzY2YzJhNVwiLFwiIzMyODhiZFwiLFwiIzVlNGZhMlwiXVxufSxSZFlsR246IHtcbjM6IFtcIiNmYzhkNTlcIixcIiNmZmZmYmZcIixcIiM5MWNmNjBcIl0sXG40OiBbXCIjZDcxOTFjXCIsXCIjZmRhZTYxXCIsXCIjYTZkOTZhXCIsXCIjMWE5NjQxXCJdLFxuNTogW1wiI2Q3MTkxY1wiLFwiI2ZkYWU2MVwiLFwiI2ZmZmZiZlwiLFwiI2E2ZDk2YVwiLFwiIzFhOTY0MVwiXSxcbjY6IFtcIiNkNzMwMjdcIixcIiNmYzhkNTlcIixcIiNmZWUwOGJcIixcIiNkOWVmOGJcIixcIiM5MWNmNjBcIixcIiMxYTk4NTBcIl0sXG43OiBbXCIjZDczMDI3XCIsXCIjZmM4ZDU5XCIsXCIjZmVlMDhiXCIsXCIjZmZmZmJmXCIsXCIjZDllZjhiXCIsXCIjOTFjZjYwXCIsXCIjMWE5ODUwXCJdLFxuODogW1wiI2Q3MzAyN1wiLFwiI2Y0NmQ0M1wiLFwiI2ZkYWU2MVwiLFwiI2ZlZTA4YlwiLFwiI2Q5ZWY4YlwiLFwiI2E2ZDk2YVwiLFwiIzY2YmQ2M1wiLFwiIzFhOTg1MFwiXSxcbjk6IFtcIiNkNzMwMjdcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOGJcIixcIiNmZmZmYmZcIixcIiNkOWVmOGJcIixcIiNhNmQ5NmFcIixcIiM2NmJkNjNcIixcIiMxYTk4NTBcIl0sXG4xMDogW1wiI2E1MDAyNlwiLFwiI2Q3MzAyN1wiLFwiI2Y0NmQ0M1wiLFwiI2ZkYWU2MVwiLFwiI2ZlZTA4YlwiLFwiI2Q5ZWY4YlwiLFwiI2E2ZDk2YVwiLFwiIzY2YmQ2M1wiLFwiIzFhOTg1MFwiLFwiIzAwNjgzN1wiXSxcbjExOiBbXCIjYTUwMDI2XCIsXCIjZDczMDI3XCIsXCIjZjQ2ZDQzXCIsXCIjZmRhZTYxXCIsXCIjZmVlMDhiXCIsXCIjZmZmZmJmXCIsXCIjZDllZjhiXCIsXCIjYTZkOTZhXCIsXCIjNjZiZDYzXCIsXCIjMWE5ODUwXCIsXCIjMDA2ODM3XCJdXG59LEFjY2VudDoge1xuMzogW1wiIzdmYzk3ZlwiLFwiI2JlYWVkNFwiLFwiI2ZkYzA4NlwiXSxcbjQ6IFtcIiM3ZmM5N2ZcIixcIiNiZWFlZDRcIixcIiNmZGMwODZcIixcIiNmZmZmOTlcIl0sXG41OiBbXCIjN2ZjOTdmXCIsXCIjYmVhZWQ0XCIsXCIjZmRjMDg2XCIsXCIjZmZmZjk5XCIsXCIjMzg2Y2IwXCJdLFxuNjogW1wiIzdmYzk3ZlwiLFwiI2JlYWVkNFwiLFwiI2ZkYzA4NlwiLFwiI2ZmZmY5OVwiLFwiIzM4NmNiMFwiLFwiI2YwMDI3ZlwiXSxcbjc6IFtcIiM3ZmM5N2ZcIixcIiNiZWFlZDRcIixcIiNmZGMwODZcIixcIiNmZmZmOTlcIixcIiMzODZjYjBcIixcIiNmMDAyN2ZcIixcIiNiZjViMTdcIl0sXG44OiBbXCIjN2ZjOTdmXCIsXCIjYmVhZWQ0XCIsXCIjZmRjMDg2XCIsXCIjZmZmZjk5XCIsXCIjMzg2Y2IwXCIsXCIjZjAwMjdmXCIsXCIjYmY1YjE3XCIsXCIjNjY2NjY2XCJdXG59LERhcmsyOiB7XG4zOiBbXCIjMWI5ZTc3XCIsXCIjZDk1ZjAyXCIsXCIjNzU3MGIzXCJdLFxuNDogW1wiIzFiOWU3N1wiLFwiI2Q5NWYwMlwiLFwiIzc1NzBiM1wiLFwiI2U3Mjk4YVwiXSxcbjU6IFtcIiMxYjllNzdcIixcIiNkOTVmMDJcIixcIiM3NTcwYjNcIixcIiNlNzI5OGFcIixcIiM2NmE2MWVcIl0sXG42OiBbXCIjMWI5ZTc3XCIsXCIjZDk1ZjAyXCIsXCIjNzU3MGIzXCIsXCIjZTcyOThhXCIsXCIjNjZhNjFlXCIsXCIjZTZhYjAyXCJdLFxuNzogW1wiIzFiOWU3N1wiLFwiI2Q5NWYwMlwiLFwiIzc1NzBiM1wiLFwiI2U3Mjk4YVwiLFwiIzY2YTYxZVwiLFwiI2U2YWIwMlwiLFwiI2E2NzYxZFwiXSxcbjg6IFtcIiMxYjllNzdcIixcIiNkOTVmMDJcIixcIiM3NTcwYjNcIixcIiNlNzI5OGFcIixcIiM2NmE2MWVcIixcIiNlNmFiMDJcIixcIiNhNjc2MWRcIixcIiM2NjY2NjZcIl1cbn0sUGFpcmVkOiB7XG4zOiBbXCIjYTZjZWUzXCIsXCIjMWY3OGI0XCIsXCIjYjJkZjhhXCJdLFxuNDogW1wiI2E2Y2VlM1wiLFwiIzFmNzhiNFwiLFwiI2IyZGY4YVwiLFwiIzMzYTAyY1wiXSxcbjU6IFtcIiNhNmNlZTNcIixcIiMxZjc4YjRcIixcIiNiMmRmOGFcIixcIiMzM2EwMmNcIixcIiNmYjlhOTlcIl0sXG42OiBbXCIjYTZjZWUzXCIsXCIjMWY3OGI0XCIsXCIjYjJkZjhhXCIsXCIjMzNhMDJjXCIsXCIjZmI5YTk5XCIsXCIjZTMxYTFjXCJdLFxuNzogW1wiI2E2Y2VlM1wiLFwiIzFmNzhiNFwiLFwiI2IyZGY4YVwiLFwiIzMzYTAyY1wiLFwiI2ZiOWE5OVwiLFwiI2UzMWExY1wiLFwiI2ZkYmY2ZlwiXSxcbjg6IFtcIiNhNmNlZTNcIixcIiMxZjc4YjRcIixcIiNiMmRmOGFcIixcIiMzM2EwMmNcIixcIiNmYjlhOTlcIixcIiNlMzFhMWNcIixcIiNmZGJmNmZcIixcIiNmZjdmMDBcIl0sXG45OiBbXCIjYTZjZWUzXCIsXCIjMWY3OGI0XCIsXCIjYjJkZjhhXCIsXCIjMzNhMDJjXCIsXCIjZmI5YTk5XCIsXCIjZTMxYTFjXCIsXCIjZmRiZjZmXCIsXCIjZmY3ZjAwXCIsXCIjY2FiMmQ2XCJdLFxuMTA6IFtcIiNhNmNlZTNcIixcIiMxZjc4YjRcIixcIiNiMmRmOGFcIixcIiMzM2EwMmNcIixcIiNmYjlhOTlcIixcIiNlMzFhMWNcIixcIiNmZGJmNmZcIixcIiNmZjdmMDBcIixcIiNjYWIyZDZcIixcIiM2YTNkOWFcIl0sXG4xMTogW1wiI2E2Y2VlM1wiLFwiIzFmNzhiNFwiLFwiI2IyZGY4YVwiLFwiIzMzYTAyY1wiLFwiI2ZiOWE5OVwiLFwiI2UzMWExY1wiLFwiI2ZkYmY2ZlwiLFwiI2ZmN2YwMFwiLFwiI2NhYjJkNlwiLFwiIzZhM2Q5YVwiLFwiI2ZmZmY5OVwiXSxcbjEyOiBbXCIjYTZjZWUzXCIsXCIjMWY3OGI0XCIsXCIjYjJkZjhhXCIsXCIjMzNhMDJjXCIsXCIjZmI5YTk5XCIsXCIjZTMxYTFjXCIsXCIjZmRiZjZmXCIsXCIjZmY3ZjAwXCIsXCIjY2FiMmQ2XCIsXCIjNmEzZDlhXCIsXCIjZmZmZjk5XCIsXCIjYjE1OTI4XCJdXG59LFBhc3RlbDE6IHtcbjM6IFtcIiNmYmI0YWVcIixcIiNiM2NkZTNcIixcIiNjY2ViYzVcIl0sXG40OiBbXCIjZmJiNGFlXCIsXCIjYjNjZGUzXCIsXCIjY2NlYmM1XCIsXCIjZGVjYmU0XCJdLFxuNTogW1wiI2ZiYjRhZVwiLFwiI2IzY2RlM1wiLFwiI2NjZWJjNVwiLFwiI2RlY2JlNFwiLFwiI2ZlZDlhNlwiXSxcbjY6IFtcIiNmYmI0YWVcIixcIiNiM2NkZTNcIixcIiNjY2ViYzVcIixcIiNkZWNiZTRcIixcIiNmZWQ5YTZcIixcIiNmZmZmY2NcIl0sXG43OiBbXCIjZmJiNGFlXCIsXCIjYjNjZGUzXCIsXCIjY2NlYmM1XCIsXCIjZGVjYmU0XCIsXCIjZmVkOWE2XCIsXCIjZmZmZmNjXCIsXCIjZTVkOGJkXCJdLFxuODogW1wiI2ZiYjRhZVwiLFwiI2IzY2RlM1wiLFwiI2NjZWJjNVwiLFwiI2RlY2JlNFwiLFwiI2ZlZDlhNlwiLFwiI2ZmZmZjY1wiLFwiI2U1ZDhiZFwiLFwiI2ZkZGFlY1wiXSxcbjk6IFtcIiNmYmI0YWVcIixcIiNiM2NkZTNcIixcIiNjY2ViYzVcIixcIiNkZWNiZTRcIixcIiNmZWQ5YTZcIixcIiNmZmZmY2NcIixcIiNlNWQ4YmRcIixcIiNmZGRhZWNcIixcIiNmMmYyZjJcIl1cbn0sUGFzdGVsMjoge1xuMzogW1wiI2IzZTJjZFwiLFwiI2ZkY2RhY1wiLFwiI2NiZDVlOFwiXSxcbjQ6IFtcIiNiM2UyY2RcIixcIiNmZGNkYWNcIixcIiNjYmQ1ZThcIixcIiNmNGNhZTRcIl0sXG41OiBbXCIjYjNlMmNkXCIsXCIjZmRjZGFjXCIsXCIjY2JkNWU4XCIsXCIjZjRjYWU0XCIsXCIjZTZmNWM5XCJdLFxuNjogW1wiI2IzZTJjZFwiLFwiI2ZkY2RhY1wiLFwiI2NiZDVlOFwiLFwiI2Y0Y2FlNFwiLFwiI2U2ZjVjOVwiLFwiI2ZmZjJhZVwiXSxcbjc6IFtcIiNiM2UyY2RcIixcIiNmZGNkYWNcIixcIiNjYmQ1ZThcIixcIiNmNGNhZTRcIixcIiNlNmY1YzlcIixcIiNmZmYyYWVcIixcIiNmMWUyY2NcIl0sXG44OiBbXCIjYjNlMmNkXCIsXCIjZmRjZGFjXCIsXCIjY2JkNWU4XCIsXCIjZjRjYWU0XCIsXCIjZTZmNWM5XCIsXCIjZmZmMmFlXCIsXCIjZjFlMmNjXCIsXCIjY2NjY2NjXCJdXG59LFNldDE6IHtcbjM6IFtcIiNlNDFhMWNcIixcIiMzNzdlYjhcIixcIiM0ZGFmNGFcIl0sXG40OiBbXCIjZTQxYTFjXCIsXCIjMzc3ZWI4XCIsXCIjNGRhZjRhXCIsXCIjOTg0ZWEzXCJdLFxuNTogW1wiI2U0MWExY1wiLFwiIzM3N2ViOFwiLFwiIzRkYWY0YVwiLFwiIzk4NGVhM1wiLFwiI2ZmN2YwMFwiXSxcbjY6IFtcIiNlNDFhMWNcIixcIiMzNzdlYjhcIixcIiM0ZGFmNGFcIixcIiM5ODRlYTNcIixcIiNmZjdmMDBcIixcIiNmZmZmMzNcIl0sXG43OiBbXCIjZTQxYTFjXCIsXCIjMzc3ZWI4XCIsXCIjNGRhZjRhXCIsXCIjOTg0ZWEzXCIsXCIjZmY3ZjAwXCIsXCIjZmZmZjMzXCIsXCIjYTY1NjI4XCJdLFxuODogW1wiI2U0MWExY1wiLFwiIzM3N2ViOFwiLFwiIzRkYWY0YVwiLFwiIzk4NGVhM1wiLFwiI2ZmN2YwMFwiLFwiI2ZmZmYzM1wiLFwiI2E2NTYyOFwiLFwiI2Y3ODFiZlwiXSxcbjk6IFtcIiNlNDFhMWNcIixcIiMzNzdlYjhcIixcIiM0ZGFmNGFcIixcIiM5ODRlYTNcIixcIiNmZjdmMDBcIixcIiNmZmZmMzNcIixcIiNhNjU2MjhcIixcIiNmNzgxYmZcIixcIiM5OTk5OTlcIl1cbn0sU2V0Mjoge1xuMzogW1wiIzY2YzJhNVwiLFwiI2ZjOGQ2MlwiLFwiIzhkYTBjYlwiXSxcbjQ6IFtcIiM2NmMyYTVcIixcIiNmYzhkNjJcIixcIiM4ZGEwY2JcIixcIiNlNzhhYzNcIl0sXG41OiBbXCIjNjZjMmE1XCIsXCIjZmM4ZDYyXCIsXCIjOGRhMGNiXCIsXCIjZTc4YWMzXCIsXCIjYTZkODU0XCJdLFxuNjogW1wiIzY2YzJhNVwiLFwiI2ZjOGQ2MlwiLFwiIzhkYTBjYlwiLFwiI2U3OGFjM1wiLFwiI2E2ZDg1NFwiLFwiI2ZmZDkyZlwiXSxcbjc6IFtcIiM2NmMyYTVcIixcIiNmYzhkNjJcIixcIiM4ZGEwY2JcIixcIiNlNzhhYzNcIixcIiNhNmQ4NTRcIixcIiNmZmQ5MmZcIixcIiNlNWM0OTRcIl0sXG44OiBbXCIjNjZjMmE1XCIsXCIjZmM4ZDYyXCIsXCIjOGRhMGNiXCIsXCIjZTc4YWMzXCIsXCIjYTZkODU0XCIsXCIjZmZkOTJmXCIsXCIjZTVjNDk0XCIsXCIjYjNiM2IzXCJdXG59LFNldDM6IHtcbjM6IFtcIiM4ZGQzYzdcIixcIiNmZmZmYjNcIixcIiNiZWJhZGFcIl0sXG40OiBbXCIjOGRkM2M3XCIsXCIjZmZmZmIzXCIsXCIjYmViYWRhXCIsXCIjZmI4MDcyXCJdLFxuNTogW1wiIzhkZDNjN1wiLFwiI2ZmZmZiM1wiLFwiI2JlYmFkYVwiLFwiI2ZiODA3MlwiLFwiIzgwYjFkM1wiXSxcbjY6IFtcIiM4ZGQzYzdcIixcIiNmZmZmYjNcIixcIiNiZWJhZGFcIixcIiNmYjgwNzJcIixcIiM4MGIxZDNcIixcIiNmZGI0NjJcIl0sXG43OiBbXCIjOGRkM2M3XCIsXCIjZmZmZmIzXCIsXCIjYmViYWRhXCIsXCIjZmI4MDcyXCIsXCIjODBiMWQzXCIsXCIjZmRiNDYyXCIsXCIjYjNkZTY5XCJdLFxuODogW1wiIzhkZDNjN1wiLFwiI2ZmZmZiM1wiLFwiI2JlYmFkYVwiLFwiI2ZiODA3MlwiLFwiIzgwYjFkM1wiLFwiI2ZkYjQ2MlwiLFwiI2IzZGU2OVwiLFwiI2ZjY2RlNVwiXSxcbjk6IFtcIiM4ZGQzYzdcIixcIiNmZmZmYjNcIixcIiNiZWJhZGFcIixcIiNmYjgwNzJcIixcIiM4MGIxZDNcIixcIiNmZGI0NjJcIixcIiNiM2RlNjlcIixcIiNmY2NkZTVcIixcIiNkOWQ5ZDlcIl0sXG4xMDogW1wiIzhkZDNjN1wiLFwiI2ZmZmZiM1wiLFwiI2JlYmFkYVwiLFwiI2ZiODA3MlwiLFwiIzgwYjFkM1wiLFwiI2ZkYjQ2MlwiLFwiI2IzZGU2OVwiLFwiI2ZjY2RlNVwiLFwiI2Q5ZDlkOVwiLFwiI2JjODBiZFwiXSxcbjExOiBbXCIjOGRkM2M3XCIsXCIjZmZmZmIzXCIsXCIjYmViYWRhXCIsXCIjZmI4MDcyXCIsXCIjODBiMWQzXCIsXCIjZmRiNDYyXCIsXCIjYjNkZTY5XCIsXCIjZmNjZGU1XCIsXCIjZDlkOWQ5XCIsXCIjYmM4MGJkXCIsXCIjY2NlYmM1XCJdLFxuMTI6IFtcIiM4ZGQzYzdcIixcIiNmZmZmYjNcIixcIiNiZWJhZGFcIixcIiNmYjgwNzJcIixcIiM4MGIxZDNcIixcIiNmZGI0NjJcIixcIiNiM2RlNjlcIixcIiNmY2NkZTVcIixcIiNkOWQ5ZDlcIixcIiNiYzgwYmRcIixcIiNjY2ViYzVcIixcIiNmZmVkNmZcIl1cbn19O1xuXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoY29sb3JicmV3ZXIpO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjb2xvcmJyZXdlcjtcbn0gZWxzZSB7XG4gICAgdGhpcy5jb2xvcmJyZXdlciA9IGNvbG9yYnJld2VyO1xufVxuXG59KCk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29sb3JicmV3ZXIuanMnKTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgZmFjdG9yeSgoZ2xvYmFsLmNvbG9yID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIGRlbHRhSHVlKGgxLCBoMCkge1xuICAgIHZhciBkZWx0YSA9IGgxIC0gaDA7XG4gICAgcmV0dXJuIGRlbHRhID4gMTgwIHx8IGRlbHRhIDwgLTE4MFxuICAgICAgICA/IGRlbHRhIC0gMzYwICogTWF0aC5yb3VuZChkZWx0YSAvIDM2MClcbiAgICAgICAgOiBkZWx0YTtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbG9yKCkge312YXIgcmVIZXgzID0gL14jKFswLTlhLWZdezN9KSQvO1xuICB2YXIgcmVIZXg2ID0gL14jKFswLTlhLWZdezZ9KSQvO1xuICB2YXIgcmVSZ2JJbnRlZ2VyID0gL15yZ2JcXChcXHMqKFstK10/XFxkKylcXHMqLFxccyooWy0rXT9cXGQrKVxccyosXFxzKihbLStdP1xcZCspXFxzKlxcKSQvO1xuICB2YXIgcmVSZ2JQZXJjZW50ID0gL15yZ2JcXChcXHMqKFstK10/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKFstK10/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKFstK10/XFxkKyg/OlxcLlxcZCspPyklXFxzKlxcKSQvO1xuICB2YXIgcmVIc2xQZXJjZW50ID0gL15oc2xcXChcXHMqKFstK10/XFxkKyg/OlxcLlxcZCspPylcXHMqLFxccyooWy0rXT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqLFxccyooWy0rXT9cXGQrKD86XFwuXFxkKyk/KSVcXHMqXFwpJC87XG4gIGNvbG9yLnByb3RvdHlwZSA9IENvbG9yLnByb3RvdHlwZSA9IHtcbiAgICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZ2IoKS5kaXNwbGF5YWJsZSgpO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmdiKCkgKyBcIlwiO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjb2xvcihmb3JtYXQpIHtcbiAgICB2YXIgbTtcbiAgICBmb3JtYXQgPSAoZm9ybWF0ICsgXCJcIikudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIChtID0gcmVIZXgzLmV4ZWMoZm9ybWF0KSkgPyAobSA9IHBhcnNlSW50KG1bMV0sIDE2KSwgcmdiKChtID4+IDggJiAweGYpIHwgKG0gPj4gNCAmIDB4MGYwKSwgKG0gPj4gNCAmIDB4ZikgfCAobSAmIDB4ZjApLCAoKG0gJiAweGYpIDw8IDQpIHwgKG0gJiAweGYpKSkgLy8gI2YwMFxuICAgICAgICA6IChtID0gcmVIZXg2LmV4ZWMoZm9ybWF0KSkgPyByZ2JuKHBhcnNlSW50KG1bMV0sIDE2KSkgLy8gI2ZmMDAwMFxuICAgICAgICA6IChtID0gcmVSZ2JJbnRlZ2VyLmV4ZWMoZm9ybWF0KSkgPyByZ2IobVsxXSwgbVsyXSwgbVszXSkgLy8gcmdiKDI1NSwwLDApXG4gICAgICAgIDogKG0gPSByZVJnYlBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IHJnYihtWzFdICogMi41NSwgbVsyXSAqIDIuNTUsIG1bM10gKiAyLjU1KSAvLyByZ2IoMTAwJSwwJSwwJSlcbiAgICAgICAgOiAobSA9IHJlSHNsUGVyY2VudC5leGVjKGZvcm1hdCkpID8gaHNsKG1bMV0sIG1bMl0gKiAuMDEsIG1bM10gKiAuMDEpIC8vIGhzbCgxMjAsNTAlLDUwJSlcbiAgICAgICAgOiBuYW1lZC5oYXNPd25Qcm9wZXJ0eShmb3JtYXQpID8gcmdibihuYW1lZFtmb3JtYXRdKVxuICAgICAgICA6IG51bGw7XG4gIH1mdW5jdGlvbiByZ2JuKG4pIHtcbiAgICByZXR1cm4gcmdiKG4gPj4gMTYgJiAweGZmLCBuID4+IDggJiAweGZmLCBuICYgMHhmZik7XG4gIH1cblxuICB2YXIgbmFtZWQgPSB7XG4gICAgYWxpY2VibHVlOiAweGYwZjhmZixcbiAgICBhbnRpcXVld2hpdGU6IDB4ZmFlYmQ3LFxuICAgIGFxdWE6IDB4MDBmZmZmLFxuICAgIGFxdWFtYXJpbmU6IDB4N2ZmZmQ0LFxuICAgIGF6dXJlOiAweGYwZmZmZixcbiAgICBiZWlnZTogMHhmNWY1ZGMsXG4gICAgYmlzcXVlOiAweGZmZTRjNCxcbiAgICBibGFjazogMHgwMDAwMDAsXG4gICAgYmxhbmNoZWRhbG1vbmQ6IDB4ZmZlYmNkLFxuICAgIGJsdWU6IDB4MDAwMGZmLFxuICAgIGJsdWV2aW9sZXQ6IDB4OGEyYmUyLFxuICAgIGJyb3duOiAweGE1MmEyYSxcbiAgICBidXJseXdvb2Q6IDB4ZGViODg3LFxuICAgIGNhZGV0Ymx1ZTogMHg1ZjllYTAsXG4gICAgY2hhcnRyZXVzZTogMHg3ZmZmMDAsXG4gICAgY2hvY29sYXRlOiAweGQyNjkxZSxcbiAgICBjb3JhbDogMHhmZjdmNTAsXG4gICAgY29ybmZsb3dlcmJsdWU6IDB4NjQ5NWVkLFxuICAgIGNvcm5zaWxrOiAweGZmZjhkYyxcbiAgICBjcmltc29uOiAweGRjMTQzYyxcbiAgICBjeWFuOiAweDAwZmZmZixcbiAgICBkYXJrYmx1ZTogMHgwMDAwOGIsXG4gICAgZGFya2N5YW46IDB4MDA4YjhiLFxuICAgIGRhcmtnb2xkZW5yb2Q6IDB4Yjg4NjBiLFxuICAgIGRhcmtncmF5OiAweGE5YTlhOSxcbiAgICBkYXJrZ3JlZW46IDB4MDA2NDAwLFxuICAgIGRhcmtncmV5OiAweGE5YTlhOSxcbiAgICBkYXJra2hha2k6IDB4YmRiNzZiLFxuICAgIGRhcmttYWdlbnRhOiAweDhiMDA4YixcbiAgICBkYXJrb2xpdmVncmVlbjogMHg1NTZiMmYsXG4gICAgZGFya29yYW5nZTogMHhmZjhjMDAsXG4gICAgZGFya29yY2hpZDogMHg5OTMyY2MsXG4gICAgZGFya3JlZDogMHg4YjAwMDAsXG4gICAgZGFya3NhbG1vbjogMHhlOTk2N2EsXG4gICAgZGFya3NlYWdyZWVuOiAweDhmYmM4ZixcbiAgICBkYXJrc2xhdGVibHVlOiAweDQ4M2Q4YixcbiAgICBkYXJrc2xhdGVncmF5OiAweDJmNGY0ZixcbiAgICBkYXJrc2xhdGVncmV5OiAweDJmNGY0ZixcbiAgICBkYXJrdHVycXVvaXNlOiAweDAwY2VkMSxcbiAgICBkYXJrdmlvbGV0OiAweDk0MDBkMyxcbiAgICBkZWVwcGluazogMHhmZjE0OTMsXG4gICAgZGVlcHNreWJsdWU6IDB4MDBiZmZmLFxuICAgIGRpbWdyYXk6IDB4Njk2OTY5LFxuICAgIGRpbWdyZXk6IDB4Njk2OTY5LFxuICAgIGRvZGdlcmJsdWU6IDB4MWU5MGZmLFxuICAgIGZpcmVicmljazogMHhiMjIyMjIsXG4gICAgZmxvcmFsd2hpdGU6IDB4ZmZmYWYwLFxuICAgIGZvcmVzdGdyZWVuOiAweDIyOGIyMixcbiAgICBmdWNoc2lhOiAweGZmMDBmZixcbiAgICBnYWluc2Jvcm86IDB4ZGNkY2RjLFxuICAgIGdob3N0d2hpdGU6IDB4ZjhmOGZmLFxuICAgIGdvbGQ6IDB4ZmZkNzAwLFxuICAgIGdvbGRlbnJvZDogMHhkYWE1MjAsXG4gICAgZ3JheTogMHg4MDgwODAsXG4gICAgZ3JlZW46IDB4MDA4MDAwLFxuICAgIGdyZWVueWVsbG93OiAweGFkZmYyZixcbiAgICBncmV5OiAweDgwODA4MCxcbiAgICBob25leWRldzogMHhmMGZmZjAsXG4gICAgaG90cGluazogMHhmZjY5YjQsXG4gICAgaW5kaWFucmVkOiAweGNkNWM1YyxcbiAgICBpbmRpZ286IDB4NGIwMDgyLFxuICAgIGl2b3J5OiAweGZmZmZmMCxcbiAgICBraGFraTogMHhmMGU2OGMsXG4gICAgbGF2ZW5kZXI6IDB4ZTZlNmZhLFxuICAgIGxhdmVuZGVyYmx1c2g6IDB4ZmZmMGY1LFxuICAgIGxhd25ncmVlbjogMHg3Y2ZjMDAsXG4gICAgbGVtb25jaGlmZm9uOiAweGZmZmFjZCxcbiAgICBsaWdodGJsdWU6IDB4YWRkOGU2LFxuICAgIGxpZ2h0Y29yYWw6IDB4ZjA4MDgwLFxuICAgIGxpZ2h0Y3lhbjogMHhlMGZmZmYsXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDB4ZmFmYWQyLFxuICAgIGxpZ2h0Z3JheTogMHhkM2QzZDMsXG4gICAgbGlnaHRncmVlbjogMHg5MGVlOTAsXG4gICAgbGlnaHRncmV5OiAweGQzZDNkMyxcbiAgICBsaWdodHBpbms6IDB4ZmZiNmMxLFxuICAgIGxpZ2h0c2FsbW9uOiAweGZmYTA3YSxcbiAgICBsaWdodHNlYWdyZWVuOiAweDIwYjJhYSxcbiAgICBsaWdodHNreWJsdWU6IDB4ODdjZWZhLFxuICAgIGxpZ2h0c2xhdGVncmF5OiAweDc3ODg5OSxcbiAgICBsaWdodHNsYXRlZ3JleTogMHg3Nzg4OTksXG4gICAgbGlnaHRzdGVlbGJsdWU6IDB4YjBjNGRlLFxuICAgIGxpZ2h0eWVsbG93OiAweGZmZmZlMCxcbiAgICBsaW1lOiAweDAwZmYwMCxcbiAgICBsaW1lZ3JlZW46IDB4MzJjZDMyLFxuICAgIGxpbmVuOiAweGZhZjBlNixcbiAgICBtYWdlbnRhOiAweGZmMDBmZixcbiAgICBtYXJvb246IDB4ODAwMDAwLFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6IDB4NjZjZGFhLFxuICAgIG1lZGl1bWJsdWU6IDB4MDAwMGNkLFxuICAgIG1lZGl1bW9yY2hpZDogMHhiYTU1ZDMsXG4gICAgbWVkaXVtcHVycGxlOiAweDkzNzBkYixcbiAgICBtZWRpdW1zZWFncmVlbjogMHgzY2IzNzEsXG4gICAgbWVkaXVtc2xhdGVibHVlOiAweDdiNjhlZSxcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogMHgwMGZhOWEsXG4gICAgbWVkaXVtdHVycXVvaXNlOiAweDQ4ZDFjYyxcbiAgICBtZWRpdW12aW9sZXRyZWQ6IDB4YzcxNTg1LFxuICAgIG1pZG5pZ2h0Ymx1ZTogMHgxOTE5NzAsXG4gICAgbWludGNyZWFtOiAweGY1ZmZmYSxcbiAgICBtaXN0eXJvc2U6IDB4ZmZlNGUxLFxuICAgIG1vY2Nhc2luOiAweGZmZTRiNSxcbiAgICBuYXZham93aGl0ZTogMHhmZmRlYWQsXG4gICAgbmF2eTogMHgwMDAwODAsXG4gICAgb2xkbGFjZTogMHhmZGY1ZTYsXG4gICAgb2xpdmU6IDB4ODA4MDAwLFxuICAgIG9saXZlZHJhYjogMHg2YjhlMjMsXG4gICAgb3JhbmdlOiAweGZmYTUwMCxcbiAgICBvcmFuZ2VyZWQ6IDB4ZmY0NTAwLFxuICAgIG9yY2hpZDogMHhkYTcwZDYsXG4gICAgcGFsZWdvbGRlbnJvZDogMHhlZWU4YWEsXG4gICAgcGFsZWdyZWVuOiAweDk4ZmI5OCxcbiAgICBwYWxldHVycXVvaXNlOiAweGFmZWVlZSxcbiAgICBwYWxldmlvbGV0cmVkOiAweGRiNzA5MyxcbiAgICBwYXBheWF3aGlwOiAweGZmZWZkNSxcbiAgICBwZWFjaHB1ZmY6IDB4ZmZkYWI5LFxuICAgIHBlcnU6IDB4Y2Q4NTNmLFxuICAgIHBpbms6IDB4ZmZjMGNiLFxuICAgIHBsdW06IDB4ZGRhMGRkLFxuICAgIHBvd2RlcmJsdWU6IDB4YjBlMGU2LFxuICAgIHB1cnBsZTogMHg4MDAwODAsXG4gICAgcmViZWNjYXB1cnBsZTogMHg2NjMzOTksXG4gICAgcmVkOiAweGZmMDAwMCxcbiAgICByb3N5YnJvd246IDB4YmM4ZjhmLFxuICAgIHJveWFsYmx1ZTogMHg0MTY5ZTEsXG4gICAgc2FkZGxlYnJvd246IDB4OGI0NTEzLFxuICAgIHNhbG1vbjogMHhmYTgwNzIsXG4gICAgc2FuZHlicm93bjogMHhmNGE0NjAsXG4gICAgc2VhZ3JlZW46IDB4MmU4YjU3LFxuICAgIHNlYXNoZWxsOiAweGZmZjVlZSxcbiAgICBzaWVubmE6IDB4YTA1MjJkLFxuICAgIHNpbHZlcjogMHhjMGMwYzAsXG4gICAgc2t5Ymx1ZTogMHg4N2NlZWIsXG4gICAgc2xhdGVibHVlOiAweDZhNWFjZCxcbiAgICBzbGF0ZWdyYXk6IDB4NzA4MDkwLFxuICAgIHNsYXRlZ3JleTogMHg3MDgwOTAsXG4gICAgc25vdzogMHhmZmZhZmEsXG4gICAgc3ByaW5nZ3JlZW46IDB4MDBmZjdmLFxuICAgIHN0ZWVsYmx1ZTogMHg0NjgyYjQsXG4gICAgdGFuOiAweGQyYjQ4YyxcbiAgICB0ZWFsOiAweDAwODA4MCxcbiAgICB0aGlzdGxlOiAweGQ4YmZkOCxcbiAgICB0b21hdG86IDB4ZmY2MzQ3LFxuICAgIHR1cnF1b2lzZTogMHg0MGUwZDAsXG4gICAgdmlvbGV0OiAweGVlODJlZSxcbiAgICB3aGVhdDogMHhmNWRlYjMsXG4gICAgd2hpdGU6IDB4ZmZmZmZmLFxuICAgIHdoaXRlc21va2U6IDB4ZjVmNWY1LFxuICAgIHllbGxvdzogMHhmZmZmMDAsXG4gICAgeWVsbG93Z3JlZW46IDB4OWFjZDMyXG4gIH07XG5cbiAgdmFyIGRhcmtlciA9IC43O1xuICB2YXIgYnJpZ2h0ZXIgPSAxIC8gZGFya2VyO1xuXG4gIGZ1bmN0aW9uIHJnYihyLCBnLCBiKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmICghKHIgaW5zdGFuY2VvZiBDb2xvcikpIHIgPSBjb2xvcihyKTtcbiAgICAgIGlmIChyKSB7XG4gICAgICAgIHIgPSByLnJnYigpO1xuICAgICAgICBiID0gci5iO1xuICAgICAgICBnID0gci5nO1xuICAgICAgICByID0gci5yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciA9IGcgPSBiID0gTmFOO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFJnYihyLCBnLCBiKTtcbiAgfWZ1bmN0aW9uIFJnYihyLCBnLCBiKSB7XG4gICAgdGhpcy5yID0gK3I7XG4gICAgdGhpcy5nID0gK2c7XG4gICAgdGhpcy5iID0gK2I7XG4gIH12YXIgX19fX3Byb3RvdHlwZSA9IHJnYi5wcm90b3R5cGUgPSBSZ2IucHJvdG90eXBlID0gbmV3IENvbG9yO1xuXG4gIF9fX19wcm90b3R5cGUuYnJpZ2h0ZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgUmdiKHRoaXMuciAqIGssIHRoaXMuZyAqIGssIHRoaXMuYiAqIGspO1xuICB9O1xuXG4gIF9fX19wcm90b3R5cGUuZGFya2VyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgUmdiKHRoaXMuciAqIGssIHRoaXMuZyAqIGssIHRoaXMuYiAqIGspO1xuICB9O1xuXG4gIF9fX19wcm90b3R5cGUucmdiID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX19fX3Byb3RvdHlwZS5kaXNwbGF5YWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoMCA8PSB0aGlzLnIgJiYgdGhpcy5yIDw9IDI1NSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5nICYmIHRoaXMuZyA8PSAyNTUpXG4gICAgICAgICYmICgwIDw9IHRoaXMuYiAmJiB0aGlzLmIgPD0gMjU1KTtcbiAgfTtcblxuICBfX19fcHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF9mb3JtYXQodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG4gIH07XG5cbiAgZnVuY3Rpb24gX2Zvcm1hdChyLCBnLCBiKSB7XG4gICAgcmV0dXJuIFwiI1wiXG4gICAgICAgICsgKGlzTmFOKHIpID8gXCIwMFwiIDogKHIgPSBNYXRoLnJvdW5kKHIpKSA8IDE2ID8gXCIwXCIgKyBNYXRoLm1heCgwLCByKS50b1N0cmluZygxNikgOiBNYXRoLm1pbigyNTUsIHIpLnRvU3RyaW5nKDE2KSlcbiAgICAgICAgKyAoaXNOYU4oZykgPyBcIjAwXCIgOiAoZyA9IE1hdGgucm91bmQoZykpIDwgMTYgPyBcIjBcIiArIE1hdGgubWF4KDAsIGcpLnRvU3RyaW5nKDE2KSA6IE1hdGgubWluKDI1NSwgZykudG9TdHJpbmcoMTYpKVxuICAgICAgICArIChpc05hTihiKSA/IFwiMDBcIiA6IChiID0gTWF0aC5yb3VuZChiKSkgPCAxNiA/IFwiMFwiICsgTWF0aC5tYXgoMCwgYikudG9TdHJpbmcoMTYpIDogTWF0aC5taW4oMjU1LCBiKS50b1N0cmluZygxNikpO1xuICB9XG5cbiAgZnVuY3Rpb24gaHNsKGgsIHMsIGwpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKGggaW5zdGFuY2VvZiBIc2wpIHtcbiAgICAgICAgbCA9IGgubDtcbiAgICAgICAgcyA9IGgucztcbiAgICAgICAgaCA9IGguaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKGggaW5zdGFuY2VvZiBDb2xvcikpIGggPSBjb2xvcihoKTtcbiAgICAgICAgaWYgKGgpIHtcbiAgICAgICAgICBpZiAoaCBpbnN0YW5jZW9mIEhzbCkgcmV0dXJuIGg7XG4gICAgICAgICAgaCA9IGgucmdiKCk7XG4gICAgICAgICAgdmFyIHIgPSBoLnIgLyAyNTUsXG4gICAgICAgICAgICAgIGcgPSBoLmcgLyAyNTUsXG4gICAgICAgICAgICAgIGIgPSBoLmIgLyAyNTUsXG4gICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgICAgICAgICAgcmFuZ2UgPSBtYXggLSBtaW47XG4gICAgICAgICAgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHMgPSBsIDwgLjUgPyByYW5nZSAvIChtYXggKyBtaW4pIDogcmFuZ2UgLyAoMiAtIG1heCAtIG1pbik7XG4gICAgICAgICAgICBpZiAociA9PT0gbWF4KSBoID0gKGcgLSBiKSAvIHJhbmdlICsgKGcgPCBiKSAqIDY7XG4gICAgICAgICAgICBlbHNlIGlmIChnID09PSBtYXgpIGggPSAoYiAtIHIpIC8gcmFuZ2UgKyAyO1xuICAgICAgICAgICAgZWxzZSBoID0gKHIgLSBnKSAvIHJhbmdlICsgNDtcbiAgICAgICAgICAgIGggKj0gNjA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGggPSBOYU47XG4gICAgICAgICAgICBzID0gbCA+IDAgJiYgbCA8IDEgPyAwIDogaDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaCA9IHMgPSBsID0gTmFOO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgSHNsKGgsIHMsIGwpO1xuICB9ZnVuY3Rpb24gSHNsKGgsIHMsIGwpIHtcbiAgICB0aGlzLmggPSAraDtcbiAgICB0aGlzLnMgPSArcztcbiAgICB0aGlzLmwgPSArbDtcbiAgfXZhciBfX19wcm90b3R5cGUgPSBoc2wucHJvdG90eXBlID0gSHNsLnByb3RvdHlwZSA9IG5ldyBDb2xvcjtcblxuICBfX19wcm90b3R5cGUuYnJpZ2h0ZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgSHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrKTtcbiAgfTtcblxuICBfX19wcm90b3R5cGUuZGFya2VyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgSHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrKTtcbiAgfTtcblxuICBfX19wcm90b3R5cGUucmdiID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGggPSB0aGlzLmggJSAzNjAgKyAodGhpcy5oIDwgMCkgKiAzNjAsXG4gICAgICAgIHMgPSBpc05hTihoKSB8fCBpc05hTih0aGlzLnMpID8gMCA6IHRoaXMucyxcbiAgICAgICAgbCA9IHRoaXMubCxcbiAgICAgICAgbTIgPSBsICsgKGwgPCAuNSA/IGwgOiAxIC0gbCkgKiBzLFxuICAgICAgICBtMSA9IDIgKiBsIC0gbTI7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICBoc2wycmdiKGggPj0gMjQwID8gaCAtIDI0MCA6IGggKyAxMjAsIG0xLCBtMiksXG4gICAgICBoc2wycmdiKGgsIG0xLCBtMiksXG4gICAgICBoc2wycmdiKGggPCAxMjAgPyBoICsgMjQwIDogaCAtIDEyMCwgbTEsIG0yKVxuICAgICk7XG4gIH07XG5cbiAgX19fcHJvdG90eXBlLmRpc3BsYXlhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICgwIDw9IHRoaXMucyAmJiB0aGlzLnMgPD0gMSB8fCBpc05hTih0aGlzLnMpKVxuICAgICAgICAmJiAoMCA8PSB0aGlzLmwgJiYgdGhpcy5sIDw9IDEpO1xuICB9O1xuXG4gIC8qIEZyb20gRnZEIDEzLjM3LCBDU1MgQ29sb3IgTW9kdWxlIExldmVsIDMgKi9cbiAgZnVuY3Rpb24gaHNsMnJnYihoLCBtMSwgbTIpIHtcbiAgICByZXR1cm4gKGggPCA2MCA/IG0xICsgKG0yIC0gbTEpICogaCAvIDYwXG4gICAgICAgIDogaCA8IDE4MCA/IG0yXG4gICAgICAgIDogaCA8IDI0MCA/IG0xICsgKG0yIC0gbTEpICogKDI0MCAtIGgpIC8gNjBcbiAgICAgICAgOiBtMSkgKiAyNTU7XG4gIH1cblxuICB2YXIgS24gPSAxODtcblxuICB2YXIgWG4gPSAwLjk1MDQ3MDtcbiAgdmFyIFluID0gMTtcbiAgdmFyIFpuID0gMS4wODg4MzA7XG4gIHZhciB0MCA9IDQgLyAyOTtcbiAgdmFyIHQxID0gNiAvIDI5O1xuICB2YXIgdDIgPSAzICogdDEgKiB0MTtcbiAgdmFyIHQzID0gdDEgKiB0MSAqIHQxO1xuICBmdW5jdGlvbiBsYWIobCwgYSwgYikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAobCBpbnN0YW5jZW9mIExhYikge1xuICAgICAgICBiID0gbC5iO1xuICAgICAgICBhID0gbC5hO1xuICAgICAgICBsID0gbC5sO1xuICAgICAgfSBlbHNlIGlmIChsIGluc3RhbmNlb2YgSGNsKSB7XG4gICAgICAgIHZhciBoID0gbC5oICogZGVnMnJhZDtcbiAgICAgICAgYiA9IE1hdGguc2luKGgpICogbC5jO1xuICAgICAgICBhID0gTWF0aC5jb3MoaCkgKiBsLmM7XG4gICAgICAgIGwgPSBsLmw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIShsIGluc3RhbmNlb2YgUmdiKSkgbCA9IHJnYihsKTtcbiAgICAgICAgdmFyIHIgPSByZ2IyeHl6KGwuciksXG4gICAgICAgICAgICBnID0gcmdiMnh5eihsLmcpLFxuICAgICAgICAgICAgYiA9IHJnYjJ4eXoobC5iKSxcbiAgICAgICAgICAgIHggPSB4eXoybGFiKCgwLjQxMjQ1NjQgKiByICsgMC4zNTc1NzYxICogZyArIDAuMTgwNDM3NSAqIGIpIC8gWG4pLFxuICAgICAgICAgICAgeSA9IHh5ejJsYWIoKDAuMjEyNjcyOSAqIHIgKyAwLjcxNTE1MjIgKiBnICsgMC4wNzIxNzUwICogYikgLyBZbiksXG4gICAgICAgICAgICB6ID0geHl6MmxhYigoMC4wMTkzMzM5ICogciArIDAuMTE5MTkyMCAqIGcgKyAwLjk1MDMwNDEgKiBiKSAvIFpuKTtcbiAgICAgICAgYiA9IDIwMCAqICh5IC0geik7XG4gICAgICAgIGEgPSA1MDAgKiAoeCAtIHkpO1xuICAgICAgICBsID0gMTE2ICogeSAtIDE2O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IExhYihsLCBhLCBiKTtcbiAgfWZ1bmN0aW9uIExhYihsLCBhLCBiKSB7XG4gICAgdGhpcy5sID0gK2w7XG4gICAgdGhpcy5hID0gK2E7XG4gICAgdGhpcy5iID0gK2I7XG4gIH12YXIgX19wcm90b3R5cGUgPSBsYWIucHJvdG90eXBlID0gTGFiLnByb3RvdHlwZSA9IG5ldyBDb2xvcjtcblxuICBfX3Byb3RvdHlwZS5icmlnaHRlciA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IExhYih0aGlzLmwgKyBLbiAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMuYSwgdGhpcy5iKTtcbiAgfTtcblxuICBfX3Byb3RvdHlwZS5kYXJrZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBMYWIodGhpcy5sIC0gS24gKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLmEsIHRoaXMuYik7XG4gIH07XG5cbiAgX19wcm90b3R5cGUucmdiID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHkgPSAodGhpcy5sICsgMTYpIC8gMTE2LFxuICAgICAgICB4ID0gaXNOYU4odGhpcy5hKSA/IHkgOiB5ICsgdGhpcy5hIC8gNTAwLFxuICAgICAgICB6ID0gaXNOYU4odGhpcy5iKSA/IHkgOiB5IC0gdGhpcy5iIC8gMjAwO1xuICAgIHkgPSBZbiAqIGxhYjJ4eXooeSk7XG4gICAgeCA9IFhuICogbGFiMnh5eih4KTtcbiAgICB6ID0gWm4gKiBsYWIyeHl6KHopO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgeHl6MnJnYiggMy4yNDA0NTQyICogeCAtIDEuNTM3MTM4NSAqIHkgLSAwLjQ5ODUzMTQgKiB6KSwgLy8gRDY1IC0+IHNSR0JcbiAgICAgIHh5ejJyZ2IoLTAuOTY5MjY2MCAqIHggKyAxLjg3NjAxMDggKiB5ICsgMC4wNDE1NTYwICogeiksXG4gICAgICB4eXoycmdiKCAwLjA1NTY0MzQgKiB4IC0gMC4yMDQwMjU5ICogeSArIDEuMDU3MjI1MiAqIHopXG4gICAgKTtcbiAgfTtcblxuICBmdW5jdGlvbiB4eXoybGFiKHQpIHtcbiAgICByZXR1cm4gdCA+IHQzID8gTWF0aC5wb3codCwgMSAvIDMpIDogdCAvIHQyICsgdDA7XG4gIH1cblxuICBmdW5jdGlvbiBsYWIyeHl6KHQpIHtcbiAgICByZXR1cm4gdCA+IHQxID8gdCAqIHQgKiB0IDogdDIgKiAodCAtIHQwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHh5ejJyZ2IoeCkge1xuICAgIHJldHVybiAyNTUgKiAoeCA8PSAwLjAwMzEzMDggPyAxMi45MiAqIHggOiAxLjA1NSAqIE1hdGgucG93KHgsIDEgLyAyLjQpIC0gMC4wNTUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmdiMnh5eih4KSB7XG4gICAgcmV0dXJuICh4IC89IDI1NSkgPD0gMC4wNDA0NSA/IHggLyAxMi45MiA6IE1hdGgucG93KCh4ICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG4gIH1cblxuICB2YXIgZGVnMnJhZCA9IE1hdGguUEkgLyAxODA7XG4gIHZhciByYWQyZGVnID0gMTgwIC8gTWF0aC5QSTtcblxuICBmdW5jdGlvbiBoY2woaCwgYywgbCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoaCBpbnN0YW5jZW9mIEhjbCkge1xuICAgICAgICBsID0gaC5sO1xuICAgICAgICBjID0gaC5jO1xuICAgICAgICBoID0gaC5oO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCEoaCBpbnN0YW5jZW9mIExhYikpIGggPSBsYWIoaCk7XG4gICAgICAgIGwgPSBoLmw7XG4gICAgICAgIGMgPSBNYXRoLnNxcnQoaC5hICogaC5hICsgaC5iICogaC5iKTtcbiAgICAgICAgaCA9IE1hdGguYXRhbjIoaC5iLCBoLmEpICogcmFkMmRlZztcbiAgICAgICAgaWYgKGggPCAwKSBoICs9IDM2MDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBIY2woaCwgYywgbCk7XG4gIH1mdW5jdGlvbiBIY2woaCwgYywgbCkge1xuICAgIHRoaXMuaCA9ICtoO1xuICAgIHRoaXMuYyA9ICtjO1xuICAgIHRoaXMubCA9ICtsO1xuICB9dmFyIF9wcm90b3R5cGUgPSBoY2wucHJvdG90eXBlID0gSGNsLnByb3RvdHlwZSA9IG5ldyBDb2xvcjtcblxuICBfcHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgKyBLbiAqIChrID09IG51bGwgPyAxIDogaykpO1xuICB9O1xuXG4gIF9wcm90b3R5cGUuZGFya2VyID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgLSBLbiAqIChrID09IG51bGwgPyAxIDogaykpO1xuICB9O1xuXG4gIF9wcm90b3R5cGUucmdiID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxhYih0aGlzKS5yZ2IoKTtcbiAgfTtcblxuICB2YXIgQSA9IC0wLjE0ODYxO1xuICB2YXIgQiA9ICsxLjc4Mjc3O1xuICB2YXIgQyA9IC0wLjI5MjI3O1xuICB2YXIgRCA9IC0wLjkwNjQ5O1xuICB2YXIgRSA9ICsxLjk3Mjk0O1xuICB2YXIgRUQgPSBFICogRDtcbiAgdmFyIEVCID0gRSAqIEI7XG4gIHZhciBCQ19EQSA9IEIgKiBDIC0gRCAqIEE7XG4gIGZ1bmN0aW9uIGN1YmVoZWxpeChoLCBzLCBsKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChoIGluc3RhbmNlb2YgQ3ViZWhlbGl4KSB7XG4gICAgICAgIGwgPSBoLmw7XG4gICAgICAgIHMgPSBoLnM7XG4gICAgICAgIGggPSBoLmg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIShoIGluc3RhbmNlb2YgUmdiKSkgaCA9IHJnYihoKTtcbiAgICAgICAgdmFyIHIgPSBoLnIgLyAyNTUsIGcgPSBoLmcgLyAyNTUsIGIgPSBoLmIgLyAyNTU7XG4gICAgICAgIGwgPSAoQkNfREEgKiBiICsgRUQgKiByIC0gRUIgKiBnKSAvIChCQ19EQSArIEVEIC0gRUIpO1xuICAgICAgICB2YXIgYmwgPSBiIC0gbCwgayA9IChFICogKGcgLSBsKSAtIEMgKiBibCkgLyBEO1xuICAgICAgICBzID0gTWF0aC5zcXJ0KGsgKiBrICsgYmwgKiBibCkgLyAoRSAqIGwgKiAoMSAtIGwpKTsgLy8gTmFOIGlmIGw9MCBvciBsPTFcbiAgICAgICAgaCA9IHMgPyBNYXRoLmF0YW4yKGssIGJsKSAqIHJhZDJkZWcgLSAxMjAgOiBOYU47XG4gICAgICAgIGlmIChoIDwgMCkgaCArPSAzNjA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ3ViZWhlbGl4KGgsIHMsIGwpO1xuICB9ZnVuY3Rpb24gQ3ViZWhlbGl4KGgsIHMsIGwpIHtcbiAgICB0aGlzLmggPSAraDtcbiAgICB0aGlzLnMgPSArcztcbiAgICB0aGlzLmwgPSArbDtcbiAgfXZhciBwcm90b3R5cGUgPSBjdWJlaGVsaXgucHJvdG90eXBlID0gQ3ViZWhlbGl4LnByb3RvdHlwZSA9IG5ldyBDb2xvcjtcblxuICBwcm90b3R5cGUuYnJpZ2h0ZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgQ3ViZWhlbGl4KHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrKTtcbiAgfTtcblxuICBwcm90b3R5cGUuZGFya2VyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgQ3ViZWhlbGl4KHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrKTtcbiAgfTtcblxuICBwcm90b3R5cGUucmdiID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGggPSBpc05hTih0aGlzLmgpID8gMCA6ICh0aGlzLmggKyAxMjApICogZGVnMnJhZCxcbiAgICAgICAgbCA9ICt0aGlzLmwsXG4gICAgICAgIGEgPSBpc05hTih0aGlzLnMpID8gMCA6IHRoaXMucyAqIGwgKiAoMSAtIGwpLFxuICAgICAgICBjb3NoID0gTWF0aC5jb3MoaCksXG4gICAgICAgIHNpbmggPSBNYXRoLnNpbihoKTtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIDI1NSAqIChsICsgYSAqIChBICogY29zaCArIEIgKiBzaW5oKSksXG4gICAgICAyNTUgKiAobCArIGEgKiAoQyAqIGNvc2ggKyBEICogc2luaCkpLFxuICAgICAgMjU1ICogKGwgKyBhICogKEUgKiBjb3NoKSlcbiAgICApO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlQ3ViZWhlbGl4R2FtbWEoZ2FtbWEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgICAgYSA9IGN1YmVoZWxpeChhKTtcbiAgICAgIGIgPSBjdWJlaGVsaXgoYik7XG4gICAgICB2YXIgYWggPSBpc05hTihhLmgpID8gYi5oIDogYS5oLFxuICAgICAgICAgIGFzID0gaXNOYU4oYS5zKSA/IGIucyA6IGEucyxcbiAgICAgICAgICBhbCA9IGEubCxcbiAgICAgICAgICBiaCA9IGlzTmFOKGIuaCkgPyAwIDogZGVsdGFIdWUoYi5oLCBhaCksXG4gICAgICAgICAgYnMgPSBpc05hTihiLnMpID8gMCA6IGIucyAtIGFzLFxuICAgICAgICAgIGJsID0gYi5sIC0gYWw7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICBhLmggPSBhaCArIGJoICogdDtcbiAgICAgICAgYS5zID0gYXMgKyBicyAqIHQ7XG4gICAgICAgIGEubCA9IGFsICsgYmwgKiBNYXRoLnBvdyh0LCBnYW1tYSk7XG4gICAgICAgIHJldHVybiBhICsgXCJcIjtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlQ3ViZWhlbGl4R2FtbWFMb25nKGdhbW1hKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGEgPSBjdWJlaGVsaXgoYSk7XG4gICAgICBiID0gY3ViZWhlbGl4KGIpO1xuICAgICAgdmFyIGFoID0gaXNOYU4oYS5oKSA/IGIuaCA6IGEuaCxcbiAgICAgICAgICBhcyA9IGlzTmFOKGEucykgPyBiLnMgOiBhLnMsXG4gICAgICAgICAgYWwgPSBhLmwsXG4gICAgICAgICAgYmggPSBpc05hTihiLmgpID8gMCA6IGIuaCAtIGFoLFxuICAgICAgICAgIGJzID0gaXNOYU4oYi5zKSA/IDAgOiBiLnMgLSBhcyxcbiAgICAgICAgICBibCA9IGIubCAtIGFsO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgYS5oID0gYWggKyBiaCAqIHQ7XG4gICAgICAgIGEucyA9IGFzICsgYnMgKiB0O1xuICAgICAgICBhLmwgPSBhbCArIGJsICogTWF0aC5wb3codCwgZ2FtbWEpO1xuICAgICAgICByZXR1cm4gYSArIFwiXCI7XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZUhjbExvbmcoYSwgYikge1xuICAgIGEgPSBoY2woYSk7XG4gICAgYiA9IGhjbChiKTtcbiAgICB2YXIgYWggPSBpc05hTihhLmgpID8gYi5oIDogYS5oLFxuICAgICAgICBhYyA9IGlzTmFOKGEuYykgPyBiLmMgOiBhLmMsXG4gICAgICAgIGFsID0gYS5sLFxuICAgICAgICBiaCA9IGlzTmFOKGIuaCkgPyAwIDogYi5oIC0gYWgsXG4gICAgICAgIGJjID0gaXNOYU4oYi5jKSA/IDAgOiBiLmMgLSBhYyxcbiAgICAgICAgYmwgPSBiLmwgLSBhbDtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgYS5oID0gYWggKyBiaCAqIHQ7XG4gICAgICBhLmMgPSBhYyArIGJjICogdDtcbiAgICAgIGEubCA9IGFsICsgYmwgKiB0O1xuICAgICAgcmV0dXJuIGEgKyBcIlwiO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZUhjbChhLCBiKSB7XG4gICAgYSA9IGhjbChhKTtcbiAgICBiID0gaGNsKGIpO1xuICAgIHZhciBhaCA9IGlzTmFOKGEuaCkgPyBiLmggOiBhLmgsXG4gICAgICAgIGFjID0gaXNOYU4oYS5jKSA/IGIuYyA6IGEuYyxcbiAgICAgICAgYWwgPSBhLmwsXG4gICAgICAgIGJoID0gaXNOYU4oYi5oKSA/IDAgOiBkZWx0YUh1ZShiLmgsIGFoKSxcbiAgICAgICAgYmMgPSBpc05hTihiLmMpID8gMCA6IGIuYyAtIGFjLFxuICAgICAgICBibCA9IGIubCAtIGFsO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBhLmggPSBhaCArIGJoICogdDtcbiAgICAgIGEuYyA9IGFjICsgYmMgKiB0O1xuICAgICAgYS5sID0gYWwgKyBibCAqIHQ7XG4gICAgICByZXR1cm4gYSArIFwiXCI7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlTGFiKGEsIGIpIHtcbiAgICBhID0gbGFiKGEpO1xuICAgIGIgPSBsYWIoYik7XG4gICAgdmFyIGFsID0gYS5sLFxuICAgICAgICBhYSA9IGEuYSxcbiAgICAgICAgYWIgPSBhLmIsXG4gICAgICAgIGJsID0gYi5sIC0gYWwsXG4gICAgICAgIGJhID0gYi5hIC0gYWEsXG4gICAgICAgIGJiID0gYi5iIC0gYWI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGEubCA9IGFsICsgYmwgKiB0O1xuICAgICAgYS5hID0gYWEgKyBiYSAqIHQ7XG4gICAgICBhLmIgPSBhYiArIGJiICogdDtcbiAgICAgIHJldHVybiBhICsgXCJcIjtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGVIc2xMb25nKGEsIGIpIHtcbiAgICBhID0gaHNsKGEpO1xuICAgIGIgPSBoc2woYik7XG4gICAgdmFyIGFoID0gaXNOYU4oYS5oKSA/IGIuaCA6IGEuaCxcbiAgICAgICAgYXMgPSBpc05hTihhLnMpID8gYi5zIDogYS5zLFxuICAgICAgICBhbCA9IGEubCxcbiAgICAgICAgYmggPSBpc05hTihiLmgpID8gMCA6IGIuaCAtIGFoLFxuICAgICAgICBicyA9IGlzTmFOKGIucykgPyAwIDogYi5zIC0gYXMsXG4gICAgICAgIGJsID0gYi5sIC0gYWw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGEuaCA9IGFoICsgYmggKiB0O1xuICAgICAgYS5zID0gYXMgKyBicyAqIHQ7XG4gICAgICBhLmwgPSBhbCArIGJsICogdDtcbiAgICAgIHJldHVybiBhICsgXCJcIjtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGVIc2woYSwgYikge1xuICAgIGEgPSBoc2woYSk7XG4gICAgYiA9IGhzbChiKTtcbiAgICB2YXIgYWggPSBpc05hTihhLmgpID8gYi5oIDogYS5oLFxuICAgICAgICBhcyA9IGlzTmFOKGEucykgPyBiLnMgOiBhLnMsXG4gICAgICAgIGFsID0gYS5sLFxuICAgICAgICBiaCA9IGlzTmFOKGIuaCkgPyAwIDogZGVsdGFIdWUoYi5oLCBhaCksXG4gICAgICAgIGJzID0gaXNOYU4oYi5zKSA/IDAgOiBiLnMgLSBhcyxcbiAgICAgICAgYmwgPSBiLmwgLSBhbDtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgYS5oID0gYWggKyBiaCAqIHQ7XG4gICAgICBhLnMgPSBhcyArIGJzICogdDtcbiAgICAgIGEubCA9IGFsICsgYmwgKiB0O1xuICAgICAgcmV0dXJuIGEgKyBcIlwiO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZVJnYihhLCBiKSB7XG4gICAgYSA9IHJnYihhKTtcbiAgICBiID0gcmdiKGIpO1xuICAgIHZhciBhciA9IGEucixcbiAgICAgICAgYWcgPSBhLmcsXG4gICAgICAgIGFiID0gYS5iLFxuICAgICAgICBiciA9IGIuciAtIGFyLFxuICAgICAgICBiZyA9IGIuZyAtIGFnLFxuICAgICAgICBiYiA9IGIuYiAtIGFiO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gX2Zvcm1hdChNYXRoLnJvdW5kKGFyICsgYnIgKiB0KSwgTWF0aC5yb3VuZChhZyArIGJnICogdCksIE1hdGgucm91bmQoYWIgKyBiYiAqIHQpKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGludGVycG9sYXRlQ3ViZWhlbGl4ID0gaW50ZXJwb2xhdGVDdWJlaGVsaXhHYW1tYSgxKTtcbiAgdmFyIGludGVycG9sYXRlQ3ViZWhlbGl4TG9uZyA9IGludGVycG9sYXRlQ3ViZWhlbGl4R2FtbWFMb25nKDEpO1xuXG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVDdWJlaGVsaXggPSBpbnRlcnBvbGF0ZUN1YmVoZWxpeDtcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmcgPSBpbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmc7XG4gIGV4cG9ydHMuY29sb3IgPSBjb2xvcjtcbiAgZXhwb3J0cy5yZ2IgPSByZ2I7XG4gIGV4cG9ydHMuaHNsID0gaHNsO1xuICBleHBvcnRzLmxhYiA9IGxhYjtcbiAgZXhwb3J0cy5oY2wgPSBoY2w7XG4gIGV4cG9ydHMuY3ViZWhlbGl4ID0gY3ViZWhlbGl4O1xuICBleHBvcnRzLmludGVycG9sYXRlUmdiID0gaW50ZXJwb2xhdGVSZ2I7XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVIc2wgPSBpbnRlcnBvbGF0ZUhzbDtcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZUhzbExvbmcgPSBpbnRlcnBvbGF0ZUhzbExvbmc7XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVMYWIgPSBpbnRlcnBvbGF0ZUxhYjtcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZUhjbCA9IGludGVycG9sYXRlSGNsO1xuICBleHBvcnRzLmludGVycG9sYXRlSGNsTG9uZyA9IGludGVycG9sYXRlSGNsTG9uZztcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZUN1YmVoZWxpeEdhbW1hID0gaW50ZXJwb2xhdGVDdWJlaGVsaXhHYW1tYTtcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZUN1YmVoZWxpeEdhbW1hTG9uZyA9IGludGVycG9sYXRlQ3ViZWhlbGl4R2FtbWFMb25nO1xuXG59KSk7IiwiaWYgKHR5cGVvZiBNYXAgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgTWFwID0gZnVuY3Rpb24oKSB7IHRoaXMuY2xlYXIoKTsgfTtcbiAgTWFwLnByb3RvdHlwZSA9IHtcbiAgICBzZXQ6IGZ1bmN0aW9uKGssIHYpIHsgdGhpcy5fW2tdID0gdjsgcmV0dXJuIHRoaXM7IH0sXG4gICAgZ2V0OiBmdW5jdGlvbihrKSB7IHJldHVybiB0aGlzLl9ba107IH0sXG4gICAgaGFzOiBmdW5jdGlvbihrKSB7IHJldHVybiBrIGluIHRoaXMuXzsgfSxcbiAgICBkZWxldGU6IGZ1bmN0aW9uKGspIHsgcmV0dXJuIGsgaW4gdGhpcy5fICYmIGRlbGV0ZSB0aGlzLl9ba107IH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkgeyB0aGlzLl8gPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9LFxuICAgIGdldCBzaXplKCkgeyB2YXIgbiA9IDA7IGZvciAodmFyIGsgaW4gdGhpcy5fKSArK247IHJldHVybiBuOyB9LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uKGMpIHsgZm9yICh2YXIgayBpbiB0aGlzLl8pIGModGhpcy5fW2tdLCBrLCB0aGlzKTsgfVxuICB9O1xufSBlbHNlIChmdW5jdGlvbigpIHtcbiAgdmFyIG0gPSBuZXcgTWFwO1xuICBpZiAobS5zZXQoMCwgMCkgIT09IG0pIHtcbiAgICBtID0gbS5zZXQ7XG4gICAgTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbigpIHsgbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gdGhpczsgfTtcbiAgfVxufSkoKTtcblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICBmYWN0b3J5KChnbG9iYWwuZm9ybWF0ID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB6aENuID0ge1xuICAgIGRlY2ltYWw6IFwiLlwiLFxuICAgIHRob3VzYW5kczogXCIsXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiwqVcIiwgXCJcIl1cbiAgfTtcblxuICB2YXIgcnVSdSA9IHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiXFx4YTBcIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCJcXHhhMNGA0YPQsS5cIl1cbiAgfTtcblxuICB2YXIgcHRCciA9IHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiLlwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIlIkXCIsIFwiXCJdXG4gIH07XG5cbiAgdmFyIHBsUGwgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIi5cIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCJ6xYJcIl1cbiAgfTtcblxuICB2YXIgbmxObCA9IHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiLlwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIuKCrFxceGEwXCIsIFwiXCJdXG4gIH07XG5cbiAgdmFyIG1rTWsgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIi5cIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCJcXHhhMNC00LXQvS5cIl1cbiAgfTtcblxuICB2YXIgamFKcCA9IHtcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB0aG91c2FuZHM6IFwiLFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIlwiLCBcIuWGhlwiXVxuICB9O1xuXG4gIHZhciBpdEl0ID0ge1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCIuXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wi4oKsXCIsIFwiXCJdXG4gIH07XG5cbiAgdmFyIGhlSWwgPSB7XG4gICAgZGVjaW1hbDogXCIuXCIsXG4gICAgdGhvdXNhbmRzOiBcIixcIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCLigqpcIiwgXCJcIl1cbiAgfTtcblxuICB2YXIgZnJGciA9IHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiLlwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIlwiLCBcIlxceGEw4oKsXCJdXG4gIH07XG5cbiAgdmFyIGZyQ2EgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIlxceGEwXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwiJFwiXVxuICB9O1xuXG4gIHZhciBmaUZpID0ge1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCJcXHhhMFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIlwiLCBcIlxceGEw4oKsXCJdXG4gIH07XG5cbiAgdmFyIGVzRXMgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIi5cIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCJcXHhhMOKCrFwiXVxuICB9O1xuXG4gIHZhciBlblVzID0ge1xuICAgIGRlY2ltYWw6IFwiLlwiLFxuICAgIHRob3VzYW5kczogXCIsXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiJFwiLCBcIlwiXVxuICB9O1xuXG4gIHZhciBlbkdiID0ge1xuICAgIGRlY2ltYWw6IFwiLlwiLFxuICAgIHRob3VzYW5kczogXCIsXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiwqNcIiwgXCJcIl1cbiAgfTtcblxuICB2YXIgZW5DYSA9IHtcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB0aG91c2FuZHM6IFwiLFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIiRcIiwgXCJcIl1cbiAgfTtcblxuICB2YXIgZGVEZSA9IHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiLlwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIlwiLCBcIlxceGEw4oKsXCJdXG4gIH07XG5cbiAgdmFyIGNhRXMgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIi5cIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCJcXHhhMOKCrFwiXVxuICB9O1xuXG5cbiAgLy8gQ29tcHV0ZXMgdGhlIGRlY2ltYWwgY29lZmZpY2llbnQgYW5kIGV4cG9uZW50IG9mIHRoZSBzcGVjaWZpZWQgbnVtYmVyIHggd2l0aFxuICAvLyBzaWduaWZpY2FudCBkaWdpdHMgcCwgd2hlcmUgeCBpcyBwb3NpdGl2ZSBhbmQgcCBpcyBpbiBbMSwgMjFdIG9yIHVuZGVmaW5lZC5cbiAgLy8gRm9yIGV4YW1wbGUsIGZvcm1hdERlY2ltYWwoMS4yMykgcmV0dXJucyBbXCIxMjNcIiwgMF0uXG4gIGZ1bmN0aW9uIGZvcm1hdERlY2ltYWwoeCwgcCkge1xuICAgIGlmICgoaSA9ICh4ID0gcCA/IHgudG9FeHBvbmVudGlhbChwIC0gMSkgOiB4LnRvRXhwb25lbnRpYWwoKSkuaW5kZXhPZihcImVcIikpIDwgMCkgcmV0dXJuIG51bGw7IC8vIE5hTiwgwrFJbmZpbml0eVxuICAgIHZhciBpLCBjb2VmZmljaWVudCA9IHguc2xpY2UoMCwgaSk7XG5cbiAgICAvLyBUaGUgc3RyaW5nIHJldHVybmVkIGJ5IHRvRXhwb25lbnRpYWwgZWl0aGVyIGhhcyB0aGUgZm9ybSBcXGRcXC5cXGQrZVstK11cXGQrXG4gICAgLy8gKGUuZy4sIDEuMmUrMykgb3IgdGhlIGZvcm0gXFxkZVstK11cXGQrIChlLmcuLCAxZSszKS5cbiAgICByZXR1cm4gW1xuICAgICAgY29lZmZpY2llbnQubGVuZ3RoID4gMSA/IGNvZWZmaWNpZW50WzBdICsgY29lZmZpY2llbnQuc2xpY2UoMikgOiBjb2VmZmljaWVudCxcbiAgICAgICt4LnNsaWNlKGkgKyAxKVxuICAgIF07XG4gIH1cblxuICBmdW5jdGlvbiBleHBvbmVudCh4KSB7XG4gICAgcmV0dXJuIHggPSBmb3JtYXREZWNpbWFsKE1hdGguYWJzKHgpKSwgeCA/IHhbMV0gOiBOYU47XG4gIH1cblxuICB2YXIgcHJlZml4RXhwb25lbnQ7XG5cbiAgZnVuY3Rpb24gZm9ybWF0UHJlZml4QXV0byh4LCBwKSB7XG4gICAgdmFyIGQgPSBmb3JtYXREZWNpbWFsKHgsIHApO1xuICAgIGlmICghZCkgcmV0dXJuIHggKyBcIlwiO1xuICAgIHZhciBjb2VmZmljaWVudCA9IGRbMF0sXG4gICAgICAgIGV4cG9uZW50ID0gZFsxXSxcbiAgICAgICAgaSA9IGV4cG9uZW50IC0gKHByZWZpeEV4cG9uZW50ID0gTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQgLyAzKSkpICogMykgKyAxLFxuICAgICAgICBuID0gY29lZmZpY2llbnQubGVuZ3RoO1xuICAgIHJldHVybiBpID09PSBuID8gY29lZmZpY2llbnRcbiAgICAgICAgOiBpID4gbiA/IGNvZWZmaWNpZW50ICsgbmV3IEFycmF5KGkgLSBuICsgMSkuam9pbihcIjBcIilcbiAgICAgICAgOiBpID4gMCA/IGNvZWZmaWNpZW50LnNsaWNlKDAsIGkpICsgXCIuXCIgKyBjb2VmZmljaWVudC5zbGljZShpKVxuICAgICAgICA6IFwiMC5cIiArIG5ldyBBcnJheSgxIC0gaSkuam9pbihcIjBcIikgKyBmb3JtYXREZWNpbWFsKHgsIHAgKyBpIC0gMSlbMF07IC8vIGxlc3MgdGhhbiAxeSFcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFJvdW5kZWQoeCwgcCkge1xuICAgIHZhciBkID0gZm9ybWF0RGVjaW1hbCh4LCBwKTtcbiAgICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcbiAgICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxuICAgICAgICBleHBvbmVudCA9IGRbMV07XG4gICAgcmV0dXJuIGV4cG9uZW50IDwgMCA/IFwiMC5cIiArIG5ldyBBcnJheSgtZXhwb25lbnQpLmpvaW4oXCIwXCIpICsgY29lZmZpY2llbnRcbiAgICAgICAgOiBjb2VmZmljaWVudC5sZW5ndGggPiBleHBvbmVudCArIDEgPyBjb2VmZmljaWVudC5zbGljZSgwLCBleHBvbmVudCArIDEpICsgXCIuXCIgKyBjb2VmZmljaWVudC5zbGljZShleHBvbmVudCArIDEpXG4gICAgICAgIDogY29lZmZpY2llbnQgKyBuZXcgQXJyYXkoZXhwb25lbnQgLSBjb2VmZmljaWVudC5sZW5ndGggKyAyKS5qb2luKFwiMFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdERlZmF1bHQoeCwgcCkge1xuICAgIHggPSB4LnRvUHJlY2lzaW9uKHApO1xuXG4gICAgb3V0OiBmb3IgKHZhciBuID0geC5sZW5ndGgsIGkgPSAxLCBpMCA9IC0xLCBpMTsgaSA8IG47ICsraSkge1xuICAgICAgc3dpdGNoICh4W2ldKSB7XG4gICAgICAgIGNhc2UgXCIuXCI6IGkwID0gaTEgPSBpOyBicmVhaztcbiAgICAgICAgY2FzZSBcIjBcIjogaWYgKGkwID09PSAwKSBpMCA9IGk7IGkxID0gaTsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlXCI6IGJyZWFrIG91dDtcbiAgICAgICAgZGVmYXVsdDogaWYgKGkwID4gMCkgaTAgPSAwOyBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaTAgPiAwID8geC5zbGljZSgwLCBpMCkgKyB4LnNsaWNlKGkxICsgMSkgOiB4O1xuICB9XG5cbiAgdmFyIGZvcm1hdFR5cGVzID0ge1xuICAgIFwiXCI6IGZvcm1hdERlZmF1bHQsXG4gICAgXCIlXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuICh4ICogMTAwKS50b0ZpeGVkKHApOyB9LFxuICAgIFwiYlwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDIpOyB9LFxuICAgIFwiY1wiOiBmdW5jdGlvbih4KSB7IHJldHVybiB4ICsgXCJcIjsgfSxcbiAgICBcImRcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxMCk7IH0sXG4gICAgXCJlXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIHgudG9FeHBvbmVudGlhbChwKTsgfSxcbiAgICBcImZcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4geC50b0ZpeGVkKHApOyB9LFxuICAgIFwiZ1wiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvUHJlY2lzaW9uKHApOyB9LFxuICAgIFwib1wiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDgpOyB9LFxuICAgIFwicFwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiBmb3JtYXRSb3VuZGVkKHggKiAxMDAsIHApOyB9LFxuICAgIFwiclwiOiBmb3JtYXRSb3VuZGVkLFxuICAgIFwic1wiOiBmb3JtYXRQcmVmaXhBdXRvLFxuICAgIFwiWFwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyB9LFxuICAgIFwieFwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDE2KTsgfVxuICB9O1xuXG5cbiAgLy8gW1tmaWxsXWFsaWduXVtzaWduXVtzeW1ib2xdWzBdW3dpZHRoXVssXVsucHJlY2lzaW9uXVt0eXBlXVxuICB2YXIgcmUgPSAvXig/OiguKT8oWzw+PV5dKSk/KFsrXFwtXFwoIF0pPyhbJCNdKT8oMCk/KFxcZCspPygsKT8oXFwuXFxkKyk/KFthLXolXSk/JC9pO1xuXG4gIGZ1bmN0aW9uIGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpIHtcbiAgICByZXR1cm4gbmV3IEZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gRm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikge1xuICAgIGlmICghKG1hdGNoID0gcmUuZXhlYyhzcGVjaWZpZXIpKSkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmb3JtYXQ6IFwiICsgc3BlY2lmaWVyKTtcblxuICAgIHZhciBtYXRjaCxcbiAgICAgICAgZmlsbCA9IG1hdGNoWzFdIHx8IFwiIFwiLFxuICAgICAgICBhbGlnbiA9IG1hdGNoWzJdIHx8IFwiPlwiLFxuICAgICAgICBzaWduID0gbWF0Y2hbM10gfHwgXCItXCIsXG4gICAgICAgIHN5bWJvbCA9IG1hdGNoWzRdIHx8IFwiXCIsXG4gICAgICAgIHplcm8gPSAhIW1hdGNoWzVdLFxuICAgICAgICB3aWR0aCA9IG1hdGNoWzZdICYmICttYXRjaFs2XSxcbiAgICAgICAgY29tbWEgPSAhIW1hdGNoWzddLFxuICAgICAgICBwcmVjaXNpb24gPSBtYXRjaFs4XSAmJiArbWF0Y2hbOF0uc2xpY2UoMSksXG4gICAgICAgIHR5cGUgPSBtYXRjaFs5XSB8fCBcIlwiO1xuXG4gICAgLy8gVGhlIFwiblwiIHR5cGUgaXMgYW4gYWxpYXMgZm9yIFwiLGdcIi5cbiAgICBpZiAodHlwZSA9PT0gXCJuXCIpIGNvbW1hID0gdHJ1ZSwgdHlwZSA9IFwiZ1wiO1xuXG4gICAgLy8gTWFwIGludmFsaWQgdHlwZXMgdG8gdGhlIGRlZmF1bHQgZm9ybWF0LlxuICAgIGVsc2UgaWYgKCFmb3JtYXRUeXBlc1t0eXBlXSkgdHlwZSA9IFwiXCI7XG5cbiAgICAvLyBJZiB6ZXJvIGZpbGwgaXMgc3BlY2lmaWVkLCBwYWRkaW5nIGdvZXMgYWZ0ZXIgc2lnbiBhbmQgYmVmb3JlIGRpZ2l0cy5cbiAgICBpZiAoemVybyB8fCAoZmlsbCA9PT0gXCIwXCIgJiYgYWxpZ24gPT09IFwiPVwiKSkgemVybyA9IHRydWUsIGZpbGwgPSBcIjBcIiwgYWxpZ24gPSBcIj1cIjtcblxuICAgIHRoaXMuZmlsbCA9IGZpbGw7XG4gICAgdGhpcy5hbGlnbiA9IGFsaWduO1xuICAgIHRoaXMuc2lnbiA9IHNpZ247XG4gICAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XG4gICAgdGhpcy56ZXJvID0gemVybztcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5jb21tYSA9IGNvbW1hO1xuICAgIHRoaXMucHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gIH1cblxuICBGb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsbFxuICAgICAgICArIHRoaXMuYWxpZ25cbiAgICAgICAgKyB0aGlzLnNpZ25cbiAgICAgICAgKyB0aGlzLnN5bWJvbFxuICAgICAgICArICh0aGlzLnplcm8gPyBcIjBcIiA6IFwiXCIpXG4gICAgICAgICsgKHRoaXMud2lkdGggPT0gbnVsbCA/IFwiXCIgOiBNYXRoLm1heCgxLCB0aGlzLndpZHRoIHwgMCkpXG4gICAgICAgICsgKHRoaXMuY29tbWEgPyBcIixcIiA6IFwiXCIpXG4gICAgICAgICsgKHRoaXMucHJlY2lzaW9uID09IG51bGwgPyBcIlwiIDogXCIuXCIgKyBNYXRoLm1heCgwLCB0aGlzLnByZWNpc2lvbiB8IDApKVxuICAgICAgICArIHRoaXMudHlwZTtcbiAgfTtcblxuICBmdW5jdGlvbiBmb3JtYXRHcm91cChncm91cGluZywgdGhvdXNhbmRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCB3aWR0aCkge1xuICAgICAgdmFyIGkgPSB2YWx1ZS5sZW5ndGgsXG4gICAgICAgICAgdCA9IFtdLFxuICAgICAgICAgIGogPSAwLFxuICAgICAgICAgIGcgPSBncm91cGluZ1swXSxcbiAgICAgICAgICBsZW5ndGggPSAwO1xuXG4gICAgICB3aGlsZSAoaSA+IDAgJiYgZyA+IDApIHtcbiAgICAgICAgaWYgKGxlbmd0aCArIGcgKyAxID4gd2lkdGgpIGcgPSBNYXRoLm1heCgxLCB3aWR0aCAtIGxlbmd0aCk7XG4gICAgICAgIHQucHVzaCh2YWx1ZS5zdWJzdHJpbmcoaSAtPSBnLCBpICsgZykpO1xuICAgICAgICBpZiAoKGxlbmd0aCArPSBnICsgMSkgPiB3aWR0aCkgYnJlYWs7XG4gICAgICAgIGcgPSBncm91cGluZ1tqID0gKGogKyAxKSAlIGdyb3VwaW5nLmxlbmd0aF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0LnJldmVyc2UoKS5qb2luKHRob3VzYW5kcyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBwcmVmaXhlcyA9IFtcInlcIixcInpcIixcImFcIixcImZcIixcInBcIixcIm5cIixcIsK1XCIsXCJtXCIsXCJcIixcImtcIixcIk1cIixcIkdcIixcIlRcIixcIlBcIixcIkVcIixcIlpcIixcIllcIl07XG5cbiAgZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICAgIHJldHVybiB4O1xuICB9XG5cbiAgZnVuY3Rpb24gbG9jYWxlKGxvY2FsZSkge1xuICAgIHZhciBncm91cCA9IGxvY2FsZS5ncm91cGluZyAmJiBsb2NhbGUudGhvdXNhbmRzID8gZm9ybWF0R3JvdXAobG9jYWxlLmdyb3VwaW5nLCBsb2NhbGUudGhvdXNhbmRzKSA6IGlkZW50aXR5LFxuICAgICAgICBjdXJyZW5jeSA9IGxvY2FsZS5jdXJyZW5jeSxcbiAgICAgICAgZGVjaW1hbCA9IGxvY2FsZS5kZWNpbWFsO1xuXG4gICAgZnVuY3Rpb24gZm9ybWF0KHNwZWNpZmllcikge1xuICAgICAgc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcik7XG5cbiAgICAgIHZhciBmaWxsID0gc3BlY2lmaWVyLmZpbGwsXG4gICAgICAgICAgYWxpZ24gPSBzcGVjaWZpZXIuYWxpZ24sXG4gICAgICAgICAgc2lnbiA9IHNwZWNpZmllci5zaWduLFxuICAgICAgICAgIHN5bWJvbCA9IHNwZWNpZmllci5zeW1ib2wsXG4gICAgICAgICAgemVybyA9IHNwZWNpZmllci56ZXJvLFxuICAgICAgICAgIHdpZHRoID0gc3BlY2lmaWVyLndpZHRoLFxuICAgICAgICAgIGNvbW1hID0gc3BlY2lmaWVyLmNvbW1hLFxuICAgICAgICAgIHByZWNpc2lvbiA9IHNwZWNpZmllci5wcmVjaXNpb24sXG4gICAgICAgICAgdHlwZSA9IHNwZWNpZmllci50eXBlO1xuXG4gICAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAgIC8vIEZvciBTSS1wcmVmaXgsIHRoZSBzdWZmaXggaXMgbGF6aWx5IGNvbXB1dGVkLlxuICAgICAgdmFyIHByZWZpeCA9IHN5bWJvbCA9PT0gXCIkXCIgPyBjdXJyZW5jeVswXSA6IHN5bWJvbCA9PT0gXCIjXCIgJiYgL1tib3hYXS8udGVzdCh0eXBlKSA/IFwiMFwiICsgdHlwZS50b0xvd2VyQ2FzZSgpIDogXCJcIixcbiAgICAgICAgICBzdWZmaXggPSBzeW1ib2wgPT09IFwiJFwiID8gY3VycmVuY3lbMV0gOiAvWyVwXS8udGVzdCh0eXBlKSA/IFwiJVwiIDogXCJcIjtcblxuICAgICAgLy8gV2hhdCBmb3JtYXQgZnVuY3Rpb24gc2hvdWxkIHdlIHVzZT9cbiAgICAgIC8vIElzIHRoaXMgYW4gaW50ZWdlciB0eXBlP1xuICAgICAgLy8gQ2FuIHRoaXMgdHlwZSBnZW5lcmF0ZSBleHBvbmVudGlhbCBub3RhdGlvbj9cbiAgICAgIHZhciBmb3JtYXRUeXBlID0gZm9ybWF0VHlwZXNbdHlwZV0sXG4gICAgICAgICAgbWF5YmVTdWZmaXggPSAhdHlwZSB8fCAvW2RlZmdwcnMlXS8udGVzdCh0eXBlKTtcblxuICAgICAgLy8gU2V0IHRoZSBkZWZhdWx0IHByZWNpc2lvbiBpZiBub3Qgc3BlY2lmaWVkLFxuICAgICAgLy8gb3IgY2xhbXAgdGhlIHNwZWNpZmllZCBwcmVjaXNpb24gdG8gdGhlIHN1cHBvcnRlZCByYW5nZS5cbiAgICAgIC8vIEZvciBzaWduaWZpY2FudCBwcmVjaXNpb24sIGl0IG11c3QgYmUgaW4gWzEsIDIxXS5cbiAgICAgIC8vIEZvciBmaXhlZCBwcmVjaXNpb24sIGl0IG11c3QgYmUgaW4gWzAsIDIwXS5cbiAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PSBudWxsID8gKHR5cGUgPyA2IDogMTIpXG4gICAgICAgICAgOiAvW2dwcnNdLy50ZXN0KHR5cGUpID8gTWF0aC5tYXgoMSwgTWF0aC5taW4oMjEsIHByZWNpc2lvbikpXG4gICAgICAgICAgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigyMCwgcHJlY2lzaW9uKSk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgdmFsdWVQcmVmaXggPSBwcmVmaXgsXG4gICAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IHN1ZmZpeDtcblxuICAgICAgICBpZiAodHlwZSA9PT0gXCJjXCIpIHtcbiAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IGZvcm1hdFR5cGUodmFsdWUpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gK3ZhbHVlO1xuXG4gICAgICAgICAgLy8gQ29udmVydCBuZWdhdGl2ZSB0byBwb3NpdGl2ZSwgYW5kIGNvbXB1dGUgdGhlIHByZWZpeC5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgLTAgaXMgbm90IGxlc3MgdGhhbiAwLCBidXQgMSAvIC0wIGlzIVxuICAgICAgICAgIHZhciB2YWx1ZU5lZ2F0aXZlID0gKHZhbHVlIDwgMCB8fCAxIC8gdmFsdWUgPCAwKSAmJiAodmFsdWUgKj0gLTEsIHRydWUpO1xuXG4gICAgICAgICAgLy8gUGVyZm9ybSB0aGUgaW5pdGlhbCBmb3JtYXR0aW5nLlxuICAgICAgICAgIHZhbHVlID0gZm9ybWF0VHlwZSh2YWx1ZSwgcHJlY2lzaW9uKTtcblxuICAgICAgICAgIC8vIENvbXB1dGUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxuICAgICAgICAgIHZhbHVlUHJlZml4ID0gKHZhbHVlTmVnYXRpdmUgPyAoc2lnbiA9PT0gXCIoXCIgPyBzaWduIDogXCItXCIpIDogc2lnbiA9PT0gXCItXCIgfHwgc2lnbiA9PT0gXCIoXCIgPyBcIlwiIDogc2lnbikgKyB2YWx1ZVByZWZpeDtcbiAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IHZhbHVlU3VmZml4ICsgKHR5cGUgPT09IFwic1wiID8gcHJlZml4ZXNbOCArIHByZWZpeEV4cG9uZW50IC8gM10gOiBcIlwiKSArICh2YWx1ZU5lZ2F0aXZlICYmIHNpZ24gPT09IFwiKFwiID8gXCIpXCIgOiBcIlwiKTtcblxuICAgICAgICAgIC8vIEJyZWFrIHRoZSBmb3JtYXR0ZWQgdmFsdWUgaW50byB0aGUgaW50ZWdlciDigJx2YWx1ZeKAnSBwYXJ0IHRoYXQgY2FuIGJlXG4gICAgICAgICAgLy8gZ3JvdXBlZCwgYW5kIGZyYWN0aW9uYWwgb3IgZXhwb25lbnRpYWwg4oCcc3VmZml44oCdIHBhcnQgdGhhdCBpcyBub3QuXG4gICAgICAgICAgaWYgKG1heWJlU3VmZml4KSB7XG4gICAgICAgICAgICB2YXIgaSA9IC0xLCBuID0gdmFsdWUubGVuZ3RoLCBjO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgaWYgKGMgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpLCA0OCA+IGMgfHwgYyA+IDU3KSB7XG4gICAgICAgICAgICAgICAgdmFsdWVTdWZmaXggPSAoYyA9PT0gNDYgPyBkZWNpbWFsICsgdmFsdWUuc2xpY2UoaSArIDEpIDogdmFsdWUuc2xpY2UoaSkpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBmaWxsIGNoYXJhY3RlciBpcyBub3QgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYmVmb3JlIHBhZGRpbmcuXG4gICAgICAgIGlmIChjb21tYSAmJiAhemVybykgdmFsdWUgPSBncm91cCh2YWx1ZSwgSW5maW5pdHkpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHBhZGRpbmcuXG4gICAgICAgIHZhciBsZW5ndGggPSB2YWx1ZVByZWZpeC5sZW5ndGggKyB2YWx1ZS5sZW5ndGggKyB2YWx1ZVN1ZmZpeC5sZW5ndGgsXG4gICAgICAgICAgICBwYWRkaW5nID0gbGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpIDogXCJcIjtcblxuICAgICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYWZ0ZXIgcGFkZGluZy5cbiAgICAgICAgaWYgKGNvbW1hICYmIHplcm8pIHZhbHVlID0gZ3JvdXAocGFkZGluZyArIHZhbHVlLCBwYWRkaW5nLmxlbmd0aCA/IHdpZHRoIC0gdmFsdWVTdWZmaXgubGVuZ3RoIDogSW5maW5pdHkpLCBwYWRkaW5nID0gXCJcIjtcblxuICAgICAgICAvLyBSZWNvbnN0cnVjdCB0aGUgZmluYWwgb3V0cHV0IGJhc2VkIG9uIHRoZSBkZXNpcmVkIGFsaWdubWVudC5cbiAgICAgICAgc3dpdGNoIChhbGlnbikge1xuICAgICAgICAgIGNhc2UgXCI8XCI6IHJldHVybiB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXggKyBwYWRkaW5nO1xuICAgICAgICAgIGNhc2UgXCI9XCI6IHJldHVybiB2YWx1ZVByZWZpeCArIHBhZGRpbmcgKyB2YWx1ZSArIHZhbHVlU3VmZml4O1xuICAgICAgICAgIGNhc2UgXCJeXCI6IHJldHVybiBwYWRkaW5nLnNsaWNlKDAsIGxlbmd0aCA9IHBhZGRpbmcubGVuZ3RoID4+IDEpICsgdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4ICsgcGFkZGluZy5zbGljZShsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWRkaW5nICsgdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSkge1xuICAgICAgdmFyIGYgPSBmb3JtYXQoKHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpLCBzcGVjaWZpZXIudHlwZSA9IFwiZlwiLCBzcGVjaWZpZXIpKSxcbiAgICAgICAgICBlID0gTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQodmFsdWUpIC8gMykpKSAqIDMsXG4gICAgICAgICAgayA9IE1hdGgucG93KDEwLCAtZSksXG4gICAgICAgICAgcHJlZml4ID0gcHJlZml4ZXNbOCArIGUgLyAzXTtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZihrICogdmFsdWUpICsgcHJlZml4O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgICBmb3JtYXRQcmVmaXg6IGZvcm1hdFByZWZpeFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwcmVjaXNpb25Sb3VuZChzdGVwLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgZXhwb25lbnQoTWF0aC5hYnMobWF4KSkgLSBleHBvbmVudChNYXRoLmFicyhzdGVwKSkpICsgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZWNpc2lvblByZWZpeChzdGVwLCB2YWx1ZSkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyAtIGV4cG9uZW50KE1hdGguYWJzKHN0ZXApKSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVjaXNpb25GaXhlZChzdGVwKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIC1leHBvbmVudChNYXRoLmFicyhzdGVwKSkpO1xuICB9XG5cbiAgdmFyIGxvY2FsZURlZmluaXRpb25zID0gKG5ldyBNYXApXG4gICAgICAuc2V0KFwiY2EtRVNcIiwgY2FFcylcbiAgICAgIC5zZXQoXCJkZS1ERVwiLCBkZURlKVxuICAgICAgLnNldChcImVuLUNBXCIsIGVuQ2EpXG4gICAgICAuc2V0KFwiZW4tR0JcIiwgZW5HYilcbiAgICAgIC5zZXQoXCJlbi1VU1wiLCBlblVzKVxuICAgICAgLnNldChcImVzLUVTXCIsIGVzRXMpXG4gICAgICAuc2V0KFwiZmktRklcIiwgZmlGaSlcbiAgICAgIC5zZXQoXCJmci1DQVwiLCBmckNhKVxuICAgICAgLnNldChcImZyLUZSXCIsIGZyRnIpXG4gICAgICAuc2V0KFwiaGUtSUxcIiwgaGVJbClcbiAgICAgIC5zZXQoXCJpdC1JVFwiLCBpdEl0KVxuICAgICAgLnNldChcImphLUpQXCIsIGphSnApXG4gICAgICAuc2V0KFwibWstTUtcIiwgbWtNaylcbiAgICAgIC5zZXQoXCJubC1OTFwiLCBubE5sKVxuICAgICAgLnNldChcInBsLVBMXCIsIHBsUGwpXG4gICAgICAuc2V0KFwicHQtQlJcIiwgcHRCcilcbiAgICAgIC5zZXQoXCJydS1SVVwiLCBydVJ1KVxuICAgICAgLnNldChcInpoLUNOXCIsIHpoQ24pO1xuXG4gIHZhciBkZWZhdWx0TG9jYWxlID0gbG9jYWxlKGVuVXMpO1xuICBleHBvcnRzLmZvcm1hdCA9IGRlZmF1bHRMb2NhbGUuZm9ybWF0O1xuICBleHBvcnRzLmZvcm1hdFByZWZpeCA9IGRlZmF1bHRMb2NhbGUuZm9ybWF0UHJlZml4O1xuXG4gIGZ1bmN0aW9uIGxvY2FsZUZvcm1hdChkZWZpbml0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBkZWZpbml0aW9uID0gbG9jYWxlRGVmaW5pdGlvbnMuZ2V0KGRlZmluaXRpb24pO1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZShkZWZpbml0aW9uKTtcbiAgfVxuICA7XG5cbiAgZXhwb3J0cy5sb2NhbGVGb3JtYXQgPSBsb2NhbGVGb3JtYXQ7XG4gIGV4cG9ydHMuZm9ybWF0U3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyO1xuICBleHBvcnRzLnByZWNpc2lvbkZpeGVkID0gcHJlY2lzaW9uRml4ZWQ7XG4gIGV4cG9ydHMucHJlY2lzaW9uUHJlZml4ID0gcHJlY2lzaW9uUHJlZml4O1xuICBleHBvcnRzLnByZWNpc2lvblJvdW5kID0gcHJlY2lzaW9uUm91bmQ7XG5cbn0pKTsiLCJpZiAodHlwZW9mIE1hcCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICBNYXAgPSBmdW5jdGlvbigpIHsgdGhpcy5jbGVhcigpOyB9O1xuICBNYXAucHJvdG90eXBlID0ge1xuICAgIHNldDogZnVuY3Rpb24oaywgdikgeyB0aGlzLl9ba10gPSB2OyByZXR1cm4gdGhpczsgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKGspIHsgcmV0dXJuIHRoaXMuX1trXTsgfSxcbiAgICBoYXM6IGZ1bmN0aW9uKGspIHsgcmV0dXJuIGsgaW4gdGhpcy5fOyB9LFxuICAgIGRlbGV0ZTogZnVuY3Rpb24oaykgeyByZXR1cm4gayBpbiB0aGlzLl8gJiYgZGVsZXRlIHRoaXMuX1trXTsgfSxcbiAgICBjbGVhcjogZnVuY3Rpb24oKSB7IHRoaXMuXyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IH0sXG4gICAgZ2V0IHNpemUoKSB7IHZhciBuID0gMDsgZm9yICh2YXIgayBpbiB0aGlzLl8pICsrbjsgcmV0dXJuIG47IH0sXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oYykgeyBmb3IgKHZhciBrIGluIHRoaXMuXykgYyh0aGlzLl9ba10sIGssIHRoaXMpOyB9XG4gIH07XG59IGVsc2UgKGZ1bmN0aW9uKCkge1xuICB2YXIgbSA9IG5ldyBNYXA7XG4gIGlmIChtLnNldCgwLCAwKSAhPT0gbSkge1xuICAgIG0gPSBtLnNldDtcbiAgICBNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKCkgeyBtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiB0aGlzOyB9O1xuICB9XG59KSgpO1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIGZhY3RvcnkoKGdsb2JhbC50aW1lRm9ybWF0ID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB6aENuID0ge1xuICAgIGRhdGVUaW1lOiBcIiVhICViICVlICVYICVZXCIsXG4gICAgZGF0ZTogXCIlWS8lLW0vJS1kXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIuS4iuWNiFwiLCBcIuS4i+WNiFwiXSxcbiAgICBkYXlzOiBbXCLmmJ/mnJ/ml6VcIiwgXCLmmJ/mnJ/kuIBcIiwgXCLmmJ/mnJ/kuoxcIiwgXCLmmJ/mnJ/kuIlcIiwgXCLmmJ/mnJ/lm5tcIiwgXCLmmJ/mnJ/kupRcIiwgXCLmmJ/mnJ/lha1cIl0sXG4gICAgc2hvcnREYXlzOiBbXCLmmJ/mnJ/ml6VcIiwgXCLmmJ/mnJ/kuIBcIiwgXCLmmJ/mnJ/kuoxcIiwgXCLmmJ/mnJ/kuIlcIiwgXCLmmJ/mnJ/lm5tcIiwgXCLmmJ/mnJ/kupRcIiwgXCLmmJ/mnJ/lha1cIl0sXG4gICAgbW9udGhzOiBbXCLkuIDmnIhcIiwgXCLkuozmnIhcIiwgXCLkuInmnIhcIiwgXCLlm5vmnIhcIiwgXCLkupTmnIhcIiwgXCLlha3mnIhcIiwgXCLkuIPmnIhcIiwgXCLlhavmnIhcIiwgXCLkuZ3mnIhcIiwgXCLljYHmnIhcIiwgXCLljYHkuIDmnIhcIiwgXCLljYHkuozmnIhcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIuS4gOaciFwiLCBcIuS6jOaciFwiLCBcIuS4ieaciFwiLCBcIuWbm+aciFwiLCBcIuS6lOaciFwiLCBcIuWFreaciFwiLCBcIuS4g+aciFwiLCBcIuWFq+aciFwiLCBcIuS5neaciFwiLCBcIuWNgeaciFwiLCBcIuWNgeS4gOaciFwiLCBcIuWNgeS6jOaciFwiXVxuICB9O1xuXG4gIHZhciBydVJ1ID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBLCAlZSAlQiAlWSDQsy4gJVhcIixcbiAgICBkYXRlOiBcIiVkLiVtLiVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgZGF5czogW1wi0LLQvtGB0LrRgNC10YHQtdC90YzQtVwiLCBcItC/0L7QvdC10LTQtdC70YzQvdC40LpcIiwgXCLQstGC0L7RgNC90LjQulwiLCBcItGB0YDQtdC00LBcIiwgXCLRh9C10YLQstC10YDQs1wiLCBcItC/0Y/RgtC90LjRhtCwXCIsIFwi0YHRg9Cx0LHQvtGC0LBcIl0sXG4gICAgc2hvcnREYXlzOiBbXCLQstGBXCIsIFwi0L/QvVwiLCBcItCy0YJcIiwgXCLRgdGAXCIsIFwi0YfRglwiLCBcItC/0YJcIiwgXCLRgdCxXCJdLFxuICAgIG1vbnRoczogW1wi0Y/QvdCy0LDRgNGPXCIsIFwi0YTQtdCy0YDQsNC70Y9cIiwgXCLQvNCw0YDRgtCwXCIsIFwi0LDQv9GA0LXQu9GPXCIsIFwi0LzQsNGPXCIsIFwi0LjRjtC90Y9cIiwgXCLQuNGO0LvRj1wiLCBcItCw0LLQs9GD0YHRgtCwXCIsIFwi0YHQtdC90YLRj9Cx0YDRj1wiLCBcItC+0LrRgtGP0LHRgNGPXCIsIFwi0L3QvtGP0LHRgNGPXCIsIFwi0LTQtdC60LDQsdGA0Y9cIl0sXG4gICAgc2hvcnRNb250aHM6IFtcItGP0L3QslwiLCBcItGE0LXQslwiLCBcItC80LDRgFwiLCBcItCw0L/RgFwiLCBcItC80LDQuVwiLCBcItC40Y7QvVwiLCBcItC40Y7Qu1wiLCBcItCw0LLQs1wiLCBcItGB0LXQvVwiLCBcItC+0LrRglwiLCBcItC90L7Rj1wiLCBcItC00LXQulwiXVxuICB9O1xuXG4gIHZhciBwdEJyID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBLCAlZSBkZSAlQiBkZSAlWS4gJVhcIixcbiAgICBkYXRlOiBcIiVkLyVtLyVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgZGF5czogW1wiRG9taW5nb1wiLCBcIlNlZ3VuZGFcIiwgXCJUZXLDp2FcIiwgXCJRdWFydGFcIiwgXCJRdWludGFcIiwgXCJTZXh0YVwiLCBcIlPDoWJhZG9cIl0sXG4gICAgc2hvcnREYXlzOiBbXCJEb21cIiwgXCJTZWdcIiwgXCJUZXJcIiwgXCJRdWFcIiwgXCJRdWlcIiwgXCJTZXhcIiwgXCJTw6FiXCJdLFxuICAgIG1vbnRoczogW1wiSmFuZWlyb1wiLCBcIkZldmVyZWlyb1wiLCBcIk1hcsOnb1wiLCBcIkFicmlsXCIsIFwiTWFpb1wiLCBcIkp1bmhvXCIsIFwiSnVsaG9cIiwgXCJBZ29zdG9cIiwgXCJTZXRlbWJyb1wiLCBcIk91dHVicm9cIiwgXCJOb3ZlbWJyb1wiLCBcIkRlemVtYnJvXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJKYW5cIiwgXCJGZXZcIiwgXCJNYXJcIiwgXCJBYnJcIiwgXCJNYWlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBZ29cIiwgXCJTZXRcIiwgXCJPdXRcIiwgXCJOb3ZcIiwgXCJEZXpcIl1cbiAgfTtcblxuICB2YXIgcGxQbCA9IHtcbiAgICBkYXRlVGltZTogXCIlQSwgJWUgJUIgJVksICVYXCIsXG4gICAgZGF0ZTogXCIlZC8lbS8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLCAvLyB1bnVzZWRcbiAgICBkYXlzOiBbXCJOaWVkemllbGFcIiwgXCJQb25pZWR6aWHFgmVrXCIsIFwiV3RvcmVrXCIsIFwixZpyb2RhXCIsIFwiQ3p3YXJ0ZWtcIiwgXCJQacSFdGVrXCIsIFwiU29ib3RhXCJdLFxuICAgIHNob3J0RGF5czogW1wiTmllZHouXCIsIFwiUG9uLlwiLCBcIld0LlwiLCBcIsWaci5cIiwgXCJDencuXCIsIFwiUHQuXCIsIFwiU29iLlwiXSxcbiAgICBtb250aHM6IFtcIlN0eWN6ZcWEXCIsIFwiTHV0eVwiLCBcIk1hcnplY1wiLCBcIkt3aWVjaWXFhFwiLCBcIk1halwiLCBcIkN6ZXJ3aWVjXCIsIFwiTGlwaWVjXCIsIFwiU2llcnBpZcWEXCIsIFwiV3J6ZXNpZcWEXCIsIFwiUGHFumR6aWVybmlrXCIsIFwiTGlzdG9wYWRcIiwgXCJHcnVkemllxYRcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIlN0eWN6LlwiLCBcIkx1dHlcIiwgXCJNYXJ6LlwiLCBcIkt3aWUuXCIsIFwiTWFqXCIsIFwiQ3plcncuXCIsIFwiTGlwYy5cIiwgXCJTaWVycC5cIiwgXCJXcnouXCIsIFwiUGHFumR6LlwiLCBcIkxpc3RvcC5cIiwgXCJHcnVkei5cIl0vKiBJbiBQb2xpc2ggbGFuZ3VhZ2UgYWJicmF2aWF0ZWQgbW9udGhzIGFyZSBub3QgY29tbW9ubHkgdXNlZCBzbyB0aGVyZSBpcyBhIGRpc3B1dGUgYWJvdXQgdGhlIHByb3BlciBhYmJyYXZpYXRpb25zLiAqL1xuICB9O1xuXG4gIHZhciBubE5sID0ge1xuICAgIGRhdGVUaW1lOiBcIiVhICVlICVCICVZICVUXCIsXG4gICAgZGF0ZTogXCIlZC0lbS0lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLCAvLyB1bnVzZWRcbiAgICBkYXlzOiBbXCJ6b25kYWdcIiwgXCJtYWFuZGFnXCIsIFwiZGluc2RhZ1wiLCBcIndvZW5zZGFnXCIsIFwiZG9uZGVyZGFnXCIsIFwidnJpamRhZ1wiLCBcInphdGVyZGFnXCJdLFxuICAgIHNob3J0RGF5czogW1wiem9cIiwgXCJtYVwiLCBcImRpXCIsIFwid29cIiwgXCJkb1wiLCBcInZyXCIsIFwiemFcIl0sXG4gICAgbW9udGhzOiBbXCJqYW51YXJpXCIsIFwiZmVicnVhcmlcIiwgXCJtYWFydFwiLCBcImFwcmlsXCIsIFwibWVpXCIsIFwianVuaVwiLCBcImp1bGlcIiwgXCJhdWd1c3R1c1wiLCBcInNlcHRlbWJlclwiLCBcIm9rdG9iZXJcIiwgXCJub3ZlbWJlclwiLCBcImRlY2VtYmVyXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJqYW5cIiwgXCJmZWJcIiwgXCJtcnRcIiwgXCJhcHJcIiwgXCJtZWlcIiwgXCJqdW5cIiwgXCJqdWxcIiwgXCJhdWdcIiwgXCJzZXBcIiwgXCJva3RcIiwgXCJub3ZcIiwgXCJkZWNcIl1cbiAgfTtcblxuICB2YXIgbWtNayA9IHtcbiAgICBkYXRlVGltZTogXCIlQSwgJWUgJUIgJVkg0LMuICVYXCIsXG4gICAgZGF0ZTogXCIlZC4lbS4lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcItC90LXQtNC10LvQsFwiLCBcItC/0L7QvdC10LTQtdC70L3QuNC6XCIsIFwi0LLRgtC+0YDQvdC40LpcIiwgXCLRgdGA0LXQtNCwXCIsIFwi0YfQtdGC0LLRgNGC0L7QulwiLCBcItC/0LXRgtC+0LpcIiwgXCLRgdCw0LHQvtGC0LBcIl0sXG4gICAgc2hvcnREYXlzOiBbXCLQvdC10LRcIiwgXCLQv9C+0L1cIiwgXCLQstGC0L5cIiwgXCLRgdGA0LVcIiwgXCLRh9C10YJcIiwgXCLQv9C10YJcIiwgXCLRgdCw0LFcIl0sXG4gICAgbW9udGhzOiBbXCLRmNCw0L3Rg9Cw0YDQuFwiLCBcItGE0LXQstGA0YPQsNGA0LhcIiwgXCLQvNCw0YDRglwiLCBcItCw0L/RgNC40LtcIiwgXCLQvNCw0ZhcIiwgXCLRmNGD0L3QuFwiLCBcItGY0YPQu9C4XCIsIFwi0LDQstCz0YPRgdGCXCIsIFwi0YHQtdC/0YLQtdC80LLRgNC4XCIsIFwi0L7QutGC0L7QvNCy0YDQuFwiLCBcItC90L7QtdC80LLRgNC4XCIsIFwi0LTQtdC60LXQvNCy0YDQuFwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wi0ZjQsNC9XCIsIFwi0YTQtdCyXCIsIFwi0LzQsNGAXCIsIFwi0LDQv9GAXCIsIFwi0LzQsNGYXCIsIFwi0ZjRg9C9XCIsIFwi0ZjRg9C7XCIsIFwi0LDQstCzXCIsIFwi0YHQtdC/XCIsIFwi0L7QutGCXCIsIFwi0L3QvtC1XCIsIFwi0LTQtdC6XCJdXG4gIH07XG5cbiAgdmFyIGl0SXQgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJUEgJWUgJUIgJVksICVYXCIsXG4gICAgZGF0ZTogXCIlZC8lbS8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLCAvLyB1bnVzZWRcbiAgICBkYXlzOiBbXCJEb21lbmljYVwiLCBcIkx1bmVkw6xcIiwgXCJNYXJ0ZWTDrFwiLCBcIk1lcmNvbGVkw6xcIiwgXCJHaW92ZWTDrFwiLCBcIlZlbmVyZMOsXCIsIFwiU2FiYXRvXCJdLFxuICAgIHNob3J0RGF5czogW1wiRG9tXCIsIFwiTHVuXCIsIFwiTWFyXCIsIFwiTWVyXCIsIFwiR2lvXCIsIFwiVmVuXCIsIFwiU2FiXCJdLFxuICAgIG1vbnRoczogW1wiR2VubmFpb1wiLCBcIkZlYmJyYWlvXCIsIFwiTWFyem9cIiwgXCJBcHJpbGVcIiwgXCJNYWdnaW9cIiwgXCJHaXVnbm9cIiwgXCJMdWdsaW9cIiwgXCJBZ29zdG9cIiwgXCJTZXR0ZW1icmVcIiwgXCJPdHRvYnJlXCIsIFwiTm92ZW1icmVcIiwgXCJEaWNlbWJyZVwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiR2VuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWFnXCIsIFwiR2l1XCIsIFwiTHVnXCIsIFwiQWdvXCIsIFwiU2V0XCIsIFwiT3R0XCIsIFwiTm92XCIsIFwiRGljXCJdXG4gIH07XG5cbiAgdmFyIGhlSWwgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJUEsICVlINeRJUIgJVkgJVhcIixcbiAgICBkYXRlOiBcIiVkLiVtLiVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgZGF5czogW1wi16jXkNep15XXn1wiLCBcItep16DXmVwiLCBcItep15zXmdep15lcIiwgXCLXqNeR15nXoteZXCIsIFwi15fXnteZ16nXmVwiLCBcItep15nXqdeZXCIsIFwi16nXkdeqXCJdLFxuICAgIHNob3J0RGF5czogW1wi15DXs1wiLCBcIteR17NcIiwgXCLXktezXCIsIFwi15PXs1wiLCBcIteU17NcIiwgXCLXldezXCIsIFwi16nXs1wiXSxcbiAgICBtb250aHM6IFtcIteZ16DXldeQ16hcIiwgXCLXpNeR16jXldeQ16hcIiwgXCLXnteo16VcIiwgXCLXkNek16jXmdecXCIsIFwi157XkNeZXCIsIFwi15nXldeg15lcIiwgXCLXmdeV15zXmVwiLCBcIteQ15XXkteV16HXmFwiLCBcIteh16TXmNee15HXqFwiLCBcIteQ15XXp9eY15XXkdeoXCIsIFwi16DXldeR157XkdeoXCIsIFwi15PXptee15HXqFwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wi15nXoNeV17NcIiwgXCLXpNeR16jXs1wiLCBcItee16jXpVwiLCBcIteQ16TXqNezXCIsIFwi157XkNeZXCIsIFwi15nXldeg15lcIiwgXCLXmdeV15zXmVwiLCBcIteQ15XXktezXCIsIFwi16HXpNeY17NcIiwgXCLXkNeV16fXs1wiLCBcIteg15XXkdezXCIsIFwi15PXptee17NcIl1cbiAgfTtcblxuICB2YXIgZnJGciA9IHtcbiAgICBkYXRlVGltZTogXCIlQSwgbGUgJWUgJUIgJVksICVYXCIsXG4gICAgZGF0ZTogXCIlZC8lbS8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLCAvLyB1bnVzZWRcbiAgICBkYXlzOiBbXCJkaW1hbmNoZVwiLCBcImx1bmRpXCIsIFwibWFyZGlcIiwgXCJtZXJjcmVkaVwiLCBcImpldWRpXCIsIFwidmVuZHJlZGlcIiwgXCJzYW1lZGlcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJkaW0uXCIsIFwibHVuLlwiLCBcIm1hci5cIiwgXCJtZXIuXCIsIFwiamV1LlwiLCBcInZlbi5cIiwgXCJzYW0uXCJdLFxuICAgIG1vbnRoczogW1wiamFudmllclwiLCBcImbDqXZyaWVyXCIsIFwibWFyc1wiLCBcImF2cmlsXCIsIFwibWFpXCIsIFwianVpblwiLCBcImp1aWxsZXRcIiwgXCJhb8O7dFwiLCBcInNlcHRlbWJyZVwiLCBcIm9jdG9icmVcIiwgXCJub3ZlbWJyZVwiLCBcImTDqWNlbWJyZVwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiamFudi5cIiwgXCJmw6l2ci5cIiwgXCJtYXJzXCIsIFwiYXZyLlwiLCBcIm1haVwiLCBcImp1aW5cIiwgXCJqdWlsLlwiLCBcImFvw7t0XCIsIFwic2VwdC5cIiwgXCJvY3QuXCIsIFwibm92LlwiLCBcImTDqWMuXCJdXG4gIH07XG5cbiAgdmFyIGZyQ2EgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJWEgJWUgJWIgJVkgJVhcIixcbiAgICBkYXRlOiBcIiVZLSVtLSVkXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIlwiLCBcIlwiXSxcbiAgICBkYXlzOiBbXCJkaW1hbmNoZVwiLCBcImx1bmRpXCIsIFwibWFyZGlcIiwgXCJtZXJjcmVkaVwiLCBcImpldWRpXCIsIFwidmVuZHJlZGlcIiwgXCJzYW1lZGlcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJkaW1cIiwgXCJsdW5cIiwgXCJtYXJcIiwgXCJtZXJcIiwgXCJqZXVcIiwgXCJ2ZW5cIiwgXCJzYW1cIl0sXG4gICAgbW9udGhzOiBbXCJqYW52aWVyXCIsIFwiZsOpdnJpZXJcIiwgXCJtYXJzXCIsIFwiYXZyaWxcIiwgXCJtYWlcIiwgXCJqdWluXCIsIFwianVpbGxldFwiLCBcImFvw7t0XCIsIFwic2VwdGVtYnJlXCIsIFwib2N0b2JyZVwiLCBcIm5vdmVtYnJlXCIsIFwiZMOpY2VtYnJlXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJqYW5cIiwgXCJmw6l2XCIsIFwibWFyXCIsIFwiYXZyXCIsIFwibWFpXCIsIFwianVpXCIsIFwianVsXCIsIFwiYW/Du1wiLCBcInNlcFwiLCBcIm9jdFwiLCBcIm5vdlwiLCBcImTDqWNcIl1cbiAgfTtcblxuICB2YXIgZmlGaSA9IHtcbiAgICBkYXRlVGltZTogXCIlQSwgJS1kLiAlQnRhICVZIGtsbyAlWFwiLFxuICAgIGRhdGU6IFwiJS1kLiUtbS4lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJhLm0uXCIsIFwicC5tLlwiXSxcbiAgICBkYXlzOiBbXCJzdW5udW50YWlcIiwgXCJtYWFuYW50YWlcIiwgXCJ0aWlzdGFpXCIsIFwia2Vza2l2aWlra29cIiwgXCJ0b3JzdGFpXCIsIFwicGVyamFudGFpXCIsIFwibGF1YW50YWlcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJTdVwiLCBcIk1hXCIsIFwiVGlcIiwgXCJLZVwiLCBcIlRvXCIsIFwiUGVcIiwgXCJMYVwiXSxcbiAgICBtb250aHM6IFtcInRhbW1pa3V1XCIsIFwiaGVsbWlrdXVcIiwgXCJtYWFsaXNrdXVcIiwgXCJodWh0aWt1dVwiLCBcInRvdWtva3V1XCIsIFwia2Vzw6RrdXVcIiwgXCJoZWluw6RrdXVcIiwgXCJlbG9rdXVcIiwgXCJzeXlza3V1XCIsIFwibG9rYWt1dVwiLCBcIm1hcnJhc2t1dVwiLCBcImpvdWx1a3V1XCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJUYW1taVwiLCBcIkhlbG1pXCIsIFwiTWFhbGlzXCIsIFwiSHVodGlcIiwgXCJUb3Vrb1wiLCBcIktlc8OkXCIsIFwiSGVpbsOkXCIsIFwiRWxvXCIsIFwiU3l5c1wiLCBcIkxva2FcIiwgXCJNYXJyYXNcIiwgXCJKb3VsdVwiXVxuICB9O1xuXG4gIHZhciBlc0VzID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBLCAlZSBkZSAlQiBkZSAlWSwgJVhcIixcbiAgICBkYXRlOiBcIiVkLyVtLyVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgZGF5czogW1wiZG9taW5nb1wiLCBcImx1bmVzXCIsIFwibWFydGVzXCIsIFwibWnDqXJjb2xlc1wiLCBcImp1ZXZlc1wiLCBcInZpZXJuZXNcIiwgXCJzw6FiYWRvXCJdLFxuICAgIHNob3J0RGF5czogW1wiZG9tXCIsIFwibHVuXCIsIFwibWFyXCIsIFwibWnDqVwiLCBcImp1ZVwiLCBcInZpZVwiLCBcInPDoWJcIl0sXG4gICAgbW9udGhzOiBbXCJlbmVyb1wiLCBcImZlYnJlcm9cIiwgXCJtYXJ6b1wiLCBcImFicmlsXCIsIFwibWF5b1wiLCBcImp1bmlvXCIsIFwianVsaW9cIiwgXCJhZ29zdG9cIiwgXCJzZXB0aWVtYnJlXCIsIFwib2N0dWJyZVwiLCBcIm5vdmllbWJyZVwiLCBcImRpY2llbWJyZVwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiZW5lXCIsIFwiZmViXCIsIFwibWFyXCIsIFwiYWJyXCIsIFwibWF5XCIsIFwianVuXCIsIFwianVsXCIsIFwiYWdvXCIsIFwic2VwXCIsIFwib2N0XCIsIFwibm92XCIsIFwiZGljXCJdXG4gIH07XG5cbiAgdmFyIGVuVXMgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJWEgJWIgJWUgJVggJVlcIixcbiAgICBkYXRlOiBcIiVtLyVkLyVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgZGF5czogW1wiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gICAgbW9udGhzOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdXG4gIH07XG5cbiAgdmFyIGVuR2IgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJWEgJWUgJWIgJVggJVlcIixcbiAgICBkYXRlOiBcIiVkLyVtLyVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgZGF5czogW1wiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gICAgbW9udGhzOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdXG4gIH07XG5cbiAgdmFyIGVuQ2EgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJWEgJWIgJWUgJVggJVlcIixcbiAgICBkYXRlOiBcIiVZLSVtLSVkXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgZGF5czogW1wiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gICAgbW9udGhzOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdXG4gIH07XG5cbiAgdmFyIGRlRGUgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJUEsIGRlciAlZS4gJUIgJVksICVYXCIsXG4gICAgZGF0ZTogXCIlZC4lbS4lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLCAvLyB1bnVzZWRcbiAgICBkYXlzOiBbXCJTb25udGFnXCIsIFwiTW9udGFnXCIsIFwiRGllbnN0YWdcIiwgXCJNaXR0d29jaFwiLCBcIkRvbm5lcnN0YWdcIiwgXCJGcmVpdGFnXCIsIFwiU2Ftc3RhZ1wiXSxcbiAgICBzaG9ydERheXM6IFtcIlNvXCIsIFwiTW9cIiwgXCJEaVwiLCBcIk1pXCIsIFwiRG9cIiwgXCJGclwiLCBcIlNhXCJdLFxuICAgIG1vbnRoczogW1wiSmFudWFyXCIsIFwiRmVicnVhclwiLCBcIk3DpHJ6XCIsIFwiQXByaWxcIiwgXCJNYWlcIiwgXCJKdW5pXCIsIFwiSnVsaVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9rdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlemVtYmVyXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNcnpcIiwgXCJBcHJcIiwgXCJNYWlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPa3RcIiwgXCJOb3ZcIiwgXCJEZXpcIl1cbiAgfTtcblxuICB2YXIgY2FFcyA9IHtcbiAgICBkYXRlVGltZTogXCIlQSwgJWUgZGUgJUIgZGUgJVksICVYXCIsXG4gICAgZGF0ZTogXCIlZC8lbS8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcImRpdW1lbmdlXCIsIFwiZGlsbHVuc1wiLCBcImRpbWFydHNcIiwgXCJkaW1lY3Jlc1wiLCBcImRpam91c1wiLCBcImRpdmVuZHJlc1wiLCBcImRpc3NhYnRlXCJdLFxuICAgIHNob3J0RGF5czogW1wiZGcuXCIsIFwiZGwuXCIsIFwiZHQuXCIsIFwiZGMuXCIsIFwiZGouXCIsIFwiZHYuXCIsIFwiZHMuXCJdLFxuICAgIG1vbnRoczogW1wiZ2VuZXJcIiwgXCJmZWJyZXJcIiwgXCJtYXLDp1wiLCBcImFicmlsXCIsIFwibWFpZ1wiLCBcImp1bnlcIiwgXCJqdWxpb2xcIiwgXCJhZ29zdFwiLCBcInNldGVtYnJlXCIsIFwib2N0dWJyZVwiLCBcIm5vdmVtYnJlXCIsIFwiZGVzZW1icmVcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcImdlbi5cIiwgXCJmZWJyLlwiLCBcIm1hcsOnXCIsIFwiYWJyLlwiLCBcIm1haWdcIiwgXCJqdW55XCIsIFwianVsLlwiLCBcImFnLlwiLCBcInNldC5cIiwgXCJvY3QuXCIsIFwibm92LlwiLCBcImRlcy5cIl1cbiAgfTtcblxuICB2YXIgdDAgPSBuZXcgRGF0ZTtcbiAgdmFyIHQxID0gbmV3IERhdGU7XG5cbiAgZnVuY3Rpb24gbmV3SW50ZXJ2YWwoZmxvb3JpLCBvZmZzZXRpLCBjb3VudCkge1xuXG4gICAgZnVuY3Rpb24gaW50ZXJ2YWwoZGF0ZSkge1xuICAgICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoK2RhdGUpKSwgZGF0ZTtcbiAgICB9XG5cbiAgICBpbnRlcnZhbC5mbG9vciA9IGludGVydmFsO1xuXG4gICAgaW50ZXJ2YWwucm91bmQgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgICB2YXIgZDAgPSBuZXcgRGF0ZSgrZGF0ZSksXG4gICAgICAgICAgZDEgPSBuZXcgRGF0ZShkYXRlIC0gMSk7XG4gICAgICBmbG9vcmkoZDApLCBmbG9vcmkoZDEpLCBvZmZzZXRpKGQxLCAxKTtcbiAgICAgIHJldHVybiBkYXRlIC0gZDAgPCBkMSAtIGRhdGUgPyBkMCA6IGQxO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5jZWlsID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoZGF0ZSAtIDEpKSwgb2Zmc2V0aShkYXRlLCAxKSwgZGF0ZTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwub2Zmc2V0ID0gZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgICAgcmV0dXJuIG9mZnNldGkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSwgc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCkpLCBkYXRlO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBbXTtcbiAgICAgIHN0YXJ0ID0gbmV3IERhdGUoc3RhcnQgLSAxKTtcbiAgICAgIHN0b3AgPSBuZXcgRGF0ZSgrc3RvcCk7XG4gICAgICBzdGVwID0gc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCk7XG4gICAgICBpZiAoIShzdGFydCA8IHN0b3ApIHx8ICEoc3RlcCA+IDApKSByZXR1cm4gcmFuZ2U7IC8vIGFsc28gaGFuZGxlcyBJbnZhbGlkIERhdGVcbiAgICAgIG9mZnNldGkoc3RhcnQsIDEpLCBmbG9vcmkoc3RhcnQpO1xuICAgICAgaWYgKHN0YXJ0IDwgc3RvcCkgcmFuZ2UucHVzaChuZXcgRGF0ZSgrc3RhcnQpKTtcbiAgICAgIHdoaWxlIChvZmZzZXRpKHN0YXJ0LCBzdGVwKSwgZmxvb3JpKHN0YXJ0KSwgc3RhcnQgPCBzdG9wKSByYW5nZS5wdXNoKG5ldyBEYXRlKCtzdGFydCkpO1xuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5maWx0ZXIgPSBmdW5jdGlvbih0ZXN0KSB7XG4gICAgICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICB3aGlsZSAoZmxvb3JpKGRhdGUpLCAhdGVzdChkYXRlKSkgZGF0ZS5zZXRUaW1lKGRhdGUgLSAxKTtcbiAgICAgIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgICAgd2hpbGUgKC0tc3RlcCA+PSAwKSB3aGlsZSAob2Zmc2V0aShkYXRlLCAxKSwgIXRlc3QoZGF0ZSkpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmIChjb3VudCkgaW50ZXJ2YWwuY291bnQgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICB0MC5zZXRUaW1lKCtzdGFydCksIHQxLnNldFRpbWUoK2VuZCk7XG4gICAgICBmbG9vcmkodDApLCBmbG9vcmkodDEpO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoY291bnQodDAsIHQxKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBpbnRlcnZhbDtcbiAgfVxuXG4gIHZhciBkYXkgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCAtIChlbmQuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogNmU0KSAvIDg2NGU1O1xuICB9KTtcblxuICBmdW5jdGlvbiB3ZWVrZGF5KGkpIHtcbiAgICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIChkYXRlLmdldERheSgpICsgNyAtIGkpICUgNyk7XG4gICAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RlcCAqIDcpO1xuICAgIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIDZlNCkgLyA2MDQ4ZTU7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgc3VuZGF5ID0gd2Vla2RheSgwKTtcbiAgdmFyIG1vbmRheSA9IHdlZWtkYXkoMSk7XG5cbiAgdmFyIHllYXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICBkYXRlLnNldE1vbnRoKDAsIDEpO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBlbmQuZ2V0RnVsbFllYXIoKSAtIHN0YXJ0LmdldEZ1bGxZZWFyKCk7XG4gIH0pO1xuXG4gIHZhciB1dGNEYXkgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyA4NjRlNTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gdXRjV2Vla2RheShpKSB7XG4gICAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSAoZGF0ZS5nZXRVVENEYXkoKSArIDcgLSBpKSAlIDcpO1xuICAgIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIHN0ZXAgKiA3KTtcbiAgICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIDYwNDhlNTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciB1dGNTdW5kYXkgPSB1dGNXZWVrZGF5KDApO1xuICB2YXIgdXRjTW9uZGF5ID0gdXRjV2Vla2RheSgxKTtcblxuICB2YXIgdXRjWWVhciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgIGRhdGUuc2V0VVRDTW9udGgoMCwgMSk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGVuZC5nZXRVVENGdWxsWWVhcigpIC0gc3RhcnQuZ2V0VVRDRnVsbFllYXIoKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gbG9jYWxEYXRlKGQpIHtcbiAgICBpZiAoMCA8PSBkLnkgJiYgZC55IDwgMTAwKSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKC0xLCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKTtcbiAgICAgIGRhdGUuc2V0RnVsbFllYXIoZC55KTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoZC55LCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHV0Y0RhdGUoZCkge1xuICAgIGlmICgwIDw9IGQueSAmJiBkLnkgPCAxMDApIHtcbiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoLTEsIGQubSwgZC5kLCBkLkgsIGQuTSwgZC5TLCBkLkwpKTtcbiAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZC55KTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoZC55LCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKSk7XG4gIH1cblxuICBmdW5jdGlvbiBuZXdZZWFyKHkpIHtcbiAgICByZXR1cm4ge3k6IHksIG06IDAsIGQ6IDEsIEg6IDAsIE06IDAsIFM6IDAsIEw6IDB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbG9jYWxlKGxvY2FsZSkge1xuICAgIHZhciBsb2NhbGVfZGF0ZVRpbWUgPSBsb2NhbGUuZGF0ZVRpbWUsXG4gICAgICAgIGxvY2FsZV9kYXRlID0gbG9jYWxlLmRhdGUsXG4gICAgICAgIGxvY2FsZV90aW1lID0gbG9jYWxlLnRpbWUsXG4gICAgICAgIGxvY2FsZV9wZXJpb2RzID0gbG9jYWxlLnBlcmlvZHMsXG4gICAgICAgIGxvY2FsZV93ZWVrZGF5cyA9IGxvY2FsZS5kYXlzLFxuICAgICAgICBsb2NhbGVfc2hvcnRXZWVrZGF5cyA9IGxvY2FsZS5zaG9ydERheXMsXG4gICAgICAgIGxvY2FsZV9tb250aHMgPSBsb2NhbGUubW9udGhzLFxuICAgICAgICBsb2NhbGVfc2hvcnRNb250aHMgPSBsb2NhbGUuc2hvcnRNb250aHM7XG5cbiAgICB2YXIgcGVyaW9kTG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9wZXJpb2RzKSxcbiAgICAgICAgd2Vla2RheVJlID0gZm9ybWF0UmUobG9jYWxlX3dlZWtkYXlzKSxcbiAgICAgICAgd2Vla2RheUxvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfd2Vla2RheXMpLFxuICAgICAgICBzaG9ydFdlZWtkYXlSZSA9IGZvcm1hdFJlKGxvY2FsZV9zaG9ydFdlZWtkYXlzKSxcbiAgICAgICAgc2hvcnRXZWVrZGF5TG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9zaG9ydFdlZWtkYXlzKSxcbiAgICAgICAgbW9udGhSZSA9IGZvcm1hdFJlKGxvY2FsZV9tb250aHMpLFxuICAgICAgICBtb250aExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfbW9udGhzKSxcbiAgICAgICAgc2hvcnRNb250aFJlID0gZm9ybWF0UmUobG9jYWxlX3Nob3J0TW9udGhzKSxcbiAgICAgICAgc2hvcnRNb250aExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfc2hvcnRNb250aHMpO1xuXG4gICAgdmFyIGZvcm1hdHMgPSB7XG4gICAgICBcImFcIjogZm9ybWF0U2hvcnRXZWVrZGF5LFxuICAgICAgXCJBXCI6IGZvcm1hdFdlZWtkYXksXG4gICAgICBcImJcIjogZm9ybWF0U2hvcnRNb250aCxcbiAgICAgIFwiQlwiOiBmb3JtYXRNb250aCxcbiAgICAgIFwiY1wiOiBudWxsLFxuICAgICAgXCJkXCI6IGZvcm1hdERheU9mTW9udGgsXG4gICAgICBcImVcIjogZm9ybWF0RGF5T2ZNb250aCxcbiAgICAgIFwiSFwiOiBmb3JtYXRIb3VyMjQsXG4gICAgICBcIklcIjogZm9ybWF0SG91cjEyLFxuICAgICAgXCJqXCI6IGZvcm1hdERheU9mWWVhcixcbiAgICAgIFwiTFwiOiBmb3JtYXRNaWxsaXNlY29uZHMsXG4gICAgICBcIm1cIjogZm9ybWF0TW9udGhOdW1iZXIsXG4gICAgICBcIk1cIjogZm9ybWF0TWludXRlcyxcbiAgICAgIFwicFwiOiBmb3JtYXRQZXJpb2QsXG4gICAgICBcIlNcIjogZm9ybWF0U2Vjb25kcyxcbiAgICAgIFwiVVwiOiBmb3JtYXRXZWVrTnVtYmVyU3VuZGF5LFxuICAgICAgXCJ3XCI6IGZvcm1hdFdlZWtkYXlOdW1iZXIsXG4gICAgICBcIldcIjogZm9ybWF0V2Vla051bWJlck1vbmRheSxcbiAgICAgIFwieFwiOiBudWxsLFxuICAgICAgXCJYXCI6IG51bGwsXG4gICAgICBcInlcIjogZm9ybWF0WWVhcixcbiAgICAgIFwiWVwiOiBmb3JtYXRGdWxsWWVhcixcbiAgICAgIFwiWlwiOiBmb3JtYXRab25lLFxuICAgICAgXCIlXCI6IGZvcm1hdExpdGVyYWxQZXJjZW50XG4gICAgfTtcblxuICAgIHZhciB1dGNGb3JtYXRzID0ge1xuICAgICAgXCJhXCI6IGZvcm1hdFVUQ1Nob3J0V2Vla2RheSxcbiAgICAgIFwiQVwiOiBmb3JtYXRVVENXZWVrZGF5LFxuICAgICAgXCJiXCI6IGZvcm1hdFVUQ1Nob3J0TW9udGgsXG4gICAgICBcIkJcIjogZm9ybWF0VVRDTW9udGgsXG4gICAgICBcImNcIjogbnVsbCxcbiAgICAgIFwiZFwiOiBmb3JtYXRVVENEYXlPZk1vbnRoLFxuICAgICAgXCJlXCI6IGZvcm1hdFVUQ0RheU9mTW9udGgsXG4gICAgICBcIkhcIjogZm9ybWF0VVRDSG91cjI0LFxuICAgICAgXCJJXCI6IGZvcm1hdFVUQ0hvdXIxMixcbiAgICAgIFwialwiOiBmb3JtYXRVVENEYXlPZlllYXIsXG4gICAgICBcIkxcIjogZm9ybWF0VVRDTWlsbGlzZWNvbmRzLFxuICAgICAgXCJtXCI6IGZvcm1hdFVUQ01vbnRoTnVtYmVyLFxuICAgICAgXCJNXCI6IGZvcm1hdFVUQ01pbnV0ZXMsXG4gICAgICBcInBcIjogZm9ybWF0VVRDUGVyaW9kLFxuICAgICAgXCJTXCI6IGZvcm1hdFVUQ1NlY29uZHMsXG4gICAgICBcIlVcIjogZm9ybWF0VVRDV2Vla051bWJlclN1bmRheSxcbiAgICAgIFwid1wiOiBmb3JtYXRVVENXZWVrZGF5TnVtYmVyLFxuICAgICAgXCJXXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJNb25kYXksXG4gICAgICBcInhcIjogbnVsbCxcbiAgICAgIFwiWFwiOiBudWxsLFxuICAgICAgXCJ5XCI6IGZvcm1hdFVUQ1llYXIsXG4gICAgICBcIllcIjogZm9ybWF0VVRDRnVsbFllYXIsXG4gICAgICBcIlpcIjogZm9ybWF0VVRDWm9uZSxcbiAgICAgIFwiJVwiOiBmb3JtYXRMaXRlcmFsUGVyY2VudFxuICAgIH07XG5cbiAgICB2YXIgcGFyc2VzID0ge1xuICAgICAgXCJhXCI6IHBhcnNlU2hvcnRXZWVrZGF5LFxuICAgICAgXCJBXCI6IHBhcnNlV2Vla2RheSxcbiAgICAgIFwiYlwiOiBwYXJzZVNob3J0TW9udGgsXG4gICAgICBcIkJcIjogcGFyc2VNb250aCxcbiAgICAgIFwiY1wiOiBwYXJzZUxvY2FsZURhdGVUaW1lLFxuICAgICAgXCJkXCI6IHBhcnNlRGF5T2ZNb250aCxcbiAgICAgIFwiZVwiOiBwYXJzZURheU9mTW9udGgsXG4gICAgICBcIkhcIjogcGFyc2VIb3VyMjQsXG4gICAgICBcIklcIjogcGFyc2VIb3VyMjQsXG4gICAgICBcImpcIjogcGFyc2VEYXlPZlllYXIsXG4gICAgICBcIkxcIjogcGFyc2VNaWxsaXNlY29uZHMsXG4gICAgICBcIm1cIjogcGFyc2VNb250aE51bWJlcixcbiAgICAgIFwiTVwiOiBwYXJzZU1pbnV0ZXMsXG4gICAgICBcInBcIjogcGFyc2VQZXJpb2QsXG4gICAgICBcIlNcIjogcGFyc2VTZWNvbmRzLFxuICAgICAgXCJVXCI6IHBhcnNlV2Vla051bWJlclN1bmRheSxcbiAgICAgIFwid1wiOiBwYXJzZVdlZWtkYXlOdW1iZXIsXG4gICAgICBcIldcIjogcGFyc2VXZWVrTnVtYmVyTW9uZGF5LFxuICAgICAgXCJ4XCI6IHBhcnNlTG9jYWxlRGF0ZSxcbiAgICAgIFwiWFwiOiBwYXJzZUxvY2FsZVRpbWUsXG4gICAgICBcInlcIjogcGFyc2VZZWFyLFxuICAgICAgXCJZXCI6IHBhcnNlRnVsbFllYXIsXG4gICAgICBcIlpcIjogcGFyc2Vab25lLFxuICAgICAgXCIlXCI6IHBhcnNlTGl0ZXJhbFBlcmNlbnRcbiAgICB9O1xuXG4gICAgLy8gVGhlc2UgcmVjdXJzaXZlIGRpcmVjdGl2ZSBkZWZpbml0aW9ucyBtdXN0IGJlIGRlZmVycmVkLlxuICAgIGZvcm1hdHMueCA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZSwgZm9ybWF0cyk7XG4gICAgZm9ybWF0cy5YID0gbmV3Rm9ybWF0KGxvY2FsZV90aW1lLCBmb3JtYXRzKTtcbiAgICBmb3JtYXRzLmMgPSBuZXdGb3JtYXQobG9jYWxlX2RhdGVUaW1lLCBmb3JtYXRzKTtcbiAgICB1dGNGb3JtYXRzLnggPSBuZXdGb3JtYXQobG9jYWxlX2RhdGUsIHV0Y0Zvcm1hdHMpO1xuICAgIHV0Y0Zvcm1hdHMuWCA9IG5ld0Zvcm1hdChsb2NhbGVfdGltZSwgdXRjRm9ybWF0cyk7XG4gICAgdXRjRm9ybWF0cy5jID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlVGltZSwgdXRjRm9ybWF0cyk7XG5cbiAgICBmdW5jdGlvbiBuZXdGb3JtYXQoc3BlY2lmaWVyLCBmb3JtYXRzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICB2YXIgc3RyaW5nID0gW10sXG4gICAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgICBqID0gMCxcbiAgICAgICAgICAgIG4gPSBzcGVjaWZpZXIubGVuZ3RoLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIHBhZCxcbiAgICAgICAgICAgIGZvcm1hdDtcblxuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIGlmIChzcGVjaWZpZXIuY2hhckNvZGVBdChpKSA9PT0gMzcpIHtcbiAgICAgICAgICAgIHN0cmluZy5wdXNoKHNwZWNpZmllci5zbGljZShqLCBpKSk7XG4gICAgICAgICAgICBpZiAoKHBhZCA9IHBhZHNbYyA9IHNwZWNpZmllci5jaGFyQXQoKytpKV0pICE9IG51bGwpIGMgPSBzcGVjaWZpZXIuY2hhckF0KCsraSk7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID0gZm9ybWF0c1tjXSkgYyA9IGZvcm1hdChkYXRlLCBwYWQgPT0gbnVsbCA/IChjID09PSBcImVcIiA/IFwiIFwiIDogXCIwXCIpIDogcGFkKTtcbiAgICAgICAgICAgIHN0cmluZy5wdXNoKGMpO1xuICAgICAgICAgICAgaiA9IGkgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmluZy5wdXNoKHNwZWNpZmllci5zbGljZShqLCBpKSk7XG4gICAgICAgIHJldHVybiBzdHJpbmcuam9pbihcIlwiKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmV3UGFyc2Uoc3BlY2lmaWVyLCBuZXdEYXRlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHZhciBkID0gbmV3WWVhcigxOTAwKSxcbiAgICAgICAgICAgIGkgPSBwYXJzZVNwZWNpZmllcihkLCBzcGVjaWZpZXIsIHN0cmluZywgMCk7XG4gICAgICAgIGlmIChpICE9IHN0cmluZy5sZW5ndGgpIHJldHVybiBudWxsO1xuXG4gICAgICAgIC8vIFRoZSBhbS1wbSBmbGFnIGlzIDAgZm9yIEFNLCBhbmQgMSBmb3IgUE0uXG4gICAgICAgIGlmIChcInBcIiBpbiBkKSBkLkggPSBkLkggJSAxMiArIGQucCAqIDEyO1xuXG4gICAgICAgIC8vIElmIGEgdGltZSB6b25lIGlzIHNwZWNpZmllZCwgYWxsIGZpZWxkcyBhcmUgaW50ZXJwcmV0ZWQgYXMgVVRDIGFuZCB0aGVuXG4gICAgICAgIC8vIG9mZnNldCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCB0aW1lIHpvbmUuXG4gICAgICAgIGlmIChcIlpcIiBpbiBkKSB7XG4gICAgICAgICAgaWYgKFwid1wiIGluIGQgJiYgKFwiV1wiIGluIGQgfHwgXCJVXCIgaW4gZCkpIHtcbiAgICAgICAgICAgIHZhciBkYXkgPSB1dGNEYXRlKG5ld1llYXIoZC55KSkuZ2V0VVRDRGF5KCk7XG4gICAgICAgICAgICBpZiAoXCJXXCIgaW4gZCkgZC5VID0gZC5XLCBkLncgPSAoZC53ICsgNikgJSA3LCAtLWRheTtcbiAgICAgICAgICAgIGQubSA9IDA7XG4gICAgICAgICAgICBkLmQgPSBkLncgKyBkLlUgKiA3IC0gKGRheSArIDYpICUgNztcbiAgICAgICAgICB9XG4gICAgICAgICAgZC5IICs9IGQuWiAvIDEwMCB8IDA7XG4gICAgICAgICAgZC5NICs9IGQuWiAlIDEwMDtcbiAgICAgICAgICByZXR1cm4gdXRjRGF0ZShkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgYWxsIGZpZWxkcyBhcmUgaW4gbG9jYWwgdGltZS5cbiAgICAgICAgaWYgKFwid1wiIGluIGQgJiYgKFwiV1wiIGluIGQgfHwgXCJVXCIgaW4gZCkpIHtcbiAgICAgICAgICB2YXIgZGF5ID0gbmV3RGF0ZShuZXdZZWFyKGQueSkpLmdldERheSgpO1xuICAgICAgICAgIGlmIChcIldcIiBpbiBkKSBkLlUgPSBkLlcsIGQudyA9IChkLncgKyA2KSAlIDcsIC0tZGF5O1xuICAgICAgICAgIGQubSA9IDA7XG4gICAgICAgICAgZC5kID0gZC53ICsgZC5VICogNyAtIChkYXkgKyA2KSAlIDc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RhdGUoZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU3BlY2lmaWVyKGQsIHNwZWNpZmllciwgc3RyaW5nLCBqKSB7XG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgbiA9IHNwZWNpZmllci5sZW5ndGgsXG4gICAgICAgICAgbSA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBwYXJzZTtcblxuICAgICAgd2hpbGUgKGkgPCBuKSB7XG4gICAgICAgIGlmIChqID49IG0pIHJldHVybiAtMTtcbiAgICAgICAgYyA9IHNwZWNpZmllci5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIGlmIChjID09PSAzNykge1xuICAgICAgICAgIGMgPSBzcGVjaWZpZXIuY2hhckF0KGkrKyk7XG4gICAgICAgICAgcGFyc2UgPSBwYXJzZXNbYyBpbiBwYWRzID8gc3BlY2lmaWVyLmNoYXJBdChpKyspIDogY107XG4gICAgICAgICAgaWYgKCFwYXJzZSB8fCAoKGogPSBwYXJzZShkLCBzdHJpbmcsIGopKSA8IDApKSByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoYyAhPSBzdHJpbmcuY2hhckNvZGVBdChqKyspKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBqO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU2hvcnRXZWVrZGF5KGQsIHN0cmluZywgaSkge1xuICAgICAgdmFyIG4gPSBzaG9ydFdlZWtkYXlSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgICByZXR1cm4gbiA/IChkLncgPSBzaG9ydFdlZWtkYXlMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoZCwgc3RyaW5nLCBpKSB7XG4gICAgICB2YXIgbiA9IHdlZWtkYXlSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgICByZXR1cm4gbiA/IChkLncgPSB3ZWVrZGF5TG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTaG9ydE1vbnRoKGQsIHN0cmluZywgaSkge1xuICAgICAgdmFyIG4gPSBzaG9ydE1vbnRoUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZC5tID0gc2hvcnRNb250aExvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gICAgICB2YXIgbiA9IG1vbnRoUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZC5tID0gbW9udGhMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUxvY2FsZURhdGVUaW1lKGQsIHN0cmluZywgaSkge1xuICAgICAgcmV0dXJuIHBhcnNlU3BlY2lmaWVyKGQsIGxvY2FsZV9kYXRlVGltZSwgc3RyaW5nLCBpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUxvY2FsZURhdGUoZCwgc3RyaW5nLCBpKSB7XG4gICAgICByZXR1cm4gcGFyc2VTcGVjaWZpZXIoZCwgbG9jYWxlX2RhdGUsIHN0cmluZywgaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VMb2NhbGVUaW1lKGQsIHN0cmluZywgaSkge1xuICAgICAgcmV0dXJuIHBhcnNlU3BlY2lmaWVyKGQsIGxvY2FsZV90aW1lLCBzdHJpbmcsIGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUGVyaW9kKGQsIHN0cmluZywgaSkge1xuICAgICAgdmFyIG4gPSBwZXJpb2RMb29rdXAuZ2V0KHN0cmluZy5zbGljZShpLCBpICs9IDIpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgcmV0dXJuIG4gPT0gbnVsbCA/IC0xIDogKGQucCA9IG4sIGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFNob3J0V2Vla2RheShkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3Nob3J0V2Vla2RheXNbZC5nZXREYXkoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0V2Vla2RheShkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3dlZWtkYXlzW2QuZ2V0RGF5KCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFNob3J0TW9udGgoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV9zaG9ydE1vbnRoc1tkLmdldE1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdE1vbnRoKGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfbW9udGhzW2QuZ2V0TW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0UGVyaW9kKGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfcGVyaW9kc1srKGQuZ2V0SG91cnMoKSA+PSAxMildO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFVUQ1Nob3J0V2Vla2RheShkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3Nob3J0V2Vla2RheXNbZC5nZXRVVENEYXkoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0VVRDV2Vla2RheShkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3dlZWtkYXlzW2QuZ2V0VVRDRGF5KCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFVUQ1Nob3J0TW9udGgoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV9zaG9ydE1vbnRoc1tkLmdldFVUQ01vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFVUQ01vbnRoKGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfbW9udGhzW2QuZ2V0VVRDTW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0VVRDUGVyaW9kKGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfcGVyaW9kc1srKGQuZ2V0VVRDSG91cnMoKSA+PSAxMildO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgICB2YXIgZiA9IG5ld0Zvcm1hdChzcGVjaWZpZXIgKz0gXCJcIiwgZm9ybWF0cyk7XG4gICAgICAgIGYucGFyc2UgPSBuZXdQYXJzZShzcGVjaWZpZXIsIGxvY2FsRGF0ZSk7XG4gICAgICAgIGYudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9LFxuICAgICAgdXRjRm9ybWF0OiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgICAgdmFyIGYgPSBuZXdGb3JtYXQoc3BlY2lmaWVyICs9IFwiXCIsIHV0Y0Zvcm1hdHMpO1xuICAgICAgICBmLnBhcnNlID0gbmV3UGFyc2Uoc3BlY2lmaWVyLCB1dGNEYXRlKTtcbiAgICAgICAgZi50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIHBhZHMgPSB7XCItXCI6IFwiXCIsIFwiX1wiOiBcIiBcIiwgXCIwXCI6IFwiMFwifTtcbiAgdmFyIG51bWJlclJlID0gL15cXHMqXFxkKy87XG4gIHZhciBwZXJjZW50UmUgPSAvXiUvO1xuICB2YXIgcmVxdW90ZVJlID0gL1tcXFxcXFxeXFwkXFwqXFwrXFw/XFx8XFxbXFxdXFwoXFwpXFwuXFx7XFx9XS9nO1xuXG4gIGZ1bmN0aW9uIHBhZCh2YWx1ZSwgZmlsbCwgd2lkdGgpIHtcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMCA/IFwiLVwiIDogXCJcIixcbiAgICAgICAgc3RyaW5nID0gKHNpZ24gPyAtdmFsdWUgOiB2YWx1ZSkgKyBcIlwiLFxuICAgICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgIHJldHVybiBzaWduICsgKGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSArIHN0cmluZyA6IHN0cmluZyk7XG4gIH1cblxuICBmdW5jdGlvbiByZXF1b3RlKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKHJlcXVvdGVSZSwgXCJcXFxcJCZcIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRSZShuYW1lcykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgbmFtZXMubWFwKHJlcXVvdGUpLmpvaW4oXCJ8XCIpICsgXCIpXCIsIFwiaVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdExvb2t1cChuYW1lcykge1xuICAgIHZhciBtYXAgPSBuZXcgTWFwLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIG1hcC5zZXQobmFtZXNbaV0udG9Mb3dlckNhc2UoKSwgaSk7XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlV2Vla2RheU51bWJlcihkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gICAgcmV0dXJuIG4gPyAoZC53ID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlV2Vla051bWJlclN1bmRheShkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLlUgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VXZWVrTnVtYmVyTW9uZGF5KGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQuVyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUZ1bGxZZWFyKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDQpKTtcbiAgICByZXR1cm4gbiA/IChkLnkgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VZZWFyKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkLnkgPSArblswXSArICgrblswXSA+IDY4ID8gMTkwMCA6IDIwMDApLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVpvbmUoZCwgc3RyaW5nLCBpKSB7XG4gICAgcmV0dXJuIC9eWystXVxcZHs0fSQvLnRlc3Qoc3RyaW5nID0gc3RyaW5nLnNsaWNlKGksIGkgKyA1KSlcbiAgICAgICAgPyAoZC5aID0gLXN0cmluZywgaSArIDUpIC8vIHNpZ24gZGlmZmVycyBmcm9tIGdldFRpbWV6b25lT2Zmc2V0IVxuICAgICAgICA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNb250aE51bWJlcihkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5tID0gblswXSAtIDEsIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRGF5T2ZNb250aChkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5kID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRGF5T2ZZZWFyKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcbiAgICByZXR1cm4gbiA/IChkLm0gPSAwLCBkLmQgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VIb3VyMjQoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGQuSCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1pbnV0ZXMoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGQuTSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVNlY29uZHMoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGQuUyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1pbGxpc2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAzKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5MID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTGl0ZXJhbFBlcmNlbnQoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBwZXJjZW50UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgICByZXR1cm4gbiA/IGkgKyBuWzBdLmxlbmd0aCA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0RGF5T2ZNb250aChkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldERhdGUoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRIb3VyMjQoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRIb3VycygpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdEhvdXIxMihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldEhvdXJzKCkgJSAxMiB8fCAxMiwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXREYXlPZlllYXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoMSArIGRheS5jb3VudCh5ZWFyKGQpLCBkKSwgcCwgMyk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRNaWxsaXNlY29uZHMoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRNaWxsaXNlY29uZHMoKSwgcCwgMyk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRNb250aE51bWJlcihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldE1vbnRoKCkgKyAxLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdE1pbnV0ZXMoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRNaW51dGVzKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0U2Vjb25kcyhkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFNlY29uZHMoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyU3VuZGF5KGQsIHApIHtcbiAgICByZXR1cm4gcGFkKHN1bmRheS5jb3VudCh5ZWFyKGQpLCBkKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRXZWVrZGF5TnVtYmVyKGQpIHtcbiAgICByZXR1cm4gZC5nZXREYXkoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXJNb25kYXkoZCwgcCkge1xuICAgIHJldHVybiBwYWQobW9uZGF5LmNvdW50KHllYXIoZCksIGQpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFllYXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRGdWxsWWVhcigpICUgMTAwLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdEZ1bGxZZWFyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMDAwLCBwLCA0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFpvbmUoZCkge1xuICAgIHZhciB6ID0gZC5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgIHJldHVybiAoeiA+IDAgPyBcIi1cIiA6ICh6ICo9IC0xLCBcIitcIikpXG4gICAgICAgICsgcGFkKHogLyA2MCB8IDAsIFwiMFwiLCAyKVxuICAgICAgICArIHBhZCh6ICUgNjAsIFwiMFwiLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ0RheU9mTW9udGgoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENEYXRlKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDSG91cjI0KGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDSG91cnMoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENIb3VyMTIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENIb3VycygpICUgMTIgfHwgMTIsIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDRGF5T2ZZZWFyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKDEgKyB1dGNEYXkuY291bnQodXRjWWVhcihkKSwgZCksIHAsIDMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDTWlsbGlzZWNvbmRzKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCksIHAsIDMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDTW9udGhOdW1iZXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENNb250aCgpICsgMSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENNaW51dGVzKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDTWludXRlcygpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1NlY29uZHMoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENTZWNvbmRzKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDV2Vla051bWJlclN1bmRheShkLCBwKSB7XG4gICAgcmV0dXJuIHBhZCh1dGNTdW5kYXkuY291bnQodXRjWWVhcihkKSwgZCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDV2Vla2RheU51bWJlcihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDRGF5KCk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENXZWVrTnVtYmVyTW9uZGF5KGQsIHApIHtcbiAgICByZXR1cm4gcGFkKHV0Y01vbmRheS5jb3VudCh1dGNZZWFyKGQpLCBkKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENZZWFyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENGdWxsWWVhcihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ0Z1bGxZZWFyKCkgJSAxMDAwMCwgcCwgNCk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENab25lKCkge1xuICAgIHJldHVybiBcIiswMDAwXCI7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRMaXRlcmFsUGVyY2VudCgpIHtcbiAgICByZXR1cm4gXCIlXCI7XG4gIH1cblxuICB2YXIgaXNvU3BlY2lmaWVyID0gXCIlWS0lbS0lZFQlSDolTTolUy4lTFpcIjtcblxuICBmdW5jdGlvbiBmb3JtYXRJc29OYXRpdmUoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCk7XG4gIH1cblxuICBmb3JtYXRJc29OYXRpdmUucGFyc2UgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHN0cmluZyk7XG4gICAgcmV0dXJuIGlzTmFOKGRhdGUpID8gbnVsbCA6IGRhdGU7XG4gIH07XG5cbiAgZm9ybWF0SXNvTmF0aXZlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzb1NwZWNpZmllcjtcbiAgfTtcblxuICB2YXIgZm9ybWF0SXNvID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgJiYgK25ldyBEYXRlKFwiMjAwMC0wMS0wMVQwMDowMDowMC4wMDBaXCIpXG4gICAgICA/IGZvcm1hdElzb05hdGl2ZVxuICAgICAgOiBlblVzLnV0Y0Zvcm1hdChpc29TcGVjaWZpZXIpO1xuXG4gIHZhciBpc29Gb3JtYXQgPSBmb3JtYXRJc287XG5cbiAgdmFyIGxvY2FsZURlZmluaXRpb25zID0gKG5ldyBNYXApXG4gICAgICAuc2V0KFwiY2EtRVNcIiwgY2FFcylcbiAgICAgIC5zZXQoXCJkZS1ERVwiLCBkZURlKVxuICAgICAgLnNldChcImVuLUNBXCIsIGVuQ2EpXG4gICAgICAuc2V0KFwiZW4tR0JcIiwgZW5HYilcbiAgICAgIC5zZXQoXCJlbi1VU1wiLCBlblVzKVxuICAgICAgLnNldChcImVzLUVTXCIsIGVzRXMpXG4gICAgICAuc2V0KFwiZmktRklcIiwgZmlGaSlcbiAgICAgIC5zZXQoXCJmci1DQVwiLCBmckNhKVxuICAgICAgLnNldChcImZyLUZSXCIsIGZyRnIpXG4gICAgICAuc2V0KFwiaGUtSUxcIiwgaGVJbClcbiAgICAgIC5zZXQoXCJpdC1JVFwiLCBpdEl0KVxuICAgICAgLnNldChcIm1rLU1LXCIsIG1rTWspXG4gICAgICAuc2V0KFwibmwtTkxcIiwgbmxObClcbiAgICAgIC5zZXQoXCJwbC1QTFwiLCBwbFBsKVxuICAgICAgLnNldChcInB0LUJSXCIsIHB0QnIpXG4gICAgICAuc2V0KFwicnUtUlVcIiwgcnVSdSlcbiAgICAgIC5zZXQoXCJ6aC1DTlwiLCB6aENuKTtcblxuICB2YXIgZGVmYXVsdExvY2FsZSA9IGxvY2FsZShlblVzKTtcbiAgZXhwb3J0cy5mb3JtYXQgPSBkZWZhdWx0TG9jYWxlLmZvcm1hdDtcbiAgZXhwb3J0cy51dGNGb3JtYXQgPSBkZWZhdWx0TG9jYWxlLnV0Y0Zvcm1hdDtcblxuICBmdW5jdGlvbiBsb2NhbGVGb3JtYXQoZGVmaW5pdGlvbikge1xuICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZGVmaW5pdGlvbiA9IGxvY2FsZURlZmluaXRpb25zLmdldChkZWZpbml0aW9uKTtcbiAgICAgIGlmICghZGVmaW5pdGlvbikgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGUoZGVmaW5pdGlvbik7XG4gIH1cbiAgO1xuXG4gIGV4cG9ydHMubG9jYWxlRm9ybWF0ID0gbG9jYWxlRm9ybWF0O1xuICBleHBvcnRzLmlzb0Zvcm1hdCA9IGlzb0Zvcm1hdDtcblxufSkpOyIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9nbG9iYWxzJyk7XG5cbnZhciBjb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0cycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gIHZsZmllbGQgPSByZXF1aXJlKCcuL2ZpZWxkJyksXG4gIHZsZW5jID0gcmVxdWlyZSgnLi9lbmMnKSxcbiAgc2NoZW1hID0gcmVxdWlyZSgnLi9zY2hlbWEvc2NoZW1hJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBFbmNvZGluZyhzcGVjLCB0aGVtZSkge1xuICAgIHZhciBkZWZhdWx0cyA9IHNjaGVtYS5pbnN0YW50aWF0ZSgpLFxuICAgICAgc3BlY0V4dGVuZGVkID0gc2NoZW1hLnV0aWwubWVyZ2UoZGVmYXVsdHMsIHRoZW1lIHx8IHt9LCBzcGVjKSA7XG5cbiAgICB0aGlzLl9kYXRhID0gc3BlY0V4dGVuZGVkLmRhdGE7XG4gICAgdGhpcy5fbWFya3R5cGUgPSBzcGVjRXh0ZW5kZWQubWFya3R5cGU7XG4gICAgdGhpcy5fZW5jID0gc3BlY0V4dGVuZGVkLmVuY29kaW5nO1xuICAgIHRoaXMuX2NvbmZpZyA9IHNwZWNFeHRlbmRlZC5jb25maWc7XG4gICAgdGhpcy5fZmlsdGVyID0gc3BlY0V4dGVuZGVkLmZpbHRlcjtcbiAgICAvLyB0aGlzLl92ZWdhMiA9IHRydWU7XG4gIH1cblxuICB2YXIgcHJvdG8gPSBFbmNvZGluZy5wcm90b3R5cGU7XG5cbiAgRW5jb2RpbmcuZnJvbVNob3J0aGFuZCA9IGZ1bmN0aW9uKHNob3J0aGFuZCwgZGF0YSwgY29uZmlnLCB0aGVtZSkge1xuICAgIHZhciBjID0gY29uc3RzLnNob3J0aGFuZCxcbiAgICAgICAgc3BsaXQgPSBzaG9ydGhhbmQuc3BsaXQoYy5kZWxpbSksXG4gICAgICAgIG1hcmt0eXBlID0gc3BsaXQuc2hpZnQoKS5zcGxpdChjLmFzc2lnbilbMV0udHJpbSgpLFxuICAgICAgICBlbmMgPSB2bGVuYy5mcm9tU2hvcnRoYW5kKHNwbGl0KTtcblxuICAgIHJldHVybiBuZXcgRW5jb2Rpbmcoe1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIG1hcmt0eXBlOiBtYXJrdHlwZSxcbiAgICAgIGVuY29kaW5nOiBlbmMsXG4gICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgIGZpbHRlcjogW11cbiAgICB9LCB0aGVtZSk7XG4gIH07XG5cbiAgRW5jb2RpbmcuZnJvbVNwZWMgPSBmdW5jdGlvbihzcGVjLCB0aGVtZSkge1xuICAgIHJldHVybiBuZXcgRW5jb2Rpbmcoc3BlYywgdGhlbWUpO1xuICB9O1xuXG4gIHByb3RvLnRvU2hvcnRoYW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGMgPSBjb25zdHMuc2hvcnRoYW5kO1xuICAgIHJldHVybiAnbWFyaycgKyBjLmFzc2lnbiArIHRoaXMuX21hcmt0eXBlICtcbiAgICAgIGMuZGVsaW0gKyB2bGVuYy5zaG9ydGhhbmQodGhpcy5fZW5jKTtcbiAgfTtcblxuICBFbmNvZGluZy5zaG9ydGhhbmQgPSBmdW5jdGlvbiAoc3BlYykge1xuICAgIHZhciBjID0gY29uc3RzLnNob3J0aGFuZDtcbiAgICByZXR1cm4gJ21hcmsnICsgYy5hc3NpZ24gKyBzcGVjLm1hcmt0eXBlICtcbiAgICAgIGMuZGVsaW0gKyB2bGVuYy5zaG9ydGhhbmQoc3BlYy5lbmNvZGluZyk7XG4gIH07XG5cbiAgRW5jb2Rpbmcuc3BlY0Zyb21TaG9ydGhhbmQgPSBmdW5jdGlvbihzaG9ydGhhbmQsIGRhdGEsIGNvbmZpZywgZXhjbHVkZUNvbmZpZykge1xuICAgIHJldHVybiBFbmNvZGluZy5mcm9tU2hvcnRoYW5kKHNob3J0aGFuZCwgZGF0YSwgY29uZmlnKS50b1NwZWMoZXhjbHVkZUNvbmZpZyk7XG4gIH07XG5cbiAgcHJvdG8udG9TcGVjID0gZnVuY3Rpb24oZXhjbHVkZUNvbmZpZywgZXhjbHVkZURhdGEpIHtcbiAgICB2YXIgZW5jID0gdXRpbC5kdXBsaWNhdGUodGhpcy5fZW5jKSxcbiAgICAgIHNwZWM7XG5cbiAgICBzcGVjID0ge1xuICAgICAgbWFya3R5cGU6IHRoaXMuX21hcmt0eXBlLFxuICAgICAgZW5jb2Rpbmc6IGVuYyxcbiAgICAgIGZpbHRlcjogdGhpcy5fZmlsdGVyXG4gICAgfTtcblxuICAgIGlmICghZXhjbHVkZUNvbmZpZykge1xuICAgICAgc3BlYy5jb25maWcgPSB1dGlsLmR1cGxpY2F0ZSh0aGlzLl9jb25maWcpO1xuICAgIH1cblxuICAgIGlmICghZXhjbHVkZURhdGEpIHtcbiAgICAgIHNwZWMuZGF0YSA9IHV0aWwuZHVwbGljYXRlKHRoaXMuX2RhdGEpO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBkZWZhdWx0c1xuICAgIHZhciBkZWZhdWx0cyA9IHNjaGVtYS5pbnN0YW50aWF0ZSgpO1xuICAgIHJldHVybiBzY2hlbWEudXRpbC5zdWJ0cmFjdChzcGVjLCBkZWZhdWx0cyk7XG4gIH07XG5cblxuICBwcm90by5tYXJrdHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXJrdHlwZTtcbiAgfTtcblxuICBwcm90by5pcyA9IGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gdGhpcy5fbWFya3R5cGUgPT09IG07XG4gIH07XG5cbiAgcHJvdG8uaGFzID0gZnVuY3Rpb24oZW5jVHlwZSkge1xuICAgIC8vIGVxdWl2YWxlbnQgdG8gY2FsbGluZyB2bGVuYy5oYXModGhpcy5fZW5jLCBlbmNUeXBlKVxuICAgIHJldHVybiB0aGlzLl9lbmNbZW5jVHlwZV0ubmFtZSAhPT0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIHByb3RvLmZpZWxkID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XTtcbiAgfTtcblxuICBwcm90by5maWx0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZmlsdGVyTnVsbCA9IFtdLFxuICAgICAgZmllbGRzID0gdGhpcy5maWVsZHMoKSxcbiAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgdXRpbC5mb3JFYWNoKGZpZWxkcywgZnVuY3Rpb24oZmllbGRMaXN0LCBmaWVsZE5hbWUpIHtcbiAgICAgIGlmIChmaWVsZE5hbWUgPT09ICcqJykgcmV0dXJuOyAvL2NvdW50XG5cbiAgICAgIGlmICgoc2VsZi5jb25maWcoJ2ZpbHRlck51bGwnKS5RICYmIGZpZWxkTGlzdC5jb250YWluc1R5cGVbUV0pIHx8XG4gICAgICAgICAgKHNlbGYuY29uZmlnKCdmaWx0ZXJOdWxsJykuVCAmJiBmaWVsZExpc3QuY29udGFpbnNUeXBlW1RdKSB8fFxuICAgICAgICAgIChzZWxmLmNvbmZpZygnZmlsdGVyTnVsbCcpLk8gJiYgZmllbGRMaXN0LmNvbnRhaW5zVHlwZVtPXSkgfHxcbiAgICAgICAgICAoc2VsZi5jb25maWcoJ2ZpbHRlck51bGwnKS5OICYmIGZpZWxkTGlzdC5jb250YWluc1R5cGVbTl0pKSB7XG4gICAgICAgIGZpbHRlck51bGwucHVzaCh7XG4gICAgICAgICAgb3BlcmFuZHM6IFtmaWVsZE5hbWVdLFxuICAgICAgICAgIG9wZXJhdG9yOiAnbm90TnVsbCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZmlsdGVyTnVsbC5jb25jYXQodGhpcy5fZmlsdGVyKTtcbiAgfTtcblxuICAvLyBnZXQgXCJmaWVsZFwiIHJlZmVyZW5jZSBmb3IgdmVnYVxuICBwcm90by5maWVsZFJlZiA9IGZ1bmN0aW9uKGV0LCBvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge307XG4gICAgb3B0LmRhdGEgPSAhdGhpcy5fdmVnYTIgJiYgKG9wdC5kYXRhICE9PSBmYWxzZSk7XG4gICAgcmV0dXJuIHZsZmllbGQuZmllbGRSZWYodGhpcy5fZW5jW2V0XSwgb3B0KTtcbiAgfTtcblxuICBwcm90by5maWVsZE5hbWUgPSBmdW5jdGlvbihldCkge1xuICAgIHJldHVybiB0aGlzLl9lbmNbZXRdLm5hbWU7XG4gIH07XG5cbiAgLypcbiAgICogcmV0dXJuIGtleS12YWx1ZSBwYWlycyBvZiBmaWVsZCBuYW1lIGFuZCBsaXN0IG9mIGZpZWxkcyBvZiB0aGF0IGZpZWxkIG5hbWVcbiAgICovXG4gIHByb3RvLmZpZWxkcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2bGVuYy5maWVsZHModGhpcy5fZW5jKTtcbiAgfTtcblxuICBwcm90by5maWVsZFRpdGxlID0gZnVuY3Rpb24oZXQpIHtcbiAgICBpZiAodmxmaWVsZC5pc0NvdW50KHRoaXMuX2VuY1tldF0pKSB7XG4gICAgICByZXR1cm4gdmxmaWVsZC5jb3VudC5kaXNwbGF5TmFtZTtcbiAgICB9XG4gICAgdmFyIGZuID0gdGhpcy5fZW5jW2V0XS5hZ2dyZWdhdGUgfHwgdGhpcy5fZW5jW2V0XS50aW1lVW5pdCB8fCAodGhpcy5fZW5jW2V0XS5iaW4gJiYgJ2JpbicpO1xuICAgIGlmIChmbikge1xuICAgICAgdmFyIHVwcGVyY2FzZSA9IGZuID09PSAnYXZnJyA/ICdNRUFOJyA6Zm4udG9VcHBlckNhc2UoKTtcbiAgICAgIHJldHVybiB1cHBlcmNhc2UgKyAnKCcgKyB0aGlzLl9lbmNbZXRdLm5hbWUgKyAnKSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbmNbZXRdLm5hbWU7XG4gICAgfVxuICB9O1xuXG4gIHByb3RvLnNjYWxlID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5zY2FsZSB8fCB7fTtcbiAgfTtcblxuICBwcm90by5heGlzID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5heGlzIHx8IHt9O1xuICB9O1xuXG4gIHByb3RvLmJhbmRTaXplID0gZnVuY3Rpb24oZW5jVHlwZSwgdXNlU21hbGxCYW5kKSB7XG4gICAgdXNlU21hbGxCYW5kID0gdXNlU21hbGxCYW5kIHx8XG4gICAgICAvL2lzQmFuZEluU21hbGxNdWx0aXBsZXNcbiAgICAgIChlbmNUeXBlID09PSBZICYmIHRoaXMuaGFzKFJPVykgJiYgdGhpcy5oYXMoWSkpIHx8XG4gICAgICAoZW5jVHlwZSA9PT0gWCAmJiB0aGlzLmhhcyhDT0wpICYmIHRoaXMuaGFzKFgpKTtcblxuICAgIC8vIGlmIGJhbmQuc2l6ZSBpcyBleHBsaWNpdGx5IHNwZWNpZmllZCwgZm9sbG93IHRoZSBzcGVjaWZpY2F0aW9uLCBvdGhlcndpc2UgZHJhdyB2YWx1ZSBmcm9tIGNvbmZpZy5cbiAgICByZXR1cm4gdGhpcy5maWVsZChlbmNUeXBlKS5iYW5kLnNpemUgfHxcbiAgICAgIHRoaXMuY29uZmlnKHVzZVNtYWxsQmFuZCA/ICdzbWFsbEJhbmRTaXplJyA6ICdsYXJnZUJhbmRTaXplJyk7XG4gIH07XG5cbiAgcHJvdG8uYWdncmVnYXRlID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5hZ2dyZWdhdGU7XG4gIH07XG5cbiAgLy8gcmV0dXJucyBmYWxzZSBpZiBiaW5uaW5nIGlzIGRpc2FibGVkLCBvdGhlcndpc2UgYW4gb2JqZWN0IHdpdGggYmlubmluZyBwcm9wZXJ0aWVzXG4gIHByb3RvLmJpbiA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgdmFyIGJpbiA9IHRoaXMuX2VuY1tldF0uYmluO1xuICAgIGlmIChiaW4gPT09IHt9KVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChiaW4gPT09IHRydWUpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXhiaW5zOiBzY2hlbWEuTUFYQklOU19ERUZBVUxUXG4gICAgICB9O1xuICAgIHJldHVybiBiaW47XG4gIH07XG5cbiAgcHJvdG8udmFsdWUgPSBmdW5jdGlvbihldCkge1xuICAgIHJldHVybiB0aGlzLl9lbmNbZXRdLnZhbHVlO1xuICB9O1xuXG4gIHByb3RvLm51bWJlckZvcm1hdCA9IGZ1bmN0aW9uKGZpZWxkU3RhdHMpIHtcbiAgICB2YXIgZm9ybWF0Q29uZmlnID0gZmllbGRTdGF0cy5tYXggPiB0aGlzLmNvbmZpZygnbWF4U21hbGxOdW1iZXInKSA/XG4gICAgICAnbGFyZ2VOdW1iZXJGb3JtYXQnOiAnc21hbGxOdW1iZXJGb3JtYXQnO1xuICAgIHJldHVybiB0aGlzLmNvbmZpZyhmb3JtYXRDb25maWcpO1xuICB9O1xuXG4gIHByb3RvLnNvcnQgPSBmdW5jdGlvbihldCwgc3RhdHMpIHtcbiAgICB2YXIgc29ydCA9IHRoaXMuX2VuY1tldF0uc29ydCxcbiAgICAgIGVuYyA9IHRoaXMuX2VuYyxcbiAgICAgIGlzVHlwZXMgPSB2bGZpZWxkLmlzVHlwZXM7XG5cbiAgICBpZiAoKCFzb3J0IHx8IHNvcnQubGVuZ3RoPT09MCkgJiZcbiAgICAgICAgLy8gRklYTUVcbiAgICAgICAgRW5jb2RpbmcudG9nZ2xlU29ydC5zdXBwb3J0KHtlbmNvZGluZzp0aGlzLl9lbmN9LCBzdGF0cywgdHJ1ZSkgJiYgLy9IQUNLXG4gICAgICAgIHRoaXMuY29uZmlnKCd0b2dnbGVTb3J0JykgPT09IFFcbiAgICAgICkge1xuICAgICAgdmFyIHFGaWVsZCA9IGlzVHlwZXMoZW5jLngsIFtOLCBPXSkgPyBlbmMueSA6IGVuYy54O1xuXG4gICAgICBpZiAoaXNUeXBlcyhlbmNbZXRdLCBbTiwgT10pKSB7XG4gICAgICAgIHNvcnQgPSBbe1xuICAgICAgICAgIG5hbWU6IHFGaWVsZC5uYW1lLFxuICAgICAgICAgIGFnZ3JlZ2F0ZTogcUZpZWxkLmFnZ3JlZ2F0ZSxcbiAgICAgICAgICB0eXBlOiBxRmllbGQudHlwZSxcbiAgICAgICAgICByZXZlcnNlOiB0cnVlXG4gICAgICAgIH1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzb3J0O1xuICB9O1xuXG4gIHByb3RvLm1hcCA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gdmxlbmMubWFwKHRoaXMuX2VuYywgZik7XG4gIH07XG5cbiAgcHJvdG8ucmVkdWNlID0gZnVuY3Rpb24oZiwgaW5pdCkge1xuICAgIHJldHVybiB2bGVuYy5yZWR1Y2UodGhpcy5fZW5jLCBmLCBpbml0KTtcbiAgfTtcblxuICBwcm90by5mb3JFYWNoID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiB2bGVuYy5mb3JFYWNoKHRoaXMuX2VuYywgZik7XG4gIH07XG5cbiAgcHJvdG8udHlwZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGV0KSA/IHRoaXMuX2VuY1tldF0udHlwZSA6IG51bGw7XG4gIH07XG5cbiAgcHJvdG8uaXNUeXBlID0gZnVuY3Rpb24oZXQsIHR5cGUpIHtcbiAgICB2YXIgZmllbGQgPSB0aGlzLmZpZWxkKGV0KTtcbiAgICByZXR1cm4gZmllbGQgJiYgdmxmaWVsZC5pc1R5cGUoZmllbGQsIHR5cGUpO1xuICB9O1xuXG5cbiAgcHJvdG8uaXNUeXBlcyA9IGZ1bmN0aW9uKGV0LCB0eXBlKSB7XG4gICAgdmFyIGZpZWxkID0gdGhpcy5maWVsZChldCk7XG4gICAgcmV0dXJuIGZpZWxkICYmIHZsZmllbGQuaXNUeXBlcyhmaWVsZCwgdHlwZSk7XG4gIH07XG5cbiAgRW5jb2RpbmcuaXNPcmRpbmFsU2NhbGUgPSBmdW5jdGlvbihlbmNvZGluZywgZW5jVHlwZSkge1xuICAgIHJldHVybiB2bGZpZWxkLmlzT3JkaW5hbFNjYWxlKGVuY29kaW5nLmZpZWxkKGVuY1R5cGUpKTtcbiAgfTtcblxuICBFbmNvZGluZy5pc0RpbWVuc2lvbiA9IGZ1bmN0aW9uKGVuY29kaW5nLCBlbmNUeXBlKSB7XG4gICAgcmV0dXJuIHZsZmllbGQuaXNEaW1lbnNpb24oZW5jb2RpbmcuZmllbGQoZW5jVHlwZSkpO1xuICB9O1xuXG4gIEVuY29kaW5nLmlzTWVhc3VyZSA9IGZ1bmN0aW9uKGVuY29kaW5nLCBlbmNUeXBlKSB7XG4gICAgcmV0dXJuIHZsZmllbGQuaXNNZWFzdXJlKGVuY29kaW5nLmZpZWxkKGVuY1R5cGUpKTtcbiAgfTtcblxuICBwcm90by5pc09yZGluYWxTY2FsZSA9IGZ1bmN0aW9uKGVuY1R5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoZW5jVHlwZSkgJiYgRW5jb2RpbmcuaXNPcmRpbmFsU2NhbGUodGhpcywgZW5jVHlwZSk7XG4gIH07XG5cbiAgcHJvdG8uaXNEaW1lbnNpb24gPSBmdW5jdGlvbihlbmNUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGVuY1R5cGUpICYmIEVuY29kaW5nLmlzRGltZW5zaW9uKHRoaXMsIGVuY1R5cGUpO1xuICB9O1xuXG4gIHByb3RvLmlzTWVhc3VyZSA9IGZ1bmN0aW9uKGVuY1R5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoZW5jVHlwZSkgJiYgRW5jb2RpbmcuaXNNZWFzdXJlKHRoaXMsIGVuY1R5cGUpO1xuICB9O1xuXG4gIHByb3RvLmlzQWdncmVnYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZsZW5jLmlzQWdncmVnYXRlKHRoaXMuX2VuYyk7XG4gIH07XG5cbiAgcHJvdG8uZGF0YVRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNBZ2dyZWdhdGUoKSA/IEFHR1JFR0FURSA6IFJBVztcbiAgfTtcblxuICBFbmNvZGluZy5pc0FnZ3JlZ2F0ZSA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICByZXR1cm4gdmxlbmMuaXNBZ2dyZWdhdGUoc3BlYy5lbmNvZGluZyk7XG4gIH07XG5cbiAgRW5jb2RpbmcuYWx3YXlzTm9PY2NsdXNpb24gPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgLy8gRklYTUUgcmF3IE94USB3aXRoICMgb2Ygcm93cyA9ICMgb2YgT1xuICAgIHJldHVybiB2bGVuYy5pc0FnZ3JlZ2F0ZShzcGVjLmVuY29kaW5nKTtcbiAgfTtcblxuICBFbmNvZGluZy5pc1N0YWNrID0gZnVuY3Rpb24oc3BlYykge1xuICAgIC8vIEZJWE1FIHVwZGF0ZSB0aGlzIG9uY2Ugd2UgaGF2ZSBjb250cm9sIGZvciBzdGFjayAuLi5cbiAgICByZXR1cm4gKHNwZWMubWFya3R5cGUgPT09ICdiYXInIHx8IHNwZWMubWFya3R5cGUgPT09ICdhcmVhJykgJiZcbiAgICAgIHNwZWMuZW5jb2RpbmcuY29sb3I7XG4gIH07XG5cbiAgcHJvdG8uaXNTdGFjayA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIEZJWE1FIHVwZGF0ZSB0aGlzIG9uY2Ugd2UgaGF2ZSBjb250cm9sIGZvciBzdGFjayAuLi5cbiAgICByZXR1cm4gKHRoaXMuaXMoJ2JhcicpIHx8IHRoaXMuaXMoJ2FyZWEnKSkgJiYgdGhpcy5oYXMoJ2NvbG9yJyk7XG4gIH07XG5cbiAgcHJvdG8uZGV0YWlscyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlbmNvZGluZyA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMucmVkdWNlKGZ1bmN0aW9uKHJlZnMsIGZpZWxkLCBlbmNUeXBlKSB7XG4gICAgICBpZiAoIWZpZWxkLmFnZ3JlZ2F0ZSAmJiAoZW5jVHlwZSAhPT0gWCAmJiBlbmNUeXBlICE9PSBZKSkge1xuICAgICAgICByZWZzLnB1c2goZW5jb2RpbmcuZmllbGRSZWYoZW5jVHlwZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlZnM7XG4gICAgfSwgW10pO1xuICB9O1xuXG4gIHByb3RvLmZhY2V0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlbmNvZGluZyA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMucmVkdWNlKGZ1bmN0aW9uKHJlZnMsIGZpZWxkLCBlbmNUeXBlKSB7XG4gICAgICBpZiAoIWZpZWxkLmFnZ3JlZ2F0ZSAmJiAoZW5jVHlwZSA9PSBST1cgfHwgZW5jVHlwZSA9PSBDT0wpKSB7XG4gICAgICAgIHJlZnMucHVzaChlbmNvZGluZy5maWVsZFJlZihlbmNUeXBlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVmcztcbiAgICB9LCBbXSk7XG4gIH07XG5cbiAgcHJvdG8uY2FyZGluYWxpdHkgPSBmdW5jdGlvbihlbmNUeXBlLCBzdGF0cykge1xuICAgIHJldHVybiB2bGZpZWxkLmNhcmRpbmFsaXR5KHRoaXMuZmllbGQoZW5jVHlwZSksIHN0YXRzLCB0aGlzLmNvbmZpZygnZmlsdGVyTnVsbCcpKTtcbiAgfTtcblxuICBwcm90by5pc1JhdyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy5pc0FnZ3JlZ2F0ZSgpO1xuICB9O1xuXG4gIHByb3RvLmRhdGEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfTtcblxuICAgLy8gcmV0dXJucyB3aGV0aGVyIHRoZSBlbmNvZGluZyBoYXMgdmFsdWVzIGVtYmVkZGVkXG4gIHByb3RvLmhhc1ZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWxzID0gdGhpcy5kYXRhKCkudmFsdWVzO1xuICAgIHJldHVybiB2YWxzICYmIHZhbHMubGVuZ3RoO1xuICB9O1xuXG4gIHByb3RvLmNvbmZpZyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnW25hbWVdO1xuICB9O1xuXG4gIEVuY29kaW5nLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICB2YXIgb2xkZW5jID0gc3BlYy5lbmNvZGluZyxcbiAgICAgIGVuYyA9IHV0aWwuZHVwbGljYXRlKHNwZWMuZW5jb2RpbmcpO1xuICAgIGVuYy54ID0gb2xkZW5jLnk7XG4gICAgZW5jLnkgPSBvbGRlbmMueDtcbiAgICBlbmMucm93ID0gb2xkZW5jLmNvbDtcbiAgICBlbmMuY29sID0gb2xkZW5jLnJvdztcbiAgICBzcGVjLmVuY29kaW5nID0gZW5jO1xuICAgIHJldHVybiBzcGVjO1xuICB9O1xuXG4gIC8vIEZJWE1FOiBSRU1PVkUgZXZlcnl0aGluZyBiZWxvdyBoZXJlXG5cbiAgRW5jb2RpbmcudG9nZ2xlU29ydCA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICBzcGVjLmNvbmZpZyA9IHNwZWMuY29uZmlnIHx8IHt9O1xuICAgIHNwZWMuY29uZmlnLnRvZ2dsZVNvcnQgPSBzcGVjLmNvbmZpZy50b2dnbGVTb3J0ID09PSBRID8gTiA6IFE7XG4gICAgcmV0dXJuIHNwZWM7XG4gIH07XG5cblxuICBFbmNvZGluZy50b2dnbGVTb3J0LmRpcmVjdGlvbiA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICBpZiAoIUVuY29kaW5nLnRvZ2dsZVNvcnQuc3VwcG9ydChzcGVjKSkgeyByZXR1cm47IH1cbiAgICB2YXIgZW5jID0gc3BlYy5lbmNvZGluZztcbiAgICByZXR1cm4gZW5jLngudHlwZSA9PT0gTiA/ICd4JyA6ICd5JztcbiAgfTtcblxuICBFbmNvZGluZy50b2dnbGVTb3J0Lm1vZGUgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgcmV0dXJuIHNwZWMuY29uZmlnLnRvZ2dsZVNvcnQ7XG4gIH07XG5cbiAgRW5jb2RpbmcudG9nZ2xlU29ydC5zdXBwb3J0ID0gZnVuY3Rpb24oc3BlYywgc3RhdHMpIHtcbiAgICB2YXIgZW5jID0gc3BlYy5lbmNvZGluZyxcbiAgICAgIGlzVHlwZXMgPSB2bGZpZWxkLmlzVHlwZXM7XG5cbiAgICBpZiAodmxlbmMuaGFzKGVuYywgUk9XKSB8fCB2bGVuYy5oYXMoZW5jLCBDT0wpIHx8XG4gICAgICAhdmxlbmMuaGFzKGVuYywgWCkgfHwgIXZsZW5jLmhhcyhlbmMsIFkpIHx8XG4gICAgICAhRW5jb2RpbmcuYWx3YXlzTm9PY2NsdXNpb24oc3BlYywgc3RhdHMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuICggaXNUeXBlcyhlbmMueCwgW04sT10pICYmIHZsZmllbGQuaXNNZWFzdXJlKGVuYy55KSkgPyAneCcgOlxuICAgICAgKCBpc1R5cGVzKGVuYy55LCBbTixPXSkgJiYgdmxmaWVsZC5pc01lYXN1cmUoZW5jLngpKSA/ICd5JyA6IGZhbHNlO1xuICB9O1xuXG4gIEVuY29kaW5nLnRvZ2dsZUZpbHRlck51bGxPID0gZnVuY3Rpb24oc3BlYykge1xuICAgIHNwZWMuY29uZmlnID0gc3BlYy5jb25maWcgfHwge307XG4gICAgc3BlYy5jb25maWcuZmlsdGVyTnVsbCA9IHNwZWMuY29uZmlnLmZpbHRlck51bGwgfHwgeyAvL0ZJWE1FXG4gICAgICBUOiB0cnVlLFxuICAgICAgUTogdHJ1ZVxuICAgIH07XG4gICAgc3BlYy5jb25maWcuZmlsdGVyTnVsbC5PID0gIXNwZWMuY29uZmlnLmZpbHRlck51bGwuTztcbiAgICByZXR1cm4gc3BlYztcbiAgfTtcblxuICBFbmNvZGluZy50b2dnbGVGaWx0ZXJOdWxsTy5zdXBwb3J0ID0gZnVuY3Rpb24oc3BlYywgc3RhdHMpIHtcbiAgICB2YXIgZmllbGRzID0gdmxlbmMuZmllbGRzKHNwZWMuZW5jb2RpbmcpO1xuICAgIGZvciAodmFyIGZpZWxkTmFtZSBpbiBmaWVsZHMpIHtcbiAgICAgIHZhciBmaWVsZExpc3QgPSBmaWVsZHNbZmllbGROYW1lXTtcbiAgICAgIGlmIChmaWVsZExpc3QuY29udGFpbnNUeXBlLk8gJiYgZmllbGROYW1lIGluIHN0YXRzICYmIHN0YXRzW2ZpZWxkTmFtZV0ubnVsbHMgPiAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgcmV0dXJuIEVuY29kaW5nO1xufSkoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgc2V0dGVyID0gdXRpbC5zZXR0ZXIsXG4gIGdldHRlciA9IHV0aWwuZ2V0dGVyLFxuICB0aW1lID0gcmVxdWlyZSgnLi90aW1lJyk7XG5cbnZhciBheGlzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuYXhpcy5kZWYgPSBmdW5jdGlvbihuYW1lLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cywgb3B0KSB7XG4gIHZhciBpc0NvbCA9IG5hbWUgPT0gQ09MLFxuICAgIGlzUm93ID0gbmFtZSA9PSBST1csXG4gICAgdHlwZSA9IGlzQ29sID8gJ3gnIDogaXNSb3cgPyAneScgOiBuYW1lO1xuXG4gIHZhciBkZWYgPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBzY2FsZTogbmFtZSxcbiAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICBsYXllcjogZW5jb2RpbmcuZmllbGQobmFtZSkuYXhpcy5sYXllcixcbiAgICBvcmllbnQ6IGF4aXMub3JpZW50KG5hbWUsIGVuY29kaW5nLCBzdGF0cylcbiAgfTtcblxuICAvLyBBZGQgYXhpcyBsYWJlbCBjdXN0b20gc2NhbGUgKGZvciBiaW4gLyB0aW1lKVxuICBkZWYgPSBheGlzLmxhYmVscy5zY2FsZShkZWYsIGVuY29kaW5nLCBuYW1lKTtcbiAgZGVmID0gYXhpcy5sYWJlbHMuZm9ybWF0KGRlZiwgbmFtZSwgZW5jb2RpbmcsIHN0YXRzKTtcbiAgZGVmID0gYXhpcy5sYWJlbHMuYW5nbGUoZGVmLCBlbmNvZGluZywgbmFtZSk7XG5cbiAgLy8gZm9yIHgtYXhpcywgc2V0IHRpY2tzIGZvciBRIG9yIHJvdGF0ZSBzY2FsZSBmb3Igb3JkaW5hbCBzY2FsZVxuICBpZiAobmFtZSA9PSBYKSB7XG4gICAgaWYgKChlbmNvZGluZy5pc0RpbWVuc2lvbihYKSB8fCBlbmNvZGluZy5pc1R5cGUoWCwgVCkpICYmXG4gICAgICAgICEoJ2FuZ2xlJyBpbiBnZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCAnbGFiZWxzJ10pKSkge1xuICAgICAgLy8gVE9ETyhrYW5pdHcpOiBKdWwgMTksIDIwMTUgLSAjNTA2IGFkZCBjb25kaXRpb24gZm9yIHJvdGF0aW9uXG4gICAgICBkZWYgPSBheGlzLmxhYmVscy5yb3RhdGUoZGVmKTtcbiAgICB9IGVsc2UgeyAvLyBRXG4gICAgICBkZWYudGlja3MgPSBlbmNvZGluZy5maWVsZChuYW1lKS5heGlzLnRpY2tzO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRpdGxlT2Zmc2V0IGRlcGVuZHMgb24gbGFiZWxzIHJvdGF0aW9uXG4gIGRlZi50aXRsZU9mZnNldCA9IGF4aXMudGl0bGVPZmZzZXQoZW5jb2RpbmcsIGxheW91dCwgbmFtZSk7XG5cbiAgLy9kZWYub2Zmc2V0IGlzIHVzZWQgaW4gYXhpcy5ncmlkXG4gIGlmKGlzUm93KSBkZWYub2Zmc2V0ID0gYXhpcy50aXRsZU9mZnNldChlbmNvZGluZywgbGF5b3V0LCBZKSArIDIwO1xuICAvLyBGSVhNRShrYW5pdHcpOiBKdWwgMTksIDIwMTUgLSBvZmZzZXQgZm9yIGNvbHVtbiB3aGVuIHggaXMgcHV0IG9uIHRvcFxuXG4gIGRlZiA9IGF4aXMuZ3JpZChkZWYsIG5hbWUsIGVuY29kaW5nLCBsYXlvdXQpO1xuICBkZWYgPSBheGlzLnRpdGxlKGRlZiwgbmFtZSwgZW5jb2RpbmcsIGxheW91dCwgb3B0KTtcblxuICBpZiAoaXNSb3cgfHwgaXNDb2wpIGRlZiA9IGF4aXMuaGlkZVRpY2tzKGRlZik7XG5cbiAgcmV0dXJuIGRlZjtcbn07XG5cbmF4aXMub3JpZW50ID0gZnVuY3Rpb24obmFtZSwgZW5jb2RpbmcsIHN0YXRzKSB7XG4gIHZhciBvcmllbnQgPSBlbmNvZGluZy5maWVsZChuYW1lKS5heGlzLm9yaWVudDtcbiAgaWYgKG9yaWVudCkgcmV0dXJuIG9yaWVudDtcblxuICBpZiAobmFtZSA9PT0gQ09MKSByZXR1cm4gJ3RvcCc7XG5cbiAgLy8geC1heGlzIGZvciBsb25nIHkgLSBwdXQgb24gdG9wXG4gIGlmIChuYW1lID09PSBYICYmIGVuY29kaW5nLmhhcyhZKSAmJiBlbmNvZGluZy5pc09yZGluYWxTY2FsZShZKSAmJiBlbmNvZGluZy5jYXJkaW5hbGl0eShZLCBzdGF0cykgPiAzMCkge1xuICAgIHJldHVybiAndG9wJztcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5heGlzLmdyaWQgPSBmdW5jdGlvbihkZWYsIG5hbWUsIGVuY29kaW5nLCBsYXlvdXQpIHtcbiAgdmFyIGNlbGxQYWRkaW5nID0gbGF5b3V0LmNlbGxQYWRkaW5nLFxuICAgIGlzQ29sID0gbmFtZSA9PSBDT0wsXG4gICAgaXNSb3cgPSBuYW1lID09IFJPVztcblxuICBpZiAoZW5jb2RpbmcuYXhpcyhuYW1lKS5ncmlkKSB7XG4gICAgZGVmLmdyaWQgPSB0cnVlO1xuXG4gICAgaWYgKGlzQ29sKSB7XG4gICAgICAvLyBzZXQgZ3JpZCBwcm9wZXJ0eSAtLSBwdXQgdGhlIGxpbmVzIG9uIHRoZSByaWdodCB0aGUgY2VsbFxuICAgICAgZGVmLnByb3BlcnRpZXMuZ3JpZCA9IHtcbiAgICAgICAgeDoge1xuICAgICAgICAgIG9mZnNldDogbGF5b3V0LmNlbGxXaWR0aCAqICgxKyBjZWxsUGFkZGluZy8yLjApLFxuICAgICAgICAgIC8vIGRlZmF1bHQgdmFsdWUocykgLS0gdmVnYSBkb2Vzbid0IGRvIHJlY3Vyc2l2ZSBtZXJnZVxuICAgICAgICAgIHNjYWxlOiAnY29sJ1xuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgdmFsdWU6IC1sYXlvdXQuY2VsbEhlaWdodCAqIChjZWxsUGFkZGluZy8yKSxcbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlOiB7IHZhbHVlOiBlbmNvZGluZy5jb25maWcoJ2NlbGxHcmlkQ29sb3InKSB9LFxuICAgICAgICBvcGFjaXR5OiB7IHZhbHVlOiBlbmNvZGluZy5jb25maWcoJ2NlbGxHcmlkT3BhY2l0eScpIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpc1Jvdykge1xuICAgICAgLy8gc2V0IGdyaWQgcHJvcGVydHkgLS0gcHV0IHRoZSBsaW5lcyBvbiB0aGUgdG9wXG4gICAgICBkZWYucHJvcGVydGllcy5ncmlkID0ge1xuICAgICAgICB5OiB7XG4gICAgICAgICAgb2Zmc2V0OiAtbGF5b3V0LmNlbGxIZWlnaHQgKiAoY2VsbFBhZGRpbmcvMiksXG4gICAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZShzKSAtLSB2ZWdhIGRvZXNuJ3QgZG8gcmVjdXJzaXZlIG1lcmdlXG4gICAgICAgICAgc2NhbGU6ICdyb3cnXG4gICAgICAgIH0sXG4gICAgICAgIHg6IHtcbiAgICAgICAgICB2YWx1ZTogZGVmLm9mZnNldFxuICAgICAgICB9LFxuICAgICAgICB4Mjoge1xuICAgICAgICAgIG9mZnNldDogZGVmLm9mZnNldCArIChsYXlvdXQuY2VsbFdpZHRoICogMC4wNSksXG4gICAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZShzKSAtLSB2ZWdhIGRvZXNuJ3QgZG8gcmVjdXJzaXZlIG1lcmdlXG4gICAgICAgICAgZ3JvdXA6ICdtYXJrLmdyb3VwLndpZHRoJyxcbiAgICAgICAgICBtdWx0OiAxXG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZTogeyB2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdjZWxsR3JpZENvbG9yJykgfSxcbiAgICAgICAgb3BhY2l0eTogeyB2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdjZWxsR3JpZE9wYWNpdHknKSB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWYucHJvcGVydGllcy5ncmlkID0ge1xuICAgICAgICBzdHJva2U6IHsgdmFsdWU6IGVuY29kaW5nLmNvbmZpZygnZ3JpZENvbG9yJykgfSxcbiAgICAgICAgb3BhY2l0eTogeyB2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdncmlkT3BhY2l0eScpIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWY7XG59O1xuXG5heGlzLmhpZGVUaWNrcyA9IGZ1bmN0aW9uKGRlZikge1xuICBkZWYucHJvcGVydGllcy50aWNrcyA9IHtvcGFjaXR5OiB7dmFsdWU6IDB9fTtcbiAgZGVmLnByb3BlcnRpZXMubWFqb3JUaWNrcyA9IHtvcGFjaXR5OiB7dmFsdWU6IDB9fTtcbiAgZGVmLnByb3BlcnRpZXMuYXhpcyA9IHtvcGFjaXR5OiB7dmFsdWU6IDB9fTtcbiAgcmV0dXJuIGRlZjtcbn07XG5cbmF4aXMudGl0bGUgPSBmdW5jdGlvbiAoZGVmLCBuYW1lLCBlbmNvZGluZywgbGF5b3V0KSB7XG4gIHZhciBheCA9IGVuY29kaW5nLmZpZWxkKG5hbWUpLmF4aXM7XG5cbiAgaWYgKGF4LnRpdGxlKSB7XG4gICAgZGVmLnRpdGxlID0gYXgudGl0bGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgbm90IGRlZmluZWQsIGF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lIGF4aXMgdGl0bGUgZnJvbSBmaWVsZCBkZWZcbiAgICB2YXIgZmllbGRUaXRsZSA9IGVuY29kaW5nLmZpZWxkVGl0bGUobmFtZSksXG4gICAgICBtYXhMZW5ndGg7XG5cbiAgICBpZiAoYXgudGl0bGVNYXhMZW5ndGgpIHtcbiAgICAgIG1heExlbmd0aCA9IGF4LnRpdGxlTWF4TGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAobmFtZT09PVgpIHtcbiAgICAgIG1heExlbmd0aCA9IGxheW91dC5jZWxsV2lkdGggLyBlbmNvZGluZy5jb25maWcoJ2NoYXJhY3RlcldpZHRoJyk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBZKSB7XG4gICAgICBtYXhMZW5ndGggPSBsYXlvdXQuY2VsbEhlaWdodCAvIGVuY29kaW5nLmNvbmZpZygnY2hhcmFjdGVyV2lkdGgnKTtcbiAgICB9XG5cbiAgICBkZWYudGl0bGUgPSBtYXhMZW5ndGggPyB1dGlsLnRydW5jYXRlKGZpZWxkVGl0bGUsIG1heExlbmd0aCkgOiBmaWVsZFRpdGxlO1xuICB9XG5cbiAgaWYgKG5hbWUgPT09IFJPVykge1xuICAgIGRlZi5wcm9wZXJ0aWVzLnRpdGxlID0ge1xuICAgICAgYW5nbGU6IHt2YWx1ZTogMH0sXG4gICAgICBhbGlnbjoge3ZhbHVlOiAncmlnaHQnfSxcbiAgICAgIGJhc2VsaW5lOiB7dmFsdWU6ICdtaWRkbGUnfSxcbiAgICAgIGR5OiB7dmFsdWU6ICgtbGF5b3V0LmhlaWdodC8yKSAtMjB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBkZWY7XG59O1xuXG5heGlzLmxhYmVscyA9IHt9O1xuXG4vKiogYWRkIGN1c3RvbSBsYWJlbCBmb3IgdGltZSB0eXBlIGFuZCBiaW4gKi9cbmF4aXMubGFiZWxzLnNjYWxlID0gZnVuY3Rpb24oZGVmLCBlbmNvZGluZywgbmFtZSkge1xuICAvLyB0aW1lXG4gIHZhciB0aW1lVW5pdCA9IGVuY29kaW5nLmZpZWxkKG5hbWUpLnRpbWVVbml0O1xuICBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFQpICYmIHRpbWVVbml0ICYmICh0aW1lLmhhc1NjYWxlKHRpbWVVbml0KSkpIHtcbiAgICBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCdsYWJlbHMnLCd0ZXh0Jywnc2NhbGUnXSwgJ3RpbWUtJysgdGltZVVuaXQpO1xuICB9XG4gIC8vIEZJWE1FIGJpblxuICByZXR1cm4gZGVmO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgbnVtYmVyIGZvcm1hdCBvciB0cnVuY2F0ZSBpZiBtYXhMYWJlbCBsZW5ndGggaXMgcHJlc2VudGVkLlxuICovXG5heGlzLmxhYmVscy5mb3JtYXQgPSBmdW5jdGlvbiAoZGVmLCBuYW1lLCBlbmNvZGluZywgc3RhdHMpIHtcbiAgdmFyIGZpZWxkU3RhdHMgPSBzdGF0c1tlbmNvZGluZy5maWVsZChuYW1lKS5uYW1lXTtcblxuICBpZiAoZW5jb2RpbmcuYXhpcyhuYW1lKS5mb3JtYXQpIHtcbiAgICBkZWYuZm9ybWF0ID0gZW5jb2RpbmcuYXhpcyhuYW1lKS5mb3JtYXQ7XG4gIH0gZWxzZSBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFEpIHx8IGZpZWxkU3RhdHMudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICBkZWYuZm9ybWF0ID0gZW5jb2RpbmcubnVtYmVyRm9ybWF0KGZpZWxkU3RhdHMpO1xuICB9IGVsc2UgaWYgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBUKSkge1xuICAgIHZhciB0aW1lVW5pdCA9IGVuY29kaW5nLmZpZWxkKG5hbWUpLnRpbWVVbml0O1xuICAgIGlmICghdGltZVVuaXQpIHtcbiAgICAgIGRlZi5mb3JtYXQgPSBlbmNvZGluZy5jb25maWcoJ3RpbWVGb3JtYXQnKTtcbiAgICB9IGVsc2UgaWYgKHRpbWVVbml0ID09PSAneWVhcicpIHtcbiAgICAgIGRlZi5mb3JtYXQgPSAnZCc7XG4gICAgfVxuICB9IGVsc2UgaWYgKGVuY29kaW5nLmlzVHlwZXMobmFtZSwgW04sIE9dKSAmJiBlbmNvZGluZy5heGlzKG5hbWUpLm1heExhYmVsTGVuZ3RoKSB7XG4gICAgc2V0dGVyKGRlZixcbiAgICAgIFsncHJvcGVydGllcycsJ2xhYmVscycsJ3RleHQnLCd0ZW1wbGF0ZSddLFxuICAgICAgJ3t7ZGF0YSB8IHRydW5jYXRlOicgKyBlbmNvZGluZy5heGlzKG5hbWUpLm1heExhYmVsTGVuZ3RoICsgJ319J1xuICAgICAgKTtcbiAgfVxuXG4gIHJldHVybiBkZWY7XG59O1xuXG5heGlzLmxhYmVscy5hbmdsZSA9IGZ1bmN0aW9uKGRlZiwgZW5jb2RpbmcsIG5hbWUpIHtcbiAgdmFyIGFuZ2xlID0gZW5jb2RpbmcuYXhpcyhuYW1lKS5sYWJlbEFuZ2xlO1xuICBpZiAodHlwZW9mIGFuZ2xlID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGRlZjtcblxuICBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCAnbGFiZWxzJywgJ2FuZ2xlJywgJ3ZhbHVlJ10sIGFuZ2xlKTtcbiAgcmV0dXJuIGRlZjtcbn07XG5cbmF4aXMubGFiZWxzLnJvdGF0ZSA9IGZ1bmN0aW9uKGRlZikge1xuIHZhciBhbGlnbiA9IGRlZi5vcmllbnQgPT09J3RvcCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsJ2xhYmVscycsICdhbmdsZScsICd2YWx1ZSddLCAyNzApO1xuIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsJ2xhYmVscycsICdhbGlnbicsICd2YWx1ZSddLCBhbGlnbik7XG4gc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywnbGFiZWxzJywgJ2Jhc2VsaW5lJywgJ3ZhbHVlJ10sICdtaWRkbGUnKTtcbiByZXR1cm4gZGVmO1xufTtcblxuYXhpcy50aXRsZU9mZnNldCA9IGZ1bmN0aW9uIChlbmNvZGluZywgbGF5b3V0LCBuYW1lKSB7XG4gIC8vIHJldHVybiBzcGVjaWZpZWQgdmFsdWUgaWYgc3BlY2lmaWVkXG4gIHZhciB2YWx1ZSA9IGVuY29kaW5nLmF4aXMobmFtZSkudGl0bGVPZmZzZXQ7XG4gIGlmICh2YWx1ZSkgIHJldHVybiB2YWx1ZTtcblxuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAvL0ZJWE1FIG1ha2UgdGhpcyBhZGp1c3RhYmxlXG4gICAgY2FzZSBST1c6IHJldHVybiAwO1xuICAgIGNhc2UgQ09MOiByZXR1cm4gMzU7XG4gIH1cbiAgcmV0dXJuIGdldHRlcihsYXlvdXQsIFtuYW1lLCAnYXhpc1RpdGxlT2Zmc2V0J10pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN1bW1hcnkgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2RhdGFsaWIvc3JjL3N0YXRzJykuc3VtbWFyeTtcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG4vKipcbiAqIE1vZHVsZSBmb3IgY29tcGlsaW5nIFZlZ2EtbGl0ZSBzcGVjIGludG8gVmVnYSBzcGVjLlxuICovXG52YXIgY29tcGlsZXIgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG52YXIgRW5jb2RpbmcgPSByZXF1aXJlKCcuLi9FbmNvZGluZycpLFxuICBheGlzID0gY29tcGlsZXIuYXhpcyA9IHJlcXVpcmUoJy4vYXhpcycpLFxuICBsZWdlbmQgPSBjb21waWxlci5sZWdlbmQgPSByZXF1aXJlKCcuL2xlZ2VuZCcpLFxuICBtYXJrcyA9IGNvbXBpbGVyLm1hcmtzID0gcmVxdWlyZSgnLi9tYXJrcycpLFxuICBzY2FsZSA9IGNvbXBpbGVyLnNjYWxlID0gcmVxdWlyZSgnLi9zY2FsZScpO1xuXG5jb21waWxlci5kYXRhID0gcmVxdWlyZSgnLi9kYXRhJyk7XG5jb21waWxlci5mYWNldCA9IHJlcXVpcmUoJy4vZmFjZXQnKTtcbmNvbXBpbGVyLmxheW91dCA9IHJlcXVpcmUoJy4vbGF5b3V0Jyk7XG5jb21waWxlci5zb3J0ID0gcmVxdWlyZSgnLi9zb3J0Jyk7XG5jb21waWxlci5zdGFjayA9IHJlcXVpcmUoJy4vc3RhY2snKTtcbmNvbXBpbGVyLnN0eWxlID0gcmVxdWlyZSgnLi9zdHlsZScpO1xuY29tcGlsZXIuc3ViZmFjZXQgPSByZXF1aXJlKCcuL3N1YmZhY2V0Jyk7XG5jb21waWxlci50aW1lID0gcmVxdWlyZSgnLi90aW1lJyk7XG5cbmNvbXBpbGVyLmNvbXBpbGUgPSBmdW5jdGlvbiAoc3BlYywgc3RhdHMsIHRoZW1lKSB7XG4gIHJldHVybiBjb21waWxlci5jb21waWxlRW5jb2RpbmcoRW5jb2RpbmcuZnJvbVNwZWMoc3BlYywgdGhlbWUpLCBzdGF0cyk7XG59O1xuXG5jb21waWxlci5zaG9ydGhhbmQgPSBmdW5jdGlvbiAoc2hvcnRoYW5kLCBzdGF0cywgY29uZmlnLCB0aGVtZSkge1xuICByZXR1cm4gY29tcGlsZXIuY29tcGlsZUVuY29kaW5nKEVuY29kaW5nLmZyb21TaG9ydGhhbmQoc2hvcnRoYW5kLCBjb25maWcsIHRoZW1lKSwgc3RhdHMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBWZWdhIHNwZWNpZmljYXRpb24gZnJvbSBhIFZlZ2EtbGl0ZSBFbmNvZGluZyBvYmplY3QuXG4gKi9cbmNvbXBpbGVyLmNvbXBpbGVFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZywgc3RhdHMpIHtcbiAgLy8gbm8gbmVlZCB0byBwYXNzIHN0YXRzIGlmIHlvdSBwYXNzIGluIHRoZSBkYXRhXG4gIGlmICghc3RhdHMpIHtcbiAgICBpZiAoZW5jb2RpbmcuaGFzVmFsdWVzKCkpIHtcbiAgICAgICAgc3RhdHMgPSBzdW1tYXJ5KGVuY29kaW5nLmRhdGEoKS52YWx1ZXMpLnJlZHVjZShmdW5jdGlvbihzLCBwKSB7XG4gICAgICAgIHNbcC5maWVsZF0gPSBwO1xuICAgICAgICByZXR1cm4gcztcbiAgICAgIH0sIHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignTm8gc3RhdHMgcHJvdmlkZWQgYW5kIGRhdGEgaXMgbm90IGVtYmVkZGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsYXlvdXQgPSBjb21waWxlci5sYXlvdXQoZW5jb2RpbmcsIHN0YXRzKTtcblxuICB2YXIgc3BlYyA9IHtcbiAgICAgIHdpZHRoOiBsYXlvdXQud2lkdGgsXG4gICAgICBoZWlnaHQ6IGxheW91dC5oZWlnaHQsXG4gICAgICBwYWRkaW5nOiAnYXV0bycsXG4gICAgICBkYXRhOiBjb21waWxlci5kYXRhKGVuY29kaW5nKSxcbiAgICAgIC8vIGdsb2JhbCBzY2FsZXMgY29udGFpbnMgb25seSB0aW1lIHVuaXQgc2NhbGVzXG4gICAgICBzY2FsZXM6IGNvbXBpbGVyLnRpbWUuc2NhbGVzKGVuY29kaW5nKSxcbiAgICAgIG1hcmtzOiBbe1xuICAgICAgICBfbmFtZTogJ2NlbGwnLFxuICAgICAgICB0eXBlOiAnZ3JvdXAnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgZW50ZXI6IHtcbiAgICAgICAgICAgIHdpZHRoOiBsYXlvdXQuY2VsbFdpZHRoID8ge3ZhbHVlOiBsYXlvdXQuY2VsbFdpZHRofSA6IHtncm91cDogJ3dpZHRoJ30sXG4gICAgICAgICAgICBoZWlnaHQ6IGxheW91dC5jZWxsSGVpZ2h0ID8ge3ZhbHVlOiBsYXlvdXQuY2VsbEhlaWdodH0gOiB7Z3JvdXA6ICdoZWlnaHQnfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfV1cbiAgICB9O1xuXG4gIHZhciBncm91cCA9IHNwZWMubWFya3NbMF07XG5cbiAgLy8gRklYTUUgcmVtb3ZlIGNvbXBpbGVyLnNvcnQgYWZ0ZXIgbWlncmF0aW5nIHRvIHZlZ2EgMi5cbiAgc3BlYy5kYXRhID0gY29tcGlsZXIuc29ydChzcGVjLmRhdGEsIGVuY29kaW5nLCBzdGF0cyk7IC8vIGFwcGVuZCBuZXcgZGF0YVxuXG4gIC8vIG1hcmtzXG4gIHZhciBzdHlsZSA9IGNvbXBpbGVyLnN0eWxlKGVuY29kaW5nLCBzdGF0cyksXG4gICAgbWRlZnMgPSBncm91cC5tYXJrcyA9IG1hcmtzLmRlZihlbmNvZGluZywgbGF5b3V0LCBzdHlsZSwgc3RhdHMpLFxuICAgIG1kZWYgPSBtZGVmc1ttZGVmcy5sZW5ndGggLSAxXTsgIC8vIFRPRE86IHJlbW92ZSB0aGlzIGRpcnR5IGhhY2sgYnkgcmVmYWN0b3JpbmcgdGhlIHdob2xlIGZsb3dcblxuICB2YXIgbGluZVR5cGUgPSBtYXJrc1tlbmNvZGluZy5tYXJrdHlwZSgpXS5saW5lO1xuXG4gIC8vIGhhbmRsZSBzdWJmYWNldHNcblxuICB2YXIgZGV0YWlscyA9IGVuY29kaW5nLmRldGFpbHMoKSxcbiAgICBzdGFjayA9IGVuY29kaW5nLmlzQWdncmVnYXRlKCkgJiYgZGV0YWlscy5sZW5ndGggPiAwICYmIGNvbXBpbGVyLnN0YWNrKHNwZWMuZGF0YSwgZW5jb2RpbmcsIG1kZWYpOyAvLyBtb2RpZnkgc3BlYy5kYXRhLCBtZGVmLntmcm9tLHByb3BlcnRpZXN9XG5cbiAgaWYgKGRldGFpbHMubGVuZ3RoID4gMCAmJiAoc3RhY2sgfHwgbGluZVR5cGUpKSB7XG4gICAgLy9zdWJmYWNldCB0byBncm91cCBzdGFjayAvIGxpbmUgdG9nZXRoZXIgaW4gb25lIGdyb3VwXG4gICAgY29tcGlsZXIuc3ViZmFjZXQoZ3JvdXAsIG1kZWYsIGRldGFpbHMsIHN0YWNrLCBlbmNvZGluZyk7XG4gIH1cblxuICAvLyBhdXRvLXNvcnQgbGluZS9hcmVhIHZhbHVlc1xuICBpZiAobGluZVR5cGUgJiYgZW5jb2RpbmcuY29uZmlnKCdhdXRvU29ydExpbmUnKSkge1xuICAgIHZhciBmID0gKGVuY29kaW5nLmlzTWVhc3VyZShYKSAmJiBlbmNvZGluZy5pc0RpbWVuc2lvbihZKSkgPyBZIDogWDtcbiAgICBpZiAoIW1kZWYuZnJvbSkgbWRlZi5mcm9tID0ge307XG4gICAgLy8gVE9ETzogd2h5IC0gP1xuICAgIG1kZWYuZnJvbS50cmFuc2Zvcm0gPSBbe3R5cGU6ICdzb3J0JywgYnk6ICctJyArIGVuY29kaW5nLmZpZWxkUmVmKGYpfV07XG4gIH1cblxuICAvLyBnZXQgYSBmbGF0dGVuZWQgbGlzdCBvZiBhbGwgc2NhbGUgbmFtZXMgdGhhdCBhcmUgdXNlZCBpbiB0aGUgdmwgc3BlY1xuICB2YXIgc2luZ2xlU2NhbGVOYW1lcyA9IFtdLmNvbmNhdC5hcHBseShbXSwgbWRlZnMubWFwKGZ1bmN0aW9uKG1hcmtQcm9wcykge1xuICAgIHJldHVybiBzY2FsZS5uYW1lcyhtYXJrUHJvcHMucHJvcGVydGllcy51cGRhdGUpO1xuICB9KSk7XG5cbiAgLy8gU21hbGwgTXVsdGlwbGVzXG4gIGlmIChlbmNvZGluZy5oYXMoUk9XKSB8fCBlbmNvZGluZy5oYXMoQ09MKSkge1xuICAgIHNwZWMgPSBjb21waWxlci5mYWNldChncm91cCwgZW5jb2RpbmcsIGxheW91dCwgc3BlYywgc2luZ2xlU2NhbGVOYW1lcywgc3RhY2ssIHN0YXRzKTtcbiAgICBzcGVjLmxlZ2VuZHMgPSBsZWdlbmQuZGVmcyhlbmNvZGluZywgc3R5bGUpO1xuICB9IGVsc2Uge1xuICAgIGdyb3VwLnNjYWxlcyA9IHNjYWxlLmRlZnMoc2luZ2xlU2NhbGVOYW1lcywgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMsIHtzdGFjazogc3RhY2t9KTtcblxuICAgIGdyb3VwLmF4ZXMgPSBbXTtcbiAgICBpZiAoZW5jb2RpbmcuaGFzKFgpKSBncm91cC5heGVzLnB1c2goYXhpcy5kZWYoWCwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpKTtcbiAgICBpZiAoZW5jb2RpbmcuaGFzKFkpKSBncm91cC5heGVzLnB1c2goYXhpcy5kZWYoWSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpKTtcblxuICAgIGdyb3VwLmxlZ2VuZHMgPSBsZWdlbmQuZGVmcyhlbmNvZGluZywgc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHNwZWM7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkYXRhO1xuXG52YXIgdmxmaWVsZCA9IHJlcXVpcmUoJy4uL2ZpZWxkJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIHRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKTtcblxuLyoqXG4gKiBDcmVhdGUgVmVnYSdzIGRhdGEgYXJyYXkgZnJvbSBhIGdpdmVuIGVuY29kaW5nLlxuICpcbiAqIEBwYXJhbSAge0VuY29kaW5nfSBlbmNvZGluZ1xuICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIFZlZ2EgZGF0YS5cbiAqICAgICAgICAgICAgICAgICBUaGlzIGFsd2F5cyBpbmNsdWRlcyBhIFwicmF3XCIgZGF0YSB0YWJsZS5cbiAqICAgICAgICAgICAgICAgICBJZiB0aGUgZW5jb2RpbmcgY29udGFpbnMgYWdncmVnYXRlIHZhbHVlLCB0aGlzIHdpbGwgYWxzbyBjcmVhdGVcbiAqICAgICAgICAgICAgICAgICBhZ2dyZWdhdGUgdGFibGUgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gZGF0YShlbmNvZGluZykge1xuICB2YXIgZGVmID0gW2RhdGEucmF3KGVuY29kaW5nKV07XG5cbiAgdmFyIGFnZ3JlZ2F0ZSA9IGRhdGEuYWdncmVnYXRlKGVuY29kaW5nKTtcbiAgaWYgKGFnZ3JlZ2F0ZSkgZGVmLnB1c2goZGF0YS5hZ2dyZWdhdGUoZW5jb2RpbmcpKTtcblxuICAvLyBUT0RPIGFkZCBcImhhdmluZ1wiIGZpbHRlciBoZXJlXG5cbiAgLy8gYXBwZW5kIG5vbi1wb3NpdGl2ZSBmaWx0ZXIgYXQgdGhlIGVuZCBmb3IgdGhlIGRhdGEgdGFibGVcbiAgZGF0YS5maWx0ZXJOb25Qb3NpdGl2ZShkZWZbZGVmLmxlbmd0aCAtIDFdLCBlbmNvZGluZyk7XG5cbiAgcmV0dXJuIGRlZjtcbn1cblxuZGF0YS5yYXcgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB2YXIgcmF3ID0ge25hbWU6IFJBV307XG5cbiAgLy8gRGF0YSBzb3VyY2UgKHVybCBvciBpbmxpbmUpXG4gIGlmIChlbmNvZGluZy5oYXNWYWx1ZXMoKSkge1xuICAgIHJhdy52YWx1ZXMgPSBlbmNvZGluZy5kYXRhKCkudmFsdWVzO1xuICB9IGVsc2Uge1xuICAgIHJhdy51cmwgPSBlbmNvZGluZy5kYXRhKCkudXJsO1xuICAgIHJhdy5mb3JtYXQgPSB7dHlwZTogZW5jb2RpbmcuZGF0YSgpLmZvcm1hdFR5cGV9O1xuICB9XG5cbiAgLy8gU2V0IGRhdGEncyBmb3JtYXQucGFyc2UgaWYgbmVlZGVkXG4gIHZhciBwYXJzZSA9IGRhdGEucmF3LmZvcm1hdFBhcnNlKGVuY29kaW5nKTtcbiAgaWYgKHBhcnNlKSB7XG4gICAgcmF3LmZvcm1hdCA9IHJhdy5mb3JtYXQgfHwge307XG4gICAgcmF3LmZvcm1hdC5wYXJzZSA9IHBhcnNlO1xuICB9XG5cbiAgcmF3LnRyYW5zZm9ybSA9IGRhdGEucmF3LnRyYW5zZm9ybShlbmNvZGluZyk7XG4gIHJldHVybiByYXc7XG59O1xuXG5kYXRhLnJhdy5mb3JtYXRQYXJzZSA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHZhciBwYXJzZTtcblxuICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkLnR5cGUgPT0gVCkge1xuICAgICAgcGFyc2UgPSBwYXJzZSB8fCB7fTtcbiAgICAgIHBhcnNlW2ZpZWxkLm5hbWVdID0gJ2RhdGUnO1xuICAgIH0gZWxzZSBpZiAoZmllbGQudHlwZSA9PSBRKSB7XG4gICAgICBpZiAodmxmaWVsZC5pc0NvdW50KGZpZWxkKSkgcmV0dXJuO1xuICAgICAgcGFyc2UgPSBwYXJzZSB8fCB7fTtcbiAgICAgIHBhcnNlW2ZpZWxkLm5hbWVdID0gJ251bWJlcic7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2U7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIFZlZ2EgdHJhbnNmb3JtcyBmb3IgdGhlIHJhdyBkYXRhIHRhYmxlLiAgVGhpcyBjYW4gaW5jbHVkZVxuICogdHJhbnNmb3JtcyBmb3IgdGltZSB1bml0LCBiaW5uaW5nIGFuZCBmaWx0ZXJpbmcuXG4gKi9cbmRhdGEucmF3LnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIC8vIHRpbWUgYW5kIGJpbiBzaG91bGQgY29tZSBiZWZvcmUgZmlsdGVyIHNvIHdlIGNhbiBmaWx0ZXIgYnkgdGltZSBhbmQgYmluXG4gIHJldHVybiBkYXRhLnJhdy50cmFuc2Zvcm0udGltZShlbmNvZGluZykuY29uY2F0KFxuICAgIGRhdGEucmF3LnRyYW5zZm9ybS5iaW4oZW5jb2RpbmcpLFxuICAgIGRhdGEucmF3LnRyYW5zZm9ybS5maWx0ZXIoZW5jb2RpbmcpXG4gICk7XG59O1xuXG52YXIgQklOQVJZID0ge1xuICAnPic6ICB0cnVlLFxuICAnPj0nOiB0cnVlLFxuICAnPSc6ICB0cnVlLFxuICAnIT0nOiB0cnVlLFxuICAnPCc6ICB0cnVlLFxuICAnPD0nOiB0cnVlXG59O1xuXG5kYXRhLnJhdy50cmFuc2Zvcm0udGltZSA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHJldHVybiBlbmNvZGluZy5yZWR1Y2UoZnVuY3Rpb24odHJhbnNmb3JtLCBmaWVsZCwgZW5jVHlwZSkge1xuICAgIGlmIChmaWVsZC50eXBlID09PSBUICYmIGZpZWxkLnRpbWVVbml0KSB7XG4gICAgICB0cmFuc2Zvcm0ucHVzaCh7XG4gICAgICAgIHR5cGU6ICdmb3JtdWxhJyxcbiAgICAgICAgZmllbGQ6IGVuY29kaW5nLmZpZWxkUmVmKGVuY1R5cGUpLFxuICAgICAgICBleHByOiB0aW1lLmZvcm11bGEoZmllbGQudGltZVVuaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZy5maWVsZFJlZihlbmNUeXBlLCB7bm9mbjogdHJ1ZSwgZDogdHJ1ZX0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmb3JtO1xuICB9LCBbXSk7XG59O1xuXG5kYXRhLnJhdy50cmFuc2Zvcm0uYmluID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGVuY29kaW5nLnJlZHVjZShmdW5jdGlvbih0cmFuc2Zvcm0sIGZpZWxkLCBlbmNUeXBlKSB7XG4gICAgaWYgKGVuY29kaW5nLmJpbihlbmNUeXBlKSkge1xuICAgICAgdHJhbnNmb3JtLnB1c2goe1xuICAgICAgICB0eXBlOiAnYmluJyxcbiAgICAgICAgZmllbGQ6IGVuY29kaW5nLmZpZWxkUmVmKGVuY1R5cGUsIHtub2ZuOiB0cnVlfSksXG4gICAgICAgIG91dHB1dDogZW5jb2RpbmcuZmllbGRSZWYoZW5jVHlwZSksXG4gICAgICAgIG1heGJpbnM6IGVuY29kaW5nLmJpbihlbmNUeXBlKS5tYXhiaW5zXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZm9ybTtcbiAgfSwgW10pO1xufTtcblxuZGF0YS5yYXcudHJhbnNmb3JtLmZpbHRlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHZhciBmaWx0ZXJzID0gZW5jb2RpbmcuZmlsdGVyKCkucmVkdWNlKGZ1bmN0aW9uKGYsIGZpbHRlcikge1xuICAgIHZhciBjb25kaXRpb24gPSAnJztcbiAgICB2YXIgb3BlcmF0b3IgPSBmaWx0ZXIub3BlcmF0b3I7XG4gICAgdmFyIG9wZXJhbmRzID0gZmlsdGVyLm9wZXJhbmRzO1xuXG4gICAgdmFyIGQgPSAnZC4nICsgKGVuY29kaW5nLl92ZWdhMiA/ICcnIDogJ2RhdGEuJyk7XG5cbiAgICBpZiAoQklOQVJZW29wZXJhdG9yXSkge1xuICAgICAgLy8gZXhwZWN0cyBhIGZpZWxkIGFuZCBhIHZhbHVlXG4gICAgICBpZiAob3BlcmF0b3IgPT09ICc9Jykge1xuICAgICAgICBvcGVyYXRvciA9ICc9PSc7XG4gICAgICB9XG5cbiAgICAgIHZhciBvcDEgPSBvcGVyYW5kc1swXTtcbiAgICAgIHZhciBvcDIgPSBvcGVyYW5kc1sxXTtcbiAgICAgIGNvbmRpdGlvbiA9IGQgKyBvcDEgKyAnICcgKyBvcGVyYXRvciArICcgJyArIG9wMjtcbiAgICB9IGVsc2UgaWYgKG9wZXJhdG9yID09PSAnbm90TnVsbCcpIHtcbiAgICAgIC8vIGV4cGVjdHMgYSBudW1iZXIgb2YgZmllbGRzXG4gICAgICBmb3IgKHZhciBqPTA7IGo8b3BlcmFuZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uZGl0aW9uICs9IGQgKyBvcGVyYW5kc1tqXSArICchPT1udWxsJztcbiAgICAgICAgaWYgKGogPCBvcGVyYW5kcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgY29uZGl0aW9uICs9ICcgJiYgJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLndhcm4oJ1Vuc3VwcG9ydGVkIG9wZXJhdG9yOiAnLCBvcGVyYXRvcik7XG4gICAgICByZXR1cm4gZjtcbiAgICB9XG4gICAgZi5wdXNoKCcoJyArIGNvbmRpdGlvbiArICcpJyk7XG4gICAgcmV0dXJuIGY7XG4gIH0sIFtdKTtcbiAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG5cbiAgcmV0dXJuIFt7XG4gICAgICB0eXBlOiAnZmlsdGVyJyxcbiAgICAgIHRlc3Q6IGZpbHRlcnMuam9pbignICYmICcpXG4gIH1dO1xufTtcblxuZGF0YS5hZ2dyZWdhdGUgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB2YXIgZGltcyA9IHt9LCBtZWFzID0ge307XG5cbiAgZW5jb2RpbmcuZm9yRWFjaChmdW5jdGlvbihmaWVsZCwgZW5jVHlwZSkge1xuICAgIGlmIChmaWVsZC5hZ2dyZWdhdGUpIHtcbiAgICAgIGlmIChmaWVsZC5hZ2dyZWdhdGUgPT09ICdjb3VudCcpIHtcbiAgICAgICAgbWVhcy5jb3VudCA9IHtvcDogJ2NvdW50JywgZmllbGQ6ICcqJ307XG4gICAgICB9ZWxzZSB7XG4gICAgICAgIG1lYXNbZmllbGQuYWdncmVnYXRlICsgJ3wnICsgZmllbGQubmFtZV0gPSB7XG4gICAgICAgICAgb3A6IGZpZWxkLmFnZ3JlZ2F0ZSxcbiAgICAgICAgICBmaWVsZDogZW5jb2RpbmcuZmllbGRSZWYoZW5jVHlwZSwge25vZm46IHRydWV9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkaW1zW2ZpZWxkLm5hbWVdID0gZW5jb2RpbmcuZmllbGRSZWYoZW5jVHlwZSk7XG4gICAgfVxuICB9KTtcblxuICBkaW1zID0gdXRpbC52YWxzKGRpbXMpO1xuICBtZWFzID0gdXRpbC52YWxzKG1lYXMpO1xuXG4gIGlmIChtZWFzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogQUdHUkVHQVRFLFxuICAgICAgc291cmNlOiBSQVcsXG4gICAgICB0cmFuc2Zvcm06IFt7XG4gICAgICAgIHR5cGU6ICdhZ2dyZWdhdGUnLFxuICAgICAgICBncm91cGJ5OiBkaW1zLFxuICAgICAgICBmaWVsZHM6IG1lYXNcbiAgICAgIH1dXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuZGF0YS5maWx0ZXJOb25Qb3NpdGl2ZSA9IGZ1bmN0aW9uKGRhdGFUYWJsZSwgZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcuZm9yRWFjaChmdW5jdGlvbihmaWVsZCwgZW5jVHlwZSkge1xuICAgIGlmIChlbmNvZGluZy5zY2FsZShlbmNUeXBlKS50eXBlID09PSAnbG9nJykge1xuICAgICAgZGF0YVRhYmxlLnRyYW5zZm9ybS5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2ZpbHRlcicsXG4gICAgICAgIHRlc3Q6IGVuY29kaW5nLmZpZWxkUmVmKGVuY1R5cGUsIHtkOiAxfSkgKyAnID4gMCdcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgYXhpcyA9IHJlcXVpcmUoJy4vYXhpcycpLFxuICBzY2FsZSA9IHJlcXVpcmUoJy4vc2NhbGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWNldGluZztcblxuZnVuY3Rpb24gZ3JvdXBkZWYobmFtZSwgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgcmV0dXJuIHtcbiAgICBfbmFtZTogbmFtZSB8fCB1bmRlZmluZWQsXG4gICAgdHlwZTogJ2dyb3VwJyxcbiAgICBmcm9tOiBvcHQuZnJvbSxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICB4OiBvcHQueCB8fCB1bmRlZmluZWQsXG4gICAgICAgIHk6IG9wdC55IHx8IHVuZGVmaW5lZCxcbiAgICAgICAgd2lkdGg6IG9wdC53aWR0aCB8fCB7Z3JvdXA6ICd3aWR0aCd9LFxuICAgICAgICBoZWlnaHQ6IG9wdC5oZWlnaHQgfHwge2dyb3VwOiAnaGVpZ2h0J31cbiAgICAgIH1cbiAgICB9LFxuICAgIHNjYWxlczogb3B0LnNjYWxlcyB8fCB1bmRlZmluZWQsXG4gICAgYXhlczogb3B0LmF4ZXMgfHwgdW5kZWZpbmVkLFxuICAgIG1hcmtzOiBvcHQubWFya3MgfHwgW11cbiAgfTtcbn1cblxuZnVuY3Rpb24gZmFjZXRpbmcoZ3JvdXAsIGVuY29kaW5nLCBsYXlvdXQsIHNwZWMsIHNpbmdsZVNjYWxlTmFtZXMsIHN0YWNrLCBzdGF0cykge1xuICB2YXIgZW50ZXIgPSBncm91cC5wcm9wZXJ0aWVzLmVudGVyO1xuICB2YXIgZmFjZXRLZXlzID0gW10sIGNlbGxBeGVzID0gW10sIGZyb20sIGF4ZXNHcnA7XG5cbiAgdmFyIGhhc1JvdyA9IGVuY29kaW5nLmhhcyhST1cpLCBoYXNDb2wgPSBlbmNvZGluZy5oYXMoQ09MKTtcblxuICBlbnRlci5maWxsID0ge3ZhbHVlOiBlbmNvZGluZy5jb25maWcoJ2NlbGxCYWNrZ3JvdW5kQ29sb3InKX07XG5cbiAgLy9tb3ZlIFwiZnJvbVwiIHRvIGNlbGwgbGV2ZWwgYW5kIGFkZCBmYWNldCB0cmFuc2Zvcm1cbiAgZ3JvdXAuZnJvbSA9IHtkYXRhOiBncm91cC5tYXJrc1swXS5mcm9tLmRhdGF9O1xuXG4gIC8vIEhhY2ssIHRoaXMgbmVlZHMgdG8gYmUgcmVmYWN0b3JlZFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLm1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1hcmsgPSBncm91cC5tYXJrc1tpXTtcbiAgICBpZiAobWFyay5mcm9tLnRyYW5zZm9ybSkge1xuICAgICAgZGVsZXRlIG1hcmsuZnJvbS5kYXRhOyAvL25lZWQgdG8ga2VlcCB0cmFuc2Zvcm0gZm9yIHN1YmZhY2V0dGluZyBjYXNlXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBtYXJrLmZyb207XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhc1Jvdykge1xuICAgIGlmICghZW5jb2RpbmcuaXNEaW1lbnNpb24oUk9XKSkge1xuICAgICAgdXRpbC5lcnJvcignUm93IGVuY29kaW5nIHNob3VsZCBiZSBvcmRpbmFsLicpO1xuICAgIH1cbiAgICBlbnRlci55ID0ge3NjYWxlOiBST1csIGZpZWxkOiAna2V5cy4nICsgZmFjZXRLZXlzLmxlbmd0aH07XG4gICAgZW50ZXIuaGVpZ2h0ID0geyd2YWx1ZSc6IGxheW91dC5jZWxsSGVpZ2h0fTsgLy8gSEFDS1xuXG4gICAgZmFjZXRLZXlzLnB1c2goZW5jb2RpbmcuZmllbGRSZWYoUk9XKSk7XG5cbiAgICBpZiAoaGFzQ29sKSB7XG4gICAgICBmcm9tID0gdXRpbC5kdXBsaWNhdGUoZ3JvdXAuZnJvbSk7XG4gICAgICBmcm9tLnRyYW5zZm9ybSA9IGZyb20udHJhbnNmb3JtIHx8IFtdO1xuICAgICAgZnJvbS50cmFuc2Zvcm0udW5zaGlmdCh7dHlwZTogJ2ZhY2V0Jywga2V5czogW2VuY29kaW5nLmZpZWxkUmVmKENPTCldfSk7XG4gICAgfVxuXG4gICAgYXhlc0dycCA9IGdyb3VwZGVmKCd4LWF4ZXMnLCB7XG4gICAgICAgIGF4ZXM6IGVuY29kaW5nLmhhcyhYKSA/IFtheGlzLmRlZihYLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cyldIDogdW5kZWZpbmVkLFxuICAgICAgICB4OiBoYXNDb2wgPyB7c2NhbGU6IENPTCwgZmllbGQ6ICdrZXlzLjAnfSA6IHt2YWx1ZTogMH0sXG4gICAgICAgIHdpZHRoOiBoYXNDb2wgJiYgeyd2YWx1ZSc6IGxheW91dC5jZWxsV2lkdGh9LCAvL0hBQ0s/XG4gICAgICAgIGZyb206IGZyb21cbiAgICAgIH0pO1xuXG4gICAgc3BlYy5tYXJrcy51bnNoaWZ0KGF4ZXNHcnApOyAvLyBuZWVkIHRvIHByZXBlbmQgc28gaXQgYXBwZWFycyB1bmRlciB0aGUgcGxvdHNcbiAgICAoc3BlYy5heGVzID0gc3BlYy5heGVzIHx8IFtdKTtcbiAgICBzcGVjLmF4ZXMucHVzaChheGlzLmRlZihST1csIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSk7XG4gIH0gZWxzZSB7IC8vIGRvZXNuJ3QgaGF2ZSByb3dcbiAgICBpZiAoZW5jb2RpbmcuaGFzKFgpKSB7XG4gICAgICAvL2tlZXAgeCBheGlzIGluIHRoZSBjZWxsXG4gICAgICBjZWxsQXhlcy5wdXNoKGF4aXMuZGVmKFgsIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhc0NvbCkge1xuICAgIGlmICghZW5jb2RpbmcuaXNEaW1lbnNpb24oQ09MKSkge1xuICAgICAgdXRpbC5lcnJvcignQ29sIGVuY29kaW5nIHNob3VsZCBiZSBvcmRpbmFsLicpO1xuICAgIH1cbiAgICBlbnRlci54ID0ge3NjYWxlOiBDT0wsIGZpZWxkOiAna2V5cy4nICsgZmFjZXRLZXlzLmxlbmd0aH07XG4gICAgZW50ZXIud2lkdGggPSB7J3ZhbHVlJzogbGF5b3V0LmNlbGxXaWR0aH07IC8vIEhBQ0tcblxuICAgIGZhY2V0S2V5cy5wdXNoKGVuY29kaW5nLmZpZWxkUmVmKENPTCkpO1xuXG4gICAgaWYgKGhhc1Jvdykge1xuICAgICAgZnJvbSA9IHV0aWwuZHVwbGljYXRlKGdyb3VwLmZyb20pO1xuICAgICAgZnJvbS50cmFuc2Zvcm0gPSBmcm9tLnRyYW5zZm9ybSB8fCBbXTtcbiAgICAgIGZyb20udHJhbnNmb3JtLnVuc2hpZnQoe3R5cGU6ICdmYWNldCcsIGtleXM6IFtlbmNvZGluZy5maWVsZFJlZihST1cpXX0pO1xuICAgIH1cblxuICAgIGF4ZXNHcnAgPSBncm91cGRlZigneS1heGVzJywge1xuICAgICAgYXhlczogZW5jb2RpbmcuaGFzKFkpID8gW2F4aXMuZGVmKFksIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKV0gOiB1bmRlZmluZWQsXG4gICAgICB5OiBoYXNSb3cgJiYge3NjYWxlOiBST1csIGZpZWxkOiAna2V5cy4wJ30sXG4gICAgICB4OiBoYXNSb3cgJiYge3ZhbHVlOiAwfSxcbiAgICAgIGhlaWdodDogaGFzUm93ICYmIHsndmFsdWUnOiBsYXlvdXQuY2VsbEhlaWdodH0sIC8vSEFDSz9cbiAgICAgIGZyb206IGZyb21cbiAgICB9KTtcblxuICAgIHNwZWMubWFya3MudW5zaGlmdChheGVzR3JwKTsgLy8gbmVlZCB0byBwcmVwZW5kIHNvIGl0IGFwcGVhcnMgdW5kZXIgdGhlIHBsb3RzXG4gICAgKHNwZWMuYXhlcyA9IHNwZWMuYXhlcyB8fCBbXSk7XG4gICAgc3BlYy5heGVzLnB1c2goYXhpcy5kZWYoQ09MLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cykpO1xuICB9IGVsc2UgeyAvLyBkb2Vzbid0IGhhdmUgY29sXG4gICAgaWYgKGVuY29kaW5nLmhhcyhZKSkge1xuICAgICAgY2VsbEF4ZXMucHVzaChheGlzLmRlZihZLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cykpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGFzc3VtaW5nIGVxdWFsIGNlbGxXaWR0aCBoZXJlXG4gIC8vIFRPRE86IHN1cHBvcnQgaGV0ZXJvZ2Vub3VzIGNlbGxXaWR0aCAobWF5YmUgYnkgdXNpbmcgbXVsdGlwbGUgc2NhbGVzPylcbiAgc3BlYy5zY2FsZXMgPSAoc3BlYy5zY2FsZXMgfHwgW10pLmNvbmNhdChzY2FsZS5kZWZzKFxuICAgIHNjYWxlLm5hbWVzKGVudGVyKS5jb25jYXQoc2luZ2xlU2NhbGVOYW1lcyksXG4gICAgZW5jb2RpbmcsXG4gICAgbGF5b3V0LFxuICAgIHN0YXRzLFxuICAgIHtzdGFjazogc3RhY2ssIGZhY2V0OiB0cnVlfVxuICApKTsgLy8gcm93L2NvbCBzY2FsZXMgKyBjZWxsIHNjYWxlc1xuXG4gIGlmIChjZWxsQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgZ3JvdXAuYXhlcyA9IGNlbGxBeGVzO1xuICB9XG5cbiAgLy8gYWRkIGZhY2V0IHRyYW5zZm9ybVxuICB2YXIgdHJhbnMgPSAoZ3JvdXAuZnJvbS50cmFuc2Zvcm0gfHwgKGdyb3VwLmZyb20udHJhbnNmb3JtID0gW10pKTtcbiAgdHJhbnMudW5zaGlmdCh7dHlwZTogJ2ZhY2V0Jywga2V5czogZmFjZXRLZXlzfSk7XG5cbiAgcmV0dXJuIHNwZWM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIHNldHRlciA9IHV0aWwuc2V0dGVyLFxuICB0aW1lID0gcmVxdWlyZSgnLi90aW1lJyksXG4gIGQzX2Zvcm1hdCA9IHJlcXVpcmUoJ2QzLWZvcm1hdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZsbGF5b3V0O1xuXG5mdW5jdGlvbiB2bGxheW91dChlbmNvZGluZywgc3RhdHMpIHtcbiAgdmFyIGxheW91dCA9IGJveChlbmNvZGluZywgc3RhdHMpO1xuICBsYXlvdXQgPSBvZmZzZXQoZW5jb2RpbmcsIHN0YXRzLCBsYXlvdXQpO1xuICByZXR1cm4gbGF5b3V0O1xufVxuXG4vKlxuICBIQUNLIHRvIHNldCBjaGFydCBzaXplXG4gIE5PVEU6IHRoaXMgZmFpbHMgZm9yIHBsb3RzIGRyaXZlbiBieSBkZXJpdmVkIHZhbHVlcyAoZS5nLiwgYWdncmVnYXRlcylcbiAgT25lIHNvbHV0aW9uIGlzIHRvIHVwZGF0ZSBWZWdhIHRvIHN1cHBvcnQgYXV0by1zaXppbmdcbiAgSW4gdGhlIG1lYW50aW1lLCBhdXRvLXBhZGRpbmcgKG1vc3RseSkgZG9lcyB0aGUgdHJpY2tcbiAqL1xuZnVuY3Rpb24gYm94KGVuY29kaW5nLCBzdGF0cykge1xuICB2YXIgaGFzUm93ID0gZW5jb2RpbmcuaGFzKFJPVyksXG4gICAgICBoYXNDb2wgPSBlbmNvZGluZy5oYXMoQ09MKSxcbiAgICAgIGhhc1ggPSBlbmNvZGluZy5oYXMoWCksXG4gICAgICBoYXNZID0gZW5jb2RpbmcuaGFzKFkpLFxuICAgICAgbWFya3R5cGUgPSBlbmNvZGluZy5tYXJrdHlwZSgpO1xuXG4gIC8vIEZJWE1FL0hBQ0sgd2UgbmVlZCB0byB0YWtlIGZpbHRlciBpbnRvIGFjY291bnRcbiAgdmFyIHhDYXJkaW5hbGl0eSA9IGhhc1ggJiYgZW5jb2RpbmcuaXNEaW1lbnNpb24oWCkgPyBlbmNvZGluZy5jYXJkaW5hbGl0eShYLCBzdGF0cykgOiAxLFxuICAgIHlDYXJkaW5hbGl0eSA9IGhhc1kgJiYgZW5jb2RpbmcuaXNEaW1lbnNpb24oWSkgPyBlbmNvZGluZy5jYXJkaW5hbGl0eShZLCBzdGF0cykgOiAxO1xuXG4gIHZhciB1c2VTbWFsbEJhbmQgPSB4Q2FyZGluYWxpdHkgPiBlbmNvZGluZy5jb25maWcoJ2xhcmdlQmFuZE1heENhcmRpbmFsaXR5JykgfHxcbiAgICB5Q2FyZGluYWxpdHkgPiBlbmNvZGluZy5jb25maWcoJ2xhcmdlQmFuZE1heENhcmRpbmFsaXR5Jyk7XG5cbiAgdmFyIGNlbGxXaWR0aCwgY2VsbEhlaWdodCwgY2VsbFBhZGRpbmcgPSBlbmNvZGluZy5jb25maWcoJ2NlbGxQYWRkaW5nJyk7XG5cbiAgLy8gc2V0IGNlbGxXaWR0aFxuICBpZiAoaGFzWCkge1xuICAgIGlmIChlbmNvZGluZy5pc09yZGluYWxTY2FsZShYKSkge1xuICAgICAgLy8gZm9yIG9yZGluYWwsIGhhc0NvbCBvciBub3QgZG9lc24ndCBtYXR0ZXIgLS0gd2Ugc2NhbGUgYmFzZWQgb24gY2FyZGluYWxpdHlcbiAgICAgIGNlbGxXaWR0aCA9ICh4Q2FyZGluYWxpdHkgKyBlbmNvZGluZy5maWVsZChYKS5iYW5kLnBhZGRpbmcpICogZW5jb2RpbmcuYmFuZFNpemUoWCwgdXNlU21hbGxCYW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VsbFdpZHRoID0gaGFzQ29sIHx8IGhhc1JvdyA/IGVuY29kaW5nLmZpZWxkKENPTCkud2lkdGggOiAgZW5jb2RpbmcuY29uZmlnKCdzaW5nbGVXaWR0aCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAobWFya3R5cGUgPT09IFRFWFQpIHtcbiAgICAgIGNlbGxXaWR0aCA9IGVuY29kaW5nLmNvbmZpZygndGV4dENlbGxXaWR0aCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZWxsV2lkdGggPSBlbmNvZGluZy5iYW5kU2l6ZShYKTtcbiAgICB9XG4gIH1cblxuICAvLyBzZXQgY2VsbEhlaWdodFxuICBpZiAoaGFzWSkge1xuICAgIGlmIChlbmNvZGluZy5pc09yZGluYWxTY2FsZShZKSkge1xuICAgICAgLy8gZm9yIG9yZGluYWwsIGhhc0NvbCBvciBub3QgZG9lc24ndCBtYXR0ZXIgLS0gd2Ugc2NhbGUgYmFzZWQgb24gY2FyZGluYWxpdHlcbiAgICAgIGNlbGxIZWlnaHQgPSAoeUNhcmRpbmFsaXR5ICsgZW5jb2RpbmcuZmllbGQoWSkuYmFuZC5wYWRkaW5nKSAqIGVuY29kaW5nLmJhbmRTaXplKFksIHVzZVNtYWxsQmFuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbGxIZWlnaHQgPSBoYXNDb2wgfHwgaGFzUm93ID8gZW5jb2RpbmcuZmllbGQoUk9XKS5oZWlnaHQgOiAgZW5jb2RpbmcuY29uZmlnKCdzaW5nbGVIZWlnaHQnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2VsbEhlaWdodCA9IGVuY29kaW5nLmJhbmRTaXplKFkpO1xuICB9XG5cbiAgLy8gQ2VsbCBiYW5kcyB1c2UgcmFuZ2VCYW5kcygpLiBUaGVyZSBhcmUgbi0xIHBhZGRpbmcuICBPdXRlcnBhZGRpbmcgPSAwIGZvciBjZWxsc1xuXG4gIHZhciB3aWR0aCA9IGNlbGxXaWR0aCwgaGVpZ2h0ID0gY2VsbEhlaWdodDtcbiAgaWYgKGhhc0NvbCkge1xuICAgIHZhciBjb2xDYXJkaW5hbGl0eSA9IGVuY29kaW5nLmNhcmRpbmFsaXR5KENPTCwgc3RhdHMpO1xuICAgIHdpZHRoID0gY2VsbFdpZHRoICogKCgxICsgY2VsbFBhZGRpbmcpICogKGNvbENhcmRpbmFsaXR5IC0gMSkgKyAxKTtcbiAgfVxuICBpZiAoaGFzUm93KSB7XG4gICAgdmFyIHJvd0NhcmRpbmFsaXR5ID0gIGVuY29kaW5nLmNhcmRpbmFsaXR5KFJPVywgc3RhdHMpO1xuICAgIGhlaWdodCA9IGNlbGxIZWlnaHQgKiAoKDEgKyBjZWxsUGFkZGluZykgKiAocm93Q2FyZGluYWxpdHkgLSAxKSArIDEpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSB3aG9sZSBjZWxsXG4gICAgY2VsbFdpZHRoOiBjZWxsV2lkdGgsXG4gICAgY2VsbEhlaWdodDogY2VsbEhlaWdodCxcbiAgICBjZWxsUGFkZGluZzogY2VsbFBhZGRpbmcsXG4gICAgLy8gd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgY2hhcnRcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgLy8gaW5mb3JtYXRpb24gYWJvdXQgeCBhbmQgeSwgc3VjaCBhcyBiYW5kIHNpemVcbiAgICB4OiB7dXNlU21hbGxCYW5kOiB1c2VTbWFsbEJhbmR9LFxuICAgIHk6IHt1c2VTbWFsbEJhbmQ6IHVzZVNtYWxsQmFuZH1cbiAgfTtcbn1cblxuXG4vLyBGSVhNRSBmaWVsZFN0YXRzLm1heCBpc24ndCBhbHdheXMgdGhlIGxvbmdlc3RcbmZ1bmN0aW9uIGdldE1heE51bWJlckxlbmd0aChlbmNvZGluZywgZXQsIGZpZWxkU3RhdHMpIHtcbiAgdmFyIGZvcm1hdCA9IGVuY29kaW5nLm51bWJlckZvcm1hdChldCwgZmllbGRTdGF0cyk7XG5cbiAgcmV0dXJuIGQzX2Zvcm1hdC5mb3JtYXQoZm9ybWF0KShmaWVsZFN0YXRzLm1heCkubGVuZ3RoO1xufVxuXG4vLyBUT0RPKCM2MDApIHJldmlzZSB0aGlzXG5mdW5jdGlvbiBnZXRNYXhMZW5ndGgoZW5jb2RpbmcsIHN0YXRzLCBldCkge1xuICB2YXIgZmllbGQgPSBlbmNvZGluZy5maWVsZChldCksXG4gICAgZmllbGRTdGF0cyA9IHN0YXRzW2ZpZWxkLm5hbWVdO1xuXG4gIGlmIChmaWVsZC5iaW4pIHtcbiAgICAvLyBUT0RPIG9uY2UgYmluIHN1cHBvcnQgcmFuZ2UsIG5lZWQgdG8gdXBkYXRlIHRoaXNcbiAgICByZXR1cm4gZ2V0TWF4TnVtYmVyTGVuZ3RoKGVuY29kaW5nLCBldCwgZmllbGRTdGF0cyk7XG4gIH0gaWYgKGVuY29kaW5nLmlzVHlwZShldCwgUSkpIHtcbiAgICByZXR1cm4gZ2V0TWF4TnVtYmVyTGVuZ3RoKGVuY29kaW5nLCBldCwgZmllbGRTdGF0cyk7XG4gIH0gZWxzZSBpZiAoZW5jb2RpbmcuaXNUeXBlKGV0LCBUKSkge1xuICAgIHJldHVybiB0aW1lLm1heExlbmd0aChlbmNvZGluZy5maWVsZChldCkudGltZVVuaXQsIGVuY29kaW5nKTtcbiAgfSBlbHNlIGlmIChlbmNvZGluZy5pc1R5cGVzKGV0LCBbTiwgT10pKSB7XG4gICAgaWYoZmllbGRTdGF0cy50eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGdldE1heE51bWJlckxlbmd0aChlbmNvZGluZywgZXQsIGZpZWxkU3RhdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4oZmllbGRTdGF0cy5tYXgsIGVuY29kaW5nLmF4aXMoZXQpLm1heExhYmVsTGVuZ3RoIHx8IEluZmluaXR5KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb2Zmc2V0KGVuY29kaW5nLCBzdGF0cywgbGF5b3V0KSB7XG4gIFtYLCBZXS5mb3JFYWNoKGZ1bmN0aW9uIChldCkge1xuICAgIC8vIFRPRE8oa2FuaXR3KTogSnVsIDE5LCAyMDE1IC0gY3JlYXRlIGEgc2V0IG9mIHZpc3VhbCB0ZXN0IGZvciBleHRyYU9mZnNldFxuICAgIHZhciBleHRyYU9mZnNldCA9IGV0ID09PSBYID8gMjAgOiAyMixcbiAgICAgIG1heExlbmd0aDtcbiAgICBpZiAoZW5jb2RpbmcuaXNEaW1lbnNpb24oZXQpIHx8IGVuY29kaW5nLmlzVHlwZShldCwgVCkpIHtcbiAgICAgIG1heExlbmd0aCA9IGdldE1heExlbmd0aChlbmNvZGluZywgc3RhdHMsIGV0KTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLy8gVE9ETyBvbmNlIHdlIGhhdmUgIzUxMiAoYWxsb3cgdXNpbmcgaW5mZXJyZWQgdHlwZSlcbiAgICAgIC8vIE5lZWQgdG8gYWRqdXN0IGNvbmRpdGlvbiBoZXJlLlxuICAgICAgZW5jb2RpbmcuaXNUeXBlKGV0LCBRKSB8fFxuICAgICAgZW5jb2RpbmcuYWdncmVnYXRlKGV0KSA9PT0gJ2NvdW50J1xuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBldD09PVlcbiAgICAgICAgLy8gfHwgKGV0PT09WCAmJiBmYWxzZSlcbiAgICAgICAgLy8gRklYTUUgZGV0ZXJtaW5lIHdoZW4gWCB3b3VsZCByb3RhdGUsIGJ1dCBzaG91bGQgbW92ZSB0aGlzIHRvIGF4aXMuanMgZmlyc3QgIzUwNlxuICAgICAgKSB7XG4gICAgICAgIG1heExlbmd0aCA9IGdldE1heExlbmd0aChlbmNvZGluZywgc3RhdHMsIGV0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm90aGluZ1xuICAgIH1cblxuICAgIGlmIChtYXhMZW5ndGgpIHtcbiAgICAgIHNldHRlcihsYXlvdXQsW2V0LCAnYXhpc1RpdGxlT2Zmc2V0J10sIGVuY29kaW5nLmNvbmZpZygnY2hhcmFjdGVyV2lkdGgnKSAqICBtYXhMZW5ndGggKyBleHRyYU9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIG5vIG1heCBsZW5ndGggKG5vIHJvdGF0aW9uIGNhc2UpLCB1c2UgbWF4TGVuZ3RoID0gM1xuICAgICAgc2V0dGVyKGxheW91dCxbZXQsICdheGlzVGl0bGVPZmZzZXQnXSwgZW5jb2RpbmcuY29uZmlnKCdjaGFyYWN0ZXJXaWR0aCcpICogMyArIGV4dHJhT2Zmc2V0KTtcbiAgICB9XG5cbiAgfSk7XG4gIHJldHVybiBsYXlvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIHRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgc2V0dGVyID0gdXRpbC5zZXR0ZXIsXG4gIGdldHRlciA9IHV0aWwuZ2V0dGVyO1xuXG52YXIgbGVnZW5kID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxubGVnZW5kLmRlZnMgPSBmdW5jdGlvbihlbmNvZGluZywgc3R5bGUpIHtcbiAgdmFyIGRlZnMgPSBbXTtcblxuICBpZiAoZW5jb2RpbmcuaGFzKENPTE9SKSAmJiBlbmNvZGluZy5maWVsZChDT0xPUikubGVnZW5kKSB7XG4gICAgZGVmcy5wdXNoKGxlZ2VuZC5kZWYoQ09MT1IsIGVuY29kaW5nLCB7XG4gICAgICBmaWxsOiBDT0xPUixcbiAgICAgIG9yaWVudDogJ3JpZ2h0J1xuICAgIH0sIHN0eWxlKSk7XG4gIH1cblxuICBpZiAoZW5jb2RpbmcuaGFzKFNJWkUpICYmIGVuY29kaW5nLmZpZWxkKFNJWkUpLmxlZ2VuZCkge1xuICAgIGRlZnMucHVzaChsZWdlbmQuZGVmKFNJWkUsIGVuY29kaW5nLCB7XG4gICAgICBzaXplOiBTSVpFLFxuICAgICAgb3JpZW50OiBkZWZzLmxlbmd0aCA9PT0gMSA/ICdsZWZ0JyA6ICdyaWdodCdcbiAgICB9LCBzdHlsZSkpO1xuICB9XG5cbiAgaWYgKGVuY29kaW5nLmhhcyhTSEFQRSkgJiYgZW5jb2RpbmcuZmllbGQoU0hBUEUpLmxlZ2VuZCkge1xuICAgIGlmIChkZWZzLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc29sZS5lcnJvcignVmVnYS1saXRlIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIHR3byBsZWdlbmRzJyk7XG4gICAgfVxuICAgIGRlZnMucHVzaChsZWdlbmQuZGVmKFNIQVBFLCBlbmNvZGluZywge1xuICAgICAgc2hhcGU6IFNIQVBFLFxuICAgICAgb3JpZW50OiBkZWZzLmxlbmd0aCA9PT0gMSA/ICdsZWZ0JyA6ICdyaWdodCdcbiAgICB9LCBzdHlsZSkpO1xuICB9XG4gIHJldHVybiBkZWZzO1xufTtcblxubGVnZW5kLmRlZiA9IGZ1bmN0aW9uKG5hbWUsIGVuY29kaW5nLCBkZWYsIHN0eWxlKSB7XG4gIHZhciB0aW1lVW5pdCA9IGVuY29kaW5nLmZpZWxkKG5hbWUpLnRpbWVVbml0O1xuXG4gIGRlZi50aXRsZSA9IGxlZ2VuZC50aXRsZShuYW1lLCBlbmNvZGluZyk7XG4gIGRlZiA9IGxlZ2VuZC5zdHlsZShuYW1lLCBlbmNvZGluZywgZGVmLCBzdHlsZSk7XG5cbiAgaWYgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBUKSAmJlxuICAgIHRpbWVVbml0ICYmXG4gICAgdGltZS5oYXNTY2FsZSh0aW1lVW5pdClcbiAgKSB7XG4gICAgc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywgJ2xhYmVscycsICd0ZXh0JywgJ3NjYWxlJ10sICd0aW1lLScrIHRpbWVVbml0KTtcbiAgfVxuXG4gIHJldHVybiBkZWY7XG59O1xuXG5sZWdlbmQuc3R5bGUgPSBmdW5jdGlvbihuYW1lLCBlLCBkZWYsIHN0eWxlKSB7XG4gIHZhciBzeW1ib2xzID0gZ2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywgJ3N5bWJvbHMnXSksXG4gICAgbWFya3R5cGUgPSBlLm1hcmt0eXBlKCk7XG5cbiAgc3dpdGNoIChtYXJrdHlwZSkge1xuICAgIGNhc2UgJ2Jhcic6XG4gICAgY2FzZSAndGljayc6XG4gICAgY2FzZSAndGV4dCc6XG4gICAgICBzeW1ib2xzLnN0cm9rZSA9IHt2YWx1ZTogJ3RyYW5zcGFyZW50J307XG4gICAgICBzeW1ib2xzLnNoYXBlID0ge3ZhbHVlOiAnc3F1YXJlJ307XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2NpcmNsZSc6XG4gICAgY2FzZSAnc3F1YXJlJzpcbiAgICAgIHN5bWJvbHMuc2hhcGUgPSB7dmFsdWU6IG1hcmt0eXBlfTtcbiAgICAgIC8qIGZhbGwgdGhyb3VnaCAqL1xuICAgIGNhc2UgJ3BvaW50JzpcbiAgICAgIC8vIGZpbGwgb3Igc3Ryb2tlXG4gICAgICBpZiAoZS5maWVsZChTSEFQRSkuZmlsbGVkKSB7XG4gICAgICAgIGlmIChlLmhhcyhDT0xPUikgJiYgbmFtZSA9PT0gQ09MT1IpIHtcbiAgICAgICAgICBzeW1ib2xzLmZpbGwgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogJ2RhdGEnfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzeW1ib2xzLmZpbGwgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgICAgICAgfVxuICAgICAgICBzeW1ib2xzLnN0cm9rZSA9IHt2YWx1ZTogJ3RyYW5zcGFyZW50J307XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZS5oYXMoQ09MT1IpICYmIG5hbWUgPT09IENPTE9SKSB7XG4gICAgICAgICAgc3ltYm9scy5zdHJva2UgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogJ2RhdGEnfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzeW1ib2xzLnN0cm9rZSA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICAgICAgICB9XG4gICAgICAgIHN5bWJvbHMuZmlsbCA9IHt2YWx1ZTogJ3RyYW5zcGFyZW50J307XG4gICAgICAgIHN5bWJvbHMuc3Ryb2tlV2lkdGggPSB7dmFsdWU6IGUuY29uZmlnKCdzdHJva2VXaWR0aCcpfTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGluZSc6XG4gICAgY2FzZSAnYXJlYSc6XG4gICAgICAvLyBUT0RPIHVzZSBzaGFwZSBoZXJlIGFmdGVyIGltcGxlbWVudGluZyAjNTA4XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHZhciBvcGFjaXR5ID0gZS5maWVsZChDT0xPUikub3BhY2l0eSB8fCBzdHlsZS5vcGFjaXR5O1xuICBpZiAob3BhY2l0eSkge1xuICAgIHN5bWJvbHMub3BhY2l0eSA9IHt2YWx1ZTogb3BhY2l0eX07XG4gIH1cbiAgcmV0dXJuIGRlZjtcbn07XG5cbmxlZ2VuZC50aXRsZSA9IGZ1bmN0aW9uKG5hbWUsIGVuY29kaW5nKSB7XG4gIHZhciBsZWcgPSBlbmNvZGluZy5maWVsZChuYW1lKS5sZWdlbmQ7XG5cbiAgaWYgKGxlZy50aXRsZSkgcmV0dXJuIGxlZy50aXRsZTtcblxuICByZXR1cm4gZW5jb2RpbmcuZmllbGRUaXRsZShuYW1lKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIG1hcmtzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxubWFya3MuZGVmID0gZnVuY3Rpb24oZW5jb2RpbmcsIGxheW91dCwgc3R5bGUsIHN0YXRzKSB7XG5cbiAgdmFyIGRlZnMgPSBbXSxcbiAgICBtYXJrID0gbWFya3NbZW5jb2RpbmcubWFya3R5cGUoKV0sXG4gICAgZnJvbSA9IGVuY29kaW5nLmRhdGFUYWJsZSgpO1xuXG4gIC8vIHRvIGFkZCBhIGJhY2tncm91bmQgdG8gdGV4dCwgd2UgbmVlZCB0byBhZGQgaXQgYmVmb3JlIHRoZSB0ZXh0XG4gIGlmIChlbmNvZGluZy5tYXJrdHlwZSgpID09PSBURVhUICYmIGVuY29kaW5nLmhhcyhDT0xPUikpIHtcbiAgICB2YXIgYmcgPSB7XG4gICAgICB4OiB7dmFsdWU6IDB9LFxuICAgICAgeToge3ZhbHVlOiAwfSxcbiAgICAgIHgyOiB7dmFsdWU6IGxheW91dC5jZWxsV2lkdGh9LFxuICAgICAgeTI6IHt2YWx1ZTogbGF5b3V0LmNlbGxIZWlnaHR9LFxuICAgICAgZmlsbDoge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGVuY29kaW5nLmZpZWxkUmVmKENPTE9SKX1cbiAgICB9O1xuICAgIGRlZnMucHVzaCh7XG4gICAgICB0eXBlOiAncmVjdCcsXG4gICAgICBmcm9tOiB7ZGF0YTogZnJvbX0sXG4gICAgICBwcm9wZXJ0aWVzOiB7ZW50ZXI6IGJnLCB1cGRhdGU6IGJnfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gYWRkIHRoZSBtYXJrIGRlZiBmb3IgdGhlIG1haW4gdGhpbmdcbiAgdmFyIHAgPSBtYXJrLnByb3AoZW5jb2RpbmcsIGxheW91dCwgc3R5bGUsIHN0YXRzKTtcbiAgZGVmcy5wdXNoKHtcbiAgICB0eXBlOiBtYXJrLnR5cGUsXG4gICAgZnJvbToge2RhdGE6IGZyb219LFxuICAgIHByb3BlcnRpZXM6IHtlbnRlcjogcCwgdXBkYXRlOiBwfVxuICB9KTtcblxuICByZXR1cm4gZGVmcztcbn07XG5cbm1hcmtzLmJhciA9IHtcbiAgdHlwZTogJ3JlY3QnLFxuICBzdGFjazogdHJ1ZSxcbiAgcHJvcDogYmFyX3Byb3BzLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCB4OiAxLCB5OiAxLCBzaXplOiAxLCBjb2xvcjogMX1cbn07XG5cbm1hcmtzLmxpbmUgPSB7XG4gIHR5cGU6ICdsaW5lJyxcbiAgbGluZTogdHJ1ZSxcbiAgcHJvcDogbGluZV9wcm9wcyxcbiAgcmVxdWlyZWRFbmNvZGluZzogWyd4JywgJ3knXSxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgeDogMSwgeTogMSwgY29sb3I6IDEsIGRldGFpbDoxfVxufTtcblxubWFya3MuYXJlYSA9IHtcbiAgdHlwZTogJ2FyZWEnLFxuICBzdGFjazogdHJ1ZSxcbiAgbGluZTogdHJ1ZSxcbiAgcmVxdWlyZWRFbmNvZGluZzogWyd4JywgJ3knXSxcbiAgcHJvcDogYXJlYV9wcm9wcyxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgeDogMSwgeTogMSwgY29sb3I6IDF9XG59O1xuXG5tYXJrcy50aWNrID0ge1xuICB0eXBlOiAncmVjdCcsXG4gIHByb3A6IHRpY2tfcHJvcHMsXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OiAxLCBjb2w6IDEsIHg6IDEsIHk6IDEsIGNvbG9yOiAxLCBkZXRhaWw6IDF9XG59O1xuXG5tYXJrcy5jaXJjbGUgPSB7XG4gIHR5cGU6ICdzeW1ib2wnLFxuICBwcm9wOiBmaWxsZWRfcG9pbnRfcHJvcHMoJ2NpcmNsZScpLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCB4OiAxLCB5OiAxLCBzaXplOiAxLCBjb2xvcjogMSwgZGV0YWlsOiAxfVxufTtcblxubWFya3Muc3F1YXJlID0ge1xuICB0eXBlOiAnc3ltYm9sJyxcbiAgcHJvcDogZmlsbGVkX3BvaW50X3Byb3BzKCdzcXVhcmUnKSxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IG1hcmtzLmNpcmNsZS5zdXBwb3J0ZWRFbmNvZGluZ1xufTtcblxubWFya3MucG9pbnQgPSB7XG4gIHR5cGU6ICdzeW1ib2wnLFxuICBwcm9wOiBwb2ludF9wcm9wcyxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgeDogMSwgeTogMSwgc2l6ZTogMSwgY29sb3I6IDEsIHNoYXBlOiAxLCBkZXRhaWw6IDF9XG59O1xuXG5tYXJrcy50ZXh0ID0ge1xuICB0eXBlOiAndGV4dCcsXG4gIHByb3A6IHRleHRfcHJvcHMsXG4gIHJlcXVpcmVkRW5jb2Rpbmc6IFsndGV4dCddLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCBzaXplOiAxLCBjb2xvcjogMSwgdGV4dDogMX1cbn07XG5cbmZ1bmN0aW9uIGJhcl9wcm9wcyhlLCBsYXlvdXQsIHN0eWxlKSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcblxuICB2YXIgcCA9IHt9O1xuXG4gIC8vIHgncyBhbmQgd2lkdGhcbiAgaWYgKGUuaXNNZWFzdXJlKFgpKSB7XG4gICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZFJlZihYKX07XG4gICAgaWYgKCFlLmhhcyhZKSB8fCBlLmlzRGltZW5zaW9uKFkpKSB7XG4gICAgICBwLngyID0ge3ZhbHVlOiAwfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGUuaGFzKFgpKSB7IC8vIGlzIG9yZGluYWxcbiAgICAgICBwLnhjID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZFJlZihYKX07XG4gICAgfSBlbHNlIHtcbiAgICAgICBwLnggPSB7dmFsdWU6IDAsIG9mZnNldDogZS5jb25maWcoJ3NpbmdsZUJhck9mZnNldCcpfTtcbiAgICB9XG4gIH1cblxuICAvLyB3aWR0aFxuICBpZiAoIXAueDIpIHtcbiAgICBpZiAoIWUuaGFzKFgpIHx8IGUuaXNPcmRpbmFsU2NhbGUoWCkpIHsgLy8gbm8gWCBvciBYIGlzIG9yZGluYWxcbiAgICAgIGlmIChlLmhhcyhTSVpFKSkge1xuICAgICAgICBwLndpZHRoID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZFJlZihTSVpFKX07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwLndpZHRoID0ge1xuICAgICAgICAgIHZhbHVlOiBlLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCksXG4gICAgICAgICAgb2Zmc2V0OiAtMVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIFggaXMgUXVhbnQgb3IgVGltZSBTY2FsZVxuICAgICAgcC53aWR0aCA9IHt2YWx1ZTogMn07XG4gICAgfVxuICB9XG5cbiAgLy8geSdzICYgaGVpZ2h0XG4gIGlmIChlLmlzTWVhc3VyZShZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGRSZWYoWSl9O1xuICAgIHAueTIgPSB7Z3JvdXA6ICdoZWlnaHQnfTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZS5oYXMoWSkpIHsgLy8gaXMgb3JkaW5hbFxuICAgICAgcC55YyA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGRSZWYoWSl9O1xuICAgIH0gZWxzZSB7XG4gICAgICBwLnkyID0ge2dyb3VwOiAnaGVpZ2h0Jywgb2Zmc2V0OiAtZS5jb25maWcoJ3NpbmdsZUJhck9mZnNldCcpfTtcbiAgICB9XG5cbiAgICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICAgIHAuaGVpZ2h0ID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZFJlZihTSVpFKX07XG4gICAgfSBlbHNlIHtcbiAgICAgIHAuaGVpZ2h0ID0ge1xuICAgICAgICB2YWx1ZTogZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpLFxuICAgICAgICBvZmZzZXQ6IC0xXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpbGxcbiAgaWYgKGUuaGFzKENPTE9SKSkge1xuICAgIHAuZmlsbCA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkUmVmKENPTE9SKX07XG4gIH0gZWxzZSB7XG4gICAgcC5maWxsID0ge3ZhbHVlOiBlLnZhbHVlKENPTE9SKX07XG4gIH1cblxuICAvLyBvcGFjaXR5XG4gIHZhciBvcGFjaXR5ID0gZS5maWVsZChDT0xPUikub3BhY2l0eTtcbiAgaWYgKG9wYWNpdHkpIHAub3BhY2l0eSA9IHt2YWx1ZTogb3BhY2l0eX07XG5cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHBvaW50X3Byb3BzKGUsIGxheW91dCwgc3R5bGUpIHtcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmhhcyhYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGRSZWYoWCl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgIHAueCA9IHt2YWx1ZTogZS5iYW5kU2l6ZShYLCBsYXlvdXQueC51c2VTbWFsbEJhbmQpIC8gMn07XG4gIH1cblxuICAvLyB5XG4gIGlmIChlLmhhcyhZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGRSZWYoWSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhZKSkge1xuICAgIHAueSA9IHt2YWx1ZTogZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMn07XG4gIH1cblxuICAvLyBzaXplXG4gIGlmIChlLmhhcyhTSVpFKSkge1xuICAgIHAuc2l6ZSA9IHtzY2FsZTogU0laRSwgZmllbGQ6IGUuZmllbGRSZWYoU0laRSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhTSVpFKSkge1xuICAgIHAuc2l6ZSA9IHt2YWx1ZTogZS52YWx1ZShTSVpFKX07XG4gIH1cblxuICAvLyBzaGFwZVxuICBpZiAoZS5oYXMoU0hBUEUpKSB7XG4gICAgcC5zaGFwZSA9IHtzY2FsZTogU0hBUEUsIGZpZWxkOiBlLmZpZWxkUmVmKFNIQVBFKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFNIQVBFKSkge1xuICAgIHAuc2hhcGUgPSB7dmFsdWU6IGUudmFsdWUoU0hBUEUpfTtcbiAgfVxuXG4gIC8vIGZpbGwgb3Igc3Ryb2tlXG4gIGlmIChlLmZpZWxkKFNIQVBFKS5maWxsZWQpIHtcbiAgICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgICBwLmZpbGwgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZFJlZihDT0xPUil9O1xuICAgIH0gZWxzZSBpZiAoIWUuaGFzKENPTE9SKSkge1xuICAgICAgcC5maWxsID0ge3ZhbHVlOiBlLnZhbHVlKENPTE9SKX07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICAgIHAuc3Ryb2tlID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGRSZWYoQ09MT1IpfTtcbiAgICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICAgIHAuc3Ryb2tlID0ge3ZhbHVlOiBlLnZhbHVlKENPTE9SKX07XG4gICAgfVxuICAgIHAuc3Ryb2tlV2lkdGggPSB7dmFsdWU6IGUuY29uZmlnKCdzdHJva2VXaWR0aCcpfTtcbiAgfVxuXG4gIC8vIG9wYWNpdHlcbiAgdmFyIG9wYWNpdHkgPSBlLmZpZWxkKENPTE9SKS5vcGFjaXR5IHx8IHN0eWxlLm9wYWNpdHk7XG4gIGlmIChvcGFjaXR5KSBwLm9wYWNpdHkgPSB7dmFsdWU6IG9wYWNpdHl9O1xuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBsaW5lX3Byb3BzKGUsbGF5b3V0LCBzdHlsZSkge1xuICAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHZhciBwID0ge307XG5cbiAgLy8geFxuICBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkUmVmKFgpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkUmVmKFkpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7Z3JvdXA6ICdoZWlnaHQnfTtcbiAgfVxuXG4gIC8vIHN0cm9rZVxuICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5zdHJva2UgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZFJlZihDT0xPUil9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICBwLnN0cm9rZSA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICB9XG5cbiAgdmFyIG9wYWNpdHkgPSBlLmZpZWxkKENPTE9SKS5vcGFjaXR5O1xuICBpZiAob3BhY2l0eSkgcC5vcGFjaXR5ID0ge3ZhbHVlOiBvcGFjaXR5fTtcblxuICBwLnN0cm9rZVdpZHRoID0ge3ZhbHVlOiBlLmNvbmZpZygnc3Ryb2tlV2lkdGgnKX07XG5cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIGFyZWFfcHJvcHMoZSwgbGF5b3V0LCBzdHlsZSkge1xuICAvLyBqc2hpbnQgdW51c2VkOmZhbHNlXG4gIHZhciBwID0ge307XG5cbiAgLy8geFxuICBpZiAoZS5pc01lYXN1cmUoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkUmVmKFgpfTtcbiAgICBpZiAoZS5pc0RpbWVuc2lvbihZKSkge1xuICAgICAgcC54MiA9IHtzY2FsZTogWCwgdmFsdWU6IDB9O1xuICAgICAgcC5vcmllbnQgPSB7dmFsdWU6ICdob3Jpem9udGFsJ307XG4gICAgfVxuICB9IGVsc2UgaWYgKGUuaGFzKFgpKSB7XG4gICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZFJlZihYKX07XG4gIH0gZWxzZSB7XG4gICAgcC54ID0ge3ZhbHVlOiAwfTtcbiAgfVxuXG4gIC8vIHlcbiAgaWYgKGUuaXNNZWFzdXJlKFkpKSB7XG4gICAgcC55ID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZFJlZihZKX07XG4gICAgcC55MiA9IHtzY2FsZTogWSwgdmFsdWU6IDB9O1xuICB9IGVsc2UgaWYgKGUuaGFzKFkpKSB7XG4gICAgcC55ID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZFJlZihZKX07XG4gIH0gZWxzZSB7XG4gICAgcC55ID0ge2dyb3VwOiAnaGVpZ2h0J307XG4gIH1cblxuICAvLyBmaWxsXG4gIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZFJlZihDT0xPUil9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgfVxuXG4gIHZhciBvcGFjaXR5ID0gZS5maWVsZChDT0xPUikub3BhY2l0eTtcbiAgaWYgKG9wYWNpdHkpIHAub3BhY2l0eSA9IHt2YWx1ZTogb3BhY2l0eX07XG5cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHRpY2tfcHJvcHMoZSwgbGF5b3V0LCBzdHlsZSkge1xuICB2YXIgcCA9IHt9O1xuXG4gIC8vIHhcbiAgaWYgKGUuaGFzKFgpKSB7XG4gICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZFJlZihYKX07XG4gICAgaWYgKGUuaXNEaW1lbnNpb24oWCkpIHtcbiAgICAgIHAueC5vZmZzZXQgPSAtZS5iYW5kU2l6ZShYLCBsYXlvdXQueC51c2VTbWFsbEJhbmQpIC8gMztcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFgpKSB7XG4gICAgcC54ID0ge3ZhbHVlOiAwfTtcbiAgfVxuXG4gIC8vIHlcbiAgaWYgKGUuaGFzKFkpKSB7XG4gICAgcC55ID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZFJlZihZKX07XG4gICAgaWYgKGUuaXNEaW1lbnNpb24oWSkpIHtcbiAgICAgIHAueS5vZmZzZXQgPSAtZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMztcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFkpKSB7XG4gICAgcC55ID0ge3ZhbHVlOiAwfTtcbiAgfVxuXG4gIC8vIHdpZHRoXG4gIGlmICghZS5oYXMoWCkgfHwgZS5pc0RpbWVuc2lvbihYKSkge1xuICAgIHAud2lkdGggPSB7dmFsdWU6IGUuYmFuZFNpemUoWCwgbGF5b3V0LnkudXNlU21hbGxCYW5kKSAvIDEuNX07XG4gIH0gZWxzZSB7XG4gICAgcC53aWR0aCA9IHt2YWx1ZTogMX07XG4gIH1cblxuICAvLyBoZWlnaHRcbiAgaWYgKCFlLmhhcyhZKSB8fCBlLmlzRGltZW5zaW9uKFkpKSB7XG4gICAgcC5oZWlnaHQgPSB7dmFsdWU6IGUuYmFuZFNpemUoWSwgbGF5b3V0LnkudXNlU21hbGxCYW5kKSAvIDEuNX07XG4gIH0gZWxzZSB7XG4gICAgcC5oZWlnaHQgPSB7dmFsdWU6IDF9O1xuICB9XG5cbiAgLy8gZmlsbFxuICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5maWxsID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGRSZWYoQ09MT1IpfTtcbiAgfSBlbHNlIHtcbiAgICBwLmZpbGwgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgfVxuXG4gIHZhciBvcGFjaXR5ID0gZS5maWVsZChDT0xPUikub3BhY2l0eSAgfHwgc3R5bGUub3BhY2l0eTtcbiAgaWYob3BhY2l0eSkgcC5vcGFjaXR5ID0ge3ZhbHVlOiBvcGFjaXR5fTtcblxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gZmlsbGVkX3BvaW50X3Byb3BzKHNoYXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbihlLCBsYXlvdXQsIHN0eWxlKSB7XG4gICAgdmFyIHAgPSB7fTtcblxuICAgIC8vIHhcbiAgICBpZiAoZS5oYXMoWCkpIHtcbiAgICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGRSZWYoWCl9O1xuICAgIH0gZWxzZSBpZiAoIWUuaGFzKFgpKSB7XG4gICAgICBwLnggPSB7dmFsdWU6IGUuYmFuZFNpemUoWCwgbGF5b3V0LngudXNlU21hbGxCYW5kKSAvIDJ9O1xuICAgIH1cblxuICAgIC8vIHlcbiAgICBpZiAoZS5oYXMoWSkpIHtcbiAgICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGRSZWYoWSl9O1xuICAgIH0gZWxzZSBpZiAoIWUuaGFzKFkpKSB7XG4gICAgICBwLnkgPSB7dmFsdWU6IGUuYmFuZFNpemUoWSwgbGF5b3V0LnkudXNlU21hbGxCYW5kKSAvIDJ9O1xuICAgIH1cblxuICAgIC8vIHNpemVcbiAgICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICAgIHAuc2l6ZSA9IHtzY2FsZTogU0laRSwgZmllbGQ6IGUuZmllbGRSZWYoU0laRSl9O1xuICAgIH0gZWxzZSBpZiAoIWUuaGFzKFgpKSB7XG4gICAgICBwLnNpemUgPSB7dmFsdWU6IGUudmFsdWUoU0laRSl9O1xuICAgIH1cblxuICAgIC8vIHNoYXBlXG4gICAgcC5zaGFwZSA9IHt2YWx1ZTogc2hhcGV9O1xuXG4gICAgLy8gZmlsbFxuICAgIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICAgIHAuZmlsbCA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkUmVmKENPTE9SKX07XG4gICAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgICBwLmZpbGwgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgICB9XG5cbiAgICB2YXIgb3BhY2l0eSA9IGUuZmllbGQoQ09MT1IpLm9wYWNpdHkgIHx8IHN0eWxlLm9wYWNpdHk7XG4gICAgaWYob3BhY2l0eSkgcC5vcGFjaXR5ID0ge3ZhbHVlOiBvcGFjaXR5fTtcblxuICAgIHJldHVybiBwO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0X3Byb3BzKGUsIGxheW91dCwgc3R5bGUsIHN0YXRzKSB7XG4gIHZhciBwID0ge30sXG4gICAgZmllbGQgPSBlLmZpZWxkKFRFWFQpO1xuXG4gIC8vIHhcbiAgaWYgKGUuaGFzKFgpKSB7XG4gICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZFJlZihYKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFgpKSB7XG4gICAgaWYgKGUuaGFzKFRFWFQpICYmIGUuaXNUeXBlKFRFWFQsIFEpKSB7XG4gICAgICBwLnggPSB7dmFsdWU6IGxheW91dC5jZWxsV2lkdGgtNX07XG4gICAgfSBlbHNlIHtcbiAgICAgIHAueCA9IHt2YWx1ZTogZS5iYW5kU2l6ZShYLCBsYXlvdXQueC51c2VTbWFsbEJhbmQpIC8gMn07XG4gICAgfVxuICB9XG5cbiAgLy8geVxuICBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkUmVmKFkpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7dmFsdWU6IGUuYmFuZFNpemUoWSwgbGF5b3V0LnkudXNlU21hbGxCYW5kKSAvIDJ9O1xuICB9XG5cbiAgLy8gc2l6ZVxuICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICBwLmZvbnRTaXplID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZFJlZihTSVpFKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFNJWkUpKSB7XG4gICAgcC5mb250U2l6ZSA9IHt2YWx1ZTogZmllbGQuZm9udC5zaXplfTtcbiAgfVxuXG4gIC8vIGZpbGxcbiAgLy8gY29sb3Igc2hvdWxkIGJlIHNldCB0byBiYWNrZ3JvdW5kXG4gIHAuZmlsbCA9IHt2YWx1ZTogZmllbGQuY29sb3J9O1xuXG4gIHZhciBvcGFjaXR5ID0gZS5maWVsZChDT0xPUikub3BhY2l0eSAgfHwgc3R5bGUub3BhY2l0eTtcbiAgaWYob3BhY2l0eSkgcC5vcGFjaXR5ID0ge3ZhbHVlOiBvcGFjaXR5fTtcblxuICAvLyB0ZXh0XG4gIGlmIChlLmhhcyhURVhUKSkge1xuICAgIGlmIChlLmlzVHlwZShURVhULCBRKSkge1xuICAgICAgdmFyIGZpZWxkU3RhdHMgPSBzdGF0c1tlLmZpZWxkTmFtZShURVhUKV0sXG4gICAgICAgIG51bWJlckZvcm1hdCA9IGZpZWxkLmZvcm1hdCB8fCBlLm51bWJlckZvcm1hdChmaWVsZFN0YXRzKTtcblxuICAgICAgcC50ZXh0ID0ge3RlbXBsYXRlOiAne3snICsgZS5maWVsZFJlZihURVhUKSArICcgfCBudW1iZXI6XFwnJyArXG4gICAgICAgIG51bWJlckZvcm1hdCArJ1xcJ319J307XG4gICAgICBwLmFsaWduID0ge3ZhbHVlOiBmaWVsZC5hbGlnbn07XG4gICAgfSBlbHNlIHtcbiAgICAgIHAudGV4dCA9IHtmaWVsZDogZS5maWVsZFJlZihURVhUKX07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHAudGV4dCA9IHt2YWx1ZTogZmllbGQucGxhY2Vob2xkZXJ9O1xuICB9XG5cbiAgcC5mb250ID0ge3ZhbHVlOiBmaWVsZC5mb250LmZhbWlseX07XG4gIHAuZm9udFdlaWdodCA9IHt2YWx1ZTogZmllbGQuZm9udC53ZWlnaHR9O1xuICBwLmZvbnRTdHlsZSA9IHt2YWx1ZTogZmllbGQuZm9udC5zdHlsZX07XG4gIHAuYmFzZWxpbmUgPSB7dmFsdWU6IGZpZWxkLmJhc2VsaW5lfTtcblxuICByZXR1cm4gcDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICB0aW1lID0gcmVxdWlyZSgnLi90aW1lJyksXG4gIGNvbG9yYnJld2VyID0gcmVxdWlyZSgnY29sb3JicmV3ZXInKSxcbiAgaW50ZXJwb2xhdGUgPSByZXF1aXJlKCdkMy1jb2xvcicpLmludGVycG9sYXRlSHNsLFxuICBzY2hlbWEgPSByZXF1aXJlKCcuLi9zY2hlbWEvc2NoZW1hJyksXG4gIHZsc29ydCA9IHJlcXVpcmUoJy4vc29ydCcpO1xuXG52YXIgc2NhbGUgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5zY2FsZS5uYW1lcyA9IGZ1bmN0aW9uKHByb3BzKSB7XG4gIHJldHVybiB1dGlsLmtleXModXRpbC5rZXlzKHByb3BzKS5yZWR1Y2UoZnVuY3Rpb24oYSwgeCkge1xuICAgIGlmIChwcm9wc1t4XSAmJiBwcm9wc1t4XS5zY2FsZSkgYVtwcm9wc1t4XS5zY2FsZV0gPSAxO1xuICAgIHJldHVybiBhO1xuICB9LCB7fSkpO1xufTtcblxuc2NhbGUuZGVmcyA9IGZ1bmN0aW9uKG5hbWVzLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cywgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcblxuICByZXR1cm4gbmFtZXMucmVkdWNlKGZ1bmN0aW9uKGEsIG5hbWUpIHtcbiAgICB2YXIgcyA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB0eXBlOiBzY2FsZS50eXBlKG5hbWUsIGVuY29kaW5nKSxcbiAgICAgIGRvbWFpbjogc2NhbGUuZG9tYWluKG5hbWUsIGVuY29kaW5nLCBzdGF0cywgb3B0KVxuICAgIH07XG5cbiAgICBzLnNvcnQgPSBzY2FsZS5zb3J0KHMsIGVuY29kaW5nLCBuYW1lKSB8fCB1bmRlZmluZWQ7XG5cbiAgICBzY2FsZS5yYW5nZShzLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cywgb3B0KTtcblxuICAgIHJldHVybiAoYS5wdXNoKHMpLCBhKTtcbiAgfSwgW10pO1xufTtcblxuc2NhbGUuc29ydCA9IGZ1bmN0aW9uKHMsIGVuY29kaW5nLCBuYW1lKSB7XG4gIHJldHVybiBzLnR5cGUgPT09ICdvcmRpbmFsJyAmJiAoXG4gICAgISFlbmNvZGluZy5iaW4obmFtZSkgfHxcbiAgICBlbmNvZGluZy5zb3J0KG5hbWUpLmxlbmd0aCA9PT0gMFxuICApO1xufTtcblxuc2NhbGUudHlwZSA9IGZ1bmN0aW9uKG5hbWUsIGVuY29kaW5nKSB7XG5cbiAgc3dpdGNoIChlbmNvZGluZy50eXBlKG5hbWUpKSB7XG4gICAgY2FzZSBOOiAvL2ZhbGwgdGhyb3VnaFxuICAgIGNhc2UgTzogcmV0dXJuICdvcmRpbmFsJztcbiAgICBjYXNlIFQ6XG4gICAgICB2YXIgdGltZVVuaXQgPSBlbmNvZGluZy5maWVsZChuYW1lKS50aW1lVW5pdDtcbiAgICAgIHJldHVybiB0aW1lVW5pdCA/IHRpbWUuc2NhbGUudHlwZSh0aW1lVW5pdCwgbmFtZSkgOiAndGltZSc7XG4gICAgY2FzZSBROlxuICAgICAgaWYgKGVuY29kaW5nLmJpbihuYW1lKSkge1xuICAgICAgICByZXR1cm4gbmFtZSA9PT0gQ09MT1IgPyAnbGluZWFyJyA6ICdvcmRpbmFsJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmNvZGluZy5zY2FsZShuYW1lKS50eXBlO1xuICB9XG59O1xuXG5zY2FsZS5kb21haW4gPSBmdW5jdGlvbiAobmFtZSwgZW5jb2RpbmcsIHN0YXRzLCBvcHQpIHtcbiAgdmFyIGZpZWxkID0gZW5jb2RpbmcuZmllbGQobmFtZSk7XG5cbiAgaWYgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBUKSkge1xuICAgIHZhciByYW5nZSA9IHRpbWUuc2NhbGUuZG9tYWluKGZpZWxkLnRpbWVVbml0LCBuYW1lKTtcbiAgICBpZihyYW5nZSkgcmV0dXJuIHJhbmdlO1xuICB9XG5cbiAgaWYgKGZpZWxkLmJpbikge1xuICAgIC8vIFRPRE8oa2FuaXR3KTogdGhpcyBtdXN0IGJlIGNoYW5nZWQgaW4gdmcyXG4gICAgdmFyIGZpZWxkU3RhdCA9IHN0YXRzW2ZpZWxkLm5hbWVdLFxuICAgICAgYmlucyA9IHV0aWwuZ2V0YmlucyhmaWVsZFN0YXQsIGZpZWxkLmJpbi5tYXhiaW5zIHx8IHNjaGVtYS5NQVhCSU5TX0RFRkFVTFQpLFxuICAgICAgbnVtYmlucyA9IChiaW5zLnN0b3AgLSBiaW5zLnN0YXJ0KSAvIGJpbnMuc3RlcDtcbiAgICByZXR1cm4gdXRpbC5yYW5nZShudW1iaW5zKS5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIGJpbnMuc3RhcnQgKyBiaW5zLnN0ZXAgKiBpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKG5hbWUgPT0gb3B0LnN0YWNrKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IFNUQUNLRUQsXG4gICAgICBmaWVsZDogZW5jb2RpbmcuZmllbGRSZWYobmFtZSwge1xuICAgICAgICBkYXRhOiAhZW5jb2RpbmcuX3ZlZ2EyLFxuICAgICAgICBwcmVmbjogKG9wdC5mYWNldCA/ICdtYXhfJyA6ICcnKSArICdzdW1fJ1xuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHZhciBhZ2dyZWdhdGUgPSBlbmNvZGluZy5hZ2dyZWdhdGUobmFtZSksXG4gICAgdGltZVVuaXQgPSBmaWVsZC50aW1lVW5pdCxcbiAgICBzY2FsZVVzZVJhd0RvbWFpbiA9IGVuY29kaW5nLnNjYWxlKG5hbWUpLnVzZVJhd0RvbWFpbixcbiAgICB1c2VSYXdEb21haW4gPSBzY2FsZVVzZVJhd0RvbWFpbiAhPT0gdW5kZWZpbmVkID9cbiAgICAgIHNjYWxlVXNlUmF3RG9tYWluIDogZW5jb2RpbmcuY29uZmlnKCd1c2VSYXdEb21haW4nKSxcbiAgICBub3RDb3VudE9yU3VtID0gIWFnZ3JlZ2F0ZSB8fCAoYWdncmVnYXRlICE9PSdjb3VudCcgJiYgYWdncmVnYXRlICE9PSAnc3VtJyk7XG5cbiAgLy8gRklYTUUgcmV2aXNlIHRoaXMgcGFydFxuXG4gIGlmICggdXNlUmF3RG9tYWluICYmIG5vdENvdW50T3JTdW0gJiYgKFxuICAgICAgLy8gUSBhbHdheXMgdXNlcyBub24tb3JkaW5hbCBzY2FsZSBleGNlcHQgd2hlbiBpdCdzIGJpbm5lZCBhbmQgdGh1cyB1c2VzIG9yZGluYWwgc2NhbGUuXG4gICAgICAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFEpICYmICFmaWVsZC5iaW4pIHx8XG4gICAgICAvLyBUIHVzZXMgbm9uLW9yZGluYWwgc2NhbGUgd2hlbiB0aGVyZSdzIG5vIHVuaXQgb3Igd2hlbiB0aGUgdW5pdCBpcyBub3Qgb3JkaW5hbC5cbiAgICAgIChlbmNvZGluZy5pc1R5cGUobmFtZSwgVCkgJiYgKCF0aW1lVW5pdCB8fCAhdGltZS5pc09yZGluYWxGbih0aW1lVW5pdCkpKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuIHtkYXRhOiBSQVcsIGZpZWxkOiBlbmNvZGluZy5maWVsZFJlZihuYW1lLCB7bm9mbjogIXRpbWVVbml0fSl9O1xuICB9XG5cbiAgdmFyIGRhdGEgPSBlbmNvZGluZy5zb3J0KG5hbWUsIHN0YXRzKS5sZW5ndGggPiAwID9cbiAgICB2bHNvcnQuZ2V0RGF0YU5hbWUobmFtZSk6XG4gICAgZW5jb2RpbmcuZGF0YVRhYmxlKCk7XG5cbiAgcmV0dXJuIHtkYXRhOiBkYXRhLCBmaWVsZDogZW5jb2RpbmcuZmllbGRSZWYobmFtZSl9O1xufTtcblxuXG5zY2FsZS5yYW5nZSA9IGZ1bmN0aW9uIChzLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cykge1xuICB2YXIgc3BlYyA9IGVuY29kaW5nLnNjYWxlKHMubmFtZSksXG4gICAgZmllbGQgPSBlbmNvZGluZy5maWVsZChzLm5hbWUpLFxuICAgIHRpbWVVbml0ID0gZmllbGQudGltZVVuaXQ7XG5cbiAgc3dpdGNoIChzLm5hbWUpIHtcbiAgICBjYXNlIFg6XG4gICAgICBzLnJhbmdlID0gbGF5b3V0LmNlbGxXaWR0aCA/IFswLCBsYXlvdXQuY2VsbFdpZHRoXSA6ICd3aWR0aCc7XG4gICAgICBpZiAocy50eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgcy5iYW5kV2lkdGggPSBlbmNvZGluZy5iYW5kU2l6ZShYLCBsYXlvdXQueC51c2VTbWFsbEJhbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVuY29kaW5nLmlzVHlwZShzLm5hbWUsVCkgJiYgdGltZVVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgICAgIHMuemVybyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMuemVybyA9IHNwZWMuemVybyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHNwZWMuemVybztcbiAgICAgICAgfVxuXG4gICAgICAgIHMucmV2ZXJzZSA9IHNwZWMucmV2ZXJzZTtcbiAgICAgIH1cbiAgICAgIHMucm91bmQgPSB0cnVlO1xuICAgICAgaWYgKHMudHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgIHMubmljZSA9IHRpbWVVbml0IHx8IGVuY29kaW5nLmNvbmZpZygndGltZVNjYWxlTmljZScpO1xuICAgICAgfWVsc2Uge1xuICAgICAgICBzLm5pY2UgPSB0cnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBZOlxuICAgICAgaWYgKHMudHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgIHMucmFuZ2UgPSBsYXlvdXQuY2VsbEhlaWdodCA/XG4gICAgICAgICAgKGZpZWxkLmJpbiA/IFtsYXlvdXQuY2VsbEhlaWdodCwgMF0gOiBbMCwgbGF5b3V0LmNlbGxIZWlnaHRdKSA6XG4gICAgICAgICAgJ2hlaWdodCc7XG4gICAgICAgIHMuYmFuZFdpZHRoID0gZW5jb2RpbmcuYmFuZFNpemUoWSwgbGF5b3V0LnkudXNlU21hbGxCYW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMucmFuZ2UgPSBsYXlvdXQuY2VsbEhlaWdodCA/IFtsYXlvdXQuY2VsbEhlaWdodCwgMF0gOiAnaGVpZ2h0JztcbiAgICAgICAgaWYgKGVuY29kaW5nLmlzVHlwZShzLm5hbWUsVCkgJiYgdGltZVVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgICAgIHMuemVybyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMuemVybyA9IHNwZWMuemVybyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHNwZWMuemVybztcbiAgICAgICAgfVxuXG4gICAgICAgIHMucmV2ZXJzZSA9IHNwZWMucmV2ZXJzZTtcbiAgICAgIH1cblxuICAgICAgcy5yb3VuZCA9IHRydWU7XG5cbiAgICAgIGlmIChzLnR5cGUgPT09ICd0aW1lJykge1xuICAgICAgICBzLm5pY2UgPSB0aW1lVW5pdCB8fCBlbmNvZGluZy5jb25maWcoJ3RpbWVTY2FsZU5pY2UnKTtcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgcy5uaWNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUk9XOiAvLyBzdXBwb3J0IG9ubHkgb3JkaW5hbFxuICAgICAgcy5iYW5kV2lkdGggPSBsYXlvdXQuY2VsbEhlaWdodDtcbiAgICAgIHMucm91bmQgPSB0cnVlO1xuICAgICAgcy5uaWNlID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ09MOiAvLyBzdXBwb3J0IG9ubHkgb3JkaW5hbFxuICAgICAgcy5iYW5kV2lkdGggPSBsYXlvdXQuY2VsbFdpZHRoO1xuICAgICAgcy5yb3VuZCA9IHRydWU7XG4gICAgICBzLm5pY2UgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTSVpFOlxuICAgICAgaWYgKGVuY29kaW5nLmlzKCdiYXInKSkge1xuICAgICAgICAvLyBGSVhNRSB0aGlzIGlzIGRlZmluaXRlbHkgaW5jb3JyZWN0XG4gICAgICAgIC8vIGJ1dCBsZXQncyBmaXggaXQgbGF0ZXIgc2luY2UgYmFyIHNpemUgaXMgYSBiYWQgZW5jb2RpbmcgYW55d2F5XG4gICAgICAgIHMucmFuZ2UgPSBbMywgTWF0aC5tYXgoZW5jb2RpbmcuYmFuZFNpemUoWCksIGVuY29kaW5nLmJhbmRTaXplKFkpKV07XG4gICAgICB9IGVsc2UgaWYgKGVuY29kaW5nLmlzKFRFWFQpKSB7XG4gICAgICAgIHMucmFuZ2UgPSBbOCwgNDBdO1xuICAgICAgfSBlbHNlIHsgLy9wb2ludFxuICAgICAgICB2YXIgYmFuZFNpemUgPSBNYXRoLm1pbihlbmNvZGluZy5iYW5kU2l6ZShYKSwgZW5jb2RpbmcuYmFuZFNpemUoWSkpIC0gMTtcbiAgICAgICAgcy5yYW5nZSA9IFsxMCwgMC44ICogYmFuZFNpemUqYmFuZFNpemVdO1xuICAgICAgfVxuICAgICAgcy5yb3VuZCA9IHRydWU7XG4gICAgICBzLnplcm8gPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0hBUEU6XG4gICAgICBzLnJhbmdlID0gJ3NoYXBlcyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENPTE9SOlxuICAgICAgcy5yYW5nZSA9IHNjYWxlLmNvbG9yKHMsIGVuY29kaW5nLCBzdGF0cyk7XG4gICAgICBpZiAocy50eXBlICE9PSAnb3JkaW5hbCcpIHMuemVybyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZyBuYW1lOiAnKyBzLm5hbWUpO1xuICB9XG5cbiAgLy8gRklYTUUoa2FuaXR3KTogSnVsIDI5LCAyMDE1IC0gY29uc29saWRhdGUgdGhpcyB3aXRoIGFib3ZlXG4gIHN3aXRjaCAocy5uYW1lKSB7XG4gICAgY2FzZSBST1c6XG4gICAgY2FzZSBDT0w6XG4gICAgICBzLnBhZGRpbmcgPSBlbmNvZGluZy5jb25maWcoJ2NlbGxQYWRkaW5nJyk7XG4gICAgICBzLm91dGVyUGFkZGluZyA9IDA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFg6XG4gICAgY2FzZSBZOlxuICAgICAgaWYgKHMudHlwZSA9PT0gJ29yZGluYWwnKSB7IC8vJiYgIXMuYmFuZFdpZHRoXG4gICAgICAgIHMucG9pbnRzID0gdHJ1ZTtcbiAgICAgICAgcy5wYWRkaW5nID0gZW5jb2RpbmcuZmllbGQocy5uYW1lKS5iYW5kLnBhZGRpbmc7XG4gICAgICB9XG4gIH1cbn07XG5cbnNjYWxlLmNvbG9yID0gZnVuY3Rpb24ocywgZW5jb2RpbmcsIHN0YXRzKSB7XG4gIHZhciBjb2xvclNjYWxlID0gZW5jb2Rpbmcuc2NhbGUoQ09MT1IpLFxuICAgIHJhbmdlID0gY29sb3JTY2FsZS5yYW5nZSxcbiAgICBjYXJkaW5hbGl0eSA9IGVuY29kaW5nLmNhcmRpbmFsaXR5KENPTE9SLCBzdGF0cyksXG4gICAgdHlwZSA9IGVuY29kaW5nLnR5cGUoQ09MT1IpO1xuXG4gIGlmIChyYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIG9yZGluYWxQYWxldHRlID0gY29sb3JTY2FsZS5vcmRpbmFsUGFsZXR0ZSxcbiAgICAgIHF1YW50aXRhdGl2ZVJhbmdlID0gY29sb3JTY2FsZS5xdWFudGl0YXRpdmVSYW5nZTtcblxuICAgIGlmIChzLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgaWYgKHR5cGUgPT09IE4pIHtcbiAgICAgICAgLy8gdXNlIGNhdGVnb3JpY2FsIGNvbG9yIHNjYWxlXG4gICAgICAgIGlmIChjYXJkaW5hbGl0eSA8PSAxMCkge1xuICAgICAgICAgIHJhbmdlID0gY29sb3JTY2FsZS5jMTBwYWxldHRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJhbmdlID0gY29sb3JTY2FsZS5jMjBwYWxldHRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2FsZS5jb2xvci5wYWxldHRlKHJhbmdlLCBjYXJkaW5hbGl0eSwgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3JkaW5hbFBhbGV0dGUpIHtcbiAgICAgICAgICByZXR1cm4gc2NhbGUuY29sb3IucGFsZXR0ZShvcmRpbmFsUGFsZXR0ZSwgY2FyZGluYWxpdHksIHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2FsZS5jb2xvci5pbnRlcnBvbGF0ZShxdWFudGl0YXRpdmVSYW5nZVswXSwgcXVhbnRpdGF0aXZlUmFuZ2VbMV0sIGNhcmRpbmFsaXR5KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvL3RpbWUgb3IgcXVhbnRpdGF0aXZlXG4gICAgICByZXR1cm4gW3F1YW50aXRhdGl2ZVJhbmdlWzBdLCBxdWFudGl0YXRpdmVSYW5nZVsxXV07XG4gICAgfVxuICB9XG59O1xuXG5zY2FsZS5jb2xvci5wYWxldHRlID0gZnVuY3Rpb24ocmFuZ2UsIGNhcmRpbmFsaXR5LCB0eXBlKSB7XG4gIC8vIEZJWE1FKGthbml0dyk6IEp1bCAyOSwgMjAxNSAtIGNoZWNrIHJhbmdlIGlzIHN0cmluZ1xuICBzd2l0Y2ggKHJhbmdlKSB7XG4gICAgY2FzZSAnY2F0ZWdvcnkxMGsnOlxuICAgICAgLy8gdGFibGVhdSdzIGNhdGVnb3J5IDEwLCBvcmRlcmVkIGJ5IHBlcmNlcHR1YWwga2VybmVsIHN0dWR5IHJlc3VsdHNcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS91d2RhdGEvcGVyY2VwdHVhbC1rZXJuZWxzXG4gICAgICByZXR1cm4gWycjMmNhMDJjJywgJyNlMzc3YzInLCAnIzdmN2Y3ZicsICcjMTdiZWNmJywgJyM4YzU2NGInLCAnI2Q2MjcyOCcsICcjYmNiZDIyJywgJyM5NDY3YmQnLCAnI2ZmN2YwZScsICcjMWY3N2I0J107XG5cbiAgICAvLyBkMy90YWJsZWF1IGNhdGVnb3J5MTAvMjAvMjBiLzIwY1xuICAgIGNhc2UgJ2NhdGVnb3J5MTAnOlxuICAgICAgcmV0dXJuIFsnIzFmNzdiNCcsICcjZmY3ZjBlJywgJyMyY2EwMmMnLCAnI2Q2MjcyOCcsICcjOTQ2N2JkJywgJyM4YzU2NGInLCAnI2UzNzdjMicsICcjN2Y3ZjdmJywgJyNiY2JkMjInLCAnIzE3YmVjZiddO1xuXG4gICAgY2FzZSAnY2F0ZWdvcnkyMCc6XG4gICAgICByZXR1cm4gWycjMWY3N2I0JywgJyNhZWM3ZTgnLCAnI2ZmN2YwZScsICcjZmZiYjc4JywgJyMyY2EwMmMnLCAnIzk4ZGY4YScsICcjZDYyNzI4JywgJyNmZjk4OTYnLCAnIzk0NjdiZCcsICcjYzViMGQ1JywgJyM4YzU2NGInLCAnI2M0OWM5NCcsICcjZTM3N2MyJywgJyNmN2I2ZDInLCAnIzdmN2Y3ZicsICcjYzdjN2M3JywgJyNiY2JkMjInLCAnI2RiZGI4ZCcsICcjMTdiZWNmJywgJyM5ZWRhZTUnXTtcblxuICAgIGNhc2UgJ2NhdGVnb3J5MjBiJzpcbiAgICAgIHJldHVybiBbJyMzOTNiNzknLCAnIzUyNTRhMycsICcjNmI2ZWNmJywgJyM5YzllZGUnLCAnIzYzNzkzOScsICcjOGNhMjUyJywgJyNiNWNmNmInLCAnI2NlZGI5YycsICcjOGM2ZDMxJywgJyNiZDllMzknLCAnI2U3YmE1MicsICcjZTdjYjk0JywgJyM4NDNjMzknLCAnI2FkNDk0YScsICcjZDY2MTZiJywgJyNlNzk2OWMnLCAnIzdiNDE3MycsICcjYTU1MTk0JywgJyNjZTZkYmQnLCAnI2RlOWVkNiddO1xuXG4gICAgY2FzZSAnY2F0ZWdvcnkyMGMnOlxuICAgICAgcmV0dXJuIFsnIzMxODJiZCcsICcjNmJhZWQ2JywgJyM5ZWNhZTEnLCAnI2M2ZGJlZicsICcjZTY1NTBkJywgJyNmZDhkM2MnLCAnI2ZkYWU2YicsICcjZmRkMGEyJywgJyMzMWEzNTQnLCAnIzc0YzQ3NicsICcjYTFkOTliJywgJyNjN2U5YzAnLCAnIzc1NmJiMScsICcjOWU5YWM4JywgJyNiY2JkZGMnLCAnI2RhZGFlYicsICcjNjM2MzYzJywgJyM5Njk2OTYnLCAnI2JkYmRiZCcsICcjZDlkOWQ5J107XG4gIH1cblxuICAvLyBUT0RPIGFkZCBvdXIgb3duIHNldCBvZiBjdXN0b20gb3JkaW5hbCBjb2xvciBwYWxldHRlXG5cbiAgaWYgKHJhbmdlIGluIGNvbG9yYnJld2VyKSB7XG4gICAgdmFyIHBhbGV0dGUgPSBjb2xvcmJyZXdlcltyYW5nZV07XG5cbiAgICAvLyBpZiBjYXJkaW5hbGl0eSBwcmUtZGVmaW5lZCwgdXNlIGl0LlxuICAgIGlmIChjYXJkaW5hbGl0eSBpbiBwYWxldHRlKSByZXR1cm4gcGFsZXR0ZVtjYXJkaW5hbGl0eV07XG5cbiAgICAvLyBpZiBub3QsIHVzZSB0aGUgaGlnaGVzdCBjYXJkaW5hbGl0eSBvbmUgZm9yIG5vbWluYWxcbiAgICBpZiAodHlwZSA9PT0gTikge1xuICAgICAgcmV0dXJuIHBhbGV0dGVbTWF0aC5tYXguYXBwbHkobnVsbCwgdXRpbC5rZXlzKHBhbGV0dGUpKV07XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlLCBpbnRlcnBvbGF0ZVxuICAgIHZhciBwcyA9IGNhcmRpbmFsaXR5IDwgMyA/IDMgOiBNYXRoLm1heC5hcHBseShudWxsLCB1dGlsLmtleXMocGFsZXR0ZSkpLFxuICAgICAgZnJvbSA9IDAgLCB0byA9IHBzIC0gMTtcbiAgICAvLyBGSVhNRSBhZGQgY29uZmlnIGZvciBmcm9tIC8gdG9cblxuICAgIHJldHVybiBzY2FsZS5jb2xvci5pbnRlcnBvbGF0ZShwYWxldHRlW3BzXVtmcm9tXSwgcGFsZXR0ZVtwc11bdG9dLCBjYXJkaW5hbGl0eSk7XG4gIH1cblxuICByZXR1cm4gcmFuZ2U7XG59O1xuXG5zY2FsZS5jb2xvci5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBjYXJkaW5hbGl0eSkge1xuXG4gIHZhciBpbnRlcnBvbGF0b3IgPSBpbnRlcnBvbGF0ZShzdGFydCwgZW5kKTtcbiAgcmV0dXJuIHV0aWwucmFuZ2UoY2FyZGluYWxpdHkpLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBpbnRlcnBvbGF0b3IoaSoxLjAvKGNhcmRpbmFsaXR5LTEpKTsgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciB2bGZpZWxkID0gcmVxdWlyZSgnLi4vZmllbGQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0O1xuXG4vLyBhZGRzIG5ldyB0cmFuc2Zvcm1zIHRoYXQgcHJvZHVjZSBzb3J0ZWQgZmllbGRzXG5mdW5jdGlvbiBzb3J0KGRhdGEsIGVuY29kaW5nLCBzdGF0cywgb3B0KSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcblxuICB2YXIgZGF0YXNldE1hcHBpbmcgPSB7fTtcblxuICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBlbmNUeXBlKSB7XG4gICAgdmFyIHNvcnRCeSA9IGVuY29kaW5nLnNvcnQoZW5jVHlwZSwgc3RhdHMpO1xuICAgIGlmIChzb3J0QnkubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGZpZWxkcyA9IHNvcnRCeS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG9wOiBkLmFnZ3JlZ2F0ZSxcbiAgICAgICAgICBmaWVsZDogdmxmaWVsZC5maWVsZFJlZihkLCB7bm9mbjogdHJ1ZSwgZGF0YTogIWVuY29kaW5nLl92ZWdhMn0pXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgdmFyIGJ5Q2xhdXNlID0gc29ydEJ5Lm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgIHZhciByZXZlcnNlID0gKGQucmV2ZXJzZSA/ICctJyA6ICcnKTtcbiAgICAgICAgcmV0dXJuIHJldmVyc2UgKyB2bGZpZWxkLmZpZWxkUmVmKGQsIHtkYXRhOiAhZW5jb2RpbmcuX3ZlZ2EyfSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGRhdGFOYW1lID0gc29ydC5nZXREYXRhTmFtZShlbmNUeXBlKTtcblxuICAgICAgdmFyIHRyYW5zZm9ybXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgICAgICBncm91cGJ5OiBbIGVuY29kaW5nLmZpZWxkUmVmKGVuY1R5cGUpIF0sXG4gICAgICAgICAgZmllbGRzOiBmaWVsZHNcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICdzb3J0JyxcbiAgICAgICAgICBieTogYnlDbGF1c2VcbiAgICAgICAgfVxuICAgICAgXTtcblxuICAgICAgZGF0YS5wdXNoKHtcbiAgICAgICAgbmFtZTogZGF0YU5hbWUsXG4gICAgICAgIHNvdXJjZTogUkFXLFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybXNcbiAgICAgIH0pO1xuXG4gICAgICBkYXRhc2V0TWFwcGluZ1tlbmNUeXBlXSA9IGRhdGFOYW1lO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbnNvcnQuZ2V0RGF0YU5hbWUgPSBmdW5jdGlvbihlbmNUeXBlKSB7XG4gIHJldHVybiAnc29ydGVkLScgKyBlbmNUeXBlO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciAgbWFya3MgPSByZXF1aXJlKCcuL21hcmtzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tpbmc7XG5cbmZ1bmN0aW9uIHN0YWNraW5nKGRhdGEsIGVuY29kaW5nLCBtZGVmKSB7XG4gIGlmICghbWFya3NbZW5jb2RpbmcubWFya3R5cGUoKV0uc3RhY2spIHJldHVybiBmYWxzZTtcblxuICAvLyBUT0RPOiBhZGQgfHwgZW5jb2RpbmcuaGFzKExPRCkgaGVyZSBvbmNlIExPRCBpcyBpbXBsZW1lbnRlZFxuICBpZiAoIWVuY29kaW5nLmhhcyhDT0xPUikpIHJldHVybiBmYWxzZTtcblxuICB2YXIgZGltPW51bGwsIHZhbD1udWxsLCBpZHggPW51bGwsXG4gICAgaXNYTWVhc3VyZSA9IGVuY29kaW5nLmlzTWVhc3VyZShYKSxcbiAgICBpc1lNZWFzdXJlID0gZW5jb2RpbmcuaXNNZWFzdXJlKFkpLFxuICAgIGZhY2V0cyA9IGVuY29kaW5nLmZhY2V0cygpO1xuXG4gIGlmIChpc1hNZWFzdXJlICYmICFpc1lNZWFzdXJlKSB7XG4gICAgZGltID0gWTtcbiAgICB2YWwgPSBYO1xuICAgIGlkeCA9IDA7XG4gIH0gZWxzZSBpZiAoaXNZTWVhc3VyZSAmJiAhaXNYTWVhc3VyZSkge1xuICAgIGRpbSA9IFg7XG4gICAgdmFsID0gWTtcbiAgICBpZHggPSAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsOyAvLyBubyBzdGFjayBlbmNvZGluZ1xuICB9XG5cbiAgLy8gYWRkIHRyYW5zZm9ybSB0byBjb21wdXRlIHN1bXMgZm9yIHNjYWxlXG4gIHZhciBzdGFja2VkID0ge1xuICAgIG5hbWU6IFNUQUNLRUQsXG4gICAgc291cmNlOiBlbmNvZGluZy5kYXRhVGFibGUoKSxcbiAgICB0cmFuc2Zvcm06IFt7XG4gICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgIGdyb3VwYnk6IFtlbmNvZGluZy5maWVsZFJlZihkaW0pXS5jb25jYXQoZmFjZXRzKSwgLy8gZGltIGFuZCBvdGhlciBmYWNldHNcbiAgICAgIGZpZWxkczogW3tvcDogJ3N1bScsIGZpZWxkOiBlbmNvZGluZy5maWVsZFJlZih2YWwpfV0gLy8gVE9ETyBjaGVjayBpZiBmaWVsZCB3aXRoIGFnZ3JlZ2F0ZSBpcyBjb3JyZWN0P1xuICAgIH1dXG4gIH07XG5cbiAgaWYgKGZhY2V0cyAmJiBmYWNldHMubGVuZ3RoID4gMCkge1xuICAgIHN0YWNrZWQudHJhbnNmb3JtLnB1c2goeyAvL2NhbGN1bGF0ZSBtYXggZm9yIGVhY2ggZmFjZXRcbiAgICAgIHR5cGU6ICdhZ2dyZWdhdGUnLFxuICAgICAgZ3JvdXBieTogZmFjZXRzLFxuICAgICAgZmllbGRzOiBbe1xuICAgICAgICBvcDogJ21heCcsXG4gICAgICAgIGZpZWxkOiBlbmNvZGluZy5maWVsZE5hbWUodmFsLCB7Zm46ICdzdW0nfSlcbiAgICAgIH1dXG4gICAgfSk7XG4gIH1cblxuICBkYXRhLnB1c2goc3RhY2tlZCk7XG5cbiAgLy8gYWRkIHN0YWNrIHRyYW5zZm9ybSB0byBtYXJrXG4gIG1kZWYuZnJvbS50cmFuc2Zvcm0gPSBbe1xuICAgIHR5cGU6ICdzdGFjaycsXG4gICAgcG9pbnQ6IGVuY29kaW5nLmZpZWxkUmVmKGRpbSksXG4gICAgaGVpZ2h0OiBlbmNvZGluZy5maWVsZFJlZih2YWwpLFxuICAgIG91dHB1dDoge3kxOiB2YWwsIHkwOiB2YWwgKyAnMid9XG4gIH1dO1xuXG4gIC8vIFRPRE86IFRoaXMgaXMgc3VwZXIgaGFjay1pc2ggLS0gY29uc29saWRhdGUgaW50byBtb2R1bGFyIG1hcmsgcHJvcGVydGllcz9cbiAgbWRlZi5wcm9wZXJ0aWVzLnVwZGF0ZVt2YWxdID0gbWRlZi5wcm9wZXJ0aWVzLmVudGVyW3ZhbF0gPSB7c2NhbGU6IHZhbCwgZmllbGQ6IHZhbH07XG4gIG1kZWYucHJvcGVydGllcy51cGRhdGVbdmFsICsgJzInXSA9IG1kZWYucHJvcGVydGllcy5lbnRlclt2YWwgKyAnMiddID0ge3NjYWxlOiB2YWwsIGZpZWxkOiB2YWwgKyAnMid9O1xuXG4gIHJldHVybiB2YWw7IC8vcmV0dXJuIHN0YWNrIGVuY29kaW5nXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIHZsZmllbGQgPSByZXF1aXJlKCcuLi9maWVsZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBzdGF0cykge1xuICByZXR1cm4ge1xuICAgIG9wYWNpdHk6IGVzdGltYXRlT3BhY2l0eShlbmNvZGluZywgc3RhdHMpLFxuICB9O1xufTtcblxuZnVuY3Rpb24gZXN0aW1hdGVPcGFjaXR5KGVuY29kaW5nLHN0YXRzKSB7XG4gIGlmICghc3RhdHMpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBudW1Qb2ludHMgPSAwO1xuXG4gIGlmIChlbmNvZGluZy5pc0FnZ3JlZ2F0ZSgpKSB7IC8vIGFnZ3JlZ2F0ZSBwbG90XG4gICAgbnVtUG9pbnRzID0gMTtcblxuICAgIC8vICBnZXQgbnVtYmVyIG9mIHBvaW50cyBpbiBlYWNoIFwiY2VsbFwiXG4gICAgLy8gIGJ5IGNhbGN1bGF0aW5nIHByb2R1Y3Qgb2YgY2FyZGluYWxpdHlcbiAgICAvLyAgZm9yIGVhY2ggbm9uIGZhY2V0aW5nIGFuZCBub24tb3JkaW5hbCBYIC8gWSBmaWVsZHNcbiAgICAvLyAgbm90ZSB0aGF0IG9yZGluYWwgeCx5IGFyZSBub3QgaW5jbHVkZSBzaW5jZSB3ZSBjYW5cbiAgICAvLyAgY29uc2lkZXIgdGhhdCBvcmRpbmFsIHggYXJlIHN1YmRpdmlkaW5nIHRoZSBjZWxsIGludG8gc3ViY2VsbHMgYW55d2F5XG4gICAgZW5jb2RpbmcuZm9yRWFjaChmdW5jdGlvbihmaWVsZCwgZW5jVHlwZSkge1xuXG4gICAgICBpZiAoZW5jVHlwZSAhPT0gUk9XICYmIGVuY1R5cGUgIT09IENPTCAmJlxuICAgICAgICAgICEoKGVuY1R5cGUgPT09IFggfHwgZW5jVHlwZSA9PT0gWSkgJiZcbiAgICAgICAgICB2bGZpZWxkLmlzT3JkaW5hbFNjYWxlKGZpZWxkKSlcbiAgICAgICAgKSB7XG4gICAgICAgIG51bVBvaW50cyAqPSBlbmNvZGluZy5jYXJkaW5hbGl0eShlbmNUeXBlLCBzdGF0cyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfSBlbHNlIHsgLy8gcmF3IHBsb3RcblxuICAgIC8vIFRPRE86IGVycm9yIGhhbmRsaW5nXG4gICAgaWYgKCFzdGF0c1snKiddKVxuICAgICAgcmV0dXJuIDE7XG5cbiAgICBudW1Qb2ludHMgPSBzdGF0c1snKiddLm1heDsgIC8vIGNvdW50XG5cbiAgICAvLyBzbWFsbCBtdWx0aXBsZXMgZGl2aWRlIG51bWJlciBvZiBwb2ludHNcbiAgICB2YXIgbnVtTXVsdGlwbGVzID0gMTtcbiAgICBpZiAoZW5jb2RpbmcuaGFzKFJPVykpIHtcbiAgICAgIG51bU11bHRpcGxlcyAqPSBlbmNvZGluZy5jYXJkaW5hbGl0eShST1csIHN0YXRzKTtcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nLmhhcyhDT0wpKSB7XG4gICAgICBudW1NdWx0aXBsZXMgKj0gZW5jb2RpbmcuY2FyZGluYWxpdHkoQ09MLCBzdGF0cyk7XG4gICAgfVxuICAgIG51bVBvaW50cyAvPSBudW1NdWx0aXBsZXM7XG4gIH1cblxuICB2YXIgb3BhY2l0eSA9IDA7XG4gIGlmIChudW1Qb2ludHMgPD0gMjUpIHtcbiAgICBvcGFjaXR5ID0gMTtcbiAgfSBlbHNlIGlmIChudW1Qb2ludHMgPCAyMDApIHtcbiAgICBvcGFjaXR5ID0gMC44O1xuICB9IGVsc2UgaWYgKG51bVBvaW50cyA8IDEwMDAgfHwgZW5jb2RpbmcuaXMoJ3RpY2snKSkge1xuICAgIG9wYWNpdHkgPSAwLjc7XG4gIH0gZWxzZSB7XG4gICAgb3BhY2l0eSA9IDAuMztcbiAgfVxuXG4gIHJldHVybiBvcGFjaXR5O1xufVxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdWJmYWNldGluZztcblxuZnVuY3Rpb24gc3ViZmFjZXRpbmcoZ3JvdXAsIG1kZWYsIGRldGFpbHMsIHN0YWNrLCBlbmNvZGluZykge1xuICB2YXIgbSA9IGdyb3VwLm1hcmtzO1xuICB2YXIgZyA9IHtcbiAgICBfbmFtZTogJ3N1YmZhY2V0JyxcbiAgICB0eXBlOiAnZ3JvdXAnLFxuICAgIGZyb206IG1kZWYuZnJvbSxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICB3aWR0aDoge2dyb3VwOiAnd2lkdGgnfSxcbiAgICAgICAgaGVpZ2h0OiB7Z3JvdXA6ICdoZWlnaHQnfVxuICAgICAgfVxuICAgIH0sXG4gICAgbWFya3M6IG1cbiAgfTtcblxuICBncm91cC5tYXJrcyA9IFtnXTtcbiAgZGVsZXRlIG1kZWYuZnJvbTsgLy8gKG1vdmUgdG8gdGhlIG5ldyBnKVxuXG4gIC8vVE9ETyB0ZXN0IExPRCAtLSB3ZSBzaG91bGQgc3VwcG9ydCBzdGFjayAvIGxpbmUgd2l0aG91dCBjb2xvciAoTE9EKSBmaWVsZFxuICB2YXIgdHJhbnMgPSAoZy5mcm9tLnRyYW5zZm9ybSB8fCAoZy5mcm9tLnRyYW5zZm9ybSA9IFtdKSk7XG4gIHRyYW5zLnVuc2hpZnQoe3R5cGU6ICdmYWNldCcsIGtleXM6IGRldGFpbHN9KTtcblxuICBpZiAoc3RhY2sgJiYgZW5jb2RpbmcuaGFzKENPTE9SKSkge1xuICAgIHRyYW5zLnVuc2hpZnQoe3R5cGU6ICdzb3J0JywgYnk6IGVuY29kaW5nLmZpZWxkUmVmKENPTE9SKX0pO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICBkM190aW1lX2Zvcm1hdCA9IHJlcXVpcmUoJ2QzLXRpbWUtZm9ybWF0Jyk7XG5cbnZhciB0aW1lID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gJ1dlZG5lc2RheSBTZXB0ZW1iZXIgMTcgMDQ6MDA6MDAgMjAxNCdcbi8vIFdlZG5lc2RheSBpcyB0aGUgbG9uZ2VzdCBkYXRlXG4vLyBTZXB0ZW1iZXIgaXMgdGhlIGxvbmdlc3QgbW9udGggKDggaW4gamF2YXNjcmlwdCBhcyBpdCBpcyB6ZXJvLWluZGV4ZWQpLlxudmFyIExPTkdfREFURSA9IG5ldyBEYXRlKERhdGUuVVRDKDIwMTQsIDgsIDE3KSk7XG5cbnRpbWUuY2FyZGluYWxpdHkgPSBmdW5jdGlvbihmaWVsZCwgc3RhdHMsIGZpbHRlck51bGwsIHR5cGUpIHtcbiAgdmFyIHRpbWVVbml0ID0gZmllbGQudGltZVVuaXQ7XG4gIHN3aXRjaCAodGltZVVuaXQpIHtcbiAgICBjYXNlICdzZWNvbmRzJzogcmV0dXJuIDYwO1xuICAgIGNhc2UgJ21pbnV0ZXMnOiByZXR1cm4gNjA7XG4gICAgY2FzZSAnaG91cnMnOiByZXR1cm4gMjQ7XG4gICAgY2FzZSAnZGF5JzogcmV0dXJuIDc7XG4gICAgY2FzZSAnZGF0ZSc6IHJldHVybiAzMTtcbiAgICBjYXNlICdtb250aCc6IHJldHVybiAxMjtcbiAgICBjYXNlICd5ZWFyJzpcbiAgICAgIHZhciBzdGF0ID0gc3RhdHNbZmllbGQubmFtZV0sXG4gICAgICAgIHllYXJzdGF0ID0gc3RhdHNbJ3llYXJfJytmaWVsZC5uYW1lXTtcblxuICAgICAgaWYgKCF5ZWFyc3RhdCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICByZXR1cm4geWVhcnN0YXQuZGlzdGluY3QgLVxuICAgICAgICAoc3RhdC5udWxscyA+IDAgJiYgZmlsdGVyTnVsbFt0eXBlXSA/IDEgOiAwKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxudGltZS5mb3JtdWxhID0gZnVuY3Rpb24odGltZVVuaXQsIGZpZWxkUmVmKSB7XG4gIC8vIFRPRE8oa2FuaXR3KTogYWRkIGZvcm11bGEgdG8gb3RoZXIgdGltZSBmb3JtYXRcbiAgdmFyIGZuID0gJ3V0YycgKyB0aW1lVW5pdDtcbiAgcmV0dXJuIGZuICsgJygnICsgZmllbGRSZWYgKyAnKSc7XG59O1xuXG50aW1lLm1heExlbmd0aCA9IGZ1bmN0aW9uKHRpbWVVbml0LCBlbmNvZGluZykge1xuICBzd2l0Y2ggKHRpbWVVbml0KSB7XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSAnbW9udGgnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgICB2YXIgcmFuZ2UgPSB0aW1lLnJhbmdlKHRpbWVVbml0LCBlbmNvZGluZyk7XG4gICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBsb25nZXN0IG5hbWUgaW4gdGhlIHJhbmdlXG4gICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCByYW5nZS5tYXAoZnVuY3Rpb24ocikge3JldHVybiByLmxlbmd0aDt9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlICd5ZWFyJzpcbiAgICAgIHJldHVybiA0OyAvLycxOTk4J1xuICB9XG4gIC8vIFRPRE8oIzYwMCkgcmV2aXNlIHRoaXNcbiAgLy8gbm8gdGltZSB1bml0XG4gIHZhciB0aW1lRm9ybWF0ID0gZW5jb2RpbmcuY29uZmlnKCd0aW1lRm9ybWF0Jyk7XG4gIHJldHVybiBkM190aW1lX2Zvcm1hdC51dGNGb3JtYXQodGltZUZvcm1hdCkoTE9OR19EQVRFKS5sZW5ndGg7XG59O1xuXG50aW1lLnJhbmdlID0gZnVuY3Rpb24odGltZVVuaXQsIGVuY29kaW5nKSB7XG4gIHZhciBsYWJlbExlbmd0aCA9IGVuY29kaW5nLmNvbmZpZygndGltZVNjYWxlTGFiZWxMZW5ndGgnKSxcbiAgICBzY2FsZUxhYmVsO1xuICBzd2l0Y2ggKHRpbWVVbml0KSB7XG4gICAgY2FzZSAnZGF5JzpcbiAgICAgIHNjYWxlTGFiZWwgPSBlbmNvZGluZy5jb25maWcoJ2RheVNjYWxlTGFiZWwnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIHNjYWxlTGFiZWwgPSBlbmNvZGluZy5jb25maWcoJ21vbnRoU2NhbGVMYWJlbCcpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgaWYgKHNjYWxlTGFiZWwpIHtcbiAgICByZXR1cm4gbGFiZWxMZW5ndGggPyBzY2FsZUxhYmVsLm1hcChcbiAgICAgICAgZnVuY3Rpb24ocykgeyByZXR1cm4gcy5zdWJzdHIoMCwgbGFiZWxMZW5ndGgpO31cbiAgICAgICkgOiBzY2FsZUxhYmVsO1xuICB9XG4gIHJldHVybjtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGVuY29kaW5nXG4gKiBAcmV0dXJuIHtBcnJheX0gIHNjYWxlcyBmb3IgdGltZSB1bml0IG5hbWVzXG4gKi9cbnRpbWUuc2NhbGVzID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdmFyIHNjYWxlcyA9IGVuY29kaW5nLnJlZHVjZShmdW5jdGlvbihzY2FsZXMsIGZpZWxkKSB7XG4gICAgdmFyIHRpbWVVbml0ID0gZmllbGQudGltZVVuaXQ7XG4gICAgaWYgKGZpZWxkLnR5cGUgPT09IFQgJiYgdGltZVVuaXQgJiYgIXNjYWxlc1t0aW1lVW5pdF0pIHtcbiAgICAgIHZhciBzY2FsZSA9IHRpbWUuc2NhbGUuZGVmKGZpZWxkLnRpbWVVbml0LCBlbmNvZGluZyk7XG4gICAgICBpZiAoc2NhbGUpIHNjYWxlc1t0aW1lVW5pdF0gPSBzY2FsZTtcbiAgICB9XG4gICAgcmV0dXJuIHNjYWxlcztcbiAgfSwge30pO1xuXG4gIHJldHVybiB1dGlsLnZhbHMoc2NhbGVzKTtcbn07XG5cblxudGltZS5zY2FsZSA9IHt9O1xuXG4vKiogYXBwZW5kIGN1c3RvbSB0aW1lIHNjYWxlcyBmb3IgYXhpcyBsYWJlbCAqL1xudGltZS5zY2FsZS5kZWYgPSBmdW5jdGlvbih0aW1lVW5pdCwgZW5jb2RpbmcpIHtcbiAgdmFyIHJhbmdlID0gdGltZS5yYW5nZSh0aW1lVW5pdCwgZW5jb2RpbmcpO1xuXG4gIGlmIChyYW5nZSkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiAndGltZS0nK3RpbWVVbml0LFxuICAgICAgdHlwZTogJ29yZGluYWwnLFxuICAgICAgZG9tYWluOiB0aW1lLnNjYWxlLmRvbWFpbih0aW1lVW5pdCksXG4gICAgICByYW5nZTogcmFuZ2VcbiAgICB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxudGltZS5pc09yZGluYWxGbiA9IGZ1bmN0aW9uKHRpbWVVbml0KSB7XG4gIHN3aXRjaCAodGltZVVuaXQpIHtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkYXRlJzpcbiAgICBjYXNlICdtb250aCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG50aW1lLnNjYWxlLnR5cGUgPSBmdW5jdGlvbih0aW1lVW5pdCwgbmFtZSkge1xuICBpZiAobmFtZSA9PT0gQ09MT1IpIHtcbiAgICByZXR1cm4gJ2xpbmVhcic7IC8vIHRpbWUgaGFzIG9yZGVyLCBzbyB1c2UgaW50ZXJwb2xhdGVkIG9yZGluYWwgY29sb3Igc2NhbGUuXG4gIH1cblxuICByZXR1cm4gdGltZS5pc09yZGluYWxGbih0aW1lVW5pdCkgfHwgbmFtZSA9PT0gQ09MIHx8IG5hbWUgPT09IFJPVyA/ICdvcmRpbmFsJyA6ICdsaW5lYXInO1xufTtcblxudGltZS5zY2FsZS5kb21haW4gPSBmdW5jdGlvbih0aW1lVW5pdCwgbmFtZSkge1xuICB2YXIgaXNDb2xvciA9IG5hbWUgPT09IENPTE9SO1xuICBzd2l0Y2ggKHRpbWVVbml0KSB7XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnbWludXRlcyc6IHJldHVybiBpc0NvbG9yID8gWzAsNTldIDogdXRpbC5yYW5nZSgwLCA2MCk7XG4gICAgY2FzZSAnaG91cnMnOiByZXR1cm4gaXNDb2xvciA/IFswLDIzXSA6IHV0aWwucmFuZ2UoMCwgMjQpO1xuICAgIGNhc2UgJ2RheSc6IHJldHVybiBpc0NvbG9yID8gWzAsNl0gOiB1dGlsLnJhbmdlKDAsIDcpO1xuICAgIGNhc2UgJ2RhdGUnOiByZXR1cm4gaXNDb2xvciA/IFsxLDMxXSA6IHV0aWwucmFuZ2UoMSwgMzIpO1xuICAgIGNhc2UgJ21vbnRoJzogcmV0dXJuIGlzQ29sb3IgPyBbMCwxMV0gOiB1dGlsLnJhbmdlKDAsIDEyKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKiB3aGV0aGVyIGEgcGFydGljdWxhciB0aW1lIGZ1bmN0aW9uIGhhcyBjdXN0b20gc2NhbGUgZm9yIGxhYmVscyBpbXBsZW1lbnRlZCBpbiB0aW1lLnNjYWxlICovXG50aW1lLmhhc1NjYWxlID0gZnVuY3Rpb24odGltZVVuaXQpIHtcbiAgc3dpdGNoICh0aW1lVW5pdCkge1xuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnbW9udGgnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9nbG9iYWxzJyk7XG5cbnZhciBjb25zdHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5jb25zdHMuZW5jb2RpbmdUeXBlcyA9IFtYLCBZLCBST1csIENPTCwgU0laRSwgU0hBUEUsIENPTE9SLCBURVhULCBERVRBSUxdO1xuXG5jb25zdHMuc2hvcnRoYW5kID0ge1xuICBkZWxpbTogICd8JyxcbiAgYXNzaWduOiAnPScsXG4gIHR5cGU6ICAgJywnLFxuICBmdW5jOiAgICdfJ1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9nbG9iYWxzJyk7XG5cbnZhciBzdGF0cyA9IHJlcXVpcmUoJ2RhdGFsaWIvc3JjL3N0YXRzJyk7XG5cbnZhciB2bGRhdGEgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vKiogTWFwcGluZyBmcm9tIGRhdGFsaWIncyBpbmZlcnJlZCB0eXBlIHRvIFZlZ2EtbGl0ZSdzIHR5cGUgKi9cbnZsZGF0YS50eXBlcyA9IHtcbiAgJ2Jvb2xlYW4nOiBOLFxuICAnbnVtYmVyJzogUSxcbiAgJ2ludGVnZXInOiBRLFxuICAnZGF0ZSc6IFQsXG4gICdzdHJpbmcnOiBOXG59O1xuXG52bGRhdGEuc3RhdHMgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciBzdW1tYXJ5ID0gc3RhdHMuc3VtbWFyeShkYXRhKTtcblxuICByZXR1cm4gc3VtbWFyeS5yZWR1Y2UoZnVuY3Rpb24ocywgcHJvZmlsZSkge1xuICAgIHNbcHJvZmlsZS5maWVsZF0gPSBwcm9maWxlO1xuICAgIHJldHVybiBzO1xuICB9LCB7XG4gICAgJyonOiB7XG4gICAgICBtYXg6IGRhdGEubGVuZ3RoLFxuICAgICAgbWluOiAwXG4gICAgfVxuICB9KTtcbn07IiwiLy8gdXRpbGl0eSBmb3IgZW5jXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNvbnN0cyA9IHJlcXVpcmUoJy4vY29uc3RzJyksXG4gIGMgPSBjb25zdHMuc2hvcnRoYW5kLFxuICB2bGZpZWxkID0gcmVxdWlyZSgnLi9maWVsZCcpLFxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gIHNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hL3NjaGVtYScpLFxuICBlbmNUeXBlcyA9IHNjaGVtYS5lbmNUeXBlcztcblxudmFyIHZsZW5jID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxudmxlbmMuY291bnRSZXRpbmFsID0gZnVuY3Rpb24oZW5jKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIGlmIChlbmMuY29sb3IpIGNvdW50Kys7XG4gIGlmIChlbmMuc2l6ZSkgY291bnQrKztcbiAgaWYgKGVuYy5zaGFwZSkgY291bnQrKztcbiAgcmV0dXJuIGNvdW50O1xufTtcblxudmxlbmMuaGFzID0gZnVuY3Rpb24oZW5jLCBlbmNUeXBlKSB7XG4gIHZhciBmaWVsZERlZiA9IGVuYyAmJiBlbmNbZW5jVHlwZV07XG4gIHJldHVybiBmaWVsZERlZiAmJiBmaWVsZERlZi5uYW1lO1xufTtcblxudmxlbmMuaXNBZ2dyZWdhdGUgPSBmdW5jdGlvbihlbmMpIHtcbiAgZm9yICh2YXIgayBpbiBlbmMpIHtcbiAgICBpZiAodmxlbmMuaGFzKGVuYywgaykgJiYgZW5jW2tdLmFnZ3JlZ2F0ZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZsZW5jLmZvckVhY2ggPSBmdW5jdGlvbihlbmMsIGYpIHtcbiAgdmFyIGkgPSAwO1xuICBlbmNUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICBpZiAodmxlbmMuaGFzKGVuYywgaykpIHtcbiAgICAgIGYoZW5jW2tdLCBrLCBpKyspO1xuICAgIH1cbiAgfSk7XG59O1xuXG52bGVuYy5tYXAgPSBmdW5jdGlvbihlbmMsIGYpIHtcbiAgdmFyIGFyciA9IFtdO1xuICBlbmNUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICBpZiAodmxlbmMuaGFzKGVuYywgaykpIHtcbiAgICAgIGFyci5wdXNoKGYoZW5jW2tdLCBrLCBlbmMpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYXJyO1xufTtcblxudmxlbmMucmVkdWNlID0gZnVuY3Rpb24oZW5jLCBmLCBpbml0KSB7XG4gIHZhciByID0gaW5pdDtcbiAgZW5jVHlwZXMuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgaWYgKHZsZW5jLmhhcyhlbmMsIGspKSB7XG4gICAgICByID0gZihyLCBlbmNba10sIGssICBlbmMpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByO1xufTtcblxuLypcbiAqIHJldHVybiBrZXktdmFsdWUgcGFpcnMgb2YgZmllbGQgbmFtZSBhbmQgbGlzdCBvZiBmaWVsZHMgb2YgdGhhdCBmaWVsZCBuYW1lXG4gKi9cbnZsZW5jLmZpZWxkcyA9IGZ1bmN0aW9uKGVuYykge1xuICByZXR1cm4gdmxlbmMucmVkdWNlKGVuYywgZnVuY3Rpb24gKG0sIGZpZWxkKSB7XG4gICAgdmFyIGZpZWxkTGlzdCA9IG1bZmllbGQubmFtZV0gPSBtW2ZpZWxkLm5hbWVdIHx8IFtdLFxuICAgICAgY29udGFpbnNUeXBlID0gZmllbGRMaXN0LmNvbnRhaW5zVHlwZSA9IGZpZWxkTGlzdC5jb250YWluc1R5cGUgfHwge307XG5cbiAgICBpZiAoZmllbGRMaXN0LmluZGV4T2YoZmllbGQpID09PSAtMSkge1xuICAgICAgZmllbGRMaXN0LnB1c2goZmllbGQpO1xuICAgICAgLy8gYXVnbWVudCB0aGUgYXJyYXkgd2l0aCBjb250YWluc1R5cGUuUSAvIE8gLyBOIC8gVFxuICAgICAgY29udGFpbnNUeXBlW2ZpZWxkLnR5cGVdID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG07XG4gIH0sIHt9KTtcbn07XG5cbnZsZW5jLnNob3J0aGFuZCA9IGZ1bmN0aW9uKGVuYykge1xuICByZXR1cm4gdmxlbmMubWFwKGVuYywgZnVuY3Rpb24oZmllbGQsIGV0KSB7XG4gICAgcmV0dXJuIGV0ICsgYy5hc3NpZ24gKyB2bGZpZWxkLnNob3J0aGFuZChmaWVsZCk7XG4gIH0pLmpvaW4oYy5kZWxpbSk7XG59O1xuXG52bGVuYy5mcm9tU2hvcnRoYW5kID0gZnVuY3Rpb24oc2hvcnRoYW5kKSB7XG4gIHZhciBlbmMgPSB1dGlsLmlzQXJyYXkoc2hvcnRoYW5kKSA/IHNob3J0aGFuZCA6IHNob3J0aGFuZC5zcGxpdChjLmRlbGltKTtcbiAgcmV0dXJuIGVuYy5yZWR1Y2UoZnVuY3Rpb24obSwgZSkge1xuICAgIHZhciBzcGxpdCA9IGUuc3BsaXQoYy5hc3NpZ24pLFxuICAgICAgICBlbmN0eXBlID0gc3BsaXRbMF0udHJpbSgpLFxuICAgICAgICBmaWVsZCA9IHNwbGl0WzFdO1xuXG4gICAgbVtlbmN0eXBlXSA9IHZsZmllbGQuZnJvbVNob3J0aGFuZChmaWVsZCk7XG4gICAgcmV0dXJuIG07XG4gIH0sIHt9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIHV0aWxpdHkgZm9yIGZpZWxkXG5cbnJlcXVpcmUoJy4vZ2xvYmFscycpO1xuXG52YXIgY29uc3RzID0gcmVxdWlyZSgnLi9jb25zdHMnKSxcbiAgYyA9IGNvbnN0cy5zaG9ydGhhbmQsXG4gIHRpbWUgPSByZXF1aXJlKCcuL2NvbXBpbGVyL3RpbWUnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICBzY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYS9zY2hlbWEnKTtcblxudmFyIHZsZmllbGQgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSBmaWVsZFxuICogQHBhcmFtIG9wdFxuICogICBvcHQubm9mbiAtLSBleGNsdWRlIGJpbiwgYWdncmVnYXRlLCB0aW1lVW5pdFxuICogICBvcHQuZGF0YSAtIGluY2x1ZGUgJ2RhdGEuJ1xuICogICBvcHQuZCAtIGluY2x1ZGUgJ2QuJ1xuICogICBvcHQuZm4gLSByZXBsYWNlIGZuIHdpdGggY3VzdG9tIGZ1bmN0aW9uIHByZWZpeFxuICogICBvcHQucHJlZm4gLSBwcmVwZW5kIGZuIHdpdGggY3VzdG9tIGZ1bmN0aW9uIHByZWZpeFxuXG4gKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xudmxmaWVsZC5maWVsZFJlZiA9IGZ1bmN0aW9uKGZpZWxkLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gIHZhciBmID0gKG9wdC5kID8gJ2QuJyA6ICcnKSArXG4gICAgICAgICAgKG9wdC5kYXRhID8gJ2RhdGEuJyA6ICcnKSArXG4gICAgICAgICAgKG9wdC5wcmVmbiB8fCAnJyksXG4gICAgbm9mbiA9IG9wdC5ub2ZuIHx8IG9wdC5mbixcbiAgICBuYW1lID0gZmllbGQubmFtZTtcblxuICBpZiAodmxmaWVsZC5pc0NvdW50KGZpZWxkKSkge1xuICAgIHJldHVybiBmICsgJ2NvdW50JztcbiAgfSBlbHNlIGlmICghbm9mbiAmJiBmaWVsZC5iaW4pIHtcbiAgICByZXR1cm4gZiArICdiaW5fJyArIG5hbWU7XG4gIH0gZWxzZSBpZiAoIW5vZm4gJiYgZmllbGQuYWdncmVnYXRlKSB7XG4gICAgcmV0dXJuIGYgKyBmaWVsZC5hZ2dyZWdhdGUgKyAnXycgKyBuYW1lO1xuICB9IGVsc2UgaWYgKCFub2ZuICYmIGZpZWxkLnRpbWVVbml0KSB7XG4gICAgcmV0dXJuIGYgKyBmaWVsZC50aW1lVW5pdCArICdfJyArIG5hbWU7XG4gIH0gZWxzZSBpZiAob3B0LmZuKSB7XG4gICAgcmV0dXJuIGYgKyBvcHQuZm4gKyAnXycgKyBuYW1lO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmICsgbmFtZTtcbiAgfVxufTtcblxudmxmaWVsZC5zaG9ydGhhbmQgPSBmdW5jdGlvbihmKSB7XG4gIHZhciBjID0gY29uc3RzLnNob3J0aGFuZDtcbiAgcmV0dXJuIChmLmFnZ3JlZ2F0ZSA/IGYuYWdncmVnYXRlICsgYy5mdW5jIDogJycpICtcbiAgICAoZi50aW1lVW5pdCA/IGYudGltZVVuaXQgKyBjLmZ1bmMgOiAnJykgK1xuICAgIChmLmJpbiA/ICdiaW4nICsgYy5mdW5jIDogJycpICtcbiAgICAoZi5uYW1lIHx8ICcnKSArIGMudHlwZSArIGYudHlwZTtcbn07XG5cbnZsZmllbGQuc2hvcnRoYW5kcyA9IGZ1bmN0aW9uKGZpZWxkcywgZGVsaW0pIHtcbiAgZGVsaW0gPSBkZWxpbSB8fCBjLmRlbGltO1xuICByZXR1cm4gZmllbGRzLm1hcCh2bGZpZWxkLnNob3J0aGFuZCkuam9pbihkZWxpbSk7XG59O1xuXG52bGZpZWxkLmZyb21TaG9ydGhhbmQgPSBmdW5jdGlvbihzaG9ydGhhbmQpIHtcbiAgdmFyIHNwbGl0ID0gc2hvcnRoYW5kLnNwbGl0KGMudHlwZSksIGk7XG4gIHZhciBvID0ge1xuICAgIG5hbWU6IHNwbGl0WzBdLnRyaW0oKSxcbiAgICB0eXBlOiBzcGxpdFsxXS50cmltKClcbiAgfTtcblxuICAvLyBjaGVjayBhZ2dyZWdhdGUgdHlwZVxuICBmb3IgKGkgaW4gc2NoZW1hLmFnZ3JlZ2F0ZS5lbnVtKSB7XG4gICAgdmFyIGEgPSBzY2hlbWEuYWdncmVnYXRlLmVudW1baV07XG4gICAgaWYgKG8ubmFtZS5pbmRleE9mKGEgKyAnXycpID09PSAwKSB7XG4gICAgICBvLm5hbWUgPSBvLm5hbWUuc3Vic3RyKGEubGVuZ3RoICsgMSk7XG4gICAgICBpZiAoYSA9PSAnY291bnQnICYmIG8ubmFtZS5sZW5ndGggPT09IDApIG8ubmFtZSA9ICcqJztcbiAgICAgIG8uYWdncmVnYXRlID0gYTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIHRpbWUgdGltZVVuaXRcbiAgZm9yIChpIGluIHNjaGVtYS50aW1lZm5zKSB7XG4gICAgdmFyIHR1ID0gc2NoZW1hLnRpbWVmbnNbaV07XG4gICAgaWYgKG8ubmFtZSAmJiBvLm5hbWUuaW5kZXhPZih0dSArICdfJykgPT09IDApIHtcbiAgICAgIG8ubmFtZSA9IG8ubmFtZS5zdWJzdHIoby5sZW5ndGggKyAxKTtcbiAgICAgIG8udGltZVVuaXQgPSB0dTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGJpblxuICBpZiAoby5uYW1lICYmIG8ubmFtZS5pbmRleE9mKCdiaW5fJykgPT09IDApIHtcbiAgICBvLm5hbWUgPSBvLm5hbWUuc3Vic3RyKDQpO1xuICAgIG8uYmluID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBvO1xufTtcblxudmFyIGlzVHlwZSA9IHZsZmllbGQuaXNUeXBlID0gZnVuY3Rpb24gKGZpZWxkRGVmLCB0eXBlKSB7XG4gIHJldHVybiBmaWVsZERlZi50eXBlID09PSB0eXBlO1xufTtcblxudmFyIGlzVHlwZXMgPSB2bGZpZWxkLmlzVHlwZXMgPSBmdW5jdGlvbiAoZmllbGREZWYsIHR5cGVzKSB7XG4gIGZvciAodmFyIHQ9MDsgdDx0eXBlcy5sZW5ndGg7IHQrKykge1xuICAgIGlmKGZpZWxkRGVmLnR5cGUgPT09IHR5cGVzW3RdKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKlxuICogTW9zdCBmaWVsZHMgdGhhdCB1c2Ugb3JkaW5hbCBzY2FsZSBhcmUgZGltZW5zaW9ucy5cbiAqIEhvd2V2ZXIsIFlFQVIoVCksIFlFQVJNT05USChUKSB1c2UgdGltZSBzY2FsZSwgbm90IG9yZGluYWwgYnV0IGFyZSBkaW1lbnNpb25zIHRvby5cbiAqL1xudmxmaWVsZC5pc09yZGluYWxTY2FsZSA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiAgaXNUeXBlcyhmaWVsZCwgW04sIE9dKSB8fCBmaWVsZC5iaW4gfHxcbiAgICAoIGlzVHlwZShmaWVsZCwgVCkgJiYgZmllbGQudGltZVVuaXQgJiYgdGltZS5pc09yZGluYWxGbihmaWVsZC50aW1lVW5pdCkgKTtcbn07XG5cbmZ1bmN0aW9uIGlzRGltZW5zaW9uKGZpZWxkKSB7XG4gIHJldHVybiAgaXNUeXBlcyhmaWVsZCwgW04sIE9dKSB8fCAhIWZpZWxkLmJpbiB8fFxuICAgICggaXNUeXBlKGZpZWxkLCBUKSAmJiAhIWZpZWxkLnRpbWVVbml0ICk7XG59XG5cbi8qKlxuICogRm9yIGVuY29kaW5nLCB1c2UgZW5jb2RpbmcuaXNEaW1lbnNpb24oKSB0byBhdm9pZCBjb25mdXNpb24uXG4gKiBPciB1c2UgRW5jb2RpbmcuaXNUeXBlIGlmIHlvdXIgZmllbGQgaXMgZnJvbSBFbmNvZGluZyAoYW5kIHRodXMgaGF2ZSBudW1lcmljIGRhdGEgdHlwZSkuXG4gKiBvdGhlcndpc2UsIGRvIG5vdCBzcGVjaWZpYyBpc1R5cGUgc28gd2UgY2FuIHVzZSB0aGUgZGVmYXVsdCBpc1R5cGVOYW1lIGhlcmUuXG4gKi9cbnZsZmllbGQuaXNEaW1lbnNpb24gPSBmdW5jdGlvbihmaWVsZCkge1xuICByZXR1cm4gZmllbGQgJiYgaXNEaW1lbnNpb24oZmllbGQpO1xufTtcblxudmxmaWVsZC5pc01lYXN1cmUgPSBmdW5jdGlvbihmaWVsZCkge1xuICByZXR1cm4gZmllbGQgJiYgIWlzRGltZW5zaW9uKGZpZWxkKTtcbn07XG5cbnZsZmllbGQuY291bnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtuYW1lOicqJywgYWdncmVnYXRlOiAnY291bnQnLCB0eXBlOiBRLCBkaXNwbGF5TmFtZTogdmxmaWVsZC5jb3VudC5kaXNwbGF5TmFtZX07XG59O1xuXG52bGZpZWxkLmNvdW50LmRpc3BsYXlOYW1lID0gJ051bWJlciBvZiBSZWNvcmRzJztcblxudmxmaWVsZC5pc0NvdW50ID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuIGZpZWxkLmFnZ3JlZ2F0ZSA9PT0gJ2NvdW50Jztcbn07XG5cbi8qKlxuICogRm9yIGVuY29kaW5nLCB1c2UgZW5jb2RpbmcuY2FyZGluYWxpdHkoKSB0byBhdm9pZCBjb25mdXNpb24uICBPciB1c2UgRW5jb2RpbmcuaXNUeXBlIGlmIHlvdXIgZmllbGQgaXMgZnJvbSBFbmNvZGluZyAoYW5kIHRodXMgaGF2ZSBudW1lcmljIGRhdGEgdHlwZSkuXG4gKiBvdGhlcndpc2UsIGRvIG5vdCBzcGVjaWZpYyBpc1R5cGUgc28gd2UgY2FuIHVzZSB0aGUgZGVmYXVsdCBpc1R5cGVOYW1lIGhlcmUuXG4gKi9cbnZsZmllbGQuY2FyZGluYWxpdHkgPSBmdW5jdGlvbihmaWVsZCwgc3RhdHMsIGZpbHRlck51bGwpIHtcbiAgLy8gRklYTUUgbmVlZCB0byB0YWtlIGZpbHRlciBpbnRvIGFjY291bnRcblxuICB2YXIgc3RhdCA9IHN0YXRzW2ZpZWxkLm5hbWVdO1xuICB2YXIgdHlwZSA9IGZpZWxkLnR5cGU7XG5cbiAgZmlsdGVyTnVsbCA9IGZpbHRlck51bGwgfHwge307XG5cbiAgaWYgKGZpZWxkLmJpbikge1xuICAgIHZhciBiaW5zID0gdXRpbC5nZXRiaW5zKHN0YXQsIGZpZWxkLmJpbi5tYXhiaW5zIHx8IHNjaGVtYS5NQVhCSU5TX0RFRkFVTFQpO1xuICAgIHJldHVybiAoYmlucy5zdG9wIC0gYmlucy5zdGFydCkgLyBiaW5zLnN0ZXA7XG4gIH1cbiAgaWYgKGlzVHlwZShmaWVsZCwgVCkpIHtcbiAgICB2YXIgY2FyZGluYWxpdHkgPSB0aW1lLmNhcmRpbmFsaXR5KGZpZWxkLCBzdGF0cywgZmlsdGVyTnVsbCwgdHlwZSk7XG4gICAgaWYoY2FyZGluYWxpdHkgIT09IG51bGwpIHJldHVybiBjYXJkaW5hbGl0eTtcbiAgICAvL290aGVyd2lzZSB1c2UgY2FsY3VsYXRpb24gYmVsb3dcbiAgfVxuICBpZiAoZmllbGQuYWdncmVnYXRlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvLyByZW1vdmUgbnVsbFxuICByZXR1cm4gc3RhdC5kaXN0aW5jdCAtXG4gICAgKHN0YXQubnVsbHMgPiAwICYmIGZpbHRlck51bGxbdHlwZV0gPyAxIDogMCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBkZWNsYXJlIGdsb2JhbCBjb25zdGFudFxudmFyIGcgPSBnbG9iYWwgfHwgd2luZG93O1xuXG5nLkFHR1JFR0FURSA9ICdhZ2dyZWdhdGUnO1xuZy5SQVcgPSAncmF3JztcbmcuU1RBQ0tFRCA9ICdzdGFja2VkJztcbmcuSU5ERVggPSAnaW5kZXgnO1xuXG5nLlggPSAneCc7XG5nLlkgPSAneSc7XG5nLlJPVyA9ICdyb3cnO1xuZy5DT0wgPSAnY29sJztcbmcuU0laRSA9ICdzaXplJztcbmcuU0hBUEUgPSAnc2hhcGUnO1xuZy5DT0xPUiA9ICdjb2xvcic7XG5nLlRFWFQgPSAndGV4dCc7XG5nLkRFVEFJTCA9ICdkZXRhaWwnO1xuXG5nLk4gPSAnTic7XG5nLk8gPSAnTyc7XG5nLlEgPSAnUSc7XG5nLlQgPSAnVCc7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIFRPRE8oa2FuaXR3KTogY2hhdCB3aXRoIFZlZ2EgdGVhbSBhbmQgcG9zc2libHkgbW92ZSB0aGlzIHRvIHZlZ2EtbG9nZ2luZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgLy8gQm9ycm93ZWQgc29tZSBpZGVhcyBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE1NjUzMjYwLzg2Njk4OVxuICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL3BhdGlrL2NvbnNvbGUubG9nLXdyYXBwZXIvYmxvYi9tYXN0ZXIvY29uc29sZWxvZy5qc1xuICB2YXIgTUVUSE9EUyA9IFsnZXJyb3InLCAnaW5mbycsICdkZWJ1ZycsICd3YXJuJywgJ2xvZyddO1xuXG4gIHJldHVybiBNRVRIT0RTLnJlZHVjZShmdW5jdGlvbihsb2dnZXIsIGZuKSB7XG4gICAgdmFyIGNmbiA9IGNvbnNvbGVbZm5dID8gZm4gOiAnbG9nJztcbiAgICBpZiAoY29uc29sZVtjZm5dLmJpbmQgPT09ICd1bmRlZmluZWQnKSB7IC8vIElFIDwgMTBcbiAgICAgICAgbG9nZ2VyW2ZuXSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwoY29uc29sZVtjZm5dLCBjb25zb2xlLCBwcmVmaXgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG9nZ2VyW2ZuXSA9IGNvbnNvbGVbY2ZuXS5iaW5kKGNvbnNvbGUsIHByZWZpeCk7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXI7XG4gIH0sIHt9KTtcbn07IiwiLy8gUGFja2FnZSBvZiBkZWZpbmluZyBWZWdhLWxpdGUgU3BlY2lmaWNhdGlvbidzIGpzb24gc2NoZW1hXG4ndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIHNjaGVtYSA9IG1vZHVsZS5leHBvcnRzID0ge30sXG4gIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIHRvTWFwID0gdXRpbC50b01hcCxcbiAgY29sb3JicmV3ZXIgPSByZXF1aXJlKCdjb2xvcmJyZXdlcicpO1xuXG5zY2hlbWEudXRpbCA9IHJlcXVpcmUoJy4vc2NoZW1hdXRpbCcpO1xuXG5zY2hlbWEubWFya3R5cGUgPSB7XG4gIHR5cGU6ICdzdHJpbmcnLFxuICBlbnVtOiBbJ3BvaW50JywgJ3RpY2snLCAnYmFyJywgJ2xpbmUnLCAnYXJlYScsICdjaXJjbGUnLCAnc3F1YXJlJywgJ3RleHQnXVxufTtcblxuc2NoZW1hLmFnZ3JlZ2F0ZSA9IHtcbiAgdHlwZTogJ3N0cmluZycsXG4gIGVudW06IFsnYXZnJywgJ3N1bScsICdtZWRpYW4nLCAnbWluJywgJ21heCcsICdjb3VudCddLFxuICBzdXBwb3J0ZWRFbnVtczoge1xuICAgIFE6IFsnYXZnJywgJ21lZGlhbicsICdzdW0nLCAnbWluJywgJ21heCcsICdjb3VudCddLFxuICAgIE86IFsnbWVkaWFuJywnbWluJywnbWF4J10sXG4gICAgTjogW10sXG4gICAgVDogWydhdmcnLCAnbWVkaWFuJywgJ21pbicsICdtYXgnXSxcbiAgICAnJzogWydjb3VudCddXG4gIH0sXG4gIHN1cHBvcnRlZFR5cGVzOiB0b01hcChbUSwgTiwgTywgVCwgJyddKVxufTtcblxuc2NoZW1hLmdldFN1cHBvcnRlZFJvbGUgPSBmdW5jdGlvbihlbmNUeXBlKSB7XG4gIHJldHVybiBzY2hlbWEuc2NoZW1hLnByb3BlcnRpZXMuZW5jb2RpbmcucHJvcGVydGllc1tlbmNUeXBlXS5zdXBwb3J0ZWRSb2xlO1xufTtcblxuc2NoZW1hLnRpbWVVbml0cyA9IFsneWVhcicsICdtb250aCcsICdkYXknLCAnZGF0ZScsICdob3VycycsICdtaW51dGVzJywgJ3NlY29uZHMnXTtcblxuc2NoZW1hLmRlZmF1bHRUaW1lRm4gPSAnbW9udGgnO1xuXG5zY2hlbWEudGltZVVuaXQgPSB7XG4gIHR5cGU6ICdzdHJpbmcnLFxuICBlbnVtOiBzY2hlbWEudGltZVVuaXRzLFxuICBzdXBwb3J0ZWRUeXBlczogdG9NYXAoW1RdKVxufTtcblxuc2NoZW1hLnNjYWxlX3R5cGUgPSB7XG4gIHR5cGU6ICdzdHJpbmcnLFxuICAvLyBUT0RPKGthbml0dykgcmVhZCB2ZWdhJ3Mgc2NoZW1hIGhlcmUsIGFkZCBkZXNjcmlwdGlvblxuICBlbnVtOiBbJ2xpbmVhcicsICdsb2cnLCAncG93JywgJ3NxcnQnLCAncXVhbnRpbGUnXSxcbiAgZGVmYXVsdDogJ2xpbmVhcicsXG4gIHN1cHBvcnRlZFR5cGVzOiB0b01hcChbUV0pXG59O1xuXG5zY2hlbWEuZmllbGQgPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgbmFtZToge1xuICAgICAgdHlwZTogJ3N0cmluZydcbiAgICB9XG4gIH1cbn07XG5cbnZhciBjbG9uZSA9IHV0aWwuZHVwbGljYXRlO1xudmFyIG1lcmdlID0gc2NoZW1hLnV0aWwubWVyZ2U7XG5cbnNjaGVtYS5NQVhCSU5TX0RFRkFVTFQgPSAxNTtcblxudmFyIGJpbiA9IHtcbiAgdHlwZTogWydib29sZWFuJywgJ29iamVjdCddLFxuICBkZWZhdWx0OiBmYWxzZSxcbiAgcHJvcGVydGllczoge1xuICAgIG1heGJpbnM6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IHNjaGVtYS5NQVhCSU5TX0RFRkFVTFQsXG4gICAgICBtaW5pbXVtOiAyLFxuICAgICAgZGVzY3JpcHRpb246ICdNYXhpbXVtIG51bWJlciBvZiBiaW5zLidcbiAgICB9XG4gIH0sXG4gIHN1cHBvcnRlZFR5cGVzOiB0b01hcChbUV0pIC8vIFRPRE86IGFkZCBPIGFmdGVyIGZpbmlzaGluZyAjODFcbn07XG5cbnZhciB0eXBpY2FsRmllbGQgPSBtZXJnZShjbG9uZShzY2hlbWEuZmllbGQpLCB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdHlwZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbTiwgTywgUSwgVF1cbiAgICB9LFxuICAgIGFnZ3JlZ2F0ZTogc2NoZW1hLmFnZ3JlZ2F0ZSxcbiAgICB0aW1lVW5pdDogc2NoZW1hLnRpbWVVbml0LFxuICAgIGJpbjogYmluLFxuICAgIHNjYWxlOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLyogQ29tbW9uIFNjYWxlIFByb3BlcnRpZXMgKi9cbiAgICAgICAgdHlwZTogc2NoZW1hLnNjYWxlX3R5cGUsXG4gICAgICAgIHJldmVyc2U6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgc3VwcG9ydGVkVHlwZXM6IHRvTWFwKFtRLCBUXSlcbiAgICAgICAgfSxcblxuICAgICAgICAvKiBRdWFudGl0YXRpdmUgU2NhbGUgUHJvcGVydGllcyAqL1xuICAgICAgICBuaWNlOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZW51bTogWydzZWNvbmQnLCAnbWludXRlJywgJ2hvdXInLCAnZGF5JywgJ3dlZWsnLCAnbW9udGgnLCAneWVhciddLFxuICAgICAgICAgIHN1cHBvcnRlZFR5cGVzOiB0b01hcChbVF0pXG4gICAgICAgIH0sXG4gICAgICAgIHplcm86IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdJbmNsdWRlIHplcm8nLFxuICAgICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgICAgc3VwcG9ydGVkVHlwZXM6IHRvTWFwKFtRLCBUXSlcbiAgICAgICAgfSxcblxuICAgICAgICAvKiBWZWdhLWxpdGUgb25seSBQcm9wZXJ0aWVzICovXG4gICAgICAgIHVzZVJhd0RvbWFpbjoge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdVc2UgdGhlIHJhdyBkYXRhIHJhbmdlIGFzIHNjYWxlIGRvbWFpbiBpbnN0ZWFkIG9mICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAnYWdncmVnYXRlZCBkYXRhIGZvciBhZ2dyZWdhdGUgYXhpcy4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICdUaGlzIG9wdGlvbiBkb2VzIG5vdCB3b3JrIHdpdGggc3VtIG9yIGNvdW50IGFnZ3JlZ2F0ZScgK1xuICAgICAgICAgICAgICAgICAgICAgICAnYXMgdGhleSBtaWdodCBoYXZlIGEgc3Vic3RhbnRpYWxseSBsYXJnZXIgc2NhbGUgcmFuZ2UuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICdCeSBkZWZhdWx0LCB1c2UgdmFsdWUgZnJvbSBjb25maWcudXNlUmF3RG9tYWluLidcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbnZhciBvbmx5T3JkaW5hbEZpZWxkID0gbWVyZ2UoY2xvbmUoc2NoZW1hLmZpZWxkKSwge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkUm9sZToge1xuICAgIGRpbWVuc2lvbjogdHJ1ZVxuICB9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdHlwZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbTiwgTywgUSwgVF0gLy8gb3JkaW5hbC1vbmx5IGZpZWxkIHN1cHBvcnRzIFEgd2hlbiBiaW4gaXMgYXBwbGllZCBhbmQgVCB3aGVuIHRpbWUgdW5pdCBpcyBhcHBsaWVkLlxuICAgIH0sXG4gICAgdGltZVVuaXQ6IHNjaGVtYS50aW1lVW5pdCxcbiAgICBiaW46IGJpbixcbiAgICBhZ2dyZWdhdGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogWydjb3VudCddLFxuICAgICAgc3VwcG9ydGVkVHlwZXM6IHRvTWFwKFtOLCBPXSkgLy8gRklYTUUgdGhpcyBsb29rcyB3ZWlyZCB0byBtZVxuICAgIH1cbiAgfVxufSk7XG5cbnZhciBheGlzTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgdGljazogdHJ1ZSwgYmFyOiB0cnVlLCBsaW5lOiB0cnVlLCBhcmVhOiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZX0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICBheGlzOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLyogVmVnYSBBeGlzIFByb3BlcnRpZXMgKi9cbiAgICAgICAgZm9ybWF0OiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLCAgLy8gYXV0b1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIGZvcm1hdHRpbmcgcGF0dGVybiBmb3IgYXhpcyBsYWJlbHMuICcrXG4gICAgICAgICAgICAgICAgICAgICAgICdJZiBub3QgdW5kZWZpbmVkLCB0aGlzIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgJ3NtYWxsL2xhcmdlTnVtYmVyRm9ybWF0IGFuZCB0aGUgbWF4IHZhbHVlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAnb2YgdGhlIGZpZWxkLidcbiAgICAgICAgfSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQSBmbGFnIGluZGljYXRlIGlmIGdyaWRsaW5lcyBzaG91bGQgYmUgY3JlYXRlZCBpbiBhZGRpdGlvbiB0byB0aWNrcy4nXG4gICAgICAgIH0sXG4gICAgICAgIGxheWVyOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogJ2JhY2snLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQSBzdHJpbmcgaW5kaWNhdGluZyBpZiB0aGUgYXhpcyAoYW5kIGFueSBncmlkbGluZXMpIHNob3VsZCBiZSBwbGFjZWQgYWJvdmUgb3IgYmVsb3cgdGhlIGRhdGEgbWFya3MuIE9uZSBvZiBcImZyb250XCIgKGRlZmF1bHQpIG9yIFwiYmFja1wiLidcbiAgICAgICAgfSxcbiAgICAgICAgb3JpZW50OiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgICAgICAgIGVudW06IFsndG9wJywgJ3JpZ2h0JywgJ2xlZnQnLCAnYm90dG9tJ10sXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdUaGUgb3JpZW50YXRpb24gb2YgdGhlIGF4aXMuIE9uZSBvZiB0b3AsIGJvdHRvbSwgbGVmdCBvciByaWdodC4gVGhlIG9yaWVudGF0aW9uIGNhbiBiZSB1c2VkIHRvIGZ1cnRoZXIgc3BlY2lhbGl6ZSB0aGUgYXhpcyB0eXBlIChlLmcuLCBhIHkgYXhpcyBvcmllbnRlZCBmb3IgdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIGNoYXJ0KS4nXG4gICAgICAgIH0sXG4gICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIGRlZmF1bHQ6IDUsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0EgZGVzaXJlZCBudW1iZXIgb2YgdGlja3MsIGZvciBheGVzIHZpc3VhbGl6aW5nIHF1YW50aXRhdGl2ZSBzY2FsZXMuIFRoZSByZXN1bHRpbmcgbnVtYmVyIG1heSBiZSBkaWZmZXJlbnQgc28gdGhhdCB2YWx1ZXMgYXJlIFwibmljZVwiIChtdWx0aXBsZXMgb2YgMiwgNSwgMTApIGFuZCBsaWUgd2l0aGluIHRoZSB1bmRlcmx5aW5nIHNjYWxlXFwncyByYW5nZS4nXG4gICAgICAgIH0sXG4gICAgICAgIC8qIFZlZ2EgQXhpcyBQcm9wZXJ0aWVzIHRoYXQgYXJlIGF1dG9tYXRpY2FsbHkgcG9wdWxhdGVkIGJ5IFZlZ2EtbGl0ZSAqL1xuICAgICAgICB0aXRsZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0EgdGl0bGUgZm9yIHRoZSBheGlzLiAoU2hvd3MgZmllbGQgbmFtZSBhbmQgaXRzIGZ1bmN0aW9uIGJ5IGRlZmF1bHQuKSdcbiAgICAgICAgfSxcbiAgICAgICAgLyogVmVnYS1saXRlIG9ubHkgKi9cbiAgICAgICAgbWF4TGFiZWxMZW5ndGg6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgZGVmYXVsdDogMjUsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RydW5jYXRlIGxhYmVscyB0aGF0IGFyZSB0b28gbG9uZy4nXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsQW5nbGU6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLCAvLyBhdXRvXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBtYXhpbXVtOiAzNjAsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdBbmdsZSBieSB3aGljaCB0byByb3RhdGUgbGFiZWxzLiBTZXQgdG8gMCB0byBmb3JjZSBob3Jpem9udGFsLidcbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGVNYXhMZW5ndGg6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdNYXggbGVuZ3RoIGZvciBheGlzIHRpdGxlIGlmIHRoZSB0aXRsZSBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBmcm9tIHRoZSBmaWVsZFxcJ3MgZGVzY3JpcHRpb24nXG4gICAgICAgIH0sXG4gICAgICAgIHRpdGxlT2Zmc2V0OiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCwgIC8vIGF1dG9cbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0EgdGl0bGUgb2Zmc2V0IHZhbHVlIGZvciB0aGUgYXhpcy4nXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgc29ydE1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIHNvcnQ6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBkZWZhdWx0OiBbXSxcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBzdXBwb3J0ZWRUeXBlczogdG9NYXAoW04sIE9dKSxcbiAgICAgICAgcmVxdWlyZWQ6IFsnbmFtZScsICdhZ2dyZWdhdGUnXSxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhZ2dyZWdhdGU6IHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgZW51bTogWydhdmcnLCAnc3VtJywgJ21pbicsICdtYXgnLCAnY291bnQnXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmV2ZXJzZToge1xuICAgICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBiYW5kTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgYmFuZDoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIGRlZmF1bHQ6IDFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGxlZ2VuZE1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIGxlZ2VuZDoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBkZXNjcmlwdGlvbjogJ1Byb3BlcnRpZXMgb2YgYSBsZWdlbmQuJyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdBIHRpdGxlIGZvciB0aGUgbGVnZW5kLiAoU2hvd3MgZmllbGQgbmFtZSBhbmQgaXRzIGZ1bmN0aW9uIGJ5IGRlZmF1bHQuKSdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHRleHRNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczogeyd0ZXh0JzogdHJ1ZX0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICBhbGlnbjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBkZWZhdWx0OiAncmlnaHQnXG4gICAgfSxcbiAgICBiYXNlbGluZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBkZWZhdWx0OiAnbWlkZGxlJ1xuICAgIH0sXG4gICAgY29sb3I6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcm9sZTogJ2NvbG9yJyxcbiAgICAgIGRlZmF1bHQ6ICcjMDAwMDAwJ1xuICAgIH0sXG4gICAgbWFyZ2luOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiA0LFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgcGxhY2Vob2xkZXI6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogJ0FiYydcbiAgICB9LFxuICAgIGZvbnQ6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICB3ZWlnaHQ6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBlbnVtOiBbJ25vcm1hbCcsICdib2xkJ10sXG4gICAgICAgICAgZGVmYXVsdDogJ25vcm1hbCdcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBkZWZhdWx0OiAxMCxcbiAgICAgICAgICBtaW5pbXVtOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGZhbWlseToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6ICdIZWx2ZXRpY2EgTmV1ZSdcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiAnbm9ybWFsJyxcbiAgICAgICAgICBlbnVtOiBbJ25vcm1hbCcsICdpdGFsaWMnXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBmb3JtYXQ6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLCAgLy8gYXV0b1xuICAgICAgZGVzY3JpcHRpb246ICdUaGUgZm9ybWF0dGluZyBwYXR0ZXJuIGZvciB0ZXh0IHZhbHVlLiAnK1xuICAgICAgICAgICAgICAgICAgICdJZiBub3QgdW5kZWZpbmVkLCB0aGlzIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSAnICtcbiAgICAgICAgICAgICAgICAgICAnc21hbGwvbGFyZ2VOdW1iZXJGb3JtYXQgYW5kIHRoZSBtYXggdmFsdWUgJyArXG4gICAgICAgICAgICAgICAgICAgJ29mIHRoZSBmaWVsZC4nXG4gICAgfSxcbiAgfVxufTtcblxudmFyIHNpemVNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczoge3BvaW50OiB0cnVlLCBiYXI6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlLCB0ZXh0OiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAzMCxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBkZXNjcmlwdGlvbjogJ1NpemUgb2YgbWFya3MuJ1xuICAgIH1cbiAgfVxufTtcblxudmFyIGNvbG9yTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgdGljazogdHJ1ZSwgYmFyOiB0cnVlLCBsaW5lOiB0cnVlLCBhcmVhOiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZSwgJ3RleHQnOiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJvbGU6ICdjb2xvcicsXG4gICAgICBkZWZhdWx0OiAnIzQ2ODJiNCcsXG4gICAgICBkZXNjcmlwdGlvbjogJ0NvbG9yIHRvIGJlIHVzZWQgZm9yIG1hcmtzLidcbiAgICB9LFxuICAgIG9wYWNpdHk6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLCAgLy8gYXV0b1xuICAgICAgbWluaW11bTogMCxcbiAgICAgIG1heGltdW06IDFcbiAgICB9LFxuICAgIHNjYWxlOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICB0eXBlOiBbJ3N0cmluZycsICdhcnJheSddLFxuICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAgICdDb2xvciBwYWxldHRlLCBpZiB1bmRlZmluZWQgdmVnYS1saXRlIHdpbGwgdXNlIGRhdGEgcHJvcGVydHknICtcbiAgICAgICAgICAgICd0byBwaWNrIG9uZSBmcm9tIGMxMHBhbGV0dGUsIGMyMHBhbGV0dGUsIG9yIG9yZGluYWxQYWxldHRlLidcbiAgICAgICAgICAgIC8vRklYTUVcbiAgICAgICAgfSxcbiAgICAgICAgYzEwcGFsZXR0ZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6ICdjYXRlZ29yeTEwJyxcbiAgICAgICAgICBlbnVtOiBbXG4gICAgICAgICAgICAvLyBUYWJsZWF1XG4gICAgICAgICAgICAnY2F0ZWdvcnkxMCcsICdjYXRlZ29yeTEwaycsXG4gICAgICAgICAgICAvLyBDb2xvciBCcmV3ZXJcbiAgICAgICAgICAgICdQYXN0ZWwxJywgJ1Bhc3RlbDInLCAnU2V0MScsICdTZXQyJywgJ1NldDMnXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBjMjBwYWxldHRlOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogJ2NhdGVnb3J5MjAnLFxuICAgICAgICAgIGVudW06IFsnY2F0ZWdvcnkyMCcsICdjYXRlZ29yeTIwYicsICdjYXRlZ29yeTIwYyddXG4gICAgICAgIH0sXG4gICAgICAgIG9yZGluYWxQYWxldHRlOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQ29sb3IgcGFsZXR0ZSB0byBlbmNvZGUgb3JkaW5hbCB2YXJpYWJsZXMuJyxcbiAgICAgICAgICBlbnVtOiB1dGlsLmtleXMoY29sb3JicmV3ZXIpXG4gICAgICAgIH0sXG4gICAgICAgIHF1YW50aXRhdGl2ZVJhbmdlOiB7XG4gICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICBkZWZhdWx0OiBbJyNBRkM2QTMnLCAnIzA5NjIyQSddLCAvLyB0YWJsZWF1IGdyZWVuc1xuICAgICAgICAgIC8vIGRlZmF1bHQ6IFsnI2NjZWNlNicsICcjMDA0NDFiJ10sIC8vIEJ1R24uOSBbMi04XVxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQ29sb3IgcmFuZ2UgdG8gZW5jb2RlIHF1YW50aXRhdGl2ZSB2YXJpYWJsZXMuJyxcbiAgICAgICAgICBtaW5JdGVtczogMixcbiAgICAgICAgICBtYXhJdGVtczogMixcbiAgICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICByb2xlOiAnY29sb3InXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2hhcGVNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczoge3BvaW50OiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZX0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbJ2NpcmNsZScsICdzcXVhcmUnLCAnY3Jvc3MnLCAnZGlhbW9uZCcsICd0cmlhbmdsZS11cCcsICd0cmlhbmdsZS1kb3duJ10sXG4gICAgICBkZWZhdWx0OiAnY2lyY2xlJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnTWFyayB0byBiZSB1c2VkLidcbiAgICB9LFxuICAgIGZpbGxlZDoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICBkZXNjcmlwdGlvbjogJ1doZXRoZXIgdGhlIHNoYXBlXFwncyBjb2xvciBzaG91bGQgYmUgdXNlZCBhcyBmaWxsIGNvbG9yIGluc3RlYWQgb2Ygc3Ryb2tlIGNvbG9yLidcbiAgICB9XG4gIH1cbn07XG5cbnZhciBkZXRhaWxNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczoge3BvaW50OiB0cnVlLCB0aWNrOiB0cnVlLCBsaW5lOiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZX1cbn07XG5cbnZhciByb3dNaXhpbiA9IHtcbiAgcHJvcGVydGllczoge1xuICAgIGhlaWdodDoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgZGVmYXVsdDogMTUwXG4gICAgfVxuICB9XG59O1xuXG52YXIgY29sTWl4aW4gPSB7XG4gIHByb3BlcnRpZXM6IHtcbiAgICB3aWR0aDoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgZGVmYXVsdDogMTUwXG4gICAgfSxcbiAgICBheGlzOiB7XG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIG1heExhYmVsTGVuZ3RoOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIGRlZmF1bHQ6IDEyLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdUcnVuY2F0ZSBsYWJlbHMgdGhhdCBhcmUgdG9vIGxvbmcuJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgZmFjZXRNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczoge3BvaW50OiB0cnVlLCB0aWNrOiB0cnVlLCBiYXI6IHRydWUsIGxpbmU6IHRydWUsIGFyZWE6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlLCB0ZXh0OiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIHBhZGRpbmc6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgbWluaW11bTogMCxcbiAgICAgIG1heGltdW06IDEsXG4gICAgICBkZWZhdWx0OiAwLjFcbiAgICB9XG4gIH1cbn07XG5cbnZhciByZXF1aXJlZE5hbWVUeXBlID0ge1xuICByZXF1aXJlZDogWyduYW1lJywgJ3R5cGUnXVxufTtcblxudmFyIG11bHRpUm9sZUZpZWxkID0gbWVyZ2UoY2xvbmUodHlwaWNhbEZpZWxkKSwge1xuICBzdXBwb3J0ZWRSb2xlOiB7XG4gICAgbWVhc3VyZTogdHJ1ZSxcbiAgICBkaW1lbnNpb246IHRydWVcbiAgfVxufSk7XG5cbnZhciBxdWFudGl0YXRpdmVGaWVsZCA9IG1lcmdlKGNsb25lKHR5cGljYWxGaWVsZCksIHtcbiAgc3VwcG9ydGVkUm9sZToge1xuICAgIG1lYXN1cmU6IHRydWUsXG4gICAgZGltZW5zaW9uOiAnb3JkaW5hbC1vbmx5JyAvLyB1c2luZyBzaXplIHRvIGVuY29kaW5nIGNhdGVnb3J5IGxlYWQgdG8gb3JkZXIgaW50ZXJwcmV0YXRpb25cbiAgfVxufSk7XG5cbnZhciBvbmx5UXVhbnRpdGF0aXZlRmllbGQgPSBtZXJnZShjbG9uZSh0eXBpY2FsRmllbGQpLCB7XG4gIHN1cHBvcnRlZFJvbGU6IHtcbiAgICBtZWFzdXJlOiB0cnVlXG4gIH1cbn0pO1xuXG52YXIgeCA9IG1lcmdlKGNsb25lKG11bHRpUm9sZUZpZWxkKSwgYXhpc01peGluLCBiYW5kTWl4aW4sIHJlcXVpcmVkTmFtZVR5cGUsIHNvcnRNaXhpbik7XG52YXIgeSA9IGNsb25lKHgpO1xuXG52YXIgZmFjZXQgPSBtZXJnZShjbG9uZShvbmx5T3JkaW5hbEZpZWxkKSwgcmVxdWlyZWROYW1lVHlwZSwgZmFjZXRNaXhpbiwgc29ydE1peGluKTtcbnZhciByb3cgPSBtZXJnZShjbG9uZShmYWNldCksIGF4aXNNaXhpbiwgcm93TWl4aW4pO1xudmFyIGNvbCA9IG1lcmdlKGNsb25lKGZhY2V0KSwgYXhpc01peGluLCBjb2xNaXhpbik7XG5cbnZhciBzaXplID0gbWVyZ2UoY2xvbmUocXVhbnRpdGF0aXZlRmllbGQpLCBsZWdlbmRNaXhpbiwgc2l6ZU1peGluLCBzb3J0TWl4aW4pO1xudmFyIGNvbG9yID0gbWVyZ2UoY2xvbmUobXVsdGlSb2xlRmllbGQpLCBsZWdlbmRNaXhpbiwgY29sb3JNaXhpbiwgc29ydE1peGluKTtcblxudmFyIHNoYXBlID0gbWVyZ2UoY2xvbmUob25seU9yZGluYWxGaWVsZCksIGxlZ2VuZE1peGluLCBzaGFwZU1peGluLCBzb3J0TWl4aW4pO1xudmFyIGRldGFpbCA9IG1lcmdlKGNsb25lKG9ubHlPcmRpbmFsRmllbGQpLCBkZXRhaWxNaXhpbiwgc29ydE1peGluKTtcblxuLy8gd2Ugb25seSBwdXQgYWdncmVnYXRlZCBtZWFzdXJlIGluIHBpdm90IHRhYmxlXG52YXIgdGV4dCA9IG1lcmdlKGNsb25lKG9ubHlRdWFudGl0YXRpdmVGaWVsZCksIHRleHRNaXhpbiwgc29ydE1peGluKTtcblxuLy8gVE9ETyBhZGQgbGFiZWxcblxudmFyIGZpbHRlciA9IHtcbiAgdHlwZTogJ2FycmF5JyxcbiAgaXRlbXM6IHtcbiAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBvcGVyYW5kczoge1xuICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICBpdGVtczoge1xuICAgICAgICAgIHR5cGU6IFsnc3RyaW5nJywgJ2Jvb2xlYW4nLCAnaW50ZWdlcicsICdudW1iZXInXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb3BlcmF0b3I6IHtcbiAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgIGVudW06IFsnPicsICc+PScsICc9JywgJyE9JywgJzwnLCAnPD0nLCAnbm90TnVsbCddXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgZGF0YSA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvLyBkYXRhIHNvdXJjZVxuICAgIGZvcm1hdFR5cGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogWydqc29uJywgJ2NzdiddLFxuICAgICAgZGVmYXVsdDogJ2pzb24nXG4gICAgfSxcbiAgICB1cmw6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICBkZXNjcmlwdGlvbjogJ1Bhc3MgYXJyYXkgb2Ygb2JqZWN0cyBpbnN0ZWFkIG9mIGEgdXJsIHRvIGEgZmlsZS4nLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgY29uZmlnID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIC8vIHRlbXBsYXRlXG4gICAgd2lkdGg6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgaGVpZ2h0OiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICB9LFxuICAgIHZpZXdwb3J0OiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogJ2ludGVnZXInXG4gICAgICB9LFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICBncmlkQ29sb3I6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcm9sZTogJ2NvbG9yJyxcbiAgICAgIGRlZmF1bHQ6ICcjMDAwMDAwJ1xuICAgIH0sXG4gICAgZ3JpZE9wYWNpdHk6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgbWluaW11bTogMCxcbiAgICAgIG1heGltdW06IDEsXG4gICAgICBkZWZhdWx0OiAwLjA4XG4gICAgfSxcblxuICAgIC8vIGZpbHRlciBudWxsXG4gICAgLy8gVE9ETygjNTk3KSByZXZpc2UgdGhpcyBjb25maWdcbiAgICBmaWx0ZXJOdWxsOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgTzoge3R5cGU6J2Jvb2xlYW4nLCBkZWZhdWx0OiBmYWxzZX0sXG4gICAgICAgIFE6IHt0eXBlOidib29sZWFuJywgZGVmYXVsdDogdHJ1ZX0sXG4gICAgICAgIFQ6IHt0eXBlOidib29sZWFuJywgZGVmYXVsdDogdHJ1ZX1cbiAgICAgIH1cbiAgICB9LFxuICAgIHRvZ2dsZVNvcnQ6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogT1xuICAgIH0sXG4gICAgYXV0b1NvcnRMaW5lOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcblxuICAgIC8vIHNpbmdsZSBwbG90XG4gICAgc2luZ2xlSGVpZ2h0OiB7XG4gICAgICAvLyB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IGJhbmRXaWR0aCAqIChjYXJkaW5hbGl0eSArIHBhZGRpbmcpXG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAyMDAsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICBzaW5nbGVXaWR0aDoge1xuICAgICAgLy8gd2lsbCBiZSBvdmVyd3JpdHRlbiBieSBiYW5kV2lkdGggKiAoY2FyZGluYWxpdHkgKyBwYWRkaW5nKVxuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMjAwLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgLy8gYmFuZCBzaXplXG4gICAgbGFyZ2VCYW5kU2l6ZToge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMjEsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICBzbWFsbEJhbmRTaXplOiB7XG4gICAgICAvL3NtYWxsIG11bHRpcGxlcyBvciBzaW5nbGUgcGxvdCB3aXRoIGhpZ2ggY2FyZGluYWxpdHlcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDEyLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgbGFyZ2VCYW5kTWF4Q2FyZGluYWxpdHk6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDEwXG4gICAgfSxcbiAgICAvLyBzbWFsbCBtdWx0aXBsZXNcbiAgICBjZWxsUGFkZGluZzoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBkZWZhdWx0OiAwLjFcbiAgICB9LFxuICAgIGNlbGxHcmlkQ29sb3I6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcm9sZTogJ2NvbG9yJyxcbiAgICAgIGRlZmF1bHQ6ICcjMDAwMDAwJ1xuICAgIH0sXG4gICAgY2VsbEdyaWRPcGFjaXR5OiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBtYXhpbXVtOiAxLFxuICAgICAgZGVmYXVsdDogMC4xNVxuICAgIH0sXG4gICAgY2VsbEJhY2tncm91bmRDb2xvcjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByb2xlOiAnY29sb3InLFxuICAgICAgZGVmYXVsdDogJ3JnYmEoMCwwLDAsMCknXG4gICAgfSxcbiAgICB0ZXh0Q2VsbFdpZHRoOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiA5MCxcbiAgICAgIG1pbmltdW06IDBcbiAgICB9LFxuXG4gICAgLy8gbWFya3NcbiAgICBzdHJva2VXaWR0aDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMixcbiAgICAgIG1pbmltdW06IDBcbiAgICB9LFxuICAgIHNpbmdsZUJhck9mZnNldDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogNSxcbiAgICAgIG1pbmltdW06IDBcbiAgICB9LFxuICAgIC8vIHNjYWxlc1xuICAgIHRpbWVTY2FsZUxhYmVsTGVuZ3RoOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAzLFxuICAgICAgbWluaW11bTogMCxcbiAgICAgIGRlc2NyaXB0aW9uOiAnTWF4IGxlbmd0aCBmb3IgdmFsdWVzIGluIGRheVNjYWxlTGFiZWwgYW5kIG1vbnRoU2NhbGVMYWJlbC4gIFplcm8gbWVhbnMgdXNpbmcgZnVsbCBuYW1lcyBpbiBkYXlTY2FsZUxhYmVsL21vbnRoU2NhbGVMYWJlbC4nXG4gICAgfSxcbiAgICBkYXlTY2FsZUxhYmVsOiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0OiBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5J10sXG4gICAgICBkZXNjcmlwdGlvbjogJ0F4aXMgbGFiZWxzIGZvciBkYXkgb2Ygd2Vlaywgc3RhcnRpbmcgZnJvbSBTdW5kYXkuJyArXG4gICAgICAgICcoQ29uc2lzdGVudCB3aXRoIEphdmFzY3JpcHQgLS0gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvZ2V0RGF5LidcbiAgICB9LFxuICAgIG1vbnRoU2NhbGVMYWJlbDoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgICB9LFxuICAgICAgZGVmYXVsdDogWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ10sXG4gICAgICBkZXNjcmlwdGlvbjogJ0F4aXMgbGFiZWxzIGZvciBtb250aC4nXG4gICAgfSxcbiAgICAvLyBvdGhlclxuICAgIGNoYXJhY3RlcldpZHRoOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiA2XG4gICAgfSxcbiAgICBtYXhTbWFsbE51bWJlcjoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBkZWZhdWx0OiAxMDAwMCxcbiAgICAgIGRlc2NyaXB0aW9uOiAnbWF4aW11bSBudW1iZXIgdGhhdCBhIGZpZWxkIHdpbGwgYmUgY29uc2lkZXJlZCBzbWFsbE51bWJlci4nK1xuICAgICAgICAgICAgICAgICAgICdVc2VkIGZvciBheGlzIGxhYmVsbGluZy4nXG4gICAgfSxcbiAgICBzbWFsbE51bWJlckZvcm1hdDoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBkZWZhdWx0OiAnJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnRDMgTnVtYmVyIGZvcm1hdCBmb3IgYXhpcyBsYWJlbHMgYW5kIHRleHQgdGFibGVzICcrXG4gICAgICAgICAgICAgICAgICAgJ2ZvciBudW1iZXIgPD0gbWF4U21hbGxOdW1iZXIuIFVzZWQgZm9yIGF4aXMgbGFiZWxsaW5nLidcbiAgICB9LFxuICAgIGxhcmdlTnVtYmVyRm9ybWF0OiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlZmF1bHQ6ICcuM3MnLFxuICAgICAgZGVzY3JpcHRpb246ICdEMyBOdW1iZXIgZm9ybWF0IGZvciBheGlzIGxhYmVscyBhbmQgdGV4dCB0YWJsZXMgJyArXG4gICAgICAgICAgICAgICAgICAgJ2ZvciBudW1iZXIgPiBtYXhTbWFsbE51bWJlci4nXG4gICAgfSxcbiAgICB0aW1lRm9ybWF0OiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlZmF1bHQ6ICclWS0lbS0lZCcsXG4gICAgICBkZXNjcmlwdGlvbjogJ0RhdGUgZm9ybWF0IGZvciBheGlzIGxhYmVscy4nXG4gICAgfSxcbiAgICB1c2VSYXdEb21haW46IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgZGVzY3JpcHRpb246ICdVc2UgdGhlIHJhdyBkYXRhIHJhbmdlIGFzIHNjYWxlIGRvbWFpbiBpbnN0ZWFkIG9mICcgK1xuICAgICAgICAgICAgICAgICAgICdhZ2dyZWdhdGVkIGRhdGEgZm9yIGFnZ3JlZ2F0ZSBheGlzLiAnICtcbiAgICAgICAgICAgICAgICAgICAnVGhpcyBvcHRpb24gZG9lcyBub3Qgd29yayB3aXRoIHN1bSBvciBjb3VudCBhZ2dyZWdhdGUnICtcbiAgICAgICAgICAgICAgICAgICAnYXMgdGhleSBtaWdodCBoYXZlIGEgc3Vic3RhbnRpYWxseSBsYXJnZXIgc2NhbGUgcmFuZ2UuJyArXG4gICAgICAgICAgICAgICAgICAgJ0J5IGRlZmF1bHQsIHVzZSB2YWx1ZSBmcm9tIGNvbmZpZy51c2VSYXdEb21haW4uJ1xuICAgIH1cbiAgfVxufTtcblxuLyoqIEB0eXBlIE9iamVjdCBTY2hlbWEgb2YgYSB2ZWdhLWxpdGUgc3BlY2lmaWNhdGlvbiAqL1xuc2NoZW1hLnNjaGVtYSA9IHtcbiAgJHNjaGVtYTogJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hIycsXG4gIGRlc2NyaXB0aW9uOiAnU2NoZW1hIGZvciBWZWdhLWxpdGUgc3BlY2lmaWNhdGlvbicsXG4gIHR5cGU6ICdvYmplY3QnLFxuICByZXF1aXJlZDogWydtYXJrdHlwZScsICdlbmNvZGluZycsICdkYXRhJ10sXG4gIHByb3BlcnRpZXM6IHtcbiAgICBkYXRhOiBkYXRhLFxuICAgIG1hcmt0eXBlOiBzY2hlbWEubWFya3R5cGUsXG4gICAgZW5jb2Rpbmc6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgY29sOiBjb2wsXG4gICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgc2hhcGU6IHNoYXBlLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgICAgfVxuICAgIH0sXG4gICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgY29uZmlnOiBjb25maWdcbiAgfVxufTtcblxuc2NoZW1hLmVuY1R5cGVzID0gdXRpbC5rZXlzKHNjaGVtYS5zY2hlbWEucHJvcGVydGllcy5lbmNvZGluZy5wcm9wZXJ0aWVzKTtcblxuLyoqIEluc3RhbnRpYXRlIGEgdmVyYm9zZSB2bCBzcGVjIGZyb20gdGhlIHNjaGVtYSAqL1xuc2NoZW1hLmluc3RhbnRpYXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBzY2hlbWEudXRpbC5pbnN0YW50aWF0ZShzY2hlbWEuc2NoZW1hKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzY2hlbWF1dGlsID0gbW9kdWxlLmV4cG9ydHMgPSB7fSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxudmFyIGlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufTtcblxuc2NoZW1hdXRpbC5leHRlbmQgPSBmdW5jdGlvbihpbnN0YW5jZSwgc2NoZW1hKSB7XG4gIHJldHVybiBzY2hlbWF1dGlsLm1lcmdlKHNjaGVtYXV0aWwuaW5zdGFudGlhdGUoc2NoZW1hKSwgaW5zdGFuY2UpO1xufTtcblxuLy8gaW5zdGFudGlhdGUgYSBzY2hlbWFcbnNjaGVtYXV0aWwuaW5zdGFudGlhdGUgPSBmdW5jdGlvbihzY2hlbWEpIHtcbiAgdmFyIHZhbDtcbiAgaWYgKHNjaGVtYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmICgnZGVmYXVsdCcgaW4gc2NoZW1hKSB7XG4gICAgdmFsID0gc2NoZW1hLmRlZmF1bHQ7XG4gICAgcmV0dXJuIHV0aWwuaXNPYmplY3QodmFsKSA/IHV0aWwuZHVwbGljYXRlKHZhbCkgOiB2YWw7XG4gIH0gZWxzZSBpZiAoc2NoZW1hLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGluc3RhbmNlID0ge307XG4gICAgZm9yICh2YXIgbmFtZSBpbiBzY2hlbWEucHJvcGVydGllcykge1xuICAgICAgdmFsID0gc2NoZW1hdXRpbC5pbnN0YW50aWF0ZShzY2hlbWEucHJvcGVydGllc1tuYW1lXSk7XG4gICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5zdGFuY2VbbmFtZV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIGlmIChzY2hlbWEudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLy8gcmVtb3ZlIGFsbCBkZWZhdWx0cyBmcm9tIGFuIGluc3RhbmNlXG5zY2hlbWF1dGlsLnN1YnRyYWN0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIGRlZmF1bHRzKSB7XG4gIHZhciBjaGFuZ2VzID0ge307XG4gIGZvciAodmFyIHByb3AgaW4gaW5zdGFuY2UpIHtcbiAgICB2YXIgZGVmID0gZGVmYXVsdHNbcHJvcF07XG4gICAgdmFyIGlucyA9IGluc3RhbmNlW3Byb3BdO1xuICAgIC8vIE5vdGU6IGRvZXMgbm90IHByb3Blcmx5IHN1YnRyYWN0IGFycmF5c1xuICAgIGlmICghZGVmYXVsdHMgfHwgZGVmICE9PSBpbnMpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zID09PSAnb2JqZWN0JyAmJiAhdXRpbC5pc0FycmF5KGlucykgJiYgZGVmKSB7XG4gICAgICAgIHZhciBjID0gc2NoZW1hdXRpbC5zdWJ0cmFjdChpbnMsIGRlZik7XG4gICAgICAgIGlmICghaXNFbXB0eShjKSlcbiAgICAgICAgICBjaGFuZ2VzW3Byb3BdID0gYztcbiAgICAgIH0gZWxzZSBpZiAoIXV0aWwuaXNBcnJheShpbnMpIHx8IGlucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNoYW5nZXNbcHJvcF0gPSBpbnM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjaGFuZ2VzO1xufTtcblxuc2NoZW1hdXRpbC5tZXJnZSA9IGZ1bmN0aW9uKC8qZGVzdCosIHNyYzAsIHNyYzEsIC4uLiovKXtcbiAgdmFyIGRlc3QgPSBhcmd1bWVudHNbMF07XG4gIGZvciAodmFyIGk9MSA7IGk8YXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVzdCA9IG1lcmdlKGRlc3QsIGFyZ3VtZW50c1tpXSk7XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG4vLyByZWN1cnNpdmVseSBtZXJnZXMgc3JjIGludG8gZGVzdFxuZnVuY3Rpb24gbWVyZ2UoZGVzdCwgc3JjKSB7XG4gIGlmICh0eXBlb2Ygc3JjICE9PSAnb2JqZWN0JyB8fCBzcmMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuXG4gIGZvciAodmFyIHAgaW4gc3JjKSB7XG4gICAgaWYgKCFzcmMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoc3JjW3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNyY1twXSAhPT0gJ29iamVjdCcgfHwgc3JjW3BdID09PSBudWxsKSB7XG4gICAgICBkZXN0W3BdID0gc3JjW3BdO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3RbcF0gIT09ICdvYmplY3QnIHx8IGRlc3RbcF0gPT09IG51bGwpIHtcbiAgICAgIGRlc3RbcF0gPSBtZXJnZShzcmNbcF0uY29uc3RydWN0b3IgPT09IEFycmF5ID8gW10gOiB7fSwgc3JjW3BdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVyZ2UoZGVzdFtwXSwgc3JjW3BdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZGF0YWxpYi9zcmMvdXRpbCcpO1xuXG51dGlsLmV4dGVuZCh1dGlsLCByZXF1aXJlKCdkYXRhbGliL3NyYy9nZW5lcmF0ZScpKTtcbnV0aWwuZXh0ZW5kKHV0aWwsIHJlcXVpcmUoJ2RhdGFsaWIvc3JjL3N0YXRzJykpO1xudXRpbC5leHRlbmQodXRpbCwgcmVxdWlyZSgnLi9sb2dnZXInKSgnW1ZMIEVycm9yXScpKTtcbnV0aWwuYmluID0gcmVxdWlyZSgnZGF0YWxpYi9zcmMvYmlucy9iaW5zJyk7XG5cbnV0aWwuaXNpbiA9IGZ1bmN0aW9uKGl0ZW0sIGFycmF5KSB7XG4gIHJldHVybiBhcnJheS5pbmRleE9mKGl0ZW0pICE9PSAtMTtcbn07XG5cbnV0aWwuZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgZiwgdGhpc0FyZykge1xuICBpZiAob2JqLmZvckVhY2gpIHtcbiAgICBvYmouZm9yRWFjaC5jYWxsKHRoaXNBcmcsIGYpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICBmLmNhbGwodGhpc0FyZywgb2JqW2tdLCBrICwgb2JqKTtcbiAgICB9XG4gIH1cbn07XG5cbnV0aWwucmVkdWNlID0gZnVuY3Rpb24ob2JqLCBmLCBpbml0LCB0aGlzQXJnKSB7XG4gIGlmIChvYmoucmVkdWNlKSB7XG4gICAgcmV0dXJuIG9iai5yZWR1Y2UuY2FsbCh0aGlzQXJnLCBmLCBpbml0KTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgaW5pdCA9IGYuY2FsbCh0aGlzQXJnLCBpbml0LCBvYmpba10sIGssIG9iaik7XG4gICAgfVxuICAgIHJldHVybiBpbml0O1xuICB9XG59O1xuXG51dGlsLm1hcCA9IGZ1bmN0aW9uKG9iaiwgZiwgdGhpc0FyZykge1xuICBpZiAob2JqLm1hcCkge1xuICAgIHJldHVybiBvYmoubWFwLmNhbGwodGhpc0FyZywgZik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICBvdXRwdXQucHVzaCggZi5jYWxsKHRoaXNBcmcsIG9ialtrXSwgaywgb2JqKSk7XG4gICAgfVxuICB9XG59O1xuXG51dGlsLmFueSA9IGZ1bmN0aW9uKGFyciwgZikge1xuICB2YXIgaSA9IDAsIGs7XG4gIGZvciAoayBpbiBhcnIpIHtcbiAgICBpZiAoZihhcnJba10sIGssIGkrKykpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnV0aWwuYWxsID0gZnVuY3Rpb24oYXJyLCBmKSB7XG4gIHZhciBpID0gMCwgaztcbiAgZm9yIChrIGluIGFycikge1xuICAgIGlmICghZihhcnJba10sIGssIGkrKykpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnV0aWwuZ2V0YmlucyA9IGZ1bmN0aW9uKHN0YXRzLCBtYXhiaW5zKSB7XG4gIHJldHVybiB1dGlsLmJpbih7XG4gICAgbWluOiBzdGF0cy5taW4sXG4gICAgbWF4OiBzdGF0cy5tYXgsXG4gICAgbWF4YmluczogbWF4Ymluc1xuICB9KTtcbn07XG5cbi8qKlxuICogeFtwWzBdXS4uLltwW25dXSA9IHZhbFxuICogQHBhcmFtIG5vYXVnbWVudCBkZXRlcm1pbmUgd2hldGhlciBuZXcgb2JqZWN0IHNob3VsZCBiZSBhZGRlZCBmXG4gKiBvciBub24tZXhpc3RpbmcgcHJvcGVydGllcyBhbG9uZyB0aGUgcGF0aFxuICovXG51dGlsLnNldHRlciA9IGZ1bmN0aW9uKHgsIHAsIHZhbCwgbm9hdWdtZW50KSB7XG4gIGZvciAodmFyIGk9MDsgaTxwLmxlbmd0aC0xOyArK2kpIHtcbiAgICBpZiAoIW5vYXVnbWVudCAmJiAhKHBbaV0gaW4geCkpe1xuICAgICAgeCA9IHhbcFtpXV0gPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHhbcFtpXV07XG4gICAgfVxuICB9XG4gIHhbcFtpXV0gPSB2YWw7XG59O1xuXG5cbi8qKlxuICogcmV0dXJucyB4W3BbMF1dLi4uW3Bbbl1dXG4gKiBAcGFyYW0gYXVnbWVudCBkZXRlcm1pbmUgd2hldGhlciBuZXcgb2JqZWN0IHNob3VsZCBiZSBhZGRlZCBmXG4gKiBvciBub24tZXhpc3RpbmcgcHJvcGVydGllcyBhbG9uZyB0aGUgcGF0aFxuICovXG51dGlsLmdldHRlciA9IGZ1bmN0aW9uKHgsIHAsIG5vYXVnbWVudCkge1xuICBmb3IgKHZhciBpPTA7IGk8cC5sZW5ndGg7ICsraSkge1xuICAgIGlmICghbm9hdWdtZW50ICYmICEocFtpXSBpbiB4KSl7XG4gICAgICB4ID0geFtwW2ldXSA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geFtwW2ldXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHg7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vZ2xvYmFscycpO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICAgIGNvbnN0cyA9IHJlcXVpcmUoJy4vY29uc3RzJyk7XG5cbnZhciB2bCA9IHt9O1xuXG51dGlsLmV4dGVuZCh2bCwgY29uc3RzLCB1dGlsKTtcblxudmwuRW5jb2RpbmcgPSByZXF1aXJlKCcuL0VuY29kaW5nJyk7XG52bC5jb21waWxlciA9IHJlcXVpcmUoJy4vY29tcGlsZXIvY29tcGlsZXInKTtcbnZsLmNvbXBpbGUgPSB2bC5jb21waWxlci5jb21waWxlO1xudmwuZGF0YSA9IHJlcXVpcmUoJy4vZGF0YScpO1xudmwuZW5jID0gcmVxdWlyZSgnLi9lbmMnKTtcbnZsLmZpZWxkID0gcmVxdWlyZSgnLi9maWVsZCcpO1xudmwuc2NoZW1hID0gcmVxdWlyZSgnLi9zY2hlbWEvc2NoZW1hJyk7XG52bC50b1Nob3J0aGFuZCA9IHZsLkVuY29kaW5nLnNob3J0aGFuZDtcbnZsLmZvcm1hdCA9IHJlcXVpcmUoJ2QzLWZvcm1hdCcpLmZvcm1hdDtcblxubW9kdWxlLmV4cG9ydHMgPSB2bDsiLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIGZhY3RvcnkoKGdsb2JhbC50aW1lID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB0MSA9IG5ldyBEYXRlO1xuXG4gIHZhciB0MCA9IG5ldyBEYXRlO1xuXG4gIGZ1bmN0aW9uIG5ld0ludGVydmFsKGZsb29yaSwgb2Zmc2V0aSwgY291bnQpIHtcblxuICAgIGZ1bmN0aW9uIGludGVydmFsKGRhdGUpIHtcbiAgICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSksIGRhdGU7XG4gICAgfVxuXG4gICAgaW50ZXJ2YWwuZmxvb3IgPSBpbnRlcnZhbDtcblxuICAgIGludGVydmFsLnJvdW5kID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgdmFyIGQwID0gbmV3IERhdGUoK2RhdGUpLFxuICAgICAgICAgIGQxID0gbmV3IERhdGUoZGF0ZSAtIDEpO1xuICAgICAgZmxvb3JpKGQwKSwgZmxvb3JpKGQxKSwgb2Zmc2V0aShkMSwgMSk7XG4gICAgICByZXR1cm4gZGF0ZSAtIGQwIDwgZDEgLSBkYXRlID8gZDAgOiBkMTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwuY2VpbCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKGRhdGUgLSAxKSksIG9mZnNldGkoZGF0ZSwgMSksIGRhdGU7XG4gICAgfTtcblxuICAgIGludGVydmFsLm9mZnNldCA9IGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgIHJldHVybiBvZmZzZXRpKGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSksIHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApKSwgZGF0ZTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgICAgdmFyIHJhbmdlID0gW107XG4gICAgICBzdGFydCA9IG5ldyBEYXRlKHN0YXJ0IC0gMSk7XG4gICAgICBzdG9wID0gbmV3IERhdGUoK3N0b3ApO1xuICAgICAgc3RlcCA9IHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApO1xuICAgICAgaWYgKCEoc3RhcnQgPCBzdG9wKSB8fCAhKHN0ZXAgPiAwKSkgcmV0dXJuIHJhbmdlOyAvLyBhbHNvIGhhbmRsZXMgSW52YWxpZCBEYXRlXG4gICAgICBvZmZzZXRpKHN0YXJ0LCAxKSwgZmxvb3JpKHN0YXJ0KTtcbiAgICAgIGlmIChzdGFydCA8IHN0b3ApIHJhbmdlLnB1c2gobmV3IERhdGUoK3N0YXJ0KSk7XG4gICAgICB3aGlsZSAob2Zmc2V0aShzdGFydCwgc3RlcCksIGZsb29yaShzdGFydCksIHN0YXJ0IDwgc3RvcCkgcmFuZ2UucHVzaChuZXcgRGF0ZSgrc3RhcnQpKTtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwuZmlsdGVyID0gZnVuY3Rpb24odGVzdCkge1xuICAgICAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgd2hpbGUgKGZsb29yaShkYXRlKSwgIXRlc3QoZGF0ZSkpIGRhdGUuc2V0VGltZShkYXRlIC0gMSk7XG4gICAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICAgIHdoaWxlICgtLXN0ZXAgPj0gMCkgd2hpbGUgKG9mZnNldGkoZGF0ZSwgMSksICF0ZXN0KGRhdGUpKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoY291bnQpIGludGVydmFsLmNvdW50ID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgdDAuc2V0VGltZSgrc3RhcnQpLCB0MS5zZXRUaW1lKCtlbmQpO1xuICAgICAgZmxvb3JpKHQwKSwgZmxvb3JpKHQxKTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGNvdW50KHQwLCB0MSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gaW50ZXJ2YWw7XG4gIH1cblxuICB2YXIgc2Vjb25kID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0TWlsbGlzZWNvbmRzKDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIDFlMyk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIDFlMztcbiAgfSk7XG5cbiAgZXhwb3J0cy5zZWNvbmRzID0gc2Vjb25kLnJhbmdlO1xuXG4gIHZhciBtaW51dGUgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRTZWNvbmRzKDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIDZlNCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIDZlNDtcbiAgfSk7XG5cbiAgZXhwb3J0cy5taW51dGVzID0gbWludXRlLnJhbmdlO1xuXG4gIHZhciBob3VyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0TWludXRlcygwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiAzNmU1KTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gMzZlNTtcbiAgfSk7XG5cbiAgZXhwb3J0cy5ob3VycyA9IGhvdXIucmFuZ2U7XG5cbiAgdmFyIGRheSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RlcCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0IC0gKGVuZC5nZXRUaW1lem9uZU9mZnNldCgpIC0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiA2ZTQpIC8gODY0ZTU7XG4gIH0pO1xuXG4gIGV4cG9ydHMuZGF5cyA9IGRheS5yYW5nZTtcblxuICBmdW5jdGlvbiB3ZWVrZGF5KGkpIHtcbiAgICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIChkYXRlLmdldERheSgpICsgNyAtIGkpICUgNyk7XG4gICAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RlcCAqIDcpO1xuICAgIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIDZlNCkgLyA2MDQ4ZTU7XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLnN1bmRheSA9IHdlZWtkYXkoMCk7XG5cbiAgZXhwb3J0cy5zdW5kYXlzID0gZXhwb3J0cy5zdW5kYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy5tb25kYXkgPSB3ZWVrZGF5KDEpO1xuXG4gIGV4cG9ydHMubW9uZGF5cyA9IGV4cG9ydHMubW9uZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMudHVlc2RheSA9IHdlZWtkYXkoMik7XG5cbiAgZXhwb3J0cy50dWVzZGF5cyA9IGV4cG9ydHMudHVlc2RheS5yYW5nZTtcblxuICBleHBvcnRzLndlZG5lc2RheSA9IHdlZWtkYXkoMyk7XG5cbiAgZXhwb3J0cy53ZWRuZXNkYXlzID0gZXhwb3J0cy53ZWRuZXNkYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy50aHVyc2RheSA9IHdlZWtkYXkoNCk7XG5cbiAgZXhwb3J0cy50aHVyc2RheXMgPSBleHBvcnRzLnRodXJzZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMuZnJpZGF5ID0gd2Vla2RheSg1KTtcblxuICBleHBvcnRzLmZyaWRheXMgPSBleHBvcnRzLmZyaWRheS5yYW5nZTtcblxuICBleHBvcnRzLnNhdHVyZGF5ID0gd2Vla2RheSg2KTtcblxuICBleHBvcnRzLnNhdHVyZGF5cyA9IGV4cG9ydHMuc2F0dXJkYXkucmFuZ2U7XG5cbiAgdmFyIHdlZWsgPSBleHBvcnRzLnN1bmRheTtcblxuICBleHBvcnRzLndlZWtzID0gd2Vlay5yYW5nZTtcblxuICB2YXIgbW9udGggPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICBkYXRlLnNldERhdGUoMSk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldE1vbnRoKGRhdGUuZ2V0TW9udGgoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGVuZC5nZXRNb250aCgpIC0gc3RhcnQuZ2V0TW9udGgoKSArIChlbmQuZ2V0RnVsbFllYXIoKSAtIHN0YXJ0LmdldEZ1bGxZZWFyKCkpICogMTI7XG4gIH0pO1xuXG4gIGV4cG9ydHMubW9udGhzID0gbW9udGgucmFuZ2U7XG5cbiAgdmFyIHllYXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICBkYXRlLnNldE1vbnRoKDAsIDEpO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBlbmQuZ2V0RnVsbFllYXIoKSAtIHN0YXJ0LmdldEZ1bGxZZWFyKCk7XG4gIH0pO1xuXG4gIGV4cG9ydHMueWVhcnMgPSB5ZWFyLnJhbmdlO1xuXG4gIHZhciB1dGNTZWNvbmQgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENNaWxsaXNlY29uZHMoMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogMWUzKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gMWUzO1xuICB9KTtcblxuICBleHBvcnRzLnV0Y1NlY29uZHMgPSB1dGNTZWNvbmQucmFuZ2U7XG5cbiAgdmFyIHV0Y01pbnV0ZSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ1NlY29uZHMoMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogNmU0KTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gNmU0O1xuICB9KTtcblxuICBleHBvcnRzLnV0Y01pbnV0ZXMgPSB1dGNNaW51dGUucmFuZ2U7XG5cbiAgdmFyIHV0Y0hvdXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENNaW51dGVzKDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIDM2ZTUpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyAzNmU1O1xuICB9KTtcblxuICBleHBvcnRzLnV0Y0hvdXJzID0gdXRjSG91ci5yYW5nZTtcblxuICB2YXIgdXRjRGF5ID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gODY0ZTU7XG4gIH0pO1xuXG4gIGV4cG9ydHMudXRjRGF5cyA9IHV0Y0RheS5yYW5nZTtcblxuICBmdW5jdGlvbiB1dGNXZWVrZGF5KGkpIHtcbiAgICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSAtIChkYXRlLmdldFVUQ0RheSgpICsgNyAtIGkpICUgNyk7XG4gICAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgc3RlcCAqIDcpO1xuICAgIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gNjA0OGU1O1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy51dGNTdW5kYXkgPSB1dGNXZWVrZGF5KDApO1xuXG4gIGV4cG9ydHMudXRjU3VuZGF5cyA9IGV4cG9ydHMudXRjU3VuZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMudXRjTW9uZGF5ID0gdXRjV2Vla2RheSgxKTtcblxuICBleHBvcnRzLnV0Y01vbmRheXMgPSBleHBvcnRzLnV0Y01vbmRheS5yYW5nZTtcblxuICBleHBvcnRzLnV0Y1R1ZXNkYXkgPSB1dGNXZWVrZGF5KDIpO1xuXG4gIGV4cG9ydHMudXRjVHVlc2RheXMgPSBleHBvcnRzLnV0Y1R1ZXNkYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy51dGNXZWRuZXNkYXkgPSB1dGNXZWVrZGF5KDMpO1xuXG4gIGV4cG9ydHMudXRjV2VkbmVzZGF5cyA9IGV4cG9ydHMudXRjV2VkbmVzZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMudXRjVGh1cnNkYXkgPSB1dGNXZWVrZGF5KDQpO1xuXG4gIGV4cG9ydHMudXRjVGh1cnNkYXlzID0gZXhwb3J0cy51dGNUaHVyc2RheS5yYW5nZTtcblxuICBleHBvcnRzLnV0Y0ZyaWRheSA9IHV0Y1dlZWtkYXkoNSk7XG5cbiAgZXhwb3J0cy51dGNGcmlkYXlzID0gZXhwb3J0cy51dGNGcmlkYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy51dGNTYXR1cmRheSA9IHV0Y1dlZWtkYXkoNik7XG5cbiAgZXhwb3J0cy51dGNTYXR1cmRheXMgPSBleHBvcnRzLnV0Y1NhdHVyZGF5LnJhbmdlO1xuXG4gIHZhciB1dGNXZWVrID0gZXhwb3J0cy51dGNTdW5kYXk7XG5cbiAgZXhwb3J0cy51dGNXZWVrcyA9IHV0Y1dlZWsucmFuZ2U7XG5cbiAgdmFyIHV0Y01vbnRoID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgZGF0ZS5zZXRVVENEYXRlKDEpO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENNb250aChkYXRlLmdldFVUQ01vbnRoKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBlbmQuZ2V0VVRDTW9udGgoKSAtIHN0YXJ0LmdldFVUQ01vbnRoKCkgKyAoZW5kLmdldFVUQ0Z1bGxZZWFyKCkgLSBzdGFydC5nZXRVVENGdWxsWWVhcigpKSAqIDEyO1xuICB9KTtcblxuICBleHBvcnRzLnV0Y01vbnRocyA9IHV0Y01vbnRoLnJhbmdlO1xuXG4gIHZhciB1dGNZZWFyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpICsgc3RlcCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZW5kLmdldFVUQ0Z1bGxZZWFyKCkgLSBzdGFydC5nZXRVVENGdWxsWWVhcigpO1xuICB9KTtcblxuICBleHBvcnRzLnV0Y1llYXJzID0gdXRjWWVhci5yYW5nZTtcblxuICBleHBvcnRzLmludGVydmFsID0gbmV3SW50ZXJ2YWw7XG4gIGV4cG9ydHMuc2Vjb25kID0gc2Vjb25kO1xuICBleHBvcnRzLm1pbnV0ZSA9IG1pbnV0ZTtcbiAgZXhwb3J0cy5ob3VyID0gaG91cjtcbiAgZXhwb3J0cy5kYXkgPSBkYXk7XG4gIGV4cG9ydHMud2VlayA9IHdlZWs7XG4gIGV4cG9ydHMubW9udGggPSBtb250aDtcbiAgZXhwb3J0cy55ZWFyID0geWVhcjtcbiAgZXhwb3J0cy51dGNTZWNvbmQgPSB1dGNTZWNvbmQ7XG4gIGV4cG9ydHMudXRjTWludXRlID0gdXRjTWludXRlO1xuICBleHBvcnRzLnV0Y0hvdXIgPSB1dGNIb3VyO1xuICBleHBvcnRzLnV0Y0RheSA9IHV0Y0RheTtcbiAgZXhwb3J0cy51dGNXZWVrID0gdXRjV2VlaztcbiAgZXhwb3J0cy51dGNNb250aCA9IHV0Y01vbnRoO1xuICBleHBvcnRzLnV0Y1llYXIgPSB1dGNZZWFyO1xuXG59KSk7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gICAgdGltZSA9IHJlcXVpcmUoJy4uL3RpbWUnKSxcbiAgICBFUFNJTE9OID0gMWUtMTU7XG5cbmZ1bmN0aW9uIGJpbnMob3B0KSB7XG4gIGlmICghb3B0KSB7IHRocm93IEVycm9yKFwiTWlzc2luZyBiaW5uaW5nIG9wdGlvbnMuXCIpOyB9XG5cbiAgLy8gZGV0ZXJtaW5lIHJhbmdlXG4gIHZhciBtYXhiID0gb3B0Lm1heGJpbnMgfHwgMTUsXG4gICAgICBiYXNlID0gb3B0LmJhc2UgfHwgMTAsXG4gICAgICBsb2diID0gTWF0aC5sb2coYmFzZSksXG4gICAgICBkaXYgPSBvcHQuZGl2IHx8IFs1LCAyXSwgICAgICBcbiAgICAgIG1pbiA9IG9wdC5taW4sXG4gICAgICBtYXggPSBvcHQubWF4LFxuICAgICAgc3BhbiA9IG1heCAtIG1pbixcbiAgICAgIHN0ZXAsIGxldmVsLCBtaW5zdGVwLCBwcmVjaXNpb24sIHYsIGksIGVwcztcblxuICBpZiAob3B0LnN0ZXApIHtcbiAgICAvLyBpZiBzdGVwIHNpemUgaXMgZXhwbGljaXRseSBnaXZlbiwgdXNlIHRoYXRcbiAgICBzdGVwID0gb3B0LnN0ZXA7XG4gIH0gZWxzZSBpZiAob3B0LnN0ZXBzKSB7XG4gICAgLy8gaWYgcHJvdmlkZWQsIGxpbWl0IGNob2ljZSB0byBhY2NlcHRhYmxlIHN0ZXAgc2l6ZXNcbiAgICBzdGVwID0gb3B0LnN0ZXBzW01hdGgubWluKFxuICAgICAgb3B0LnN0ZXBzLmxlbmd0aCAtIDEsXG4gICAgICBiaXNlY3Qob3B0LnN0ZXBzLCBzcGFuL21heGIsIDAsIG9wdC5zdGVwcy5sZW5ndGgpXG4gICAgKV07XG4gIH0gZWxzZSB7XG4gICAgLy8gZWxzZSB1c2Ugc3BhbiB0byBkZXRlcm1pbmUgc3RlcCBzaXplXG4gICAgbGV2ZWwgPSBNYXRoLmNlaWwoTWF0aC5sb2cobWF4YikgLyBsb2diKTtcbiAgICBtaW5zdGVwID0gb3B0Lm1pbnN0ZXAgfHwgMDtcbiAgICBzdGVwID0gTWF0aC5tYXgoXG4gICAgICBtaW5zdGVwLFxuICAgICAgTWF0aC5wb3coYmFzZSwgTWF0aC5yb3VuZChNYXRoLmxvZyhzcGFuKSAvIGxvZ2IpIC0gbGV2ZWwpXG4gICAgKTtcbiAgICBcbiAgICAvLyBpbmNyZWFzZSBzdGVwIHNpemUgaWYgdG9vIG1hbnkgYmluc1xuICAgIGRvIHsgc3RlcCAqPSBiYXNlOyB9IHdoaWxlIChNYXRoLmNlaWwoc3Bhbi9zdGVwKSA+IG1heGIpO1xuXG4gICAgLy8gZGVjcmVhc2Ugc3RlcCBzaXplIGlmIGFsbG93ZWRcbiAgICBmb3IgKGk9MDsgaTxkaXYubGVuZ3RoOyArK2kpIHtcbiAgICAgIHYgPSBzdGVwIC8gZGl2W2ldO1xuICAgICAgaWYgKHYgPj0gbWluc3RlcCAmJiBzcGFuIC8gdiA8PSBtYXhiKSBzdGVwID0gdjtcbiAgICB9XG4gIH1cblxuICAvLyB1cGRhdGUgcHJlY2lzaW9uLCBtaW4gYW5kIG1heFxuICB2ID0gTWF0aC5sb2coc3RlcCk7XG4gIHByZWNpc2lvbiA9IHYgPj0gMCA/IDAgOiB+figtdiAvIGxvZ2IpICsgMTtcbiAgZXBzID0gTWF0aC5wb3coYmFzZSwgLXByZWNpc2lvbiAtIDEpO1xuICBtaW4gPSBNYXRoLm1pbihtaW4sIE1hdGguZmxvb3IobWluIC8gc3RlcCArIGVwcykgKiBzdGVwKTtcbiAgbWF4ID0gTWF0aC5jZWlsKG1heCAvIHN0ZXApICogc3RlcDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBtaW4sXG4gICAgc3RvcDogIG1heCxcbiAgICBzdGVwOiAgc3RlcCxcbiAgICB1bml0OiAge3ByZWNpc2lvbjogcHJlY2lzaW9ufSxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgaW5kZXg6IGluZGV4XG4gIH07XG59XG5cbmZ1bmN0aW9uIGJpc2VjdChhLCB4LCBsbywgaGkpIHtcbiAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICBpZiAodXRpbC5jbXAoYVttaWRdLCB4KSA8IDApIHsgbG8gPSBtaWQgKyAxOyB9XG4gICAgZWxzZSB7IGhpID0gbWlkOyB9XG4gIH1cbiAgcmV0dXJuIGxvO1xufVxuXG5mdW5jdGlvbiB2YWx1ZSh2KSB7XG4gIHJldHVybiB0aGlzLnN0ZXAgKiBNYXRoLmZsb29yKHYgLyB0aGlzLnN0ZXAgKyBFUFNJTE9OKTtcbn1cblxuZnVuY3Rpb24gaW5kZXgodikge1xuICByZXR1cm4gTWF0aC5mbG9vcigodiAtIHRoaXMuc3RhcnQpIC8gdGhpcy5zdGVwICsgRVBTSUxPTik7XG59XG5cbmZ1bmN0aW9uIGRhdGVfdmFsdWUodikge1xuICByZXR1cm4gdGhpcy51bml0LmRhdGUodmFsdWUuY2FsbCh0aGlzLCB2KSk7XG59XG5cbmZ1bmN0aW9uIGRhdGVfaW5kZXgodikge1xuICByZXR1cm4gaW5kZXguY2FsbCh0aGlzLCB0aGlzLnVuaXQudW5pdCh2KSk7XG59XG5cbmJpbnMuZGF0ZSA9IGZ1bmN0aW9uKG9wdCkge1xuICBpZiAoIW9wdCkgeyB0aHJvdyBFcnJvcihcIk1pc3NpbmcgZGF0ZSBiaW5uaW5nIG9wdGlvbnMuXCIpOyB9XG5cbiAgLy8gZmluZCB0aW1lIHN0ZXAsIHRoZW4gYmluXG4gIHZhciB1bml0cyA9IG9wdC51dGMgPyB0aW1lLnV0YyA6IHRpbWUsXG4gICAgICBkbWluID0gb3B0Lm1pbixcbiAgICAgIGRtYXggPSBvcHQubWF4LFxuICAgICAgbWF4YiA9IG9wdC5tYXhiaW5zIHx8IDIwLFxuICAgICAgbWluYiA9IG9wdC5taW5iaW5zIHx8IDQsXG4gICAgICBzcGFuID0gKCtkbWF4KSAtICgrZG1pbiksXG4gICAgICB1bml0ID0gb3B0LnVuaXQgPyB1bml0c1tvcHQudW5pdF0gOiB1bml0cy5maW5kKHNwYW4sIG1pbmIsIG1heGIpLFxuICAgICAgc3BlYyA9IGJpbnMoe1xuICAgICAgICBtaW46ICAgICB1bml0Lm1pbiAhPSBudWxsID8gdW5pdC5taW4gOiB1bml0LnVuaXQoZG1pbiksXG4gICAgICAgIG1heDogICAgIHVuaXQubWF4ICE9IG51bGwgPyB1bml0Lm1heCA6IHVuaXQudW5pdChkbWF4KSxcbiAgICAgICAgbWF4YmluczogbWF4YixcbiAgICAgICAgbWluc3RlcDogdW5pdC5taW5zdGVwLFxuICAgICAgICBzdGVwczogICB1bml0LnN0ZXBcbiAgICAgIH0pO1xuXG4gIHNwZWMudW5pdCA9IHVuaXQ7XG4gIHNwZWMuaW5kZXggPSBkYXRlX2luZGV4O1xuICBpZiAoIW9wdC5yYXcpIHNwZWMudmFsdWUgPSBkYXRlX3ZhbHVlO1xuICByZXR1cm4gc3BlYztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmlucztcbiIsInZhciBnZW4gPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5nZW4ucmVwZWF0ID0gZnVuY3Rpb24odmFsLCBuKSB7XG4gIHZhciBhID0gQXJyYXkobiksIGk7XG4gIGZvciAoaT0wOyBpPG47ICsraSkgYVtpXSA9IHZhbDtcbiAgcmV0dXJuIGE7XG59O1xuXG5nZW4uemVyb3MgPSBmdW5jdGlvbihuKSB7XG4gIHJldHVybiBnZW4ucmVwZWF0KDAsIG4pO1xufTtcblxuZ2VuLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgc3RlcCA9IDE7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBzdG9wID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICB9XG4gIGlmICgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXAgPT0gSW5maW5pdHkpIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgcmFuZ2UnKTtcbiAgdmFyIHJhbmdlID0gW10sIGkgPSAtMSwgajtcbiAgaWYgKHN0ZXAgPCAwKSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpID4gc3RvcCkgcmFuZ2UucHVzaChqKTtcbiAgZWxzZSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpIDwgc3RvcCkgcmFuZ2UucHVzaChqKTtcbiAgcmV0dXJuIHJhbmdlO1xufTtcblxuZ2VuLnJhbmRvbSA9IHt9O1xuXG5nZW4ucmFuZG9tLnVuaWZvcm0gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICBtYXggPSBtaW4gPT09IHVuZGVmaW5lZCA/IDEgOiBtaW47XG4gICAgbWluID0gMDtcbiAgfVxuICB2YXIgZCA9IG1heCAtIG1pbjtcbiAgdmFyIGYgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbWluICsgZCAqIE1hdGgucmFuZG9tKCk7XG4gIH07XG4gIGYuc2FtcGxlcyA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIGdlbi56ZXJvcyhuKS5tYXAoZik7IH07XG4gIHJldHVybiBmO1xufTtcblxuZ2VuLnJhbmRvbS5pbnRlZ2VyID0gZnVuY3Rpb24oYSwgYikge1xuICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYiA9IGE7XG4gICAgYSA9IDA7XG4gIH1cbiAgdmFyIGQgPSBiIC0gYTtcbiAgdmFyIGYgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYSArIE1hdGguZmxvb3IoZCAqIE1hdGgucmFuZG9tKCkpO1xuICB9O1xuICBmLnNhbXBsZXMgPSBmdW5jdGlvbihuKSB7IHJldHVybiBnZW4uemVyb3MobikubWFwKGYpOyB9O1xuICByZXR1cm4gZjtcbn07XG5cbmdlbi5yYW5kb20ubm9ybWFsID0gZnVuY3Rpb24obWVhbiwgc3RkZXYpIHtcbiAgbWVhbiA9IG1lYW4gfHwgMDtcbiAgc3RkZXYgPSBzdGRldiB8fCAxO1xuICB2YXIgbmV4dDtcbiAgdmFyIGYgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgeCA9IDAsIHkgPSAwLCByZHMsIGM7XG4gICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgeCA9IG5leHQ7XG4gICAgICBuZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGRvIHtcbiAgICAgIHggPSBNYXRoLnJhbmRvbSgpKjItMTtcbiAgICAgIHkgPSBNYXRoLnJhbmRvbSgpKjItMTtcbiAgICAgIHJkcyA9IHgqeCArIHkqeTtcbiAgICB9IHdoaWxlIChyZHMgPT09IDAgfHwgcmRzID4gMSk7XG4gICAgYyA9IE1hdGguc3FydCgtMipNYXRoLmxvZyhyZHMpL3Jkcyk7IC8vIEJveC1NdWxsZXIgdHJhbnNmb3JtXG4gICAgbmV4dCA9IG1lYW4gKyB5KmMqc3RkZXY7XG4gICAgcmV0dXJuIG1lYW4gKyB4KmMqc3RkZXY7XG4gIH07XG4gIGYuc2FtcGxlcyA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIGdlbi56ZXJvcyhuKS5tYXAoZik7IH07XG4gIHJldHVybiBmO1xufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxudmFyIFRZUEVTID0gJ19fdHlwZXNfXyc7XG5cbnZhciBQQVJTRVJTID0ge1xuICBib29sZWFuOiB1dGlsLmJvb2xlYW4sXG4gIGludGVnZXI6IHV0aWwubnVtYmVyLFxuICBudW1iZXI6ICB1dGlsLm51bWJlcixcbiAgZGF0ZTogICAgdXRpbC5kYXRlLFxuICBzdHJpbmc6ICBmdW5jdGlvbih4KSB7IHJldHVybiB4PT09JycgPyBudWxsIDogeDsgfVxufTtcblxudmFyIFRFU1RTID0ge1xuICBib29sZWFuOiBmdW5jdGlvbih4KSB7IHJldHVybiB4PT09J3RydWUnIHx8IHg9PT0nZmFsc2UnIHx8IHV0aWwuaXNCb29sZWFuKHgpOyB9LFxuICBpbnRlZ2VyOiBmdW5jdGlvbih4KSB7IHJldHVybiBURVNUUy5udW1iZXIoeCkgJiYgKHg9K3gpID09PSB+fng7IH0sXG4gIG51bWJlcjogZnVuY3Rpb24oeCkgeyByZXR1cm4gIWlzTmFOKCt4KSAmJiAhdXRpbC5pc0RhdGUoeCk7IH0sXG4gIGRhdGU6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuICFpc05hTihEYXRlLnBhcnNlKHgpKTsgfVxufTtcblxuZnVuY3Rpb24gYW5ub3RhdGlvbihkYXRhLCB0eXBlcykge1xuICBpZiAoIXR5cGVzKSByZXR1cm4gZGF0YSAmJiBkYXRhW1RZUEVTXSB8fCBudWxsO1xuICBkYXRhW1RZUEVTXSA9IHR5cGVzO1xufVxuXG5mdW5jdGlvbiB0eXBlKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgdiwgaSwgbjtcblxuICAvLyBpZiBkYXRhIGFycmF5IGhhcyB0eXBlIGFubm90YXRpb25zLCB1c2UgdGhlbVxuICBpZiAodmFsdWVzW1RZUEVTXSkge1xuICAgIHYgPSBmKHZhbHVlc1tUWVBFU10pO1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHYpKSByZXR1cm4gdjtcbiAgfVxuXG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7ICF1dGlsLmlzVmFsaWQodikgJiYgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgfVxuXG4gIHJldHVybiB1dGlsLmlzRGF0ZSh2KSA/ICdkYXRlJyA6XG4gICAgdXRpbC5pc051bWJlcih2KSAgICA/ICdudW1iZXInIDpcbiAgICB1dGlsLmlzQm9vbGVhbih2KSAgID8gJ2Jvb2xlYW4nIDpcbiAgICB1dGlsLmlzU3RyaW5nKHYpICAgID8gJ3N0cmluZycgOiBudWxsO1xufVxuXG5mdW5jdGlvbiB0eXBlQWxsKGRhdGEsIGZpZWxkcykge1xuICBpZiAoIWRhdGEubGVuZ3RoKSByZXR1cm47XG4gIGZpZWxkcyA9IGZpZWxkcyB8fCB1dGlsLmtleXMoZGF0YVswXSk7XG4gIHJldHVybiBmaWVsZHMucmVkdWNlKGZ1bmN0aW9uKHR5cGVzLCBmKSB7XG4gICAgcmV0dXJuICh0eXBlc1tmXSA9IHR5cGUoZGF0YSwgZiksIHR5cGVzKTtcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBpbmZlcih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIGksIGosIHY7XG5cbiAgLy8gdHlwZXMgdG8gdGVzdCBmb3IsIGluIHByZWNlZGVuY2Ugb3JkZXJcbiAgdmFyIHR5cGVzID0gWydib29sZWFuJywgJ2ludGVnZXInLCAnbnVtYmVyJywgJ2RhdGUnXTtcblxuICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBnZXQgbmV4dCB2YWx1ZSB0byB0ZXN0XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgLy8gdGVzdCB2YWx1ZSBhZ2FpbnN0IHJlbWFpbmluZyB0eXBlc1xuICAgIGZvciAoaj0wOyBqPHR5cGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAodXRpbC5pc1ZhbGlkKHYpICYmICFURVNUU1t0eXBlc1tqXV0odikpIHtcbiAgICAgICAgdHlwZXMuc3BsaWNlKGosIDEpO1xuICAgICAgICBqIC09IDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIG5vIHR5cGVzIGxlZnQsIHJldHVybiAnc3RyaW5nJ1xuICAgIGlmICh0eXBlcy5sZW5ndGggPT09IDApIHJldHVybiAnc3RyaW5nJztcbiAgfVxuXG4gIHJldHVybiB0eXBlc1swXTtcbn1cblxuZnVuY3Rpb24gaW5mZXJBbGwoZGF0YSwgZmllbGRzKSB7XG4gIGZpZWxkcyA9IGZpZWxkcyB8fCB1dGlsLmtleXMoZGF0YVswXSk7XG4gIHJldHVybiBmaWVsZHMucmVkdWNlKGZ1bmN0aW9uKHR5cGVzLCBmKSB7XG4gICAgdHlwZXNbZl0gPSBpbmZlcihkYXRhLCBmKTtcbiAgICByZXR1cm4gdHlwZXM7XG4gIH0sIHt9KTtcbn1cblxudHlwZS5hbm5vdGF0aW9uID0gYW5ub3RhdGlvbjtcbnR5cGUuYWxsID0gdHlwZUFsbDtcbnR5cGUuaW5mZXIgPSBpbmZlcjtcbnR5cGUuaW5mZXJBbGwgPSBpbmZlckFsbDtcbnR5cGUucGFyc2VycyA9IFBBUlNFUlM7XG5tb2R1bGUuZXhwb3J0cyA9IHR5cGU7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnLi9pbXBvcnQvdHlwZScpO1xudmFyIGdlbiA9IHJlcXVpcmUoJy4vZ2VuZXJhdGUnKTtcbnZhciBzdGF0cyA9IHt9O1xuXG4vLyBDb2xsZWN0IHVuaXF1ZSB2YWx1ZXMuXG4vLyBPdXRwdXQ6IGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIGZpcnN0LW9ic2VydmVkIG9yZGVyXG5zdGF0cy51bmlxdWUgPSBmdW5jdGlvbih2YWx1ZXMsIGYsIHJlc3VsdHMpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG4gIHZhciB1ID0ge30sIHYsIGksIG47XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgaW4gdSkgY29udGludWU7XG4gICAgdVt2XSA9IDE7XG4gICAgcmVzdWx0cy5wdXNoKHYpO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGlucHV0IGFycmF5Llxuc3RhdHMuY291bnQgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgcmV0dXJuIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoIHx8IDA7XG59O1xuXG4vLyBDb3VudCB0aGUgbnVtYmVyIG9mIG5vbi1udWxsLCBub24tdW5kZWZpbmVkLCBub24tTmFOIHZhbHVlcy5cbnN0YXRzLmNvdW50LnZhbGlkID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciB2LCBpLCBuLCB2YWxpZCA9IDA7XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkgdmFsaWQgKz0gMTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59O1xuXG4vLyBDb3VudCB0aGUgbnVtYmVyIG9mIG51bGwgb3IgdW5kZWZpbmVkIHZhbHVlcy5cbnN0YXRzLmNvdW50Lm1pc3NpbmcgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIHYsIGksIG4sIGNvdW50ID0gMDtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodiA9PSBudWxsKSBjb3VudCArPSAxO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn07XG5cbi8vIENvdW50IHRoZSBudW1iZXIgb2YgZGlzdGluY3QgdmFsdWVzLlxuLy8gTnVsbCwgdW5kZWZpbmVkIGFuZCBOYU4gYXJlIGVhY2ggY29uc2lkZXJlZCBkaXN0aW5jdCB2YWx1ZXMuXG5zdGF0cy5jb3VudC5kaXN0aW5jdCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgdSA9IHt9LCB2LCBpLCBuLCBjb3VudCA9IDA7XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgaW4gdSkgY29udGludWU7XG4gICAgdVt2XSA9IDE7XG4gICAgY291bnQgKz0gMTtcbiAgfVxuICByZXR1cm4gY291bnQ7XG59O1xuXG4vLyBDb25zdHJ1Y3QgYSBtYXAgZnJvbSBkaXN0aW5jdCB2YWx1ZXMgdG8gb2NjdXJyZW5jZSBjb3VudHMuXG5zdGF0cy5jb3VudC5tYXAgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIG1hcCA9IHt9LCB2LCBpLCBuO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIG1hcFt2XSA9ICh2IGluIG1hcCkgPyBtYXBbdl0gKyAxIDogMTtcbiAgfVxuICByZXR1cm4gbWFwO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbWVkaWFuIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5tZWRpYW4gPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgaWYgKGYpIHZhbHVlcyA9IHZhbHVlcy5tYXAodXRpbC4kKGYpKTtcbiAgdmFsdWVzID0gdmFsdWVzLmZpbHRlcih1dGlsLmlzVmFsaWQpLnNvcnQodXRpbC5jbXApO1xuICByZXR1cm4gc3RhdHMucXVhbnRpbGUodmFsdWVzLCAwLjUpO1xufTtcblxuLy8gQ29tcHV0ZXMgdGhlIHF1YXJ0aWxlIGJvdW5kYXJpZXMgb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLnF1YXJ0aWxlID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGlmIChmKSB2YWx1ZXMgPSB2YWx1ZXMubWFwKHV0aWwuJChmKSk7XG4gIHZhbHVlcyA9IHZhbHVlcy5maWx0ZXIodXRpbC5pc1ZhbGlkKS5zb3J0KHV0aWwuY21wKTtcbiAgdmFyIHEgPSBzdGF0cy5xdWFudGlsZTtcbiAgcmV0dXJuIFtxKHZhbHVlcywgMC4yNSksIHEodmFsdWVzLCAwLjUwKSwgcSh2YWx1ZXMsIDAuNzUpXTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHF1YW50aWxlIG9mIGEgc29ydGVkIGFycmF5IG9mIG51bWJlcnMuXG4vLyBBZGFwdGVkIGZyb20gdGhlIEQzLmpzIGltcGxlbWVudGF0aW9uLlxuc3RhdHMucXVhbnRpbGUgPSBmdW5jdGlvbih2YWx1ZXMsIGYsIHApIHtcbiAgaWYgKHAgPT09IHVuZGVmaW5lZCkgeyBwID0gZjsgZiA9IHV0aWwuaWRlbnRpdHk7IH1cbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIEggPSAodmFsdWVzLmxlbmd0aCAtIDEpICogcCArIDEsXG4gICAgICBoID0gTWF0aC5mbG9vcihIKSxcbiAgICAgIHYgPSArZih2YWx1ZXNbaCAtIDFdKSxcbiAgICAgIGUgPSBIIC0gaDtcbiAgcmV0dXJuIGUgPyB2ICsgZSAqIChmKHZhbHVlc1toXSkgLSB2KSA6IHY7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBzdW0gb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLnN1bSA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICBmb3IgKHZhciBzdW09MCwgaT0wLCBuPXZhbHVlcy5sZW5ndGgsIHY7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkgc3VtICs9IHY7XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIG1lYW4gKGF2ZXJhZ2UpIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5tZWFuID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBtZWFuID0gMCwgZGVsdGEsIGksIG4sIGMsIHY7XG4gIGZvciAoaT0wLCBjPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBkZWx0YSA9IHYgLSBtZWFuO1xuICAgICAgbWVhbiA9IG1lYW4gKyBkZWx0YSAvICgrK2MpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVhbjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHNhbXBsZSB2YXJpYW5jZSBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMudmFyaWFuY2UgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgaWYgKCF1dGlsLmlzQXJyYXkodmFsdWVzKSB8fCB2YWx1ZXMubGVuZ3RoIDwgMikgcmV0dXJuIDA7XG4gIHZhciBtZWFuID0gMCwgTTIgPSAwLCBkZWx0YSwgaSwgYywgdjtcbiAgZm9yIChpPTAsIGM9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBkZWx0YSA9IHYgLSBtZWFuO1xuICAgICAgbWVhbiA9IG1lYW4gKyBkZWx0YSAvICgrK2MpO1xuICAgICAgTTIgPSBNMiArIGRlbHRhICogKHYgLSBtZWFuKTtcbiAgICB9XG4gIH1cbiAgTTIgPSBNMiAvIChjIC0gMSk7XG4gIHJldHVybiBNMjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHNhbXBsZSBzdGFuZGFyZCBkZXZpYXRpb24gb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLnN0ZGV2ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoc3RhdHMudmFyaWFuY2UodmFsdWVzLCBmKSk7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBQZWFyc29uIG1vZGUgc2tld25lc3MgKChtZWRpYW4tbWVhbikvc3RkZXYpIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5tb2Rlc2tldyA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICB2YXIgYXZnID0gc3RhdHMubWVhbih2YWx1ZXMsIGYpLFxuICAgICAgbWVkID0gc3RhdHMubWVkaWFuKHZhbHVlcywgZiksXG4gICAgICBzdGQgPSBzdGF0cy5zdGRldih2YWx1ZXMsIGYpO1xuICByZXR1cm4gc3RkID09PSAwID8gMCA6IChhdmcgLSBtZWQpIC8gc3RkO1xufTtcblxuLy8gRmluZCB0aGUgbWluaW11bSB2YWx1ZSBpbiBhbiBhcnJheS5cbnN0YXRzLm1pbiA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICByZXR1cm4gc3RhdHMuZXh0ZW50KHZhbHVlcywgZilbMF07XG59O1xuXG4vLyBGaW5kIHRoZSBtYXhpbXVtIHZhbHVlIGluIGFuIGFycmF5Llxuc3RhdHMubWF4ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHJldHVybiBzdGF0cy5leHRlbnQodmFsdWVzLCBmKVsxXTtcbn07XG5cbi8vIEZpbmQgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gb2YgYW4gYXJyYXkgb2YgdmFsdWVzLlxuc3RhdHMuZXh0ZW50ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBhLCBiLCB2LCBpLCBuID0gdmFsdWVzLmxlbmd0aDtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkgeyBhID0gYiA9IHY7IGJyZWFrOyB9XG4gIH1cbiAgZm9yICg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkge1xuICAgICAgaWYgKHYgPCBhKSBhID0gdjtcbiAgICAgIGlmICh2ID4gYikgYiA9IHY7XG4gICAgfVxuICB9XG4gIHJldHVybiBbYSwgYl07XG59O1xuXG4vLyBGaW5kIHRoZSBpbnRlZ2VyIGluZGljZXMgb2YgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVzLlxuc3RhdHMuZXh0ZW50LmluZGV4ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciB4ID0gLTEsIHkgPSAtMSwgYSwgYiwgdiwgaSwgbiA9IHZhbHVlcy5sZW5ndGg7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHsgYSA9IGIgPSB2OyB4ID0geSA9IGk7IGJyZWFrOyB9XG4gIH1cbiAgZm9yICg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkge1xuICAgICAgaWYgKHYgPCBhKSB7IGEgPSB2OyB4ID0gaTsgfVxuICAgICAgaWYgKHYgPiBiKSB7IGIgPSB2OyB5ID0gaTsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gW3gsIHldO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuc3RhdHMuZG90ID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciBzdW0gPSAwLCBpLCB2O1xuICBpZiAoIWIpIHtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCAhPT0gYS5sZW5ndGgpIHtcbiAgICAgIHRocm93IEVycm9yKCdBcnJheSBsZW5ndGhzIG11c3QgbWF0Y2guJyk7XG4gICAgfVxuICAgIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdiA9IHZhbHVlc1tpXSAqIGFbaV07XG4gICAgICBpZiAodiA9PT0gdikgc3VtICs9IHY7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGEgPSB1dGlsLiQoYSk7XG4gICAgYiA9IHV0aWwuJChiKTtcbiAgICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHYgPSBhKHZhbHVlc1tpXSkgKiBiKHZhbHVlc1tpXSk7XG4gICAgICBpZiAodiA9PT0gdikgc3VtICs9IHY7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdW07XG59O1xuXG4vLyBDb21wdXRlIGFzY2VuZGluZyByYW5rIHNjb3JlcyBmb3IgYW4gYXJyYXkgb2YgdmFsdWVzLlxuLy8gVGllcyBhcmUgYXNzaWduZWQgdGhlaXIgY29sbGVjdGl2ZSBtZWFuIHJhbmsuXG5zdGF0cy5yYW5rID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZikgfHwgdXRpbC5pZGVudGl0eTtcbiAgdmFyIGEgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uKHYsIGkpIHtcbiAgICAgIHJldHVybiB7aWR4OiBpLCB2YWw6IGYodil9O1xuICAgIH0pXG4gICAgLnNvcnQodXRpbC5jb21wYXJhdG9yKCd2YWwnKSk7XG5cbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgciA9IEFycmF5KG4pLFxuICAgICAgdGllID0gLTEsIHAgPSB7fSwgaSwgdiwgbXU7XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgdiA9IGFbaV0udmFsO1xuICAgIGlmICh0aWUgPCAwICYmIHAgPT09IHYpIHtcbiAgICAgIHRpZSA9IGkgLSAxO1xuICAgIH0gZWxzZSBpZiAodGllID4gLTEgJiYgcCAhPT0gdikge1xuICAgICAgbXUgPSAxICsgKGktMSArIHRpZSkgLyAyO1xuICAgICAgZm9yICg7IHRpZTxpOyArK3RpZSkgclthW3RpZV0uaWR4XSA9IG11O1xuICAgICAgdGllID0gLTE7XG4gICAgfVxuICAgIHJbYVtpXS5pZHhdID0gaSArIDE7XG4gICAgcCA9IHY7XG4gIH1cblxuICBpZiAodGllID4gLTEpIHtcbiAgICBtdSA9IDEgKyAobi0xICsgdGllKSAvIDI7XG4gICAgZm9yICg7IHRpZTxuOyArK3RpZSkgclthW3RpZV0uaWR4XSA9IG11O1xuICB9XG5cbiAgcmV0dXJuIHI7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBzYW1wbGUgUGVhcnNvbiBwcm9kdWN0LW1vbWVudCBjb3JyZWxhdGlvbiBvZiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXG5zdGF0cy5jb3IgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIGZuID0gYjtcbiAgYiA9IGZuID8gdmFsdWVzLm1hcCh1dGlsLiQoYikpIDogYTtcbiAgYSA9IGZuID8gdmFsdWVzLm1hcCh1dGlsLiQoYSkpIDogdmFsdWVzO1xuXG4gIHZhciBkb3QgPSBzdGF0cy5kb3QoYSwgYiksXG4gICAgICBtdWEgPSBzdGF0cy5tZWFuKGEpLFxuICAgICAgbXViID0gc3RhdHMubWVhbihiKSxcbiAgICAgIHNkYSA9IHN0YXRzLnN0ZGV2KGEpLFxuICAgICAgc2RiID0gc3RhdHMuc3RkZXYoYiksXG4gICAgICBuID0gdmFsdWVzLmxlbmd0aDtcblxuICByZXR1cm4gKGRvdCAtIG4qbXVhKm11YikgLyAoKG4tMSkgKiBzZGEgKiBzZGIpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgU3BlYXJtYW4gcmFuayBjb3JyZWxhdGlvbiBvZiB0d28gYXJyYXlzIG9mIHZhbHVlcy5cbnN0YXRzLmNvci5yYW5rID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciByYSA9IGIgPyBzdGF0cy5yYW5rKHZhbHVlcywgdXRpbC4kKGEpKSA6IHN0YXRzLnJhbmsodmFsdWVzKSxcbiAgICAgIHJiID0gYiA/IHN0YXRzLnJhbmsodmFsdWVzLCB1dGlsLiQoYikpIDogc3RhdHMucmFuayhhKSxcbiAgICAgIG4gPSB2YWx1ZXMubGVuZ3RoLCBpLCBzLCBkO1xuXG4gIGZvciAoaT0wLCBzPTA7IGk8bjsgKytpKSB7XG4gICAgZCA9IHJhW2ldIC0gcmJbaV07XG4gICAgcyArPSBkICogZDtcbiAgfVxuXG4gIHJldHVybiAxIC0gNipzIC8gKG4gKiAobipuLTEpKTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIGRpc3RhbmNlIGNvcnJlbGF0aW9uIG9mIHR3byBhcnJheXMgb2YgbnVtYmVycy5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlzdGFuY2VfY29ycmVsYXRpb25cbnN0YXRzLmNvci5kaXN0ID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciBYID0gYiA/IHZhbHVlcy5tYXAodXRpbC4kKGEpKSA6IHZhbHVlcyxcbiAgICAgIFkgPSBiID8gdmFsdWVzLm1hcCh1dGlsLiQoYikpIDogYTtcblxuICB2YXIgQSA9IHN0YXRzLmRpc3QubWF0KFgpLFxuICAgICAgQiA9IHN0YXRzLmRpc3QubWF0KFkpLFxuICAgICAgbiA9IEEubGVuZ3RoLFxuICAgICAgaSwgYWEsIGJiLCBhYjtcblxuICBmb3IgKGk9MCwgYWE9MCwgYmI9MCwgYWI9MDsgaTxuOyArK2kpIHtcbiAgICBhYSArPSBBW2ldKkFbaV07XG4gICAgYmIgKz0gQltpXSpCW2ldO1xuICAgIGFiICs9IEFbaV0qQltpXTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLnNxcnQoYWIgLyBNYXRoLnNxcnQoYWEqYmIpKTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHZlY3RvciBkaXN0YW5jZSBiZXR3ZWVuIHR3byBhcnJheXMgb2YgbnVtYmVycy5cbi8vIERlZmF1bHQgaXMgRXVjbGlkZWFuIChleHA9MikgZGlzdGFuY2UsIGNvbmZpZ3VyYWJsZSB2aWEgZXhwIGFyZ3VtZW50Llxuc3RhdHMuZGlzdCA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYiwgZXhwKSB7XG4gIHZhciBmID0gdXRpbC5pc0Z1bmN0aW9uKGIpIHx8IHV0aWwuaXNTdHJpbmcoYiksXG4gICAgICBYID0gdmFsdWVzLFxuICAgICAgWSA9IGYgPyB2YWx1ZXMgOiBhLFxuICAgICAgZSA9IGYgPyBleHAgOiBiLFxuICAgICAgTDIgPSBlID09PSAyIHx8IGUgPT0gbnVsbCxcbiAgICAgIG4gPSB2YWx1ZXMubGVuZ3RoLCBzID0gMCwgZCwgaTtcbiAgaWYgKGYpIHtcbiAgICBhID0gdXRpbC4kKGEpO1xuICAgIGIgPSB1dGlsLiQoYik7XG4gIH1cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgZCA9IGYgPyAoYShYW2ldKS1iKFlbaV0pKSA6IChYW2ldLVlbaV0pO1xuICAgIHMgKz0gTDIgPyBkKmQgOiBNYXRoLnBvdyhNYXRoLmFicyhkKSwgZSk7XG4gIH1cbiAgcmV0dXJuIEwyID8gTWF0aC5zcXJ0KHMpIDogTWF0aC5wb3cocywgMS9lKTtcbn07XG5cbi8vIENvbnN0cnVjdCBhIG1lYW4tY2VudGVyZWQgZGlzdGFuY2UgbWF0cml4IGZvciBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMuZGlzdC5tYXQgPSBmdW5jdGlvbihYKSB7XG4gIHZhciBuID0gWC5sZW5ndGgsXG4gICAgICBtID0gbipuLFxuICAgICAgQSA9IEFycmF5KG0pLFxuICAgICAgUiA9IGdlbi56ZXJvcyhuKSxcbiAgICAgIE0gPSAwLCB2LCBpLCBqO1xuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIEFbaSpuK2ldID0gMDtcbiAgICBmb3IgKGo9aSsxOyBqPG47ICsraikge1xuICAgICAgQVtpKm4ral0gPSAodiA9IE1hdGguYWJzKFhbaV0gLSBYW2pdKSk7XG4gICAgICBBW2oqbitpXSA9IHY7XG4gICAgICBSW2ldICs9IHY7XG4gICAgICBSW2pdICs9IHY7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgTSArPSBSW2ldO1xuICAgIFJbaV0gLz0gbjtcbiAgfVxuICBNIC89IG07XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgZm9yIChqPWk7IGo8bjsgKytqKSB7XG4gICAgICBBW2kqbitqXSArPSBNIC0gUltpXSAtIFJbal07XG4gICAgICBBW2oqbitpXSA9IEFbaSpuK2pdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBBO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgU2hhbm5vbiBlbnRyb3B5IChsb2cgYmFzZSAyKSBvZiBhbiBhcnJheSBvZiBjb3VudHMuXG5zdGF0cy5lbnRyb3B5ID0gZnVuY3Rpb24oY291bnRzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBpLCBwLCBzID0gMCwgSCA9IDAsIG4gPSBjb3VudHMubGVuZ3RoO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBzICs9IChmID8gZihjb3VudHNbaV0pIDogY291bnRzW2ldKTtcbiAgfVxuICBpZiAocyA9PT0gMCkgcmV0dXJuIDA7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHAgPSAoZiA/IGYoY291bnRzW2ldKSA6IGNvdW50c1tpXSkgLyBzO1xuICAgIGlmIChwKSBIICs9IHAgKiBNYXRoLmxvZyhwKTtcbiAgfVxuICByZXR1cm4gLUggLyBNYXRoLkxOMjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIG11dHVhbCBpbmZvcm1hdGlvbiBiZXR3ZWVuIHR3byBkaXNjcmV0ZSB2YXJpYWJsZXMuXG4vLyBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBmb3JtIFtNSSwgTUlfZGlzdGFuY2VdIFxuLy8gTUlfZGlzdGFuY2UgaXMgZGVmaW5lZCBhcyAxIC0gSShhLGIpIC8gSChhLGIpLlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NdXR1YWxfaW5mb3JtYXRpb25cbnN0YXRzLm11dHVhbCA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYiwgY291bnRzKSB7XG4gIHZhciB4ID0gY291bnRzID8gdmFsdWVzLm1hcCh1dGlsLiQoYSkpIDogdmFsdWVzLFxuICAgICAgeSA9IGNvdW50cyA/IHZhbHVlcy5tYXAodXRpbC4kKGIpKSA6IGEsXG4gICAgICB6ID0gY291bnRzID8gdmFsdWVzLm1hcCh1dGlsLiQoY291bnRzKSkgOiBiO1xuXG4gIHZhciBweCA9IHt9LFxuICAgICAgcHkgPSB7fSxcbiAgICAgIG4gPSB6Lmxlbmd0aCxcbiAgICAgIHMgPSAwLCBJID0gMCwgSCA9IDAsIHAsIHQsIGk7XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgcHhbeFtpXV0gPSAwO1xuICAgIHB5W3lbaV1dID0gMDtcbiAgfVxuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHB4W3hbaV1dICs9IHpbaV07XG4gICAgcHlbeVtpXV0gKz0geltpXTtcbiAgICBzICs9IHpbaV07XG4gIH1cblxuICB0ID0gMSAvIChzICogTWF0aC5MTjIpO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBpZiAoeltpXSA9PT0gMCkgY29udGludWU7XG4gICAgcCA9IChzICogeltpXSkgLyAocHhbeFtpXV0gKiBweVt5W2ldXSk7XG4gICAgSSArPSB6W2ldICogdCAqIE1hdGgubG9nKHApO1xuICAgIEggKz0geltpXSAqIHQgKiBNYXRoLmxvZyh6W2ldL3MpO1xuICB9XG5cbiAgcmV0dXJuIFtJLCAxICsgSS9IXTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIG11dHVhbCBpbmZvcm1hdGlvbiBiZXR3ZWVuIHR3byBkaXNjcmV0ZSB2YXJpYWJsZXMuXG5zdGF0cy5tdXR1YWwuaW5mbyA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYiwgY291bnRzKSB7XG4gIHJldHVybiBzdGF0cy5tdXR1YWwodmFsdWVzLCBhLCBiLCBjb3VudHMpWzBdO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbXV0dWFsIGluZm9ybWF0aW9uIGRpc3RhbmNlIGJldHdlZW4gdHdvIGRpc2NyZXRlIHZhcmlhYmxlcy5cbi8vIE1JX2Rpc3RhbmNlIGlzIGRlZmluZWQgYXMgMSAtIEkoYSxiKSAvIEgoYSxiKS5cbnN0YXRzLm11dHVhbC5kaXN0ID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBjb3VudHMpIHtcbiAgcmV0dXJuIHN0YXRzLm11dHVhbCh2YWx1ZXMsIGEsIGIsIGNvdW50cylbMV07XG59O1xuXG4vLyBDb21wdXRlIGEgcHJvZmlsZSBvZiBzdW1tYXJ5IHN0YXRpc3RpY3MgZm9yIGEgdmFyaWFibGUuXG5zdGF0cy5wcm9maWxlID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHZhciBtZWFuID0gMCxcbiAgICAgIHZhbGlkID0gMCxcbiAgICAgIG1pc3NpbmcgPSAwLFxuICAgICAgZGlzdGluY3QgPSAwLFxuICAgICAgbWluID0gbnVsbCxcbiAgICAgIG1heCA9IG51bGwsXG4gICAgICBNMiA9IDAsXG4gICAgICB2YWxzID0gW10sXG4gICAgICB1ID0ge30sIGRlbHRhLCBzZCwgaSwgdiwgeDtcblxuICAvLyBjb21wdXRlIHN1bW1hcnkgc3RhdHNcbiAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG5cbiAgICAvLyB1cGRhdGUgdW5pcXVlIHZhbHVlc1xuICAgIHVbdl0gPSAodiBpbiB1KSA/IHVbdl0gKyAxIDogKGRpc3RpbmN0ICs9IDEsIDEpO1xuXG4gICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgKyttaXNzaW5nO1xuICAgIH0gZWxzZSBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICAvLyB1cGRhdGUgc3RhdHNcbiAgICAgIHggPSAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSA/IHYubGVuZ3RoIDogdjtcbiAgICAgIGlmIChtaW49PT1udWxsIHx8IHggPCBtaW4pIG1pbiA9IHg7XG4gICAgICBpZiAobWF4PT09bnVsbCB8fCB4ID4gbWF4KSBtYXggPSB4O1xuICAgICAgZGVsdGEgPSB4IC0gbWVhbjtcbiAgICAgIG1lYW4gPSBtZWFuICsgZGVsdGEgLyAoKyt2YWxpZCk7XG4gICAgICBNMiA9IE0yICsgZGVsdGEgKiAoeCAtIG1lYW4pO1xuICAgICAgdmFscy5wdXNoKHgpO1xuICAgIH1cbiAgfVxuICBNMiA9IE0yIC8gKHZhbGlkIC0gMSk7XG4gIHNkID0gTWF0aC5zcXJ0KE0yKTtcblxuICAvLyBzb3J0IHZhbHVlcyBmb3IgbWVkaWFuIGFuZCBpcXJcbiAgdmFscy5zb3J0KHV0aWwuY21wKTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6ICAgICB0eXBlKHZhbHVlcywgZiksXG4gICAgdW5pcXVlOiAgIHUsXG4gICAgY291bnQ6ICAgIHZhbHVlcy5sZW5ndGgsXG4gICAgdmFsaWQ6ICAgIHZhbGlkLFxuICAgIG1pc3Npbmc6ICBtaXNzaW5nLFxuICAgIGRpc3RpbmN0OiBkaXN0aW5jdCxcbiAgICBtaW46ICAgICAgbWluLFxuICAgIG1heDogICAgICBtYXgsXG4gICAgbWVhbjogICAgIG1lYW4sXG4gICAgc3RkZXY6ICAgIHNkLFxuICAgIG1lZGlhbjogICAodiA9IHN0YXRzLnF1YW50aWxlKHZhbHMsIDAuNSkpLFxuICAgIHExOiAgICAgICBzdGF0cy5xdWFudGlsZSh2YWxzLCAwLjI1KSxcbiAgICBxMzogICAgICAgc3RhdHMucXVhbnRpbGUodmFscywgMC43NSksXG4gICAgbW9kZXNrZXc6IHNkID09PSAwID8gMCA6IChtZWFuIC0gdikgLyBzZFxuICB9O1xufTtcblxuLy8gQ29tcHV0ZSBwcm9maWxlcyBmb3IgYWxsIHZhcmlhYmxlcyBpbiBhIGRhdGEgc2V0Llxuc3RhdHMuc3VtbWFyeSA9IGZ1bmN0aW9uKGRhdGEsIGZpZWxkcykge1xuICBmaWVsZHMgPSBmaWVsZHMgfHwgdXRpbC5rZXlzKGRhdGFbMF0pO1xuICB2YXIgcyA9IGZpZWxkcy5tYXAoZnVuY3Rpb24oZikge1xuICAgIHZhciBwID0gc3RhdHMucHJvZmlsZShkYXRhLCB1dGlsLiQoZikpO1xuICAgIHJldHVybiAocC5maWVsZCA9IGYsIHApO1xuICB9KTtcbiAgcmV0dXJuIChzLl9fc3VtbWFyeV9fID0gdHJ1ZSwgcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YXRzOyIsInZhciBkM190aW1lID0gcmVxdWlyZSgnZDMtdGltZScpO1xuXG52YXIgdGVtcERhdGUgPSBuZXcgRGF0ZSgpLFxuICAgIGJhc2VEYXRlID0gbmV3IERhdGUoMCwgMCwgMSkuc2V0RnVsbFllYXIoMCksIC8vIEphbiAxLCAwIEFEXG4gICAgdXRjQmFzZURhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQygwLCAwLCAxKSkuc2V0VVRDRnVsbFllYXIoMCk7XG5cbmZ1bmN0aW9uIGRhdGUoZCkge1xuICByZXR1cm4gKHRlbXBEYXRlLnNldFRpbWUoK2QpLCB0ZW1wRGF0ZSk7XG59XG5cbi8vIGNyZWF0ZSBhIHRpbWUgdW5pdCBlbnRyeVxuZnVuY3Rpb24gZW50cnkodHlwZSwgZGF0ZSwgdW5pdCwgc3RlcCwgbWluLCBtYXgpIHtcbiAgdmFyIGUgPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBkYXRlOiBkYXRlLFxuICAgIHVuaXQ6IHVuaXRcbiAgfTtcbiAgaWYgKHN0ZXApIHtcbiAgICBlLnN0ZXAgPSBzdGVwO1xuICB9IGVsc2Uge1xuICAgIGUubWluc3RlcCA9IDE7XG4gIH1cbiAgaWYgKG1pbiAhPSBudWxsKSBlLm1pbiA9IG1pbjtcbiAgaWYgKG1heCAhPSBudWxsKSBlLm1heCA9IG1heDtcbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZSh0eXBlLCB1bml0LCBiYXNlLCBzdGVwLCBtaW4sIG1heCkge1xuICByZXR1cm4gZW50cnkodHlwZSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiB1bml0Lm9mZnNldChiYXNlLCBkKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiB1bml0LmNvdW50KGJhc2UsIGQpOyB9LFxuICAgIHN0ZXAsIG1pbiwgbWF4KTtcbn1cblxudmFyIGxvY2FsZSA9IFtcbiAgY3JlYXRlKCdzZWNvbmQnLCBkM190aW1lLnNlY29uZCwgYmFzZURhdGUpLFxuICBjcmVhdGUoJ21pbnV0ZScsIGQzX3RpbWUubWludXRlLCBiYXNlRGF0ZSksXG4gIGNyZWF0ZSgnaG91cicsICAgZDNfdGltZS5ob3VyLCAgIGJhc2VEYXRlKSxcbiAgY3JlYXRlKCdkYXknLCAgICBkM190aW1lLmRheSwgICAgYmFzZURhdGUsIFsxLCA3XSksXG4gIGNyZWF0ZSgnbW9udGgnLCAgZDNfdGltZS5tb250aCwgIGJhc2VEYXRlLCBbMSwgMywgNl0pLFxuICBjcmVhdGUoJ3llYXInLCAgIGQzX3RpbWUueWVhciwgICBiYXNlRGF0ZSksXG5cbiAgLy8gcGVyaW9kaWMgdW5pdHNcbiAgZW50cnkoJ3NlY29uZHMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKDE5NzAsIDAsIDEsIDAsIDAsIGQpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0U2Vjb25kcygpOyB9LFxuICAgIG51bGwsIDAsIDU5XG4gICksXG4gIGVudHJ5KCdtaW51dGVzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZSgxOTcwLCAwLCAxLCAwLCBkKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldE1pbnV0ZXMoKTsgfSxcbiAgICBudWxsLCAwLCA1OVxuICApLFxuICBlbnRyeSgnaG91cnMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKDE5NzAsIDAsIDEsIGQpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0SG91cnMoKTsgfSxcbiAgICBudWxsLCAwLCAyM1xuICApLFxuICBlbnRyeSgnd2Vla2RheXMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKDE5NzAsIDAsIDQrZCk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXREYXkoKTsgfSxcbiAgICBbMV0sIDAsIDZcbiAgKSxcbiAgZW50cnkoJ2RhdGVzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZSgxOTcwLCAwLCBkKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldERhdGUoKTsgfSxcbiAgICBbMV0sIDEsIDMxXG4gICksXG4gIGVudHJ5KCdtb250aHMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKDE5NzAsIGQgJSAxMiwgMSk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXRNb250aCgpOyB9LFxuICAgIFsxXSwgMCwgMTFcbiAgKVxuXTtcblxudmFyIHV0YyA9IFtcbiAgY3JlYXRlKCdzZWNvbmQnLCBkM190aW1lLnV0Y1NlY29uZCwgdXRjQmFzZURhdGUpLFxuICBjcmVhdGUoJ21pbnV0ZScsIGQzX3RpbWUudXRjTWludXRlLCB1dGNCYXNlRGF0ZSksXG4gIGNyZWF0ZSgnaG91cicsICAgZDNfdGltZS51dGNIb3VyLCAgIHV0Y0Jhc2VEYXRlKSxcbiAgY3JlYXRlKCdkYXknLCAgICBkM190aW1lLnV0Y0RheSwgICAgdXRjQmFzZURhdGUsIFsxLCA3XSksXG4gIGNyZWF0ZSgnbW9udGgnLCAgZDNfdGltZS51dGNNb250aCwgIHV0Y0Jhc2VEYXRlLCBbMSwgMywgNl0pLFxuICBjcmVhdGUoJ3llYXInLCAgIGQzX3RpbWUudXRjWWVhciwgICB1dGNCYXNlRGF0ZSksXG5cbiAgLy8gcGVyaW9kaWMgdW5pdHNcbiAgZW50cnkoJ3NlY29uZHMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIDEsIDAsIDAsIGQpKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldFVUQ1NlY29uZHMoKTsgfSxcbiAgICBudWxsLCAwLCA1OVxuICApLFxuICBlbnRyeSgnbWludXRlcycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgMSwgMCwgZCkpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0VVRDTWludXRlcygpOyB9LFxuICAgIG51bGwsIDAsIDU5XG4gICksXG4gIGVudHJ5KCdob3VycycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgMSwgZCkpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0VVRDSG91cnMoKTsgfSxcbiAgICBudWxsLCAwLCAyM1xuICApLFxuICBlbnRyeSgnd2Vla2RheXMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIDQrZCkpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0VVRDRGF5KCk7IH0sXG4gICAgWzFdLCAwLCA2XG4gICksXG4gIGVudHJ5KCdkYXRlcycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgZCkpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0VVRDRGF0ZSgpOyB9LFxuICAgIFsxXSwgMSwgMzFcbiAgKSxcbiAgZW50cnkoJ21vbnRocycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgZCAlIDEyLCAxKSk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXRVVENNb250aCgpOyB9LFxuICAgIFsxXSwgMCwgMTFcbiAgKVxuXTtcblxudmFyIFNURVBTID0gW1xuICBbMzE1MzZlNiwgNV0sICAvLyAxLXllYXJcbiAgWzc3NzZlNiwgNF0sICAgLy8gMy1tb250aFxuICBbMjU5MmU2LCA0XSwgICAvLyAxLW1vbnRoXG4gIFsxMjA5NmU1LCAzXSwgIC8vIDItd2Vla1xuICBbNjA0OGU1LCAzXSwgICAvLyAxLXdlZWtcbiAgWzE3MjhlNSwgM10sICAgLy8gMi1kYXlcbiAgWzg2NGU1LCAzXSwgICAgLy8gMS1kYXlcbiAgWzQzMmU1LCAyXSwgICAgLy8gMTItaG91clxuICBbMjE2ZTUsIDJdLCAgICAvLyA2LWhvdXJcbiAgWzEwOGU1LCAyXSwgICAgLy8gMy1ob3VyXG4gIFszNmU1LCAyXSwgICAgIC8vIDEtaG91clxuICBbMThlNSwgMV0sICAgICAvLyAzMC1taW51dGVcbiAgWzllNSwgMV0sICAgICAgLy8gMTUtbWludXRlXG4gIFszZTUsIDFdLCAgICAgIC8vIDUtbWludXRlXG4gIFs2ZTQsIDFdLCAgICAgIC8vIDEtbWludXRlXG4gIFszZTQsIDBdLCAgICAgIC8vIDMwLXNlY29uZFxuICBbMTVlMywgMF0sICAgICAvLyAxNS1zZWNvbmRcbiAgWzVlMywgMF0sICAgICAgLy8gNS1zZWNvbmRcbiAgWzFlMywgMF0gICAgICAgLy8gMS1zZWNvbmRcbl07XG5cbmZ1bmN0aW9uIGZpbmQodW5pdHMsIHNwYW4sIG1pbmIsIG1heGIpIHtcbiAgdmFyIHN0ZXAgPSBTVEVQU1swXSwgaSwgbiwgYmlucztcblxuICBmb3IgKGk9MSwgbj1TVEVQUy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgc3RlcCA9IFNURVBTW2ldO1xuICAgIGlmIChzcGFuID4gc3RlcFswXSkge1xuICAgICAgYmlucyA9IHNwYW4gLyBzdGVwWzBdO1xuICAgICAgaWYgKGJpbnMgPiBtYXhiKSB7XG4gICAgICAgIHJldHVybiB1bml0c1tTVEVQU1tpLTFdWzFdXTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5zID49IG1pbmIpIHtcbiAgICAgICAgcmV0dXJuIHVuaXRzW3N0ZXBbMV1dO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdW5pdHNbU1RFUFNbbi0xXVsxXV07XG59XG5cbmZ1bmN0aW9uIHRvVW5pdE1hcCh1bml0cykge1xuICB2YXIgbWFwID0ge30sIGksIG47XG4gIGZvciAoaT0wLCBuPXVuaXRzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBtYXBbdW5pdHNbaV0udHlwZV0gPSB1bml0c1tpXTtcbiAgfVxuICBtYXAuZmluZCA9IGZ1bmN0aW9uKHNwYW4sIG1pbmIsIG1heGIpIHtcbiAgICByZXR1cm4gZmluZCh1bml0cywgc3BhbiwgbWluYiwgbWF4Yik7XG4gIH07XG4gIHJldHVybiBtYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Vbml0TWFwKGxvY2FsZSk7XG5tb2R1bGUuZXhwb3J0cy51dGMgPSB0b1VuaXRNYXAodXRjKTtcbiIsInZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKSxcbiAgICB0aW1lID0gcmVxdWlyZSgnLi90aW1lJyksXG4gICAgdXRjID0gdGltZS51dGM7XG5cbnZhciB1ID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gdXRpbGl0eSBmdW5jdGlvbnNcblxudmFyIEZOQU1FID0gJ19fbmFtZV9fJztcblxudS5uYW1lZGZ1bmMgPSBmdW5jdGlvbihuYW1lLCBmKSB7IHJldHVybiAoZltGTkFNRV0gPSBuYW1lLCBmKTsgfTtcblxudS5uYW1lID0gZnVuY3Rpb24oZikgeyByZXR1cm4gZj09bnVsbCA/IG51bGwgOiBmW0ZOQU1FXTsgfTtcblxudS5pZGVudGl0eSA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg7IH07XG5cbnUudHJ1ZSA9IHUubmFtZWRmdW5jKCd0cnVlJywgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9KTtcblxudS5mYWxzZSA9IHUubmFtZWRmdW5jKCdmYWxzZScsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH0pO1xuXG51LmR1cGxpY2F0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn07XG5cbnUuZXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShhKSA9PT0gSlNPTi5zdHJpbmdpZnkoYik7XG59O1xuXG51LmV4dGVuZCA9IGZ1bmN0aW9uKG9iaikge1xuICBmb3IgKHZhciB4LCBuYW1lLCBpPTEsIGxlbj1hcmd1bWVudHMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgeCA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKG5hbWUgaW4geCkgeyBvYmpbbmFtZV0gPSB4W25hbWVdOyB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG5cbnUubGVuZ3RoID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCAhPSBudWxsICYmIHgubGVuZ3RoICE9IG51bGwgPyB4Lmxlbmd0aCA6IG51bGw7XG59O1xuXG51LmtleXMgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBrZXlzID0gW10sIGs7XG4gIGZvciAoayBpbiB4KSBrZXlzLnB1c2goayk7XG4gIHJldHVybiBrZXlzO1xufTtcblxudS52YWxzID0gZnVuY3Rpb24oeCkge1xuICB2YXIgdmFscyA9IFtdLCBrO1xuICBmb3IgKGsgaW4geCkgdmFscy5wdXNoKHhba10pO1xuICByZXR1cm4gdmFscztcbn07XG5cbnUudG9NYXAgPSBmdW5jdGlvbihsaXN0LCBmKSB7XG4gIHJldHVybiAoZiA9IHUuJChmKSkgP1xuICAgIGxpc3QucmVkdWNlKGZ1bmN0aW9uKG9iaiwgeCkgeyByZXR1cm4gKG9ialtmKHgpXSA9IDEsIG9iaik7IH0sIHt9KSA6XG4gICAgbGlzdC5yZWR1Y2UoZnVuY3Rpb24ob2JqLCB4KSB7IHJldHVybiAob2JqW3hdID0gMSwgb2JqKTsgfSwge30pO1xufTtcblxudS5rZXlzdHIgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgLy8gdXNlIHRvIGVuc3VyZSBjb25zaXN0ZW50IGtleSBnZW5lcmF0aW9uIGFjcm9zcyBtb2R1bGVzXG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgaWYgKCFuKSByZXR1cm4gJyc7XG4gIGZvciAodmFyIHM9U3RyaW5nKHZhbHVlc1swXSksIGk9MTsgaTxuOyArK2kpIHtcbiAgICBzICs9ICd8JyArIFN0cmluZyh2YWx1ZXNbaV0pO1xuICB9XG4gIHJldHVybiBzO1xufTtcblxuLy8gdHlwZSBjaGVja2luZyBmdW5jdGlvbnNcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxudS5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbn07XG5cbnUuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudS5pc1N0cmluZyA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcblxudS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnUuaXNOdW1iZXIgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdudW1iZXInIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59O1xuXG51LmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEJvb2xlYW5dJztcbn07XG5cbnUuaXNEYXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJztcbn07XG5cbnUuaXNWYWxpZCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmo7XG59O1xuXG51LmlzQnVmZmVyID0gKGJ1ZmZlci5CdWZmZXIgJiYgYnVmZmVyLkJ1ZmZlci5pc0J1ZmZlcikgfHwgdS5mYWxzZTtcblxuLy8gdHlwZSBjb2VyY2lvbiBmdW5jdGlvbnNcblxudS5udW1iZXIgPSBmdW5jdGlvbihzKSB7XG4gIHJldHVybiBzID09IG51bGwgfHwgcyA9PT0gJycgPyBudWxsIDogK3M7XG59O1xuXG51LmJvb2xlYW4gPSBmdW5jdGlvbihzKSB7XG4gIHJldHVybiBzID09IG51bGwgfHwgcyA9PT0gJycgPyBudWxsIDogcz09PSdmYWxzZScgPyBmYWxzZSA6ICEhcztcbn07XG5cbnUuZGF0ZSA9IGZ1bmN0aW9uKHMpIHtcbiAgcmV0dXJuIHMgPT0gbnVsbCB8fCBzID09PSAnJyA/IG51bGwgOiBEYXRlLnBhcnNlKHMpO1xufTtcblxudS5hcnJheSA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggIT0gbnVsbCA/ICh1LmlzQXJyYXkoeCkgPyB4IDogW3hdKSA6IFtdO1xufTtcblxudS5zdHIgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB1LmlzQXJyYXkoeCkgPyAnWycgKyB4Lm1hcCh1LnN0cikgKyAnXSdcbiAgICA6IHUuaXNPYmplY3QoeCkgPyBKU09OLnN0cmluZ2lmeSh4KVxuICAgIDogdS5pc1N0cmluZyh4KSA/ICgnXFwnJyt1dGlsX2VzY2FwZV9zdHIoeCkrJ1xcJycpIDogeDtcbn07XG5cbnZhciBlc2NhcGVfc3RyX3JlID0gLyhefFteXFxcXF0pJy9nO1xuXG5mdW5jdGlvbiB1dGlsX2VzY2FwZV9zdHIoeCkge1xuICByZXR1cm4geC5yZXBsYWNlKGVzY2FwZV9zdHJfcmUsICckMVxcXFxcXCcnKTtcbn1cblxuLy8gZGF0YSBhY2Nlc3MgZnVuY3Rpb25zXG5cbnUuZmllbGQgPSBmdW5jdGlvbihmKSB7XG4gIHJldHVybiBTdHJpbmcoZikuc3BsaXQoJ1xcXFwuJylcbiAgICAubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuc3BsaXQoJy4nKTsgfSlcbiAgICAucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGlmIChhLmxlbmd0aCkgeyBhW2EubGVuZ3RoLTFdICs9ICcuJyArIGIuc2hpZnQoKTsgfVxuICAgICAgYS5wdXNoLmFwcGx5KGEsIGIpO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfSwgW10pO1xufTtcblxudS5hY2Nlc3NvciA9IGZ1bmN0aW9uKGYpIHtcbiAgdmFyIHM7XG4gIHJldHVybiBmPT1udWxsIHx8IHUuaXNGdW5jdGlvbihmKSA/IGYgOlxuICAgIHUubmFtZWRmdW5jKGYsIChzID0gdS5maWVsZChmKSkubGVuZ3RoID4gMSA/XG4gICAgICBmdW5jdGlvbih4KSB7IHJldHVybiBzLnJlZHVjZShmdW5jdGlvbih4LGYpIHsgcmV0dXJuIHhbZl07IH0sIHgpOyB9IDpcbiAgICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHhbZl07IH1cbiAgICApO1xufTtcblxuLy8gc2hvcnQtY3V0IGZvciBhY2Nlc3NvclxudS4kID0gdS5hY2Nlc3NvcjtcblxudS5tdXRhdG9yID0gZnVuY3Rpb24oZikge1xuICB2YXIgcztcbiAgcmV0dXJuIHUuaXNTdHJpbmcoZikgJiYgKHM9dS5maWVsZChmKSkubGVuZ3RoID4gMSA/XG4gICAgZnVuY3Rpb24oeCwgdikge1xuICAgICAgZm9yICh2YXIgaT0wOyBpPHMubGVuZ3RoLTE7ICsraSkgeCA9IHhbc1tpXV07XG4gICAgICB4W3NbaV1dID0gdjtcbiAgICB9IDpcbiAgICBmdW5jdGlvbih4LCB2KSB7IHhbZl0gPSB2OyB9O1xufTtcblxuXG51LiRmdW5jID0gZnVuY3Rpb24obmFtZSwgb3ApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGYpIHtcbiAgICBmID0gdS4kKGYpIHx8IHUuaWRlbnRpdHk7XG4gICAgdmFyIG4gPSBuYW1lICsgKHUubmFtZShmKSA/ICdfJyt1Lm5hbWUoZikgOiAnJyk7XG4gICAgcmV0dXJuIHUubmFtZWRmdW5jKG4sIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG9wKGYoZCkpOyB9KTtcbiAgfTtcbn07XG5cbnUuJHZhbGlkICA9IHUuJGZ1bmMoJ3ZhbGlkJywgdS5pc1ZhbGlkKTtcbnUuJGxlbmd0aCA9IHUuJGZ1bmMoJ2xlbmd0aCcsIHUubGVuZ3RoKTtcblxudS4kaW4gPSBmdW5jdGlvbihmLCB2YWx1ZXMpIHtcbiAgZiA9IHUuJChmKTtcbiAgdmFyIG1hcCA9IHUuaXNBcnJheSh2YWx1ZXMpID8gdS50b01hcCh2YWx1ZXMpIDogdmFsdWVzO1xuICByZXR1cm4gZnVuY3Rpb24oZCkgeyByZXR1cm4gISFtYXBbZihkKV07IH07XG59O1xuXG51LiR5ZWFyICAgPSB1LiRmdW5jKCd5ZWFyJywgdGltZS55ZWFyLnVuaXQpO1xudS4kbW9udGggID0gdS4kZnVuYygnbW9udGgnLCB0aW1lLm1vbnRocy51bml0KTtcbnUuJGRhdGUgICA9IHUuJGZ1bmMoJ2RhdGUnLCB0aW1lLmRhdGVzLnVuaXQpO1xudS4kZGF5ICAgID0gdS4kZnVuYygnZGF5JywgdGltZS53ZWVrZGF5cy51bml0KTtcbnUuJGhvdXIgICA9IHUuJGZ1bmMoJ2hvdXInLCB0aW1lLmhvdXJzLnVuaXQpO1xudS4kbWludXRlID0gdS4kZnVuYygnbWludXRlJywgdGltZS5taW51dGVzLnVuaXQpO1xudS4kc2Vjb25kID0gdS4kZnVuYygnc2Vjb25kJywgdGltZS5zZWNvbmRzLnVuaXQpO1xuXG51LiR1dGNZZWFyICAgPSB1LiRmdW5jKCd1dGNZZWFyJywgdXRjLnllYXIudW5pdCk7XG51LiR1dGNNb250aCAgPSB1LiRmdW5jKCd1dGNNb250aCcsIHV0Yy5tb250aHMudW5pdCk7XG51LiR1dGNEYXRlICAgPSB1LiRmdW5jKCd1dGNEYXRlJywgdXRjLmRhdGVzLnVuaXQpO1xudS4kdXRjRGF5ICAgID0gdS4kZnVuYygndXRjRGF5JywgdXRjLndlZWtkYXlzLnVuaXQpO1xudS4kdXRjSG91ciAgID0gdS4kZnVuYygndXRjSG91cicsIHV0Yy5ob3Vycy51bml0KTtcbnUuJHV0Y01pbnV0ZSA9IHUuJGZ1bmMoJ3V0Y01pbnV0ZScsIHV0Yy5taW51dGVzLnVuaXQpO1xudS4kdXRjU2Vjb25kID0gdS4kZnVuYygndXRjU2Vjb25kJywgdXRjLnNlY29uZHMudW5pdCk7XG5cbi8vIGNvbXBhcmlzb24gLyBzb3J0aW5nIGZ1bmN0aW9uc1xuXG51LmNvbXBhcmF0b3IgPSBmdW5jdGlvbihzb3J0KSB7XG4gIHZhciBzaWduID0gW107XG4gIGlmIChzb3J0ID09PSB1bmRlZmluZWQpIHNvcnQgPSBbXTtcbiAgc29ydCA9IHUuYXJyYXkoc29ydCkubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICB2YXIgcyA9IDE7XG4gICAgaWYgICAgICAoZlswXSA9PT0gJy0nKSB7IHMgPSAtMTsgZiA9IGYuc2xpY2UoMSk7IH1cbiAgICBlbHNlIGlmIChmWzBdID09PSAnKycpIHsgcyA9ICsxOyBmID0gZi5zbGljZSgxKTsgfVxuICAgIHNpZ24ucHVzaChzKTtcbiAgICByZXR1cm4gdS5hY2Nlc3NvcihmKTtcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbihhLGIpIHtcbiAgICB2YXIgaSwgbiwgZiwgeCwgeTtcbiAgICBmb3IgKGk9MCwgbj1zb3J0Lmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGYgPSBzb3J0W2ldOyB4ID0gZihhKTsgeSA9IGYoYik7XG4gICAgICBpZiAoeCA8IHkpIHJldHVybiAtMSAqIHNpZ25baV07XG4gICAgICBpZiAoeCA+IHkpIHJldHVybiBzaWduW2ldO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbn07XG5cbnUuY21wID0gZnVuY3Rpb24oYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChhID49IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChhID09PSBudWxsKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gTmFOO1xufTtcblxudS5udW1jbXAgPSBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfTtcblxudS5zdGFibGVzb3J0ID0gZnVuY3Rpb24oYXJyYXksIHNvcnRCeSwga2V5Rm4pIHtcbiAgdmFyIGluZGljZXMgPSBhcnJheS5yZWR1Y2UoZnVuY3Rpb24oaWR4LCB2LCBpKSB7XG4gICAgcmV0dXJuIChpZHhba2V5Rm4odildID0gaSwgaWR4KTtcbiAgfSwge30pO1xuXG4gIGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBzYSA9IHNvcnRCeShhKSxcbiAgICAgICAgc2IgPSBzb3J0QnkoYik7XG4gICAgcmV0dXJuIHNhIDwgc2IgPyAtMSA6IHNhID4gc2IgPyAxXG4gICAgICAgICA6IChpbmRpY2VzW2tleUZuKGEpXSAtIGluZGljZXNba2V5Rm4oYildKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuXG4vLyBzdHJpbmcgZnVuY3Rpb25zXG5cbnUucGFkID0gZnVuY3Rpb24ocywgbGVuZ3RoLCBwb3MsIHBhZGNoYXIpIHtcbiAgcGFkY2hhciA9IHBhZGNoYXIgfHwgXCIgXCI7XG4gIHZhciBkID0gbGVuZ3RoIC0gcy5sZW5ndGg7XG4gIGlmIChkIDw9IDApIHJldHVybiBzO1xuICBzd2l0Y2ggKHBvcykge1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgcmV0dXJuIHN0cnJlcChkLCBwYWRjaGFyKSArIHM7XG4gICAgY2FzZSAnbWlkZGxlJzpcbiAgICBjYXNlICdjZW50ZXInOlxuICAgICAgcmV0dXJuIHN0cnJlcChNYXRoLmZsb29yKGQvMiksIHBhZGNoYXIpICtcbiAgICAgICAgIHMgKyBzdHJyZXAoTWF0aC5jZWlsKGQvMiksIHBhZGNoYXIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcyArIHN0cnJlcChkLCBwYWRjaGFyKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gc3RycmVwKG4sIHN0cikge1xuICB2YXIgcyA9IFwiXCIsIGk7XG4gIGZvciAoaT0wOyBpPG47ICsraSkgcyArPSBzdHI7XG4gIHJldHVybiBzO1xufVxuXG51LnRydW5jYXRlID0gZnVuY3Rpb24ocywgbGVuZ3RoLCBwb3MsIHdvcmQsIGVsbGlwc2lzKSB7XG4gIHZhciBsZW4gPSBzLmxlbmd0aDtcbiAgaWYgKGxlbiA8PSBsZW5ndGgpIHJldHVybiBzO1xuICBlbGxpcHNpcyA9IGVsbGlwc2lzICE9PSB1bmRlZmluZWQgPyBTdHJpbmcoZWxsaXBzaXMpIDogJ1xcdTIwMjYnO1xuICB2YXIgbCA9IE1hdGgubWF4KDAsIGxlbmd0aCAtIGVsbGlwc2lzLmxlbmd0aCk7XG5cbiAgc3dpdGNoIChwb3MpIHtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHJldHVybiBlbGxpcHNpcyArICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsLDEpIDogcy5zbGljZShsZW4tbCkpO1xuICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIHZhciBsMSA9IE1hdGguY2VpbChsLzIpLCBsMiA9IE1hdGguZmxvb3IobC8yKTtcbiAgICAgIHJldHVybiAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbDEpIDogcy5zbGljZSgwLGwxKSkgK1xuICAgICAgICBlbGxpcHNpcyArICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsMiwxKSA6IHMuc2xpY2UobGVuLWwyKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbCkgOiBzLnNsaWNlKDAsbCkpICsgZWxsaXBzaXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHRydW5jYXRlT25Xb3JkKHMsIGxlbiwgcmV2KSB7XG4gIHZhciBjbnQgPSAwLCB0b2sgPSBzLnNwbGl0KHRydW5jYXRlX3dvcmRfcmUpO1xuICBpZiAocmV2KSB7XG4gICAgcyA9ICh0b2sgPSB0b2sucmV2ZXJzZSgpKVxuICAgICAgLmZpbHRlcihmdW5jdGlvbih3KSB7IGNudCArPSB3Lmxlbmd0aDsgcmV0dXJuIGNudCA8PSBsZW47IH0pXG4gICAgICAucmV2ZXJzZSgpO1xuICB9IGVsc2Uge1xuICAgIHMgPSB0b2suZmlsdGVyKGZ1bmN0aW9uKHcpIHsgY250ICs9IHcubGVuZ3RoOyByZXR1cm4gY250IDw9IGxlbjsgfSk7XG4gIH1cbiAgcmV0dXJuIHMubGVuZ3RoID8gcy5qb2luKCcnKS50cmltKCkgOiB0b2tbMF0uc2xpY2UoMCwgbGVuKTtcbn1cblxudmFyIHRydW5jYXRlX3dvcmRfcmUgPSAvKFtcXHUwMDA5XFx1MDAwQVxcdTAwMEJcXHUwMDBDXFx1MDAwRFxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MjAyOFxcdTIwMjlcXHUzMDAwXFx1RkVGRl0pLztcbiJdfQ==\n","// This product includes color specifications and designs developed by Cynthia Brewer (http://colorbrewer.org/).\n// JavaScript specs as packaged in the D3 library (d3js.org). Please see license at http://colorbrewer.org/export/LICENSE.txt\n!function() {\n\nvar colorbrewer = {YlGn: {\n3: [\"#f7fcb9\",\"#addd8e\",\"#31a354\"],\n4: [\"#ffffcc\",\"#c2e699\",\"#78c679\",\"#238443\"],\n5: [\"#ffffcc\",\"#c2e699\",\"#78c679\",\"#31a354\",\"#006837\"],\n6: [\"#ffffcc\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#31a354\",\"#006837\"],\n7: [\"#ffffcc\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#005a32\"],\n8: [\"#ffffe5\",\"#f7fcb9\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#005a32\"],\n9: [\"#ffffe5\",\"#f7fcb9\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#006837\",\"#004529\"]\n},YlGnBu: {\n3: [\"#edf8b1\",\"#7fcdbb\",\"#2c7fb8\"],\n4: [\"#ffffcc\",\"#a1dab4\",\"#41b6c4\",\"#225ea8\"],\n5: [\"#ffffcc\",\"#a1dab4\",\"#41b6c4\",\"#2c7fb8\",\"#253494\"],\n6: [\"#ffffcc\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#2c7fb8\",\"#253494\"],\n7: [\"#ffffcc\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#0c2c84\"],\n8: [\"#ffffd9\",\"#edf8b1\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#0c2c84\"],\n9: [\"#ffffd9\",\"#edf8b1\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#253494\",\"#081d58\"]\n},GnBu: {\n3: [\"#e0f3db\",\"#a8ddb5\",\"#43a2ca\"],\n4: [\"#f0f9e8\",\"#bae4bc\",\"#7bccc4\",\"#2b8cbe\"],\n5: [\"#f0f9e8\",\"#bae4bc\",\"#7bccc4\",\"#43a2ca\",\"#0868ac\"],\n6: [\"#f0f9e8\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#43a2ca\",\"#0868ac\"],\n7: [\"#f0f9e8\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#08589e\"],\n8: [\"#f7fcf0\",\"#e0f3db\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#08589e\"],\n9: [\"#f7fcf0\",\"#e0f3db\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#0868ac\",\"#084081\"]\n},BuGn: {\n3: [\"#e5f5f9\",\"#99d8c9\",\"#2ca25f\"],\n4: [\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#238b45\"],\n5: [\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\"],\n6: [\"#edf8fb\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\"],\n7: [\"#edf8fb\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#005824\"],\n8: [\"#f7fcfd\",\"#e5f5f9\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#005824\"],\n9: [\"#f7fcfd\",\"#e5f5f9\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#006d2c\",\"#00441b\"]\n},PuBuGn: {\n3: [\"#ece2f0\",\"#a6bddb\",\"#1c9099\"],\n4: [\"#f6eff7\",\"#bdc9e1\",\"#67a9cf\",\"#02818a\"],\n5: [\"#f6eff7\",\"#bdc9e1\",\"#67a9cf\",\"#1c9099\",\"#016c59\"],\n6: [\"#f6eff7\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#1c9099\",\"#016c59\"],\n7: [\"#f6eff7\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016450\"],\n8: [\"#fff7fb\",\"#ece2f0\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016450\"],\n9: [\"#fff7fb\",\"#ece2f0\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016c59\",\"#014636\"]\n},PuBu: {\n3: [\"#ece7f2\",\"#a6bddb\",\"#2b8cbe\"],\n4: [\"#f1eef6\",\"#bdc9e1\",\"#74a9cf\",\"#0570b0\"],\n5: [\"#f1eef6\",\"#bdc9e1\",\"#74a9cf\",\"#2b8cbe\",\"#045a8d\"],\n6: [\"#f1eef6\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#2b8cbe\",\"#045a8d\"],\n7: [\"#f1eef6\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#034e7b\"],\n8: [\"#fff7fb\",\"#ece7f2\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#034e7b\"],\n9: [\"#fff7fb\",\"#ece7f2\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#045a8d\",\"#023858\"]\n},BuPu: {\n3: [\"#e0ecf4\",\"#9ebcda\",\"#8856a7\"],\n4: [\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#88419d\"],\n5: [\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#8856a7\",\"#810f7c\"],\n6: [\"#edf8fb\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8856a7\",\"#810f7c\"],\n7: [\"#edf8fb\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#6e016b\"],\n8: [\"#f7fcfd\",\"#e0ecf4\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#6e016b\"],\n9: [\"#f7fcfd\",\"#e0ecf4\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#810f7c\",\"#4d004b\"]\n},RdPu: {\n3: [\"#fde0dd\",\"#fa9fb5\",\"#c51b8a\"],\n4: [\"#feebe2\",\"#fbb4b9\",\"#f768a1\",\"#ae017e\"],\n5: [\"#feebe2\",\"#fbb4b9\",\"#f768a1\",\"#c51b8a\",\"#7a0177\"],\n6: [\"#feebe2\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#c51b8a\",\"#7a0177\"],\n7: [\"#feebe2\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\"],\n8: [\"#fff7f3\",\"#fde0dd\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\"],\n9: [\"#fff7f3\",\"#fde0dd\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\",\"#49006a\"]\n},PuRd: {\n3: [\"#e7e1ef\",\"#c994c7\",\"#dd1c77\"],\n4: [\"#f1eef6\",\"#d7b5d8\",\"#df65b0\",\"#ce1256\"],\n5: [\"#f1eef6\",\"#d7b5d8\",\"#df65b0\",\"#dd1c77\",\"#980043\"],\n6: [\"#f1eef6\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#dd1c77\",\"#980043\"],\n7: [\"#f1eef6\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#91003f\"],\n8: [\"#f7f4f9\",\"#e7e1ef\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#91003f\"],\n9: [\"#f7f4f9\",\"#e7e1ef\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#980043\",\"#67001f\"]\n},OrRd: {\n3: [\"#fee8c8\",\"#fdbb84\",\"#e34a33\"],\n4: [\"#fef0d9\",\"#fdcc8a\",\"#fc8d59\",\"#d7301f\"],\n5: [\"#fef0d9\",\"#fdcc8a\",\"#fc8d59\",\"#e34a33\",\"#b30000\"],\n6: [\"#fef0d9\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#e34a33\",\"#b30000\"],\n7: [\"#fef0d9\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#990000\"],\n8: [\"#fff7ec\",\"#fee8c8\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#990000\"],\n9: [\"#fff7ec\",\"#fee8c8\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#b30000\",\"#7f0000\"]\n},YlOrRd: {\n3: [\"#ffeda0\",\"#feb24c\",\"#f03b20\"],\n4: [\"#ffffb2\",\"#fecc5c\",\"#fd8d3c\",\"#e31a1c\"],\n5: [\"#ffffb2\",\"#fecc5c\",\"#fd8d3c\",\"#f03b20\",\"#bd0026\"],\n6: [\"#ffffb2\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#f03b20\",\"#bd0026\"],\n7: [\"#ffffb2\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#b10026\"],\n8: [\"#ffffcc\",\"#ffeda0\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#b10026\"],\n9: [\"#ffffcc\",\"#ffeda0\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#bd0026\",\"#800026\"]\n},YlOrBr: {\n3: [\"#fff7bc\",\"#fec44f\",\"#d95f0e\"],\n4: [\"#ffffd4\",\"#fed98e\",\"#fe9929\",\"#cc4c02\"],\n5: [\"#ffffd4\",\"#fed98e\",\"#fe9929\",\"#d95f0e\",\"#993404\"],\n6: [\"#ffffd4\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#d95f0e\",\"#993404\"],\n7: [\"#ffffd4\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#8c2d04\"],\n8: [\"#ffffe5\",\"#fff7bc\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#8c2d04\"],\n9: [\"#ffffe5\",\"#fff7bc\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#993404\",\"#662506\"]\n},Purples: {\n3: [\"#efedf5\",\"#bcbddc\",\"#756bb1\"],\n4: [\"#f2f0f7\",\"#cbc9e2\",\"#9e9ac8\",\"#6a51a3\"],\n5: [\"#f2f0f7\",\"#cbc9e2\",\"#9e9ac8\",\"#756bb1\",\"#54278f\"],\n6: [\"#f2f0f7\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#756bb1\",\"#54278f\"],\n7: [\"#f2f0f7\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#4a1486\"],\n8: [\"#fcfbfd\",\"#efedf5\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#4a1486\"],\n9: [\"#fcfbfd\",\"#efedf5\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#54278f\",\"#3f007d\"]\n},Blues: {\n3: [\"#deebf7\",\"#9ecae1\",\"#3182bd\"],\n4: [\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#2171b5\"],\n5: [\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#3182bd\",\"#08519c\"],\n6: [\"#eff3ff\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#3182bd\",\"#08519c\"],\n7: [\"#eff3ff\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#084594\"],\n8: [\"#f7fbff\",\"#deebf7\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#084594\"],\n9: [\"#f7fbff\",\"#deebf7\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#08519c\",\"#08306b\"]\n},Greens: {\n3: [\"#e5f5e0\",\"#a1d99b\",\"#31a354\"],\n4: [\"#edf8e9\",\"#bae4b3\",\"#74c476\",\"#238b45\"],\n5: [\"#edf8e9\",\"#bae4b3\",\"#74c476\",\"#31a354\",\"#006d2c\"],\n6: [\"#edf8e9\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#31a354\",\"#006d2c\"],\n7: [\"#edf8e9\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#005a32\"],\n8: [\"#f7fcf5\",\"#e5f5e0\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#005a32\"],\n9: [\"#f7fcf5\",\"#e5f5e0\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#006d2c\",\"#00441b\"]\n},Oranges: {\n3: [\"#fee6ce\",\"#fdae6b\",\"#e6550d\"],\n4: [\"#feedde\",\"#fdbe85\",\"#fd8d3c\",\"#d94701\"],\n5: [\"#feedde\",\"#fdbe85\",\"#fd8d3c\",\"#e6550d\",\"#a63603\"],\n6: [\"#feedde\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#e6550d\",\"#a63603\"],\n7: [\"#feedde\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#8c2d04\"],\n8: [\"#fff5eb\",\"#fee6ce\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#8c2d04\"],\n9: [\"#fff5eb\",\"#fee6ce\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#a63603\",\"#7f2704\"]\n},Reds: {\n3: [\"#fee0d2\",\"#fc9272\",\"#de2d26\"],\n4: [\"#fee5d9\",\"#fcae91\",\"#fb6a4a\",\"#cb181d\"],\n5: [\"#fee5d9\",\"#fcae91\",\"#fb6a4a\",\"#de2d26\",\"#a50f15\"],\n6: [\"#fee5d9\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#de2d26\",\"#a50f15\"],\n7: [\"#fee5d9\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#99000d\"],\n8: [\"#fff5f0\",\"#fee0d2\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#99000d\"],\n9: [\"#fff5f0\",\"#fee0d2\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#a50f15\",\"#67000d\"]\n},Greys: {\n3: [\"#f0f0f0\",\"#bdbdbd\",\"#636363\"],\n4: [\"#f7f7f7\",\"#cccccc\",\"#969696\",\"#525252\"],\n5: [\"#f7f7f7\",\"#cccccc\",\"#969696\",\"#636363\",\"#252525\"],\n6: [\"#f7f7f7\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#636363\",\"#252525\"],\n7: [\"#f7f7f7\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\"],\n8: [\"#ffffff\",\"#f0f0f0\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\"],\n9: [\"#ffffff\",\"#f0f0f0\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\",\"#000000\"]\n},PuOr: {\n3: [\"#f1a340\",\"#f7f7f7\",\"#998ec3\"],\n4: [\"#e66101\",\"#fdb863\",\"#b2abd2\",\"#5e3c99\"],\n5: [\"#e66101\",\"#fdb863\",\"#f7f7f7\",\"#b2abd2\",\"#5e3c99\"],\n6: [\"#b35806\",\"#f1a340\",\"#fee0b6\",\"#d8daeb\",\"#998ec3\",\"#542788\"],\n7: [\"#b35806\",\"#f1a340\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#998ec3\",\"#542788\"],\n8: [\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\"],\n9: [\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\"],\n10: [\"#7f3b08\",\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\",\"#2d004b\"],\n11: [\"#7f3b08\",\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\",\"#2d004b\"]\n},BrBG: {\n3: [\"#d8b365\",\"#f5f5f5\",\"#5ab4ac\"],\n4: [\"#a6611a\",\"#dfc27d\",\"#80cdc1\",\"#018571\"],\n5: [\"#a6611a\",\"#dfc27d\",\"#f5f5f5\",\"#80cdc1\",\"#018571\"],\n6: [\"#8c510a\",\"#d8b365\",\"#f6e8c3\",\"#c7eae5\",\"#5ab4ac\",\"#01665e\"],\n7: [\"#8c510a\",\"#d8b365\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#5ab4ac\",\"#01665e\"],\n8: [\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\"],\n9: [\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\"],\n10: [\"#543005\",\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\",\"#003c30\"],\n11: [\"#543005\",\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\",\"#003c30\"]\n},PRGn: {\n3: [\"#af8dc3\",\"#f7f7f7\",\"#7fbf7b\"],\n4: [\"#7b3294\",\"#c2a5cf\",\"#a6dba0\",\"#008837\"],\n5: [\"#7b3294\",\"#c2a5cf\",\"#f7f7f7\",\"#a6dba0\",\"#008837\"],\n6: [\"#762a83\",\"#af8dc3\",\"#e7d4e8\",\"#d9f0d3\",\"#7fbf7b\",\"#1b7837\"],\n7: [\"#762a83\",\"#af8dc3\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#7fbf7b\",\"#1b7837\"],\n8: [\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\"],\n9: [\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\"],\n10: [\"#40004b\",\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\",\"#00441b\"],\n11: [\"#40004b\",\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\",\"#00441b\"]\n},PiYG: {\n3: [\"#e9a3c9\",\"#f7f7f7\",\"#a1d76a\"],\n4: [\"#d01c8b\",\"#f1b6da\",\"#b8e186\",\"#4dac26\"],\n5: [\"#d01c8b\",\"#f1b6da\",\"#f7f7f7\",\"#b8e186\",\"#4dac26\"],\n6: [\"#c51b7d\",\"#e9a3c9\",\"#fde0ef\",\"#e6f5d0\",\"#a1d76a\",\"#4d9221\"],\n7: [\"#c51b7d\",\"#e9a3c9\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#a1d76a\",\"#4d9221\"],\n8: [\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\"],\n9: [\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\"],\n10: [\"#8e0152\",\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\",\"#276419\"],\n11: [\"#8e0152\",\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\",\"#276419\"]\n},RdBu: {\n3: [\"#ef8a62\",\"#f7f7f7\",\"#67a9cf\"],\n4: [\"#ca0020\",\"#f4a582\",\"#92c5de\",\"#0571b0\"],\n5: [\"#ca0020\",\"#f4a582\",\"#f7f7f7\",\"#92c5de\",\"#0571b0\"],\n6: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#d1e5f0\",\"#67a9cf\",\"#2166ac\"],\n7: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#67a9cf\",\"#2166ac\"],\n8: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\"],\n9: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\"],\n10: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\",\"#053061\"],\n11: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\",\"#053061\"]\n},RdGy: {\n3: [\"#ef8a62\",\"#ffffff\",\"#999999\"],\n4: [\"#ca0020\",\"#f4a582\",\"#bababa\",\"#404040\"],\n5: [\"#ca0020\",\"#f4a582\",\"#ffffff\",\"#bababa\",\"#404040\"],\n6: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#e0e0e0\",\"#999999\",\"#4d4d4d\"],\n7: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#999999\",\"#4d4d4d\"],\n8: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\"],\n9: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\"],\n10: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\",\"#1a1a1a\"],\n11: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\",\"#1a1a1a\"]\n},RdYlBu: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#91bfdb\"],\n4: [\"#d7191c\",\"#fdae61\",\"#abd9e9\",\"#2c7bb6\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#abd9e9\",\"#2c7bb6\"],\n6: [\"#d73027\",\"#fc8d59\",\"#fee090\",\"#e0f3f8\",\"#91bfdb\",\"#4575b4\"],\n7: [\"#d73027\",\"#fc8d59\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#91bfdb\",\"#4575b4\"],\n8: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\"],\n9: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\"],\n10: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\",\"#313695\"],\n11: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\",\"#313695\"]\n},Spectral: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#99d594\"],\n4: [\"#d7191c\",\"#fdae61\",\"#abdda4\",\"#2b83ba\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#abdda4\",\"#2b83ba\"],\n6: [\"#d53e4f\",\"#fc8d59\",\"#fee08b\",\"#e6f598\",\"#99d594\",\"#3288bd\"],\n7: [\"#d53e4f\",\"#fc8d59\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#99d594\",\"#3288bd\"],\n8: [\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\"],\n9: [\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\"],\n10: [\"#9e0142\",\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\",\"#5e4fa2\"],\n11: [\"#9e0142\",\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\",\"#5e4fa2\"]\n},RdYlGn: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#91cf60\"],\n4: [\"#d7191c\",\"#fdae61\",\"#a6d96a\",\"#1a9641\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#a6d96a\",\"#1a9641\"],\n6: [\"#d73027\",\"#fc8d59\",\"#fee08b\",\"#d9ef8b\",\"#91cf60\",\"#1a9850\"],\n7: [\"#d73027\",\"#fc8d59\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#91cf60\",\"#1a9850\"],\n8: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\"],\n9: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\"],\n10: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\",\"#006837\"],\n11: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\",\"#006837\"]\n},Accent: {\n3: [\"#7fc97f\",\"#beaed4\",\"#fdc086\"],\n4: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\"],\n5: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\"],\n6: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\"],\n7: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\",\"#bf5b17\"],\n8: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\",\"#bf5b17\",\"#666666\"]\n},Dark2: {\n3: [\"#1b9e77\",\"#d95f02\",\"#7570b3\"],\n4: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\"],\n5: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\"],\n6: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\"],\n7: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\",\"#a6761d\"],\n8: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\",\"#a6761d\",\"#666666\"]\n},Paired: {\n3: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\"],\n4: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\"],\n5: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\"],\n6: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\"],\n7: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\"],\n8: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\"],\n9: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\"],\n10: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\"],\n11: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\",\"#ffff99\"],\n12: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\",\"#ffff99\",\"#b15928\"]\n},Pastel1: {\n3: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\"],\n4: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\"],\n5: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\"],\n6: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\"],\n7: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\"],\n8: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\"#fddaec\"],\n9: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\"#fddaec\",\"#f2f2f2\"]\n},Pastel2: {\n3: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\"],\n4: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\"],\n5: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\"],\n6: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\"],\n7: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\",\"#f1e2cc\"],\n8: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\",\"#f1e2cc\",\"#cccccc\"]\n},Set1: {\n3: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\"],\n4: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\"],\n5: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\"],\n6: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\"],\n7: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\"],\n8: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\",\"#f781bf\"],\n9: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\",\"#f781bf\",\"#999999\"]\n},Set2: {\n3: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\"],\n4: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\"],\n5: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\"],\n6: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\"],\n7: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\",\"#e5c494\"],\n8: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\",\"#e5c494\",\"#b3b3b3\"]\n},Set3: {\n3: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\"],\n4: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\"],\n5: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\"],\n6: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\"],\n7: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\"],\n8: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\"],\n9: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\"],\n10: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\"],\n11: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\",\"#ccebc5\"],\n12: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\",\"#ccebc5\",\"#ffed6f\"]\n}};\n\nif (typeof define === \"function\" && define.amd) {\n    define(colorbrewer);\n} else if (typeof module === \"object\" && module.exports) {\n    module.exports = colorbrewer;\n} else {\n    this.colorbrewer = colorbrewer;\n}\n\n}();\n","module.exports = require('./colorbrewer.js');\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.color = {}));\n}(this, function (exports) { 'use strict';\n\n  function deltaHue(h1, h0) {\n    var delta = h1 - h0;\n    return delta > 180 || delta < -180\n        ? delta - 360 * Math.round(delta / 360)\n        : delta;\n  }\n\n  function Color() {}var reHex3 = /^#([0-9a-f]{3})$/;\n  var reHex6 = /^#([0-9a-f]{6})$/;\n  var reRgbInteger = /^rgb\\(\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*\\)$/;\n  var reRgbPercent = /^rgb\\(\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n  var reHslPercent = /^hsl\\(\\s*([-+]?\\d+(?:\\.\\d+)?)\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n  color.prototype = Color.prototype = {\n    displayable: function() {\n      return this.rgb().displayable();\n    },\n    toString: function() {\n      return this.rgb() + \"\";\n    }\n  };\n\n  function color(format) {\n    var m;\n    format = (format + \"\").trim().toLowerCase();\n    return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf))) // #f00\n        : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000\n        : (m = reRgbInteger.exec(format)) ? rgb(m[1], m[2], m[3]) // rgb(255,0,0)\n        : (m = reRgbPercent.exec(format)) ? rgb(m[1] * 2.55, m[2] * 2.55, m[3] * 2.55) // rgb(100%,0%,0%)\n        : (m = reHslPercent.exec(format)) ? hsl(m[1], m[2] * .01, m[3] * .01) // hsl(120,50%,50%)\n        : named.hasOwnProperty(format) ? rgbn(named[format])\n        : null;\n  }function rgbn(n) {\n    return rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff);\n  }\n\n  var named = {\n    aliceblue: 0xf0f8ff,\n    antiquewhite: 0xfaebd7,\n    aqua: 0x00ffff,\n    aquamarine: 0x7fffd4,\n    azure: 0xf0ffff,\n    beige: 0xf5f5dc,\n    bisque: 0xffe4c4,\n    black: 0x000000,\n    blanchedalmond: 0xffebcd,\n    blue: 0x0000ff,\n    blueviolet: 0x8a2be2,\n    brown: 0xa52a2a,\n    burlywood: 0xdeb887,\n    cadetblue: 0x5f9ea0,\n    chartreuse: 0x7fff00,\n    chocolate: 0xd2691e,\n    coral: 0xff7f50,\n    cornflowerblue: 0x6495ed,\n    cornsilk: 0xfff8dc,\n    crimson: 0xdc143c,\n    cyan: 0x00ffff,\n    darkblue: 0x00008b,\n    darkcyan: 0x008b8b,\n    darkgoldenrod: 0xb8860b,\n    darkgray: 0xa9a9a9,\n    darkgreen: 0x006400,\n    darkgrey: 0xa9a9a9,\n    darkkhaki: 0xbdb76b,\n    darkmagenta: 0x8b008b,\n    darkolivegreen: 0x556b2f,\n    darkorange: 0xff8c00,\n    darkorchid: 0x9932cc,\n    darkred: 0x8b0000,\n    darksalmon: 0xe9967a,\n    darkseagreen: 0x8fbc8f,\n    darkslateblue: 0x483d8b,\n    darkslategray: 0x2f4f4f,\n    darkslategrey: 0x2f4f4f,\n    darkturquoise: 0x00ced1,\n    darkviolet: 0x9400d3,\n    deeppink: 0xff1493,\n    deepskyblue: 0x00bfff,\n    dimgray: 0x696969,\n    dimgrey: 0x696969,\n    dodgerblue: 0x1e90ff,\n    firebrick: 0xb22222,\n    floralwhite: 0xfffaf0,\n    forestgreen: 0x228b22,\n    fuchsia: 0xff00ff,\n    gainsboro: 0xdcdcdc,\n    ghostwhite: 0xf8f8ff,\n    gold: 0xffd700,\n    goldenrod: 0xdaa520,\n    gray: 0x808080,\n    green: 0x008000,\n    greenyellow: 0xadff2f,\n    grey: 0x808080,\n    honeydew: 0xf0fff0,\n    hotpink: 0xff69b4,\n    indianred: 0xcd5c5c,\n    indigo: 0x4b0082,\n    ivory: 0xfffff0,\n    khaki: 0xf0e68c,\n    lavender: 0xe6e6fa,\n    lavenderblush: 0xfff0f5,\n    lawngreen: 0x7cfc00,\n    lemonchiffon: 0xfffacd,\n    lightblue: 0xadd8e6,\n    lightcoral: 0xf08080,\n    lightcyan: 0xe0ffff,\n    lightgoldenrodyellow: 0xfafad2,\n    lightgray: 0xd3d3d3,\n    lightgreen: 0x90ee90,\n    lightgrey: 0xd3d3d3,\n    lightpink: 0xffb6c1,\n    lightsalmon: 0xffa07a,\n    lightseagreen: 0x20b2aa,\n    lightskyblue: 0x87cefa,\n    lightslategray: 0x778899,\n    lightslategrey: 0x778899,\n    lightsteelblue: 0xb0c4de,\n    lightyellow: 0xffffe0,\n    lime: 0x00ff00,\n    limegreen: 0x32cd32,\n    linen: 0xfaf0e6,\n    magenta: 0xff00ff,\n    maroon: 0x800000,\n    mediumaquamarine: 0x66cdaa,\n    mediumblue: 0x0000cd,\n    mediumorchid: 0xba55d3,\n    mediumpurple: 0x9370db,\n    mediumseagreen: 0x3cb371,\n    mediumslateblue: 0x7b68ee,\n    mediumspringgreen: 0x00fa9a,\n    mediumturquoise: 0x48d1cc,\n    mediumvioletred: 0xc71585,\n    midnightblue: 0x191970,\n    mintcream: 0xf5fffa,\n    mistyrose: 0xffe4e1,\n    moccasin: 0xffe4b5,\n    navajowhite: 0xffdead,\n    navy: 0x000080,\n    oldlace: 0xfdf5e6,\n    olive: 0x808000,\n    olivedrab: 0x6b8e23,\n    orange: 0xffa500,\n    orangered: 0xff4500,\n    orchid: 0xda70d6,\n    palegoldenrod: 0xeee8aa,\n    palegreen: 0x98fb98,\n    paleturquoise: 0xafeeee,\n    palevioletred: 0xdb7093,\n    papayawhip: 0xffefd5,\n    peachpuff: 0xffdab9,\n    peru: 0xcd853f,\n    pink: 0xffc0cb,\n    plum: 0xdda0dd,\n    powderblue: 0xb0e0e6,\n    purple: 0x800080,\n    rebeccapurple: 0x663399,\n    red: 0xff0000,\n    rosybrown: 0xbc8f8f,\n    royalblue: 0x4169e1,\n    saddlebrown: 0x8b4513,\n    salmon: 0xfa8072,\n    sandybrown: 0xf4a460,\n    seagreen: 0x2e8b57,\n    seashell: 0xfff5ee,\n    sienna: 0xa0522d,\n    silver: 0xc0c0c0,\n    skyblue: 0x87ceeb,\n    slateblue: 0x6a5acd,\n    slategray: 0x708090,\n    slategrey: 0x708090,\n    snow: 0xfffafa,\n    springgreen: 0x00ff7f,\n    steelblue: 0x4682b4,\n    tan: 0xd2b48c,\n    teal: 0x008080,\n    thistle: 0xd8bfd8,\n    tomato: 0xff6347,\n    turquoise: 0x40e0d0,\n    violet: 0xee82ee,\n    wheat: 0xf5deb3,\n    white: 0xffffff,\n    whitesmoke: 0xf5f5f5,\n    yellow: 0xffff00,\n    yellowgreen: 0x9acd32\n  };\n\n  var darker = .7;\n  var brighter = 1 / darker;\n\n  function rgb(r, g, b) {\n    if (arguments.length === 1) {\n      if (!(r instanceof Color)) r = color(r);\n      if (r) {\n        r = r.rgb();\n        b = r.b;\n        g = r.g;\n        r = r.r;\n      } else {\n        r = g = b = NaN;\n      }\n    }\n    return new Rgb(r, g, b);\n  }function Rgb(r, g, b) {\n    this.r = +r;\n    this.g = +g;\n    this.b = +b;\n  }var ____prototype = rgb.prototype = Rgb.prototype = new Color;\n\n  ____prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k);\n  };\n\n  ____prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k);\n  };\n\n  ____prototype.rgb = function() {\n    return this;\n  };\n\n  ____prototype.displayable = function() {\n    return (0 <= this.r && this.r <= 255)\n        && (0 <= this.g && this.g <= 255)\n        && (0 <= this.b && this.b <= 255);\n  };\n\n  ____prototype.toString = function() {\n    return _format(this.r, this.g, this.b);\n  };\n\n  function _format(r, g, b) {\n    return \"#\"\n        + (isNaN(r) ? \"00\" : (r = Math.round(r)) < 16 ? \"0\" + Math.max(0, r).toString(16) : Math.min(255, r).toString(16))\n        + (isNaN(g) ? \"00\" : (g = Math.round(g)) < 16 ? \"0\" + Math.max(0, g).toString(16) : Math.min(255, g).toString(16))\n        + (isNaN(b) ? \"00\" : (b = Math.round(b)) < 16 ? \"0\" + Math.max(0, b).toString(16) : Math.min(255, b).toString(16));\n  }\n\n  function hsl(h, s, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Hsl) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n      } else {\n        if (!(h instanceof Color)) h = color(h);\n        if (h) {\n          if (h instanceof Hsl) return h;\n          h = h.rgb();\n          var r = h.r / 255,\n              g = h.g / 255,\n              b = h.b / 255,\n              min = Math.min(r, g, b),\n              max = Math.max(r, g, b),\n              range = max - min;\n          l = (max + min) / 2;\n          if (range) {\n            s = l < .5 ? range / (max + min) : range / (2 - max - min);\n            if (r === max) h = (g - b) / range + (g < b) * 6;\n            else if (g === max) h = (b - r) / range + 2;\n            else h = (r - g) / range + 4;\n            h *= 60;\n          } else {\n            h = NaN;\n            s = l > 0 && l < 1 ? 0 : h;\n          }\n        } else {\n          h = s = l = NaN;\n        }\n      }\n    }\n    return new Hsl(h, s, l);\n  }function Hsl(h, s, l) {\n    this.h = +h;\n    this.s = +s;\n    this.l = +l;\n  }var ___prototype = hsl.prototype = Hsl.prototype = new Color;\n\n  ___prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Hsl(this.h, this.s, this.l * k);\n  };\n\n  ___prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Hsl(this.h, this.s, this.l * k);\n  };\n\n  ___prototype.rgb = function() {\n    var h = this.h % 360 + (this.h < 0) * 360,\n        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,\n        l = this.l,\n        m2 = l + (l < .5 ? l : 1 - l) * s,\n        m1 = 2 * l - m2;\n    return new Rgb(\n      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),\n      hsl2rgb(h, m1, m2),\n      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2)\n    );\n  };\n\n  ___prototype.displayable = function() {\n    return (0 <= this.s && this.s <= 1 || isNaN(this.s))\n        && (0 <= this.l && this.l <= 1);\n  };\n\n  /* From FvD 13.37, CSS Color Module Level 3 */\n  function hsl2rgb(h, m1, m2) {\n    return (h < 60 ? m1 + (m2 - m1) * h / 60\n        : h < 180 ? m2\n        : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60\n        : m1) * 255;\n  }\n\n  var Kn = 18;\n\n  var Xn = 0.950470;\n  var Yn = 1;\n  var Zn = 1.088830;\n  var t0 = 4 / 29;\n  var t1 = 6 / 29;\n  var t2 = 3 * t1 * t1;\n  var t3 = t1 * t1 * t1;\n  function lab(l, a, b) {\n    if (arguments.length === 1) {\n      if (l instanceof Lab) {\n        b = l.b;\n        a = l.a;\n        l = l.l;\n      } else if (l instanceof Hcl) {\n        var h = l.h * deg2rad;\n        b = Math.sin(h) * l.c;\n        a = Math.cos(h) * l.c;\n        l = l.l;\n      } else {\n        if (!(l instanceof Rgb)) l = rgb(l);\n        var r = rgb2xyz(l.r),\n            g = rgb2xyz(l.g),\n            b = rgb2xyz(l.b),\n            x = xyz2lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / Xn),\n            y = xyz2lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / Yn),\n            z = xyz2lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / Zn);\n        b = 200 * (y - z);\n        a = 500 * (x - y);\n        l = 116 * y - 16;\n      }\n    }\n    return new Lab(l, a, b);\n  }function Lab(l, a, b) {\n    this.l = +l;\n    this.a = +a;\n    this.b = +b;\n  }var __prototype = lab.prototype = Lab.prototype = new Color;\n\n  __prototype.brighter = function(k) {\n    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b);\n  };\n\n  __prototype.darker = function(k) {\n    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b);\n  };\n\n  __prototype.rgb = function() {\n    var y = (this.l + 16) / 116,\n        x = isNaN(this.a) ? y : y + this.a / 500,\n        z = isNaN(this.b) ? y : y - this.b / 200;\n    y = Yn * lab2xyz(y);\n    x = Xn * lab2xyz(x);\n    z = Zn * lab2xyz(z);\n    return new Rgb(\n      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB\n      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),\n      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z)\n    );\n  };\n\n  function xyz2lab(t) {\n    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n  }\n\n  function lab2xyz(t) {\n    return t > t1 ? t * t * t : t2 * (t - t0);\n  }\n\n  function xyz2rgb(x) {\n    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n  }\n\n  function rgb2xyz(x) {\n    return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n  }\n\n  var deg2rad = Math.PI / 180;\n  var rad2deg = 180 / Math.PI;\n\n  function hcl(h, c, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Hcl) {\n        l = h.l;\n        c = h.c;\n        h = h.h;\n      } else {\n        if (!(h instanceof Lab)) h = lab(h);\n        l = h.l;\n        c = Math.sqrt(h.a * h.a + h.b * h.b);\n        h = Math.atan2(h.b, h.a) * rad2deg;\n        if (h < 0) h += 360;\n      }\n    }\n    return new Hcl(h, c, l);\n  }function Hcl(h, c, l) {\n    this.h = +h;\n    this.c = +c;\n    this.l = +l;\n  }var _prototype = hcl.prototype = Hcl.prototype = new Color;\n\n  _prototype.brighter = function(k) {\n    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k));\n  };\n\n  _prototype.darker = function(k) {\n    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k));\n  };\n\n  _prototype.rgb = function() {\n    return lab(this).rgb();\n  };\n\n  var A = -0.14861;\n  var B = +1.78277;\n  var C = -0.29227;\n  var D = -0.90649;\n  var E = +1.97294;\n  var ED = E * D;\n  var EB = E * B;\n  var BC_DA = B * C - D * A;\n  function cubehelix(h, s, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Cubehelix) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n      } else {\n        if (!(h instanceof Rgb)) h = rgb(h);\n        var r = h.r / 255, g = h.g / 255, b = h.b / 255;\n        l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB);\n        var bl = b - l, k = (E * (g - l) - C * bl) / D;\n        s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)); // NaN if l=0 or l=1\n        h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;\n        if (h < 0) h += 360;\n      }\n    }\n    return new Cubehelix(h, s, l);\n  }function Cubehelix(h, s, l) {\n    this.h = +h;\n    this.s = +s;\n    this.l = +l;\n  }var prototype = cubehelix.prototype = Cubehelix.prototype = new Color;\n\n  prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Cubehelix(this.h, this.s, this.l * k);\n  };\n\n  prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Cubehelix(this.h, this.s, this.l * k);\n  };\n\n  prototype.rgb = function() {\n    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,\n        l = +this.l,\n        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),\n        cosh = Math.cos(h),\n        sinh = Math.sin(h);\n    return new Rgb(\n      255 * (l + a * (A * cosh + B * sinh)),\n      255 * (l + a * (C * cosh + D * sinh)),\n      255 * (l + a * (E * cosh))\n    );\n  };\n\n  function interpolateCubehelixGamma(gamma) {\n    return function(a, b) {\n      a = cubehelix(a);\n      b = cubehelix(b);\n      var ah = isNaN(a.h) ? b.h : a.h,\n          as = isNaN(a.s) ? b.s : a.s,\n          al = a.l,\n          bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n          bs = isNaN(b.s) ? 0 : b.s - as,\n          bl = b.l - al;\n      return function(t) {\n        a.h = ah + bh * t;\n        a.s = as + bs * t;\n        a.l = al + bl * Math.pow(t, gamma);\n        return a + \"\";\n      };\n    };\n  }\n\n  function interpolateCubehelixGammaLong(gamma) {\n    return function(a, b) {\n      a = cubehelix(a);\n      b = cubehelix(b);\n      var ah = isNaN(a.h) ? b.h : a.h,\n          as = isNaN(a.s) ? b.s : a.s,\n          al = a.l,\n          bh = isNaN(b.h) ? 0 : b.h - ah,\n          bs = isNaN(b.s) ? 0 : b.s - as,\n          bl = b.l - al;\n      return function(t) {\n        a.h = ah + bh * t;\n        a.s = as + bs * t;\n        a.l = al + bl * Math.pow(t, gamma);\n        return a + \"\";\n      };\n    };\n  }\n\n  function interpolateHclLong(a, b) {\n    a = hcl(a);\n    b = hcl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        ac = isNaN(a.c) ? b.c : a.c,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : b.h - ah,\n        bc = isNaN(b.c) ? 0 : b.c - ac,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.c = ac + bc * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHcl(a, b) {\n    a = hcl(a);\n    b = hcl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        ac = isNaN(a.c) ? b.c : a.c,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n        bc = isNaN(b.c) ? 0 : b.c - ac,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.c = ac + bc * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateLab(a, b) {\n    a = lab(a);\n    b = lab(b);\n    var al = a.l,\n        aa = a.a,\n        ab = a.b,\n        bl = b.l - al,\n        ba = b.a - aa,\n        bb = b.b - ab;\n    return function(t) {\n      a.l = al + bl * t;\n      a.a = aa + ba * t;\n      a.b = ab + bb * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHslLong(a, b) {\n    a = hsl(a);\n    b = hsl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : b.h - ah,\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHsl(a, b) {\n    a = hsl(a);\n    b = hsl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateRgb(a, b) {\n    a = rgb(a);\n    b = rgb(b);\n    var ar = a.r,\n        ag = a.g,\n        ab = a.b,\n        br = b.r - ar,\n        bg = b.g - ag,\n        bb = b.b - ab;\n    return function(t) {\n      return _format(Math.round(ar + br * t), Math.round(ag + bg * t), Math.round(ab + bb * t));\n    };\n  }\n\n  var interpolateCubehelix = interpolateCubehelixGamma(1);\n  var interpolateCubehelixLong = interpolateCubehelixGammaLong(1);\n\n  exports.interpolateCubehelix = interpolateCubehelix;\n  exports.interpolateCubehelixLong = interpolateCubehelixLong;\n  exports.color = color;\n  exports.rgb = rgb;\n  exports.hsl = hsl;\n  exports.lab = lab;\n  exports.hcl = hcl;\n  exports.cubehelix = cubehelix;\n  exports.interpolateRgb = interpolateRgb;\n  exports.interpolateHsl = interpolateHsl;\n  exports.interpolateHslLong = interpolateHslLong;\n  exports.interpolateLab = interpolateLab;\n  exports.interpolateHcl = interpolateHcl;\n  exports.interpolateHclLong = interpolateHclLong;\n  exports.interpolateCubehelixGamma = interpolateCubehelixGamma;\n  exports.interpolateCubehelixGammaLong = interpolateCubehelixGammaLong;\n\n}));","if (typeof Map === \"undefined\") {\n  Map = function() { this.clear(); };\n  Map.prototype = {\n    set: function(k, v) { this._[k] = v; return this; },\n    get: function(k) { return this._[k]; },\n    has: function(k) { return k in this._; },\n    delete: function(k) { return k in this._ && delete this._[k]; },\n    clear: function() { this._ = Object.create(null); },\n    get size() { var n = 0; for (var k in this._) ++n; return n; },\n    forEach: function(c) { for (var k in this._) c(this._[k], k, this); }\n  };\n} else (function() {\n  var m = new Map;\n  if (m.set(0, 0) !== m) {\n    m = m.set;\n    Map.prototype.set = function() { m.apply(this, arguments); return this; };\n  }\n})();\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.format = {}));\n}(this, function (exports) { 'use strict';\n\n  var zhCn = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  };\n\n  var ruRu = {\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0.\"]\n  };\n\n  var ptBr = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"R$\", \"\"]\n  };\n\n  var plPl = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"z\"]\n  };\n\n  var nlNl = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\\xa0\", \"\"]\n  };\n\n  var mkMk = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0.\"]\n  };\n\n  var jaJp = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  };\n\n  var itIt = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  };\n\n  var heIl = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  };\n\n  var frFr = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  };\n\n  var frCa = {\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"$\"]\n  };\n\n  var fiFi = {\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  };\n\n  var esEs = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  };\n\n  var enUs = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"$\", \"\"]\n  };\n\n  var enGb = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  };\n\n  var enCa = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"$\", \"\"]\n  };\n\n  var deDe = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  };\n\n  var caEs = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  };\n\n\n  // Computes the decimal coefficient and exponent of the specified number x with\n  // significant digits p, where x is positive and p is in [1, 21] or undefined.\n  // For example, formatDecimal(1.23) returns [\"123\", 0].\n  function formatDecimal(x, p) {\n    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, Infinity\n    var i, coefficient = x.slice(0, i);\n\n    // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n    // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n    return [\n      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n      +x.slice(i + 1)\n    ];\n  }\n\n  function exponent(x) {\n    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;\n  }\n\n  var prefixExponent;\n\n  function formatPrefixAuto(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1],\n        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n        n = coefficient.length;\n    return i === n ? coefficient\n        : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n        : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n        : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimal(x, p + i - 1)[0]; // less than 1y!\n  }\n\n  function formatRounded(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1];\n    return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n        : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n  }\n\n  function formatDefault(x, p) {\n    x = x.toPrecision(p);\n\n    out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {\n      switch (x[i]) {\n        case \".\": i0 = i1 = i; break;\n        case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n        case \"e\": break out;\n        default: if (i0 > 0) i0 = 0; break;\n      }\n    }\n\n    return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;\n  }\n\n  var formatTypes = {\n    \"\": formatDefault,\n    \"%\": function(x, p) { return (x * 100).toFixed(p); },\n    \"b\": function(x) { return Math.round(x).toString(2); },\n    \"c\": function(x) { return x + \"\"; },\n    \"d\": function(x) { return Math.round(x).toString(10); },\n    \"e\": function(x, p) { return x.toExponential(p); },\n    \"f\": function(x, p) { return x.toFixed(p); },\n    \"g\": function(x, p) { return x.toPrecision(p); },\n    \"o\": function(x) { return Math.round(x).toString(8); },\n    \"p\": function(x, p) { return formatRounded(x * 100, p); },\n    \"r\": formatRounded,\n    \"s\": formatPrefixAuto,\n    \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n    \"x\": function(x) { return Math.round(x).toString(16); }\n  };\n\n\n  // [[fill]align][sign][symbol][0][width][,][.precision][type]\n  var re = /^(?:(.)?([<>=^]))?([+\\-\\( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?([a-z%])?$/i;\n\n  function formatSpecifier(specifier) {\n    return new FormatSpecifier(specifier);\n  }\n\n  function FormatSpecifier(specifier) {\n    if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n\n    var match,\n        fill = match[1] || \" \",\n        align = match[2] || \">\",\n        sign = match[3] || \"-\",\n        symbol = match[4] || \"\",\n        zero = !!match[5],\n        width = match[6] && +match[6],\n        comma = !!match[7],\n        precision = match[8] && +match[8].slice(1),\n        type = match[9] || \"\";\n\n    // The \"n\" type is an alias for \",g\".\n    if (type === \"n\") comma = true, type = \"g\";\n\n    // Map invalid types to the default format.\n    else if (!formatTypes[type]) type = \"\";\n\n    // If zero fill is specified, padding goes after sign and before digits.\n    if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n    this.fill = fill;\n    this.align = align;\n    this.sign = sign;\n    this.symbol = symbol;\n    this.zero = zero;\n    this.width = width;\n    this.comma = comma;\n    this.precision = precision;\n    this.type = type;\n  }\n\n  FormatSpecifier.prototype.toString = function() {\n    return this.fill\n        + this.align\n        + this.sign\n        + this.symbol\n        + (this.zero ? \"0\" : \"\")\n        + (this.width == null ? \"\" : Math.max(1, this.width | 0))\n        + (this.comma ? \",\" : \"\")\n        + (this.precision == null ? \"\" : \".\" + Math.max(0, this.precision | 0))\n        + this.type;\n  };\n\n  function formatGroup(grouping, thousands) {\n    return function(value, width) {\n      var i = value.length,\n          t = [],\n          j = 0,\n          g = grouping[0],\n          length = 0;\n\n      while (i > 0 && g > 0) {\n        if (length + g + 1 > width) g = Math.max(1, width - length);\n        t.push(value.substring(i -= g, i + g));\n        if ((length += g + 1) > width) break;\n        g = grouping[j = (j + 1) % grouping.length];\n      }\n\n      return t.reverse().join(thousands);\n    };\n  }\n\n  var prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\n  function identity(x) {\n    return x;\n  }\n\n  function locale(locale) {\n    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,\n        currency = locale.currency,\n        decimal = locale.decimal;\n\n    function format(specifier) {\n      specifier = formatSpecifier(specifier);\n\n      var fill = specifier.fill,\n          align = specifier.align,\n          sign = specifier.sign,\n          symbol = specifier.symbol,\n          zero = specifier.zero,\n          width = specifier.width,\n          comma = specifier.comma,\n          precision = specifier.precision,\n          type = specifier.type;\n\n      // Compute the prefix and suffix.\n      // For SI-prefix, the suffix is lazily computed.\n      var prefix = symbol === \"$\" ? currency[0] : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n          suffix = symbol === \"$\" ? currency[1] : /[%p]/.test(type) ? \"%\" : \"\";\n\n      // What format function should we use?\n      // Is this an integer type?\n      // Can this type generate exponential notation?\n      var formatType = formatTypes[type],\n          maybeSuffix = !type || /[defgprs%]/.test(type);\n\n      // Set the default precision if not specified,\n      // or clamp the specified precision to the supported range.\n      // For significant precision, it must be in [1, 21].\n      // For fixed precision, it must be in [0, 20].\n      precision = precision == null ? (type ? 6 : 12)\n          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n          : Math.max(0, Math.min(20, precision));\n\n      return function(value) {\n        var valuePrefix = prefix,\n            valueSuffix = suffix;\n\n        if (type === \"c\") {\n          valueSuffix = formatType(value) + valueSuffix;\n          value = \"\";\n        } else {\n          value = +value;\n\n          // Convert negative to positive, and compute the prefix.\n          // Note that -0 is not less than 0, but 1 / -0 is!\n          var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);\n\n          // Perform the initial formatting.\n          value = formatType(value, precision);\n\n          // Compute the prefix and suffix.\n          valuePrefix = (valueNegative ? (sign === \"(\" ? sign : \"-\") : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n          valueSuffix = valueSuffix + (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n          // Break the formatted value into the integer value part that can be\n          // grouped, and fractional or exponential suffix part that is not.\n          if (maybeSuffix) {\n            var i = -1, n = value.length, c;\n            while (++i < n) {\n              if (c = value.charCodeAt(i), 48 > c || c > 57) {\n                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n                value = value.slice(0, i);\n                break;\n              }\n            }\n          }\n        }\n\n        // If the fill character is not \"0\", grouping is applied before padding.\n        if (comma && !zero) value = group(value, Infinity);\n\n        // Compute the padding.\n        var length = valuePrefix.length + value.length + valueSuffix.length,\n            padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n        // If the fill character is \"0\", grouping is applied after padding.\n        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n        // Reconstruct the final output based on the desired alignment.\n        switch (align) {\n          case \"<\": return valuePrefix + value + valueSuffix + padding;\n          case \"=\": return valuePrefix + padding + value + valueSuffix;\n          case \"^\": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);\n        }\n        return padding + valuePrefix + value + valueSuffix;\n      };\n    }\n\n    function formatPrefix(specifier, value) {\n      var f = format((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,\n          k = Math.pow(10, -e),\n          prefix = prefixes[8 + e / 3];\n      return function(value) {\n        return f(k * value) + prefix;\n      };\n    }\n\n    return {\n      format: format,\n      formatPrefix: formatPrefix\n    };\n  }\n\n  function precisionRound(step, max) {\n    return Math.max(0, exponent(Math.abs(max)) - exponent(Math.abs(step))) + 1;\n  }\n\n  function precisionPrefix(step, value) {\n    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));\n  }\n\n  function precisionFixed(step) {\n    return Math.max(0, -exponent(Math.abs(step)));\n  }\n\n  var localeDefinitions = (new Map)\n      .set(\"ca-ES\", caEs)\n      .set(\"de-DE\", deDe)\n      .set(\"en-CA\", enCa)\n      .set(\"en-GB\", enGb)\n      .set(\"en-US\", enUs)\n      .set(\"es-ES\", esEs)\n      .set(\"fi-FI\", fiFi)\n      .set(\"fr-CA\", frCa)\n      .set(\"fr-FR\", frFr)\n      .set(\"he-IL\", heIl)\n      .set(\"it-IT\", itIt)\n      .set(\"ja-JP\", jaJp)\n      .set(\"mk-MK\", mkMk)\n      .set(\"nl-NL\", nlNl)\n      .set(\"pl-PL\", plPl)\n      .set(\"pt-BR\", ptBr)\n      .set(\"ru-RU\", ruRu)\n      .set(\"zh-CN\", zhCn);\n\n  var defaultLocale = locale(enUs);\n  exports.format = defaultLocale.format;\n  exports.formatPrefix = defaultLocale.formatPrefix;\n\n  function localeFormat(definition) {\n    if (typeof definition === \"string\") {\n      definition = localeDefinitions.get(definition);\n      if (!definition) return null;\n    }\n    return locale(definition);\n  }\n  ;\n\n  exports.localeFormat = localeFormat;\n  exports.formatSpecifier = formatSpecifier;\n  exports.precisionFixed = precisionFixed;\n  exports.precisionPrefix = precisionPrefix;\n  exports.precisionRound = precisionRound;\n\n}));","if (typeof Map === \"undefined\") {\n  Map = function() { this.clear(); };\n  Map.prototype = {\n    set: function(k, v) { this._[k] = v; return this; },\n    get: function(k) { return this._[k]; },\n    has: function(k) { return k in this._; },\n    delete: function(k) { return k in this._ && delete this._[k]; },\n    clear: function() { this._ = Object.create(null); },\n    get size() { var n = 0; for (var k in this._) ++n; return n; },\n    forEach: function(c) { for (var k in this._) c(this._[k], k, this); }\n  };\n} else (function() {\n  var m = new Map;\n  if (m.set(0, 0) !== m) {\n    m = m.set;\n    Map.prototype.set = function() { m.apply(this, arguments); return this; };\n  }\n})();\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.timeFormat = {}));\n}(this, function (exports) { 'use strict';\n\n  var zhCn = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%Y/%-m/%-d\",\n    time: \"%H:%M:%S\",\n    periods: [\"\", \"\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  };\n\n  var ruRu = {\n    dateTime: \"%A, %e %B %Y . %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  };\n\n  var ptBr = {\n    dateTime: \"%A, %e de %B de %Y. %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Domingo\", \"Segunda\", \"Tera\", \"Quarta\", \"Quinta\", \"Sexta\", \"Sbado\"],\n    shortDays: [\"Dom\", \"Seg\", \"Ter\", \"Qua\", \"Qui\", \"Sex\", \"Sb\"],\n    months: [\"Janeiro\", \"Fevereiro\", \"Maro\", \"Abril\", \"Maio\", \"Junho\", \"Julho\", \"Agosto\", \"Setembro\", \"Outubro\", \"Novembro\", \"Dezembro\"],\n    shortMonths: [\"Jan\", \"Fev\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\"]\n  };\n\n  var plPl = {\n    dateTime: \"%A, %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Niedziela\", \"Poniedziaek\", \"Wtorek\", \"roda\", \"Czwartek\", \"Pitek\", \"Sobota\"],\n    shortDays: [\"Niedz.\", \"Pon.\", \"Wt.\", \"r.\", \"Czw.\", \"Pt.\", \"Sob.\"],\n    months: [\"Stycze\", \"Luty\", \"Marzec\", \"Kwiecie\", \"Maj\", \"Czerwiec\", \"Lipiec\", \"Sierpie\", \"Wrzesie\", \"Padziernik\", \"Listopad\", \"Grudzie\"],\n    shortMonths: [\"Stycz.\", \"Luty\", \"Marz.\", \"Kwie.\", \"Maj\", \"Czerw.\", \"Lipc.\", \"Sierp.\", \"Wrz.\", \"Padz.\", \"Listop.\", \"Grudz.\"]/* In Polish language abbraviated months are not commonly used so there is a dispute about the proper abbraviations. */\n  };\n\n  var nlNl = {\n    dateTime: \"%a %e %B %Y %T\",\n    date: \"%d-%m-%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"zondag\", \"maandag\", \"dinsdag\", \"woensdag\", \"donderdag\", \"vrijdag\", \"zaterdag\"],\n    shortDays: [\"zo\", \"ma\", \"di\", \"wo\", \"do\", \"vr\", \"za\"],\n    months: [\"januari\", \"februari\", \"maart\", \"april\", \"mei\", \"juni\", \"juli\", \"augustus\", \"september\", \"oktober\", \"november\", \"december\"],\n    shortMonths: [\"jan\", \"feb\", \"mrt\", \"apr\", \"mei\", \"jun\", \"jul\", \"aug\", \"sep\", \"okt\", \"nov\", \"dec\"]\n  };\n\n  var mkMk = {\n    dateTime: \"%A, %e %B %Y . %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  };\n\n  var itIt = {\n    dateTime: \"%A %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Domenica\", \"Luned\", \"Marted\", \"Mercoled\", \"Gioved\", \"Venerd\", \"Sabato\"],\n    shortDays: [\"Dom\", \"Lun\", \"Mar\", \"Mer\", \"Gio\", \"Ven\", \"Sab\"],\n    months: [\"Gennaio\", \"Febbraio\", \"Marzo\", \"Aprile\", \"Maggio\", \"Giugno\", \"Luglio\", \"Agosto\", \"Settembre\", \"Ottobre\", \"Novembre\", \"Dicembre\"],\n    shortMonths: [\"Gen\", \"Feb\", \"Mar\", \"Apr\", \"Mag\", \"Giu\", \"Lug\", \"Ago\", \"Set\", \"Ott\", \"Nov\", \"Dic\"]\n  };\n\n  var heIl = {\n    dateTime: \"%A, %e %B %Y %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  };\n\n  var frFr = {\n    dateTime: \"%A, le %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"],\n    shortDays: [\"dim.\", \"lun.\", \"mar.\", \"mer.\", \"jeu.\", \"ven.\", \"sam.\"],\n    months: [\"janvier\", \"fvrier\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"aot\", \"septembre\", \"octobre\", \"novembre\", \"dcembre\"],\n    shortMonths: [\"janv.\", \"fvr.\", \"mars\", \"avr.\", \"mai\", \"juin\", \"juil.\", \"aot\", \"sept.\", \"oct.\", \"nov.\", \"dc.\"]\n  };\n\n  var frCa = {\n    dateTime: \"%a %e %b %Y %X\",\n    date: \"%Y-%m-%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"\", \"\"],\n    days: [\"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"],\n    shortDays: [\"dim\", \"lun\", \"mar\", \"mer\", \"jeu\", \"ven\", \"sam\"],\n    months: [\"janvier\", \"fvrier\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"aot\", \"septembre\", \"octobre\", \"novembre\", \"dcembre\"],\n    shortMonths: [\"jan\", \"fv\", \"mar\", \"avr\", \"mai\", \"jui\", \"jul\", \"ao\", \"sep\", \"oct\", \"nov\", \"dc\"]\n  };\n\n  var fiFi = {\n    dateTime: \"%A, %-d. %Bta %Y klo %X\",\n    date: \"%-d.%-m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"a.m.\", \"p.m.\"],\n    days: [\"sunnuntai\", \"maanantai\", \"tiistai\", \"keskiviikko\", \"torstai\", \"perjantai\", \"lauantai\"],\n    shortDays: [\"Su\", \"Ma\", \"Ti\", \"Ke\", \"To\", \"Pe\", \"La\"],\n    months: [\"tammikuu\", \"helmikuu\", \"maaliskuu\", \"huhtikuu\", \"toukokuu\", \"keskuu\", \"heinkuu\", \"elokuu\", \"syyskuu\", \"lokakuu\", \"marraskuu\", \"joulukuu\"],\n    shortMonths: [\"Tammi\", \"Helmi\", \"Maalis\", \"Huhti\", \"Touko\", \"Kes\", \"Hein\", \"Elo\", \"Syys\", \"Loka\", \"Marras\", \"Joulu\"]\n  };\n\n  var esEs = {\n    dateTime: \"%A, %e de %B de %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"domingo\", \"lunes\", \"martes\", \"mircoles\", \"jueves\", \"viernes\", \"sbado\"],\n    shortDays: [\"dom\", \"lun\", \"mar\", \"mi\", \"jue\", \"vie\", \"sb\"],\n    months: [\"enero\", \"febrero\", \"marzo\", \"abril\", \"mayo\", \"junio\", \"julio\", \"agosto\", \"septiembre\", \"octubre\", \"noviembre\", \"diciembre\"],\n    shortMonths: [\"ene\", \"feb\", \"mar\", \"abr\", \"may\", \"jun\", \"jul\", \"ago\", \"sep\", \"oct\", \"nov\", \"dic\"]\n  };\n\n  var enUs = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%m/%d/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var enGb = {\n    dateTime: \"%a %e %b %X %Y\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var enCa = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%Y-%m-%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var deDe = {\n    dateTime: \"%A, der %e. %B %Y, %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Sonntag\", \"Montag\", \"Dienstag\", \"Mittwoch\", \"Donnerstag\", \"Freitag\", \"Samstag\"],\n    shortDays: [\"So\", \"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\", \"Sa\"],\n    months: [\"Januar\", \"Februar\", \"Mrz\", \"April\", \"Mai\", \"Juni\", \"Juli\", \"August\", \"September\", \"Oktober\", \"November\", \"Dezember\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mrz\", \"Apr\", \"Mai\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dez\"]\n  };\n\n  var caEs = {\n    dateTime: \"%A, %e de %B de %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"diumenge\", \"dilluns\", \"dimarts\", \"dimecres\", \"dijous\", \"divendres\", \"dissabte\"],\n    shortDays: [\"dg.\", \"dl.\", \"dt.\", \"dc.\", \"dj.\", \"dv.\", \"ds.\"],\n    months: [\"gener\", \"febrer\", \"mar\", \"abril\", \"maig\", \"juny\", \"juliol\", \"agost\", \"setembre\", \"octubre\", \"novembre\", \"desembre\"],\n    shortMonths: [\"gen.\", \"febr.\", \"mar\", \"abr.\", \"maig\", \"juny\", \"jul.\", \"ag.\", \"set.\", \"oct.\", \"nov.\", \"des.\"]\n  };\n\n  var t0 = new Date;\n  var t1 = new Date;\n\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  }\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var sunday = weekday(0);\n  var monday = weekday(1);\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcSunday = utcWeekday(0);\n  var utcMonday = utcWeekday(1);\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  function localDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n      date.setFullYear(d.y);\n      return date;\n    }\n    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n  }\n\n  function utcDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n      date.setUTCFullYear(d.y);\n      return date;\n    }\n    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n  }\n\n  function newYear(y) {\n    return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};\n  }\n\n  function locale(locale) {\n    var locale_dateTime = locale.dateTime,\n        locale_date = locale.date,\n        locale_time = locale.time,\n        locale_periods = locale.periods,\n        locale_weekdays = locale.days,\n        locale_shortWeekdays = locale.shortDays,\n        locale_months = locale.months,\n        locale_shortMonths = locale.shortMonths;\n\n    var periodLookup = formatLookup(locale_periods),\n        weekdayRe = formatRe(locale_weekdays),\n        weekdayLookup = formatLookup(locale_weekdays),\n        shortWeekdayRe = formatRe(locale_shortWeekdays),\n        shortWeekdayLookup = formatLookup(locale_shortWeekdays),\n        monthRe = formatRe(locale_months),\n        monthLookup = formatLookup(locale_months),\n        shortMonthRe = formatRe(locale_shortMonths),\n        shortMonthLookup = formatLookup(locale_shortMonths);\n\n    var formats = {\n      \"a\": formatShortWeekday,\n      \"A\": formatWeekday,\n      \"b\": formatShortMonth,\n      \"B\": formatMonth,\n      \"c\": null,\n      \"d\": formatDayOfMonth,\n      \"e\": formatDayOfMonth,\n      \"H\": formatHour24,\n      \"I\": formatHour12,\n      \"j\": formatDayOfYear,\n      \"L\": formatMilliseconds,\n      \"m\": formatMonthNumber,\n      \"M\": formatMinutes,\n      \"p\": formatPeriod,\n      \"S\": formatSeconds,\n      \"U\": formatWeekNumberSunday,\n      \"w\": formatWeekdayNumber,\n      \"W\": formatWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatYear,\n      \"Y\": formatFullYear,\n      \"Z\": formatZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var utcFormats = {\n      \"a\": formatUTCShortWeekday,\n      \"A\": formatUTCWeekday,\n      \"b\": formatUTCShortMonth,\n      \"B\": formatUTCMonth,\n      \"c\": null,\n      \"d\": formatUTCDayOfMonth,\n      \"e\": formatUTCDayOfMonth,\n      \"H\": formatUTCHour24,\n      \"I\": formatUTCHour12,\n      \"j\": formatUTCDayOfYear,\n      \"L\": formatUTCMilliseconds,\n      \"m\": formatUTCMonthNumber,\n      \"M\": formatUTCMinutes,\n      \"p\": formatUTCPeriod,\n      \"S\": formatUTCSeconds,\n      \"U\": formatUTCWeekNumberSunday,\n      \"w\": formatUTCWeekdayNumber,\n      \"W\": formatUTCWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatUTCYear,\n      \"Y\": formatUTCFullYear,\n      \"Z\": formatUTCZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var parses = {\n      \"a\": parseShortWeekday,\n      \"A\": parseWeekday,\n      \"b\": parseShortMonth,\n      \"B\": parseMonth,\n      \"c\": parseLocaleDateTime,\n      \"d\": parseDayOfMonth,\n      \"e\": parseDayOfMonth,\n      \"H\": parseHour24,\n      \"I\": parseHour24,\n      \"j\": parseDayOfYear,\n      \"L\": parseMilliseconds,\n      \"m\": parseMonthNumber,\n      \"M\": parseMinutes,\n      \"p\": parsePeriod,\n      \"S\": parseSeconds,\n      \"U\": parseWeekNumberSunday,\n      \"w\": parseWeekdayNumber,\n      \"W\": parseWeekNumberMonday,\n      \"x\": parseLocaleDate,\n      \"X\": parseLocaleTime,\n      \"y\": parseYear,\n      \"Y\": parseFullYear,\n      \"Z\": parseZone,\n      \"%\": parseLiteralPercent\n    };\n\n    // These recursive directive definitions must be deferred.\n    formats.x = newFormat(locale_date, formats);\n    formats.X = newFormat(locale_time, formats);\n    formats.c = newFormat(locale_dateTime, formats);\n    utcFormats.x = newFormat(locale_date, utcFormats);\n    utcFormats.X = newFormat(locale_time, utcFormats);\n    utcFormats.c = newFormat(locale_dateTime, utcFormats);\n\n    function newFormat(specifier, formats) {\n      return function(date) {\n        var string = [],\n            i = -1,\n            j = 0,\n            n = specifier.length,\n            c,\n            pad,\n            format;\n\n        while (++i < n) {\n          if (specifier.charCodeAt(i) === 37) {\n            string.push(specifier.slice(j, i));\n            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);\n            if (format = formats[c]) c = format(date, pad == null ? (c === \"e\" ? \" \" : \"0\") : pad);\n            string.push(c);\n            j = i + 1;\n          }\n        }\n\n        string.push(specifier.slice(j, i));\n        return string.join(\"\");\n      };\n    }\n\n    function newParse(specifier, newDate) {\n      return function(string) {\n        var d = newYear(1900),\n            i = parseSpecifier(d, specifier, string, 0);\n        if (i != string.length) return null;\n\n        // The am-pm flag is 0 for AM, and 1 for PM.\n        if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\n        // If a time zone is specified, all fields are interpreted as UTC and then\n        // offset according to the specified time zone.\n        if (\"Z\" in d) {\n          if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n            var day = utcDate(newYear(d.y)).getUTCDay();\n            if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n            d.m = 0;\n            d.d = d.w + d.U * 7 - (day + 6) % 7;\n          }\n          d.H += d.Z / 100 | 0;\n          d.M += d.Z % 100;\n          return utcDate(d);\n        }\n\n        // Otherwise, all fields are in local time.\n        if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n          var day = newDate(newYear(d.y)).getDay();\n          if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n          d.m = 0;\n          d.d = d.w + d.U * 7 - (day + 6) % 7;\n        }\n        return newDate(d);\n      };\n    }\n\n    function parseSpecifier(d, specifier, string, j) {\n      var i = 0,\n          n = specifier.length,\n          m = string.length,\n          c,\n          parse;\n\n      while (i < n) {\n        if (j >= m) return -1;\n        c = specifier.charCodeAt(i++);\n        if (c === 37) {\n          c = specifier.charAt(i++);\n          parse = parses[c in pads ? specifier.charAt(i++) : c];\n          if (!parse || ((j = parse(d, string, j)) < 0)) return -1;\n        } else if (c != string.charCodeAt(j++)) {\n          return -1;\n        }\n      }\n\n      return j;\n    }\n\n    function parseShortWeekday(d, string, i) {\n      var n = shortWeekdayRe.exec(string.slice(i));\n      return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseWeekday(d, string, i) {\n      var n = weekdayRe.exec(string.slice(i));\n      return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseShortMonth(d, string, i) {\n      var n = shortMonthRe.exec(string.slice(i));\n      return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseMonth(d, string, i) {\n      var n = monthRe.exec(string.slice(i));\n      return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseLocaleDateTime(d, string, i) {\n      return parseSpecifier(d, locale_dateTime, string, i);\n    }\n\n    function parseLocaleDate(d, string, i) {\n      return parseSpecifier(d, locale_date, string, i);\n    }\n\n    function parseLocaleTime(d, string, i) {\n      return parseSpecifier(d, locale_time, string, i);\n    }\n\n    function parsePeriod(d, string, i) {\n      var n = periodLookup.get(string.slice(i, i += 2).toLowerCase());\n      return n == null ? -1 : (d.p = n, i);\n    }\n\n    function formatShortWeekday(d) {\n      return locale_shortWeekdays[d.getDay()];\n    }\n\n    function formatWeekday(d) {\n      return locale_weekdays[d.getDay()];\n    }\n\n    function formatShortMonth(d) {\n      return locale_shortMonths[d.getMonth()];\n    }\n\n    function formatMonth(d) {\n      return locale_months[d.getMonth()];\n    }\n\n    function formatPeriod(d) {\n      return locale_periods[+(d.getHours() >= 12)];\n    }\n\n    function formatUTCShortWeekday(d) {\n      return locale_shortWeekdays[d.getUTCDay()];\n    }\n\n    function formatUTCWeekday(d) {\n      return locale_weekdays[d.getUTCDay()];\n    }\n\n    function formatUTCShortMonth(d) {\n      return locale_shortMonths[d.getUTCMonth()];\n    }\n\n    function formatUTCMonth(d) {\n      return locale_months[d.getUTCMonth()];\n    }\n\n    function formatUTCPeriod(d) {\n      return locale_periods[+(d.getUTCHours() >= 12)];\n    }\n\n    return {\n      format: function(specifier) {\n        var f = newFormat(specifier += \"\", formats);\n        f.parse = newParse(specifier, localDate);\n        f.toString = function() { return specifier; };\n        return f;\n      },\n      utcFormat: function(specifier) {\n        var f = newFormat(specifier += \"\", utcFormats);\n        f.parse = newParse(specifier, utcDate);\n        f.toString = function() { return specifier; };\n        return f;\n      }\n    };\n  }\n\n  var pads = {\"-\": \"\", \"_\": \" \", \"0\": \"0\"};\n  var numberRe = /^\\s*\\d+/;\n  var percentRe = /^%/;\n  var requoteRe = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\n  function pad(value, fill, width) {\n    var sign = value < 0 ? \"-\" : \"\",\n        string = (sign ? -value : value) + \"\",\n        length = string.length;\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n  }\n\n  function requote(s) {\n    return s.replace(requoteRe, \"\\\\$&\");\n  }\n\n  function formatRe(names) {\n    return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n  }\n\n  function formatLookup(names) {\n    var map = new Map, i = -1, n = names.length;\n    while (++i < n) map.set(names[i].toLowerCase(), i);\n    return map;\n  }\n\n  function parseWeekdayNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 1));\n    return n ? (d.w = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberSunday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.U = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberMonday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.W = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseFullYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 4));\n    return n ? (d.y = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n  }\n\n  function parseZone(d, string, i) {\n    return /^[+-]\\d{4}$/.test(string = string.slice(i, i + 5))\n        ? (d.Z = -string, i + 5) // sign differs from getTimezoneOffset!\n        : -1;\n  }\n\n  function parseMonthNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n  }\n\n  function parseDayOfMonth(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseDayOfYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseHour24(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.H = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMinutes(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.M = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseSeconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.S = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMilliseconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.L = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseLiteralPercent(d, string, i) {\n    var n = percentRe.exec(string.slice(i, i + 1));\n    return n ? i + n[0].length : -1;\n  }\n\n  function formatDayOfMonth(d, p) {\n    return pad(d.getDate(), p, 2);\n  }\n\n  function formatHour24(d, p) {\n    return pad(d.getHours(), p, 2);\n  }\n\n  function formatHour12(d, p) {\n    return pad(d.getHours() % 12 || 12, p, 2);\n  }\n\n  function formatDayOfYear(d, p) {\n    return pad(1 + day.count(year(d), d), p, 3);\n  }\n\n  function formatMilliseconds(d, p) {\n    return pad(d.getMilliseconds(), p, 3);\n  }\n\n  function formatMonthNumber(d, p) {\n    return pad(d.getMonth() + 1, p, 2);\n  }\n\n  function formatMinutes(d, p) {\n    return pad(d.getMinutes(), p, 2);\n  }\n\n  function formatSeconds(d, p) {\n    return pad(d.getSeconds(), p, 2);\n  }\n\n  function formatWeekNumberSunday(d, p) {\n    return pad(sunday.count(year(d), d), p, 2);\n  }\n\n  function formatWeekdayNumber(d) {\n    return d.getDay();\n  }\n\n  function formatWeekNumberMonday(d, p) {\n    return pad(monday.count(year(d), d), p, 2);\n  }\n\n  function formatYear(d, p) {\n    return pad(d.getFullYear() % 100, p, 2);\n  }\n\n  function formatFullYear(d, p) {\n    return pad(d.getFullYear() % 10000, p, 4);\n  }\n\n  function formatZone(d) {\n    var z = d.getTimezoneOffset();\n    return (z > 0 ? \"-\" : (z *= -1, \"+\"))\n        + pad(z / 60 | 0, \"0\", 2)\n        + pad(z % 60, \"0\", 2);\n  }\n\n  function formatUTCDayOfMonth(d, p) {\n    return pad(d.getUTCDate(), p, 2);\n  }\n\n  function formatUTCHour24(d, p) {\n    return pad(d.getUTCHours(), p, 2);\n  }\n\n  function formatUTCHour12(d, p) {\n    return pad(d.getUTCHours() % 12 || 12, p, 2);\n  }\n\n  function formatUTCDayOfYear(d, p) {\n    return pad(1 + utcDay.count(utcYear(d), d), p, 3);\n  }\n\n  function formatUTCMilliseconds(d, p) {\n    return pad(d.getUTCMilliseconds(), p, 3);\n  }\n\n  function formatUTCMonthNumber(d, p) {\n    return pad(d.getUTCMonth() + 1, p, 2);\n  }\n\n  function formatUTCMinutes(d, p) {\n    return pad(d.getUTCMinutes(), p, 2);\n  }\n\n  function formatUTCSeconds(d, p) {\n    return pad(d.getUTCSeconds(), p, 2);\n  }\n\n  function formatUTCWeekNumberSunday(d, p) {\n    return pad(utcSunday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCWeekdayNumber(d) {\n    return d.getUTCDay();\n  }\n\n  function formatUTCWeekNumberMonday(d, p) {\n    return pad(utcMonday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCYear(d, p) {\n    return pad(d.getUTCFullYear() % 100, p, 2);\n  }\n\n  function formatUTCFullYear(d, p) {\n    return pad(d.getUTCFullYear() % 10000, p, 4);\n  }\n\n  function formatUTCZone() {\n    return \"+0000\";\n  }\n\n  function formatLiteralPercent() {\n    return \"%\";\n  }\n\n  var isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\n\n  function formatIsoNative(date) {\n    return date.toISOString();\n  }\n\n  formatIsoNative.parse = function(string) {\n    var date = new Date(string);\n    return isNaN(date) ? null : date;\n  };\n\n  formatIsoNative.toString = function() {\n    return isoSpecifier;\n  };\n\n  var formatIso = Date.prototype.toISOString && +new Date(\"2000-01-01T00:00:00.000Z\")\n      ? formatIsoNative\n      : enUs.utcFormat(isoSpecifier);\n\n  var isoFormat = formatIso;\n\n  var localeDefinitions = (new Map)\n      .set(\"ca-ES\", caEs)\n      .set(\"de-DE\", deDe)\n      .set(\"en-CA\", enCa)\n      .set(\"en-GB\", enGb)\n      .set(\"en-US\", enUs)\n      .set(\"es-ES\", esEs)\n      .set(\"fi-FI\", fiFi)\n      .set(\"fr-CA\", frCa)\n      .set(\"fr-FR\", frFr)\n      .set(\"he-IL\", heIl)\n      .set(\"it-IT\", itIt)\n      .set(\"mk-MK\", mkMk)\n      .set(\"nl-NL\", nlNl)\n      .set(\"pl-PL\", plPl)\n      .set(\"pt-BR\", ptBr)\n      .set(\"ru-RU\", ruRu)\n      .set(\"zh-CN\", zhCn);\n\n  var defaultLocale = locale(enUs);\n  exports.format = defaultLocale.format;\n  exports.utcFormat = defaultLocale.utcFormat;\n\n  function localeFormat(definition) {\n    if (typeof definition === \"string\") {\n      definition = localeDefinitions.get(definition);\n      if (!definition) return null;\n    }\n    return locale(definition);\n  }\n  ;\n\n  exports.localeFormat = localeFormat;\n  exports.isoFormat = isoFormat;\n\n}));","'use strict';\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  util = require('./util'),\n  vlfield = require('./field'),\n  vlenc = require('./enc'),\n  schema = require('./schema/schema');\n\nmodule.exports = (function() {\n  function Encoding(spec, theme) {\n    var defaults = schema.instantiate(),\n      specExtended = schema.util.merge(defaults, theme || {}, spec) ;\n\n    this._data = specExtended.data;\n    this._marktype = specExtended.marktype;\n    this._enc = specExtended.encoding;\n    this._config = specExtended.config;\n    this._filter = specExtended.filter;\n    // this._vega2 = true;\n  }\n\n  var proto = Encoding.prototype;\n\n  Encoding.fromShorthand = function(shorthand, data, config, theme) {\n    var c = consts.shorthand,\n        split = shorthand.split(c.delim),\n        marktype = split.shift().split(c.assign)[1].trim(),\n        enc = vlenc.fromShorthand(split);\n\n    return new Encoding({\n      data: data,\n      marktype: marktype,\n      encoding: enc,\n      config: config,\n      filter: []\n    }, theme);\n  };\n\n  Encoding.fromSpec = function(spec, theme) {\n    return new Encoding(spec, theme);\n  };\n\n  proto.toShorthand = function() {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + this._marktype +\n      c.delim + vlenc.shorthand(this._enc);\n  };\n\n  Encoding.shorthand = function (spec) {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + spec.marktype +\n      c.delim + vlenc.shorthand(spec.encoding);\n  };\n\n  Encoding.specFromShorthand = function(shorthand, data, config, excludeConfig) {\n    return Encoding.fromShorthand(shorthand, data, config).toSpec(excludeConfig);\n  };\n\n  proto.toSpec = function(excludeConfig, excludeData) {\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    spec = {\n      marktype: this._marktype,\n      encoding: enc,\n      filter: this._filter\n    };\n\n    if (!excludeConfig) {\n      spec.config = util.duplicate(this._config);\n    }\n\n    if (!excludeData) {\n      spec.data = util.duplicate(this._data);\n    }\n\n    // remove defaults\n    var defaults = schema.instantiate();\n    return schema.util.subtract(spec, defaults);\n  };\n\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(encType) {\n    // equivalent to calling vlenc.has(this._enc, encType)\n    return this._enc[encType].name !== undefined;\n  };\n\n  proto.field = function(et) {\n    return this._enc[et];\n  };\n\n  proto.filter = function() {\n    var filterNull = [],\n      fields = this.fields(),\n      self = this;\n\n    util.forEach(fields, function(fieldList, fieldName) {\n      if (fieldName === '*') return; //count\n\n      if ((self.config('filterNull').Q && fieldList.containsType[Q]) ||\n          (self.config('filterNull').T && fieldList.containsType[T]) ||\n          (self.config('filterNull').O && fieldList.containsType[O]) ||\n          (self.config('filterNull').N && fieldList.containsType[N])) {\n        filterNull.push({\n          operands: [fieldName],\n          operator: 'notNull'\n        });\n      }\n    });\n\n    return filterNull.concat(this._filter);\n  };\n\n  // get \"field\" reference for vega\n  proto.fieldRef = function(et, opt) {\n    opt = opt || {};\n    opt.data = !this._vega2 && (opt.data !== false);\n    return vlfield.fieldRef(this._enc[et], opt);\n  };\n\n  proto.fieldName = function(et) {\n    return this._enc[et].name;\n  };\n\n  /*\n   * return key-value pairs of field name and list of fields of that field name\n   */\n  proto.fields = function() {\n    return vlenc.fields(this._enc);\n  };\n\n  proto.fieldTitle = function(et) {\n    if (vlfield.isCount(this._enc[et])) {\n      return vlfield.count.displayName;\n    }\n    var fn = this._enc[et].aggregate || this._enc[et].timeUnit || (this._enc[et].bin && 'bin');\n    if (fn) {\n      var uppercase = fn === 'avg' ? 'MEAN' :fn.toUpperCase();\n      return uppercase + '(' + this._enc[et].name + ')';\n    } else {\n      return this._enc[et].name;\n    }\n  };\n\n  proto.scale = function(et) {\n    return this._enc[et].scale || {};\n  };\n\n  proto.axis = function(et) {\n    return this._enc[et].axis || {};\n  };\n\n  proto.bandSize = function(encType, useSmallBand) {\n    useSmallBand = useSmallBand ||\n      //isBandInSmallMultiples\n      (encType === Y && this.has(ROW) && this.has(Y)) ||\n      (encType === X && this.has(COL) && this.has(X));\n\n    // if band.size is explicitly specified, follow the specification, otherwise draw value from config.\n    return this.field(encType).band.size ||\n      this.config(useSmallBand ? 'smallBandSize' : 'largeBandSize');\n  };\n\n  proto.aggregate = function(et) {\n    return this._enc[et].aggregate;\n  };\n\n  // returns false if binning is disabled, otherwise an object with binning properties\n  proto.bin = function(et) {\n    var bin = this._enc[et].bin;\n    if (bin === {})\n      return false;\n    if (bin === true)\n      return {\n        maxbins: schema.MAXBINS_DEFAULT\n      };\n    return bin;\n  };\n\n  proto.value = function(et) {\n    return this._enc[et].value;\n  };\n\n  proto.numberFormat = function(fieldStats) {\n    var formatConfig = fieldStats.max > this.config('maxSmallNumber') ?\n      'largeNumberFormat': 'smallNumberFormat';\n    return this.config(formatConfig);\n  };\n\n  proto.sort = function(et, stats) {\n    var sort = this._enc[et].sort,\n      enc = this._enc,\n      isTypes = vlfield.isTypes;\n\n    if ((!sort || sort.length===0) &&\n        // FIXME\n        Encoding.toggleSort.support({encoding:this._enc}, stats, true) && //HACK\n        this.config('toggleSort') === Q\n      ) {\n      var qField = isTypes(enc.x, [N, O]) ? enc.y : enc.x;\n\n      if (isTypes(enc[et], [N, O])) {\n        sort = [{\n          name: qField.name,\n          aggregate: qField.aggregate,\n          type: qField.type,\n          reverse: true\n        }];\n      }\n    }\n\n    return sort;\n  };\n\n  proto.map = function(f) {\n    return vlenc.map(this._enc, f);\n  };\n\n  proto.reduce = function(f, init) {\n    return vlenc.reduce(this._enc, f, init);\n  };\n\n  proto.forEach = function(f) {\n    return vlenc.forEach(this._enc, f);\n  };\n\n  proto.type = function(et) {\n    return this.has(et) ? this._enc[et].type : null;\n  };\n\n  proto.isType = function(et, type) {\n    var field = this.field(et);\n    return field && vlfield.isType(field, type);\n  };\n\n\n  proto.isTypes = function(et, type) {\n    var field = this.field(et);\n    return field && vlfield.isTypes(field, type);\n  };\n\n  Encoding.isOrdinalScale = function(encoding, encType) {\n    return vlfield.isOrdinalScale(encoding.field(encType));\n  };\n\n  Encoding.isDimension = function(encoding, encType) {\n    return vlfield.isDimension(encoding.field(encType));\n  };\n\n  Encoding.isMeasure = function(encoding, encType) {\n    return vlfield.isMeasure(encoding.field(encType));\n  };\n\n  proto.isOrdinalScale = function(encType) {\n    return this.has(encType) && Encoding.isOrdinalScale(this, encType);\n  };\n\n  proto.isDimension = function(encType) {\n    return this.has(encType) && Encoding.isDimension(this, encType);\n  };\n\n  proto.isMeasure = function(encType) {\n    return this.has(encType) && Encoding.isMeasure(this, encType);\n  };\n\n  proto.isAggregate = function() {\n    return vlenc.isAggregate(this._enc);\n  };\n\n  proto.dataTable = function() {\n    return this.isAggregate() ? AGGREGATE : RAW;\n  };\n\n  Encoding.isAggregate = function(spec) {\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.alwaysNoOcclusion = function(spec) {\n    // FIXME raw OxQ with # of rows = # of O\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.isStack = function(spec) {\n    // FIXME update this once we have control for stack ...\n    return (spec.marktype === 'bar' || spec.marktype === 'area') &&\n      spec.encoding.color;\n  };\n\n  proto.isStack = function() {\n    // FIXME update this once we have control for stack ...\n    return (this.is('bar') || this.is('area')) && this.has('color');\n  };\n\n  proto.details = function() {\n    var encoding = this;\n    return this.reduce(function(refs, field, encType) {\n      if (!field.aggregate && (encType !== X && encType !== Y)) {\n        refs.push(encoding.fieldRef(encType));\n      }\n      return refs;\n    }, []);\n  };\n\n  proto.facets = function() {\n    var encoding = this;\n    return this.reduce(function(refs, field, encType) {\n      if (!field.aggregate && (encType == ROW || encType == COL)) {\n        refs.push(encoding.fieldRef(encType));\n      }\n      return refs;\n    }, []);\n  };\n\n  proto.cardinality = function(encType, stats) {\n    return vlfield.cardinality(this.field(encType), stats, this.config('filterNull'));\n  };\n\n  proto.isRaw = function() {\n    return !this.isAggregate();\n  };\n\n  proto.data = function() {\n    return this._data;\n  };\n\n   // returns whether the encoding has values embedded\n  proto.hasValues = function() {\n    var vals = this.data().values;\n    return vals && vals.length;\n  };\n\n  proto.config = function(name) {\n    return this._config[name];\n  };\n\n  Encoding.transpose = function(spec) {\n    var oldenc = spec.encoding,\n      enc = util.duplicate(spec.encoding);\n    enc.x = oldenc.y;\n    enc.y = oldenc.x;\n    enc.row = oldenc.col;\n    enc.col = oldenc.row;\n    spec.encoding = enc;\n    return spec;\n  };\n\n  // FIXME: REMOVE everything below here\n\n  Encoding.toggleSort = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.toggleSort = spec.config.toggleSort === Q ? N : Q;\n    return spec;\n  };\n\n\n  Encoding.toggleSort.direction = function(spec) {\n    if (!Encoding.toggleSort.support(spec)) { return; }\n    var enc = spec.encoding;\n    return enc.x.type === N ? 'x' : 'y';\n  };\n\n  Encoding.toggleSort.mode = function(spec) {\n    return spec.config.toggleSort;\n  };\n\n  Encoding.toggleSort.support = function(spec, stats) {\n    var enc = spec.encoding,\n      isTypes = vlfield.isTypes;\n\n    if (vlenc.has(enc, ROW) || vlenc.has(enc, COL) ||\n      !vlenc.has(enc, X) || !vlenc.has(enc, Y) ||\n      !Encoding.alwaysNoOcclusion(spec, stats)) {\n      return false;\n    }\n\n    return ( isTypes(enc.x, [N,O]) && vlfield.isMeasure(enc.y)) ? 'x' :\n      ( isTypes(enc.y, [N,O]) && vlfield.isMeasure(enc.x)) ? 'y' : false;\n  };\n\n  Encoding.toggleFilterNullO = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.filterNull = spec.config.filterNull || { //FIXME\n      T: true,\n      Q: true\n    };\n    spec.config.filterNull.O = !spec.config.filterNull.O;\n    return spec;\n  };\n\n  Encoding.toggleFilterNullO.support = function(spec, stats) {\n    var fields = vlenc.fields(spec.encoding);\n    for (var fieldName in fields) {\n      var fieldList = fields[fieldName];\n      if (fieldList.containsType.O && fieldName in stats && stats[fieldName].nulls > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  return Encoding;\n})();\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  getter = util.getter,\n  time = require('./time');\n\nvar axis = module.exports = {};\n\naxis.def = function(name, encoding, layout, stats, opt) {\n  var isCol = name == COL,\n    isRow = name == ROW,\n    type = isCol ? 'x' : isRow ? 'y' : name;\n\n  var def = {\n    type: type,\n    scale: name,\n    properties: {},\n    layer: encoding.field(name).axis.layer,\n    orient: axis.orient(name, encoding, stats)\n  };\n\n  // Add axis label custom scale (for bin / time)\n  def = axis.labels.scale(def, encoding, name);\n  def = axis.labels.format(def, name, encoding, stats);\n  def = axis.labels.angle(def, encoding, name);\n\n  // for x-axis, set ticks for Q or rotate scale for ordinal scale\n  if (name == X) {\n    if ((encoding.isDimension(X) || encoding.isType(X, T)) &&\n        !('angle' in getter(def, ['properties', 'labels']))) {\n      // TODO(kanitw): Jul 19, 2015 - #506 add condition for rotation\n      def = axis.labels.rotate(def);\n    } else { // Q\n      def.ticks = encoding.field(name).axis.ticks;\n    }\n  }\n\n  // TitleOffset depends on labels rotation\n  def.titleOffset = axis.titleOffset(encoding, layout, name);\n\n  //def.offset is used in axis.grid\n  if(isRow) def.offset = axis.titleOffset(encoding, layout, Y) + 20;\n  // FIXME(kanitw): Jul 19, 2015 - offset for column when x is put on top\n\n  def = axis.grid(def, name, encoding, layout);\n  def = axis.title(def, name, encoding, layout, opt);\n\n  if (isRow || isCol) def = axis.hideTicks(def);\n\n  return def;\n};\n\naxis.orient = function(name, encoding, stats) {\n  var orient = encoding.field(name).axis.orient;\n  if (orient) return orient;\n\n  if (name === COL) return 'top';\n\n  // x-axis for long y - put on top\n  if (name === X && encoding.has(Y) && encoding.isOrdinalScale(Y) && encoding.cardinality(Y, stats) > 30) {\n    return 'top';\n  }\n\n  return undefined;\n};\n\naxis.grid = function(def, name, encoding, layout) {\n  var cellPadding = layout.cellPadding,\n    isCol = name == COL,\n    isRow = name == ROW;\n\n  if (encoding.axis(name).grid) {\n    def.grid = true;\n\n    if (isCol) {\n      // set grid property -- put the lines on the right the cell\n      def.properties.grid = {\n        x: {\n          offset: layout.cellWidth * (1+ cellPadding/2.0),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'col'\n        },\n        y: {\n          value: -layout.cellHeight * (cellPadding/2),\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      };\n    } else if (isRow) {\n      // set grid property -- put the lines on the top\n      def.properties.grid = {\n        y: {\n          offset: -layout.cellHeight * (cellPadding/2),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'row'\n        },\n        x: {\n          value: def.offset\n        },\n        x2: {\n          offset: def.offset + (layout.cellWidth * 0.05),\n          // default value(s) -- vega doesn't do recursive merge\n          group: 'mark.group.width',\n          mult: 1\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      };\n    } else {\n      def.properties.grid = {\n        stroke: { value: encoding.config('gridColor') },\n        opacity: { value: encoding.config('gridOpacity') }\n      };\n    }\n  }\n  return def;\n};\n\naxis.hideTicks = function(def) {\n  def.properties.ticks = {opacity: {value: 0}};\n  def.properties.majorTicks = {opacity: {value: 0}};\n  def.properties.axis = {opacity: {value: 0}};\n  return def;\n};\n\naxis.title = function (def, name, encoding, layout) {\n  var ax = encoding.field(name).axis;\n\n  if (ax.title) {\n    def.title = ax.title;\n  } else {\n    // if not defined, automatically determine axis title from field def\n    var fieldTitle = encoding.fieldTitle(name),\n      maxLength;\n\n    if (ax.titleMaxLength) {\n      maxLength = ax.titleMaxLength;\n    } else if (name===X) {\n      maxLength = layout.cellWidth / encoding.config('characterWidth');\n    } else if (name === Y) {\n      maxLength = layout.cellHeight / encoding.config('characterWidth');\n    }\n\n    def.title = maxLength ? util.truncate(fieldTitle, maxLength) : fieldTitle;\n  }\n\n  if (name === ROW) {\n    def.properties.title = {\n      angle: {value: 0},\n      align: {value: 'right'},\n      baseline: {value: 'middle'},\n      dy: {value: (-layout.height/2) -20}\n    };\n  }\n\n  return def;\n};\n\naxis.labels = {};\n\n/** add custom label for time type and bin */\naxis.labels.scale = function(def, encoding, name) {\n  // time\n  var timeUnit = encoding.field(name).timeUnit;\n  if (encoding.isType(name, T) && timeUnit && (time.hasScale(timeUnit))) {\n    setter(def, ['properties','labels','text','scale'], 'time-'+ timeUnit);\n  }\n  // FIXME bin\n  return def;\n};\n\n/**\n * Determine number format or truncate if maxLabel length is presented.\n */\naxis.labels.format = function (def, name, encoding, stats) {\n  var fieldStats = stats[encoding.field(name).name];\n\n  if (encoding.axis(name).format) {\n    def.format = encoding.axis(name).format;\n  } else if (encoding.isType(name, Q) || fieldStats.type === 'number') {\n    def.format = encoding.numberFormat(fieldStats);\n  } else if (encoding.isType(name, T)) {\n    var timeUnit = encoding.field(name).timeUnit;\n    if (!timeUnit) {\n      def.format = encoding.config('timeFormat');\n    } else if (timeUnit === 'year') {\n      def.format = 'd';\n    }\n  } else if (encoding.isTypes(name, [N, O]) && encoding.axis(name).maxLabelLength) {\n    setter(def,\n      ['properties','labels','text','template'],\n      '{{data | truncate:' + encoding.axis(name).maxLabelLength + '}}'\n      );\n  }\n\n  return def;\n};\n\naxis.labels.angle = function(def, encoding, name) {\n  var angle = encoding.axis(name).labelAngle;\n  if (typeof angle === 'undefined') return def;\n\n  setter(def, ['properties', 'labels', 'angle', 'value'], angle);\n  return def;\n};\n\naxis.labels.rotate = function(def) {\n var align = def.orient ==='top' ? 'left' : 'right';\n setter(def, ['properties','labels', 'angle', 'value'], 270);\n setter(def, ['properties','labels', 'align', 'value'], align);\n setter(def, ['properties','labels', 'baseline', 'value'], 'middle');\n return def;\n};\n\naxis.titleOffset = function (encoding, layout, name) {\n  // return specified value if specified\n  var value = encoding.axis(name).titleOffset;\n  if (value)  return value;\n\n  switch (name) {\n    //FIXME make this adjustable\n    case ROW: return 0;\n    case COL: return 35;\n  }\n  return getter(layout, [name, 'axisTitleOffset']);\n};\n","'use strict';\n\nvar summary = module.exports = require('datalib/src/stats').summary;\n\nrequire('../globals');\n\n/**\n * Module for compiling Vega-lite spec into Vega spec.\n */\nvar compiler = module.exports = {};\n\nvar Encoding = require('../Encoding'),\n  axis = compiler.axis = require('./axis'),\n  legend = compiler.legend = require('./legend'),\n  marks = compiler.marks = require('./marks'),\n  scale = compiler.scale = require('./scale');\n\ncompiler.data = require('./data');\ncompiler.facet = require('./facet');\ncompiler.layout = require('./layout');\ncompiler.sort = require('./sort');\ncompiler.stack = require('./stack');\ncompiler.style = require('./style');\ncompiler.subfacet = require('./subfacet');\ncompiler.time = require('./time');\n\ncompiler.compile = function (spec, stats, theme) {\n  return compiler.compileEncoding(Encoding.fromSpec(spec, theme), stats);\n};\n\ncompiler.shorthand = function (shorthand, stats, config, theme) {\n  return compiler.compileEncoding(Encoding.fromShorthand(shorthand, config, theme), stats);\n};\n\n/**\n * Create a Vega specification from a Vega-lite Encoding object.\n */\ncompiler.compileEncoding = function (encoding, stats) {\n  // no need to pass stats if you pass in the data\n  if (!stats) {\n    if (encoding.hasValues()) {\n        stats = summary(encoding.data().values).reduce(function(s, p) {\n        s[p.field] = p;\n        return s;\n      }, {});\n    } else {\n      console.error('No stats provided and data is not embedded.');\n    }\n  }\n\n  var layout = compiler.layout(encoding, stats);\n\n  var spec = {\n      width: layout.width,\n      height: layout.height,\n      padding: 'auto',\n      data: compiler.data(encoding),\n      // global scales contains only time unit scales\n      scales: compiler.time.scales(encoding),\n      marks: [{\n        _name: 'cell',\n        type: 'group',\n        properties: {\n          enter: {\n            width: layout.cellWidth ? {value: layout.cellWidth} : {group: 'width'},\n            height: layout.cellHeight ? {value: layout.cellHeight} : {group: 'height'}\n          }\n        }\n      }]\n    };\n\n  var group = spec.marks[0];\n\n  // FIXME remove compiler.sort after migrating to vega 2.\n  spec.data = compiler.sort(spec.data, encoding, stats); // append new data\n\n  // marks\n  var style = compiler.style(encoding, stats),\n    mdefs = group.marks = marks.def(encoding, layout, style, stats),\n    mdef = mdefs[mdefs.length - 1];  // TODO: remove this dirty hack by refactoring the whole flow\n\n  var lineType = marks[encoding.marktype()].line;\n\n  // handle subfacets\n\n  var details = encoding.details(),\n    stack = encoding.isAggregate() && details.length > 0 && compiler.stack(spec.data, encoding, mdef); // modify spec.data, mdef.{from,properties}\n\n  if (details.length > 0 && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    compiler.subfacet(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  if (lineType && encoding.config('autoSortLine')) {\n    var f = (encoding.isMeasure(X) && encoding.isDimension(Y)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    // TODO: why - ?\n    mdef.from.transform = [{type: 'sort', by: '-' + encoding.fieldRef(f)}];\n  }\n\n  // get a flattened list of all scale names that are used in the vl spec\n  var singleScaleNames = [].concat.apply([], mdefs.map(function(markProps) {\n    return scale.names(markProps.properties.update);\n  }));\n\n  // Small Multiples\n  if (encoding.has(ROW) || encoding.has(COL)) {\n    spec = compiler.facet(group, encoding, layout, spec, singleScaleNames, stack, stats);\n    spec.legends = legend.defs(encoding, style);\n  } else {\n    group.scales = scale.defs(singleScaleNames, encoding, layout, stats, {stack: stack});\n\n    group.axes = [];\n    if (encoding.has(X)) group.axes.push(axis.def(X, encoding, layout, stats));\n    if (encoding.has(Y)) group.axes.push(axis.def(Y, encoding, layout, stats));\n\n    group.legends = legend.defs(encoding, style);\n  }\n\n  return spec;\n};\n\n","'use strict';\n\nrequire('../globals');\n\nmodule.exports = data;\n\nvar vlfield = require('../field'),\n  util = require('../util'),\n  time = require('./time');\n\n/**\n * Create Vega's data array from a given encoding.\n *\n * @param  {Encoding} encoding\n * @return {Array} Array of Vega data.\n *                 This always includes a \"raw\" data table.\n *                 If the encoding contains aggregate value, this will also create\n *                 aggregate table as well.\n */\nfunction data(encoding) {\n  var def = [data.raw(encoding)];\n\n  var aggregate = data.aggregate(encoding);\n  if (aggregate) def.push(data.aggregate(encoding));\n\n  // TODO add \"having\" filter here\n\n  // append non-positive filter at the end for the data table\n  data.filterNonPositive(def[def.length - 1], encoding);\n\n  return def;\n}\n\ndata.raw = function(encoding) {\n  var raw = {name: RAW};\n\n  // Data source (url or inline)\n  if (encoding.hasValues()) {\n    raw.values = encoding.data().values;\n  } else {\n    raw.url = encoding.data().url;\n    raw.format = {type: encoding.data().formatType};\n  }\n\n  // Set data's format.parse if needed\n  var parse = data.raw.formatParse(encoding);\n  if (parse) {\n    raw.format = raw.format || {};\n    raw.format.parse = parse;\n  }\n\n  raw.transform = data.raw.transform(encoding);\n  return raw;\n};\n\ndata.raw.formatParse = function(encoding) {\n  var parse;\n\n  encoding.forEach(function(field) {\n    if (field.type == T) {\n      parse = parse || {};\n      parse[field.name] = 'date';\n    } else if (field.type == Q) {\n      if (vlfield.isCount(field)) return;\n      parse = parse || {};\n      parse[field.name] = 'number';\n    }\n  });\n\n  return parse;\n};\n\n/**\n * Generate Vega transforms for the raw data table.  This can include\n * transforms for time unit, binning and filtering.\n */\ndata.raw.transform = function(encoding) {\n  // time and bin should come before filter so we can filter by time and bin\n  return data.raw.transform.time(encoding).concat(\n    data.raw.transform.bin(encoding),\n    data.raw.transform.filter(encoding)\n  );\n};\n\nvar BINARY = {\n  '>':  true,\n  '>=': true,\n  '=':  true,\n  '!=': true,\n  '<':  true,\n  '<=': true\n};\n\ndata.raw.transform.time = function(encoding) {\n  return encoding.reduce(function(transform, field, encType) {\n    if (field.type === T && field.timeUnit) {\n      transform.push({\n        type: 'formula',\n        field: encoding.fieldRef(encType),\n        expr: time.formula(field.timeUnit,\n                           encoding.fieldRef(encType, {nofn: true, d: true})\n                          )\n      });\n    }\n    return transform;\n  }, []);\n};\n\ndata.raw.transform.bin = function(encoding) {\n  return encoding.reduce(function(transform, field, encType) {\n    if (encoding.bin(encType)) {\n      transform.push({\n        type: 'bin',\n        field: encoding.fieldRef(encType, {nofn: true}),\n        output: encoding.fieldRef(encType),\n        maxbins: encoding.bin(encType).maxbins\n      });\n    }\n    return transform;\n  }, []);\n};\n\ndata.raw.transform.filter = function(encoding) {\n  var filters = encoding.filter().reduce(function(f, filter) {\n    var condition = '';\n    var operator = filter.operator;\n    var operands = filter.operands;\n\n    var d = 'd.' + (encoding._vega2 ? '' : 'data.');\n\n    if (BINARY[operator]) {\n      // expects a field and a value\n      if (operator === '=') {\n        operator = '==';\n      }\n\n      var op1 = operands[0];\n      var op2 = operands[1];\n      condition = d + op1 + ' ' + operator + ' ' + op2;\n    } else if (operator === 'notNull') {\n      // expects a number of fields\n      for (var j=0; j<operands.length; j++) {\n        condition += d + operands[j] + '!==null';\n        if (j < operands.length - 1) {\n          condition += ' && ';\n        }\n      }\n    } else {\n      util.warn('Unsupported operator: ', operator);\n      return f;\n    }\n    f.push('(' + condition + ')');\n    return f;\n  }, []);\n  if (filters.length === 0) return [];\n\n  return [{\n      type: 'filter',\n      test: filters.join(' && ')\n  }];\n};\n\ndata.aggregate = function(encoding) {\n  var dims = {}, meas = {};\n\n  encoding.forEach(function(field, encType) {\n    if (field.aggregate) {\n      if (field.aggregate === 'count') {\n        meas.count = {op: 'count', field: '*'};\n      }else {\n        meas[field.aggregate + '|' + field.name] = {\n          op: field.aggregate,\n          field: encoding.fieldRef(encType, {nofn: true})\n        };\n      }\n    } else {\n      dims[field.name] = encoding.fieldRef(encType);\n    }\n  });\n\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0) {\n    return {\n      name: AGGREGATE,\n      source: RAW,\n      transform: [{\n        type: 'aggregate',\n        groupby: dims,\n        fields: meas\n      }]\n    };\n  }\n\n  return null;\n};\n\ndata.filterNonPositive = function(dataTable, encoding) {\n  encoding.forEach(function(field, encType) {\n    if (encoding.scale(encType).type === 'log') {\n      dataTable.transform.push({\n        type: 'filter',\n        test: encoding.fieldRef(encType, {d: 1}) + ' > 0'\n      });\n    }\n  });\n};\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util');\n\nvar axis = require('./axis'),\n  scale = require('./scale');\n\nmodule.exports = faceting;\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: 'group',\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: 'width'},\n        height: opt.height || {group: 'height'}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n\nfunction faceting(group, encoding, layout, spec, singleScaleNames, stack, stats) {\n  var enter = group.properties.enter;\n  var facetKeys = [], cellAxes = [], from, axesGrp;\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  enter.fill = {value: encoding.config('cellBackgroundColor')};\n\n  //move \"from\" to cell level and add facet transform\n  group.from = {data: group.marks[0].from.data};\n\n  // Hack, this needs to be refactored\n  for (var i = 0; i < group.marks.length; i++) {\n    var mark = group.marks[i];\n    if (mark.from.transform) {\n      delete mark.from.data; //need to keep transform for subfacetting case\n    } else {\n      delete mark.from;\n    }\n  }\n\n  if (hasRow) {\n    if (!encoding.isDimension(ROW)) {\n      util.error('Row encoding should be ordinal.');\n    }\n    enter.y = {scale: ROW, field: 'keys.' + facetKeys.length};\n    enter.height = {'value': layout.cellHeight}; // HACK\n\n    facetKeys.push(encoding.fieldRef(ROW));\n\n    if (hasCol) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.fieldRef(COL)]});\n    }\n\n    axesGrp = groupdef('x-axes', {\n        axes: encoding.has(X) ? [axis.def(X, encoding, layout, stats)] : undefined,\n        x: hasCol ? {scale: COL, field: 'keys.0'} : {value: 0},\n        width: hasCol && {'value': layout.cellWidth}, //HACK?\n        from: from\n      });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push(axis.def(ROW, encoding, layout, stats));\n  } else { // doesn't have row\n    if (encoding.has(X)) {\n      //keep x axis in the cell\n      cellAxes.push(axis.def(X, encoding, layout, stats));\n    }\n  }\n\n  if (hasCol) {\n    if (!encoding.isDimension(COL)) {\n      util.error('Col encoding should be ordinal.');\n    }\n    enter.x = {scale: COL, field: 'keys.' + facetKeys.length};\n    enter.width = {'value': layout.cellWidth}; // HACK\n\n    facetKeys.push(encoding.fieldRef(COL));\n\n    if (hasRow) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.fieldRef(ROW)]});\n    }\n\n    axesGrp = groupdef('y-axes', {\n      axes: encoding.has(Y) ? [axis.def(Y, encoding, layout, stats)] : undefined,\n      y: hasRow && {scale: ROW, field: 'keys.0'},\n      x: hasRow && {value: 0},\n      height: hasRow && {'value': layout.cellHeight}, //HACK?\n      from: from\n    });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push(axis.def(COL, encoding, layout, stats));\n  } else { // doesn't have col\n    if (encoding.has(Y)) {\n      cellAxes.push(axis.def(Y, encoding, layout, stats));\n    }\n  }\n\n  // assuming equal cellWidth here\n  // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n  spec.scales = (spec.scales || []).concat(scale.defs(\n    scale.names(enter).concat(singleScaleNames),\n    encoding,\n    layout,\n    stats,\n    {stack: stack, facet: true}\n  )); // row/col scales + cell scales\n\n  if (cellAxes.length > 0) {\n    group.axes = cellAxes;\n  }\n\n  // add facet transform\n  var trans = (group.from.transform || (group.from.transform = []));\n  trans.unshift({type: 'facet', keys: facetKeys});\n\n  return spec;\n}\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  time = require('./time'),\n  d3_format = require('d3-format');\n\nmodule.exports = vllayout;\n\nfunction vllayout(encoding, stats) {\n  var layout = box(encoding, stats);\n  layout = offset(encoding, stats, layout);\n  return layout;\n}\n\n/*\n  HACK to set chart size\n  NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  One solution is to update Vega to support auto-sizing\n  In the meantime, auto-padding (mostly) does the trick\n */\nfunction box(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y),\n      marktype = encoding.marktype();\n\n  // FIXME/HACK we need to take filter into account\n  var xCardinality = hasX && encoding.isDimension(X) ? encoding.cardinality(X, stats) : 1,\n    yCardinality = hasY && encoding.isDimension(Y) ? encoding.cardinality(Y, stats) : 1;\n\n  var useSmallBand = xCardinality > encoding.config('largeBandMaxCardinality') ||\n    yCardinality > encoding.config('largeBandMaxCardinality');\n\n  var cellWidth, cellHeight, cellPadding = encoding.config('cellPadding');\n\n  // set cellWidth\n  if (hasX) {\n    if (encoding.isOrdinalScale(X)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellWidth = (xCardinality + encoding.field(X).band.padding) * encoding.bandSize(X, useSmallBand);\n    } else {\n      cellWidth = hasCol || hasRow ? encoding.field(COL).width :  encoding.config('singleWidth');\n    }\n  } else {\n    if (marktype === TEXT) {\n      cellWidth = encoding.config('textCellWidth');\n    } else {\n      cellWidth = encoding.bandSize(X);\n    }\n  }\n\n  // set cellHeight\n  if (hasY) {\n    if (encoding.isOrdinalScale(Y)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellHeight = (yCardinality + encoding.field(Y).band.padding) * encoding.bandSize(Y, useSmallBand);\n    } else {\n      cellHeight = hasCol || hasRow ? encoding.field(ROW).height :  encoding.config('singleHeight');\n    }\n  } else {\n    cellHeight = encoding.bandSize(Y);\n  }\n\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n\n  var width = cellWidth, height = cellHeight;\n  if (hasCol) {\n    var colCardinality = encoding.cardinality(COL, stats);\n    width = cellWidth * ((1 + cellPadding) * (colCardinality - 1) + 1);\n  }\n  if (hasRow) {\n    var rowCardinality =  encoding.cardinality(ROW, stats);\n    height = cellHeight * ((1 + cellPadding) * (rowCardinality - 1) + 1);\n  }\n\n  return {\n    // width and height of the whole cell\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    cellPadding: cellPadding,\n    // width and height of the chart\n    width: width,\n    height: height,\n    // information about x and y, such as band size\n    x: {useSmallBand: useSmallBand},\n    y: {useSmallBand: useSmallBand}\n  };\n}\n\n\n// FIXME fieldStats.max isn't always the longest\nfunction getMaxNumberLength(encoding, et, fieldStats) {\n  var format = encoding.numberFormat(et, fieldStats);\n\n  return d3_format.format(format)(fieldStats.max).length;\n}\n\n// TODO(#600) revise this\nfunction getMaxLength(encoding, stats, et) {\n  var field = encoding.field(et),\n    fieldStats = stats[field.name];\n\n  if (field.bin) {\n    // TODO once bin support range, need to update this\n    return getMaxNumberLength(encoding, et, fieldStats);\n  } if (encoding.isType(et, Q)) {\n    return getMaxNumberLength(encoding, et, fieldStats);\n  } else if (encoding.isType(et, T)) {\n    return time.maxLength(encoding.field(et).timeUnit, encoding);\n  } else if (encoding.isTypes(et, [N, O])) {\n    if(fieldStats.type === 'number') {\n      return getMaxNumberLength(encoding, et, fieldStats);\n    } else {\n      return Math.min(fieldStats.max, encoding.axis(et).maxLabelLength || Infinity);\n    }\n  }\n}\n\nfunction offset(encoding, stats, layout) {\n  [X, Y].forEach(function (et) {\n    // TODO(kanitw): Jul 19, 2015 - create a set of visual test for extraOffset\n    var extraOffset = et === X ? 20 : 22,\n      maxLength;\n    if (encoding.isDimension(et) || encoding.isType(et, T)) {\n      maxLength = getMaxLength(encoding, stats, et);\n    } else if (\n      // TODO once we have #512 (allow using inferred type)\n      // Need to adjust condition here.\n      encoding.isType(et, Q) ||\n      encoding.aggregate(et) === 'count'\n    ) {\n      if (\n        et===Y\n        // || (et===X && false)\n        // FIXME determine when X would rotate, but should move this to axis.js first #506\n      ) {\n        maxLength = getMaxLength(encoding, stats, et);\n      }\n    } else {\n      // nothing\n    }\n\n    if (maxLength) {\n      setter(layout,[et, 'axisTitleOffset'], encoding.config('characterWidth') *  maxLength + extraOffset);\n    } else {\n      // if no max length (no rotation case), use maxLength = 3\n      setter(layout,[et, 'axisTitleOffset'], encoding.config('characterWidth') * 3 + extraOffset);\n    }\n\n  });\n  return layout;\n}\n","'use strict';\n\nrequire('../globals');\n\nvar time = require('./time'),\n  util = require('../util'),\n  setter = util.setter,\n  getter = util.getter;\n\nvar legend = module.exports = {};\n\nlegend.defs = function(encoding, style) {\n  var defs = [];\n\n  if (encoding.has(COLOR) && encoding.field(COLOR).legend) {\n    defs.push(legend.def(COLOR, encoding, {\n      fill: COLOR,\n      orient: 'right'\n    }, style));\n  }\n\n  if (encoding.has(SIZE) && encoding.field(SIZE).legend) {\n    defs.push(legend.def(SIZE, encoding, {\n      size: SIZE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }, style));\n  }\n\n  if (encoding.has(SHAPE) && encoding.field(SHAPE).legend) {\n    if (defs.length === 2) {\n      console.error('Vega-lite currently only supports two legends');\n    }\n    defs.push(legend.def(SHAPE, encoding, {\n      shape: SHAPE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }, style));\n  }\n  return defs;\n};\n\nlegend.def = function(name, encoding, def, style) {\n  var timeUnit = encoding.field(name).timeUnit;\n\n  def.title = legend.title(name, encoding);\n  def = legend.style(name, encoding, def, style);\n\n  if (encoding.isType(name, T) &&\n    timeUnit &&\n    time.hasScale(timeUnit)\n  ) {\n    setter(def, ['properties', 'labels', 'text', 'scale'], 'time-'+ timeUnit);\n  }\n\n  return def;\n};\n\nlegend.style = function(name, e, def, style) {\n  var symbols = getter(def, ['properties', 'symbols']),\n    marktype = e.marktype();\n\n  switch (marktype) {\n    case 'bar':\n    case 'tick':\n    case 'text':\n      symbols.stroke = {value: 'transparent'};\n      symbols.shape = {value: 'square'};\n      break;\n\n    case 'circle':\n    case 'square':\n      symbols.shape = {value: marktype};\n      /* fall through */\n    case 'point':\n      // fill or stroke\n      if (e.field(SHAPE).filled) {\n        if (e.has(COLOR) && name === COLOR) {\n          symbols.fill = {scale: COLOR, field: 'data'};\n        } else {\n          symbols.fill = {value: e.value(COLOR)};\n        }\n        symbols.stroke = {value: 'transparent'};\n      } else {\n        if (e.has(COLOR) && name === COLOR) {\n          symbols.stroke = {scale: COLOR, field: 'data'};\n        } else {\n          symbols.stroke = {value: e.value(COLOR)};\n        }\n        symbols.fill = {value: 'transparent'};\n        symbols.strokeWidth = {value: e.config('strokeWidth')};\n      }\n\n      break;\n    case 'line':\n    case 'area':\n      // TODO use shape here after implementing #508\n      break;\n  }\n\n  var opacity = e.field(COLOR).opacity || style.opacity;\n  if (opacity) {\n    symbols.opacity = {value: opacity};\n  }\n  return def;\n};\n\nlegend.title = function(name, encoding) {\n  var leg = encoding.field(name).legend;\n\n  if (leg.title) return leg.title;\n\n  return encoding.fieldTitle(name);\n};\n","'use strict';\n\nrequire('../globals');\n\nvar marks = module.exports = {};\n\nmarks.def = function(encoding, layout, style, stats) {\n\n  var defs = [],\n    mark = marks[encoding.marktype()],\n    from = encoding.dataTable();\n\n  // to add a background to text, we need to add it before the text\n  if (encoding.marktype() === TEXT && encoding.has(COLOR)) {\n    var bg = {\n      x: {value: 0},\n      y: {value: 0},\n      x2: {value: layout.cellWidth},\n      y2: {value: layout.cellHeight},\n      fill: {scale: COLOR, field: encoding.fieldRef(COLOR)}\n    };\n    defs.push({\n      type: 'rect',\n      from: {data: from},\n      properties: {enter: bg, update: bg}\n    });\n  }\n\n  // add the mark def for the main thing\n  var p = mark.prop(encoding, layout, style, stats);\n  defs.push({\n    type: mark.type,\n    from: {data: from},\n    properties: {enter: p, update: p}\n  });\n\n  return defs;\n};\n\nmarks.bar = {\n  type: 'rect',\n  stack: true,\n  prop: bar_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1}\n};\n\nmarks.line = {\n  type: 'line',\n  line: true,\n  prop: line_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, detail:1}\n};\n\nmarks.area = {\n  type: 'area',\n  stack: true,\n  line: true,\n  requiredEncoding: ['x', 'y'],\n  prop: area_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1}\n};\n\nmarks.tick = {\n  type: 'rect',\n  prop: tick_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, detail: 1}\n};\n\nmarks.circle = {\n  type: 'symbol',\n  prop: filled_point_props('circle'),\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, detail: 1}\n};\n\nmarks.square = {\n  type: 'symbol',\n  prop: filled_point_props('square'),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: 'symbol',\n  prop: point_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, shape: 1, detail: 1}\n};\n\nmarks.text = {\n  type: 'text',\n  prop: text_props,\n  requiredEncoding: ['text'],\n  supportedEncoding: {row: 1, col: 1, size: 1, color: 1, text: 1}\n};\n\nfunction bar_props(e, layout, style) {\n  // jshint unused:false\n\n  var p = {};\n\n  // x's and width\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (!e.has(Y) || e.isDimension(Y)) {\n      p.x2 = {value: 0};\n    }\n  } else {\n    if (e.has(X)) { // is ordinal\n       p.xc = {scale: X, field: e.fieldRef(X)};\n    } else {\n       p.x = {value: 0, offset: e.config('singleBarOffset')};\n    }\n  }\n\n  // width\n  if (!p.x2) {\n    if (!e.has(X) || e.isOrdinalScale(X)) { // no X or X is ordinal\n      if (e.has(SIZE)) {\n        p.width = {scale: SIZE, field: e.fieldRef(SIZE)};\n      } else {\n        p.width = {\n          value: e.bandSize(X, layout.x.useSmallBand),\n          offset: -1\n        };\n      }\n    } else { // X is Quant or Time Scale\n      p.width = {value: 2};\n    }\n  }\n\n  // y's & height\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    p.y2 = {group: 'height'};\n  } else {\n    if (e.has(Y)) { // is ordinal\n      p.yc = {scale: Y, field: e.fieldRef(Y)};\n    } else {\n      p.y2 = {group: 'height', offset: -e.config('singleBarOffset')};\n    }\n\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.fieldRef(SIZE)};\n    } else {\n      p.height = {\n        value: e.bandSize(Y, layout.y.useSmallBand),\n        offset: -1\n      };\n    }\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // opacity\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction point_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.fieldRef(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.value(SIZE)};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.fieldRef(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.value(SHAPE)};\n  }\n\n  // fill or stroke\n  if (e.field(SHAPE).filled) {\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n  } else {\n    if (e.has(COLOR)) {\n      p.stroke = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.stroke = {value: e.value(COLOR)};\n    }\n    p.strokeWidth = {value: e.config('strokeWidth')};\n  }\n\n  // opacity\n  var opacity = e.field(COLOR).opacity || style.opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction line_props(e,layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction area_props(e, layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: 'horizontal'};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else {\n    p.y = {group: 'height'};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction tick_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (e.isDimension(X)) {\n      p.x.offset = -e.bandSize(X, layout.x.useSmallBand) / 3;\n    }\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    if (e.isDimension(Y)) {\n      p.y.offset = -e.bandSize(Y, layout.y.useSmallBand) / 3;\n    }\n  } else if (!e.has(Y)) {\n    p.y = {value: 0};\n  }\n\n  // width\n  if (!e.has(X) || e.isDimension(X)) {\n    p.width = {value: e.bandSize(X, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.width = {value: 1};\n  }\n\n  // height\n  if (!e.has(Y) || e.isDimension(Y)) {\n    p.height = {value: e.bandSize(Y, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.height = {value: 1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity  || style.opacity;\n  if(opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, layout, style) {\n    var p = {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.fieldRef(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.fieldRef(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.fieldRef(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.value(SIZE)};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n\n    var opacity = e.field(COLOR).opacity  || style.opacity;\n    if(opacity) p.opacity = {value: opacity};\n\n    return p;\n  };\n}\n\nfunction text_props(e, layout, style, stats) {\n  var p = {},\n    field = e.field(TEXT);\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    if (e.has(TEXT) && e.isType(TEXT, Q)) {\n      p.x = {value: layout.cellWidth-5};\n    } else {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.fieldRef(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.fontSize = {value: field.font.size};\n  }\n\n  // fill\n  // color should be set to background\n  p.fill = {value: field.color};\n\n  var opacity = e.field(COLOR).opacity  || style.opacity;\n  if(opacity) p.opacity = {value: opacity};\n\n  // text\n  if (e.has(TEXT)) {\n    if (e.isType(TEXT, Q)) {\n      var fieldStats = stats[e.fieldName(TEXT)],\n        numberFormat = field.format || e.numberFormat(fieldStats);\n\n      p.text = {template: '{{' + e.fieldRef(TEXT) + ' | number:\\'' +\n        numberFormat +'\\'}}'};\n      p.align = {value: field.align};\n    } else {\n      p.text = {field: e.fieldRef(TEXT)};\n    }\n  } else {\n    p.text = {value: field.placeholder};\n  }\n\n  p.font = {value: field.font.family};\n  p.fontWeight = {value: field.font.weight};\n  p.fontStyle = {value: field.font.style};\n  p.baseline = {value: field.baseline};\n\n  return p;\n}\n","'use strict';\nrequire('../globals');\nvar util = require('../util'),\n  time = require('./time'),\n  colorbrewer = require('colorbrewer'),\n  interpolate = require('d3-color').interpolateHsl,\n  schema = require('../schema/schema'),\n  vlsort = require('./sort');\n\nvar scale = module.exports = {};\n\nscale.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\nscale.defs = function(names, encoding, layout, stats, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale.type(name, encoding),\n      domain: scale.domain(name, encoding, stats, opt)\n    };\n\n    s.sort = scale.sort(s, encoding, name) || undefined;\n\n    scale.range(s, encoding, layout, stats, opt);\n\n    return (a.push(s), a);\n  }, []);\n};\n\nscale.sort = function(s, encoding, name) {\n  return s.type === 'ordinal' && (\n    !!encoding.bin(name) ||\n    encoding.sort(name).length === 0\n  );\n};\n\nscale.type = function(name, encoding) {\n\n  switch (encoding.type(name)) {\n    case N: //fall through\n    case O: return 'ordinal';\n    case T:\n      var timeUnit = encoding.field(name).timeUnit;\n      return timeUnit ? time.scale.type(timeUnit, name) : 'time';\n    case Q:\n      if (encoding.bin(name)) {\n        return name === COLOR ? 'linear' : 'ordinal';\n      }\n      return encoding.scale(name).type;\n  }\n};\n\nscale.domain = function (name, encoding, stats, opt) {\n  var field = encoding.field(name);\n\n  if (encoding.isType(name, T)) {\n    var range = time.scale.domain(field.timeUnit, name);\n    if(range) return range;\n  }\n\n  if (field.bin) {\n    // TODO(kanitw): this must be changed in vg2\n    var fieldStat = stats[field.name],\n      bins = util.getbins(fieldStat, field.bin.maxbins || schema.MAXBINS_DEFAULT),\n      numbins = (bins.stop - bins.start) / bins.step;\n    return util.range(numbins).map(function(i) {\n      return bins.start + bins.step * i;\n    });\n  }\n\n  if (name == opt.stack) {\n    return {\n      data: STACKED,\n      field: encoding.fieldRef(name, {\n        data: !encoding._vega2,\n        prefn: (opt.facet ? 'max_' : '') + 'sum_'\n      })\n    };\n  }\n  var aggregate = encoding.aggregate(name),\n    timeUnit = field.timeUnit,\n    scaleUseRawDomain = encoding.scale(name).useRawDomain,\n    useRawDomain = scaleUseRawDomain !== undefined ?\n      scaleUseRawDomain : encoding.config('useRawDomain'),\n    notCountOrSum = !aggregate || (aggregate !=='count' && aggregate !== 'sum');\n\n  // FIXME revise this part\n\n  if ( useRawDomain && notCountOrSum && (\n      // Q always uses non-ordinal scale except when it's binned and thus uses ordinal scale.\n      (encoding.isType(name, Q) && !field.bin) ||\n      // T uses non-ordinal scale when there's no unit or when the unit is not ordinal.\n      (encoding.isType(name, T) && (!timeUnit || !time.isOrdinalFn(timeUnit)))\n    )\n  ) {\n    return {data: RAW, field: encoding.fieldRef(name, {nofn: !timeUnit})};\n  }\n\n  var data = encoding.sort(name, stats).length > 0 ?\n    vlsort.getDataName(name):\n    encoding.dataTable();\n\n  return {data: data, field: encoding.fieldRef(name)};\n};\n\n\nscale.range = function (s, encoding, layout, stats) {\n  var spec = encoding.scale(s.name),\n    field = encoding.field(s.name),\n    timeUnit = field.timeUnit;\n\n  switch (s.name) {\n    case X:\n      s.range = layout.cellWidth ? [0, layout.cellWidth] : 'width';\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(X, layout.x.useSmallBand);\n      } else {\n        if (encoding.isType(s.name,T) && timeUnit === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n      s.round = true;\n      if (s.type === 'time') {\n        s.nice = timeUnit || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (s.type === 'ordinal') {\n        s.range = layout.cellHeight ?\n          (field.bin ? [layout.cellHeight, 0] : [0, layout.cellHeight]) :\n          'height';\n        s.bandWidth = encoding.bandSize(Y, layout.y.useSmallBand);\n      } else {\n        s.range = layout.cellHeight ? [layout.cellHeight, 0] : 'height';\n        if (encoding.isType(s.name,T) && timeUnit === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n\n      s.round = true;\n\n      if (s.type === 'time') {\n        s.nice = timeUnit || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case ROW: // support only ordinal\n      s.bandWidth = layout.cellHeight;\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL: // support only ordinal\n      s.bandWidth = layout.cellWidth;\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is('bar')) {\n        // FIXME this is definitely incorrect\n        // but let's fix it later since bar size is a bad encoding anyway\n        s.range = [3, Math.max(encoding.bandSize(X), encoding.bandSize(Y))];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else { //point\n        var bandSize = Math.min(encoding.bandSize(X), encoding.bandSize(Y)) - 1;\n        s.range = [10, 0.8 * bandSize*bandSize];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = 'shapes';\n      break;\n    case COLOR:\n      s.range = scale.color(s, encoding, stats);\n      if (s.type !== 'ordinal') s.zero = false;\n      break;\n    default:\n      throw new Error('Unknown encoding name: '+ s.name);\n  }\n\n  // FIXME(kanitw): Jul 29, 2015 - consolidate this with above\n  switch (s.name) {\n    case ROW:\n    case COL:\n      s.padding = encoding.config('cellPadding');\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (s.type === 'ordinal') { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.field(s.name).band.padding;\n      }\n  }\n};\n\nscale.color = function(s, encoding, stats) {\n  var colorScale = encoding.scale(COLOR),\n    range = colorScale.range,\n    cardinality = encoding.cardinality(COLOR, stats),\n    type = encoding.type(COLOR);\n\n  if (range === undefined) {\n    var ordinalPalette = colorScale.ordinalPalette,\n      quantitativeRange = colorScale.quantitativeRange;\n\n    if (s.type === 'ordinal') {\n      if (type === N) {\n        // use categorical color scale\n        if (cardinality <= 10) {\n          range = colorScale.c10palette;\n        } else {\n          range = colorScale.c20palette;\n        }\n        return scale.color.palette(range, cardinality, type);\n      } else {\n        if (ordinalPalette) {\n          return scale.color.palette(ordinalPalette, cardinality, type);\n        }\n        return scale.color.interpolate(quantitativeRange[0], quantitativeRange[1], cardinality);\n      }\n    } else { //time or quantitative\n      return [quantitativeRange[0], quantitativeRange[1]];\n    }\n  }\n};\n\nscale.color.palette = function(range, cardinality, type) {\n  // FIXME(kanitw): Jul 29, 2015 - check range is string\n  switch (range) {\n    case 'category10k':\n      // tableau's category 10, ordered by perceptual kernel study results\n      // https://github.com/uwdata/perceptual-kernels\n      return ['#2ca02c', '#e377c2', '#7f7f7f', '#17becf', '#8c564b', '#d62728', '#bcbd22', '#9467bd', '#ff7f0e', '#1f77b4'];\n\n    // d3/tableau category10/20/20b/20c\n    case 'category10':\n      return ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];\n\n    case 'category20':\n      return ['#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'];\n\n    case 'category20b':\n      return ['#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39', '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b', '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'];\n\n    case 'category20c':\n      return ['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#e6550d', '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354', '#74c476', '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc', '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9'];\n  }\n\n  // TODO add our own set of custom ordinal color palette\n\n  if (range in colorbrewer) {\n    var palette = colorbrewer[range];\n\n    // if cardinality pre-defined, use it.\n    if (cardinality in palette) return palette[cardinality];\n\n    // if not, use the highest cardinality one for nominal\n    if (type === N) {\n      return palette[Math.max.apply(null, util.keys(palette))];\n    }\n\n    // otherwise, interpolate\n    var ps = cardinality < 3 ? 3 : Math.max.apply(null, util.keys(palette)),\n      from = 0 , to = ps - 1;\n    // FIXME add config for from / to\n\n    return scale.color.interpolate(palette[ps][from], palette[ps][to], cardinality);\n  }\n\n  return range;\n};\n\nscale.color.interpolate = function (start, end, cardinality) {\n\n  var interpolator = interpolate(start, end);\n  return util.range(cardinality).map(function(i) { return interpolator(i*1.0/(cardinality-1)); });\n};\n","'use strict';\n\nrequire('../globals');\n\nvar vlfield = require('../field');\n\nmodule.exports = sort;\n\n// adds new transforms that produce sorted fields\nfunction sort(data, encoding, stats, opt) {\n  // jshint unused:false\n\n  var datasetMapping = {};\n\n  encoding.forEach(function(field, encType) {\n    var sortBy = encoding.sort(encType, stats);\n    if (sortBy.length > 0) {\n      var fields = sortBy.map(function(d) {\n        return {\n          op: d.aggregate,\n          field: vlfield.fieldRef(d, {nofn: true, data: !encoding._vega2})\n        };\n      });\n\n      var byClause = sortBy.map(function(d) {\n        var reverse = (d.reverse ? '-' : '');\n        return reverse + vlfield.fieldRef(d, {data: !encoding._vega2});\n      });\n\n      var dataName = sort.getDataName(encType);\n\n      var transforms = [\n        {\n          type: 'aggregate',\n          groupby: [ encoding.fieldRef(encType) ],\n          fields: fields\n        },\n        {\n          type: 'sort',\n          by: byClause\n        }\n      ];\n\n      data.push({\n        name: dataName,\n        source: RAW,\n        transform: transforms\n      });\n\n      datasetMapping[encType] = dataName;\n    }\n  });\n\n  return data;\n}\n\nsort.getDataName = function(encType) {\n  return 'sorted-' + encType;\n};\n\n","'use strict';\n\nrequire('../globals');\n\nvar  marks = require('./marks');\n\nmodule.exports = stacking;\n\nfunction stacking(data, encoding, mdef) {\n  if (!marks[encoding.marktype()].stack) return false;\n\n  // TODO: add || encoding.has(LOD) here once LOD is implemented\n  if (!encoding.has(COLOR)) return false;\n\n  var dim=null, val=null, idx =null,\n    isXMeasure = encoding.isMeasure(X),\n    isYMeasure = encoding.isMeasure(Y),\n    facets = encoding.facets();\n\n  if (isXMeasure && !isYMeasure) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  } else if (isYMeasure && !isXMeasure) {\n    dim = X;\n    val = Y;\n    idx = 1;\n  } else {\n    return null; // no stack encoding\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: encoding.dataTable(),\n    transform: [{\n      type: 'aggregate',\n      groupby: [encoding.fieldRef(dim)].concat(facets), // dim and other facets\n      fields: [{op: 'sum', field: encoding.fieldRef(val)}] // TODO check if field with aggregate is correct?\n    }]\n  };\n\n  if (facets && facets.length > 0) {\n    stacked.transform.push({ //calculate max for each facet\n      type: 'aggregate',\n      groupby: facets,\n      fields: [{\n        op: 'max',\n        field: encoding.fieldName(val, {fn: 'sum'})\n      }]\n    });\n  }\n\n  data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: 'stack',\n    point: encoding.fieldRef(dim),\n    height: encoding.fieldRef(val),\n    output: {y1: val, y0: val + '2'}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val + '2'] = mdef.properties.enter[val + '2'] = {scale: val, field: val + '2'};\n\n  return val; //return stack encoding\n}\n","'use strict';\n\nrequire('../globals');\n\nvar vlfield = require('../field');\n\nmodule.exports = function(encoding, stats) {\n  return {\n    opacity: estimateOpacity(encoding, stats),\n  };\n};\n\nfunction estimateOpacity(encoding,stats) {\n  if (!stats) {\n    return 1;\n  }\n\n  var numPoints = 0;\n\n  if (encoding.isAggregate()) { // aggregate plot\n    numPoints = 1;\n\n    //  get number of points in each \"cell\"\n    //  by calculating product of cardinality\n    //  for each non faceting and non-ordinal X / Y fields\n    //  note that ordinal x,y are not include since we can\n    //  consider that ordinal x are subdividing the cell into subcells anyway\n    encoding.forEach(function(field, encType) {\n\n      if (encType !== ROW && encType !== COL &&\n          !((encType === X || encType === Y) &&\n          vlfield.isOrdinalScale(field))\n        ) {\n        numPoints *= encoding.cardinality(encType, stats);\n      }\n    });\n\n  } else { // raw plot\n\n    // TODO: error handling\n    if (!stats['*'])\n      return 1;\n\n    numPoints = stats['*'].max;  // count\n\n    // small multiples divide number of points\n    var numMultiples = 1;\n    if (encoding.has(ROW)) {\n      numMultiples *= encoding.cardinality(ROW, stats);\n    }\n    if (encoding.has(COL)) {\n      numMultiples *= encoding.cardinality(COL, stats);\n    }\n    numPoints /= numMultiples;\n  }\n\n  var opacity = 0;\n  if (numPoints <= 25) {\n    opacity = 1;\n  } else if (numPoints < 200) {\n    opacity = 0.8;\n  } else if (numPoints < 1000 || encoding.is('tick')) {\n    opacity = 0.7;\n  } else {\n    opacity = 0.3;\n  }\n\n  return opacity;\n}\n\n","'use strict';\n\nrequire('../globals');\n\nmodule.exports = subfaceting;\n\nfunction subfaceting(group, mdef, details, stack, encoding) {\n  var m = group.marks;\n  var g = {\n    _name: 'subfacet',\n    type: 'group',\n    from: mdef.from,\n    properties: {\n      enter: {\n        width: {group: 'width'},\n        height: {group: 'height'}\n      }\n    },\n    marks: m\n  };\n\n  group.marks = [g];\n  delete mdef.from; // (move to the new g)\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: 'facet', keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: 'sort', by: encoding.fieldRef(COLOR)});\n  }\n}\n","'use strict';\n\nvar util = require('../util'),\n  d3_time_format = require('d3-time-format');\n\nvar time = module.exports = {};\n\n// 'Wednesday September 17 04:00:00 2014'\n// Wednesday is the longest date\n// September is the longest month (8 in javascript as it is zero-indexed).\nvar LONG_DATE = new Date(Date.UTC(2014, 8, 17));\n\ntime.cardinality = function(field, stats, filterNull, type) {\n  var timeUnit = field.timeUnit;\n  switch (timeUnit) {\n    case 'seconds': return 60;\n    case 'minutes': return 60;\n    case 'hours': return 24;\n    case 'day': return 7;\n    case 'date': return 31;\n    case 'month': return 12;\n    case 'year':\n      var stat = stats[field.name],\n        yearstat = stats['year_'+field.name];\n\n      if (!yearstat) { return null; }\n\n      return yearstat.distinct -\n        (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n  }\n\n  return null;\n};\n\ntime.formula = function(timeUnit, fieldRef) {\n  // TODO(kanitw): add formula to other time format\n  var fn = 'utc' + timeUnit;\n  return fn + '(' + fieldRef + ')';\n};\n\ntime.maxLength = function(timeUnit, encoding) {\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'date':\n      return 2;\n    case 'month':\n    case 'day':\n      var range = time.range(timeUnit, encoding);\n      if (range) {\n        // return the longest name in the range\n        return Math.max.apply(null, range.map(function(r) {return r.length;}));\n      }\n      return 2;\n    case 'year':\n      return 4; //'1998'\n  }\n  // TODO(#600) revise this\n  // no time unit\n  var timeFormat = encoding.config('timeFormat');\n  return d3_time_format.utcFormat(timeFormat)(LONG_DATE).length;\n};\n\ntime.range = function(timeUnit, encoding) {\n  var labelLength = encoding.config('timeScaleLabelLength'),\n    scaleLabel;\n  switch (timeUnit) {\n    case 'day':\n      scaleLabel = encoding.config('dayScaleLabel');\n      break;\n    case 'month':\n      scaleLabel = encoding.config('monthScaleLabel');\n      break;\n  }\n  if (scaleLabel) {\n    return labelLength ? scaleLabel.map(\n        function(s) { return s.substr(0, labelLength);}\n      ) : scaleLabel;\n  }\n  return;\n};\n\n\n/**\n * @param  {Object} encoding\n * @return {Array}  scales for time unit names\n */\ntime.scales = function(encoding) {\n  var scales = encoding.reduce(function(scales, field) {\n    var timeUnit = field.timeUnit;\n    if (field.type === T && timeUnit && !scales[timeUnit]) {\n      var scale = time.scale.def(field.timeUnit, encoding);\n      if (scale) scales[timeUnit] = scale;\n    }\n    return scales;\n  }, {});\n\n  return util.vals(scales);\n};\n\n\ntime.scale = {};\n\n/** append custom time scales for axis label */\ntime.scale.def = function(timeUnit, encoding) {\n  var range = time.range(timeUnit, encoding);\n\n  if (range) {\n    return {\n      name: 'time-'+timeUnit,\n      type: 'ordinal',\n      domain: time.scale.domain(timeUnit),\n      range: range\n    };\n  }\n  return null;\n};\n\ntime.isOrdinalFn = function(timeUnit) {\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'day':\n    case 'date':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\ntime.scale.type = function(timeUnit, name) {\n  if (name === COLOR) {\n    return 'linear'; // time has order, so use interpolated ordinal color scale.\n  }\n\n  return time.isOrdinalFn(timeUnit) || name === COL || name === ROW ? 'ordinal' : 'linear';\n};\n\ntime.scale.domain = function(timeUnit, name) {\n  var isColor = name === COLOR;\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes': return isColor ? [0,59] : util.range(0, 60);\n    case 'hours': return isColor ? [0,23] : util.range(0, 24);\n    case 'day': return isColor ? [0,6] : util.range(0, 7);\n    case 'date': return isColor ? [1,31] : util.range(1, 32);\n    case 'month': return isColor ? [0,11] : util.range(0, 12);\n  }\n  return null;\n};\n\n/** whether a particular time function has custom scale for labels implemented in time.scale */\ntime.hasScale = function(timeUnit) {\n  switch (timeUnit) {\n    case 'day':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n","'use strict';\n\nrequire('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, TEXT, DETAIL];\n\nconsts.shorthand = {\n  delim:  '|',\n  assign: '=',\n  type:   ',',\n  func:   '_'\n};\n","'use strict';\n\nrequire('./globals');\n\nvar stats = require('datalib/src/stats');\n\nvar vldata = module.exports = {};\n\n/** Mapping from datalib's inferred type to Vega-lite's type */\nvldata.types = {\n  'boolean': N,\n  'number': Q,\n  'integer': Q,\n  'date': T,\n  'string': N\n};\n\nvldata.stats = function(data) {\n  var summary = stats.summary(data);\n\n  return summary.reduce(function(s, profile) {\n    s[profile.field] = profile;\n    return s;\n  }, {\n    '*': {\n      max: data.length,\n      min: 0\n    }\n  });\n};","// utility for enc\n\n'use strict';\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  vlfield = require('./field'),\n  util = require('./util'),\n  schema = require('./schema/schema'),\n  encTypes = schema.encTypes;\n\nvar vlenc = module.exports = {};\n\nvlenc.countRetinal = function(enc) {\n  var count = 0;\n  if (enc.color) count++;\n  if (enc.size) count++;\n  if (enc.shape) count++;\n  return count;\n};\n\nvlenc.has = function(enc, encType) {\n  var fieldDef = enc && enc[encType];\n  return fieldDef && fieldDef.name;\n};\n\nvlenc.isAggregate = function(enc) {\n  for (var k in enc) {\n    if (vlenc.has(enc, k) && enc[k].aggregate) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvlenc.forEach = function(enc, f) {\n  var i = 0;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      f(enc[k], k, i++);\n    }\n  });\n};\n\nvlenc.map = function(enc, f) {\n  var arr = [];\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      arr.push(f(enc[k], k, enc));\n    }\n  });\n  return arr;\n};\n\nvlenc.reduce = function(enc, f, init) {\n  var r = init;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      r = f(r, enc[k], k,  enc);\n    }\n  });\n  return r;\n};\n\n/*\n * return key-value pairs of field name and list of fields of that field name\n */\nvlenc.fields = function(enc) {\n  return vlenc.reduce(enc, function (m, field) {\n    var fieldList = m[field.name] = m[field.name] || [],\n      containsType = fieldList.containsType = fieldList.containsType || {};\n\n    if (fieldList.indexOf(field) === -1) {\n      fieldList.push(field);\n      // augment the array with containsType.Q / O / N / T\n      containsType[field.type] = true;\n    }\n    return m;\n  }, {});\n};\n\nvlenc.shorthand = function(enc) {\n  return vlenc.map(enc, function(field, et) {\n    return et + c.assign + vlfield.shorthand(field);\n  }).join(c.delim);\n};\n\nvlenc.fromShorthand = function(shorthand) {\n  var enc = util.isArray(shorthand) ? shorthand : shorthand.split(c.delim);\n  return enc.reduce(function(m, e) {\n    var split = e.split(c.assign),\n        enctype = split[0].trim(),\n        field = split[1];\n\n    m[enctype] = vlfield.fromShorthand(field);\n    return m;\n  }, {});\n};\n","'use strict';\n\n// utility for field\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compiler/time'),\n  util = require('./util'),\n  schema = require('./schema/schema');\n\nvar vlfield = module.exports = {};\n\n/**\n * @param field\n * @param opt\n *   opt.nofn -- exclude bin, aggregate, timeUnit\n *   opt.data - include 'data.'\n *   opt.d - include 'd.'\n *   opt.fn - replace fn with custom function prefix\n *   opt.prefn - prepend fn with custom function prefix\n\n * @return {[type]}       [description]\n */\nvlfield.fieldRef = function(field, opt) {\n  opt = opt || {};\n\n  var f = (opt.d ? 'd.' : '') +\n          (opt.data ? 'data.' : '') +\n          (opt.prefn || ''),\n    nofn = opt.nofn || opt.fn,\n    name = field.name;\n\n  if (vlfield.isCount(field)) {\n    return f + 'count';\n  } else if (!nofn && field.bin) {\n    return f + 'bin_' + name;\n  } else if (!nofn && field.aggregate) {\n    return f + field.aggregate + '_' + name;\n  } else if (!nofn && field.timeUnit) {\n    return f + field.timeUnit + '_' + name;\n  } else if (opt.fn) {\n    return f + opt.fn + '_' + name;\n  } else {\n    return f + name;\n  }\n};\n\nvlfield.shorthand = function(f) {\n  var c = consts.shorthand;\n  return (f.aggregate ? f.aggregate + c.func : '') +\n    (f.timeUnit ? f.timeUnit + c.func : '') +\n    (f.bin ? 'bin' + c.func : '') +\n    (f.name || '') + c.type + f.type;\n};\n\nvlfield.shorthands = function(fields, delim) {\n  delim = delim || c.delim;\n  return fields.map(vlfield.shorthand).join(delim);\n};\n\nvlfield.fromShorthand = function(shorthand) {\n  var split = shorthand.split(c.type), i;\n  var o = {\n    name: split[0].trim(),\n    type: split[1].trim()\n  };\n\n  // check aggregate type\n  for (i in schema.aggregate.enum) {\n    var a = schema.aggregate.enum[i];\n    if (o.name.indexOf(a + '_') === 0) {\n      o.name = o.name.substr(a.length + 1);\n      if (a == 'count' && o.name.length === 0) o.name = '*';\n      o.aggregate = a;\n      break;\n    }\n  }\n\n  // check time timeUnit\n  for (i in schema.timefns) {\n    var tu = schema.timefns[i];\n    if (o.name && o.name.indexOf(tu + '_') === 0) {\n      o.name = o.name.substr(o.length + 1);\n      o.timeUnit = tu;\n      break;\n    }\n  }\n\n  // check bin\n  if (o.name && o.name.indexOf('bin_') === 0) {\n    o.name = o.name.substr(4);\n    o.bin = true;\n  }\n\n  return o;\n};\n\nvar isType = vlfield.isType = function (fieldDef, type) {\n  return fieldDef.type === type;\n};\n\nvar isTypes = vlfield.isTypes = function (fieldDef, types) {\n  for (var t=0; t<types.length; t++) {\n    if(fieldDef.type === types[t]) return true;\n  }\n  return false;\n};\n\n/*\n * Most fields that use ordinal scale are dimensions.\n * However, YEAR(T), YEARMONTH(T) use time scale, not ordinal but are dimensions too.\n */\nvlfield.isOrdinalScale = function(field) {\n  return  isTypes(field, [N, O]) || field.bin ||\n    ( isType(field, T) && field.timeUnit && time.isOrdinalFn(field.timeUnit) );\n};\n\nfunction isDimension(field) {\n  return  isTypes(field, [N, O]) || !!field.bin ||\n    ( isType(field, T) && !!field.timeUnit );\n}\n\n/**\n * For encoding, use encoding.isDimension() to avoid confusion.\n * Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.isDimension = function(field) {\n  return field && isDimension(field);\n};\n\nvlfield.isMeasure = function(field) {\n  return field && !isDimension(field);\n};\n\nvlfield.count = function() {\n  return {name:'*', aggregate: 'count', type: Q, displayName: vlfield.count.displayName};\n};\n\nvlfield.count.displayName = 'Number of Records';\n\nvlfield.isCount = function(field) {\n  return field.aggregate === 'count';\n};\n\n/**\n * For encoding, use encoding.cardinality() to avoid confusion.  Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.cardinality = function(field, stats, filterNull) {\n  // FIXME need to take filter into account\n\n  var stat = stats[field.name];\n  var type = field.type;\n\n  filterNull = filterNull || {};\n\n  if (field.bin) {\n    var bins = util.getbins(stat, field.bin.maxbins || schema.MAXBINS_DEFAULT);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  if (isType(field, T)) {\n    var cardinality = time.cardinality(field, stats, filterNull, type);\n    if(cardinality !== null) return cardinality;\n    //otherwise use calculation below\n  }\n  if (field.aggregate) {\n    return 1;\n  }\n\n  // remove null\n  return stat.distinct -\n    (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n};\n","'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.AGGREGATE = 'aggregate';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.N = 'N';\ng.O = 'O';\ng.Q = 'Q';\ng.T = 'T';\n","'use strict';\n\n// TODO(kanitw): chat with Vega team and possibly move this to vega-logging\nmodule.exports = function(prefix) {\n  // Borrowed some ideas from http://stackoverflow.com/a/15653260/866989\n  // and https://github.com/patik/console.log-wrapper/blob/master/consolelog.js\n  var METHODS = ['error', 'info', 'debug', 'warn', 'log'];\n\n  return METHODS.reduce(function(logger, fn) {\n    var cfn = console[fn] ? fn : 'log';\n    if (console[cfn].bind === 'undefined') { // IE < 10\n        logger[fn] = Function.prototype.bind.call(console[cfn], console, prefix);\n    }\n    else {\n        logger[fn] = console[cfn].bind(console, prefix);\n    }\n    return logger;\n  }, {});\n};","// Package of defining Vega-lite Specification's json schema\n'use strict';\n\nrequire('../globals');\n\nvar schema = module.exports = {},\n  util = require('../util'),\n  toMap = util.toMap,\n  colorbrewer = require('colorbrewer');\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: 'string',\n  enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\n};\n\nschema.aggregate = {\n  type: 'string',\n  enum: ['avg', 'sum', 'median', 'min', 'max', 'count'],\n  supportedEnums: {\n    Q: ['avg', 'median', 'sum', 'min', 'max', 'count'],\n    O: ['median','min','max'],\n    N: [],\n    T: ['avg', 'median', 'min', 'max'],\n    '': ['count']\n  },\n  supportedTypes: toMap([Q, N, O, T, ''])\n};\n\nschema.getSupportedRole = function(encType) {\n  return schema.schema.properties.encoding.properties[encType].supportedRole;\n};\n\nschema.timeUnits = ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'];\n\nschema.defaultTimeFn = 'month';\n\nschema.timeUnit = {\n  type: 'string',\n  enum: schema.timeUnits,\n  supportedTypes: toMap([T])\n};\n\nschema.scale_type = {\n  type: 'string',\n  // TODO(kanitw) read vega's schema here, add description\n  enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\n  default: 'linear',\n  supportedTypes: toMap([Q])\n};\n\nschema.field = {\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string'\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nschema.MAXBINS_DEFAULT = 15;\n\nvar bin = {\n  type: ['boolean', 'object'],\n  default: false,\n  properties: {\n    maxbins: {\n      type: 'integer',\n      default: schema.MAXBINS_DEFAULT,\n      minimum: 2,\n      description: 'Maximum number of bins.'\n    }\n  },\n  supportedTypes: toMap([Q]) // TODO: add O after finishing #81\n};\n\nvar typicalField = merge(clone(schema.field), {\n  type: 'object',\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T]\n    },\n    aggregate: schema.aggregate,\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    scale: {\n      type: 'object',\n      properties: {\n        /* Common Scale Properties */\n        type: schema.scale_type,\n        reverse: {\n          type: 'boolean',\n          default: false,\n          supportedTypes: toMap([Q, T])\n        },\n\n        /* Quantitative Scale Properties */\n        nice: {\n          type: 'string',\n          enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\n          supportedTypes: toMap([T])\n        },\n        zero: {\n          type: 'boolean',\n          description: 'Include zero',\n          default: true,\n          supportedTypes: toMap([Q, T])\n        },\n\n        /* Vega-lite only Properties */\n        useRawDomain: {\n          type: 'boolean',\n          default: undefined,\n          description: 'Use the raw data range as scale domain instead of ' +\n                       'aggregated data for aggregate axis. ' +\n                       'This option does not work with sum or count aggregate' +\n                       'as they might have a substantially larger scale range.' +\n                       'By default, use value from config.useRawDomain.'\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: 'object',\n  supportedRole: {\n    dimension: true\n  },\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T] // ordinal-only field supports Q when bin is applied and T when time unit is applied.\n    },\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    aggregate: {\n      type: 'string',\n      enum: ['count'],\n      supportedTypes: toMap([N, O]) // FIXME this looks weird to me\n    }\n  }\n});\n\nvar axisMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true},\n  properties: {\n    axis: {\n      type: 'object',\n      properties: {\n        /* Vega Axis Properties */\n        format: {\n          type: 'string',\n          default: undefined,  // auto\n          description: 'The formatting pattern for axis labels. '+\n                       'If not undefined, this will be determined by ' +\n                       'small/largeNumberFormat and the max value ' +\n                       'of the field.'\n        },\n        grid: {\n          type: 'boolean',\n          default: true,\n          description: 'A flag indicate if gridlines should be created in addition to ticks.'\n        },\n        layer: {\n          type: 'string',\n          default: 'back',\n          description: 'A string indicating if the axis (and any gridlines) should be placed above or below the data marks. One of \"front\" (default) or \"back\".'\n        },\n        orient: {\n          type: 'string',\n          default: undefined,\n          enum: ['top', 'right', 'left', 'bottom'],\n          description: 'The orientation of the axis. One of top, bottom, left or right. The orientation can be used to further specialize the axis type (e.g., a y axis oriented for the right edge of the chart).'\n        },\n        ticks: {\n          type: 'integer',\n          default: 5,\n          minimum: 0,\n          description: 'A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale\\'s range.'\n        },\n        /* Vega Axis Properties that are automatically populated by Vega-lite */\n        title: {\n          type: 'string',\n          default: undefined,\n          description: 'A title for the axis. (Shows field name and its function by default.)'\n        },\n        /* Vega-lite only */\n        maxLabelLength: {\n          type: 'integer',\n          default: 25,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        },\n        labelAngle: {\n          type: 'integer',\n          default: undefined, // auto\n          minimum: 0,\n          maximum: 360,\n          description: 'Angle by which to rotate labels. Set to 0 to force horizontal.'\n        },\n        titleMaxLength: {\n          type: 'integer',\n          default: undefined,\n          minimum: 0,\n          description: 'Max length for axis title if the title is automatically generated from the field\\'s description'\n        },\n        titleOffset: {\n          type: 'integer',\n          default: undefined,  // auto\n          description: 'A title offset value for the axis.'\n        },\n      }\n    }\n  }\n};\n\nvar sortMixin = {\n  type: 'object',\n  properties: {\n    sort: {\n      type: 'array',\n      default: [],\n      items: {\n        type: 'object',\n        supportedTypes: toMap([N, O]),\n        required: ['name', 'aggregate'],\n        properties: {\n          name: {\n            type: 'string'\n          },\n          aggregate: {\n            type: 'string',\n            enum: ['avg', 'sum', 'min', 'max', 'count']\n          },\n          reverse: {\n            type: 'boolean',\n            default: false\n          }\n        }\n      }\n    }\n  }\n};\n\nvar bandMixin = {\n  type: 'object',\n  properties: {\n    band: {\n      type: 'object',\n      properties: {\n        size: {\n          type: 'integer',\n          minimum: 0,\n          default: undefined\n        },\n        padding: {\n          type: 'integer',\n          minimum: 0,\n          default: 1\n        }\n      }\n    }\n  }\n};\n\nvar legendMixin = {\n  type: 'object',\n  properties: {\n    legend: {\n      type: 'object',\n      description: 'Properties of a legend.',\n      properties: {\n        title: {\n          type: 'string',\n          default: undefined,\n          description: 'A title for the legend. (Shows field name and its function by default.)'\n        }\n      }\n    }\n  }\n};\n\nvar textMixin = {\n  type: 'object',\n  supportedMarktypes: {'text': true},\n  properties: {\n    align: {\n      type: 'string',\n      default: 'right'\n    },\n    baseline: {\n      type: 'string',\n      default: 'middle'\n    },\n    color: {\n      type: 'string',\n      role: 'color',\n      default: '#000000'\n    },\n    margin: {\n      type: 'integer',\n      default: 4,\n      minimum: 0\n    },\n    placeholder: {\n      type: 'string',\n      default: 'Abc'\n    },\n    font: {\n      type: 'object',\n      properties: {\n        weight: {\n          type: 'string',\n          enum: ['normal', 'bold'],\n          default: 'normal'\n        },\n        size: {\n          type: 'integer',\n          default: 10,\n          minimum: 0\n        },\n        family: {\n          type: 'string',\n          default: 'Helvetica Neue'\n        },\n        style: {\n          type: 'string',\n          default: 'normal',\n          enum: ['normal', 'italic']\n        }\n      }\n    },\n    format: {\n      type: 'string',\n      default: undefined,  // auto\n      description: 'The formatting pattern for text value. '+\n                   'If not undefined, this will be determined by ' +\n                   'small/largeNumberFormat and the max value ' +\n                   'of the field.'\n    },\n  }\n};\n\nvar sizeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, bar: true, circle: true, square: true, text: true},\n  properties: {\n    value: {\n      type: 'integer',\n      default: 30,\n      minimum: 0,\n      description: 'Size of marks.'\n    }\n  }\n};\n\nvar colorMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'string',\n      role: 'color',\n      default: '#4682b4',\n      description: 'Color to be used for marks.'\n    },\n    opacity: {\n      type: 'number',\n      default: undefined,  // auto\n      minimum: 0,\n      maximum: 1\n    },\n    scale: {\n      type: 'object',\n      properties: {\n        range: {\n          type: ['string', 'array'],\n          default: undefined,\n          description:\n            'Color palette, if undefined vega-lite will use data property' +\n            'to pick one from c10palette, c20palette, or ordinalPalette.'\n            //FIXME\n        },\n        c10palette: {\n          type: 'string',\n          default: 'category10',\n          enum: [\n            // Tableau\n            'category10', 'category10k',\n            // Color Brewer\n            'Pastel1', 'Pastel2', 'Set1', 'Set2', 'Set3'\n          ]\n        },\n        c20palette: {\n          type: 'string',\n          default: 'category20',\n          enum: ['category20', 'category20b', 'category20c']\n        },\n        ordinalPalette: {\n          type: 'string',\n          default: undefined,\n          description: 'Color palette to encode ordinal variables.',\n          enum: util.keys(colorbrewer)\n        },\n        quantitativeRange: {\n          type: 'array',\n          default: ['#AFC6A3', '#09622A'], // tableau greens\n          // default: ['#ccece6', '#00441b'], // BuGn.9 [2-8]\n          description: 'Color range to encode quantitative variables.',\n          minItems: 2,\n          maxItems: 2,\n          items: {\n            type: 'string',\n            role: 'color'\n          }\n        }\n      }\n    }\n  }\n};\n\nvar shapeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, circle: true, square: true},\n  properties: {\n    value: {\n      type: 'string',\n      enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\n      default: 'circle',\n      description: 'Mark to be used.'\n    },\n    filled: {\n      type: 'boolean',\n      default: false,\n      description: 'Whether the shape\\'s color should be used as fill color instead of stroke color.'\n    }\n  }\n};\n\nvar detailMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, line: true, circle: true, square: true}\n};\n\nvar rowMixin = {\n  properties: {\n    height: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    }\n  }\n};\n\nvar colMixin = {\n  properties: {\n    width: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    axis: {\n      properties: {\n        maxLabelLength: {\n          type: 'integer',\n          default: 12,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar facetMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, text: true},\n  properties: {\n    padding: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.1\n    }\n  }\n};\n\nvar requiredNameType = {\n  required: ['name', 'type']\n};\n\nvar multiRoleField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: true\n  }\n});\n\nvar quantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: 'ordinal-only' // using size to encoding category lead to order interpretation\n  }\n});\n\nvar onlyQuantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true\n  }\n});\n\nvar x = merge(clone(multiRoleField), axisMixin, bandMixin, requiredNameType, sortMixin);\nvar y = clone(x);\n\nvar facet = merge(clone(onlyOrdinalField), requiredNameType, facetMixin, sortMixin);\nvar row = merge(clone(facet), axisMixin, rowMixin);\nvar col = merge(clone(facet), axisMixin, colMixin);\n\nvar size = merge(clone(quantitativeField), legendMixin, sizeMixin, sortMixin);\nvar color = merge(clone(multiRoleField), legendMixin, colorMixin, sortMixin);\n\nvar shape = merge(clone(onlyOrdinalField), legendMixin, shapeMixin, sortMixin);\nvar detail = merge(clone(onlyOrdinalField), detailMixin, sortMixin);\n\n// we only put aggregated measure in pivot table\nvar text = merge(clone(onlyQuantitativeField), textMixin, sortMixin);\n\n// TODO add label\n\nvar filter = {\n  type: 'array',\n  items: {\n    type: 'object',\n    properties: {\n      operands: {\n        type: 'array',\n        items: {\n          type: ['string', 'boolean', 'integer', 'number']\n        }\n      },\n      operator: {\n        type: 'string',\n        enum: ['>', '>=', '=', '!=', '<', '<=', 'notNull']\n      }\n    }\n  }\n};\n\nvar data = {\n  type: 'object',\n  properties: {\n    // data source\n    formatType: {\n      type: 'string',\n      enum: ['json', 'csv'],\n      default: 'json'\n    },\n    url: {\n      type: 'string',\n      default: undefined\n    },\n    values: {\n      type: 'array',\n      default: undefined,\n      description: 'Pass array of objects instead of a url to a file.',\n      items: {\n        type: 'object',\n        additionalProperties: true\n      }\n    }\n  }\n};\n\nvar config = {\n  type: 'object',\n  properties: {\n    // template\n    width: {\n      type: 'integer',\n      default: undefined\n    },\n    height: {\n      type: 'integer',\n      default: undefined\n    },\n    viewport: {\n      type: 'array',\n      items: {\n        type: 'integer'\n      },\n      default: undefined\n    },\n    gridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#000000'\n    },\n    gridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.08\n    },\n\n    // filter null\n    // TODO(#597) revise this config\n    filterNull: {\n      type: 'object',\n      properties: {\n        O: {type:'boolean', default: false},\n        Q: {type:'boolean', default: true},\n        T: {type:'boolean', default: true}\n      }\n    },\n    toggleSort: {\n      type: 'string',\n      default: O\n    },\n    autoSortLine: {\n      type: 'boolean',\n      default: true\n    },\n\n    // single plot\n    singleHeight: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    singleWidth: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    // band size\n    largeBandSize: {\n      type: 'integer',\n      default: 21,\n      minimum: 0\n    },\n    smallBandSize: {\n      //small multiples or single plot with high cardinality\n      type: 'integer',\n      default: 12,\n      minimum: 0\n    },\n    largeBandMaxCardinality: {\n      type: 'integer',\n      default: 10\n    },\n    // small multiples\n    cellPadding: {\n      type: 'number',\n      default: 0.1\n    },\n    cellGridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#000000'\n    },\n    cellGridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.15\n    },\n    cellBackgroundColor: {\n      type: 'string',\n      role: 'color',\n      default: 'rgba(0,0,0,0)'\n    },\n    textCellWidth: {\n      type: 'integer',\n      default: 90,\n      minimum: 0\n    },\n\n    // marks\n    strokeWidth: {\n      type: 'integer',\n      default: 2,\n      minimum: 0\n    },\n    singleBarOffset: {\n      type: 'integer',\n      default: 5,\n      minimum: 0\n    },\n    // scales\n    timeScaleLabelLength: {\n      type: 'integer',\n      default: 3,\n      minimum: 0,\n      description: 'Max length for values in dayScaleLabel and monthScaleLabel.  Zero means using full names in dayScaleLabel/monthScaleLabel.'\n    },\n    dayScaleLabel: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      default: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n      description: 'Axis labels for day of week, starting from Sunday.' +\n        '(Consistent with Javascript -- See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getDay.'\n    },\n    monthScaleLabel: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      default: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n      description: 'Axis labels for month.'\n    },\n    // other\n    characterWidth: {\n      type: 'integer',\n      default: 6\n    },\n    maxSmallNumber: {\n      type: 'number',\n      default: 10000,\n      description: 'maximum number that a field will be considered smallNumber.'+\n                   'Used for axis labelling.'\n    },\n    smallNumberFormat: {\n      type: 'string',\n      default: '',\n      description: 'D3 Number format for axis labels and text tables '+\n                   'for number <= maxSmallNumber. Used for axis labelling.'\n    },\n    largeNumberFormat: {\n      type: 'string',\n      default: '.3s',\n      description: 'D3 Number format for axis labels and text tables ' +\n                   'for number > maxSmallNumber.'\n    },\n    timeFormat: {\n      type: 'string',\n      default: '%Y-%m-%d',\n      description: 'Date format for axis labels.'\n    },\n    useRawDomain: {\n      type: 'boolean',\n      default: false,\n      description: 'Use the raw data range as scale domain instead of ' +\n                   'aggregated data for aggregate axis. ' +\n                   'This option does not work with sum or count aggregate' +\n                   'as they might have a substantially larger scale range.' +\n                   'By default, use value from config.useRawDomain.'\n    }\n  }\n};\n\n/** @type Object Schema of a vega-lite specification */\nschema.schema = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  description: 'Schema for Vega-lite specification',\n  type: 'object',\n  required: ['marktype', 'encoding', 'data'],\n  properties: {\n    data: data,\n    marktype: schema.marktype,\n    encoding: {\n      type: 'object',\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        shape: shape,\n        text: text,\n        detail: detail\n      }\n    },\n    filter: filter,\n    config: config\n  }\n};\n\nschema.encTypes = util.keys(schema.schema.properties.encoding.properties);\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function() {\n  return schema.util.instantiate(schema.schema);\n};\n","'use strict';\n\nvar schemautil = module.exports = {},\n  util = require('../util');\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\nschemautil.extend = function(instance, schema) {\n  return schemautil.merge(schemautil.instantiate(schema), instance);\n};\n\n// instantiate a schema\nschemautil.instantiate = function(schema) {\n  var val;\n  if (schema === undefined) {\n    return undefined;\n  } else if ('default' in schema) {\n    val = schema.default;\n    return util.isObject(val) ? util.duplicate(val) : val;\n  } else if (schema.type === 'object') {\n    var instance = {};\n    for (var name in schema.properties) {\n      val = schemautil.instantiate(schema.properties[name]);\n      if (val !== undefined) {\n        instance[name] = val;\n      }\n    }\n    return instance;\n  } else if (schema.type === 'array') {\n    return [];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nschemautil.subtract = function(instance, defaults) {\n  var changes = {};\n  for (var prop in instance) {\n    var def = defaults[prop];\n    var ins = instance[prop];\n    // Note: does not properly subtract arrays\n    if (!defaults || def !== ins) {\n      if (typeof ins === 'object' && !util.isArray(ins) && def) {\n        var c = schemautil.subtract(ins, def);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else if (!util.isArray(ins) || ins.length > 0) {\n        changes[prop] = ins;\n      }\n    }\n  }\n  return changes;\n};\n\nschemautil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction merge(dest, src) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (var p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      merge(dest[p], src[p]);\n    }\n  }\n  return dest;\n}","'use strict';\n\nvar util = module.exports = require('datalib/src/util');\n\nutil.extend(util, require('datalib/src/generate'));\nutil.extend(util, require('datalib/src/stats'));\nutil.extend(util, require('./logger')('[VL Error]'));\nutil.bin = require('datalib/src/bins/bins');\n\nutil.isin = function(item, array) {\n  return array.indexOf(item) !== -1;\n};\n\nutil.forEach = function(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  } else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k , obj);\n    }\n  }\n};\n\nutil.reduce = function(obj, f, init, thisArg) {\n  if (obj.reduce) {\n    return obj.reduce.call(thisArg, f, init);\n  } else {\n    for (var k in obj) {\n      init = f.call(thisArg, init, obj[k], k, obj);\n    }\n    return init;\n  }\n};\n\nutil.map = function(obj, f, thisArg) {\n  if (obj.map) {\n    return obj.map.call(thisArg, f);\n  } else {\n    var output = [];\n    for (var k in obj) {\n      output.push( f.call(thisArg, obj[k], k, obj));\n    }\n  }\n};\n\nutil.any = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (f(arr[k], k, i++)) return true;\n  }\n  return false;\n};\n\nutil.all = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (!f(arr[k], k, i++)) return false;\n  }\n  return true;\n};\n\nutil.getbins = function(stats, maxbins) {\n  return util.bin({\n    min: stats.min,\n    max: stats.max,\n    maxbins: maxbins\n  });\n};\n\n/**\n * x[p[0]]...[p[n]] = val\n * @param noaugment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.setter = function(x, p, val, noaugment) {\n  for (var i=0; i<p.length-1; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  x[p[i]] = val;\n};\n\n\n/**\n * returns x[p[0]]...[p[n]]\n * @param augment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.getter = function(x, p, noaugment) {\n  for (var i=0; i<p.length; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  return x;\n};\n\n","'use strict';\n\nrequire('./globals');\n\nvar util = require('./util'),\n    consts = require('./consts');\n\nvar vl = {};\n\nutil.extend(vl, consts, util);\n\nvl.Encoding = require('./Encoding');\nvl.compiler = require('./compiler/compiler');\nvl.compile = vl.compiler.compile;\nvl.data = require('./data');\nvl.enc = require('./enc');\nvl.field = require('./field');\nvl.schema = require('./schema/schema');\nvl.toShorthand = vl.Encoding.shorthand;\nvl.format = require('d3-format').format;\n\nmodule.exports = vl;","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t1 = new Date;\n\n  var t0 = new Date;\n\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  }\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  exports.seconds = second.range;\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  exports.minutes = minute.range;\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  exports.hours = hour.range;\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  exports.days = day.range;\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  exports.sunday = weekday(0);\n\n  exports.sundays = exports.sunday.range;\n\n  exports.monday = weekday(1);\n\n  exports.mondays = exports.monday.range;\n\n  exports.tuesday = weekday(2);\n\n  exports.tuesdays = exports.tuesday.range;\n\n  exports.wednesday = weekday(3);\n\n  exports.wednesdays = exports.wednesday.range;\n\n  exports.thursday = weekday(4);\n\n  exports.thursdays = exports.thursday.range;\n\n  exports.friday = weekday(5);\n\n  exports.fridays = exports.friday.range;\n\n  exports.saturday = weekday(6);\n\n  exports.saturdays = exports.saturday.range;\n\n  var week = exports.sunday;\n\n  exports.weeks = week.range;\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  });\n\n  exports.months = month.range;\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  exports.years = year.range;\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  exports.utcSeconds = utcSecond.range;\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  exports.utcMinutes = utcMinute.range;\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  exports.utcHours = utcHour.range;\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  exports.utcDays = utcDay.range;\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  exports.utcSunday = utcWeekday(0);\n\n  exports.utcSundays = exports.utcSunday.range;\n\n  exports.utcMonday = utcWeekday(1);\n\n  exports.utcMondays = exports.utcMonday.range;\n\n  exports.utcTuesday = utcWeekday(2);\n\n  exports.utcTuesdays = exports.utcTuesday.range;\n\n  exports.utcWednesday = utcWeekday(3);\n\n  exports.utcWednesdays = exports.utcWednesday.range;\n\n  exports.utcThursday = utcWeekday(4);\n\n  exports.utcThursdays = exports.utcThursday.range;\n\n  exports.utcFriday = utcWeekday(5);\n\n  exports.utcFridays = exports.utcFriday.range;\n\n  exports.utcSaturday = utcWeekday(6);\n\n  exports.utcSaturdays = exports.utcSaturday.range;\n\n  var utcWeek = exports.utcSunday;\n\n  exports.utcWeeks = utcWeek.range;\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  });\n\n  exports.utcMonths = utcMonth.range;\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  exports.utcYears = utcYear.range;\n\n  exports.interval = newInterval;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.week = week;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcWeek = utcWeek;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n\n}));","var util = require('../util'),\n    time = require('../time'),\n    EPSILON = 1e-15;\n\nfunction bins(opt) {\n  if (!opt) { throw Error(\"Missing binning options.\"); }\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  if (!opt) { throw Error(\"Missing date binning options.\"); }\n\n  // find time step, then bin\n  var units = opt.utc ? time.utc : time,\n      dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n","var gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};","var util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    types[f] = infer(data, f);\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;","var util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length < 2) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (v === v) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (v === v) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance] \n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;","var d3_time = require('d3-time');\n\nvar tempDate = new Date(),\n    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD\n    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);\n\nfunction date(d) {\n  return (tempDate.setTime(+d), tempDate);\n}\n\n// create a time unit entry\nfunction entry(type, date, unit, step, min, max) {\n  var e = {\n    type: type,\n    date: date,\n    unit: unit\n  };\n  if (step) {\n    e.step = step;\n  } else {\n    e.minstep = 1;\n  }\n  if (min != null) e.min = min;\n  if (max != null) e.max = max;\n  return e;\n}\n\nfunction create(type, unit, base, step, min, max) {\n  return entry(type,\n    function(d) { return unit.offset(base, d); },\n    function(d) { return unit.count(base, d); },\n    step, min, max);\n}\n\nvar locale = [\n  create('second', d3_time.second, baseDate),\n  create('minute', d3_time.minute, baseDate),\n  create('hour',   d3_time.hour,   baseDate),\n  create('day',    d3_time.day,    baseDate, [1, 7]),\n  create('month',  d3_time.month,  baseDate, [1, 3, 6]),\n  create('year',   d3_time.year,   baseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(1970, 0, 1, 0, 0, d); },\n    function(d) { return date(d).getSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(1970, 0, 1, 0, d); },\n    function(d) { return date(d).getMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(1970, 0, 1, d); },\n    function(d) { return date(d).getHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(1970, 0, 4+d); },\n    function(d) { return date(d).getDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(1970, 0, d); },\n    function(d) { return date(d).getDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(1970, d % 12, 1); },\n    function(d) { return date(d).getMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar utc = [\n  create('second', d3_time.utcSecond, utcBaseDate),\n  create('minute', d3_time.utcMinute, utcBaseDate),\n  create('hour',   d3_time.utcHour,   utcBaseDate),\n  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),\n  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),\n  create('year',   d3_time.utcYear,   utcBaseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },\n    function(d) { return date(d).getUTCSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },\n    function(d) { return date(d).getUTCMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },\n    function(d) { return date(d).getUTCHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },\n    function(d) { return date(d).getUTCDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(Date.UTC(1970, 0, d)); },\n    function(d) { return date(d).getUTCDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },\n    function(d) { return date(d).getUTCMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction find(units, span, minb, maxb) {\n  var step = STEPS[0], i, n, bins;\n\n  for (i=1, n=STEPS.length; i<n; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return units[STEPS[i-1][1]];\n      }\n      if (bins >= minb) {\n        return units[step[1]];\n      }\n    }\n  }\n  return units[STEPS[n-1][1]];\n}\n\nfunction toUnitMap(units) {\n  var map = {}, i, n;\n  for (i=0, n=units.length; i<n; ++i) {\n    map[units[i].type] = units[i];\n  }\n  map.find = function(span, minb, maxb) {\n    return find(units, span, minb, maxb);\n  };\n  return map;\n}\n\nmodule.exports = toUnitMap(locale);\nmodule.exports.utc = toUnitMap(utc);\n","var buffer = require('buffer'),\n    time = require('./time'),\n    utc = time.utc;\n\nvar u = module.exports = {};\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (buffer.Buffer && buffer.Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\nu.date = function(s) {\n  return s == null || s === '' ? null : Date.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nu.field = function(f) {\n  return String(f).split('\\\\.')\n    .map(function(d) { return d.split('.'); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += '.' + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\nu.$year   = u.$func('year', time.year.unit);\nu.$month  = u.$func('month', time.months.unit);\nu.$date   = u.$func('date', time.dates.unit);\nu.$day    = u.$func('day', time.weekdays.unit);\nu.$hour   = u.$func('hour', time.hours.unit);\nu.$minute = u.$func('minute', time.minutes.unit);\nu.$second = u.$func('second', time.seconds.unit);\n\nu.$utcYear   = u.$func('utcYear', utc.year.unit);\nu.$utcMonth  = u.$func('utcMonth', utc.months.unit);\nu.$utcDate   = u.$func('utcDate', utc.dates.unit);\nu.$utcDay    = u.$func('utcDay', utc.weekdays.unit);\nu.$utcHour   = u.$func('utcHour', utc.hours.unit);\nu.$utcMinute = u.$func('utcMinute', utc.minutes.unit);\nu.$utcSecond = u.$func('utcSecond', utc.seconds.unit);\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n"],"sourceRoot":"/source/"}