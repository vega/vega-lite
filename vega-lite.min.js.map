{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","vega-lite.js","node_modules/colorbrewer/colorbrewer.js","node_modules/colorbrewer/index.js","node_modules/d3-color/build/color.js","node_modules/d3-format/build/format.js","node_modules/d3-time-format/build/timeFormat.js","node_modules/datalib/node_modules/d3-time/build/time.js","node_modules/datalib/src/bins/bins.js","node_modules/datalib/src/generate.js","node_modules/datalib/src/import/type.js","node_modules/datalib/src/stats.js","node_modules/datalib/src/time.js","node_modules/datalib/src/util.js","src/Encoding.js","src/compiler/axis.js","src/compiler/compiler.js","src/compiler/data.js","src/compiler/facet.js","src/compiler/group.js","src/compiler/layout.js","src/compiler/legend.js","src/compiler/marks.js","src/compiler/scale.js","src/compiler/sort.js","src/compiler/stack.js","src/compiler/style.js","src/compiler/subfacet.js","src/compiler/time.js","src/consts.js","src/data.js","src/enc.js","src/field.js","src/globals.js","src/logger.js","src/schema/schema.js","src/schema/schemautil.js","src/util.js","src/vl"],"names":["f","exports","module","define","amd","g","window","global","self","this","vl","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,2,"colorbrewer","YlGn",3,4,5,6,7,8,9,"YlGnBu","GnBu","BuGn","PuBuGn","PuBu","BuPu","RdPu","PuRd","OrRd","YlOrRd","YlOrBr","Purples","Blues","Greens","Oranges","Reds","Greys","PuOr",10,11,"BrBG","PRGn","PiYG","RdBu","RdGy","RdYlBu","Spectral","RdYlGn","Accent","Dark2","Paired",12,"Pastel1","Pastel2","Set1","Set2","Set3","./colorbrewer.js","Map","clear","prototype","set","k","v","_","get","has","delete","Object","create",{"end":{"file":"?","comments_before":[],"nlb":false,"endpos":20771,"endcol":12,"endline":332,"pos":20767,"col":8,"line":332,"value":"size","type":"name"},"start":{"file":"?","comments_before":[],"nlb":false,"endpos":20771,"endcol":12,"endline":332,"pos":20767,"col":8,"line":332,"value":"size","type":"name"},"name":"size"},"size","forEach","c","m","apply","arguments","factory","color","deltaHue","h1","h0","delta","Math","round","Color","format","trim","toLowerCase","reHex3","exec","parseInt","rgb","reHex6","rgbn","reRgbInteger","reRgbPercent","reHslPercent","hsl","named","b","NaN","Rgb","isNaN","max","toString","min","h","Hsl","range","hsl2rgb","m1","m2","lab","Lab","Hcl","deg2rad","sin","cos","rgb2xyz","x","xyz2lab","Xn","y","Yn","z","Zn","t3","pow","t2","t0","lab2xyz","t1","xyz2rgb","hcl","sqrt","atan2","rad2deg","cubehelix","Cubehelix","BC_DA","ED","EB","bl","E","C","D","interpolateCubehelixGamma","gamma","ah","as","al","bh","bs","interpolateCubehelixGammaLong","interpolateHclLong","ac","bc","interpolateHcl","interpolateLab","aa","ab","ba","bb","interpolateHslLong","interpolateHsl","interpolateRgb","ar","ag","br","bg","displayable","darker","brighter","_prototype","__prototype","Kn","___prototype","PI","____prototype","A","B","cosh","sinh","interpolateCubehelix","interpolateCubehelixLong","formatDecimal","p","toExponential","indexOf","coefficient","slice","exponent","abs","formatPrefixAuto","d","prefixExponent","floor","Array","join","formatRounded","formatDefault","toPrecision","out","i1","i0","formatSpecifier","specifier","FormatSpecifier","match","re","fill","align","sign","symbol","zero","width","comma","precision","type","formatTypes","formatGroup","grouping","thousands","value","j","push","substring","reverse","identity","locale","prefix","currency","test","suffix","formatType","maybeSuffix","valuePrefix","valueSuffix","valueNegative","prefixes","charCodeAt","decimal","group","Infinity","padding","formatPrefix","precisionRound","step","precisionPrefix","precisionFixed","localeFormat","definition","localeDefinitions","zhCn","ruRu","ptBr","plPl","nlNl","mkMk","itIt","heIl","frFr","frCa","fiFi","esEs","enUs","enGb","enCa","deDe","caEs","%","toFixed","X","toUpperCase","defaultLocale","timeFormat","newInterval","floori","offseti","count","interval","date","Date","d0","d1","ceil","offset","start","stop","filter","setTime","end","weekday","setHours","setDate","getDate","getDay","getTimezoneOffset","utcWeekday","setUTCHours","setUTCDate","getUTCDate","getUTCDay","localDate","H","M","S","L","setFullYear","utcDate","UTC","setUTCFullYear","newYear","newFormat","formats","pad","string","pads","charAt","newParse","newDate","parseSpecifier","day","U","W","w","Z","parse","parses","parseShortWeekday","shortWeekdayRe","shortWeekdayLookup","parseWeekday","weekdayRe","weekdayLookup","parseShortMonth","shortMonthRe","shortMonthLookup","parseMonth","monthRe","monthLookup","parseLocaleDateTime","locale_dateTime","parseLocaleDate","locale_date","parseLocaleTime","locale_time","parsePeriod","periodLookup","formatShortWeekday","locale_shortWeekdays","formatWeekday","locale_weekdays","formatShortMonth","locale_shortMonths","getMonth","formatMonth","locale_months","formatPeriod","locale_periods","getHours","formatUTCShortWeekday","formatUTCWeekday","formatUTCShortMonth","getUTCMonth","formatUTCMonth","formatUTCPeriod","getUTCHours","dateTime","time","periods","days","shortDays","months","shortMonths","formatLookup","formatRe","formatDayOfMonth","formatHour24","I","formatHour12","formatDayOfYear","formatMilliseconds","formatMonthNumber","formatMinutes","formatSeconds","formatWeekNumberSunday","formatWeekdayNumber","formatWeekNumberMonday","formatYear","Y","formatFullYear","formatZone","formatLiteralPercent","utcFormats","formatUTCDayOfMonth","formatUTCHour24","formatUTCHour12","formatUTCDayOfYear","formatUTCMilliseconds","formatUTCMonthNumber","formatUTCMinutes","formatUTCSeconds","formatUTCWeekNumberSunday","formatUTCWeekdayNumber","formatUTCWeekNumberMonday","formatUTCYear","formatUTCFullYear","formatUTCZone","parseDayOfMonth","parseHour24","parseDayOfYear","parseMilliseconds","parseMonthNumber","parseMinutes","parseSeconds","parseWeekNumberSunday","parseWeekdayNumber","parseWeekNumberMonday","parseYear","parseFullYear","parseZone","parseLiteralPercent","utcFormat","requote","replace","requoteRe","names","RegExp","map","numberRe","percentRe","year","getMilliseconds","getMinutes","getSeconds","sunday","monday","getFullYear","utcDay","utcYear","getUTCMilliseconds","getUTCMinutes","getUTCSeconds","utcSunday","utcMonday","getUTCFullYear","formatIsoNative","toISOString","setMonth","setUTCMonth","-","0","isoSpecifier","formatIso","isoFormat","second","setMilliseconds","seconds","minute","setSeconds","minutes","hour","setMinutes","hours","sundays","mondays","tuesday","tuesdays","wednesday","wednesdays","thursday","thursdays","friday","fridays","saturday","saturdays","week","weeks","month","years","utcSecond","setUTCMilliseconds","utcSeconds","utcMinute","setUTCSeconds","utcMinutes","utcHour","setUTCMinutes","utcHours","utcDays","utcSundays","utcMondays","utcTuesday","utcTuesdays","utcWednesday","utcWednesdays","utcThursday","utcThursdays","utcFriday","utcFridays","utcSaturday","utcSaturdays","utcWeek","utcWeeks","utcMonth","utcMonths","utcYears","bins","opt","level","minstep","eps","maxb","maxbins","base","logb","log","div","span","steps","bisect","unit","index","lo","hi","mid","util","cmp","EPSILON","date_value","date_index","units","utc","dmin","dmax","minb","minbins","find","spec","raw","../time","../util","gen","repeat","val","zeros","random","uniform","undefined","samples","integer","normal","mean","stdev","next","rds","annotation","data","types","TYPES","values","$","isString","isValid","isDate","isNumber","isBoolean","typeAll","fields","keys","reduce","infer","TESTS","splice","inferAll","PARSERS","boolean","number","all","parsers","stats","unique","results","valid","missing","distinct","median","sort","quantile","quartile","q","sum","variance","isArray","M2","modeskew","avg","med","std","extent","dot","rank","mu","idx","comparator","tie","cor","fn","mua","mub","sda","sdb","ra","rb","dist","mat","exp","isFunction","L2","R","entropy","counts","LN2","mutual","px","py","info","profile","sd","vals","q1","q3","summary","field","__summary__","./generate","./import/type","./util","tempDate","entry","STEPS","toUnitMap","d3_time","baseDate","utcBaseDate","d3-time",13,"util_escape_str","escape_str_re","strrep","str","truncateOnWord","len","rev","cnt","tok","split","truncate_word_re","buffer","FNAME","namedfunc","name","duplicate","obj","JSON","stringify","equal","extend","toMap","list","keystr","String","isObject","isBuffer","Buffer","array","field_re","accessor","mutator","$func","op","$valid","$length","$in","$year","$month","$date","dates","$day","weekdays","$hour","$minute","$second","$utcYear","$utcMonth","$utcDate","$utcDay","$utcHour","$utcMinute","$utcSecond","numcmp","stablesort","sortBy","keyFn","indices","sa","sb","pos","padchar","truncate","word","ellipsis","l1","l2","./time",14,"consts","vlfield","vlenc","schema","Encoding","theme","defaults","instantiate","specExtended","merge","_data","_marktype","marktype","_enc","encoding","_config","config","_filter","proto","fromShorthand","shorthand","delim","shift","assign","enc","fromSpec","toShorthand","specFromShorthand","excludeConfig","toSpec","excludeData","subtract","is","encType","et","filterNull","fieldList","fieldName","Q","containsType","T","O","N","operands","operator","concat","fieldRef","_vega2","fieldTitle","isCount","displayName","aggregate","timeUnit","bin","uppercase","scale","axis","bandSize","useSmallBand","ROW","COL","band","MAXBINS_DEFAULT","numberFormat","fieldStats","formatConfig","isTypes","toggleSort","support","qField","init","isType","isOrdinalScale","isDimension","isMeasure","isAggregate","dataTable","AGGREGATE","RAW","alwaysNoOcclusion","isStack","details","refs","facets","cardinality","isRaw","hasValues","transpose","oldenc","row","col","direction","mode","toggleFilterNullO","nulls","./consts","./enc","./field","./globals","./schema/schema",15,"setter","getter","def","layout","isCol","isRow","properties","layer","orient","labels","angle","ticks","rotate","titleOffset","grid","title","hideTicks","cellPadding","cellWidth","cellHeight","stroke","opacity","x2","mult","majorTicks","ax","maxLength","titleMaxLength","baseline","dy","height","hasScale","maxLabelLength","labelAngle","../globals",16,"compiler","legend","marks","facet","stack","style","subfacet","compile","compileEncoding","console","error","scales","mdefs","mdef","lineType","line","from","transform","by","singleScaleNames","markProps","update","legends","defs","axes","../Encoding","./axis","./data","./facet","./group","./layout","./legend","./marks","./scale","./sort","./stack","./style","./subfacet","datalib/src/stats",17,"filterNonPositive","url","formatParse","BINARY",">",">=","=","!=","<","<=","expr","formula","nofn","output","filters","condition","op1","op2","warn","dims","meas","source","groupby","../field",18,"faceting","axesGrp","enter","facetKeys","cellAxes","hasRow","hasCol","mark","unshift","groupdef","trans",19,"_name",20,"vllayout","box","hasX","hasY","xCardinality","yCardinality","TEXT","colCardinality","rowCardinality","getMaxNumberLength","d3_format","getMaxLength","extraOffset","d3-format",21,"COLOR","SIZE","SHAPE","shape","symbols","filled","strokeWidth","leg",22,"bar_props","xc","y2","yc","point_props","line_props","area_props","tick_props","filled_point_props","text_props","fontSize","font","text","template","placeholder","family","fontWeight","weight","fontStyle","prop","bar","supportedEncoding","requiredEncoding","detail","area","tick","circle","square","point",23,"interpolate","vlsort","props","domain","fieldStat","getbins","numbins","STACKED","prefn","scaleUseRawDomain","useRawDomain","notCountOrSum","isOrdinalFn","getDataName","bandWidth","nice","outerPadding","points","colorScale","ordinalPalette","quantitativeRange","c10palette","c20palette","palette","ps","to","interpolator","../schema/schema","d3-color",24,"datasetMapping","byClause","dataName","transforms",25,"stacking","dim","isXMeasure","isYMeasure","stacked","y1","y0",26,"estimateOpacity","numPoints","numMultiples",27,"subfaceting",28,"d3_time_format","LONG_DATE","stat","yearstat","scaleLabel","labelLength","substr","isColor","d3-time-format",29,"encodingTypes","DETAIL","func",30,"vldata","*",31,"encTypes","countRetinal","fieldDef","arr","enctype",32,"shorthands","timefns","tu","./compiler/time",33,"INDEX",34,"METHODS","logger","cfn","bind","Function",35,"enum","supportedEnums","supportedTypes","getSupportedRole","supportedRole","timeUnits","defaultTimeFn","scale_type","default","clone","minimum","description","typicalField","onlyOrdinalField","dimension","axisMixin","supportedMarktypes","maximum","sortMixin","items","required","bandMixin","legendMixin","textMixin","role","margin","sizeMixin","colorMixin","minItems","maxItems","shapeMixin","detailMixin","rowMixin","colMixin","facetMixin","requiredNameType","multiRoleField","measure","quantitativeField","onlyQuantitativeField","additionalProperties","viewport","gridColor","gridOpacity","autoSortLine","singleHeight","singleWidth","largeBandSize","smallBandSize","largeBandMaxCardinality","cellGridColor","cellGridOpacity","cellBackgroundColor","textCellWidth","singleBarOffset","timeScaleLabelLength","dayScaleLabel","monthScaleLabel","characterWidth","maxSmallNumber","smallNumberFormat","largeNumberFormat","$schema","./schemautil",36,"dest","src","hasOwnProperty","constructor","schemautil","isEmpty","instance","changes","ins",37,"isin","item","thisArg","any","noaugment","./logger","datalib/src/bins/bins","datalib/src/generate","datalib/src/util",38,"./Encoding","./compiler/compiler"],"mappings":"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","file":"vega-lite.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.vl = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\n},{}],2:[function(require,module,exports){\n// This product includes color specifications and designs developed by Cynthia Brewer (http://colorbrewer.org/).\n// JavaScript specs as packaged in the D3 library (d3js.org). Please see license at http://colorbrewer.org/export/LICENSE.txt\n!function() {\n\nvar colorbrewer = {YlGn: {\n3: [\"#f7fcb9\",\"#addd8e\",\"#31a354\"],\n4: [\"#ffffcc\",\"#c2e699\",\"#78c679\",\"#238443\"],\n5: [\"#ffffcc\",\"#c2e699\",\"#78c679\",\"#31a354\",\"#006837\"],\n6: [\"#ffffcc\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#31a354\",\"#006837\"],\n7: [\"#ffffcc\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#005a32\"],\n8: [\"#ffffe5\",\"#f7fcb9\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#005a32\"],\n9: [\"#ffffe5\",\"#f7fcb9\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#006837\",\"#004529\"]\n},YlGnBu: {\n3: [\"#edf8b1\",\"#7fcdbb\",\"#2c7fb8\"],\n4: [\"#ffffcc\",\"#a1dab4\",\"#41b6c4\",\"#225ea8\"],\n5: [\"#ffffcc\",\"#a1dab4\",\"#41b6c4\",\"#2c7fb8\",\"#253494\"],\n6: [\"#ffffcc\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#2c7fb8\",\"#253494\"],\n7: [\"#ffffcc\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#0c2c84\"],\n8: [\"#ffffd9\",\"#edf8b1\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#0c2c84\"],\n9: [\"#ffffd9\",\"#edf8b1\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#253494\",\"#081d58\"]\n},GnBu: {\n3: [\"#e0f3db\",\"#a8ddb5\",\"#43a2ca\"],\n4: [\"#f0f9e8\",\"#bae4bc\",\"#7bccc4\",\"#2b8cbe\"],\n5: [\"#f0f9e8\",\"#bae4bc\",\"#7bccc4\",\"#43a2ca\",\"#0868ac\"],\n6: [\"#f0f9e8\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#43a2ca\",\"#0868ac\"],\n7: [\"#f0f9e8\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#08589e\"],\n8: [\"#f7fcf0\",\"#e0f3db\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#08589e\"],\n9: [\"#f7fcf0\",\"#e0f3db\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#0868ac\",\"#084081\"]\n},BuGn: {\n3: [\"#e5f5f9\",\"#99d8c9\",\"#2ca25f\"],\n4: [\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#238b45\"],\n5: [\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\"],\n6: [\"#edf8fb\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\"],\n7: [\"#edf8fb\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#005824\"],\n8: [\"#f7fcfd\",\"#e5f5f9\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#005824\"],\n9: [\"#f7fcfd\",\"#e5f5f9\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#006d2c\",\"#00441b\"]\n},PuBuGn: {\n3: [\"#ece2f0\",\"#a6bddb\",\"#1c9099\"],\n4: [\"#f6eff7\",\"#bdc9e1\",\"#67a9cf\",\"#02818a\"],\n5: [\"#f6eff7\",\"#bdc9e1\",\"#67a9cf\",\"#1c9099\",\"#016c59\"],\n6: [\"#f6eff7\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#1c9099\",\"#016c59\"],\n7: [\"#f6eff7\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016450\"],\n8: [\"#fff7fb\",\"#ece2f0\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016450\"],\n9: [\"#fff7fb\",\"#ece2f0\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016c59\",\"#014636\"]\n},PuBu: {\n3: [\"#ece7f2\",\"#a6bddb\",\"#2b8cbe\"],\n4: [\"#f1eef6\",\"#bdc9e1\",\"#74a9cf\",\"#0570b0\"],\n5: [\"#f1eef6\",\"#bdc9e1\",\"#74a9cf\",\"#2b8cbe\",\"#045a8d\"],\n6: [\"#f1eef6\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#2b8cbe\",\"#045a8d\"],\n7: [\"#f1eef6\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#034e7b\"],\n8: [\"#fff7fb\",\"#ece7f2\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#034e7b\"],\n9: [\"#fff7fb\",\"#ece7f2\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#045a8d\",\"#023858\"]\n},BuPu: {\n3: [\"#e0ecf4\",\"#9ebcda\",\"#8856a7\"],\n4: [\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#88419d\"],\n5: [\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#8856a7\",\"#810f7c\"],\n6: [\"#edf8fb\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8856a7\",\"#810f7c\"],\n7: [\"#edf8fb\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#6e016b\"],\n8: [\"#f7fcfd\",\"#e0ecf4\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#6e016b\"],\n9: [\"#f7fcfd\",\"#e0ecf4\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#810f7c\",\"#4d004b\"]\n},RdPu: {\n3: [\"#fde0dd\",\"#fa9fb5\",\"#c51b8a\"],\n4: [\"#feebe2\",\"#fbb4b9\",\"#f768a1\",\"#ae017e\"],\n5: [\"#feebe2\",\"#fbb4b9\",\"#f768a1\",\"#c51b8a\",\"#7a0177\"],\n6: [\"#feebe2\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#c51b8a\",\"#7a0177\"],\n7: [\"#feebe2\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\"],\n8: [\"#fff7f3\",\"#fde0dd\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\"],\n9: [\"#fff7f3\",\"#fde0dd\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\",\"#49006a\"]\n},PuRd: {\n3: [\"#e7e1ef\",\"#c994c7\",\"#dd1c77\"],\n4: [\"#f1eef6\",\"#d7b5d8\",\"#df65b0\",\"#ce1256\"],\n5: [\"#f1eef6\",\"#d7b5d8\",\"#df65b0\",\"#dd1c77\",\"#980043\"],\n6: [\"#f1eef6\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#dd1c77\",\"#980043\"],\n7: [\"#f1eef6\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#91003f\"],\n8: [\"#f7f4f9\",\"#e7e1ef\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#91003f\"],\n9: [\"#f7f4f9\",\"#e7e1ef\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#980043\",\"#67001f\"]\n},OrRd: {\n3: [\"#fee8c8\",\"#fdbb84\",\"#e34a33\"],\n4: [\"#fef0d9\",\"#fdcc8a\",\"#fc8d59\",\"#d7301f\"],\n5: [\"#fef0d9\",\"#fdcc8a\",\"#fc8d59\",\"#e34a33\",\"#b30000\"],\n6: [\"#fef0d9\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#e34a33\",\"#b30000\"],\n7: [\"#fef0d9\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#990000\"],\n8: [\"#fff7ec\",\"#fee8c8\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#990000\"],\n9: [\"#fff7ec\",\"#fee8c8\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#b30000\",\"#7f0000\"]\n},YlOrRd: {\n3: [\"#ffeda0\",\"#feb24c\",\"#f03b20\"],\n4: [\"#ffffb2\",\"#fecc5c\",\"#fd8d3c\",\"#e31a1c\"],\n5: [\"#ffffb2\",\"#fecc5c\",\"#fd8d3c\",\"#f03b20\",\"#bd0026\"],\n6: [\"#ffffb2\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#f03b20\",\"#bd0026\"],\n7: [\"#ffffb2\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#b10026\"],\n8: [\"#ffffcc\",\"#ffeda0\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#b10026\"],\n9: [\"#ffffcc\",\"#ffeda0\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#bd0026\",\"#800026\"]\n},YlOrBr: {\n3: [\"#fff7bc\",\"#fec44f\",\"#d95f0e\"],\n4: [\"#ffffd4\",\"#fed98e\",\"#fe9929\",\"#cc4c02\"],\n5: [\"#ffffd4\",\"#fed98e\",\"#fe9929\",\"#d95f0e\",\"#993404\"],\n6: [\"#ffffd4\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#d95f0e\",\"#993404\"],\n7: [\"#ffffd4\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#8c2d04\"],\n8: [\"#ffffe5\",\"#fff7bc\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#8c2d04\"],\n9: [\"#ffffe5\",\"#fff7bc\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#993404\",\"#662506\"]\n},Purples: {\n3: [\"#efedf5\",\"#bcbddc\",\"#756bb1\"],\n4: [\"#f2f0f7\",\"#cbc9e2\",\"#9e9ac8\",\"#6a51a3\"],\n5: [\"#f2f0f7\",\"#cbc9e2\",\"#9e9ac8\",\"#756bb1\",\"#54278f\"],\n6: [\"#f2f0f7\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#756bb1\",\"#54278f\"],\n7: [\"#f2f0f7\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#4a1486\"],\n8: [\"#fcfbfd\",\"#efedf5\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#4a1486\"],\n9: [\"#fcfbfd\",\"#efedf5\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#54278f\",\"#3f007d\"]\n},Blues: {\n3: [\"#deebf7\",\"#9ecae1\",\"#3182bd\"],\n4: [\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#2171b5\"],\n5: [\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#3182bd\",\"#08519c\"],\n6: [\"#eff3ff\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#3182bd\",\"#08519c\"],\n7: [\"#eff3ff\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#084594\"],\n8: [\"#f7fbff\",\"#deebf7\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#084594\"],\n9: [\"#f7fbff\",\"#deebf7\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#08519c\",\"#08306b\"]\n},Greens: {\n3: [\"#e5f5e0\",\"#a1d99b\",\"#31a354\"],\n4: [\"#edf8e9\",\"#bae4b3\",\"#74c476\",\"#238b45\"],\n5: [\"#edf8e9\",\"#bae4b3\",\"#74c476\",\"#31a354\",\"#006d2c\"],\n6: [\"#edf8e9\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#31a354\",\"#006d2c\"],\n7: [\"#edf8e9\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#005a32\"],\n8: [\"#f7fcf5\",\"#e5f5e0\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#005a32\"],\n9: [\"#f7fcf5\",\"#e5f5e0\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#006d2c\",\"#00441b\"]\n},Oranges: {\n3: [\"#fee6ce\",\"#fdae6b\",\"#e6550d\"],\n4: [\"#feedde\",\"#fdbe85\",\"#fd8d3c\",\"#d94701\"],\n5: [\"#feedde\",\"#fdbe85\",\"#fd8d3c\",\"#e6550d\",\"#a63603\"],\n6: [\"#feedde\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#e6550d\",\"#a63603\"],\n7: [\"#feedde\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#8c2d04\"],\n8: [\"#fff5eb\",\"#fee6ce\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#8c2d04\"],\n9: [\"#fff5eb\",\"#fee6ce\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#a63603\",\"#7f2704\"]\n},Reds: {\n3: [\"#fee0d2\",\"#fc9272\",\"#de2d26\"],\n4: [\"#fee5d9\",\"#fcae91\",\"#fb6a4a\",\"#cb181d\"],\n5: [\"#fee5d9\",\"#fcae91\",\"#fb6a4a\",\"#de2d26\",\"#a50f15\"],\n6: [\"#fee5d9\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#de2d26\",\"#a50f15\"],\n7: [\"#fee5d9\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#99000d\"],\n8: [\"#fff5f0\",\"#fee0d2\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#99000d\"],\n9: [\"#fff5f0\",\"#fee0d2\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#a50f15\",\"#67000d\"]\n},Greys: {\n3: [\"#f0f0f0\",\"#bdbdbd\",\"#636363\"],\n4: [\"#f7f7f7\",\"#cccccc\",\"#969696\",\"#525252\"],\n5: [\"#f7f7f7\",\"#cccccc\",\"#969696\",\"#636363\",\"#252525\"],\n6: [\"#f7f7f7\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#636363\",\"#252525\"],\n7: [\"#f7f7f7\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\"],\n8: [\"#ffffff\",\"#f0f0f0\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\"],\n9: [\"#ffffff\",\"#f0f0f0\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\",\"#000000\"]\n},PuOr: {\n3: [\"#f1a340\",\"#f7f7f7\",\"#998ec3\"],\n4: [\"#e66101\",\"#fdb863\",\"#b2abd2\",\"#5e3c99\"],\n5: [\"#e66101\",\"#fdb863\",\"#f7f7f7\",\"#b2abd2\",\"#5e3c99\"],\n6: [\"#b35806\",\"#f1a340\",\"#fee0b6\",\"#d8daeb\",\"#998ec3\",\"#542788\"],\n7: [\"#b35806\",\"#f1a340\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#998ec3\",\"#542788\"],\n8: [\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\"],\n9: [\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\"],\n10: [\"#7f3b08\",\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\",\"#2d004b\"],\n11: [\"#7f3b08\",\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\",\"#2d004b\"]\n},BrBG: {\n3: [\"#d8b365\",\"#f5f5f5\",\"#5ab4ac\"],\n4: [\"#a6611a\",\"#dfc27d\",\"#80cdc1\",\"#018571\"],\n5: [\"#a6611a\",\"#dfc27d\",\"#f5f5f5\",\"#80cdc1\",\"#018571\"],\n6: [\"#8c510a\",\"#d8b365\",\"#f6e8c3\",\"#c7eae5\",\"#5ab4ac\",\"#01665e\"],\n7: [\"#8c510a\",\"#d8b365\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#5ab4ac\",\"#01665e\"],\n8: [\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\"],\n9: [\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\"],\n10: [\"#543005\",\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\",\"#003c30\"],\n11: [\"#543005\",\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\",\"#003c30\"]\n},PRGn: {\n3: [\"#af8dc3\",\"#f7f7f7\",\"#7fbf7b\"],\n4: [\"#7b3294\",\"#c2a5cf\",\"#a6dba0\",\"#008837\"],\n5: [\"#7b3294\",\"#c2a5cf\",\"#f7f7f7\",\"#a6dba0\",\"#008837\"],\n6: [\"#762a83\",\"#af8dc3\",\"#e7d4e8\",\"#d9f0d3\",\"#7fbf7b\",\"#1b7837\"],\n7: [\"#762a83\",\"#af8dc3\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#7fbf7b\",\"#1b7837\"],\n8: [\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\"],\n9: [\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\"],\n10: [\"#40004b\",\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\",\"#00441b\"],\n11: [\"#40004b\",\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\",\"#00441b\"]\n},PiYG: {\n3: [\"#e9a3c9\",\"#f7f7f7\",\"#a1d76a\"],\n4: [\"#d01c8b\",\"#f1b6da\",\"#b8e186\",\"#4dac26\"],\n5: [\"#d01c8b\",\"#f1b6da\",\"#f7f7f7\",\"#b8e186\",\"#4dac26\"],\n6: [\"#c51b7d\",\"#e9a3c9\",\"#fde0ef\",\"#e6f5d0\",\"#a1d76a\",\"#4d9221\"],\n7: [\"#c51b7d\",\"#e9a3c9\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#a1d76a\",\"#4d9221\"],\n8: [\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\"],\n9: [\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\"],\n10: [\"#8e0152\",\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\",\"#276419\"],\n11: [\"#8e0152\",\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\",\"#276419\"]\n},RdBu: {\n3: [\"#ef8a62\",\"#f7f7f7\",\"#67a9cf\"],\n4: [\"#ca0020\",\"#f4a582\",\"#92c5de\",\"#0571b0\"],\n5: [\"#ca0020\",\"#f4a582\",\"#f7f7f7\",\"#92c5de\",\"#0571b0\"],\n6: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#d1e5f0\",\"#67a9cf\",\"#2166ac\"],\n7: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#67a9cf\",\"#2166ac\"],\n8: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\"],\n9: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\"],\n10: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\",\"#053061\"],\n11: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\",\"#053061\"]\n},RdGy: {\n3: [\"#ef8a62\",\"#ffffff\",\"#999999\"],\n4: [\"#ca0020\",\"#f4a582\",\"#bababa\",\"#404040\"],\n5: [\"#ca0020\",\"#f4a582\",\"#ffffff\",\"#bababa\",\"#404040\"],\n6: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#e0e0e0\",\"#999999\",\"#4d4d4d\"],\n7: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#999999\",\"#4d4d4d\"],\n8: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\"],\n9: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\"],\n10: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\",\"#1a1a1a\"],\n11: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\",\"#1a1a1a\"]\n},RdYlBu: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#91bfdb\"],\n4: [\"#d7191c\",\"#fdae61\",\"#abd9e9\",\"#2c7bb6\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#abd9e9\",\"#2c7bb6\"],\n6: [\"#d73027\",\"#fc8d59\",\"#fee090\",\"#e0f3f8\",\"#91bfdb\",\"#4575b4\"],\n7: [\"#d73027\",\"#fc8d59\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#91bfdb\",\"#4575b4\"],\n8: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\"],\n9: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\"],\n10: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\",\"#313695\"],\n11: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\",\"#313695\"]\n},Spectral: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#99d594\"],\n4: [\"#d7191c\",\"#fdae61\",\"#abdda4\",\"#2b83ba\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#abdda4\",\"#2b83ba\"],\n6: [\"#d53e4f\",\"#fc8d59\",\"#fee08b\",\"#e6f598\",\"#99d594\",\"#3288bd\"],\n7: [\"#d53e4f\",\"#fc8d59\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#99d594\",\"#3288bd\"],\n8: [\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\"],\n9: [\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\"],\n10: [\"#9e0142\",\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\",\"#5e4fa2\"],\n11: [\"#9e0142\",\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\",\"#5e4fa2\"]\n},RdYlGn: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#91cf60\"],\n4: [\"#d7191c\",\"#fdae61\",\"#a6d96a\",\"#1a9641\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#a6d96a\",\"#1a9641\"],\n6: [\"#d73027\",\"#fc8d59\",\"#fee08b\",\"#d9ef8b\",\"#91cf60\",\"#1a9850\"],\n7: [\"#d73027\",\"#fc8d59\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#91cf60\",\"#1a9850\"],\n8: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\"],\n9: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\"],\n10: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\",\"#006837\"],\n11: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\",\"#006837\"]\n},Accent: {\n3: [\"#7fc97f\",\"#beaed4\",\"#fdc086\"],\n4: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\"],\n5: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\"],\n6: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\"],\n7: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\",\"#bf5b17\"],\n8: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\",\"#bf5b17\",\"#666666\"]\n},Dark2: {\n3: [\"#1b9e77\",\"#d95f02\",\"#7570b3\"],\n4: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\"],\n5: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\"],\n6: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\"],\n7: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\",\"#a6761d\"],\n8: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\",\"#a6761d\",\"#666666\"]\n},Paired: {\n3: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\"],\n4: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\"],\n5: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\"],\n6: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\"],\n7: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\"],\n8: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\"],\n9: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\"],\n10: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\"],\n11: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\",\"#ffff99\"],\n12: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\",\"#ffff99\",\"#b15928\"]\n},Pastel1: {\n3: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\"],\n4: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\"],\n5: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\"],\n6: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\"],\n7: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\"],\n8: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\"#fddaec\"],\n9: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\"#fddaec\",\"#f2f2f2\"]\n},Pastel2: {\n3: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\"],\n4: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\"],\n5: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\"],\n6: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\"],\n7: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\",\"#f1e2cc\"],\n8: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\",\"#f1e2cc\",\"#cccccc\"]\n},Set1: {\n3: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\"],\n4: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\"],\n5: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\"],\n6: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\"],\n7: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\"],\n8: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\",\"#f781bf\"],\n9: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\",\"#f781bf\",\"#999999\"]\n},Set2: {\n3: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\"],\n4: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\"],\n5: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\"],\n6: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\"],\n7: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\",\"#e5c494\"],\n8: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\",\"#e5c494\",\"#b3b3b3\"]\n},Set3: {\n3: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\"],\n4: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\"],\n5: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\"],\n6: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\"],\n7: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\"],\n8: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\"],\n9: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\"],\n10: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\"],\n11: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\",\"#ccebc5\"],\n12: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\",\"#ccebc5\",\"#ffed6f\"]\n}};\n\nif (typeof define === \"function\" && define.amd) {\n    define(colorbrewer);\n} else if (typeof module === \"object\" && module.exports) {\n    module.exports = colorbrewer;\n} else {\n    this.colorbrewer = colorbrewer;\n}\n\n}();\n\n},{}],3:[function(require,module,exports){\nmodule.exports = require('./colorbrewer.js');\n\n},{\"./colorbrewer.js\":2}],4:[function(require,module,exports){\nif (typeof Map === \"undefined\") {\n  Map = function() { this.clear(); };\n  Map.prototype = {\n    set: function(k, v) { this._[k] = v; return this; },\n    get: function(k) { return this._[k]; },\n    has: function(k) { return k in this._; },\n    delete: function(k) { return k in this._ && delete this._[k]; },\n    clear: function() { this._ = Object.create(null); },\n    get size() { var n = 0; for (var k in this._) ++n; return n; },\n    forEach: function(c) { for (var k in this._) c(this._[k], k, this); }\n  };\n} else (function() {\n  var m = new Map;\n  if (m.set(0, 0) !== m) {\n    m = m.set;\n    Map.prototype.set = function() { m.apply(this, arguments); return this; };\n  }\n})();\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.color = {}));\n}(this, function (exports) { 'use strict';\n\n  function deltaHue(h1, h0) {\n    var delta = h1 - h0;\n    return delta > 180 || delta < -180\n        ? delta - 360 * Math.round(delta / 360)\n        : delta;\n  }\n\n  function Color() {}\n\n  var reHex3 = /^#([0-9a-f]{3})$/;\n  var reHex6 = /^#([0-9a-f]{6})$/;\n  var reRgbInteger = /^rgb\\(\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*\\)$/;\n  var reRgbPercent = /^rgb\\(\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n  var reHslPercent = /^hsl\\(\\s*([-+]?\\d+(?:\\.\\d+)?)\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n\n  color.prototype = Color.prototype = {\n    displayable: function() {\n      return this.rgb().displayable();\n    },\n    toString: function() {\n      return this.rgb() + \"\";\n    }\n  };\n\n  function color(format) {\n    var m;\n    format = (format + \"\").trim().toLowerCase();\n    return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf))) // #f00\n        : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000\n        : (m = reRgbInteger.exec(format)) ? rgb(m[1], m[2], m[3]) // rgb(255,0,0)\n        : (m = reRgbPercent.exec(format)) ? rgb(m[1] * 2.55, m[2] * 2.55, m[3] * 2.55) // rgb(100%,0%,0%)\n        : (m = reHslPercent.exec(format)) ? hsl(m[1], m[2] * .01, m[3] * .01) // hsl(120,50%,50%)\n        : named.has(format) ? rgbn(named.get(format))\n        : null;\n  }\n\n  function rgbn(n) {\n    return rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff);\n  }\n\n  var named = (new Map)\n      .set(\"aliceblue\", 0xf0f8ff)\n      .set(\"antiquewhite\", 0xfaebd7)\n      .set(\"aqua\", 0x00ffff)\n      .set(\"aquamarine\", 0x7fffd4)\n      .set(\"azure\", 0xf0ffff)\n      .set(\"beige\", 0xf5f5dc)\n      .set(\"bisque\", 0xffe4c4)\n      .set(\"black\", 0x000000)\n      .set(\"blanchedalmond\", 0xffebcd)\n      .set(\"blue\", 0x0000ff)\n      .set(\"blueviolet\", 0x8a2be2)\n      .set(\"brown\", 0xa52a2a)\n      .set(\"burlywood\", 0xdeb887)\n      .set(\"cadetblue\", 0x5f9ea0)\n      .set(\"chartreuse\", 0x7fff00)\n      .set(\"chocolate\", 0xd2691e)\n      .set(\"coral\", 0xff7f50)\n      .set(\"cornflowerblue\", 0x6495ed)\n      .set(\"cornsilk\", 0xfff8dc)\n      .set(\"crimson\", 0xdc143c)\n      .set(\"cyan\", 0x00ffff)\n      .set(\"darkblue\", 0x00008b)\n      .set(\"darkcyan\", 0x008b8b)\n      .set(\"darkgoldenrod\", 0xb8860b)\n      .set(\"darkgray\", 0xa9a9a9)\n      .set(\"darkgreen\", 0x006400)\n      .set(\"darkgrey\", 0xa9a9a9)\n      .set(\"darkkhaki\", 0xbdb76b)\n      .set(\"darkmagenta\", 0x8b008b)\n      .set(\"darkolivegreen\", 0x556b2f)\n      .set(\"darkorange\", 0xff8c00)\n      .set(\"darkorchid\", 0x9932cc)\n      .set(\"darkred\", 0x8b0000)\n      .set(\"darksalmon\", 0xe9967a)\n      .set(\"darkseagreen\", 0x8fbc8f)\n      .set(\"darkslateblue\", 0x483d8b)\n      .set(\"darkslategray\", 0x2f4f4f)\n      .set(\"darkslategrey\", 0x2f4f4f)\n      .set(\"darkturquoise\", 0x00ced1)\n      .set(\"darkviolet\", 0x9400d3)\n      .set(\"deeppink\", 0xff1493)\n      .set(\"deepskyblue\", 0x00bfff)\n      .set(\"dimgray\", 0x696969)\n      .set(\"dimgrey\", 0x696969)\n      .set(\"dodgerblue\", 0x1e90ff)\n      .set(\"firebrick\", 0xb22222)\n      .set(\"floralwhite\", 0xfffaf0)\n      .set(\"forestgreen\", 0x228b22)\n      .set(\"fuchsia\", 0xff00ff)\n      .set(\"gainsboro\", 0xdcdcdc)\n      .set(\"ghostwhite\", 0xf8f8ff)\n      .set(\"gold\", 0xffd700)\n      .set(\"goldenrod\", 0xdaa520)\n      .set(\"gray\", 0x808080)\n      .set(\"green\", 0x008000)\n      .set(\"greenyellow\", 0xadff2f)\n      .set(\"grey\", 0x808080)\n      .set(\"honeydew\", 0xf0fff0)\n      .set(\"hotpink\", 0xff69b4)\n      .set(\"indianred\", 0xcd5c5c)\n      .set(\"indigo\", 0x4b0082)\n      .set(\"ivory\", 0xfffff0)\n      .set(\"khaki\", 0xf0e68c)\n      .set(\"lavender\", 0xe6e6fa)\n      .set(\"lavenderblush\", 0xfff0f5)\n      .set(\"lawngreen\", 0x7cfc00)\n      .set(\"lemonchiffon\", 0xfffacd)\n      .set(\"lightblue\", 0xadd8e6)\n      .set(\"lightcoral\", 0xf08080)\n      .set(\"lightcyan\", 0xe0ffff)\n      .set(\"lightgoldenrodyellow\", 0xfafad2)\n      .set(\"lightgray\", 0xd3d3d3)\n      .set(\"lightgreen\", 0x90ee90)\n      .set(\"lightgrey\", 0xd3d3d3)\n      .set(\"lightpink\", 0xffb6c1)\n      .set(\"lightsalmon\", 0xffa07a)\n      .set(\"lightseagreen\", 0x20b2aa)\n      .set(\"lightskyblue\", 0x87cefa)\n      .set(\"lightslategray\", 0x778899)\n      .set(\"lightslategrey\", 0x778899)\n      .set(\"lightsteelblue\", 0xb0c4de)\n      .set(\"lightyellow\", 0xffffe0)\n      .set(\"lime\", 0x00ff00)\n      .set(\"limegreen\", 0x32cd32)\n      .set(\"linen\", 0xfaf0e6)\n      .set(\"magenta\", 0xff00ff)\n      .set(\"maroon\", 0x800000)\n      .set(\"mediumaquamarine\", 0x66cdaa)\n      .set(\"mediumblue\", 0x0000cd)\n      .set(\"mediumorchid\", 0xba55d3)\n      .set(\"mediumpurple\", 0x9370db)\n      .set(\"mediumseagreen\", 0x3cb371)\n      .set(\"mediumslateblue\", 0x7b68ee)\n      .set(\"mediumspringgreen\", 0x00fa9a)\n      .set(\"mediumturquoise\", 0x48d1cc)\n      .set(\"mediumvioletred\", 0xc71585)\n      .set(\"midnightblue\", 0x191970)\n      .set(\"mintcream\", 0xf5fffa)\n      .set(\"mistyrose\", 0xffe4e1)\n      .set(\"moccasin\", 0xffe4b5)\n      .set(\"navajowhite\", 0xffdead)\n      .set(\"navy\", 0x000080)\n      .set(\"oldlace\", 0xfdf5e6)\n      .set(\"olive\", 0x808000)\n      .set(\"olivedrab\", 0x6b8e23)\n      .set(\"orange\", 0xffa500)\n      .set(\"orangered\", 0xff4500)\n      .set(\"orchid\", 0xda70d6)\n      .set(\"palegoldenrod\", 0xeee8aa)\n      .set(\"palegreen\", 0x98fb98)\n      .set(\"paleturquoise\", 0xafeeee)\n      .set(\"palevioletred\", 0xdb7093)\n      .set(\"papayawhip\", 0xffefd5)\n      .set(\"peachpuff\", 0xffdab9)\n      .set(\"peru\", 0xcd853f)\n      .set(\"pink\", 0xffc0cb)\n      .set(\"plum\", 0xdda0dd)\n      .set(\"powderblue\", 0xb0e0e6)\n      .set(\"purple\", 0x800080)\n      .set(\"rebeccapurple\", 0x663399)\n      .set(\"red\", 0xff0000)\n      .set(\"rosybrown\", 0xbc8f8f)\n      .set(\"royalblue\", 0x4169e1)\n      .set(\"saddlebrown\", 0x8b4513)\n      .set(\"salmon\", 0xfa8072)\n      .set(\"sandybrown\", 0xf4a460)\n      .set(\"seagreen\", 0x2e8b57)\n      .set(\"seashell\", 0xfff5ee)\n      .set(\"sienna\", 0xa0522d)\n      .set(\"silver\", 0xc0c0c0)\n      .set(\"skyblue\", 0x87ceeb)\n      .set(\"slateblue\", 0x6a5acd)\n      .set(\"slategray\", 0x708090)\n      .set(\"slategrey\", 0x708090)\n      .set(\"snow\", 0xfffafa)\n      .set(\"springgreen\", 0x00ff7f)\n      .set(\"steelblue\", 0x4682b4)\n      .set(\"tan\", 0xd2b48c)\n      .set(\"teal\", 0x008080)\n      .set(\"thistle\", 0xd8bfd8)\n      .set(\"tomato\", 0xff6347)\n      .set(\"turquoise\", 0x40e0d0)\n      .set(\"violet\", 0xee82ee)\n      .set(\"wheat\", 0xf5deb3)\n      .set(\"white\", 0xffffff)\n      .set(\"whitesmoke\", 0xf5f5f5)\n      .set(\"yellow\", 0xffff00)\n      .set(\"yellowgreen\", 0x9acd32);\n\n  var darker = .7;\n  var brighter = 1 / darker;\n\n  function rgb(r, g, b) {\n    if (arguments.length === 1) {\n      if (!(r instanceof Color)) r = color(r);\n      if (r) {\n        r = r.rgb();\n        b = r.b;\n        g = r.g;\n        r = r.r;\n      } else {\n        r = g = b = NaN;\n      }\n    }\n    return new Rgb(r, g, b);\n  }\n\n  function Rgb(r, g, b) {\n    this.r = +r;\n    this.g = +g;\n    this.b = +b;\n  }\n\n  var _prototype = rgb.prototype = Rgb.prototype = new Color;\n\n  _prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k);\n  };\n\n  _prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k);\n  };\n\n  _prototype.rgb = function() {\n    return this;\n  };\n\n  _prototype.displayable = function() {\n    return (0 <= this.r && this.r <= 255)\n        && (0 <= this.g && this.g <= 255)\n        && (0 <= this.b && this.b <= 255);\n  };\n\n  _prototype.toString = function() {\n    return format(this.r, this.g, this.b);\n  };\n\n  function format(r, g, b) {\n    return \"#\"\n        + (isNaN(r) ? \"00\" : (r = Math.round(r)) < 16 ? \"0\" + Math.max(0, r).toString(16) : Math.min(255, r).toString(16))\n        + (isNaN(g) ? \"00\" : (g = Math.round(g)) < 16 ? \"0\" + Math.max(0, g).toString(16) : Math.min(255, g).toString(16))\n        + (isNaN(b) ? \"00\" : (b = Math.round(b)) < 16 ? \"0\" + Math.max(0, b).toString(16) : Math.min(255, b).toString(16));\n  }\n\n  function hsl(h, s, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Hsl) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n      } else {\n        if (!(h instanceof Color)) h = color(h);\n        if (h) {\n          if (h instanceof Hsl) return h;\n          h = h.rgb();\n          var r = h.r / 255,\n              g = h.g / 255,\n              b = h.b / 255,\n              min = Math.min(r, g, b),\n              max = Math.max(r, g, b),\n              range = max - min;\n          l = (max + min) / 2;\n          if (range) {\n            s = l < .5 ? range / (max + min) : range / (2 - max - min);\n            if (r === max) h = (g - b) / range + (g < b) * 6;\n            else if (g === max) h = (b - r) / range + 2;\n            else h = (r - g) / range + 4;\n            h *= 60;\n          } else {\n            h = NaN;\n            s = l > 0 && l < 1 ? 0 : h;\n          }\n        } else {\n          h = s = l = NaN;\n        }\n      }\n    }\n    return new Hsl(h, s, l);\n  }\n\n  function Hsl(h, s, l) {\n    this.h = +h;\n    this.s = +s;\n    this.l = +l;\n  }\n\n  var __prototype = hsl.prototype = Hsl.prototype = new Color;\n\n  __prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Hsl(this.h, this.s, this.l * k);\n  };\n\n  __prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Hsl(this.h, this.s, this.l * k);\n  };\n\n  __prototype.rgb = function() {\n    var h = this.h % 360 + (this.h < 0) * 360,\n        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,\n        l = this.l,\n        m2 = l + (l < .5 ? l : 1 - l) * s,\n        m1 = 2 * l - m2;\n    return new Rgb(\n      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),\n      hsl2rgb(h, m1, m2),\n      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2)\n    );\n  };\n\n  __prototype.displayable = function() {\n    return (0 <= this.s && this.s <= 1 || isNaN(this.s))\n        && (0 <= this.l && this.l <= 1);\n  };\n\n  /* From FvD 13.37, CSS Color Module Level 3 */\n  function hsl2rgb(h, m1, m2) {\n    return (h < 60 ? m1 + (m2 - m1) * h / 60\n        : h < 180 ? m2\n        : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60\n        : m1) * 255;\n  }\n\n  var Kn = 18;\n\n  var Xn = 0.950470;\n  var Yn = 1;\n  var Zn = 1.088830;\n  var t0 = 4 / 29;\n  var t1 = 6 / 29;\n  var t2 = 3 * t1 * t1;\n  var t3 = t1 * t1 * t1;\n\n  function lab(l, a, b) {\n    if (arguments.length === 1) {\n      if (l instanceof Lab) {\n        b = l.b;\n        a = l.a;\n        l = l.l;\n      } else if (l instanceof Hcl) {\n        var h = l.h * deg2rad;\n        b = Math.sin(h) * l.c;\n        a = Math.cos(h) * l.c;\n        l = l.l;\n      } else {\n        if (!(l instanceof Rgb)) l = rgb(l);\n        var r = rgb2xyz(l.r),\n            g = rgb2xyz(l.g),\n            b = rgb2xyz(l.b),\n            x = xyz2lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / Xn),\n            y = xyz2lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / Yn),\n            z = xyz2lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / Zn);\n        b = 200 * (y - z);\n        a = 500 * (x - y);\n        l = 116 * y - 16;\n      }\n    }\n    return new Lab(l, a, b);\n  }\n\n  function Lab(l, a, b) {\n    this.l = +l;\n    this.a = +a;\n    this.b = +b;\n  }\n\n  var ___prototype = lab.prototype = Lab.prototype = new Color;\n\n  ___prototype.brighter = function(k) {\n    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b);\n  };\n\n  ___prototype.darker = function(k) {\n    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b);\n  };\n\n  ___prototype.rgb = function() {\n    var y = (this.l + 16) / 116,\n        x = isNaN(this.a) ? y : y + this.a / 500,\n        z = isNaN(this.b) ? y : y - this.b / 200;\n    y = Yn * lab2xyz(y);\n    x = Xn * lab2xyz(x);\n    z = Zn * lab2xyz(z);\n    return new Rgb(\n      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB\n      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),\n      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z)\n    );\n  };\n\n  function xyz2lab(t) {\n    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n  }\n\n  function lab2xyz(t) {\n    return t > t1 ? t * t * t : t2 * (t - t0);\n  }\n\n  function xyz2rgb(x) {\n    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n  }\n\n  function rgb2xyz(x) {\n    return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n  }\n\n  var deg2rad = Math.PI / 180;\n  var rad2deg = 180 / Math.PI;\n\n  function hcl(h, c, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Hcl) {\n        l = h.l;\n        c = h.c;\n        h = h.h;\n      } else {\n        if (!(h instanceof Lab)) h = lab(h);\n        l = h.l;\n        c = Math.sqrt(h.a * h.a + h.b * h.b);\n        h = Math.atan2(h.b, h.a) * rad2deg;\n        if (h < 0) h += 360;\n      }\n    }\n    return new Hcl(h, c, l);\n  }\n\n  function Hcl(h, c, l) {\n    this.h = +h;\n    this.c = +c;\n    this.l = +l;\n  }\n\n  var ____prototype = hcl.prototype = Hcl.prototype = new Color;\n\n  ____prototype.brighter = function(k) {\n    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k));\n  };\n\n  ____prototype.darker = function(k) {\n    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k));\n  };\n\n  ____prototype.rgb = function() {\n    return lab(this).rgb();\n  };\n\n  var A = -0.14861;\n  var B = +1.78277;\n  var C = -0.29227;\n  var D = -0.90649;\n  var E = +1.97294;\n  var ED = E * D;\n  var EB = E * B;\n  var BC_DA = B * C - D * A;\n\n  function cubehelix(h, s, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Cubehelix) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n      } else {\n        if (!(h instanceof Rgb)) h = rgb(h);\n        var r = h.r / 255, g = h.g / 255, b = h.b / 255;\n        l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB);\n        var bl = b - l, k = (E * (g - l) - C * bl) / D;\n        s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)); // NaN if l=0 or l=1\n        h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;\n        if (h < 0) h += 360;\n      }\n    }\n    return new Cubehelix(h, s, l);\n  }\n\n  function Cubehelix(h, s, l) {\n    this.h = +h;\n    this.s = +s;\n    this.l = +l;\n  }\n\n  var prototype = cubehelix.prototype = Cubehelix.prototype = new Color;\n\n  prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Cubehelix(this.h, this.s, this.l * k);\n  };\n\n  prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Cubehelix(this.h, this.s, this.l * k);\n  };\n\n  prototype.rgb = function() {\n    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,\n        l = +this.l,\n        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),\n        cosh = Math.cos(h),\n        sinh = Math.sin(h);\n    return new Rgb(\n      255 * (l + a * (A * cosh + B * sinh)),\n      255 * (l + a * (C * cosh + D * sinh)),\n      255 * (l + a * (E * cosh))\n    );\n  };\n\n  function interpolateCubehelixGamma(gamma) {\n    return function(a, b) {\n      a = cubehelix(a);\n      b = cubehelix(b);\n      var ah = isNaN(a.h) ? b.h : a.h,\n          as = isNaN(a.s) ? b.s : a.s,\n          al = a.l,\n          bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n          bs = isNaN(b.s) ? 0 : b.s - as,\n          bl = b.l - al;\n      return function(t) {\n        a.h = ah + bh * t;\n        a.s = as + bs * t;\n        a.l = al + bl * Math.pow(t, gamma);\n        return a + \"\";\n      };\n    };\n  }\n\n  function interpolateCubehelixGammaLong(gamma) {\n    return function(a, b) {\n      a = cubehelix(a);\n      b = cubehelix(b);\n      var ah = isNaN(a.h) ? b.h : a.h,\n          as = isNaN(a.s) ? b.s : a.s,\n          al = a.l,\n          bh = isNaN(b.h) ? 0 : b.h - ah,\n          bs = isNaN(b.s) ? 0 : b.s - as,\n          bl = b.l - al;\n      return function(t) {\n        a.h = ah + bh * t;\n        a.s = as + bs * t;\n        a.l = al + bl * Math.pow(t, gamma);\n        return a + \"\";\n      };\n    };\n  }\n\n  function interpolateHclLong(a, b) {\n    a = hcl(a);\n    b = hcl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        ac = isNaN(a.c) ? b.c : a.c,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : b.h - ah,\n        bc = isNaN(b.c) ? 0 : b.c - ac,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.c = ac + bc * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHcl(a, b) {\n    a = hcl(a);\n    b = hcl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        ac = isNaN(a.c) ? b.c : a.c,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n        bc = isNaN(b.c) ? 0 : b.c - ac,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.c = ac + bc * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateLab(a, b) {\n    a = lab(a);\n    b = lab(b);\n    var al = a.l,\n        aa = a.a,\n        ab = a.b,\n        bl = b.l - al,\n        ba = b.a - aa,\n        bb = b.b - ab;\n    return function(t) {\n      a.l = al + bl * t;\n      a.a = aa + ba * t;\n      a.b = ab + bb * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHslLong(a, b) {\n    a = hsl(a);\n    b = hsl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : b.h - ah,\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHsl(a, b) {\n    a = hsl(a);\n    b = hsl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateRgb(a, b) {\n    a = rgb(a);\n    b = rgb(b);\n    var ar = a.r,\n        ag = a.g,\n        ab = a.b,\n        br = b.r - ar,\n        bg = b.g - ag,\n        bb = b.b - ab;\n    return function(t) {\n      return format(Math.round(ar + br * t), Math.round(ag + bg * t), Math.round(ab + bb * t));\n    };\n  }\n\n  exports.interpolateCubehelix = interpolateCubehelixGamma(1);\n  exports.interpolateCubehelixLong = interpolateCubehelixGammaLong(1);\n\n  exports.color = color;\n  exports.rgb = rgb;\n  exports.hsl = hsl;\n  exports.lab = lab;\n  exports.hcl = hcl;\n  exports.cubehelix = cubehelix;\n  exports.interpolateRgb = interpolateRgb;\n  exports.interpolateHsl = interpolateHsl;\n  exports.interpolateHslLong = interpolateHslLong;\n  exports.interpolateLab = interpolateLab;\n  exports.interpolateHcl = interpolateHcl;\n  exports.interpolateHclLong = interpolateHclLong;\n  exports.interpolateCubehelixGamma = interpolateCubehelixGamma;\n  exports.interpolateCubehelixGammaLong = interpolateCubehelixGammaLong;\n\n}));\n},{}],5:[function(require,module,exports){\nif (typeof Map === \"undefined\") {\n  Map = function() { this.clear(); };\n  Map.prototype = {\n    set: function(k, v) { this._[k] = v; return this; },\n    get: function(k) { return this._[k]; },\n    has: function(k) { return k in this._; },\n    delete: function(k) { return k in this._ && delete this._[k]; },\n    clear: function() { this._ = Object.create(null); },\n    get size() { var n = 0; for (var k in this._) ++n; return n; },\n    forEach: function(c) { for (var k in this._) c(this._[k], k, this); }\n  };\n} else (function() {\n  var m = new Map;\n  if (m.set(0, 0) !== m) {\n    m = m.set;\n    Map.prototype.set = function() { m.apply(this, arguments); return this; };\n  }\n})();\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.format = {}));\n}(this, function (exports) { 'use strict';\n\n  var zhCn = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  };\n\n  var ruRu = {\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0.\"]\n  };\n\n  var ptBr = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"R$\", \"\"]\n  };\n\n  var plPl = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"z\"]\n  };\n\n  var nlNl = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\\xa0\", \"\"]\n  };\n\n  var mkMk = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0.\"]\n  };\n\n  var itIt = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  };\n\n  var heIl = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  };\n\n  var frFr = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  };\n\n  var frCa = {\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"$\"]\n  };\n\n  var fiFi = {\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  };\n\n  var esEs = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  };\n\n  var enUs = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"$\", \"\"]\n  };\n\n  var enGb = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  };\n\n  var enCa = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"$\", \"\"]\n  };\n\n  var deDe = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  };\n\n  var caEs = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  };\n\n\n  // Computes the decimal coefficient and exponent of the specified number x with\n  // significant digits p, where x is positive and p is in [1, 21] or undefined.\n  // For example, formatDecimal(1.23) returns [\"123\", 0].\n  function formatDecimal(x, p) {\n    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, Infinity\n    var i, coefficient = x.slice(0, i);\n\n    // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n    // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n    return [\n      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n      +x.slice(i + 1)\n    ];\n  }\n\n  function exponent(x) {\n    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;\n  }\n\n  var prefixExponent;\n\n  function formatPrefixAuto(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1],\n        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n        n = coefficient.length;\n    return i === n ? coefficient\n        : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n        : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n        : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimal(x, p + i - 1)[0]; // less than 1y!\n  }\n\n  function formatRounded(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1];\n    return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n        : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n  }\n\n  function formatDefault(x, p) {\n    x = x.toPrecision(p);\n\n    out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {\n      switch (x[i]) {\n        case \".\": i0 = i1 = i; break;\n        case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n        case \"e\": break out;\n        default: if (i0 > 0) i0 = 0; break;\n      }\n    }\n\n    return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;\n  }\n\n  var formatTypes = {\n    \"\": formatDefault,\n    \"%\": function(x, p) { return (x * 100).toFixed(p); },\n    \"b\": function(x) { return Math.round(x).toString(2); },\n    \"c\": function(x) { return x + \"\"; },\n    \"d\": function(x) { return Math.round(x).toString(10); },\n    \"e\": function(x, p) { return x.toExponential(p); },\n    \"f\": function(x, p) { return x.toFixed(p); },\n    \"g\": function(x, p) { return x.toPrecision(p); },\n    \"o\": function(x) { return Math.round(x).toString(8); },\n    \"p\": function(x, p) { return formatRounded(x * 100, p); },\n    \"r\": formatRounded,\n    \"s\": formatPrefixAuto,\n    \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n    \"x\": function(x) { return Math.round(x).toString(16); }\n  };\n\n\n  // [[fill]align][sign][symbol][0][width][,][.precision][type]\n  var re = /^(?:(.)?([<>=^]))?([+\\-\\( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?([a-z%])?$/i;\n\n  function formatSpecifier(specifier) {\n    return new FormatSpecifier(specifier);\n  }\n\n  function FormatSpecifier(specifier) {\n    if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n\n    var match,\n        fill = match[1] || \" \",\n        align = match[2] || \">\",\n        sign = match[3] || \"-\",\n        symbol = match[4] || \"\",\n        zero = !!match[5],\n        width = match[6] && +match[6],\n        comma = !!match[7],\n        precision = match[8] && +match[8].slice(1),\n        type = match[9] || \"\";\n\n    // The \"n\" type is an alias for \",g\".\n    if (type === \"n\") comma = true, type = \"g\";\n\n    // Map invalid types to the default format.\n    else if (!formatTypes[type]) type = \"\";\n\n    // If zero fill is specified, padding goes after sign and before digits.\n    if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n    this.fill = fill;\n    this.align = align;\n    this.sign = sign;\n    this.symbol = symbol;\n    this.zero = zero;\n    this.width = width;\n    this.comma = comma;\n    this.precision = precision;\n    this.type = type;\n  }\n\n  FormatSpecifier.prototype.toString = function() {\n    return this.fill\n        + this.align\n        + this.sign\n        + this.symbol\n        + (this.zero ? \"0\" : \"\")\n        + (this.width == null ? \"\" : Math.max(1, this.width | 0))\n        + (this.comma ? \",\" : \"\")\n        + (this.precision == null ? \"\" : \".\" + Math.max(0, this.precision | 0))\n        + this.type;\n  };\n\n  function formatGroup(grouping, thousands) {\n    return function(value, width) {\n      var i = value.length,\n          t = [],\n          j = 0,\n          g = grouping[0],\n          length = 0;\n\n      while (i > 0 && g > 0) {\n        if (length + g + 1 > width) g = Math.max(1, width - length);\n        t.push(value.substring(i -= g, i + g));\n        if ((length += g + 1) > width) break;\n        g = grouping[j = (j + 1) % grouping.length];\n      }\n\n      return t.reverse().join(thousands);\n    };\n  }\n\n  var prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\n  function identity(x) {\n    return x;\n  }\n\n  function locale(locale) {\n    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,\n        currency = locale.currency,\n        decimal = locale.decimal;\n\n    function format(specifier) {\n      specifier = formatSpecifier(specifier);\n\n      var fill = specifier.fill,\n          align = specifier.align,\n          sign = specifier.sign,\n          symbol = specifier.symbol,\n          zero = specifier.zero,\n          width = specifier.width,\n          comma = specifier.comma,\n          precision = specifier.precision,\n          type = specifier.type;\n\n      // Compute the prefix and suffix.\n      // For SI-prefix, the suffix is lazily computed.\n      var prefix = symbol === \"$\" ? currency[0] : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n          suffix = symbol === \"$\" ? currency[1] : /[%p]/.test(type) ? \"%\" : \"\";\n\n      // What format function should we use?\n      // Is this an integer type?\n      // Can this type generate exponential notation?\n      var formatType = formatTypes[type],\n          maybeSuffix = !type || /[defgprs%]/.test(type);\n\n      // Set the default precision if not specified,\n      // or clamp the specified precision to the supported range.\n      // For significant precision, it must be in [1, 21].\n      // For fixed precision, it must be in [0, 20].\n      precision = precision == null ? (type ? 6 : 12)\n          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n          : Math.max(0, Math.min(20, precision));\n\n      return function(value) {\n        var valuePrefix = prefix,\n            valueSuffix = suffix;\n\n        if (type === \"c\") {\n          valueSuffix = formatType(value) + valueSuffix;\n          value = \"\";\n        } else {\n          value = +value;\n\n          // Convert negative to positive, and compute the prefix.\n          // Note that -0 is not less than 0, but 1 / -0 is!\n          var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);\n\n          // Perform the initial formatting.\n          value = formatType(value, precision);\n\n          // Compute the prefix and suffix.\n          valuePrefix = (valueNegative ? (sign === \"(\" ? sign : \"-\") : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n          valueSuffix = valueSuffix + (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n          // Break the formatted value into the integer value part that can be\n          // grouped, and fractional or exponential suffix part that is not.\n          if (maybeSuffix) {\n            var i = -1, n = value.length, c;\n            while (++i < n) {\n              if (c = value.charCodeAt(i), 48 > c || c > 57) {\n                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n                value = value.slice(0, i);\n                break;\n              }\n            }\n          }\n        }\n\n        // If the fill character is not \"0\", grouping is applied before padding.\n        if (comma && !zero) value = group(value, Infinity);\n\n        // Compute the padding.\n        var length = valuePrefix.length + value.length + valueSuffix.length,\n            padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n        // If the fill character is \"0\", grouping is applied after padding.\n        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n        // Reconstruct the final output based on the desired alignment.\n        switch (align) {\n          case \"<\": return valuePrefix + value + valueSuffix + padding;\n          case \"=\": return valuePrefix + padding + value + valueSuffix;\n          case \"^\": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);\n        }\n        return padding + valuePrefix + value + valueSuffix;\n      };\n    }\n\n    function formatPrefix(specifier, value) {\n      var f = format((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,\n          k = Math.pow(10, -e),\n          prefix = prefixes[8 + e / 3];\n      return function(value) {\n        return f(k * value) + prefix;\n      };\n    }\n\n    return {\n      format: format,\n      formatPrefix: formatPrefix\n    };\n  }\n\n  function precisionRound(step, max) {\n    return Math.max(0, exponent(Math.abs(max)) - exponent(Math.abs(step))) + 1;\n  }\n\n  function precisionPrefix(step, value) {\n    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));\n  }\n\n  function precisionFixed(step) {\n    return Math.max(0, -exponent(Math.abs(step)));\n  }\n\n  var localeDefinitions = (new Map)\n      .set(\"ca-ES\", caEs)\n      .set(\"de-DE\", deDe)\n      .set(\"en-CA\", enCa)\n      .set(\"en-GB\", enGb)\n      .set(\"en-US\", enUs)\n      .set(\"es-ES\", esEs)\n      .set(\"fi-FI\", fiFi)\n      .set(\"fr-CA\", frCa)\n      .set(\"fr-FR\", frFr)\n      .set(\"he-IL\", heIl)\n      .set(\"it-IT\", itIt)\n      .set(\"mk-MK\", mkMk)\n      .set(\"nl-NL\", nlNl)\n      .set(\"pl-PL\", plPl)\n      .set(\"pt-BR\", ptBr)\n      .set(\"ru-RU\", ruRu)\n      .set(\"zh-CN\", zhCn);\n\n  var defaultLocale = locale(enUs);\n  exports.format = defaultLocale.format;\n  exports.formatPrefix = defaultLocale.formatPrefix;\n\n  function localeFormat(definition) {\n    if (typeof definition === \"string\") {\n      definition = localeDefinitions.get(definition);\n      if (!definition) return null;\n    }\n    return locale(definition);\n  }\n  ;\n\n  exports.localeFormat = localeFormat;\n  exports.formatSpecifier = formatSpecifier;\n  exports.precisionFixed = precisionFixed;\n  exports.precisionPrefix = precisionPrefix;\n  exports.precisionRound = precisionRound;\n\n}));\n},{}],6:[function(require,module,exports){\nif (typeof Map === \"undefined\") {\n  Map = function() { this.clear(); };\n  Map.prototype = {\n    set: function(k, v) { this._[k] = v; return this; },\n    get: function(k) { return this._[k]; },\n    has: function(k) { return k in this._; },\n    delete: function(k) { return k in this._ && delete this._[k]; },\n    clear: function() { this._ = Object.create(null); },\n    get size() { var n = 0; for (var k in this._) ++n; return n; },\n    forEach: function(c) { for (var k in this._) c(this._[k], k, this); }\n  };\n} else (function() {\n  var m = new Map;\n  if (m.set(0, 0) !== m) {\n    m = m.set;\n    Map.prototype.set = function() { m.apply(this, arguments); return this; };\n  }\n})();\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.timeFormat = {}));\n}(this, function (exports) { 'use strict';\n\n  var zhCn = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%Y/%-m/%-d\",\n    time: \"%H:%M:%S\",\n    periods: [\"\", \"\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  };\n\n  var ruRu = {\n    dateTime: \"%A, %e %B %Y . %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  };\n\n  var ptBr = {\n    dateTime: \"%A, %e de %B de %Y. %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Domingo\", \"Segunda\", \"Tera\", \"Quarta\", \"Quinta\", \"Sexta\", \"Sbado\"],\n    shortDays: [\"Dom\", \"Seg\", \"Ter\", \"Qua\", \"Qui\", \"Sex\", \"Sb\"],\n    months: [\"Janeiro\", \"Fevereiro\", \"Maro\", \"Abril\", \"Maio\", \"Junho\", \"Julho\", \"Agosto\", \"Setembro\", \"Outubro\", \"Novembro\", \"Dezembro\"],\n    shortMonths: [\"Jan\", \"Fev\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\"]\n  };\n\n  var plPl = {\n    dateTime: \"%A, %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Niedziela\", \"Poniedziaek\", \"Wtorek\", \"roda\", \"Czwartek\", \"Pitek\", \"Sobota\"],\n    shortDays: [\"Niedz.\", \"Pon.\", \"Wt.\", \"r.\", \"Czw.\", \"Pt.\", \"Sob.\"],\n    months: [\"Stycze\", \"Luty\", \"Marzec\", \"Kwiecie\", \"Maj\", \"Czerwiec\", \"Lipiec\", \"Sierpie\", \"Wrzesie\", \"Padziernik\", \"Listopad\", \"Grudzie\"],\n    shortMonths: [\"Stycz.\", \"Luty\", \"Marz.\", \"Kwie.\", \"Maj\", \"Czerw.\", \"Lipc.\", \"Sierp.\", \"Wrz.\", \"Padz.\", \"Listop.\", \"Grudz.\"]/* In Polish language abbraviated months are not commonly used so there is a dispute about the proper abbraviations. */\n  };\n\n  var nlNl = {\n    dateTime: \"%a %e %B %Y %T\",\n    date: \"%d-%m-%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"zondag\", \"maandag\", \"dinsdag\", \"woensdag\", \"donderdag\", \"vrijdag\", \"zaterdag\"],\n    shortDays: [\"zo\", \"ma\", \"di\", \"wo\", \"do\", \"vr\", \"za\"],\n    months: [\"januari\", \"februari\", \"maart\", \"april\", \"mei\", \"juni\", \"juli\", \"augustus\", \"september\", \"oktober\", \"november\", \"december\"],\n    shortMonths: [\"jan\", \"feb\", \"mrt\", \"apr\", \"mei\", \"jun\", \"jul\", \"aug\", \"sep\", \"okt\", \"nov\", \"dec\"]\n  };\n\n  var mkMk = {\n    dateTime: \"%A, %e %B %Y . %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  };\n\n  var itIt = {\n    dateTime: \"%A %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Domenica\", \"Luned\", \"Marted\", \"Mercoled\", \"Gioved\", \"Venerd\", \"Sabato\"],\n    shortDays: [\"Dom\", \"Lun\", \"Mar\", \"Mer\", \"Gio\", \"Ven\", \"Sab\"],\n    months: [\"Gennaio\", \"Febbraio\", \"Marzo\", \"Aprile\", \"Maggio\", \"Giugno\", \"Luglio\", \"Agosto\", \"Settembre\", \"Ottobre\", \"Novembre\", \"Dicembre\"],\n    shortMonths: [\"Gen\", \"Feb\", \"Mar\", \"Apr\", \"Mag\", \"Giu\", \"Lug\", \"Ago\", \"Set\", \"Ott\", \"Nov\", \"Dic\"]\n  };\n\n  var heIl = {\n    dateTime: \"%A, %e %B %Y %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  };\n\n  var frFr = {\n    dateTime: \"%A, le %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"],\n    shortDays: [\"dim.\", \"lun.\", \"mar.\", \"mer.\", \"jeu.\", \"ven.\", \"sam.\"],\n    months: [\"janvier\", \"fvrier\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"aot\", \"septembre\", \"octobre\", \"novembre\", \"dcembre\"],\n    shortMonths: [\"janv.\", \"fvr.\", \"mars\", \"avr.\", \"mai\", \"juin\", \"juil.\", \"aot\", \"sept.\", \"oct.\", \"nov.\", \"dc.\"]\n  };\n\n  var frCa = {\n    dateTime: \"%a %e %b %Y %X\",\n    date: \"%Y-%m-%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"\", \"\"],\n    days: [\"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"],\n    shortDays: [\"dim\", \"lun\", \"mar\", \"mer\", \"jeu\", \"ven\", \"sam\"],\n    months: [\"janvier\", \"fvrier\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"aot\", \"septembre\", \"octobre\", \"novembre\", \"dcembre\"],\n    shortMonths: [\"jan\", \"fv\", \"mar\", \"avr\", \"mai\", \"jui\", \"jul\", \"ao\", \"sep\", \"oct\", \"nov\", \"dc\"]\n  };\n\n  var fiFi = {\n    dateTime: \"%A, %-d. %Bta %Y klo %X\",\n    date: \"%-d.%-m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"a.m.\", \"p.m.\"],\n    days: [\"sunnuntai\", \"maanantai\", \"tiistai\", \"keskiviikko\", \"torstai\", \"perjantai\", \"lauantai\"],\n    shortDays: [\"Su\", \"Ma\", \"Ti\", \"Ke\", \"To\", \"Pe\", \"La\"],\n    months: [\"tammikuu\", \"helmikuu\", \"maaliskuu\", \"huhtikuu\", \"toukokuu\", \"keskuu\", \"heinkuu\", \"elokuu\", \"syyskuu\", \"lokakuu\", \"marraskuu\", \"joulukuu\"],\n    shortMonths: [\"Tammi\", \"Helmi\", \"Maalis\", \"Huhti\", \"Touko\", \"Kes\", \"Hein\", \"Elo\", \"Syys\", \"Loka\", \"Marras\", \"Joulu\"]\n  };\n\n  var esEs = {\n    dateTime: \"%A, %e de %B de %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"domingo\", \"lunes\", \"martes\", \"mircoles\", \"jueves\", \"viernes\", \"sbado\"],\n    shortDays: [\"dom\", \"lun\", \"mar\", \"mi\", \"jue\", \"vie\", \"sb\"],\n    months: [\"enero\", \"febrero\", \"marzo\", \"abril\", \"mayo\", \"junio\", \"julio\", \"agosto\", \"septiembre\", \"octubre\", \"noviembre\", \"diciembre\"],\n    shortMonths: [\"ene\", \"feb\", \"mar\", \"abr\", \"may\", \"jun\", \"jul\", \"ago\", \"sep\", \"oct\", \"nov\", \"dic\"]\n  };\n\n  var enUs = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%m/%d/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var enGb = {\n    dateTime: \"%a %e %b %X %Y\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var enCa = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%Y-%m-%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var deDe = {\n    dateTime: \"%A, der %e. %B %Y, %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Sonntag\", \"Montag\", \"Dienstag\", \"Mittwoch\", \"Donnerstag\", \"Freitag\", \"Samstag\"],\n    shortDays: [\"So\", \"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\", \"Sa\"],\n    months: [\"Januar\", \"Februar\", \"Mrz\", \"April\", \"Mai\", \"Juni\", \"Juli\", \"August\", \"September\", \"Oktober\", \"November\", \"Dezember\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mrz\", \"Apr\", \"Mai\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dez\"]\n  };\n\n  var caEs = {\n    dateTime: \"%A, %e de %B de %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"diumenge\", \"dilluns\", \"dimarts\", \"dimecres\", \"dijous\", \"divendres\", \"dissabte\"],\n    shortDays: [\"dg.\", \"dl.\", \"dt.\", \"dc.\", \"dj.\", \"dv.\", \"ds.\"],\n    months: [\"gener\", \"febrer\", \"mar\", \"abril\", \"maig\", \"juny\", \"juliol\", \"agost\", \"setembre\", \"octubre\", \"novembre\", \"desembre\"],\n    shortMonths: [\"gen.\", \"febr.\", \"mar\", \"abr.\", \"maig\", \"juny\", \"jul.\", \"ag.\", \"set.\", \"oct.\", \"nov.\", \"des.\"]\n  };\n\n  var t0 = new Date;\n  var t1 = new Date;\n\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  }\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var sunday = weekday(0);\n  var monday = weekday(1);\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcSunday = utcWeekday(0);\n  var utcMonday = utcWeekday(1);\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  function localDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n      date.setFullYear(d.y);\n      return date;\n    }\n    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n  }\n\n  function utcDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n      date.setUTCFullYear(d.y);\n      return date;\n    }\n    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n  }\n\n  function newYear(y) {\n    return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};\n  }\n\n  function locale(locale) {\n    var locale_dateTime = locale.dateTime,\n        locale_date = locale.date,\n        locale_time = locale.time,\n        locale_periods = locale.periods,\n        locale_weekdays = locale.days,\n        locale_shortWeekdays = locale.shortDays,\n        locale_months = locale.months,\n        locale_shortMonths = locale.shortMonths;\n\n    var periodLookup = formatLookup(locale_periods),\n        weekdayRe = formatRe(locale_weekdays),\n        weekdayLookup = formatLookup(locale_weekdays),\n        shortWeekdayRe = formatRe(locale_shortWeekdays),\n        shortWeekdayLookup = formatLookup(locale_shortWeekdays),\n        monthRe = formatRe(locale_months),\n        monthLookup = formatLookup(locale_months),\n        shortMonthRe = formatRe(locale_shortMonths),\n        shortMonthLookup = formatLookup(locale_shortMonths);\n\n    var formats = {\n      \"a\": formatShortWeekday,\n      \"A\": formatWeekday,\n      \"b\": formatShortMonth,\n      \"B\": formatMonth,\n      \"c\": null,\n      \"d\": formatDayOfMonth,\n      \"e\": formatDayOfMonth,\n      \"H\": formatHour24,\n      \"I\": formatHour12,\n      \"j\": formatDayOfYear,\n      \"L\": formatMilliseconds,\n      \"m\": formatMonthNumber,\n      \"M\": formatMinutes,\n      \"p\": formatPeriod,\n      \"S\": formatSeconds,\n      \"U\": formatWeekNumberSunday,\n      \"w\": formatWeekdayNumber,\n      \"W\": formatWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatYear,\n      \"Y\": formatFullYear,\n      \"Z\": formatZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var utcFormats = {\n      \"a\": formatUTCShortWeekday,\n      \"A\": formatUTCWeekday,\n      \"b\": formatUTCShortMonth,\n      \"B\": formatUTCMonth,\n      \"c\": null,\n      \"d\": formatUTCDayOfMonth,\n      \"e\": formatUTCDayOfMonth,\n      \"H\": formatUTCHour24,\n      \"I\": formatUTCHour12,\n      \"j\": formatUTCDayOfYear,\n      \"L\": formatUTCMilliseconds,\n      \"m\": formatUTCMonthNumber,\n      \"M\": formatUTCMinutes,\n      \"p\": formatUTCPeriod,\n      \"S\": formatUTCSeconds,\n      \"U\": formatUTCWeekNumberSunday,\n      \"w\": formatUTCWeekdayNumber,\n      \"W\": formatUTCWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatUTCYear,\n      \"Y\": formatUTCFullYear,\n      \"Z\": formatUTCZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var parses = {\n      \"a\": parseShortWeekday,\n      \"A\": parseWeekday,\n      \"b\": parseShortMonth,\n      \"B\": parseMonth,\n      \"c\": parseLocaleDateTime,\n      \"d\": parseDayOfMonth,\n      \"e\": parseDayOfMonth,\n      \"H\": parseHour24,\n      \"I\": parseHour24,\n      \"j\": parseDayOfYear,\n      \"L\": parseMilliseconds,\n      \"m\": parseMonthNumber,\n      \"M\": parseMinutes,\n      \"p\": parsePeriod,\n      \"S\": parseSeconds,\n      \"U\": parseWeekNumberSunday,\n      \"w\": parseWeekdayNumber,\n      \"W\": parseWeekNumberMonday,\n      \"x\": parseLocaleDate,\n      \"X\": parseLocaleTime,\n      \"y\": parseYear,\n      \"Y\": parseFullYear,\n      \"Z\": parseZone,\n      \"%\": parseLiteralPercent\n    };\n\n    // These recursive directive definitions must be deferred.\n    formats.x = newFormat(locale_date, formats);\n    formats.X = newFormat(locale_time, formats);\n    formats.c = newFormat(locale_dateTime, formats);\n    utcFormats.x = newFormat(locale_date, utcFormats);\n    utcFormats.X = newFormat(locale_time, utcFormats);\n    utcFormats.c = newFormat(locale_dateTime, utcFormats);\n\n    function newFormat(specifier, formats) {\n      return function(date) {\n        var string = [],\n            i = -1,\n            j = 0,\n            n = specifier.length,\n            c,\n            pad,\n            format;\n\n        while (++i < n) {\n          if (specifier.charCodeAt(i) === 37) {\n            string.push(specifier.slice(j, i));\n            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);\n            if (format = formats[c]) c = format(date, pad == null ? (c === \"e\" ? \" \" : \"0\") : pad);\n            string.push(c);\n            j = i + 1;\n          }\n        }\n\n        string.push(specifier.slice(j, i));\n        return string.join(\"\");\n      };\n    }\n\n    function newParse(specifier, newDate) {\n      return function(string) {\n        var d = newYear(1900),\n            i = parseSpecifier(d, specifier, string, 0);\n        if (i != string.length) return null;\n\n        // The am-pm flag is 0 for AM, and 1 for PM.\n        if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\n        // If a time zone is specified, all fields are interpreted as UTC and then\n        // offset according to the specified time zone.\n        if (\"Z\" in d) {\n          if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n            var day = utcDate(newYear(d.y)).getUTCDay();\n            if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n            d.m = 0;\n            d.d = d.w + d.U * 7 - (day + 6) % 7;\n          }\n          d.H += d.Z / 100 | 0;\n          d.M += d.Z % 100;\n          return utcDate(d);\n        }\n\n        // Otherwise, all fields are in local time.\n        if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n          var day = newDate(newYear(d.y)).getDay();\n          if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n          d.m = 0;\n          d.d = d.w + d.U * 7 - (day + 6) % 7;\n        }\n        return newDate(d);\n      };\n    }\n\n    function parseSpecifier(d, specifier, string, j) {\n      var i = 0,\n          n = specifier.length,\n          m = string.length,\n          c,\n          parse;\n\n      while (i < n) {\n        if (j >= m) return -1;\n        c = specifier.charCodeAt(i++);\n        if (c === 37) {\n          c = specifier.charAt(i++);\n          parse = parses[c in pads ? specifier.charAt(i++) : c];\n          if (!parse || ((j = parse(d, string, j)) < 0)) return -1;\n        } else if (c != string.charCodeAt(j++)) {\n          return -1;\n        }\n      }\n\n      return j;\n    }\n\n    function parseShortWeekday(d, string, i) {\n      var n = shortWeekdayRe.exec(string.slice(i));\n      return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseWeekday(d, string, i) {\n      var n = weekdayRe.exec(string.slice(i));\n      return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseShortMonth(d, string, i) {\n      var n = shortMonthRe.exec(string.slice(i));\n      return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseMonth(d, string, i) {\n      var n = monthRe.exec(string.slice(i));\n      return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseLocaleDateTime(d, string, i) {\n      return parseSpecifier(d, locale_dateTime, string, i);\n    }\n\n    function parseLocaleDate(d, string, i) {\n      return parseSpecifier(d, locale_date, string, i);\n    }\n\n    function parseLocaleTime(d, string, i) {\n      return parseSpecifier(d, locale_time, string, i);\n    }\n\n    function parsePeriod(d, string, i) {\n      var n = periodLookup.get(string.slice(i, i += 2).toLowerCase());\n      return n == null ? -1 : (d.p = n, i);\n    }\n\n    function formatShortWeekday(d) {\n      return locale_shortWeekdays[d.getDay()];\n    }\n\n    function formatWeekday(d) {\n      return locale_weekdays[d.getDay()];\n    }\n\n    function formatShortMonth(d) {\n      return locale_shortMonths[d.getMonth()];\n    }\n\n    function formatMonth(d) {\n      return locale_months[d.getMonth()];\n    }\n\n    function formatPeriod(d) {\n      return locale_periods[+(d.getHours() >= 12)];\n    }\n\n    function formatUTCShortWeekday(d) {\n      return locale_shortWeekdays[d.getUTCDay()];\n    }\n\n    function formatUTCWeekday(d) {\n      return locale_weekdays[d.getUTCDay()];\n    }\n\n    function formatUTCShortMonth(d) {\n      return locale_shortMonths[d.getUTCMonth()];\n    }\n\n    function formatUTCMonth(d) {\n      return locale_months[d.getUTCMonth()];\n    }\n\n    function formatUTCPeriod(d) {\n      return locale_periods[+(d.getUTCHours() >= 12)];\n    }\n\n    return {\n      format: function(specifier) {\n        var f = newFormat(specifier += \"\", formats);\n        f.parse = newParse(specifier, localDate);\n        f.toString = function() { return specifier; };\n        return f;\n      },\n      utcFormat: function(specifier) {\n        var f = newFormat(specifier += \"\", utcFormats);\n        f.parse = newParse(specifier, utcDate);\n        f.toString = function() { return specifier; };\n        return f;\n      }\n    };\n  }\n\n  var pads = {\"-\": \"\", \"_\": \" \", \"0\": \"0\"};\n  var numberRe = /^\\s*\\d+/;\n  var percentRe = /^%/;\n  var requoteRe = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\n  function pad(value, fill, width) {\n    var sign = value < 0 ? \"-\" : \"\",\n        string = (sign ? -value : value) + \"\",\n        length = string.length;\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n  }\n\n  function requote(s) {\n    return s.replace(requoteRe, \"\\\\$&\");\n  }\n\n  function formatRe(names) {\n    return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n  }\n\n  function formatLookup(names) {\n    var map = new Map, i = -1, n = names.length;\n    while (++i < n) map.set(names[i].toLowerCase(), i);\n    return map;\n  }\n\n  function parseWeekdayNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 1));\n    return n ? (d.w = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberSunday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.U = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberMonday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.W = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseFullYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 4));\n    return n ? (d.y = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n  }\n\n  function parseZone(d, string, i) {\n    return /^[+-]\\d{4}$/.test(string = string.slice(i, i + 5))\n        ? (d.Z = -string, i + 5) // sign differs from getTimezoneOffset!\n        : -1;\n  }\n\n  function parseMonthNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n  }\n\n  function parseDayOfMonth(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseDayOfYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseHour24(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.H = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMinutes(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.M = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseSeconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.S = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMilliseconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.L = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseLiteralPercent(d, string, i) {\n    var n = percentRe.exec(string.slice(i, i + 1));\n    return n ? i + n[0].length : -1;\n  }\n\n  function formatDayOfMonth(d, p) {\n    return pad(d.getDate(), p, 2);\n  }\n\n  function formatHour24(d, p) {\n    return pad(d.getHours(), p, 2);\n  }\n\n  function formatHour12(d, p) {\n    return pad(d.getHours() % 12 || 12, p, 2);\n  }\n\n  function formatDayOfYear(d, p) {\n    return pad(1 + day.count(year(d), d), p, 3);\n  }\n\n  function formatMilliseconds(d, p) {\n    return pad(d.getMilliseconds(), p, 3);\n  }\n\n  function formatMonthNumber(d, p) {\n    return pad(d.getMonth() + 1, p, 2);\n  }\n\n  function formatMinutes(d, p) {\n    return pad(d.getMinutes(), p, 2);\n  }\n\n  function formatSeconds(d, p) {\n    return pad(d.getSeconds(), p, 2);\n  }\n\n  function formatWeekNumberSunday(d, p) {\n    return pad(sunday.count(year(d), d), p, 2);\n  }\n\n  function formatWeekdayNumber(d) {\n    return d.getDay();\n  }\n\n  function formatWeekNumberMonday(d, p) {\n    return pad(monday.count(year(d), d), p, 2);\n  }\n\n  function formatYear(d, p) {\n    return pad(d.getFullYear() % 100, p, 2);\n  }\n\n  function formatFullYear(d, p) {\n    return pad(d.getFullYear() % 10000, p, 4);\n  }\n\n  function formatZone(d) {\n    var z = d.getTimezoneOffset();\n    return (z > 0 ? \"-\" : (z *= -1, \"+\"))\n        + pad(z / 60 | 0, \"0\", 2)\n        + pad(z % 60, \"0\", 2);\n  }\n\n  function formatUTCDayOfMonth(d, p) {\n    return pad(d.getUTCDate(), p, 2);\n  }\n\n  function formatUTCHour24(d, p) {\n    return pad(d.getUTCHours(), p, 2);\n  }\n\n  function formatUTCHour12(d, p) {\n    return pad(d.getUTCHours() % 12 || 12, p, 2);\n  }\n\n  function formatUTCDayOfYear(d, p) {\n    return pad(1 + utcDay.count(utcYear(d), d), p, 3);\n  }\n\n  function formatUTCMilliseconds(d, p) {\n    return pad(d.getUTCMilliseconds(), p, 3);\n  }\n\n  function formatUTCMonthNumber(d, p) {\n    return pad(d.getUTCMonth() + 1, p, 2);\n  }\n\n  function formatUTCMinutes(d, p) {\n    return pad(d.getUTCMinutes(), p, 2);\n  }\n\n  function formatUTCSeconds(d, p) {\n    return pad(d.getUTCSeconds(), p, 2);\n  }\n\n  function formatUTCWeekNumberSunday(d, p) {\n    return pad(utcSunday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCWeekdayNumber(d) {\n    return d.getUTCDay();\n  }\n\n  function formatUTCWeekNumberMonday(d, p) {\n    return pad(utcMonday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCYear(d, p) {\n    return pad(d.getUTCFullYear() % 100, p, 2);\n  }\n\n  function formatUTCFullYear(d, p) {\n    return pad(d.getUTCFullYear() % 10000, p, 4);\n  }\n\n  function formatUTCZone() {\n    return \"+0000\";\n  }\n\n  function formatLiteralPercent() {\n    return \"%\";\n  }\n\n  var isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\n\n  function formatIsoNative(date) {\n    return date.toISOString();\n  }\n\n  formatIsoNative.parse = function(string) {\n    var date = new Date(string);\n    return isNaN(date) ? null : date;\n  };\n\n  formatIsoNative.toString = function() {\n    return isoSpecifier;\n  };\n\n  var formatIso = Date.prototype.toISOString && +new Date(\"2000-01-01T00:00:00.000Z\")\n      ? formatIsoNative\n      : enUs.utcFormat(isoSpecifier);\n\n  var isoFormat = formatIso;\n\n  var localeDefinitions = (new Map)\n      .set(\"ca-ES\", caEs)\n      .set(\"de-DE\", deDe)\n      .set(\"en-CA\", enCa)\n      .set(\"en-GB\", enGb)\n      .set(\"en-US\", enUs)\n      .set(\"es-ES\", esEs)\n      .set(\"fi-FI\", fiFi)\n      .set(\"fr-CA\", frCa)\n      .set(\"fr-FR\", frFr)\n      .set(\"he-IL\", heIl)\n      .set(\"it-IT\", itIt)\n      .set(\"mk-MK\", mkMk)\n      .set(\"nl-NL\", nlNl)\n      .set(\"pl-PL\", plPl)\n      .set(\"pt-BR\", ptBr)\n      .set(\"ru-RU\", ruRu)\n      .set(\"zh-CN\", zhCn);\n\n  var defaultLocale = locale(enUs);\n  exports.format = defaultLocale.format;\n  exports.utcFormat = defaultLocale.utcFormat;\n\n  function localeFormat(definition) {\n    if (typeof definition === \"string\") {\n      definition = localeDefinitions.get(definition);\n      if (!definition) return null;\n    }\n    return locale(definition);\n  }\n  ;\n\n  exports.localeFormat = localeFormat;\n  exports.isoFormat = isoFormat;\n\n}));\n},{}],7:[function(require,module,exports){\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t1 = new Date;\n\n  var t0 = new Date;\n\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  }\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  exports.seconds = second.range;\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  exports.minutes = minute.range;\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  exports.hours = hour.range;\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  exports.days = day.range;\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  exports.sunday = weekday(0);\n\n  exports.sundays = exports.sunday.range;\n\n  exports.monday = weekday(1);\n\n  exports.mondays = exports.monday.range;\n\n  exports.tuesday = weekday(2);\n\n  exports.tuesdays = exports.tuesday.range;\n\n  exports.wednesday = weekday(3);\n\n  exports.wednesdays = exports.wednesday.range;\n\n  exports.thursday = weekday(4);\n\n  exports.thursdays = exports.thursday.range;\n\n  exports.friday = weekday(5);\n\n  exports.fridays = exports.friday.range;\n\n  exports.saturday = weekday(6);\n\n  exports.saturdays = exports.saturday.range;\n\n  var week = exports.sunday;\n\n  exports.weeks = week.range;\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  });\n\n  exports.months = month.range;\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  exports.years = year.range;\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  exports.utcSeconds = utcSecond.range;\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  exports.utcMinutes = utcMinute.range;\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  exports.utcHours = utcHour.range;\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  exports.utcDays = utcDay.range;\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  exports.utcSunday = utcWeekday(0);\n\n  exports.utcSundays = exports.utcSunday.range;\n\n  exports.utcMonday = utcWeekday(1);\n\n  exports.utcMondays = exports.utcMonday.range;\n\n  exports.utcTuesday = utcWeekday(2);\n\n  exports.utcTuesdays = exports.utcTuesday.range;\n\n  exports.utcWednesday = utcWeekday(3);\n\n  exports.utcWednesdays = exports.utcWednesday.range;\n\n  exports.utcThursday = utcWeekday(4);\n\n  exports.utcThursdays = exports.utcThursday.range;\n\n  exports.utcFriday = utcWeekday(5);\n\n  exports.utcFridays = exports.utcFriday.range;\n\n  exports.utcSaturday = utcWeekday(6);\n\n  exports.utcSaturdays = exports.utcSaturday.range;\n\n  var utcWeek = exports.utcSunday;\n\n  exports.utcWeeks = utcWeek.range;\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  });\n\n  exports.utcMonths = utcMonth.range;\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  exports.utcYears = utcYear.range;\n\n  exports.interval = newInterval;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.week = week;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcWeek = utcWeek;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n\n}));\n},{}],8:[function(require,module,exports){\nvar util = require('../util'),\n    time = require('../time'),\n    EPSILON = 1e-15;\n\nfunction bins(opt) {\n  if (!opt) { throw Error(\"Missing binning options.\"); }\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  if (!opt) { throw Error(\"Missing date binning options.\"); }\n\n  // find time step, then bin\n  var units = opt.utc ? time.utc : time,\n      dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n\n},{\"../time\":12,\"../util\":13}],9:[function(require,module,exports){\nvar gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n},{}],10:[function(require,module,exports){\nvar util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    types[f] = infer(data, f);\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;\n},{\"../util\":13}],11:[function(require,module,exports){\nvar util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length < 2) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (v === v) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (v === v) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance] \n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;\n},{\"./generate\":9,\"./import/type\":10,\"./util\":13}],12:[function(require,module,exports){\nvar d3_time = require('d3-time');\n\nvar tempDate = new Date(),\n    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD\n    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);\n\nfunction date(d) {\n  return (tempDate.setTime(+d), tempDate);\n}\n\n// create a time unit entry\nfunction entry(type, date, unit, step, min, max) {\n  var e = {\n    type: type,\n    date: date,\n    unit: unit\n  };\n  if (step) {\n    e.step = step;\n  } else {\n    e.minstep = 1;\n  }\n  if (min != null) e.min = min;\n  if (max != null) e.max = max;\n  return e;\n}\n\nfunction create(type, unit, base, step, min, max) {\n  return entry(type,\n    function(d) { return unit.offset(base, d); },\n    function(d) { return unit.count(base, d); },\n    step, min, max);\n}\n\nvar locale = [\n  create('second', d3_time.second, baseDate),\n  create('minute', d3_time.minute, baseDate),\n  create('hour',   d3_time.hour,   baseDate),\n  create('day',    d3_time.day,    baseDate, [1, 7]),\n  create('month',  d3_time.month,  baseDate, [1, 3, 6]),\n  create('year',   d3_time.year,   baseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(1970, 0, 1, 0, 0, d); },\n    function(d) { return date(d).getSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(1970, 0, 1, 0, d); },\n    function(d) { return date(d).getMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(1970, 0, 1, d); },\n    function(d) { return date(d).getHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(1970, 0, 4+d); },\n    function(d) { return date(d).getDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(1970, 0, d); },\n    function(d) { return date(d).getDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(1970, d % 12, 1); },\n    function(d) { return date(d).getMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar utc = [\n  create('second', d3_time.utcSecond, utcBaseDate),\n  create('minute', d3_time.utcMinute, utcBaseDate),\n  create('hour',   d3_time.utcHour,   utcBaseDate),\n  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),\n  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),\n  create('year',   d3_time.utcYear,   utcBaseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },\n    function(d) { return date(d).getUTCSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },\n    function(d) { return date(d).getUTCMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },\n    function(d) { return date(d).getUTCHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },\n    function(d) { return date(d).getUTCDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(Date.UTC(1970, 0, d)); },\n    function(d) { return date(d).getUTCDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },\n    function(d) { return date(d).getUTCMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction find(units, span, minb, maxb) {\n  var step = STEPS[0], i, n, bins;\n\n  for (i=1, n=STEPS.length; i<n; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return units[STEPS[i-1][1]];\n      }\n      if (bins >= minb) {\n        return units[step[1]];\n      }\n    }\n  }\n  return units[STEPS[n-1][1]];\n}\n\nfunction toUnitMap(units) {\n  var map = {}, i, n;\n  for (i=0, n=units.length; i<n; ++i) {\n    map[units[i].type] = units[i];\n  }\n  map.find = function(span, minb, maxb) {\n    return find(units, span, minb, maxb);\n  };\n  return map;\n}\n\nmodule.exports = toUnitMap(locale);\nmodule.exports.utc = toUnitMap(utc);\n\n},{\"d3-time\":7}],13:[function(require,module,exports){\nvar buffer = require('buffer'),\n    time = require('./time'),\n    utc = time.utc;\n\nvar u = module.exports = {};\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (buffer.Buffer && buffer.Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\nu.date = function(s) {\n  return s == null || s === '' ? null : Date.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nvar field_re = /\\[(.*?)\\]|[^.\\[]+/g;\n\nu.field = function(f) {\n  return String(f).match(field_re).map(function(d) {\n    return d[0] !== '[' ? d :\n      d[1] !== \"'\" && d[1] !== '\"' ? d.slice(1, -1) :\n      d.slice(2, -2).replace(/\\\\([\"'])/g, '$1');\n  });\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\nu.$year   = u.$func('year', time.year.unit);\nu.$month  = u.$func('month', time.months.unit);\nu.$date   = u.$func('date', time.dates.unit);\nu.$day    = u.$func('day', time.weekdays.unit);\nu.$hour   = u.$func('hour', time.hours.unit);\nu.$minute = u.$func('minute', time.minutes.unit);\nu.$second = u.$func('second', time.seconds.unit);\n\nu.$utcYear   = u.$func('utcYear', utc.year.unit);\nu.$utcMonth  = u.$func('utcMonth', utc.months.unit);\nu.$utcDate   = u.$func('utcDate', utc.dates.unit);\nu.$utcDay    = u.$func('utcDay', utc.weekdays.unit);\nu.$utcHour   = u.$func('utcHour', utc.hours.unit);\nu.$utcMinute = u.$func('utcMinute', utc.minutes.unit);\nu.$utcSecond = u.$func('utcSecond', utc.seconds.unit);\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n\n},{\"./time\":12,\"buffer\":1}],14:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  util = require('./util'),\n  vlfield = require('./field'),\n  vlenc = require('./enc'),\n  schema = require('./schema/schema');\n\nmodule.exports = (function() {\n  function Encoding(spec, theme) {\n    var defaults = schema.instantiate(),\n      specExtended = schema.util.merge(defaults, theme || {}, spec) ;\n\n    this._data = specExtended.data;\n    this._marktype = specExtended.marktype;\n    this._enc = specExtended.encoding;\n    this._config = specExtended.config;\n    this._filter = specExtended.filter;\n    // this._vega2 = true;\n  }\n\n  var proto = Encoding.prototype;\n\n  Encoding.fromShorthand = function(shorthand, data, config, theme) {\n    var c = consts.shorthand,\n        split = shorthand.split(c.delim),\n        marktype = split.shift().split(c.assign)[1].trim(),\n        enc = vlenc.fromShorthand(split);\n\n    return new Encoding({\n      data: data,\n      marktype: marktype,\n      encoding: enc,\n      config: config,\n      filter: []\n    }, theme);\n  };\n\n  Encoding.fromSpec = function(spec, theme) {\n    return new Encoding(spec, theme);\n  };\n\n  proto.toShorthand = function() {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + this._marktype +\n      c.delim + vlenc.shorthand(this._enc);\n  };\n\n  Encoding.shorthand = function (spec) {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + spec.marktype +\n      c.delim + vlenc.shorthand(spec.encoding);\n  };\n\n  Encoding.specFromShorthand = function(shorthand, data, config, excludeConfig) {\n    return Encoding.fromShorthand(shorthand, data, config).toSpec(excludeConfig);\n  };\n\n  proto.toSpec = function(excludeConfig, excludeData) {\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    spec = {\n      marktype: this._marktype,\n      encoding: enc,\n      filter: this._filter\n    };\n\n    if (!excludeConfig) {\n      spec.config = util.duplicate(this._config);\n    }\n\n    if (!excludeData) {\n      spec.data = util.duplicate(this._data);\n    }\n\n    // remove defaults\n    var defaults = schema.instantiate();\n    return schema.util.subtract(spec, defaults);\n  };\n\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(encType) {\n    // equivalent to calling vlenc.has(this._enc, encType)\n    return this._enc[encType].name !== undefined;\n  };\n\n  proto.field = function(et) {\n    return this._enc[et];\n  };\n\n  proto.filter = function() {\n    var filterNull = [],\n      fields = this.fields(),\n      self = this;\n\n    util.forEach(fields, function(fieldList, fieldName) {\n      if (fieldName === '*') return; //count\n\n      if ((self.config('filterNull').Q && fieldList.containsType[Q]) ||\n          (self.config('filterNull').T && fieldList.containsType[T]) ||\n          (self.config('filterNull').O && fieldList.containsType[O]) ||\n          (self.config('filterNull').N && fieldList.containsType[N])) {\n        filterNull.push({\n          operands: [fieldName],\n          operator: 'notNull'\n        });\n      }\n    });\n\n    return filterNull.concat(this._filter);\n  };\n\n  // get \"field\" reference for vega\n  proto.fieldRef = function(et, opt) {\n    opt = opt || {};\n    opt.data = !this._vega2 && (opt.data !== false);\n    return vlfield.fieldRef(this._enc[et], opt);\n  };\n\n  proto.fieldName = function(et) {\n    return this._enc[et].name;\n  };\n\n  /*\n   * return key-value pairs of field name and list of fields of that field name\n   */\n  proto.fields = function() {\n    return vlenc.fields(this._enc);\n  };\n\n  proto.fieldTitle = function(et) {\n    if (vlfield.isCount(this._enc[et])) {\n      return vlfield.count.displayName;\n    }\n    var fn = this._enc[et].aggregate || this._enc[et].timeUnit || (this._enc[et].bin && 'bin');\n    if (fn) {\n      var uppercase = fn === 'avg' ? 'MEAN' :fn.toUpperCase();\n      return uppercase + '(' + this._enc[et].name + ')';\n    } else {\n      return this._enc[et].name;\n    }\n  };\n\n  proto.scale = function(et) {\n    return this._enc[et].scale || {};\n  };\n\n  proto.axis = function(et) {\n    return this._enc[et].axis || {};\n  };\n\n  proto.bandSize = function(encType, useSmallBand) {\n    useSmallBand = useSmallBand ||\n      //isBandInSmallMultiples\n      (encType === Y && this.has(ROW) && this.has(Y)) ||\n      (encType === X && this.has(COL) && this.has(X));\n\n    // if band.size is explicitly specified, follow the specification, otherwise draw value from config.\n    return this.field(encType).band.size ||\n      this.config(useSmallBand ? 'smallBandSize' : 'largeBandSize');\n  };\n\n  proto.aggregate = function(et) {\n    return this._enc[et].aggregate;\n  };\n\n  // returns false if binning is disabled, otherwise an object with binning properties\n  proto.bin = function(et) {\n    var bin = this._enc[et].bin;\n    if (bin === {})\n      return false;\n    if (bin === true)\n      return {\n        maxbins: schema.MAXBINS_DEFAULT\n      };\n    return bin;\n  };\n\n  proto.value = function(et) {\n    return this._enc[et].value;\n  };\n\n  proto.numberFormat = function(fieldStats) {\n    var formatConfig = fieldStats.max > this.config('maxSmallNumber') ?\n      'largeNumberFormat': 'smallNumberFormat';\n    return this.config(formatConfig);\n  };\n\n  proto.sort = function(et, stats) {\n    var sort = this._enc[et].sort,\n      enc = this._enc,\n      isTypes = vlfield.isTypes;\n\n    if ((!sort || sort.length===0) &&\n        // FIXME\n        Encoding.toggleSort.support({encoding:this._enc}, stats, true) && //HACK\n        this.config('toggleSort') === Q\n      ) {\n      var qField = isTypes(enc.x, [N, O]) ? enc.y : enc.x;\n\n      if (isTypes(enc[et], [N, O])) {\n        sort = [{\n          name: qField.name,\n          aggregate: qField.aggregate,\n          type: qField.type,\n          reverse: true\n        }];\n      }\n    }\n\n    return sort;\n  };\n\n  proto.map = function(f) {\n    return vlenc.map(this._enc, f);\n  };\n\n  proto.reduce = function(f, init) {\n    return vlenc.reduce(this._enc, f, init);\n  };\n\n  proto.forEach = function(f) {\n    return vlenc.forEach(this._enc, f);\n  };\n\n  proto.type = function(et) {\n    return this.has(et) ? this._enc[et].type : null;\n  };\n\n  proto.isType = function(et, type) {\n    var field = this.field(et);\n    return field && vlfield.isType(field, type);\n  };\n\n\n  proto.isTypes = function(et, type) {\n    var field = this.field(et);\n    return field && vlfield.isTypes(field, type);\n  };\n\n  Encoding.isOrdinalScale = function(encoding, encType) {\n    return vlfield.isOrdinalScale(encoding.field(encType));\n  };\n\n  Encoding.isDimension = function(encoding, encType) {\n    return vlfield.isDimension(encoding.field(encType));\n  };\n\n  Encoding.isMeasure = function(encoding, encType) {\n    return vlfield.isMeasure(encoding.field(encType));\n  };\n\n  proto.isOrdinalScale = function(encType) {\n    return this.has(encType) && Encoding.isOrdinalScale(this, encType);\n  };\n\n  proto.isDimension = function(encType) {\n    return this.has(encType) && Encoding.isDimension(this, encType);\n  };\n\n  proto.isMeasure = function(encType) {\n    return this.has(encType) && Encoding.isMeasure(this, encType);\n  };\n\n  proto.isAggregate = function() {\n    return vlenc.isAggregate(this._enc);\n  };\n\n  proto.dataTable = function() {\n    return this.isAggregate() ? AGGREGATE : RAW;\n  };\n\n  Encoding.isAggregate = function(spec) {\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.alwaysNoOcclusion = function(spec) {\n    // FIXME raw OxQ with # of rows = # of O\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.isStack = function(spec) {\n    // FIXME update this once we have control for stack ...\n    return (spec.marktype === 'bar' || spec.marktype === 'area') &&\n      spec.encoding.color;\n  };\n\n  proto.isStack = function() {\n    // FIXME update this once we have control for stack ...\n    return (this.is('bar') || this.is('area')) && this.has('color');\n  };\n\n  proto.details = function() {\n    var encoding = this;\n    return this.reduce(function(refs, field, encType) {\n      if (!field.aggregate && (encType !== X && encType !== Y)) {\n        refs.push(encoding.fieldRef(encType));\n      }\n      return refs;\n    }, []);\n  };\n\n  proto.facets = function() {\n    var encoding = this;\n    return this.reduce(function(refs, field, encType) {\n      if (!field.aggregate && (encType == ROW || encType == COL)) {\n        refs.push(encoding.fieldRef(encType));\n      }\n      return refs;\n    }, []);\n  };\n\n  proto.cardinality = function(encType, stats) {\n    return vlfield.cardinality(this.field(encType), stats, this.config('filterNull'));\n  };\n\n  proto.isRaw = function() {\n    return !this.isAggregate();\n  };\n\n  proto.data = function() {\n    return this._data;\n  };\n\n   // returns whether the encoding has values embedded\n  proto.hasValues = function() {\n    var vals = this.data().values;\n    return vals && vals.length;\n  };\n\n  proto.config = function(name) {\n    return this._config[name];\n  };\n\n  Encoding.transpose = function(spec) {\n    var oldenc = spec.encoding,\n      enc = util.duplicate(spec.encoding);\n    enc.x = oldenc.y;\n    enc.y = oldenc.x;\n    enc.row = oldenc.col;\n    enc.col = oldenc.row;\n    spec.encoding = enc;\n    return spec;\n  };\n\n  // FIXME: REMOVE everything below here\n\n  Encoding.toggleSort = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.toggleSort = spec.config.toggleSort === Q ? N : Q;\n    return spec;\n  };\n\n\n  Encoding.toggleSort.direction = function(spec) {\n    if (!Encoding.toggleSort.support(spec)) { return; }\n    var enc = spec.encoding;\n    return enc.x.type === N ? 'x' : 'y';\n  };\n\n  Encoding.toggleSort.mode = function(spec) {\n    return spec.config.toggleSort;\n  };\n\n  Encoding.toggleSort.support = function(spec, stats) {\n    var enc = spec.encoding,\n      isTypes = vlfield.isTypes;\n\n    if (vlenc.has(enc, ROW) || vlenc.has(enc, COL) ||\n      !vlenc.has(enc, X) || !vlenc.has(enc, Y) ||\n      !Encoding.alwaysNoOcclusion(spec, stats)) {\n      return false;\n    }\n\n    return ( isTypes(enc.x, [N,O]) && vlfield.isMeasure(enc.y)) ? 'x' :\n      ( isTypes(enc.y, [N,O]) && vlfield.isMeasure(enc.x)) ? 'y' : false;\n  };\n\n  Encoding.toggleFilterNullO = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.filterNull = spec.config.filterNull || { //FIXME\n      T: true,\n      Q: true\n    };\n    spec.config.filterNull.O = !spec.config.filterNull.O;\n    return spec;\n  };\n\n  Encoding.toggleFilterNullO.support = function(spec, stats) {\n    var fields = vlenc.fields(spec.encoding);\n    for (var fieldName in fields) {\n      var fieldList = fields[fieldName];\n      if (fieldList.containsType.O && fieldName in stats && stats[fieldName].nulls > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  return Encoding;\n})();\n\n},{\"./consts\":29,\"./enc\":31,\"./field\":32,\"./globals\":33,\"./schema/schema\":35,\"./util\":37}],15:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  getter = util.getter,\n  time = require('./time');\n\nvar axis = module.exports = {};\n\naxis.def = function(name, encoding, layout, stats, opt) {\n  var isCol = name == COL,\n    isRow = name == ROW,\n    type = isCol ? 'x' : isRow ? 'y' : name;\n\n  var def = {\n    type: type,\n    scale: name,\n    properties: {},\n    layer: encoding.field(name).axis.layer,\n    orient: axis.orient(name, encoding, stats)\n  };\n\n  // Add axis label custom scale (for bin / time)\n  def = axis.labels.scale(def, encoding, name);\n  def = axis.labels.format(def, name, encoding, stats);\n  def = axis.labels.angle(def, encoding, name);\n\n  // for x-axis, set ticks for Q or rotate scale for ordinal scale\n  if (name == X) {\n    if ((encoding.isDimension(X) || encoding.isType(X, T)) &&\n        !('angle' in getter(def, ['properties', 'labels']))) {\n      // TODO(kanitw): Jul 19, 2015 - #506 add condition for rotation\n      def = axis.labels.rotate(def);\n    } else { // Q\n      def.ticks = encoding.field(name).axis.ticks;\n    }\n  }\n\n  // TitleOffset depends on labels rotation\n  def.titleOffset = axis.titleOffset(encoding, layout, name);\n\n  //def.offset is used in axis.grid\n  if(isRow) def.offset = axis.titleOffset(encoding, layout, Y) + 20;\n  // FIXME(kanitw): Jul 19, 2015 - offset for column when x is put on top\n\n  def = axis.grid(def, name, encoding, layout);\n  def = axis.title(def, name, encoding, layout, opt);\n\n  if (isRow || isCol) def = axis.hideTicks(def);\n\n  return def;\n};\n\naxis.orient = function(name, encoding, stats) {\n  var orient = encoding.field(name).axis.orient;\n  if (orient) return orient;\n\n  if (name===COL) return 'top';\n\n  // x-axis for long y - put on top\n  if (name===X && encoding.has(Y) && encoding.isOrdinalScale(Y) && encoding.cardinality(Y, stats) > 30) {\n    return 'top';\n  }\n\n  return undefined;\n};\n\naxis.grid = function(def, name, encoding, layout) {\n  var cellPadding = layout.cellPadding,\n    isCol = name == COL,\n    isRow = name == ROW;\n\n  if (encoding.axis(name).grid) {\n    def.grid = true;\n\n    if (isCol) {\n      // set grid property -- put the lines on the right the cell\n      def.properties.grid = {\n        x: {\n          offset: layout.cellWidth * (1+ cellPadding/2.0),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'col'\n        },\n        y: {\n          value: -layout.cellHeight * (cellPadding/2),\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      };\n    } else if (isRow) {\n      // set grid property -- put the lines on the top\n      def.properties.grid = {\n        y: {\n          offset: -layout.cellHeight * (cellPadding/2),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'row'\n        },\n        x: {\n          value: def.offset\n        },\n        x2: {\n          offset: def.offset + (layout.cellWidth * 0.05),\n          // default value(s) -- vega doesn't do recursive merge\n          group: 'mark.group.width',\n          mult: 1\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      };\n    } else {\n      def.properties.grid = {\n        stroke: { value: encoding.config('gridColor') },\n        opacity: { value: encoding.config('gridOpacity') }\n      };\n    }\n  }\n  return def;\n};\n\naxis.hideTicks = function(def) {\n  def.properties.ticks = {opacity: {value: 0}};\n  def.properties.majorTicks = {opacity: {value: 0}};\n  def.properties.axis = {opacity: {value: 0}};\n  return def;\n};\n\naxis.title = function (def, name, encoding, layout) {\n  var ax = encoding.field(name).axis;\n\n  if (ax.title) {\n    def.title = ax.title;\n  } else {\n    // if not defined, automatically determine axis title from field def\n    var fieldTitle = encoding.fieldTitle(name),\n      maxLength;\n\n    if (ax.titleMaxLength) {\n      maxLength = ax.titleMaxLength;\n    } else if (name===X) {\n      maxLength = layout.cellWidth / encoding.config('characterWidth');\n    } else if (name === Y) {\n      maxLength = layout.cellHeight / encoding.config('characterWidth');\n    }\n\n    def.title = maxLength ? util.truncate(fieldTitle, maxLength) : fieldTitle;\n  }\n\n  if (name === ROW) {\n    def.properties.title = {\n      angle: {value: 0},\n      align: {value: 'right'},\n      baseline: {value: 'middle'},\n      dy: {value: (-layout.height/2) -20}\n    };\n  }\n\n  return def;\n};\n\naxis.labels = {};\n\n/** add custom label for time type and bin */\naxis.labels.scale = function(def, encoding, name) {\n  // time\n  var timeUnit = encoding.field(name).timeUnit;\n  if (encoding.isType(name, T) && timeUnit && (time.hasScale(timeUnit))) {\n    setter(def, ['properties','labels','text','scale'], 'time-'+ timeUnit);\n  }\n  // FIXME bin\n  return def;\n};\n\n/**\n * Determine number format or truncate if maxLabel length is presented.\n */\naxis.labels.format = function (def, name, encoding, stats) {\n  var fieldStats = stats[encoding.field(name).name];\n\n  if (encoding.axis(name).format) {\n    def.format = encoding.axis(name).format;\n  } else if (encoding.isType(name, Q) || fieldStats.type === 'number') {\n    def.format = encoding.numberFormat(fieldStats);\n  } else if (encoding.isType(name, T)) {\n    var timeUnit = encoding.field(name).timeUnit;\n    if (!timeUnit) {\n      def.format = encoding.config('timeFormat');\n    } else if (timeUnit === 'year') {\n      def.format = 'd';\n    }\n  } else if (encoding.isTypes(name, [N, O]) && encoding.axis(name).maxLabelLength) {\n    setter(def,\n      ['properties','labels','text','template'],\n      '{{data | truncate:' + encoding.axis(name).maxLabelLength + '}}'\n      );\n  }\n\n  return def;\n};\n\naxis.labels.angle = function(def, encoding, name) {\n  var angle = encoding.axis(name).labelAngle;\n  if (typeof angle === 'undefined') return def;\n\n  setter(def, ['properties', 'labels', 'angle', 'value'], angle);\n  return def;\n};\n\naxis.labels.rotate = function(def) {\n var align = def.orient ==='top' ? 'left' : 'right';\n setter(def, ['properties','labels', 'angle', 'value'], 270);\n setter(def, ['properties','labels', 'align', 'value'], align);\n setter(def, ['properties','labels', 'baseline', 'value'], 'middle');\n return def;\n};\n\naxis.titleOffset = function (encoding, layout, name) {\n  // return specified value if specified\n  var value = encoding.axis(name).titleOffset;\n  if (value)  return value;\n\n  switch (name) {\n    //FIXME make this adjustable\n    case ROW: return 0;\n    case COL: return 35;\n  }\n  return getter(layout, [name, 'axisTitleOffset']);\n};\n\n},{\"../globals\":33,\"../util\":37,\"./time\":28}],16:[function(require,module,exports){\n'use strict';\n\nvar summary = module.exports = require('datalib/src/stats').summary;\n\nrequire('../globals');\n\nvar compiler = module.exports = {};\n\nvar Encoding = require('../Encoding'),\n  axis = compiler.axis = require('./axis'),\n  legend = compiler.legend = require('./legend'),\n  marks = compiler.marks = require('./marks'),\n  scale = compiler.scale = require('./scale');\n\ncompiler.data = require('./data');\ncompiler.facet = require('./facet');\ncompiler.group = require('./group');\ncompiler.layout = require('./layout');\ncompiler.sort = require('./sort');\ncompiler.stack = require('./stack');\ncompiler.style = require('./style');\ncompiler.subfacet = require('./subfacet');\ncompiler.time = require('./time');\n\ncompiler.compile = function (spec, stats, theme) {\n  return compiler.compileEncoding(Encoding.fromSpec(spec, theme), stats);\n};\n\ncompiler.shorthand = function (shorthand, stats, config, theme) {\n  return compiler.compileEncoding(Encoding.fromShorthand(shorthand, config, theme), stats);\n};\n\n\ncompiler.compileEncoding = function (encoding, stats) {\n  // no need to pass stats if you pass in the data\n  if (!stats) {\n    if (encoding.hasValues()) {\n        stats = summary(encoding.data().values).reduce(function(s, p) {\n        s[p.field] = p;\n        return s;\n      }, {});\n    } else {\n      console.error('No stats provided and data is not embedded.');\n    }\n  }\n\n  var layout = compiler.layout(encoding, stats);\n\n  var spec = {\n      width: layout.width,\n      height: layout.height,\n      padding: 'auto',\n      data: compiler.data(encoding),\n      // global scales contains only time unit scales\n      scales: compiler.time.scales(encoding)\n    };\n\n  // FIXME remove compiler.sort after migrating to vega 2.\n  spec.data = compiler.sort(spec.data, encoding, stats); // append new data\n\n  // marks\n\n  // TODO this line is temporary and should be refactored\n  spec.marks = [compiler.group.def('cell', {\n    width: layout.cellWidth ? {value: layout.cellWidth} : undefined,\n    height: layout.cellHeight ? {value: layout.cellHeight} : undefined\n  })];\n\n  var style = compiler.style(encoding, stats),\n    group = spec.marks[0],\n    mdefs = marks.def(encoding, layout, style, stats),\n    mdef = mdefs[mdefs.length - 1];  // TODO: remove this dirty hack by refactoring the whole flow\n\n  for (var i = 0; i < mdefs.length; i++) {\n    group.marks.push(mdefs[i]);\n  }\n\n  var lineType = marks[encoding.marktype()].line;\n\n  // handle subfacets\n\n  var details = encoding.details(),\n    stack = encoding.isAggregate() && details.length > 0 && compiler.stack(spec.data, encoding, mdef); // modify spec.data, mdef.{from,properties}\n\n  if (details.length > 0 && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    compiler.subfacet(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  if (lineType && encoding.config('autoSortLine')) {\n    var f = (encoding.isMeasure(X) && encoding.isDimension(Y)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    // TODO: why - ?\n    mdef.from.transform = [{type: 'sort', by: '-' + encoding.fieldRef(f)}];\n  }\n\n  // get a flattened list of all scale names that are used in the vl spec\n  var singleScaleNames = [].concat.apply([], mdefs.map(function(markProps) {\n    return scale.names(markProps.properties.update);\n  }));\n\n  // Small Multiples\n  if (encoding.has(ROW) || encoding.has(COL)) {\n    spec = compiler.facet(group, encoding, layout, spec, singleScaleNames, stack, stats);\n    spec.legends = legend.defs(encoding, style);\n  } else {\n    group.scales = scale.defs(singleScaleNames, encoding, layout, stats, {stack: stack});\n\n    group.axes = [];\n    if (encoding.has(X)) group.axes.push(axis.def(X, encoding, layout, stats));\n    if (encoding.has(Y)) group.axes.push(axis.def(Y, encoding, layout, stats));\n\n    group.legends = legend.defs(encoding, style);\n  }\n\n\n\n  return spec;\n};\n\n\n},{\"../Encoding\":14,\"../globals\":33,\"./axis\":15,\"./data\":17,\"./facet\":18,\"./group\":19,\"./layout\":20,\"./legend\":21,\"./marks\":22,\"./scale\":23,\"./sort\":24,\"./stack\":25,\"./style\":26,\"./subfacet\":27,\"./time\":28,\"datalib/src/stats\":11}],17:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nmodule.exports = data;\n\nvar vlfield = require('../field'),\n  util = require('../util'),\n  time = require('./time');\n\nfunction data(encoding) {\n  var def = [data.raw(encoding)];\n\n  var aggregate = data.aggregate(encoding);\n  if (aggregate) def.push(data.aggregate(encoding));\n\n  // TODO add \"having\" filter here\n\n  // append non-positive filter at the end for the data table\n  data.filterNonPositive(def[def.length - 1], encoding);\n\n  return def;\n}\n\ndata.raw = function(encoding) {\n  var raw = {name: RAW};\n\n  // Data source (url or inline)\n  if (encoding.hasValues()) {\n    raw.values = encoding.data().values;\n  } else {\n    raw.url = encoding.data().url;\n    raw.format = {type: encoding.data().formatType};\n  }\n\n  // Set format.parse if needed\n  var parse = data.raw.formatParse(encoding);\n  if (parse) {\n    raw.format = raw.format || {};\n    raw.format.parse = parse;\n  }\n\n  raw.transform = data.raw.transform(encoding);\n  return raw;\n};\n\ndata.raw.formatParse = function(encoding) {\n  var parse;\n\n  encoding.forEach(function(field) {\n    if (field.type == T) {\n      parse = parse || {};\n      parse[field.name] = 'date';\n    } else if (field.type == Q) {\n      if (vlfield.isCount(field)) return;\n      parse = parse || {};\n      parse[field.name] = 'number';\n    }\n  });\n\n  return parse;\n};\n\ndata.raw.transform = function(encoding) {\n  // time and bin should come before filter so we can filter by time and bin\n  return data.raw.transform.time(encoding).concat(\n    data.raw.transform.bin(encoding),\n    data.raw.transform.filter(encoding)\n  );\n};\n\nvar BINARY = {\n  '>':  true,\n  '>=': true,\n  '=':  true,\n  '!=': true,\n  '<':  true,\n  '<=': true\n};\n\ndata.raw.transform.time = function(encoding) {\n  return encoding.reduce(function(transform, field, encType) {\n    if (field.type === T && field.timeUnit) {\n      transform.push({\n        type: 'formula',\n        field: encoding.fieldRef(encType),\n        expr: time.formula(field.timeUnit, encoding.fieldRef(encType, {nofn: true, d: true}))\n      });\n    }\n    return transform;\n  }, []);\n};\n\ndata.raw.transform.bin = function(encoding) {\n  return encoding.reduce(function(transform, field, encType) {\n    if (encoding.bin(encType)) {\n      transform.push({\n        type: 'bin',\n        field: encoding.fieldRef(encType, {nofn: true}),\n        output: encoding.fieldRef(encType),\n        maxbins: encoding.bin(encType).maxbins\n      });\n    }\n    return transform;\n  }, []);\n};\n\ndata.raw.transform.filter = function(encoding) {\n  var filters = encoding.filter().reduce(function(f, filter) {\n    var condition = '';\n    var operator = filter.operator;\n    var operands = filter.operands;\n\n    var d = 'd.' + (encoding._vega2 ? '' : 'data.');\n\n    if (BINARY[operator]) {\n      // expects a field and a value\n      if (operator === '=') {\n        operator = '==';\n      }\n\n      var op1 = operands[0];\n      var op2 = operands[1];\n      condition = d + op1 + ' ' + operator + ' ' + op2;\n    } else if (operator === 'notNull') {\n      // expects a number of fields\n      for (var j=0; j<operands.length; j++) {\n        condition += d + operands[j] + '!==null';\n        if (j < operands.length - 1) {\n          condition += ' && ';\n        }\n      }\n    } else {\n      util.warn('Unsupported operator: ', operator);\n      return f;\n    }\n    f.push('(' + condition + ')');\n    return f;\n  }, []);\n  if (filters.length === 0) return [];\n\n  return [{\n      type: 'filter',\n      test: filters.join(' && ')\n  }];\n};\n\ndata.aggregate = function(encoding) {\n  var dims = {}, meas = {};\n\n  encoding.forEach(function(field, encType) {\n    if (field.aggregate) {\n      if (field.aggregate === 'count') {\n        meas.count = {op: 'count', field: '*'};\n      }else {\n        meas[field.aggregate + '|' + field.name] = {\n          op: field.aggregate,\n          field: encoding.fieldRef(encType, {nofn: true})\n        };\n      }\n    } else {\n      dims[field.name] = encoding.fieldRef(encType);\n    }\n  });\n\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0) {\n    return {\n      name: AGGREGATE,\n      source: RAW,\n      transform: [{\n        type: 'aggregate',\n        groupby: dims,\n        fields: meas\n      }]\n    };\n  }\n\n  return null;\n};\n\ndata.filterNonPositive = function(dataTable, encoding) {\n  encoding.forEach(function(field, encType) {\n    if (encoding.scale(encType).type === 'log') {\n      dataTable.transform.push({\n        type: 'filter',\n        test: encoding.fieldRef(encType, {d: 1}) + ' > 0'\n      });\n    }\n  });\n};\n\n},{\"../field\":32,\"../globals\":33,\"../util\":37,\"./time\":28}],18:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util');\n\nvar axis = require('./axis'),\n  groupdef = require('./group').def,\n  scale = require('./scale');\n\nmodule.exports = faceting;\n\nfunction faceting(group, encoding, layout, spec, singleScaleNames, stack, stats) {\n  var enter = group.properties.enter;\n  var facetKeys = [], cellAxes = [], from, axesGrp;\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  enter.fill = {value: encoding.config('cellBackgroundColor')};\n\n  //move \"from\" to cell level and add facet transform\n  group.from = {data: group.marks[0].from.data};\n\n  // Hack, this needs to be refactored\n  for (var i = 0; i < group.marks.length; i++) {\n    var mark = group.marks[i];\n    if (mark.from.transform) {\n      delete mark.from.data; //need to keep transform for subfacetting case\n    } else {\n      delete mark.from;\n    }\n  }\n\n  if (hasRow) {\n    if (!encoding.isDimension(ROW)) {\n      util.error('Row encoding should be ordinal.');\n    }\n    enter.y = {scale: ROW, field: 'keys.' + facetKeys.length};\n    enter.height = {'value': layout.cellHeight}; // HACK\n\n    facetKeys.push(encoding.fieldRef(ROW));\n\n    if (hasCol) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.fieldRef(COL)]});\n    }\n\n    axesGrp = groupdef('x-axes', {\n        axes: encoding.has(X) ? [axis.def(X, encoding, layout, stats)] : undefined,\n        x: hasCol ? {scale: COL, field: 'keys.0'} : {value: 0},\n        width: hasCol && {'value': layout.cellWidth}, //HACK?\n        from: from\n      });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push(axis.def(ROW, encoding, layout, stats));\n  } else { // doesn't have row\n    if (encoding.has(X)) {\n      //keep x axis in the cell\n      cellAxes.push(axis.def(X, encoding, layout, stats));\n    }\n  }\n\n  if (hasCol) {\n    if (!encoding.isDimension(COL)) {\n      util.error('Col encoding should be ordinal.');\n    }\n    enter.x = {scale: COL, field: 'keys.' + facetKeys.length};\n    enter.width = {'value': layout.cellWidth}; // HACK\n\n    facetKeys.push(encoding.fieldRef(COL));\n\n    if (hasRow) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.fieldRef(ROW)]});\n    }\n\n    axesGrp = groupdef('y-axes', {\n      axes: encoding.has(Y) ? [axis.def(Y, encoding, layout, stats)] : undefined,\n      y: hasRow && {scale: ROW, field: 'keys.0'},\n      x: hasRow && {value: 0},\n      height: hasRow && {'value': layout.cellHeight}, //HACK?\n      from: from\n    });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push(axis.def(COL, encoding, layout, stats));\n  } else { // doesn't have col\n    if (encoding.has(Y)) {\n      cellAxes.push(axis.def(Y, encoding, layout, stats));\n    }\n  }\n\n  // assuming equal cellWidth here\n  // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n  spec.scales = (spec.scales || []).concat(scale.defs(\n    scale.names(enter).concat(singleScaleNames),\n    encoding,\n    layout,\n    stats,\n    {stack: stack, facet: true}\n  )); // row/col scales + cell scales\n\n  if (cellAxes.length > 0) {\n    group.axes = cellAxes;\n  }\n\n  // add facet transform\n  var trans = (group.from.transform || (group.from.transform = []));\n  trans.unshift({type: 'facet', keys: facetKeys});\n\n  return spec;\n}\n\n},{\"../globals\":33,\"../util\":37,\"./axis\":15,\"./group\":19,\"./scale\":23}],19:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  def: groupdef\n};\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: 'group',\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: 'width'},\n        height: opt.height || {group: 'height'}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n\n},{}],20:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  time = require('./time'),\n  d3_format = require('d3-format');\n\nmodule.exports = vllayout;\n\nfunction vllayout(encoding, stats) {\n  var layout = box(encoding, stats);\n  layout = offset(encoding, stats, layout);\n  return layout;\n}\n\n/*\n  HACK to set chart size\n  NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  One solution is to update Vega to support auto-sizing\n  In the meantime, auto-padding (mostly) does the trick\n */\nfunction box(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y),\n      marktype = encoding.marktype();\n\n  // FIXME/HACK we need to take filter into account\n  var xCardinality = hasX && encoding.isDimension(X) ? encoding.cardinality(X, stats) : 1,\n    yCardinality = hasY && encoding.isDimension(Y) ? encoding.cardinality(Y, stats) : 1;\n\n  var useSmallBand = xCardinality > encoding.config('largeBandMaxCardinality') ||\n    yCardinality > encoding.config('largeBandMaxCardinality');\n\n  var cellWidth, cellHeight, cellPadding = encoding.config('cellPadding');\n\n  // set cellWidth\n  if (hasX) {\n    if (encoding.isOrdinalScale(X)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellWidth = (xCardinality + encoding.field(X).band.padding) * encoding.bandSize(X, useSmallBand);\n    } else {\n      cellWidth = hasCol || hasRow ? encoding.field(COL).width :  encoding.config('singleWidth');\n    }\n  } else {\n    if (marktype === TEXT) {\n      cellWidth = encoding.config('textCellWidth');\n    } else {\n      cellWidth = encoding.bandSize(X);\n    }\n  }\n\n  // set cellHeight\n  if (hasY) {\n    if (encoding.isOrdinalScale(Y)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellHeight = (yCardinality + encoding.field(Y).band.padding) * encoding.bandSize(Y, useSmallBand);\n    } else {\n      cellHeight = hasCol || hasRow ? encoding.field(ROW).height :  encoding.config('singleHeight');\n    }\n  } else {\n    cellHeight = encoding.bandSize(Y);\n  }\n\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n\n  var width = cellWidth, height = cellHeight;\n  if (hasCol) {\n    var colCardinality = encoding.cardinality(COL, stats);\n    width = cellWidth * ((1 + cellPadding) * (colCardinality - 1) + 1);\n  }\n  if (hasRow) {\n    var rowCardinality =  encoding.cardinality(ROW, stats);\n    height = cellHeight * ((1 + cellPadding) * (rowCardinality - 1) + 1);\n  }\n\n  return {\n    // width and height of the whole cell\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    cellPadding: cellPadding,\n    // width and height of the chart\n    width: width,\n    height: height,\n    // information about x and y, such as band size\n    x: {useSmallBand: useSmallBand},\n    y: {useSmallBand: useSmallBand}\n  };\n}\n\n\n// FIXME fieldStats.max isn't always the longest\nfunction getMaxNumberLength(encoding, et, fieldStats) {\n  var format = encoding.numberFormat(et, fieldStats);\n\n  return d3_format.format(format)(fieldStats.max).length;\n}\n\nfunction getMaxLength(encoding, stats, et) {\n  var field = encoding.field(et),\n    fieldStats = stats[field.name];\n\n  if (field.bin) {\n    // TODO once bin support range, need to update this\n    return getMaxNumberLength(encoding, et, fieldStats);\n  } if (encoding.isType(et, Q)) {\n    return getMaxNumberLength(encoding, et, fieldStats);\n  } else if (encoding.isType(et, T)) {\n    return time.maxLength(encoding.field(et).timeUnit, encoding);\n  } else if (encoding.isTypes(et, [N, O])) {\n    if(fieldStats.type === 'number') {\n      return getMaxNumberLength(encoding, et, fieldStats);\n    } else {\n      return Math.min(fieldStats.max, encoding.axis(et).maxLabelLength || Infinity);\n    }\n  }\n}\n\nfunction offset(encoding, stats, layout) {\n  [X, Y].forEach(function (et) {\n    // TODO(kanitw): Jul 19, 2015 - create a set of visual test for extraOffset\n    var extraOffset = et === X ? 20 : 22,\n      maxLength;\n    if (encoding.isDimension(et) || encoding.isType(et, T)) {\n      maxLength = getMaxLength(encoding, stats, et);\n    } else if (\n      // TODO once we have #512 (allow using inferred type)\n      // Need to adjust condition here.\n      encoding.isType(et, Q) ||\n      encoding.aggregate(et) === 'count'\n    ) {\n      if (\n        et===Y\n        // || (et===X && false)\n        // FIXME determine when X would rotate, but should move this to axis.js first #506\n      ) {\n        maxLength = getMaxLength(encoding, stats, et);\n      }\n    } else {\n      // nothing\n    }\n\n    if (maxLength) {\n      setter(layout,[et, 'axisTitleOffset'], encoding.config('characterWidth') *  maxLength + extraOffset);\n    } else {\n      // if no max length (no rotation case), use maxLength = 3\n      setter(layout,[et, 'axisTitleOffset'], encoding.config('characterWidth') * 3 + extraOffset);\n    }\n\n  });\n  return layout;\n}\n\n},{\"../globals\":33,\"../util\":37,\"./time\":28,\"d3-format\":5}],21:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar time = require('./time'),\n  util = require('../util'),\n  setter = util.setter,\n  getter = util.getter;\n\nvar legend = module.exports = {};\n\nlegend.defs = function(encoding, style) {\n  var defs = [];\n\n  if (encoding.has(COLOR) && encoding.field(COLOR).legend) {\n    defs.push(legend.def(COLOR, encoding, {\n      fill: COLOR,\n      orient: 'right'\n    }, style));\n  }\n\n  if (encoding.has(SIZE) && encoding.field(SIZE).legend) {\n    defs.push(legend.def(SIZE, encoding, {\n      size: SIZE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }, style));\n  }\n\n  if (encoding.has(SHAPE) && encoding.field(SHAPE).legend) {\n    if (defs.length === 2) {\n      console.error('Vega-lite currently only supports two legends');\n    }\n    defs.push(legend.def(SHAPE, encoding, {\n      shape: SHAPE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }, style));\n  }\n  return defs;\n};\n\nlegend.def = function(name, encoding, def, style) {\n  var timeUnit = encoding.field(name).timeUnit;\n\n  def.title = legend.title(name, encoding);\n  def = legend.style(name, encoding, def, style);\n\n  if (encoding.isType(name, T) &&\n    timeUnit &&\n    time.hasScale(timeUnit)\n  ) {\n    setter(def, ['properties', 'labels', 'text', 'scale'], 'time-'+ timeUnit);\n  }\n\n  return def;\n};\n\nlegend.style = function(name, e, def, style) {\n  var symbols = getter(def, ['properties', 'symbols']),\n    marktype = e.marktype();\n\n  switch (marktype) {\n    case 'bar':\n    case 'tick':\n    case 'text':\n      symbols.stroke = {value: 'transparent'};\n      symbols.shape = {value: 'square'};\n      break;\n\n    case 'circle':\n    case 'square':\n      symbols.shape = {value: marktype};\n      /* fall through */\n    case 'point':\n      // fill or stroke\n      if (e.field(SHAPE).filled) {\n        if (e.has(COLOR) && name === COLOR) {\n          symbols.fill = {scale: COLOR, field: 'data'};\n        } else {\n          symbols.fill = {value: e.value(COLOR)};\n        }\n        symbols.stroke = {value: 'transparent'};\n      } else {\n        if (e.has(COLOR) && name === COLOR) {\n          symbols.stroke = {scale: COLOR, field: 'data'};\n        } else {\n          symbols.stroke = {value: e.value(COLOR)};\n        }\n        symbols.fill = {value: 'transparent'};\n        symbols.strokeWidth = {value: e.config('strokeWidth')};\n      }\n\n      break;\n    case 'line':\n    case 'area':\n      // TODO use shape here after implementing #508\n      break;\n  }\n\n  var opacity = e.field(COLOR).opacity || style.opacity;\n  if (opacity) {\n    symbols.opacity = {value: opacity};\n  }\n  return def;\n};\n\nlegend.title = function(name, encoding) {\n  var leg = encoding.field(name).legend;\n\n  if (leg.title) return leg.title;\n\n  return encoding.fieldTitle(name);\n};\n\n},{\"../globals\":33,\"../util\":37,\"./time\":28}],22:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar marks = module.exports = {};\n\nmarks.def = function(encoding, layout, style, stats) {\n\n  var defs = [],\n    mark = marks[encoding.marktype()],\n    from = encoding.dataTable();\n\n  // to add a background to text, we need to add it before the text\n  if (encoding.marktype() === TEXT && encoding.has(COLOR)) {\n    var bg = {\n      x: {value: 0},\n      y: {value: 0},\n      x2: {value: layout.cellWidth},\n      y2: {value: layout.cellHeight},\n      fill: {scale: COLOR, field: encoding.fieldRef(COLOR)}\n    };\n    defs.push({\n      type: 'rect',\n      from: {data: from},\n      properties: {enter: bg, update: bg}\n    });\n  }\n\n  // add the mark def for the main thing\n  var p = mark.prop(encoding, layout, style, stats);\n  defs.push({\n    type: mark.type,\n    from: {data: from},\n    properties: {enter: p, update: p}\n  });\n\n  return defs;\n};\n\nmarks.bar = {\n  type: 'rect',\n  stack: true,\n  prop: bar_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1}\n};\n\nmarks.line = {\n  type: 'line',\n  line: true,\n  prop: line_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, detail:1}\n};\n\nmarks.area = {\n  type: 'area',\n  stack: true,\n  line: true,\n  requiredEncoding: ['x', 'y'],\n  prop: area_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1}\n};\n\nmarks.tick = {\n  type: 'rect',\n  prop: tick_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, detail: 1}\n};\n\nmarks.circle = {\n  type: 'symbol',\n  prop: filled_point_props('circle'),\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, detail: 1}\n};\n\nmarks.square = {\n  type: 'symbol',\n  prop: filled_point_props('square'),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: 'symbol',\n  prop: point_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, shape: 1, detail: 1}\n};\n\nmarks.text = {\n  type: 'text',\n  prop: text_props,\n  requiredEncoding: ['text'],\n  supportedEncoding: {row: 1, col: 1, size: 1, color: 1, text: 1}\n};\n\nfunction bar_props(e, layout, style) {\n  // jshint unused:false\n\n  var p = {};\n\n  // x's and width\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (!e.has(Y) || e.isDimension(Y)) {\n      p.x2 = {value: 0};\n    }\n  } else {\n    if (e.has(X)) { // is ordinal\n       p.xc = {scale: X, field: e.fieldRef(X)};\n    } else {\n       p.x = {value: 0, offset: e.config('singleBarOffset')};\n    }\n  }\n\n  // width\n  if (!p.x2) {\n    if (!e.has(X) || e.isOrdinalScale(X)) { // no X or X is ordinal\n      if (e.has(SIZE)) {\n        p.width = {scale: SIZE, field: e.fieldRef(SIZE)};\n      } else {\n        p.width = {\n          value: e.bandSize(X, layout.x.useSmallBand),\n          offset: -1\n        };\n      }\n    } else { // X is Quant or Time Scale\n      p.width = {value: 2};\n    }\n  }\n\n  // y's & height\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    p.y2 = {group: 'height'};\n  } else {\n    if (e.has(Y)) { // is ordinal\n      p.yc = {scale: Y, field: e.fieldRef(Y)};\n    } else {\n      p.y2 = {group: 'height', offset: -e.config('singleBarOffset')};\n    }\n\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.fieldRef(SIZE)};\n    } else {\n      p.height = {\n        value: e.bandSize(Y, layout.y.useSmallBand),\n        offset: -1\n      };\n    }\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // opacity\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction point_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.fieldRef(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.value(SIZE)};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.fieldRef(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.value(SHAPE)};\n  }\n\n  // fill or stroke\n  if (e.field(SHAPE).filled) {\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n  } else {\n    if (e.has(COLOR)) {\n      p.stroke = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.stroke = {value: e.value(COLOR)};\n    }\n    p.strokeWidth = {value: e.config('strokeWidth')};\n  }\n\n  // opacity\n  var opacity = e.field(COLOR).opacity || style.opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction line_props(e,layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction area_props(e, layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: 'horizontal'};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else {\n    p.y = {group: 'height'};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction tick_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (e.isDimension(X)) {\n      p.x.offset = -e.bandSize(X, layout.x.useSmallBand) / 3;\n    }\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    if (e.isDimension(Y)) {\n      p.y.offset = -e.bandSize(Y, layout.y.useSmallBand) / 3;\n    }\n  } else if (!e.has(Y)) {\n    p.y = {value: 0};\n  }\n\n  // width\n  if (!e.has(X) || e.isDimension(X)) {\n    p.width = {value: e.bandSize(X, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.width = {value: 1};\n  }\n\n  // height\n  if (!e.has(Y) || e.isDimension(Y)) {\n    p.height = {value: e.bandSize(Y, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.height = {value: 1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity  || style.opacity;\n  if(opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, layout, style) {\n    var p = {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.fieldRef(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.fieldRef(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.fieldRef(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.value(SIZE)};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n\n    var opacity = e.field(COLOR).opacity  || style.opacity;\n    if(opacity) p.opacity = {value: opacity};\n\n    return p;\n  };\n}\n\nfunction text_props(e, layout, style, stats) {\n  var p = {},\n    field = e.field(TEXT);\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    if (e.has(TEXT) && e.isType(TEXT, Q)) {\n      p.x = {value: layout.cellWidth-5};\n    } else {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.fieldRef(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.fontSize = {value: field.font.size};\n  }\n\n  // fill\n  // color should be set to background\n  p.fill = {value: field.color};\n\n  var opacity = e.field(COLOR).opacity  || style.opacity;\n  if(opacity) p.opacity = {value: opacity};\n\n  // text\n  if (e.has(TEXT)) {\n    if (e.isType(TEXT, Q)) {\n      var fieldStats = stats[e.fieldName(TEXT)],\n        numberFormat = field.format || e.numberFormat(fieldStats);\n\n      p.text = {template: '{{' + e.fieldRef(TEXT) + ' | number:\\'' +\n        numberFormat +'\\'}}'};\n      p.align = {value: field.align};\n    } else {\n      p.text = {field: e.fieldRef(TEXT)};\n    }\n  } else {\n    p.text = {value: field.placeholder};\n  }\n\n  p.font = {value: field.font.family};\n  p.fontWeight = {value: field.font.weight};\n  p.fontStyle = {value: field.font.style};\n  p.baseline = {value: field.baseline};\n\n  return p;\n}\n\n},{\"../globals\":33}],23:[function(require,module,exports){\n'use strict';\nrequire('../globals');\nvar util = require('../util'),\n  time = require('./time'),\n  colorbrewer = require('colorbrewer'),\n  interpolate = require('d3-color').interpolateHsl,\n  schema = require('../schema/schema'),\n  vlsort = require('./sort');\n\nvar scale = module.exports = {};\n\nscale.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\nscale.defs = function(names, encoding, layout, stats, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale.type(name, encoding),\n      domain: scale.domain(name, encoding, stats, opt)\n    };\n\n    s.sort = scale.sort(s, encoding, name) || undefined;\n\n    scale.range(s, encoding, layout, stats, opt);\n\n    return (a.push(s), a);\n  }, []);\n};\n\nscale.sort = function(s, encoding, name) {\n  return s.type === 'ordinal' && (\n    !!encoding.bin(name) ||\n    encoding.sort(name).length === 0\n  );\n};\n\nscale.type = function(name, encoding) {\n\n  switch (encoding.type(name)) {\n    case N: //fall through\n    case O: return 'ordinal';\n    case T:\n      var timeUnit = encoding.field(name).timeUnit;\n      return timeUnit ? time.scale.type(timeUnit, name) : 'time';\n    case Q:\n      if (encoding.bin(name)) {\n        return name === COLOR ? 'linear' : 'ordinal';\n      }\n      return encoding.scale(name).type;\n  }\n};\n\nscale.domain = function (name, encoding, stats, opt) {\n  var field = encoding.field(name);\n\n  if (encoding.isType(name, T)) {\n    var range = time.scale.domain(field.timeUnit, name);\n    if(range) return range;\n  }\n\n  if (field.bin) {\n    // TODO(kanitw): this must be changed in vg2\n    var fieldStat = stats[field.name],\n      bins = util.getbins(fieldStat, field.bin.maxbins || schema.MAXBINS_DEFAULT),\n      numbins = (bins.stop - bins.start) / bins.step;\n    return util.range(numbins).map(function(i) {\n      return bins.start + bins.step * i;\n    });\n  }\n\n  if (name == opt.stack) {\n    return {\n      data: STACKED,\n      field: encoding.fieldRef(name, {\n        data: !encoding._vega2,\n        prefn: (opt.facet ? 'max_' : '') + 'sum_'\n      })\n    };\n  }\n  var aggregate = encoding.aggregate(name),\n    timeUnit = field.timeUnit,\n    scaleUseRawDomain = encoding.scale(name).useRawDomain,\n    useRawDomain = scaleUseRawDomain !== undefined ?\n      scaleUseRawDomain : encoding.config('useRawDomain'),\n    notCountOrSum = !aggregate || (aggregate !=='count' && aggregate !== 'sum');\n\n  // FIXME revise this part\n\n  if ( useRawDomain && notCountOrSum && (\n      // Q always uses non-ordinal scale except when it's binned and thus uses ordinal scale.\n      (encoding.isType(name, Q) && !field.bin) ||\n      // T uses non-ordinal scale when there's no unit or when the unit is not ordinal.\n      (encoding.isType(name, T) && (!timeUnit || !time.isOrdinalFn(timeUnit)))\n    )\n  ) {\n    return {data: RAW, field: encoding.fieldRef(name, {nofn: !timeUnit})};\n  }\n\n  var data = encoding.sort(name, stats).length > 0 ?\n    vlsort.getDataName(name):\n    encoding.dataTable();\n\n  return {data: data, field: encoding.fieldRef(name)};\n};\n\n\nscale.range = function (s, encoding, layout, stats) {\n  var spec = encoding.scale(s.name),\n    field = encoding.field(s.name),\n    timeUnit = field.timeUnit;\n\n  switch (s.name) {\n    case X:\n      s.range = layout.cellWidth ? [0, layout.cellWidth] : 'width';\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(X, layout.x.useSmallBand);\n      } else {\n        if (encoding.isType(s.name,T) && timeUnit === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n      s.round = true;\n      if (s.type === 'time') {\n        s.nice = timeUnit || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (s.type === 'ordinal') {\n        s.range = layout.cellHeight ?\n          (field.bin ? [layout.cellHeight, 0] : [0, layout.cellHeight]) :\n          'height';\n        s.bandWidth = encoding.bandSize(Y, layout.y.useSmallBand);\n      } else {\n        s.range = layout.cellHeight ? [layout.cellHeight, 0] : 'height';\n        if (encoding.isType(s.name,T) && timeUnit === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n\n      s.round = true;\n\n      if (s.type === 'time') {\n        s.nice = timeUnit || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case ROW: // support only ordinal\n      s.bandWidth = layout.cellHeight;\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL: // support only ordinal\n      s.bandWidth = layout.cellWidth;\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is('bar')) {\n        // FIXME this is definitely incorrect\n        // but let's fix it later since bar size is a bad encoding anyway\n        s.range = [3, Math.max(encoding.bandSize(X), encoding.bandSize(Y))];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else { //point\n        var bandSize = Math.min(encoding.bandSize(X), encoding.bandSize(Y)) - 1;\n        s.range = [10, 0.8 * bandSize*bandSize];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = 'shapes';\n      break;\n    case COLOR:\n      s.range = scale.color(s, encoding, stats);\n      if (s.type !== 'ordinal') s.zero = false;\n      break;\n    default:\n      throw new Error('Unknown encoding name: '+ s.name);\n  }\n\n  // FIXME(kanitw): Jul 29, 2015 - consolidate this with above\n  switch (s.name) {\n    case ROW:\n    case COL:\n      s.padding = encoding.config('cellPadding');\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (s.type === 'ordinal') { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.field(s.name).band.padding;\n      }\n  }\n};\n\nscale.color = function(s, encoding, stats) {\n  var colorScale = encoding.scale(COLOR),\n    range = colorScale.range,\n    cardinality = encoding.cardinality(COLOR, stats),\n    type = encoding.type(COLOR);\n\n  if (range === undefined) {\n    var ordinalPalette = colorScale.ordinalPalette,\n      quantitativeRange = colorScale.quantitativeRange;\n\n    if (s.type === 'ordinal') {\n      if (type === N) {\n        // use categorical color scale\n        if (cardinality <= 10) {\n          range = colorScale.c10palette;\n        } else {\n          range = colorScale.c20palette;\n        }\n        return scale.color.palette(range, cardinality, type);\n      } else {\n        if (ordinalPalette) {\n          return scale.color.palette(ordinalPalette, cardinality, type);\n        }\n        return scale.color.interpolate(quantitativeRange[0], quantitativeRange[1], cardinality);\n      }\n    } else { //time or quantitative\n      return [quantitativeRange[0], quantitativeRange[1]];\n    }\n  }\n};\n\nscale.color.palette = function(range, cardinality, type) {\n  // FIXME(kanitw): Jul 29, 2015 - check range is string\n  switch (range) {\n    case 'category10k':\n      // tableau's category 10, ordered by perceptual kernel study results\n      // https://github.com/uwdata/perceptual-kernels\n      return ['#2ca02c', '#e377c2', '#7f7f7f', '#17becf', '#8c564b', '#d62728', '#bcbd22', '#9467bd', '#ff7f0e', '#1f77b4'];\n\n    // d3/tableau category10/20/20b/20c\n    case 'category10':\n      return ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];\n\n    case 'category20':\n      return ['#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'];\n\n    case 'category20b':\n      return ['#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39', '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b', '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'];\n\n    case 'category20c':\n      return ['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#e6550d', '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354', '#74c476', '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc', '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9'];\n  }\n\n  // TODO add our own set of custom ordinal color palette\n\n  if (range in colorbrewer) {\n    var palette = colorbrewer[range];\n\n    // if cardinality pre-defined, use it.\n    if (cardinality in palette) return palette[cardinality];\n\n    // if not, use the highest cardinality one for nominal\n    if (type === N) {\n      return palette[Math.max.apply(null, util.keys(palette))];\n    }\n\n    // otherwise, interpolate\n    var ps = cardinality < 3 ? 3 : Math.max.apply(null, util.keys(palette)),\n      from = 0 , to = ps - 1;\n    // FIXME add config for from / to\n\n    return scale.color.interpolate(palette[ps][from], palette[ps][to], cardinality);\n  }\n\n  return range;\n};\n\nscale.color.interpolate = function (start, end, cardinality) {\n\n  var interpolator = interpolate(start, end);\n  return util.range(cardinality).map(function(i) { return interpolator(i*1.0/(cardinality-1)); });\n};\n\n},{\"../globals\":33,\"../schema/schema\":35,\"../util\":37,\"./sort\":24,\"./time\":28,\"colorbrewer\":3,\"d3-color\":4}],24:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar vlfield = require('../field');\n\nmodule.exports = sort;\n\n// adds new transforms that produce sorted fields\nfunction sort(data, encoding, stats, opt) {\n  // jshint unused:false\n\n  var datasetMapping = {};\n\n  encoding.forEach(function(field, encType) {\n    var sortBy = encoding.sort(encType, stats);\n    if (sortBy.length > 0) {\n      var fields = sortBy.map(function(d) {\n        return {\n          op: d.aggregate,\n          field: vlfield.fieldRef(d, {nofn: true, data: !encoding._vega2})\n        };\n      });\n\n      var byClause = sortBy.map(function(d) {\n        var reverse = (d.reverse ? '-' : '');\n        return reverse + vlfield.fieldRef(d, {data: !encoding._vega2});\n      });\n\n      var dataName = sort.getDataName(encType);\n\n      var transforms = [\n        {\n          type: 'aggregate',\n          groupby: [ encoding.fieldRef(encType) ],\n          fields: fields\n        },\n        {\n          type: 'sort',\n          by: byClause\n        }\n      ];\n\n      data.push({\n        name: dataName,\n        source: RAW,\n        transform: transforms\n      });\n\n      datasetMapping[encType] = dataName;\n    }\n  });\n\n  return data;\n}\n\nsort.getDataName = function(encType) {\n  return 'sorted-' + encType;\n};\n\n\n},{\"../field\":32,\"../globals\":33}],25:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar  marks = require('./marks');\n\nmodule.exports = stacking;\n\nfunction stacking(data, encoding, mdef) {\n  if (!marks[encoding.marktype()].stack) return false;\n\n  // TODO: add || encoding.has(LOD) here once LOD is implemented\n  if (!encoding.has(COLOR)) return false;\n\n  var dim=null, val=null, idx =null,\n    isXMeasure = encoding.isMeasure(X),\n    isYMeasure = encoding.isMeasure(Y),\n    facets = encoding.facets();\n\n  if (isXMeasure && !isYMeasure) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  } else if (isYMeasure && !isXMeasure) {\n    dim = X;\n    val = Y;\n    idx = 1;\n  } else {\n    return null; // no stack encoding\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: encoding.dataTable(),\n    transform: [{\n      type: 'aggregate',\n      groupby: [encoding.fieldRef(dim)].concat(facets), // dim and other facets\n      fields: [{op: 'sum', field: encoding.fieldRef(val)}] // TODO check if field with aggregate is correct?\n    }]\n  };\n\n  if (facets && facets.length > 0) {\n    stacked.transform.push({ //calculate max for each facet\n      type: 'aggregate',\n      groupby: facets,\n      fields: [{\n        op: 'max',\n        field: encoding.fieldName(val, {fn: 'sum'})\n      }]\n    });\n  }\n\n  data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: 'stack',\n    point: encoding.fieldRef(dim),\n    height: encoding.fieldRef(val),\n    output: {y1: val, y0: val + '2'}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val + '2'] = mdef.properties.enter[val + '2'] = {scale: val, field: val + '2'};\n\n  return val; //return stack encoding\n}\n\n},{\"../globals\":33,\"./marks\":22}],26:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar vlfield = require('../field');\n\nmodule.exports = function(encoding, stats) {\n  return {\n    opacity: estimateOpacity(encoding, stats),\n  };\n};\n\nfunction estimateOpacity(encoding,stats) {\n  if (!stats) {\n    return 1;\n  }\n\n  var numPoints = 0;\n\n  if (encoding.isAggregate()) { // aggregate plot\n    numPoints = 1;\n\n    //  get number of points in each \"cell\"\n    //  by calculating product of cardinality\n    //  for each non faceting and non-ordinal X / Y fields\n    //  note that ordinal x,y are not include since we can\n    //  consider that ordinal x are subdividing the cell into subcells anyway\n    encoding.forEach(function(field, encType) {\n\n      if (encType !== ROW && encType !== COL &&\n          !((encType === X || encType === Y) &&\n          vlfield.isOrdinalScale(field))\n        ) {\n        numPoints *= encoding.cardinality(encType, stats);\n      }\n    });\n\n  } else { // raw plot\n\n    // TODO: error handling\n    if (!stats['*'])\n      return 1;\n\n    numPoints = stats['*'].max;  // count\n\n    // small multiples divide number of points\n    var numMultiples = 1;\n    if (encoding.has(ROW)) {\n      numMultiples *= encoding.cardinality(ROW, stats);\n    }\n    if (encoding.has(COL)) {\n      numMultiples *= encoding.cardinality(COL, stats);\n    }\n    numPoints /= numMultiples;\n  }\n\n  var opacity = 0;\n  if (numPoints <= 25) {\n    opacity = 1;\n  } else if (numPoints < 200) {\n    opacity = 0.8;\n  } else if (numPoints < 1000 || encoding.is('tick')) {\n    opacity = 0.7;\n  } else {\n    opacity = 0.3;\n  }\n\n  return opacity;\n}\n\n\n},{\"../field\":32,\"../globals\":33}],27:[function(require,module,exports){\n'use strict';\n\nrequire('../globals');\n\nvar groupdef = require('./group').def;\n\nmodule.exports = subfaceting;\n\nfunction subfaceting(group, mdef, details, stack, encoding) {\n  var m = group.marks,\n    g = groupdef('subfacet', {marks: m});\n\n  group.marks = [g];\n  g.from = mdef.from;\n  delete mdef.from;\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: 'facet', keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: 'sort', by: encoding.fieldRef(COLOR)});\n  }\n}\n\n},{\"../globals\":33,\"./group\":19}],28:[function(require,module,exports){\n'use strict';\n\nvar util = require('../util'),\n  d3_time_format = require('d3-time-format');\n\nvar time = module.exports = {};\n\nvar LONG_DATE = new Date(2014, 8, 17);\n\ntime.cardinality = function(field, stats, filterNull, type) {\n  var timeUnit = field.timeUnit;\n  switch (timeUnit) {\n    case 'seconds': return 60;\n    case 'minutes': return 60;\n    case 'hours': return 24;\n    case 'day': return 7;\n    case 'date': return 31;\n    case 'month': return 12;\n    case 'year':\n      var stat = stats[field.name],\n        yearstat = stats['year_'+field.name];\n\n      if (!yearstat) { return null; }\n\n      return yearstat.distinct -\n        (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n  }\n\n  return null;\n};\n\ntime.formula = function(timeUnit, fieldRef) {\n  // TODO(kanitw): add formula to other time format\n  var fn = 'utc' + timeUnit;\n  return fn + '(' + fieldRef + ')';\n};\n\ntime.maxLength = function(timeUnit, encoding) {\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'date':\n      return 2;\n    case 'month':\n    case 'day':\n      var range = time.range(timeUnit, encoding);\n      if (range) {\n        // return the longest name in the range\n        return Math.max.apply(null, range.map(function(r) {return r.length;}));\n      }\n      return 2;\n    case 'year':\n      return 4; //'1998'\n  }\n  // no time unit\n  var timeFormat = encoding.config('timeFormat');\n  return d3_time_format.utcFormat(timeFormat)(LONG_DATE).length;\n};\n\ntime.range = function(timeUnit, encoding) {\n  var labelLength = encoding.config('timeScaleLabelLength'),\n    scaleLabel;\n  switch (timeUnit) {\n    case 'day':\n      scaleLabel = encoding.config('dayScaleLabel');\n      break;\n    case 'month':\n      scaleLabel = encoding.config('monthScaleLabel');\n      break;\n  }\n  if (scaleLabel) {\n    return labelLength ? scaleLabel.map(\n        function(s) { return s.substr(0, labelLength);}\n      ) : scaleLabel;\n  }\n  return;\n};\n\n\n/**\n * @param  {Object} encoding\n * @return {Array}  scales for time unit names\n */\ntime.scales = function(encoding) {\n  var scales = encoding.reduce(function(scales, field) {\n    var timeUnit = field.timeUnit;\n    if (field.type === T && timeUnit && !scales[timeUnit]) {\n      var scale = time.scale.def(field.timeUnit, encoding);\n      if (scale) scales[timeUnit] = scale;\n    }\n    return scales;\n  }, {});\n\n  return util.vals(scales);\n};\n\n\ntime.scale = {};\n\n/** append custom time scales for axis label */\ntime.scale.def = function(timeUnit, encoding) {\n  var range = time.range(timeUnit, encoding);\n\n  if (range) {\n    return {\n      name: 'time-'+timeUnit,\n      type: 'ordinal',\n      domain: time.scale.domain(timeUnit),\n      range: range\n    };\n  }\n  return null;\n};\n\ntime.isOrdinalFn = function(timeUnit) {\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'day':\n    case 'date':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\ntime.scale.type = function(timeUnit, name) {\n  if (name === COLOR) {\n    return 'linear'; // time has order, so use interpolated ordinal color scale.\n  }\n\n  return time.isOrdinalFn(timeUnit) || name === COL || name === ROW ? 'ordinal' : 'linear';\n};\n\ntime.scale.domain = function(timeUnit, name) {\n  var isColor = name === COLOR;\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes': return isColor ? [0,59] : util.range(0, 60);\n    case 'hours': return isColor ? [0,23] : util.range(0, 24);\n    case 'day': return isColor ? [0,6] : util.range(0, 7);\n    case 'date': return isColor ? [1,31] : util.range(1, 32);\n    case 'month': return isColor ? [0,11] : util.range(0, 12);\n  }\n  return null;\n};\n\n/** whether a particular time function has custom scale for labels implemented in time.scale */\ntime.hasScale = function(timeUnit) {\n  switch (timeUnit) {\n    case 'day':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\n},{\"../util\":37,\"d3-time-format\":6}],29:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, TEXT, DETAIL];\n\nconsts.shorthand = {\n  delim:  '|',\n  assign: '=',\n  type:   ',',\n  func:   '_'\n};\n\n},{\"./globals\":33}],30:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar stats = require('datalib/src/stats');\n\nvar vldata = module.exports = {};\n\n/** Mapping from datalib's inferred type to Vega-lite's type */\nvldata.types = {\n  'boolean': N,\n  'number': Q,\n  'integer': Q,\n  'date': T,\n  'string': N\n};\n\nvldata.stats = function(data) {\n  var summary = stats.summary(data);\n\n  return summary.reduce(function(s, profile) {\n    s[profile.field] = profile;\n    return s;\n  }, {\n    '*': {\n      max: data.length,\n      min: 0\n    }\n  });\n};\n},{\"./globals\":33,\"datalib/src/stats\":11}],31:[function(require,module,exports){\n// utility for enc\n\n'use strict';\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  vlfield = require('./field'),\n  util = require('./util'),\n  schema = require('./schema/schema'),\n  encTypes = schema.encTypes;\n\nvar vlenc = module.exports = {};\n\nvlenc.countRetinal = function(enc) {\n  var count = 0;\n  if (enc.color) count++;\n  if (enc.size) count++;\n  if (enc.shape) count++;\n  return count;\n};\n\nvlenc.has = function(enc, encType) {\n  var fieldDef = enc && enc[encType];\n  return fieldDef && fieldDef.name;\n};\n\nvlenc.isAggregate = function(enc) {\n  for (var k in enc) {\n    if (vlenc.has(enc, k) && enc[k].aggregate) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvlenc.forEach = function(enc, f) {\n  var i = 0;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      f(enc[k], k, i++);\n    }\n  });\n};\n\nvlenc.map = function(enc, f) {\n  var arr = [];\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      arr.push(f(enc[k], k, enc));\n    }\n  });\n  return arr;\n};\n\nvlenc.reduce = function(enc, f, init) {\n  var r = init;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      r = f(r, enc[k], k,  enc);\n    }\n  });\n  return r;\n};\n\n/*\n * return key-value pairs of field name and list of fields of that field name\n */\nvlenc.fields = function(enc) {\n  return vlenc.reduce(enc, function (m, field) {\n    var fieldList = m[field.name] = m[field.name] || [],\n      containsType = fieldList.containsType = fieldList.containsType || {};\n\n    if (fieldList.indexOf(field) === -1) {\n      fieldList.push(field);\n      // augment the array with containsType.Q / O / N / T\n      containsType[field.type] = true;\n    }\n    return m;\n  }, {});\n};\n\nvlenc.shorthand = function(enc) {\n  return vlenc.map(enc, function(field, et) {\n    return et + c.assign + vlfield.shorthand(field);\n  }).join(c.delim);\n};\n\nvlenc.fromShorthand = function(shorthand) {\n  var enc = util.isArray(shorthand) ? shorthand : shorthand.split(c.delim);\n  return enc.reduce(function(m, e) {\n    var split = e.split(c.assign),\n        enctype = split[0].trim(),\n        field = split[1];\n\n    m[enctype] = vlfield.fromShorthand(field);\n    return m;\n  }, {});\n};\n},{\"./consts\":29,\"./field\":32,\"./schema/schema\":35,\"./util\":37}],32:[function(require,module,exports){\n'use strict';\n\n// utility for field\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compiler/time'),\n  util = require('./util'),\n  schema = require('./schema/schema');\n\nvar vlfield = module.exports = {};\n\n/**\n * @param field\n * @param opt\n *   opt.nofn -- exclude bin, aggregate, timeUnit\n *   opt.data - include 'data.'\n *   opt.d - include 'd.'\n *   opt.fn - replace fn with custom function prefix\n *   opt.prefn - prepend fn with custom function prefix\n\n * @return {[type]}       [description]\n */\nvlfield.fieldRef = function(field, opt) {\n  opt = opt || {};\n\n  var f = (opt.d ? 'd.' : '') +\n          (opt.data ? 'data.' : '') +\n          (opt.prefn || ''),\n    nofn = opt.nofn || opt.fn,\n    name = field.name;\n\n  if (vlfield.isCount(field)) {\n    return f + 'count';\n  } else if (!nofn && field.bin) {\n    return f + 'bin_' + name;\n  } else if (!nofn && field.aggregate) {\n    return f + field.aggregate + '_' + name;\n  } else if (!nofn && field.timeUnit) {\n    return f + field.timeUnit + '_' + name;\n  } else if (opt.fn) {\n    return f + opt.fn + '_' + name;\n  } else {\n    return f + name;\n  }\n};\n\nvlfield.shorthand = function(f) {\n  var c = consts.shorthand;\n  return (f.aggregate ? f.aggregate + c.func : '') +\n    (f.timeUnit ? f.timeUnit + c.func : '') +\n    (f.bin ? 'bin' + c.func : '') +\n    (f.name || '') + c.type + f.type;\n};\n\nvlfield.shorthands = function(fields, delim) {\n  delim = delim || c.delim;\n  return fields.map(vlfield.shorthand).join(delim);\n};\n\nvlfield.fromShorthand = function(shorthand) {\n  var split = shorthand.split(c.type), i;\n  var o = {\n    name: split[0].trim(),\n    type: split[1].trim()\n  };\n\n  // check aggregate type\n  for (i in schema.aggregate.enum) {\n    var a = schema.aggregate.enum[i];\n    if (o.name.indexOf(a + '_') === 0) {\n      o.name = o.name.substr(a.length + 1);\n      if (a == 'count' && o.name.length === 0) o.name = '*';\n      o.aggregate = a;\n      break;\n    }\n  }\n\n  // check time timeUnit\n  for (i in schema.timefns) {\n    var tu = schema.timefns[i];\n    if (o.name && o.name.indexOf(tu + '_') === 0) {\n      o.name = o.name.substr(o.length + 1);\n      o.timeUnit = tu;\n      break;\n    }\n  }\n\n  // check bin\n  if (o.name && o.name.indexOf('bin_') === 0) {\n    o.name = o.name.substr(4);\n    o.bin = true;\n  }\n\n  return o;\n};\n\nvar isType = vlfield.isType = function (fieldDef, type) {\n  return fieldDef.type === type;\n};\n\nvar isTypes = vlfield.isTypes = function (fieldDef, types) {\n  for (var t=0; t<types.length; t++) {\n    if(fieldDef.type === types[t]) return true;\n  }\n  return false;\n};\n\n/*\n * Most fields that use ordinal scale are dimensions.\n * However, YEAR(T), YEARMONTH(T) use time scale, not ordinal but are dimensions too.\n */\nvlfield.isOrdinalScale = function(field) {\n  return  isTypes(field, [N, O]) || field.bin ||\n    ( isType(field, T) && field.timeUnit && time.isOrdinalFn(field.timeUnit) );\n};\n\nfunction isDimension(field) {\n  return  isTypes(field, [N, O]) || !!field.bin ||\n    ( isType(field, T) && !!field.timeUnit );\n}\n\n/**\n * For encoding, use encoding.isDimension() to avoid confusion.\n * Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.isDimension = function(field) {\n  return field && isDimension(field);\n};\n\nvlfield.isMeasure = function(field) {\n  return field && !isDimension(field);\n};\n\nvlfield.count = function() {\n  return {name:'*', aggregate: 'count', type: Q, displayName: vlfield.count.displayName};\n};\n\nvlfield.count.displayName = 'Number of Records';\n\nvlfield.isCount = function(field) {\n  return field.aggregate === 'count';\n};\n\n/**\n * For encoding, use encoding.cardinality() to avoid confusion.  Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.cardinality = function(field, stats, filterNull) {\n  // FIXME need to take filter into account\n\n  var stat = stats[field.name];\n  var type = field.type;\n\n  filterNull = filterNull || {};\n\n  if (field.bin) {\n    var bins = util.getbins(stat, field.bin.maxbins || schema.MAXBINS_DEFAULT);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  if (isType(field, T)) {\n    var cardinality = time.cardinality(field, stats, filterNull, type);\n    if(cardinality !== null) return cardinality;\n    //otherwise use calculation below\n  }\n  if (field.aggregate) {\n    return 1;\n  }\n\n  // remove null\n  return stat.distinct -\n    (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n};\n\n},{\"./compiler/time\":28,\"./consts\":29,\"./globals\":33,\"./schema/schema\":35,\"./util\":37}],33:[function(require,module,exports){\n(function (global){\n'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.AGGREGATE = 'aggregate';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.N = 'N';\ng.O = 'O';\ng.Q = 'Q';\ng.T = 'T';\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],34:[function(require,module,exports){\n'use strict';\n\n// TODO(kanitw): chat with Vega team and possibly move this to vega-logging\nmodule.exports = function(prefix) {\n  // Borrowed some ideas from http://stackoverflow.com/a/15653260/866989\n  // and https://github.com/patik/console.log-wrapper/blob/master/consolelog.js\n  var METHODS = ['error', 'info', 'debug', 'warn', 'log'];\n\n  return METHODS.reduce(function(logger, fn) {\n    var cfn = console[fn] ? fn : 'log';\n    if (console[cfn].bind === 'undefined') { // IE < 10\n        logger[fn] = Function.prototype.bind.call(console[cfn], console, prefix);\n    }\n    else {\n        logger[fn] = console[cfn].bind(console, prefix);\n    }\n    return logger;\n  }, {});\n};\n},{}],35:[function(require,module,exports){\n// Package of defining Vega-lite Specification's json schema\n'use strict';\n\nrequire('../globals');\n\nvar schema = module.exports = {},\n  util = require('../util'),\n  toMap = util.toMap,\n  colorbrewer = require('colorbrewer');\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: 'string',\n  enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\n};\n\nschema.aggregate = {\n  type: 'string',\n  enum: ['avg', 'sum', 'median', 'min', 'max', 'count'],\n  supportedEnums: {\n    Q: ['avg', 'median', 'sum', 'min', 'max', 'count'],\n    O: ['median','min','max'],\n    N: [],\n    T: ['avg', 'median', 'min', 'max'],\n    '': ['count']\n  },\n  supportedTypes: toMap([Q, N, O, T, ''])\n};\n\nschema.getSupportedRole = function(encType) {\n  return schema.schema.properties.encoding.properties[encType].supportedRole;\n};\n\nschema.timeUnits = ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'];\n\nschema.defaultTimeFn = 'month';\n\nschema.timeUnit = {\n  type: 'string',\n  enum: schema.timeUnits,\n  supportedTypes: toMap([T])\n};\n\nschema.scale_type = {\n  type: 'string',\n  // TODO(kanitw) read vega's schema here, add description\n  enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\n  default: 'linear',\n  supportedTypes: toMap([Q])\n};\n\nschema.field = {\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string'\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nschema.MAXBINS_DEFAULT = 15;\n\nvar bin = {\n  type: ['boolean', 'object'],\n  default: false,\n  properties: {\n    maxbins: {\n      type: 'integer',\n      default: schema.MAXBINS_DEFAULT,\n      minimum: 2,\n      description: 'Maximum number of bins.'\n    }\n  },\n  supportedTypes: toMap([Q]) // TODO: add O after finishing #81\n};\n\nvar typicalField = merge(clone(schema.field), {\n  type: 'object',\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T]\n    },\n    aggregate: schema.aggregate,\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    scale: {\n      type: 'object',\n      properties: {\n        type: schema.scale_type,\n        reverse: {\n          type: 'boolean',\n          default: false,\n          supportedTypes: toMap([Q, T])\n        },\n        zero: {\n          type: 'boolean',\n          description: 'Include zero',\n          default: true,\n          supportedTypes: toMap([Q, T])\n        },\n        nice: {\n          type: 'string',\n          enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\n          supportedTypes: toMap([T])\n        },\n        useRawDomain: {\n          type: 'boolean',\n          default: undefined,\n          description: 'Use the raw data range as scale domain instead of ' +\n                       'aggregated data for aggregate axis. ' +\n                       'This option does not work with sum or count aggregate' +\n                       'as they might have a substantially larger scale range.' +\n                       'By default, use value from config.useRawDomain.'\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: 'object',\n  supportedRole: {\n    dimension: true\n  },\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T] // ordinal-only field supports Q when bin is applied and T when time unit is applied.\n    },\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    aggregate: {\n      type: 'string',\n      enum: ['count'],\n      supportedTypes: toMap([N, O]) // FIXME this looks weird to me\n    }\n  }\n});\n\nvar axisMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true},\n  properties: {\n    axis: {\n      type: 'object',\n      properties: {\n        grid: {\n          type: 'boolean',\n          default: true,\n          description: 'A flag indicate if gridlines should be created in addition to ticks.'\n        },\n        layer: {\n          type: 'string',\n          default: 'back',\n          description: 'A string indicating if the axis (and any gridlines) should be placed above or below the data marks.'\n        },\n        orient: {\n          type: 'string',\n          default: undefined,\n          enum: ['top', 'right', 'left', 'bottom'],\n          description: 'The orientation of the axis. One of top, bottom, left or right. The orientation can be used to further specialize the axis type (e.g., a y axis oriented for the right edge of the chart).'\n        },\n        ticks: {\n          type: 'integer',\n          default: 5,\n          minimum: 0,\n          description: 'A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale\\'s range.'\n        },\n        title: {\n          type: 'string',\n          default: undefined,\n          description: 'A title for the axis. (Shows field name and its function by default.)'\n        },\n        titleMaxLength: {\n          type: 'integer',\n          default: undefined,\n          minimum: 0,\n          description: 'Max length for axis title if the title is automatically generated from the field\\'s description'\n        },\n        titleOffset: {\n          type: 'integer',\n          default: undefined,  // auto\n          description: 'A title offset value for the axis.'\n        },\n        format: {\n          type: 'string',\n          default: undefined,  // auto\n          description: 'The formatting pattern for axis labels. '+\n                       'If not undefined, this will be determined by ' +\n                       'small/largeNumberFormat and the max value ' +\n                       'of the field.'\n        },\n        maxLabelLength: {\n          type: 'integer',\n          default: 25,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        },\n        labelAngle: {\n          type: 'integer',\n          default: undefined, // auto\n          minimum: 0,\n          maximum: 360,\n          description: 'Angle by which to rotate labels. Set to 0 to force horizontal.'\n        },\n      }\n    }\n  }\n};\n\nvar sortMixin = {\n  type: 'object',\n  properties: {\n    sort: {\n      type: 'array',\n      default: [],\n      items: {\n        type: 'object',\n        supportedTypes: toMap([N, O]),\n        required: ['name', 'aggregate'],\n        properties: {\n          name: {\n            type: 'string'\n          },\n          aggregate: {\n            type: 'string',\n            enum: ['avg', 'sum', 'min', 'max', 'count']\n          },\n          reverse: {\n            type: 'boolean',\n            default: false\n          }\n        }\n      }\n    }\n  }\n};\n\nvar bandMixin = {\n  type: 'object',\n  properties: {\n    band: {\n      type: 'object',\n      properties: {\n        size: {\n          type: 'integer',\n          minimum: 0,\n          default: undefined\n        },\n        padding: {\n          type: 'integer',\n          minimum: 0,\n          default: 1\n        }\n      }\n    }\n  }\n};\n\nvar legendMixin = {\n  type: 'object',\n  properties: {\n    legend: {\n      type: 'object',\n      description: 'Properties of a legend.',\n      properties: {\n        title: {\n          type: 'string',\n          default: undefined,\n          description: 'A title for the legend. (Shows field name and its function by default.)'\n        }\n      }\n    }\n  }\n};\n\nvar textMixin = {\n  type: 'object',\n  supportedMarktypes: {'text': true},\n  properties: {\n    align: {\n      type: 'string',\n      default: 'right'\n    },\n    baseline: {\n      type: 'string',\n      default: 'middle'\n    },\n    color: {\n      type: 'string',\n      role: 'color',\n      default: '#000000'\n    },\n    margin: {\n      type: 'integer',\n      default: 4,\n      minimum: 0\n    },\n    placeholder: {\n      type: 'string',\n      default: 'Abc'\n    },\n    font: {\n      type: 'object',\n      properties: {\n        weight: {\n          type: 'string',\n          enum: ['normal', 'bold'],\n          default: 'normal'\n        },\n        size: {\n          type: 'integer',\n          default: 10,\n          minimum: 0\n        },\n        family: {\n          type: 'string',\n          default: 'Helvetica Neue'\n        },\n        style: {\n          type: 'string',\n          default: 'normal',\n          enum: ['normal', 'italic']\n        }\n      }\n    },\n    format: {\n      type: 'string',\n      default: undefined,  // auto\n      description: 'The formatting pattern for text value. '+\n                   'If not undefined, this will be determined by ' +\n                   'small/largeNumberFormat and the max value ' +\n                   'of the field.'\n    },\n  }\n};\n\nvar sizeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, bar: true, circle: true, square: true, text: true},\n  properties: {\n    value: {\n      type: 'integer',\n      default: 30,\n      minimum: 0,\n      description: 'Size of marks.'\n    }\n  }\n};\n\nvar colorMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'string',\n      role: 'color',\n      default: '#4682b4',\n      description: 'Color to be used for marks.'\n    },\n    opacity: {\n      type: 'number',\n      default: undefined,  // auto\n      minimum: 0,\n      maximum: 1\n    },\n    scale: {\n      type: 'object',\n      properties: {\n        range: {\n          type: ['string', 'array'],\n          default: undefined,\n          description:\n            'Color palette, if undefined vega-lite will use data property' +\n            'to pick one from c10palette, c20palette, or ordinalPalette.'\n            //FIXME\n        },\n        c10palette: {\n          type: 'string',\n          default: 'category10',\n          enum: [\n            // Tableau\n            'category10', 'category10k',\n            // Color Brewer\n            'Pastel1', 'Pastel2', 'Set1', 'Set2', 'Set3'\n          ]\n        },\n        c20palette: {\n          type: 'string',\n          default: 'category20',\n          enum: ['category20', 'category20b', 'category20c']\n        },\n        ordinalPalette: {\n          type: 'string',\n          default: undefined,\n          description: 'Color palette to encode ordinal variables.',\n          enum: util.keys(colorbrewer)\n        },\n        quantitativeRange: {\n          type: 'array',\n          default: ['#AFC6A3', '#09622A'], // tableau greens\n          // default: ['#ccece6', '#00441b'], // BuGn.9 [2-8]\n          description: 'Color range to encode quantitative variables.',\n          minItems: 2,\n          maxItems: 2,\n          items: {\n            type: 'string',\n            role: 'color'\n          }\n        }\n      }\n    }\n  }\n};\n\nvar shapeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, circle: true, square: true},\n  properties: {\n    value: {\n      type: 'string',\n      enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\n      default: 'circle',\n      description: 'Mark to be used.'\n    },\n    filled: {\n      type: 'boolean',\n      default: false,\n      description: 'Whether the shape\\'s color should be used as fill color instead of stroke color.'\n    }\n  }\n};\n\nvar detailMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, line: true, circle: true, square: true}\n};\n\nvar rowMixin = {\n  properties: {\n    height: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    }\n  }\n};\n\nvar colMixin = {\n  properties: {\n    width: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    axis: {\n      properties: {\n        maxLabelLength: {\n          type: 'integer',\n          default: 12,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar facetMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, text: true},\n  properties: {\n    padding: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.1\n    }\n  }\n};\n\nvar requiredNameType = {\n  required: ['name', 'type']\n};\n\nvar multiRoleField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: true\n  }\n});\n\nvar quantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: 'ordinal-only' // using size to encoding category lead to order interpretation\n  }\n});\n\nvar onlyQuantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true\n  }\n});\n\nvar x = merge(clone(multiRoleField), axisMixin, bandMixin, requiredNameType, sortMixin);\nvar y = clone(x);\n\nvar facet = merge(clone(onlyOrdinalField), requiredNameType, facetMixin, sortMixin);\nvar row = merge(clone(facet), axisMixin, rowMixin);\nvar col = merge(clone(facet), axisMixin, colMixin);\n\nvar size = merge(clone(quantitativeField), legendMixin, sizeMixin, sortMixin);\nvar color = merge(clone(multiRoleField), legendMixin, colorMixin, sortMixin);\n\nvar shape = merge(clone(onlyOrdinalField), legendMixin, shapeMixin, sortMixin);\nvar detail = merge(clone(onlyOrdinalField), detailMixin, sortMixin);\n\n// we only put aggregated measure in pivot table\nvar text = merge(clone(onlyQuantitativeField), textMixin, sortMixin);\n\n// TODO add label\n\nvar filter = {\n  type: 'array',\n  items: {\n    type: 'object',\n    properties: {\n      operands: {\n        type: 'array',\n        items: {\n          type: ['string', 'boolean', 'integer', 'number']\n        }\n      },\n      operator: {\n        type: 'string',\n        enum: ['>', '>=', '=', '!=', '<', '<=', 'notNull']\n      }\n    }\n  }\n};\n\nvar data = {\n  type: 'object',\n  properties: {\n    // data source\n    formatType: {\n      type: 'string',\n      enum: ['json', 'csv'],\n      default: 'json'\n    },\n    url: {\n      type: 'string',\n      default: undefined\n    },\n    values: {\n      type: 'array',\n      default: undefined,\n      description: 'Pass array of objects instead of a url to a file.',\n      items: {\n        type: 'object',\n        additionalProperties: true\n      }\n    }\n  }\n};\n\nvar config = {\n  type: 'object',\n  properties: {\n    // template\n    width: {\n      type: 'integer',\n      default: undefined\n    },\n    height: {\n      type: 'integer',\n      default: undefined\n    },\n    viewport: {\n      type: 'array',\n      items: {\n        type: 'integer'\n      },\n      default: undefined\n    },\n    gridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#000000'\n    },\n    gridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.08\n    },\n\n    // filter null\n    filterNull: {\n      type: 'object',\n      properties: {\n        O: {type:'boolean', default: false},\n        Q: {type:'boolean', default: true},\n        T: {type:'boolean', default: true}\n      }\n    },\n    toggleSort: {\n      type: 'string',\n      default: O\n    },\n    autoSortLine: {\n      type: 'boolean',\n      default: true\n    },\n\n    // single plot\n    singleHeight: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    singleWidth: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    // band size\n    largeBandSize: {\n      type: 'integer',\n      default: 21,\n      minimum: 0\n    },\n    smallBandSize: {\n      //small multiples or single plot with high cardinality\n      type: 'integer',\n      default: 12,\n      minimum: 0\n    },\n    largeBandMaxCardinality: {\n      type: 'integer',\n      default: 10\n    },\n    // small multiples\n    cellPadding: {\n      type: 'number',\n      default: 0.1\n    },\n    cellGridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#000000'\n    },\n    cellGridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.15\n    },\n    cellBackgroundColor: {\n      type: 'string',\n      role: 'color',\n      default: 'rgba(0,0,0,0)'\n    },\n    textCellWidth: {\n      type: 'integer',\n      default: 90,\n      minimum: 0\n    },\n\n    // marks\n    strokeWidth: {\n      type: 'integer',\n      default: 2,\n      minimum: 0\n    },\n    singleBarOffset: {\n      type: 'integer',\n      default: 5,\n      minimum: 0\n    },\n    // scales\n    timeScaleLabelLength: {\n      type: 'integer',\n      default: 3,\n      minimum: 0,\n      description: 'Max length for values in dayScaleLabel and monthScaleLabel.  Zero means using full names in dayScaleLabel/monthScaleLabel.'\n    },\n    dayScaleLabel: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      default: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n      description: 'Axis labels for day of week, starting from Sunday.' +\n        '(Consistent with Javascript -- See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getDay.'\n    },\n    monthScaleLabel: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      default: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n      description: 'Axis labels for month.'\n    },\n    // other\n    characterWidth: {\n      type: 'integer',\n      default: 6\n    },\n    maxSmallNumber: {\n      type: 'number',\n      default: 10000,\n      description: 'maximum number that a field will be considered smallNumber.'+\n                   'Used for axis labelling.'\n    },\n    smallNumberFormat: {\n      type: 'string',\n      default: '',\n      description: 'D3 Number format for axis labels and text tables '+\n                   'for number <= maxSmallNumber. Used for axis labelling.'\n    },\n    largeNumberFormat: {\n      type: 'string',\n      default: '.3s',\n      description: 'D3 Number format for axis labels and text tables ' +\n                   'for number > maxSmallNumber.'\n    },\n    timeFormat: {\n      type: 'string',\n      default: '%Y-%m-%d',\n      description: 'Date format for axis labels.'\n    },\n    useRawDomain: {\n      type: 'boolean',\n      default: false,\n      description: 'Use the raw data range as scale domain instead of ' +\n                   'aggregated data for aggregate axis. ' +\n                   'This option does not work with sum or count aggregate' +\n                   'as they might have a substantially larger scale range.' +\n                   'By default, use value from config.useRawDomain.'\n    }\n  }\n};\n\n/** @type Object Schema of a vega-lite specification */\nschema.schema = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  description: 'Schema for Vega-lite specification',\n  type: 'object',\n  required: ['marktype', 'encoding', 'data'],\n  properties: {\n    data: data,\n    marktype: schema.marktype,\n    encoding: {\n      type: 'object',\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        shape: shape,\n        text: text,\n        detail: detail\n      }\n    },\n    filter: filter,\n    config: config\n  }\n};\n\nschema.encTypes = util.keys(schema.schema.properties.encoding.properties);\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function() {\n  return schema.util.instantiate(schema.schema);\n};\n\n},{\"../globals\":33,\"../util\":37,\"./schemautil\":36,\"colorbrewer\":3}],36:[function(require,module,exports){\n'use strict';\n\nvar schemautil = module.exports = {},\n  util = require('../util');\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\nschemautil.extend = function(instance, schema) {\n  return schemautil.merge(schemautil.instantiate(schema), instance);\n};\n\n// instantiate a schema\nschemautil.instantiate = function(schema) {\n  var val;\n  if (schema === undefined) {\n    return undefined;\n  } else if ('default' in schema) {\n    val = schema.default;\n    return util.isObject(val) ? util.duplicate(val) : val;\n  } else if (schema.type === 'object') {\n    var instance = {};\n    for (var name in schema.properties) {\n      val = schemautil.instantiate(schema.properties[name]);\n      if (val !== undefined) {\n        instance[name] = val;\n      }\n    }\n    return instance;\n  } else if (schema.type === 'array') {\n    return [];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nschemautil.subtract = function(instance, defaults) {\n  var changes = {};\n  for (var prop in instance) {\n    var def = defaults[prop];\n    var ins = instance[prop];\n    // Note: does not properly subtract arrays\n    if (!defaults || def !== ins) {\n      if (typeof ins === 'object' && !util.isArray(ins) && def) {\n        var c = schemautil.subtract(ins, def);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else if (!util.isArray(ins) || ins.length > 0) {\n        changes[prop] = ins;\n      }\n    }\n  }\n  return changes;\n};\n\nschemautil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction merge(dest, src) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (var p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      merge(dest[p], src[p]);\n    }\n  }\n  return dest;\n}\n},{\"../util\":37}],37:[function(require,module,exports){\n'use strict';\n\nvar util = module.exports = require('datalib/src/util');\n\nutil.extend(util, require('datalib/src/generate'));\nutil.extend(util, require('datalib/src/stats'));\nutil.extend(util, require('./logger')('[VL Error]'));\nutil.bin = require('datalib/src/bins/bins');\n\nutil.isin = function(item, array) {\n  return array.indexOf(item) !== -1;\n};\n\nutil.forEach = function(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  } else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k , obj);\n    }\n  }\n};\n\nutil.reduce = function(obj, f, init, thisArg) {\n  if (obj.reduce) {\n    return obj.reduce.call(thisArg, f, init);\n  } else {\n    for (var k in obj) {\n      init = f.call(thisArg, init, obj[k], k, obj);\n    }\n    return init;\n  }\n};\n\nutil.map = function(obj, f, thisArg) {\n  if (obj.map) {\n    return obj.map.call(thisArg, f);\n  } else {\n    var output = [];\n    for (var k in obj) {\n      output.push( f.call(thisArg, obj[k], k, obj));\n    }\n  }\n};\n\nutil.any = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (f(arr[k], k, i++)) return true;\n  }\n  return false;\n};\n\nutil.all = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (!f(arr[k], k, i++)) return false;\n  }\n  return true;\n};\n\nutil.getbins = function(stats, maxbins) {\n  return util.bin({\n    min: stats.min,\n    max: stats.max,\n    maxbins: maxbins\n  });\n};\n\n/**\n * x[p[0]]...[p[n]] = val\n * @param noaugment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.setter = function(x, p, val, noaugment) {\n  for (var i=0; i<p.length-1; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  x[p[i]] = val;\n};\n\n\n/**\n * returns x[p[0]]...[p[n]]\n * @param augment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.getter = function(x, p, noaugment) {\n  for (var i=0; i<p.length; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  return x;\n};\n\n\n},{\"./logger\":34,\"datalib/src/bins/bins\":8,\"datalib/src/generate\":9,\"datalib/src/stats\":11,\"datalib/src/util\":13}],38:[function(require,module,exports){\n'use strict';\n\nrequire('./globals');\n\nvar util = require('./util'),\n    consts = require('./consts');\n\nvar vl = {};\n\nutil.extend(vl, consts, util);\n\nvl.Encoding = require('./Encoding');\nvl.compiler = require('./compiler/compiler');\nvl.compile = vl.compiler.compile;\nvl.data = require('./data');\nvl.enc = require('./enc');\nvl.field = require('./field');\nvl.schema = require('./schema/schema');\nvl.toShorthand = vl.Encoding.shorthand;\nvl.format = require('d3-format').format;\n\nmodule.exports = vl;\n},{\"./Encoding\":14,\"./compiler/compiler\":16,\"./consts\":29,\"./data\":30,\"./enc\":31,\"./field\":32,\"./globals\":33,\"./schema/schema\":35,\"./util\":37,\"d3-format\":5}]},{},[38])(38)\n});\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yYnJld2VyL2NvbG9yYnJld2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yYnJld2VyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2QzLWNvbG9yL2J1aWxkL2NvbG9yLmpzIiwibm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9idWlsZC9mb3JtYXQuanMiLCJub2RlX21vZHVsZXMvZDMtdGltZS1mb3JtYXQvYnVpbGQvdGltZUZvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL25vZGVfbW9kdWxlcy9kMy10aW1lL2J1aWxkL3RpbWUuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvYmlucy9iaW5zLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2dlbmVyYXRlLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC90eXBlLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL3N0YXRzLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL3RpbWUuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvdXRpbC5qcyIsInNyYy9FbmNvZGluZy5qcyIsInNyYy9jb21waWxlci9heGlzLmpzIiwic3JjL2NvbXBpbGVyL2NvbXBpbGVyLmpzIiwic3JjL2NvbXBpbGVyL2RhdGEuanMiLCJzcmMvY29tcGlsZXIvZmFjZXQuanMiLCJzcmMvY29tcGlsZXIvZ3JvdXAuanMiLCJzcmMvY29tcGlsZXIvbGF5b3V0LmpzIiwic3JjL2NvbXBpbGVyL2xlZ2VuZC5qcyIsInNyYy9jb21waWxlci9tYXJrcy5qcyIsInNyYy9jb21waWxlci9zY2FsZS5qcyIsInNyYy9jb21waWxlci9zb3J0LmpzIiwic3JjL2NvbXBpbGVyL3N0YWNrLmpzIiwic3JjL2NvbXBpbGVyL3N0eWxlLmpzIiwic3JjL2NvbXBpbGVyL3N1YmZhY2V0LmpzIiwic3JjL2NvbXBpbGVyL3RpbWUuanMiLCJzcmMvY29uc3RzLmpzIiwic3JjL2RhdGEuanMiLCJzcmMvZW5jLmpzIiwic3JjL2ZpZWxkLmpzIiwic3JjL2dsb2JhbHMuanMiLCJzcmMvbG9nZ2VyLmpzIiwic3JjL3NjaGVtYS9zY2hlbWEuanMiLCJzcmMvc2NoZW1hL3NjaGVtYXV0aWwuanMiLCJzcmMvdXRpbC5qcyIsInNyYy92bCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNUQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMTRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIixudWxsLCIvLyBUaGlzIHByb2R1Y3QgaW5jbHVkZXMgY29sb3Igc3BlY2lmaWNhdGlvbnMgYW5kIGRlc2lnbnMgZGV2ZWxvcGVkIGJ5IEN5bnRoaWEgQnJld2VyIChodHRwOi8vY29sb3JicmV3ZXIub3JnLykuXG4vLyBKYXZhU2NyaXB0IHNwZWNzIGFzIHBhY2thZ2VkIGluIHRoZSBEMyBsaWJyYXJ5IChkM2pzLm9yZykuIFBsZWFzZSBzZWUgbGljZW5zZSBhdCBodHRwOi8vY29sb3JicmV3ZXIub3JnL2V4cG9ydC9MSUNFTlNFLnR4dFxuIWZ1bmN0aW9uKCkge1xuXG52YXIgY29sb3JicmV3ZXIgPSB7WWxHbjoge1xuMzogW1wiI2Y3ZmNiOVwiLFwiI2FkZGQ4ZVwiLFwiIzMxYTM1NFwiXSxcbjQ6IFtcIiNmZmZmY2NcIixcIiNjMmU2OTlcIixcIiM3OGM2NzlcIixcIiMyMzg0NDNcIl0sXG41OiBbXCIjZmZmZmNjXCIsXCIjYzJlNjk5XCIsXCIjNzhjNjc5XCIsXCIjMzFhMzU0XCIsXCIjMDA2ODM3XCJdLFxuNjogW1wiI2ZmZmZjY1wiLFwiI2Q5ZjBhM1wiLFwiI2FkZGQ4ZVwiLFwiIzc4YzY3OVwiLFwiIzMxYTM1NFwiLFwiIzAwNjgzN1wiXSxcbjc6IFtcIiNmZmZmY2NcIixcIiNkOWYwYTNcIixcIiNhZGRkOGVcIixcIiM3OGM2NzlcIixcIiM0MWFiNWRcIixcIiMyMzg0NDNcIixcIiMwMDVhMzJcIl0sXG44OiBbXCIjZmZmZmU1XCIsXCIjZjdmY2I5XCIsXCIjZDlmMGEzXCIsXCIjYWRkZDhlXCIsXCIjNzhjNjc5XCIsXCIjNDFhYjVkXCIsXCIjMjM4NDQzXCIsXCIjMDA1YTMyXCJdLFxuOTogW1wiI2ZmZmZlNVwiLFwiI2Y3ZmNiOVwiLFwiI2Q5ZjBhM1wiLFwiI2FkZGQ4ZVwiLFwiIzc4YzY3OVwiLFwiIzQxYWI1ZFwiLFwiIzIzODQ0M1wiLFwiIzAwNjgzN1wiLFwiIzAwNDUyOVwiXVxufSxZbEduQnU6IHtcbjM6IFtcIiNlZGY4YjFcIixcIiM3ZmNkYmJcIixcIiMyYzdmYjhcIl0sXG40OiBbXCIjZmZmZmNjXCIsXCIjYTFkYWI0XCIsXCIjNDFiNmM0XCIsXCIjMjI1ZWE4XCJdLFxuNTogW1wiI2ZmZmZjY1wiLFwiI2ExZGFiNFwiLFwiIzQxYjZjNFwiLFwiIzJjN2ZiOFwiLFwiIzI1MzQ5NFwiXSxcbjY6IFtcIiNmZmZmY2NcIixcIiNjN2U5YjRcIixcIiM3ZmNkYmJcIixcIiM0MWI2YzRcIixcIiMyYzdmYjhcIixcIiMyNTM0OTRcIl0sXG43OiBbXCIjZmZmZmNjXCIsXCIjYzdlOWI0XCIsXCIjN2ZjZGJiXCIsXCIjNDFiNmM0XCIsXCIjMWQ5MWMwXCIsXCIjMjI1ZWE4XCIsXCIjMGMyYzg0XCJdLFxuODogW1wiI2ZmZmZkOVwiLFwiI2VkZjhiMVwiLFwiI2M3ZTliNFwiLFwiIzdmY2RiYlwiLFwiIzQxYjZjNFwiLFwiIzFkOTFjMFwiLFwiIzIyNWVhOFwiLFwiIzBjMmM4NFwiXSxcbjk6IFtcIiNmZmZmZDlcIixcIiNlZGY4YjFcIixcIiNjN2U5YjRcIixcIiM3ZmNkYmJcIixcIiM0MWI2YzRcIixcIiMxZDkxYzBcIixcIiMyMjVlYThcIixcIiMyNTM0OTRcIixcIiMwODFkNThcIl1cbn0sR25CdToge1xuMzogW1wiI2UwZjNkYlwiLFwiI2E4ZGRiNVwiLFwiIzQzYTJjYVwiXSxcbjQ6IFtcIiNmMGY5ZThcIixcIiNiYWU0YmNcIixcIiM3YmNjYzRcIixcIiMyYjhjYmVcIl0sXG41OiBbXCIjZjBmOWU4XCIsXCIjYmFlNGJjXCIsXCIjN2JjY2M0XCIsXCIjNDNhMmNhXCIsXCIjMDg2OGFjXCJdLFxuNjogW1wiI2YwZjllOFwiLFwiI2NjZWJjNVwiLFwiI2E4ZGRiNVwiLFwiIzdiY2NjNFwiLFwiIzQzYTJjYVwiLFwiIzA4NjhhY1wiXSxcbjc6IFtcIiNmMGY5ZThcIixcIiNjY2ViYzVcIixcIiNhOGRkYjVcIixcIiM3YmNjYzRcIixcIiM0ZWIzZDNcIixcIiMyYjhjYmVcIixcIiMwODU4OWVcIl0sXG44OiBbXCIjZjdmY2YwXCIsXCIjZTBmM2RiXCIsXCIjY2NlYmM1XCIsXCIjYThkZGI1XCIsXCIjN2JjY2M0XCIsXCIjNGViM2QzXCIsXCIjMmI4Y2JlXCIsXCIjMDg1ODllXCJdLFxuOTogW1wiI2Y3ZmNmMFwiLFwiI2UwZjNkYlwiLFwiI2NjZWJjNVwiLFwiI2E4ZGRiNVwiLFwiIzdiY2NjNFwiLFwiIzRlYjNkM1wiLFwiIzJiOGNiZVwiLFwiIzA4NjhhY1wiLFwiIzA4NDA4MVwiXVxufSxCdUduOiB7XG4zOiBbXCIjZTVmNWY5XCIsXCIjOTlkOGM5XCIsXCIjMmNhMjVmXCJdLFxuNDogW1wiI2VkZjhmYlwiLFwiI2IyZTJlMlwiLFwiIzY2YzJhNFwiLFwiIzIzOGI0NVwiXSxcbjU6IFtcIiNlZGY4ZmJcIixcIiNiMmUyZTJcIixcIiM2NmMyYTRcIixcIiMyY2EyNWZcIixcIiMwMDZkMmNcIl0sXG42OiBbXCIjZWRmOGZiXCIsXCIjY2NlY2U2XCIsXCIjOTlkOGM5XCIsXCIjNjZjMmE0XCIsXCIjMmNhMjVmXCIsXCIjMDA2ZDJjXCJdLFxuNzogW1wiI2VkZjhmYlwiLFwiI2NjZWNlNlwiLFwiIzk5ZDhjOVwiLFwiIzY2YzJhNFwiLFwiIzQxYWU3NlwiLFwiIzIzOGI0NVwiLFwiIzAwNTgyNFwiXSxcbjg6IFtcIiNmN2ZjZmRcIixcIiNlNWY1ZjlcIixcIiNjY2VjZTZcIixcIiM5OWQ4YzlcIixcIiM2NmMyYTRcIixcIiM0MWFlNzZcIixcIiMyMzhiNDVcIixcIiMwMDU4MjRcIl0sXG45OiBbXCIjZjdmY2ZkXCIsXCIjZTVmNWY5XCIsXCIjY2NlY2U2XCIsXCIjOTlkOGM5XCIsXCIjNjZjMmE0XCIsXCIjNDFhZTc2XCIsXCIjMjM4YjQ1XCIsXCIjMDA2ZDJjXCIsXCIjMDA0NDFiXCJdXG59LFB1QnVHbjoge1xuMzogW1wiI2VjZTJmMFwiLFwiI2E2YmRkYlwiLFwiIzFjOTA5OVwiXSxcbjQ6IFtcIiNmNmVmZjdcIixcIiNiZGM5ZTFcIixcIiM2N2E5Y2ZcIixcIiMwMjgxOGFcIl0sXG41OiBbXCIjZjZlZmY3XCIsXCIjYmRjOWUxXCIsXCIjNjdhOWNmXCIsXCIjMWM5MDk5XCIsXCIjMDE2YzU5XCJdLFxuNjogW1wiI2Y2ZWZmN1wiLFwiI2QwZDFlNlwiLFwiI2E2YmRkYlwiLFwiIzY3YTljZlwiLFwiIzFjOTA5OVwiLFwiIzAxNmM1OVwiXSxcbjc6IFtcIiNmNmVmZjdcIixcIiNkMGQxZTZcIixcIiNhNmJkZGJcIixcIiM2N2E5Y2ZcIixcIiMzNjkwYzBcIixcIiMwMjgxOGFcIixcIiMwMTY0NTBcIl0sXG44OiBbXCIjZmZmN2ZiXCIsXCIjZWNlMmYwXCIsXCIjZDBkMWU2XCIsXCIjYTZiZGRiXCIsXCIjNjdhOWNmXCIsXCIjMzY5MGMwXCIsXCIjMDI4MThhXCIsXCIjMDE2NDUwXCJdLFxuOTogW1wiI2ZmZjdmYlwiLFwiI2VjZTJmMFwiLFwiI2QwZDFlNlwiLFwiI2E2YmRkYlwiLFwiIzY3YTljZlwiLFwiIzM2OTBjMFwiLFwiIzAyODE4YVwiLFwiIzAxNmM1OVwiLFwiIzAxNDYzNlwiXVxufSxQdUJ1OiB7XG4zOiBbXCIjZWNlN2YyXCIsXCIjYTZiZGRiXCIsXCIjMmI4Y2JlXCJdLFxuNDogW1wiI2YxZWVmNlwiLFwiI2JkYzllMVwiLFwiIzc0YTljZlwiLFwiIzA1NzBiMFwiXSxcbjU6IFtcIiNmMWVlZjZcIixcIiNiZGM5ZTFcIixcIiM3NGE5Y2ZcIixcIiMyYjhjYmVcIixcIiMwNDVhOGRcIl0sXG42OiBbXCIjZjFlZWY2XCIsXCIjZDBkMWU2XCIsXCIjYTZiZGRiXCIsXCIjNzRhOWNmXCIsXCIjMmI4Y2JlXCIsXCIjMDQ1YThkXCJdLFxuNzogW1wiI2YxZWVmNlwiLFwiI2QwZDFlNlwiLFwiI2E2YmRkYlwiLFwiIzc0YTljZlwiLFwiIzM2OTBjMFwiLFwiIzA1NzBiMFwiLFwiIzAzNGU3YlwiXSxcbjg6IFtcIiNmZmY3ZmJcIixcIiNlY2U3ZjJcIixcIiNkMGQxZTZcIixcIiNhNmJkZGJcIixcIiM3NGE5Y2ZcIixcIiMzNjkwYzBcIixcIiMwNTcwYjBcIixcIiMwMzRlN2JcIl0sXG45OiBbXCIjZmZmN2ZiXCIsXCIjZWNlN2YyXCIsXCIjZDBkMWU2XCIsXCIjYTZiZGRiXCIsXCIjNzRhOWNmXCIsXCIjMzY5MGMwXCIsXCIjMDU3MGIwXCIsXCIjMDQ1YThkXCIsXCIjMDIzODU4XCJdXG59LEJ1UHU6IHtcbjM6IFtcIiNlMGVjZjRcIixcIiM5ZWJjZGFcIixcIiM4ODU2YTdcIl0sXG40OiBbXCIjZWRmOGZiXCIsXCIjYjNjZGUzXCIsXCIjOGM5NmM2XCIsXCIjODg0MTlkXCJdLFxuNTogW1wiI2VkZjhmYlwiLFwiI2IzY2RlM1wiLFwiIzhjOTZjNlwiLFwiIzg4NTZhN1wiLFwiIzgxMGY3Y1wiXSxcbjY6IFtcIiNlZGY4ZmJcIixcIiNiZmQzZTZcIixcIiM5ZWJjZGFcIixcIiM4Yzk2YzZcIixcIiM4ODU2YTdcIixcIiM4MTBmN2NcIl0sXG43OiBbXCIjZWRmOGZiXCIsXCIjYmZkM2U2XCIsXCIjOWViY2RhXCIsXCIjOGM5NmM2XCIsXCIjOGM2YmIxXCIsXCIjODg0MTlkXCIsXCIjNmUwMTZiXCJdLFxuODogW1wiI2Y3ZmNmZFwiLFwiI2UwZWNmNFwiLFwiI2JmZDNlNlwiLFwiIzllYmNkYVwiLFwiIzhjOTZjNlwiLFwiIzhjNmJiMVwiLFwiIzg4NDE5ZFwiLFwiIzZlMDE2YlwiXSxcbjk6IFtcIiNmN2ZjZmRcIixcIiNlMGVjZjRcIixcIiNiZmQzZTZcIixcIiM5ZWJjZGFcIixcIiM4Yzk2YzZcIixcIiM4YzZiYjFcIixcIiM4ODQxOWRcIixcIiM4MTBmN2NcIixcIiM0ZDAwNGJcIl1cbn0sUmRQdToge1xuMzogW1wiI2ZkZTBkZFwiLFwiI2ZhOWZiNVwiLFwiI2M1MWI4YVwiXSxcbjQ6IFtcIiNmZWViZTJcIixcIiNmYmI0YjlcIixcIiNmNzY4YTFcIixcIiNhZTAxN2VcIl0sXG41OiBbXCIjZmVlYmUyXCIsXCIjZmJiNGI5XCIsXCIjZjc2OGExXCIsXCIjYzUxYjhhXCIsXCIjN2EwMTc3XCJdLFxuNjogW1wiI2ZlZWJlMlwiLFwiI2ZjYzVjMFwiLFwiI2ZhOWZiNVwiLFwiI2Y3NjhhMVwiLFwiI2M1MWI4YVwiLFwiIzdhMDE3N1wiXSxcbjc6IFtcIiNmZWViZTJcIixcIiNmY2M1YzBcIixcIiNmYTlmYjVcIixcIiNmNzY4YTFcIixcIiNkZDM0OTdcIixcIiNhZTAxN2VcIixcIiM3YTAxNzdcIl0sXG44OiBbXCIjZmZmN2YzXCIsXCIjZmRlMGRkXCIsXCIjZmNjNWMwXCIsXCIjZmE5ZmI1XCIsXCIjZjc2OGExXCIsXCIjZGQzNDk3XCIsXCIjYWUwMTdlXCIsXCIjN2EwMTc3XCJdLFxuOTogW1wiI2ZmZjdmM1wiLFwiI2ZkZTBkZFwiLFwiI2ZjYzVjMFwiLFwiI2ZhOWZiNVwiLFwiI2Y3NjhhMVwiLFwiI2RkMzQ5N1wiLFwiI2FlMDE3ZVwiLFwiIzdhMDE3N1wiLFwiIzQ5MDA2YVwiXVxufSxQdVJkOiB7XG4zOiBbXCIjZTdlMWVmXCIsXCIjYzk5NGM3XCIsXCIjZGQxYzc3XCJdLFxuNDogW1wiI2YxZWVmNlwiLFwiI2Q3YjVkOFwiLFwiI2RmNjViMFwiLFwiI2NlMTI1NlwiXSxcbjU6IFtcIiNmMWVlZjZcIixcIiNkN2I1ZDhcIixcIiNkZjY1YjBcIixcIiNkZDFjNzdcIixcIiM5ODAwNDNcIl0sXG42OiBbXCIjZjFlZWY2XCIsXCIjZDRiOWRhXCIsXCIjYzk5NGM3XCIsXCIjZGY2NWIwXCIsXCIjZGQxYzc3XCIsXCIjOTgwMDQzXCJdLFxuNzogW1wiI2YxZWVmNlwiLFwiI2Q0YjlkYVwiLFwiI2M5OTRjN1wiLFwiI2RmNjViMFwiLFwiI2U3Mjk4YVwiLFwiI2NlMTI1NlwiLFwiIzkxMDAzZlwiXSxcbjg6IFtcIiNmN2Y0ZjlcIixcIiNlN2UxZWZcIixcIiNkNGI5ZGFcIixcIiNjOTk0YzdcIixcIiNkZjY1YjBcIixcIiNlNzI5OGFcIixcIiNjZTEyNTZcIixcIiM5MTAwM2ZcIl0sXG45OiBbXCIjZjdmNGY5XCIsXCIjZTdlMWVmXCIsXCIjZDRiOWRhXCIsXCIjYzk5NGM3XCIsXCIjZGY2NWIwXCIsXCIjZTcyOThhXCIsXCIjY2UxMjU2XCIsXCIjOTgwMDQzXCIsXCIjNjcwMDFmXCJdXG59LE9yUmQ6IHtcbjM6IFtcIiNmZWU4YzhcIixcIiNmZGJiODRcIixcIiNlMzRhMzNcIl0sXG40OiBbXCIjZmVmMGQ5XCIsXCIjZmRjYzhhXCIsXCIjZmM4ZDU5XCIsXCIjZDczMDFmXCJdLFxuNTogW1wiI2ZlZjBkOVwiLFwiI2ZkY2M4YVwiLFwiI2ZjOGQ1OVwiLFwiI2UzNGEzM1wiLFwiI2IzMDAwMFwiXSxcbjY6IFtcIiNmZWYwZDlcIixcIiNmZGQ0OWVcIixcIiNmZGJiODRcIixcIiNmYzhkNTlcIixcIiNlMzRhMzNcIixcIiNiMzAwMDBcIl0sXG43OiBbXCIjZmVmMGQ5XCIsXCIjZmRkNDllXCIsXCIjZmRiYjg0XCIsXCIjZmM4ZDU5XCIsXCIjZWY2NTQ4XCIsXCIjZDczMDFmXCIsXCIjOTkwMDAwXCJdLFxuODogW1wiI2ZmZjdlY1wiLFwiI2ZlZThjOFwiLFwiI2ZkZDQ5ZVwiLFwiI2ZkYmI4NFwiLFwiI2ZjOGQ1OVwiLFwiI2VmNjU0OFwiLFwiI2Q3MzAxZlwiLFwiIzk5MDAwMFwiXSxcbjk6IFtcIiNmZmY3ZWNcIixcIiNmZWU4YzhcIixcIiNmZGQ0OWVcIixcIiNmZGJiODRcIixcIiNmYzhkNTlcIixcIiNlZjY1NDhcIixcIiNkNzMwMWZcIixcIiNiMzAwMDBcIixcIiM3ZjAwMDBcIl1cbn0sWWxPclJkOiB7XG4zOiBbXCIjZmZlZGEwXCIsXCIjZmViMjRjXCIsXCIjZjAzYjIwXCJdLFxuNDogW1wiI2ZmZmZiMlwiLFwiI2ZlY2M1Y1wiLFwiI2ZkOGQzY1wiLFwiI2UzMWExY1wiXSxcbjU6IFtcIiNmZmZmYjJcIixcIiNmZWNjNWNcIixcIiNmZDhkM2NcIixcIiNmMDNiMjBcIixcIiNiZDAwMjZcIl0sXG42OiBbXCIjZmZmZmIyXCIsXCIjZmVkOTc2XCIsXCIjZmViMjRjXCIsXCIjZmQ4ZDNjXCIsXCIjZjAzYjIwXCIsXCIjYmQwMDI2XCJdLFxuNzogW1wiI2ZmZmZiMlwiLFwiI2ZlZDk3NlwiLFwiI2ZlYjI0Y1wiLFwiI2ZkOGQzY1wiLFwiI2ZjNGUyYVwiLFwiI2UzMWExY1wiLFwiI2IxMDAyNlwiXSxcbjg6IFtcIiNmZmZmY2NcIixcIiNmZmVkYTBcIixcIiNmZWQ5NzZcIixcIiNmZWIyNGNcIixcIiNmZDhkM2NcIixcIiNmYzRlMmFcIixcIiNlMzFhMWNcIixcIiNiMTAwMjZcIl0sXG45OiBbXCIjZmZmZmNjXCIsXCIjZmZlZGEwXCIsXCIjZmVkOTc2XCIsXCIjZmViMjRjXCIsXCIjZmQ4ZDNjXCIsXCIjZmM0ZTJhXCIsXCIjZTMxYTFjXCIsXCIjYmQwMDI2XCIsXCIjODAwMDI2XCJdXG59LFlsT3JCcjoge1xuMzogW1wiI2ZmZjdiY1wiLFwiI2ZlYzQ0ZlwiLFwiI2Q5NWYwZVwiXSxcbjQ6IFtcIiNmZmZmZDRcIixcIiNmZWQ5OGVcIixcIiNmZTk5MjlcIixcIiNjYzRjMDJcIl0sXG41OiBbXCIjZmZmZmQ0XCIsXCIjZmVkOThlXCIsXCIjZmU5OTI5XCIsXCIjZDk1ZjBlXCIsXCIjOTkzNDA0XCJdLFxuNjogW1wiI2ZmZmZkNFwiLFwiI2ZlZTM5MVwiLFwiI2ZlYzQ0ZlwiLFwiI2ZlOTkyOVwiLFwiI2Q5NWYwZVwiLFwiIzk5MzQwNFwiXSxcbjc6IFtcIiNmZmZmZDRcIixcIiNmZWUzOTFcIixcIiNmZWM0NGZcIixcIiNmZTk5MjlcIixcIiNlYzcwMTRcIixcIiNjYzRjMDJcIixcIiM4YzJkMDRcIl0sXG44OiBbXCIjZmZmZmU1XCIsXCIjZmZmN2JjXCIsXCIjZmVlMzkxXCIsXCIjZmVjNDRmXCIsXCIjZmU5OTI5XCIsXCIjZWM3MDE0XCIsXCIjY2M0YzAyXCIsXCIjOGMyZDA0XCJdLFxuOTogW1wiI2ZmZmZlNVwiLFwiI2ZmZjdiY1wiLFwiI2ZlZTM5MVwiLFwiI2ZlYzQ0ZlwiLFwiI2ZlOTkyOVwiLFwiI2VjNzAxNFwiLFwiI2NjNGMwMlwiLFwiIzk5MzQwNFwiLFwiIzY2MjUwNlwiXVxufSxQdXJwbGVzOiB7XG4zOiBbXCIjZWZlZGY1XCIsXCIjYmNiZGRjXCIsXCIjNzU2YmIxXCJdLFxuNDogW1wiI2YyZjBmN1wiLFwiI2NiYzllMlwiLFwiIzllOWFjOFwiLFwiIzZhNTFhM1wiXSxcbjU6IFtcIiNmMmYwZjdcIixcIiNjYmM5ZTJcIixcIiM5ZTlhYzhcIixcIiM3NTZiYjFcIixcIiM1NDI3OGZcIl0sXG42OiBbXCIjZjJmMGY3XCIsXCIjZGFkYWViXCIsXCIjYmNiZGRjXCIsXCIjOWU5YWM4XCIsXCIjNzU2YmIxXCIsXCIjNTQyNzhmXCJdLFxuNzogW1wiI2YyZjBmN1wiLFwiI2RhZGFlYlwiLFwiI2JjYmRkY1wiLFwiIzllOWFjOFwiLFwiIzgwN2RiYVwiLFwiIzZhNTFhM1wiLFwiIzRhMTQ4NlwiXSxcbjg6IFtcIiNmY2ZiZmRcIixcIiNlZmVkZjVcIixcIiNkYWRhZWJcIixcIiNiY2JkZGNcIixcIiM5ZTlhYzhcIixcIiM4MDdkYmFcIixcIiM2YTUxYTNcIixcIiM0YTE0ODZcIl0sXG45OiBbXCIjZmNmYmZkXCIsXCIjZWZlZGY1XCIsXCIjZGFkYWViXCIsXCIjYmNiZGRjXCIsXCIjOWU5YWM4XCIsXCIjODA3ZGJhXCIsXCIjNmE1MWEzXCIsXCIjNTQyNzhmXCIsXCIjM2YwMDdkXCJdXG59LEJsdWVzOiB7XG4zOiBbXCIjZGVlYmY3XCIsXCIjOWVjYWUxXCIsXCIjMzE4MmJkXCJdLFxuNDogW1wiI2VmZjNmZlwiLFwiI2JkZDdlN1wiLFwiIzZiYWVkNlwiLFwiIzIxNzFiNVwiXSxcbjU6IFtcIiNlZmYzZmZcIixcIiNiZGQ3ZTdcIixcIiM2YmFlZDZcIixcIiMzMTgyYmRcIixcIiMwODUxOWNcIl0sXG42OiBbXCIjZWZmM2ZmXCIsXCIjYzZkYmVmXCIsXCIjOWVjYWUxXCIsXCIjNmJhZWQ2XCIsXCIjMzE4MmJkXCIsXCIjMDg1MTljXCJdLFxuNzogW1wiI2VmZjNmZlwiLFwiI2M2ZGJlZlwiLFwiIzllY2FlMVwiLFwiIzZiYWVkNlwiLFwiIzQyOTJjNlwiLFwiIzIxNzFiNVwiLFwiIzA4NDU5NFwiXSxcbjg6IFtcIiNmN2ZiZmZcIixcIiNkZWViZjdcIixcIiNjNmRiZWZcIixcIiM5ZWNhZTFcIixcIiM2YmFlZDZcIixcIiM0MjkyYzZcIixcIiMyMTcxYjVcIixcIiMwODQ1OTRcIl0sXG45OiBbXCIjZjdmYmZmXCIsXCIjZGVlYmY3XCIsXCIjYzZkYmVmXCIsXCIjOWVjYWUxXCIsXCIjNmJhZWQ2XCIsXCIjNDI5MmM2XCIsXCIjMjE3MWI1XCIsXCIjMDg1MTljXCIsXCIjMDgzMDZiXCJdXG59LEdyZWVuczoge1xuMzogW1wiI2U1ZjVlMFwiLFwiI2ExZDk5YlwiLFwiIzMxYTM1NFwiXSxcbjQ6IFtcIiNlZGY4ZTlcIixcIiNiYWU0YjNcIixcIiM3NGM0NzZcIixcIiMyMzhiNDVcIl0sXG41OiBbXCIjZWRmOGU5XCIsXCIjYmFlNGIzXCIsXCIjNzRjNDc2XCIsXCIjMzFhMzU0XCIsXCIjMDA2ZDJjXCJdLFxuNjogW1wiI2VkZjhlOVwiLFwiI2M3ZTljMFwiLFwiI2ExZDk5YlwiLFwiIzc0YzQ3NlwiLFwiIzMxYTM1NFwiLFwiIzAwNmQyY1wiXSxcbjc6IFtcIiNlZGY4ZTlcIixcIiNjN2U5YzBcIixcIiNhMWQ5OWJcIixcIiM3NGM0NzZcIixcIiM0MWFiNWRcIixcIiMyMzhiNDVcIixcIiMwMDVhMzJcIl0sXG44OiBbXCIjZjdmY2Y1XCIsXCIjZTVmNWUwXCIsXCIjYzdlOWMwXCIsXCIjYTFkOTliXCIsXCIjNzRjNDc2XCIsXCIjNDFhYjVkXCIsXCIjMjM4YjQ1XCIsXCIjMDA1YTMyXCJdLFxuOTogW1wiI2Y3ZmNmNVwiLFwiI2U1ZjVlMFwiLFwiI2M3ZTljMFwiLFwiI2ExZDk5YlwiLFwiIzc0YzQ3NlwiLFwiIzQxYWI1ZFwiLFwiIzIzOGI0NVwiLFwiIzAwNmQyY1wiLFwiIzAwNDQxYlwiXVxufSxPcmFuZ2VzOiB7XG4zOiBbXCIjZmVlNmNlXCIsXCIjZmRhZTZiXCIsXCIjZTY1NTBkXCJdLFxuNDogW1wiI2ZlZWRkZVwiLFwiI2ZkYmU4NVwiLFwiI2ZkOGQzY1wiLFwiI2Q5NDcwMVwiXSxcbjU6IFtcIiNmZWVkZGVcIixcIiNmZGJlODVcIixcIiNmZDhkM2NcIixcIiNlNjU1MGRcIixcIiNhNjM2MDNcIl0sXG42OiBbXCIjZmVlZGRlXCIsXCIjZmRkMGEyXCIsXCIjZmRhZTZiXCIsXCIjZmQ4ZDNjXCIsXCIjZTY1NTBkXCIsXCIjYTYzNjAzXCJdLFxuNzogW1wiI2ZlZWRkZVwiLFwiI2ZkZDBhMlwiLFwiI2ZkYWU2YlwiLFwiI2ZkOGQzY1wiLFwiI2YxNjkxM1wiLFwiI2Q5NDgwMVwiLFwiIzhjMmQwNFwiXSxcbjg6IFtcIiNmZmY1ZWJcIixcIiNmZWU2Y2VcIixcIiNmZGQwYTJcIixcIiNmZGFlNmJcIixcIiNmZDhkM2NcIixcIiNmMTY5MTNcIixcIiNkOTQ4MDFcIixcIiM4YzJkMDRcIl0sXG45OiBbXCIjZmZmNWViXCIsXCIjZmVlNmNlXCIsXCIjZmRkMGEyXCIsXCIjZmRhZTZiXCIsXCIjZmQ4ZDNjXCIsXCIjZjE2OTEzXCIsXCIjZDk0ODAxXCIsXCIjYTYzNjAzXCIsXCIjN2YyNzA0XCJdXG59LFJlZHM6IHtcbjM6IFtcIiNmZWUwZDJcIixcIiNmYzkyNzJcIixcIiNkZTJkMjZcIl0sXG40OiBbXCIjZmVlNWQ5XCIsXCIjZmNhZTkxXCIsXCIjZmI2YTRhXCIsXCIjY2IxODFkXCJdLFxuNTogW1wiI2ZlZTVkOVwiLFwiI2ZjYWU5MVwiLFwiI2ZiNmE0YVwiLFwiI2RlMmQyNlwiLFwiI2E1MGYxNVwiXSxcbjY6IFtcIiNmZWU1ZDlcIixcIiNmY2JiYTFcIixcIiNmYzkyNzJcIixcIiNmYjZhNGFcIixcIiNkZTJkMjZcIixcIiNhNTBmMTVcIl0sXG43OiBbXCIjZmVlNWQ5XCIsXCIjZmNiYmExXCIsXCIjZmM5MjcyXCIsXCIjZmI2YTRhXCIsXCIjZWYzYjJjXCIsXCIjY2IxODFkXCIsXCIjOTkwMDBkXCJdLFxuODogW1wiI2ZmZjVmMFwiLFwiI2ZlZTBkMlwiLFwiI2ZjYmJhMVwiLFwiI2ZjOTI3MlwiLFwiI2ZiNmE0YVwiLFwiI2VmM2IyY1wiLFwiI2NiMTgxZFwiLFwiIzk5MDAwZFwiXSxcbjk6IFtcIiNmZmY1ZjBcIixcIiNmZWUwZDJcIixcIiNmY2JiYTFcIixcIiNmYzkyNzJcIixcIiNmYjZhNGFcIixcIiNlZjNiMmNcIixcIiNjYjE4MWRcIixcIiNhNTBmMTVcIixcIiM2NzAwMGRcIl1cbn0sR3JleXM6IHtcbjM6IFtcIiNmMGYwZjBcIixcIiNiZGJkYmRcIixcIiM2MzYzNjNcIl0sXG40OiBbXCIjZjdmN2Y3XCIsXCIjY2NjY2NjXCIsXCIjOTY5Njk2XCIsXCIjNTI1MjUyXCJdLFxuNTogW1wiI2Y3ZjdmN1wiLFwiI2NjY2NjY1wiLFwiIzk2OTY5NlwiLFwiIzYzNjM2M1wiLFwiIzI1MjUyNVwiXSxcbjY6IFtcIiNmN2Y3ZjdcIixcIiNkOWQ5ZDlcIixcIiNiZGJkYmRcIixcIiM5Njk2OTZcIixcIiM2MzYzNjNcIixcIiMyNTI1MjVcIl0sXG43OiBbXCIjZjdmN2Y3XCIsXCIjZDlkOWQ5XCIsXCIjYmRiZGJkXCIsXCIjOTY5Njk2XCIsXCIjNzM3MzczXCIsXCIjNTI1MjUyXCIsXCIjMjUyNTI1XCJdLFxuODogW1wiI2ZmZmZmZlwiLFwiI2YwZjBmMFwiLFwiI2Q5ZDlkOVwiLFwiI2JkYmRiZFwiLFwiIzk2OTY5NlwiLFwiIzczNzM3M1wiLFwiIzUyNTI1MlwiLFwiIzI1MjUyNVwiXSxcbjk6IFtcIiNmZmZmZmZcIixcIiNmMGYwZjBcIixcIiNkOWQ5ZDlcIixcIiNiZGJkYmRcIixcIiM5Njk2OTZcIixcIiM3MzczNzNcIixcIiM1MjUyNTJcIixcIiMyNTI1MjVcIixcIiMwMDAwMDBcIl1cbn0sUHVPcjoge1xuMzogW1wiI2YxYTM0MFwiLFwiI2Y3ZjdmN1wiLFwiIzk5OGVjM1wiXSxcbjQ6IFtcIiNlNjYxMDFcIixcIiNmZGI4NjNcIixcIiNiMmFiZDJcIixcIiM1ZTNjOTlcIl0sXG41OiBbXCIjZTY2MTAxXCIsXCIjZmRiODYzXCIsXCIjZjdmN2Y3XCIsXCIjYjJhYmQyXCIsXCIjNWUzYzk5XCJdLFxuNjogW1wiI2IzNTgwNlwiLFwiI2YxYTM0MFwiLFwiI2ZlZTBiNlwiLFwiI2Q4ZGFlYlwiLFwiIzk5OGVjM1wiLFwiIzU0Mjc4OFwiXSxcbjc6IFtcIiNiMzU4MDZcIixcIiNmMWEzNDBcIixcIiNmZWUwYjZcIixcIiNmN2Y3ZjdcIixcIiNkOGRhZWJcIixcIiM5OThlYzNcIixcIiM1NDI3ODhcIl0sXG44OiBbXCIjYjM1ODA2XCIsXCIjZTA4MjE0XCIsXCIjZmRiODYzXCIsXCIjZmVlMGI2XCIsXCIjZDhkYWViXCIsXCIjYjJhYmQyXCIsXCIjODA3M2FjXCIsXCIjNTQyNzg4XCJdLFxuOTogW1wiI2IzNTgwNlwiLFwiI2UwODIxNFwiLFwiI2ZkYjg2M1wiLFwiI2ZlZTBiNlwiLFwiI2Y3ZjdmN1wiLFwiI2Q4ZGFlYlwiLFwiI2IyYWJkMlwiLFwiIzgwNzNhY1wiLFwiIzU0Mjc4OFwiXSxcbjEwOiBbXCIjN2YzYjA4XCIsXCIjYjM1ODA2XCIsXCIjZTA4MjE0XCIsXCIjZmRiODYzXCIsXCIjZmVlMGI2XCIsXCIjZDhkYWViXCIsXCIjYjJhYmQyXCIsXCIjODA3M2FjXCIsXCIjNTQyNzg4XCIsXCIjMmQwMDRiXCJdLFxuMTE6IFtcIiM3ZjNiMDhcIixcIiNiMzU4MDZcIixcIiNlMDgyMTRcIixcIiNmZGI4NjNcIixcIiNmZWUwYjZcIixcIiNmN2Y3ZjdcIixcIiNkOGRhZWJcIixcIiNiMmFiZDJcIixcIiM4MDczYWNcIixcIiM1NDI3ODhcIixcIiMyZDAwNGJcIl1cbn0sQnJCRzoge1xuMzogW1wiI2Q4YjM2NVwiLFwiI2Y1ZjVmNVwiLFwiIzVhYjRhY1wiXSxcbjQ6IFtcIiNhNjYxMWFcIixcIiNkZmMyN2RcIixcIiM4MGNkYzFcIixcIiMwMTg1NzFcIl0sXG41OiBbXCIjYTY2MTFhXCIsXCIjZGZjMjdkXCIsXCIjZjVmNWY1XCIsXCIjODBjZGMxXCIsXCIjMDE4NTcxXCJdLFxuNjogW1wiIzhjNTEwYVwiLFwiI2Q4YjM2NVwiLFwiI2Y2ZThjM1wiLFwiI2M3ZWFlNVwiLFwiIzVhYjRhY1wiLFwiIzAxNjY1ZVwiXSxcbjc6IFtcIiM4YzUxMGFcIixcIiNkOGIzNjVcIixcIiNmNmU4YzNcIixcIiNmNWY1ZjVcIixcIiNjN2VhZTVcIixcIiM1YWI0YWNcIixcIiMwMTY2NWVcIl0sXG44OiBbXCIjOGM1MTBhXCIsXCIjYmY4MTJkXCIsXCIjZGZjMjdkXCIsXCIjZjZlOGMzXCIsXCIjYzdlYWU1XCIsXCIjODBjZGMxXCIsXCIjMzU5NzhmXCIsXCIjMDE2NjVlXCJdLFxuOTogW1wiIzhjNTEwYVwiLFwiI2JmODEyZFwiLFwiI2RmYzI3ZFwiLFwiI2Y2ZThjM1wiLFwiI2Y1ZjVmNVwiLFwiI2M3ZWFlNVwiLFwiIzgwY2RjMVwiLFwiIzM1OTc4ZlwiLFwiIzAxNjY1ZVwiXSxcbjEwOiBbXCIjNTQzMDA1XCIsXCIjOGM1MTBhXCIsXCIjYmY4MTJkXCIsXCIjZGZjMjdkXCIsXCIjZjZlOGMzXCIsXCIjYzdlYWU1XCIsXCIjODBjZGMxXCIsXCIjMzU5NzhmXCIsXCIjMDE2NjVlXCIsXCIjMDAzYzMwXCJdLFxuMTE6IFtcIiM1NDMwMDVcIixcIiM4YzUxMGFcIixcIiNiZjgxMmRcIixcIiNkZmMyN2RcIixcIiNmNmU4YzNcIixcIiNmNWY1ZjVcIixcIiNjN2VhZTVcIixcIiM4MGNkYzFcIixcIiMzNTk3OGZcIixcIiMwMTY2NWVcIixcIiMwMDNjMzBcIl1cbn0sUFJHbjoge1xuMzogW1wiI2FmOGRjM1wiLFwiI2Y3ZjdmN1wiLFwiIzdmYmY3YlwiXSxcbjQ6IFtcIiM3YjMyOTRcIixcIiNjMmE1Y2ZcIixcIiNhNmRiYTBcIixcIiMwMDg4MzdcIl0sXG41OiBbXCIjN2IzMjk0XCIsXCIjYzJhNWNmXCIsXCIjZjdmN2Y3XCIsXCIjYTZkYmEwXCIsXCIjMDA4ODM3XCJdLFxuNjogW1wiIzc2MmE4M1wiLFwiI2FmOGRjM1wiLFwiI2U3ZDRlOFwiLFwiI2Q5ZjBkM1wiLFwiIzdmYmY3YlwiLFwiIzFiNzgzN1wiXSxcbjc6IFtcIiM3NjJhODNcIixcIiNhZjhkYzNcIixcIiNlN2Q0ZThcIixcIiNmN2Y3ZjdcIixcIiNkOWYwZDNcIixcIiM3ZmJmN2JcIixcIiMxYjc4MzdcIl0sXG44OiBbXCIjNzYyYTgzXCIsXCIjOTk3MGFiXCIsXCIjYzJhNWNmXCIsXCIjZTdkNGU4XCIsXCIjZDlmMGQzXCIsXCIjYTZkYmEwXCIsXCIjNWFhZTYxXCIsXCIjMWI3ODM3XCJdLFxuOTogW1wiIzc2MmE4M1wiLFwiIzk5NzBhYlwiLFwiI2MyYTVjZlwiLFwiI2U3ZDRlOFwiLFwiI2Y3ZjdmN1wiLFwiI2Q5ZjBkM1wiLFwiI2E2ZGJhMFwiLFwiIzVhYWU2MVwiLFwiIzFiNzgzN1wiXSxcbjEwOiBbXCIjNDAwMDRiXCIsXCIjNzYyYTgzXCIsXCIjOTk3MGFiXCIsXCIjYzJhNWNmXCIsXCIjZTdkNGU4XCIsXCIjZDlmMGQzXCIsXCIjYTZkYmEwXCIsXCIjNWFhZTYxXCIsXCIjMWI3ODM3XCIsXCIjMDA0NDFiXCJdLFxuMTE6IFtcIiM0MDAwNGJcIixcIiM3NjJhODNcIixcIiM5OTcwYWJcIixcIiNjMmE1Y2ZcIixcIiNlN2Q0ZThcIixcIiNmN2Y3ZjdcIixcIiNkOWYwZDNcIixcIiNhNmRiYTBcIixcIiM1YWFlNjFcIixcIiMxYjc4MzdcIixcIiMwMDQ0MWJcIl1cbn0sUGlZRzoge1xuMzogW1wiI2U5YTNjOVwiLFwiI2Y3ZjdmN1wiLFwiI2ExZDc2YVwiXSxcbjQ6IFtcIiNkMDFjOGJcIixcIiNmMWI2ZGFcIixcIiNiOGUxODZcIixcIiM0ZGFjMjZcIl0sXG41OiBbXCIjZDAxYzhiXCIsXCIjZjFiNmRhXCIsXCIjZjdmN2Y3XCIsXCIjYjhlMTg2XCIsXCIjNGRhYzI2XCJdLFxuNjogW1wiI2M1MWI3ZFwiLFwiI2U5YTNjOVwiLFwiI2ZkZTBlZlwiLFwiI2U2ZjVkMFwiLFwiI2ExZDc2YVwiLFwiIzRkOTIyMVwiXSxcbjc6IFtcIiNjNTFiN2RcIixcIiNlOWEzYzlcIixcIiNmZGUwZWZcIixcIiNmN2Y3ZjdcIixcIiNlNmY1ZDBcIixcIiNhMWQ3NmFcIixcIiM0ZDkyMjFcIl0sXG44OiBbXCIjYzUxYjdkXCIsXCIjZGU3N2FlXCIsXCIjZjFiNmRhXCIsXCIjZmRlMGVmXCIsXCIjZTZmNWQwXCIsXCIjYjhlMTg2XCIsXCIjN2ZiYzQxXCIsXCIjNGQ5MjIxXCJdLFxuOTogW1wiI2M1MWI3ZFwiLFwiI2RlNzdhZVwiLFwiI2YxYjZkYVwiLFwiI2ZkZTBlZlwiLFwiI2Y3ZjdmN1wiLFwiI2U2ZjVkMFwiLFwiI2I4ZTE4NlwiLFwiIzdmYmM0MVwiLFwiIzRkOTIyMVwiXSxcbjEwOiBbXCIjOGUwMTUyXCIsXCIjYzUxYjdkXCIsXCIjZGU3N2FlXCIsXCIjZjFiNmRhXCIsXCIjZmRlMGVmXCIsXCIjZTZmNWQwXCIsXCIjYjhlMTg2XCIsXCIjN2ZiYzQxXCIsXCIjNGQ5MjIxXCIsXCIjMjc2NDE5XCJdLFxuMTE6IFtcIiM4ZTAxNTJcIixcIiNjNTFiN2RcIixcIiNkZTc3YWVcIixcIiNmMWI2ZGFcIixcIiNmZGUwZWZcIixcIiNmN2Y3ZjdcIixcIiNlNmY1ZDBcIixcIiNiOGUxODZcIixcIiM3ZmJjNDFcIixcIiM0ZDkyMjFcIixcIiMyNzY0MTlcIl1cbn0sUmRCdToge1xuMzogW1wiI2VmOGE2MlwiLFwiI2Y3ZjdmN1wiLFwiIzY3YTljZlwiXSxcbjQ6IFtcIiNjYTAwMjBcIixcIiNmNGE1ODJcIixcIiM5MmM1ZGVcIixcIiMwNTcxYjBcIl0sXG41OiBbXCIjY2EwMDIwXCIsXCIjZjRhNTgyXCIsXCIjZjdmN2Y3XCIsXCIjOTJjNWRlXCIsXCIjMDU3MWIwXCJdLFxuNjogW1wiI2IyMTgyYlwiLFwiI2VmOGE2MlwiLFwiI2ZkZGJjN1wiLFwiI2QxZTVmMFwiLFwiIzY3YTljZlwiLFwiIzIxNjZhY1wiXSxcbjc6IFtcIiNiMjE4MmJcIixcIiNlZjhhNjJcIixcIiNmZGRiYzdcIixcIiNmN2Y3ZjdcIixcIiNkMWU1ZjBcIixcIiM2N2E5Y2ZcIixcIiMyMTY2YWNcIl0sXG44OiBbXCIjYjIxODJiXCIsXCIjZDY2MDRkXCIsXCIjZjRhNTgyXCIsXCIjZmRkYmM3XCIsXCIjZDFlNWYwXCIsXCIjOTJjNWRlXCIsXCIjNDM5M2MzXCIsXCIjMjE2NmFjXCJdLFxuOTogW1wiI2IyMTgyYlwiLFwiI2Q2NjA0ZFwiLFwiI2Y0YTU4MlwiLFwiI2ZkZGJjN1wiLFwiI2Y3ZjdmN1wiLFwiI2QxZTVmMFwiLFwiIzkyYzVkZVwiLFwiIzQzOTNjM1wiLFwiIzIxNjZhY1wiXSxcbjEwOiBbXCIjNjcwMDFmXCIsXCIjYjIxODJiXCIsXCIjZDY2MDRkXCIsXCIjZjRhNTgyXCIsXCIjZmRkYmM3XCIsXCIjZDFlNWYwXCIsXCIjOTJjNWRlXCIsXCIjNDM5M2MzXCIsXCIjMjE2NmFjXCIsXCIjMDUzMDYxXCJdLFxuMTE6IFtcIiM2NzAwMWZcIixcIiNiMjE4MmJcIixcIiNkNjYwNGRcIixcIiNmNGE1ODJcIixcIiNmZGRiYzdcIixcIiNmN2Y3ZjdcIixcIiNkMWU1ZjBcIixcIiM5MmM1ZGVcIixcIiM0MzkzYzNcIixcIiMyMTY2YWNcIixcIiMwNTMwNjFcIl1cbn0sUmRHeToge1xuMzogW1wiI2VmOGE2MlwiLFwiI2ZmZmZmZlwiLFwiIzk5OTk5OVwiXSxcbjQ6IFtcIiNjYTAwMjBcIixcIiNmNGE1ODJcIixcIiNiYWJhYmFcIixcIiM0MDQwNDBcIl0sXG41OiBbXCIjY2EwMDIwXCIsXCIjZjRhNTgyXCIsXCIjZmZmZmZmXCIsXCIjYmFiYWJhXCIsXCIjNDA0MDQwXCJdLFxuNjogW1wiI2IyMTgyYlwiLFwiI2VmOGE2MlwiLFwiI2ZkZGJjN1wiLFwiI2UwZTBlMFwiLFwiIzk5OTk5OVwiLFwiIzRkNGQ0ZFwiXSxcbjc6IFtcIiNiMjE4MmJcIixcIiNlZjhhNjJcIixcIiNmZGRiYzdcIixcIiNmZmZmZmZcIixcIiNlMGUwZTBcIixcIiM5OTk5OTlcIixcIiM0ZDRkNGRcIl0sXG44OiBbXCIjYjIxODJiXCIsXCIjZDY2MDRkXCIsXCIjZjRhNTgyXCIsXCIjZmRkYmM3XCIsXCIjZTBlMGUwXCIsXCIjYmFiYWJhXCIsXCIjODc4Nzg3XCIsXCIjNGQ0ZDRkXCJdLFxuOTogW1wiI2IyMTgyYlwiLFwiI2Q2NjA0ZFwiLFwiI2Y0YTU4MlwiLFwiI2ZkZGJjN1wiLFwiI2ZmZmZmZlwiLFwiI2UwZTBlMFwiLFwiI2JhYmFiYVwiLFwiIzg3ODc4N1wiLFwiIzRkNGQ0ZFwiXSxcbjEwOiBbXCIjNjcwMDFmXCIsXCIjYjIxODJiXCIsXCIjZDY2MDRkXCIsXCIjZjRhNTgyXCIsXCIjZmRkYmM3XCIsXCIjZTBlMGUwXCIsXCIjYmFiYWJhXCIsXCIjODc4Nzg3XCIsXCIjNGQ0ZDRkXCIsXCIjMWExYTFhXCJdLFxuMTE6IFtcIiM2NzAwMWZcIixcIiNiMjE4MmJcIixcIiNkNjYwNGRcIixcIiNmNGE1ODJcIixcIiNmZGRiYzdcIixcIiNmZmZmZmZcIixcIiNlMGUwZTBcIixcIiNiYWJhYmFcIixcIiM4Nzg3ODdcIixcIiM0ZDRkNGRcIixcIiMxYTFhMWFcIl1cbn0sUmRZbEJ1OiB7XG4zOiBbXCIjZmM4ZDU5XCIsXCIjZmZmZmJmXCIsXCIjOTFiZmRiXCJdLFxuNDogW1wiI2Q3MTkxY1wiLFwiI2ZkYWU2MVwiLFwiI2FiZDllOVwiLFwiIzJjN2JiNlwiXSxcbjU6IFtcIiNkNzE5MWNcIixcIiNmZGFlNjFcIixcIiNmZmZmYmZcIixcIiNhYmQ5ZTlcIixcIiMyYzdiYjZcIl0sXG42OiBbXCIjZDczMDI3XCIsXCIjZmM4ZDU5XCIsXCIjZmVlMDkwXCIsXCIjZTBmM2Y4XCIsXCIjOTFiZmRiXCIsXCIjNDU3NWI0XCJdLFxuNzogW1wiI2Q3MzAyN1wiLFwiI2ZjOGQ1OVwiLFwiI2ZlZTA5MFwiLFwiI2ZmZmZiZlwiLFwiI2UwZjNmOFwiLFwiIzkxYmZkYlwiLFwiIzQ1NzViNFwiXSxcbjg6IFtcIiNkNzMwMjdcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOTBcIixcIiNlMGYzZjhcIixcIiNhYmQ5ZTlcIixcIiM3NGFkZDFcIixcIiM0NTc1YjRcIl0sXG45OiBbXCIjZDczMDI3XCIsXCIjZjQ2ZDQzXCIsXCIjZmRhZTYxXCIsXCIjZmVlMDkwXCIsXCIjZmZmZmJmXCIsXCIjZTBmM2Y4XCIsXCIjYWJkOWU5XCIsXCIjNzRhZGQxXCIsXCIjNDU3NWI0XCJdLFxuMTA6IFtcIiNhNTAwMjZcIixcIiNkNzMwMjdcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOTBcIixcIiNlMGYzZjhcIixcIiNhYmQ5ZTlcIixcIiM3NGFkZDFcIixcIiM0NTc1YjRcIixcIiMzMTM2OTVcIl0sXG4xMTogW1wiI2E1MDAyNlwiLFwiI2Q3MzAyN1wiLFwiI2Y0NmQ0M1wiLFwiI2ZkYWU2MVwiLFwiI2ZlZTA5MFwiLFwiI2ZmZmZiZlwiLFwiI2UwZjNmOFwiLFwiI2FiZDllOVwiLFwiIzc0YWRkMVwiLFwiIzQ1NzViNFwiLFwiIzMxMzY5NVwiXVxufSxTcGVjdHJhbDoge1xuMzogW1wiI2ZjOGQ1OVwiLFwiI2ZmZmZiZlwiLFwiIzk5ZDU5NFwiXSxcbjQ6IFtcIiNkNzE5MWNcIixcIiNmZGFlNjFcIixcIiNhYmRkYTRcIixcIiMyYjgzYmFcIl0sXG41OiBbXCIjZDcxOTFjXCIsXCIjZmRhZTYxXCIsXCIjZmZmZmJmXCIsXCIjYWJkZGE0XCIsXCIjMmI4M2JhXCJdLFxuNjogW1wiI2Q1M2U0ZlwiLFwiI2ZjOGQ1OVwiLFwiI2ZlZTA4YlwiLFwiI2U2ZjU5OFwiLFwiIzk5ZDU5NFwiLFwiIzMyODhiZFwiXSxcbjc6IFtcIiNkNTNlNGZcIixcIiNmYzhkNTlcIixcIiNmZWUwOGJcIixcIiNmZmZmYmZcIixcIiNlNmY1OThcIixcIiM5OWQ1OTRcIixcIiMzMjg4YmRcIl0sXG44OiBbXCIjZDUzZTRmXCIsXCIjZjQ2ZDQzXCIsXCIjZmRhZTYxXCIsXCIjZmVlMDhiXCIsXCIjZTZmNTk4XCIsXCIjYWJkZGE0XCIsXCIjNjZjMmE1XCIsXCIjMzI4OGJkXCJdLFxuOTogW1wiI2Q1M2U0ZlwiLFwiI2Y0NmQ0M1wiLFwiI2ZkYWU2MVwiLFwiI2ZlZTA4YlwiLFwiI2ZmZmZiZlwiLFwiI2U2ZjU5OFwiLFwiI2FiZGRhNFwiLFwiIzY2YzJhNVwiLFwiIzMyODhiZFwiXSxcbjEwOiBbXCIjOWUwMTQyXCIsXCIjZDUzZTRmXCIsXCIjZjQ2ZDQzXCIsXCIjZmRhZTYxXCIsXCIjZmVlMDhiXCIsXCIjZTZmNTk4XCIsXCIjYWJkZGE0XCIsXCIjNjZjMmE1XCIsXCIjMzI4OGJkXCIsXCIjNWU0ZmEyXCJdLFxuMTE6IFtcIiM5ZTAxNDJcIixcIiNkNTNlNGZcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOGJcIixcIiNmZmZmYmZcIixcIiNlNmY1OThcIixcIiNhYmRkYTRcIixcIiM2NmMyYTVcIixcIiMzMjg4YmRcIixcIiM1ZTRmYTJcIl1cbn0sUmRZbEduOiB7XG4zOiBbXCIjZmM4ZDU5XCIsXCIjZmZmZmJmXCIsXCIjOTFjZjYwXCJdLFxuNDogW1wiI2Q3MTkxY1wiLFwiI2ZkYWU2MVwiLFwiI2E2ZDk2YVwiLFwiIzFhOTY0MVwiXSxcbjU6IFtcIiNkNzE5MWNcIixcIiNmZGFlNjFcIixcIiNmZmZmYmZcIixcIiNhNmQ5NmFcIixcIiMxYTk2NDFcIl0sXG42OiBbXCIjZDczMDI3XCIsXCIjZmM4ZDU5XCIsXCIjZmVlMDhiXCIsXCIjZDllZjhiXCIsXCIjOTFjZjYwXCIsXCIjMWE5ODUwXCJdLFxuNzogW1wiI2Q3MzAyN1wiLFwiI2ZjOGQ1OVwiLFwiI2ZlZTA4YlwiLFwiI2ZmZmZiZlwiLFwiI2Q5ZWY4YlwiLFwiIzkxY2Y2MFwiLFwiIzFhOTg1MFwiXSxcbjg6IFtcIiNkNzMwMjdcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOGJcIixcIiNkOWVmOGJcIixcIiNhNmQ5NmFcIixcIiM2NmJkNjNcIixcIiMxYTk4NTBcIl0sXG45OiBbXCIjZDczMDI3XCIsXCIjZjQ2ZDQzXCIsXCIjZmRhZTYxXCIsXCIjZmVlMDhiXCIsXCIjZmZmZmJmXCIsXCIjZDllZjhiXCIsXCIjYTZkOTZhXCIsXCIjNjZiZDYzXCIsXCIjMWE5ODUwXCJdLFxuMTA6IFtcIiNhNTAwMjZcIixcIiNkNzMwMjdcIixcIiNmNDZkNDNcIixcIiNmZGFlNjFcIixcIiNmZWUwOGJcIixcIiNkOWVmOGJcIixcIiNhNmQ5NmFcIixcIiM2NmJkNjNcIixcIiMxYTk4NTBcIixcIiMwMDY4MzdcIl0sXG4xMTogW1wiI2E1MDAyNlwiLFwiI2Q3MzAyN1wiLFwiI2Y0NmQ0M1wiLFwiI2ZkYWU2MVwiLFwiI2ZlZTA4YlwiLFwiI2ZmZmZiZlwiLFwiI2Q5ZWY4YlwiLFwiI2E2ZDk2YVwiLFwiIzY2YmQ2M1wiLFwiIzFhOTg1MFwiLFwiIzAwNjgzN1wiXVxufSxBY2NlbnQ6IHtcbjM6IFtcIiM3ZmM5N2ZcIixcIiNiZWFlZDRcIixcIiNmZGMwODZcIl0sXG40OiBbXCIjN2ZjOTdmXCIsXCIjYmVhZWQ0XCIsXCIjZmRjMDg2XCIsXCIjZmZmZjk5XCJdLFxuNTogW1wiIzdmYzk3ZlwiLFwiI2JlYWVkNFwiLFwiI2ZkYzA4NlwiLFwiI2ZmZmY5OVwiLFwiIzM4NmNiMFwiXSxcbjY6IFtcIiM3ZmM5N2ZcIixcIiNiZWFlZDRcIixcIiNmZGMwODZcIixcIiNmZmZmOTlcIixcIiMzODZjYjBcIixcIiNmMDAyN2ZcIl0sXG43OiBbXCIjN2ZjOTdmXCIsXCIjYmVhZWQ0XCIsXCIjZmRjMDg2XCIsXCIjZmZmZjk5XCIsXCIjMzg2Y2IwXCIsXCIjZjAwMjdmXCIsXCIjYmY1YjE3XCJdLFxuODogW1wiIzdmYzk3ZlwiLFwiI2JlYWVkNFwiLFwiI2ZkYzA4NlwiLFwiI2ZmZmY5OVwiLFwiIzM4NmNiMFwiLFwiI2YwMDI3ZlwiLFwiI2JmNWIxN1wiLFwiIzY2NjY2NlwiXVxufSxEYXJrMjoge1xuMzogW1wiIzFiOWU3N1wiLFwiI2Q5NWYwMlwiLFwiIzc1NzBiM1wiXSxcbjQ6IFtcIiMxYjllNzdcIixcIiNkOTVmMDJcIixcIiM3NTcwYjNcIixcIiNlNzI5OGFcIl0sXG41OiBbXCIjMWI5ZTc3XCIsXCIjZDk1ZjAyXCIsXCIjNzU3MGIzXCIsXCIjZTcyOThhXCIsXCIjNjZhNjFlXCJdLFxuNjogW1wiIzFiOWU3N1wiLFwiI2Q5NWYwMlwiLFwiIzc1NzBiM1wiLFwiI2U3Mjk4YVwiLFwiIzY2YTYxZVwiLFwiI2U2YWIwMlwiXSxcbjc6IFtcIiMxYjllNzdcIixcIiNkOTVmMDJcIixcIiM3NTcwYjNcIixcIiNlNzI5OGFcIixcIiM2NmE2MWVcIixcIiNlNmFiMDJcIixcIiNhNjc2MWRcIl0sXG44OiBbXCIjMWI5ZTc3XCIsXCIjZDk1ZjAyXCIsXCIjNzU3MGIzXCIsXCIjZTcyOThhXCIsXCIjNjZhNjFlXCIsXCIjZTZhYjAyXCIsXCIjYTY3NjFkXCIsXCIjNjY2NjY2XCJdXG59LFBhaXJlZDoge1xuMzogW1wiI2E2Y2VlM1wiLFwiIzFmNzhiNFwiLFwiI2IyZGY4YVwiXSxcbjQ6IFtcIiNhNmNlZTNcIixcIiMxZjc4YjRcIixcIiNiMmRmOGFcIixcIiMzM2EwMmNcIl0sXG41OiBbXCIjYTZjZWUzXCIsXCIjMWY3OGI0XCIsXCIjYjJkZjhhXCIsXCIjMzNhMDJjXCIsXCIjZmI5YTk5XCJdLFxuNjogW1wiI2E2Y2VlM1wiLFwiIzFmNzhiNFwiLFwiI2IyZGY4YVwiLFwiIzMzYTAyY1wiLFwiI2ZiOWE5OVwiLFwiI2UzMWExY1wiXSxcbjc6IFtcIiNhNmNlZTNcIixcIiMxZjc4YjRcIixcIiNiMmRmOGFcIixcIiMzM2EwMmNcIixcIiNmYjlhOTlcIixcIiNlMzFhMWNcIixcIiNmZGJmNmZcIl0sXG44OiBbXCIjYTZjZWUzXCIsXCIjMWY3OGI0XCIsXCIjYjJkZjhhXCIsXCIjMzNhMDJjXCIsXCIjZmI5YTk5XCIsXCIjZTMxYTFjXCIsXCIjZmRiZjZmXCIsXCIjZmY3ZjAwXCJdLFxuOTogW1wiI2E2Y2VlM1wiLFwiIzFmNzhiNFwiLFwiI2IyZGY4YVwiLFwiIzMzYTAyY1wiLFwiI2ZiOWE5OVwiLFwiI2UzMWExY1wiLFwiI2ZkYmY2ZlwiLFwiI2ZmN2YwMFwiLFwiI2NhYjJkNlwiXSxcbjEwOiBbXCIjYTZjZWUzXCIsXCIjMWY3OGI0XCIsXCIjYjJkZjhhXCIsXCIjMzNhMDJjXCIsXCIjZmI5YTk5XCIsXCIjZTMxYTFjXCIsXCIjZmRiZjZmXCIsXCIjZmY3ZjAwXCIsXCIjY2FiMmQ2XCIsXCIjNmEzZDlhXCJdLFxuMTE6IFtcIiNhNmNlZTNcIixcIiMxZjc4YjRcIixcIiNiMmRmOGFcIixcIiMzM2EwMmNcIixcIiNmYjlhOTlcIixcIiNlMzFhMWNcIixcIiNmZGJmNmZcIixcIiNmZjdmMDBcIixcIiNjYWIyZDZcIixcIiM2YTNkOWFcIixcIiNmZmZmOTlcIl0sXG4xMjogW1wiI2E2Y2VlM1wiLFwiIzFmNzhiNFwiLFwiI2IyZGY4YVwiLFwiIzMzYTAyY1wiLFwiI2ZiOWE5OVwiLFwiI2UzMWExY1wiLFwiI2ZkYmY2ZlwiLFwiI2ZmN2YwMFwiLFwiI2NhYjJkNlwiLFwiIzZhM2Q5YVwiLFwiI2ZmZmY5OVwiLFwiI2IxNTkyOFwiXVxufSxQYXN0ZWwxOiB7XG4zOiBbXCIjZmJiNGFlXCIsXCIjYjNjZGUzXCIsXCIjY2NlYmM1XCJdLFxuNDogW1wiI2ZiYjRhZVwiLFwiI2IzY2RlM1wiLFwiI2NjZWJjNVwiLFwiI2RlY2JlNFwiXSxcbjU6IFtcIiNmYmI0YWVcIixcIiNiM2NkZTNcIixcIiNjY2ViYzVcIixcIiNkZWNiZTRcIixcIiNmZWQ5YTZcIl0sXG42OiBbXCIjZmJiNGFlXCIsXCIjYjNjZGUzXCIsXCIjY2NlYmM1XCIsXCIjZGVjYmU0XCIsXCIjZmVkOWE2XCIsXCIjZmZmZmNjXCJdLFxuNzogW1wiI2ZiYjRhZVwiLFwiI2IzY2RlM1wiLFwiI2NjZWJjNVwiLFwiI2RlY2JlNFwiLFwiI2ZlZDlhNlwiLFwiI2ZmZmZjY1wiLFwiI2U1ZDhiZFwiXSxcbjg6IFtcIiNmYmI0YWVcIixcIiNiM2NkZTNcIixcIiNjY2ViYzVcIixcIiNkZWNiZTRcIixcIiNmZWQ5YTZcIixcIiNmZmZmY2NcIixcIiNlNWQ4YmRcIixcIiNmZGRhZWNcIl0sXG45OiBbXCIjZmJiNGFlXCIsXCIjYjNjZGUzXCIsXCIjY2NlYmM1XCIsXCIjZGVjYmU0XCIsXCIjZmVkOWE2XCIsXCIjZmZmZmNjXCIsXCIjZTVkOGJkXCIsXCIjZmRkYWVjXCIsXCIjZjJmMmYyXCJdXG59LFBhc3RlbDI6IHtcbjM6IFtcIiNiM2UyY2RcIixcIiNmZGNkYWNcIixcIiNjYmQ1ZThcIl0sXG40OiBbXCIjYjNlMmNkXCIsXCIjZmRjZGFjXCIsXCIjY2JkNWU4XCIsXCIjZjRjYWU0XCJdLFxuNTogW1wiI2IzZTJjZFwiLFwiI2ZkY2RhY1wiLFwiI2NiZDVlOFwiLFwiI2Y0Y2FlNFwiLFwiI2U2ZjVjOVwiXSxcbjY6IFtcIiNiM2UyY2RcIixcIiNmZGNkYWNcIixcIiNjYmQ1ZThcIixcIiNmNGNhZTRcIixcIiNlNmY1YzlcIixcIiNmZmYyYWVcIl0sXG43OiBbXCIjYjNlMmNkXCIsXCIjZmRjZGFjXCIsXCIjY2JkNWU4XCIsXCIjZjRjYWU0XCIsXCIjZTZmNWM5XCIsXCIjZmZmMmFlXCIsXCIjZjFlMmNjXCJdLFxuODogW1wiI2IzZTJjZFwiLFwiI2ZkY2RhY1wiLFwiI2NiZDVlOFwiLFwiI2Y0Y2FlNFwiLFwiI2U2ZjVjOVwiLFwiI2ZmZjJhZVwiLFwiI2YxZTJjY1wiLFwiI2NjY2NjY1wiXVxufSxTZXQxOiB7XG4zOiBbXCIjZTQxYTFjXCIsXCIjMzc3ZWI4XCIsXCIjNGRhZjRhXCJdLFxuNDogW1wiI2U0MWExY1wiLFwiIzM3N2ViOFwiLFwiIzRkYWY0YVwiLFwiIzk4NGVhM1wiXSxcbjU6IFtcIiNlNDFhMWNcIixcIiMzNzdlYjhcIixcIiM0ZGFmNGFcIixcIiM5ODRlYTNcIixcIiNmZjdmMDBcIl0sXG42OiBbXCIjZTQxYTFjXCIsXCIjMzc3ZWI4XCIsXCIjNGRhZjRhXCIsXCIjOTg0ZWEzXCIsXCIjZmY3ZjAwXCIsXCIjZmZmZjMzXCJdLFxuNzogW1wiI2U0MWExY1wiLFwiIzM3N2ViOFwiLFwiIzRkYWY0YVwiLFwiIzk4NGVhM1wiLFwiI2ZmN2YwMFwiLFwiI2ZmZmYzM1wiLFwiI2E2NTYyOFwiXSxcbjg6IFtcIiNlNDFhMWNcIixcIiMzNzdlYjhcIixcIiM0ZGFmNGFcIixcIiM5ODRlYTNcIixcIiNmZjdmMDBcIixcIiNmZmZmMzNcIixcIiNhNjU2MjhcIixcIiNmNzgxYmZcIl0sXG45OiBbXCIjZTQxYTFjXCIsXCIjMzc3ZWI4XCIsXCIjNGRhZjRhXCIsXCIjOTg0ZWEzXCIsXCIjZmY3ZjAwXCIsXCIjZmZmZjMzXCIsXCIjYTY1NjI4XCIsXCIjZjc4MWJmXCIsXCIjOTk5OTk5XCJdXG59LFNldDI6IHtcbjM6IFtcIiM2NmMyYTVcIixcIiNmYzhkNjJcIixcIiM4ZGEwY2JcIl0sXG40OiBbXCIjNjZjMmE1XCIsXCIjZmM4ZDYyXCIsXCIjOGRhMGNiXCIsXCIjZTc4YWMzXCJdLFxuNTogW1wiIzY2YzJhNVwiLFwiI2ZjOGQ2MlwiLFwiIzhkYTBjYlwiLFwiI2U3OGFjM1wiLFwiI2E2ZDg1NFwiXSxcbjY6IFtcIiM2NmMyYTVcIixcIiNmYzhkNjJcIixcIiM4ZGEwY2JcIixcIiNlNzhhYzNcIixcIiNhNmQ4NTRcIixcIiNmZmQ5MmZcIl0sXG43OiBbXCIjNjZjMmE1XCIsXCIjZmM4ZDYyXCIsXCIjOGRhMGNiXCIsXCIjZTc4YWMzXCIsXCIjYTZkODU0XCIsXCIjZmZkOTJmXCIsXCIjZTVjNDk0XCJdLFxuODogW1wiIzY2YzJhNVwiLFwiI2ZjOGQ2MlwiLFwiIzhkYTBjYlwiLFwiI2U3OGFjM1wiLFwiI2E2ZDg1NFwiLFwiI2ZmZDkyZlwiLFwiI2U1YzQ5NFwiLFwiI2IzYjNiM1wiXVxufSxTZXQzOiB7XG4zOiBbXCIjOGRkM2M3XCIsXCIjZmZmZmIzXCIsXCIjYmViYWRhXCJdLFxuNDogW1wiIzhkZDNjN1wiLFwiI2ZmZmZiM1wiLFwiI2JlYmFkYVwiLFwiI2ZiODA3MlwiXSxcbjU6IFtcIiM4ZGQzYzdcIixcIiNmZmZmYjNcIixcIiNiZWJhZGFcIixcIiNmYjgwNzJcIixcIiM4MGIxZDNcIl0sXG42OiBbXCIjOGRkM2M3XCIsXCIjZmZmZmIzXCIsXCIjYmViYWRhXCIsXCIjZmI4MDcyXCIsXCIjODBiMWQzXCIsXCIjZmRiNDYyXCJdLFxuNzogW1wiIzhkZDNjN1wiLFwiI2ZmZmZiM1wiLFwiI2JlYmFkYVwiLFwiI2ZiODA3MlwiLFwiIzgwYjFkM1wiLFwiI2ZkYjQ2MlwiLFwiI2IzZGU2OVwiXSxcbjg6IFtcIiM4ZGQzYzdcIixcIiNmZmZmYjNcIixcIiNiZWJhZGFcIixcIiNmYjgwNzJcIixcIiM4MGIxZDNcIixcIiNmZGI0NjJcIixcIiNiM2RlNjlcIixcIiNmY2NkZTVcIl0sXG45OiBbXCIjOGRkM2M3XCIsXCIjZmZmZmIzXCIsXCIjYmViYWRhXCIsXCIjZmI4MDcyXCIsXCIjODBiMWQzXCIsXCIjZmRiNDYyXCIsXCIjYjNkZTY5XCIsXCIjZmNjZGU1XCIsXCIjZDlkOWQ5XCJdLFxuMTA6IFtcIiM4ZGQzYzdcIixcIiNmZmZmYjNcIixcIiNiZWJhZGFcIixcIiNmYjgwNzJcIixcIiM4MGIxZDNcIixcIiNmZGI0NjJcIixcIiNiM2RlNjlcIixcIiNmY2NkZTVcIixcIiNkOWQ5ZDlcIixcIiNiYzgwYmRcIl0sXG4xMTogW1wiIzhkZDNjN1wiLFwiI2ZmZmZiM1wiLFwiI2JlYmFkYVwiLFwiI2ZiODA3MlwiLFwiIzgwYjFkM1wiLFwiI2ZkYjQ2MlwiLFwiI2IzZGU2OVwiLFwiI2ZjY2RlNVwiLFwiI2Q5ZDlkOVwiLFwiI2JjODBiZFwiLFwiI2NjZWJjNVwiXSxcbjEyOiBbXCIjOGRkM2M3XCIsXCIjZmZmZmIzXCIsXCIjYmViYWRhXCIsXCIjZmI4MDcyXCIsXCIjODBiMWQzXCIsXCIjZmRiNDYyXCIsXCIjYjNkZTY5XCIsXCIjZmNjZGU1XCIsXCIjZDlkOWQ5XCIsXCIjYmM4MGJkXCIsXCIjY2NlYmM1XCIsXCIjZmZlZDZmXCJdXG59fTtcblxuaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGNvbG9yYnJld2VyKTtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gY29sb3JicmV3ZXI7XG59IGVsc2Uge1xuICAgIHRoaXMuY29sb3JicmV3ZXIgPSBjb2xvcmJyZXdlcjtcbn1cblxufSgpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbG9yYnJld2VyLmpzJyk7XG4iLCJpZiAodHlwZW9mIE1hcCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICBNYXAgPSBmdW5jdGlvbigpIHsgdGhpcy5jbGVhcigpOyB9O1xuICBNYXAucHJvdG90eXBlID0ge1xuICAgIHNldDogZnVuY3Rpb24oaywgdikgeyB0aGlzLl9ba10gPSB2OyByZXR1cm4gdGhpczsgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKGspIHsgcmV0dXJuIHRoaXMuX1trXTsgfSxcbiAgICBoYXM6IGZ1bmN0aW9uKGspIHsgcmV0dXJuIGsgaW4gdGhpcy5fOyB9LFxuICAgIGRlbGV0ZTogZnVuY3Rpb24oaykgeyByZXR1cm4gayBpbiB0aGlzLl8gJiYgZGVsZXRlIHRoaXMuX1trXTsgfSxcbiAgICBjbGVhcjogZnVuY3Rpb24oKSB7IHRoaXMuXyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IH0sXG4gICAgZ2V0IHNpemUoKSB7IHZhciBuID0gMDsgZm9yICh2YXIgayBpbiB0aGlzLl8pICsrbjsgcmV0dXJuIG47IH0sXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oYykgeyBmb3IgKHZhciBrIGluIHRoaXMuXykgYyh0aGlzLl9ba10sIGssIHRoaXMpOyB9XG4gIH07XG59IGVsc2UgKGZ1bmN0aW9uKCkge1xuICB2YXIgbSA9IG5ldyBNYXA7XG4gIGlmIChtLnNldCgwLCAwKSAhPT0gbSkge1xuICAgIG0gPSBtLnNldDtcbiAgICBNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKCkgeyBtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiB0aGlzOyB9O1xuICB9XG59KSgpO1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIGZhY3RvcnkoKGdsb2JhbC5jb2xvciA9IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBkZWx0YUh1ZShoMSwgaDApIHtcbiAgICB2YXIgZGVsdGEgPSBoMSAtIGgwO1xuICAgIHJldHVybiBkZWx0YSA+IDE4MCB8fCBkZWx0YSA8IC0xODBcbiAgICAgICAgPyBkZWx0YSAtIDM2MCAqIE1hdGgucm91bmQoZGVsdGEgLyAzNjApXG4gICAgICAgIDogZGVsdGE7XG4gIH1cblxuICBmdW5jdGlvbiBDb2xvcigpIHt9XG5cbiAgdmFyIHJlSGV4MyA9IC9eIyhbMC05YS1mXXszfSkkLztcbiAgdmFyIHJlSGV4NiA9IC9eIyhbMC05YS1mXXs2fSkkLztcbiAgdmFyIHJlUmdiSW50ZWdlciA9IC9ecmdiXFwoXFxzKihbLStdP1xcZCspXFxzKixcXHMqKFstK10/XFxkKylcXHMqLFxccyooWy0rXT9cXGQrKVxccypcXCkkLztcbiAgdmFyIHJlUmdiUGVyY2VudCA9IC9ecmdiXFwoXFxzKihbLStdP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKihbLStdP1xcZCsoPzpcXC5cXGQrKT8pJVxccyosXFxzKihbLStdP1xcZCsoPzpcXC5cXGQrKT8pJVxccypcXCkkLztcbiAgdmFyIHJlSHNsUGVyY2VudCA9IC9eaHNsXFwoXFxzKihbLStdP1xcZCsoPzpcXC5cXGQrKT8pXFxzKixcXHMqKFstK10/XFxkKyg/OlxcLlxcZCspPyklXFxzKixcXHMqKFstK10/XFxkKyg/OlxcLlxcZCspPyklXFxzKlxcKSQvO1xuXG4gIGNvbG9yLnByb3RvdHlwZSA9IENvbG9yLnByb3RvdHlwZSA9IHtcbiAgICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZ2IoKS5kaXNwbGF5YWJsZSgpO1xuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmdiKCkgKyBcIlwiO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjb2xvcihmb3JtYXQpIHtcbiAgICB2YXIgbTtcbiAgICBmb3JtYXQgPSAoZm9ybWF0ICsgXCJcIikudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIChtID0gcmVIZXgzLmV4ZWMoZm9ybWF0KSkgPyAobSA9IHBhcnNlSW50KG1bMV0sIDE2KSwgcmdiKChtID4+IDggJiAweGYpIHwgKG0gPj4gNCAmIDB4MGYwKSwgKG0gPj4gNCAmIDB4ZikgfCAobSAmIDB4ZjApLCAoKG0gJiAweGYpIDw8IDQpIHwgKG0gJiAweGYpKSkgLy8gI2YwMFxuICAgICAgICA6IChtID0gcmVIZXg2LmV4ZWMoZm9ybWF0KSkgPyByZ2JuKHBhcnNlSW50KG1bMV0sIDE2KSkgLy8gI2ZmMDAwMFxuICAgICAgICA6IChtID0gcmVSZ2JJbnRlZ2VyLmV4ZWMoZm9ybWF0KSkgPyByZ2IobVsxXSwgbVsyXSwgbVszXSkgLy8gcmdiKDI1NSwwLDApXG4gICAgICAgIDogKG0gPSByZVJnYlBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IHJnYihtWzFdICogMi41NSwgbVsyXSAqIDIuNTUsIG1bM10gKiAyLjU1KSAvLyByZ2IoMTAwJSwwJSwwJSlcbiAgICAgICAgOiAobSA9IHJlSHNsUGVyY2VudC5leGVjKGZvcm1hdCkpID8gaHNsKG1bMV0sIG1bMl0gKiAuMDEsIG1bM10gKiAuMDEpIC8vIGhzbCgxMjAsNTAlLDUwJSlcbiAgICAgICAgOiBuYW1lZC5oYXMoZm9ybWF0KSA/IHJnYm4obmFtZWQuZ2V0KGZvcm1hdCkpXG4gICAgICAgIDogbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJnYm4obikge1xuICAgIHJldHVybiByZ2IobiA+PiAxNiAmIDB4ZmYsIG4gPj4gOCAmIDB4ZmYsIG4gJiAweGZmKTtcbiAgfVxuXG4gIHZhciBuYW1lZCA9IChuZXcgTWFwKVxuICAgICAgLnNldChcImFsaWNlYmx1ZVwiLCAweGYwZjhmZilcbiAgICAgIC5zZXQoXCJhbnRpcXVld2hpdGVcIiwgMHhmYWViZDcpXG4gICAgICAuc2V0KFwiYXF1YVwiLCAweDAwZmZmZilcbiAgICAgIC5zZXQoXCJhcXVhbWFyaW5lXCIsIDB4N2ZmZmQ0KVxuICAgICAgLnNldChcImF6dXJlXCIsIDB4ZjBmZmZmKVxuICAgICAgLnNldChcImJlaWdlXCIsIDB4ZjVmNWRjKVxuICAgICAgLnNldChcImJpc3F1ZVwiLCAweGZmZTRjNClcbiAgICAgIC5zZXQoXCJibGFja1wiLCAweDAwMDAwMClcbiAgICAgIC5zZXQoXCJibGFuY2hlZGFsbW9uZFwiLCAweGZmZWJjZClcbiAgICAgIC5zZXQoXCJibHVlXCIsIDB4MDAwMGZmKVxuICAgICAgLnNldChcImJsdWV2aW9sZXRcIiwgMHg4YTJiZTIpXG4gICAgICAuc2V0KFwiYnJvd25cIiwgMHhhNTJhMmEpXG4gICAgICAuc2V0KFwiYnVybHl3b29kXCIsIDB4ZGViODg3KVxuICAgICAgLnNldChcImNhZGV0Ymx1ZVwiLCAweDVmOWVhMClcbiAgICAgIC5zZXQoXCJjaGFydHJldXNlXCIsIDB4N2ZmZjAwKVxuICAgICAgLnNldChcImNob2NvbGF0ZVwiLCAweGQyNjkxZSlcbiAgICAgIC5zZXQoXCJjb3JhbFwiLCAweGZmN2Y1MClcbiAgICAgIC5zZXQoXCJjb3JuZmxvd2VyYmx1ZVwiLCAweDY0OTVlZClcbiAgICAgIC5zZXQoXCJjb3Juc2lsa1wiLCAweGZmZjhkYylcbiAgICAgIC5zZXQoXCJjcmltc29uXCIsIDB4ZGMxNDNjKVxuICAgICAgLnNldChcImN5YW5cIiwgMHgwMGZmZmYpXG4gICAgICAuc2V0KFwiZGFya2JsdWVcIiwgMHgwMDAwOGIpXG4gICAgICAuc2V0KFwiZGFya2N5YW5cIiwgMHgwMDhiOGIpXG4gICAgICAuc2V0KFwiZGFya2dvbGRlbnJvZFwiLCAweGI4ODYwYilcbiAgICAgIC5zZXQoXCJkYXJrZ3JheVwiLCAweGE5YTlhOSlcbiAgICAgIC5zZXQoXCJkYXJrZ3JlZW5cIiwgMHgwMDY0MDApXG4gICAgICAuc2V0KFwiZGFya2dyZXlcIiwgMHhhOWE5YTkpXG4gICAgICAuc2V0KFwiZGFya2toYWtpXCIsIDB4YmRiNzZiKVxuICAgICAgLnNldChcImRhcmttYWdlbnRhXCIsIDB4OGIwMDhiKVxuICAgICAgLnNldChcImRhcmtvbGl2ZWdyZWVuXCIsIDB4NTU2YjJmKVxuICAgICAgLnNldChcImRhcmtvcmFuZ2VcIiwgMHhmZjhjMDApXG4gICAgICAuc2V0KFwiZGFya29yY2hpZFwiLCAweDk5MzJjYylcbiAgICAgIC5zZXQoXCJkYXJrcmVkXCIsIDB4OGIwMDAwKVxuICAgICAgLnNldChcImRhcmtzYWxtb25cIiwgMHhlOTk2N2EpXG4gICAgICAuc2V0KFwiZGFya3NlYWdyZWVuXCIsIDB4OGZiYzhmKVxuICAgICAgLnNldChcImRhcmtzbGF0ZWJsdWVcIiwgMHg0ODNkOGIpXG4gICAgICAuc2V0KFwiZGFya3NsYXRlZ3JheVwiLCAweDJmNGY0ZilcbiAgICAgIC5zZXQoXCJkYXJrc2xhdGVncmV5XCIsIDB4MmY0ZjRmKVxuICAgICAgLnNldChcImRhcmt0dXJxdW9pc2VcIiwgMHgwMGNlZDEpXG4gICAgICAuc2V0KFwiZGFya3Zpb2xldFwiLCAweDk0MDBkMylcbiAgICAgIC5zZXQoXCJkZWVwcGlua1wiLCAweGZmMTQ5MylcbiAgICAgIC5zZXQoXCJkZWVwc2t5Ymx1ZVwiLCAweDAwYmZmZilcbiAgICAgIC5zZXQoXCJkaW1ncmF5XCIsIDB4Njk2OTY5KVxuICAgICAgLnNldChcImRpbWdyZXlcIiwgMHg2OTY5NjkpXG4gICAgICAuc2V0KFwiZG9kZ2VyYmx1ZVwiLCAweDFlOTBmZilcbiAgICAgIC5zZXQoXCJmaXJlYnJpY2tcIiwgMHhiMjIyMjIpXG4gICAgICAuc2V0KFwiZmxvcmFsd2hpdGVcIiwgMHhmZmZhZjApXG4gICAgICAuc2V0KFwiZm9yZXN0Z3JlZW5cIiwgMHgyMjhiMjIpXG4gICAgICAuc2V0KFwiZnVjaHNpYVwiLCAweGZmMDBmZilcbiAgICAgIC5zZXQoXCJnYWluc2Jvcm9cIiwgMHhkY2RjZGMpXG4gICAgICAuc2V0KFwiZ2hvc3R3aGl0ZVwiLCAweGY4ZjhmZilcbiAgICAgIC5zZXQoXCJnb2xkXCIsIDB4ZmZkNzAwKVxuICAgICAgLnNldChcImdvbGRlbnJvZFwiLCAweGRhYTUyMClcbiAgICAgIC5zZXQoXCJncmF5XCIsIDB4ODA4MDgwKVxuICAgICAgLnNldChcImdyZWVuXCIsIDB4MDA4MDAwKVxuICAgICAgLnNldChcImdyZWVueWVsbG93XCIsIDB4YWRmZjJmKVxuICAgICAgLnNldChcImdyZXlcIiwgMHg4MDgwODApXG4gICAgICAuc2V0KFwiaG9uZXlkZXdcIiwgMHhmMGZmZjApXG4gICAgICAuc2V0KFwiaG90cGlua1wiLCAweGZmNjliNClcbiAgICAgIC5zZXQoXCJpbmRpYW5yZWRcIiwgMHhjZDVjNWMpXG4gICAgICAuc2V0KFwiaW5kaWdvXCIsIDB4NGIwMDgyKVxuICAgICAgLnNldChcIml2b3J5XCIsIDB4ZmZmZmYwKVxuICAgICAgLnNldChcImtoYWtpXCIsIDB4ZjBlNjhjKVxuICAgICAgLnNldChcImxhdmVuZGVyXCIsIDB4ZTZlNmZhKVxuICAgICAgLnNldChcImxhdmVuZGVyYmx1c2hcIiwgMHhmZmYwZjUpXG4gICAgICAuc2V0KFwibGF3bmdyZWVuXCIsIDB4N2NmYzAwKVxuICAgICAgLnNldChcImxlbW9uY2hpZmZvblwiLCAweGZmZmFjZClcbiAgICAgIC5zZXQoXCJsaWdodGJsdWVcIiwgMHhhZGQ4ZTYpXG4gICAgICAuc2V0KFwibGlnaHRjb3JhbFwiLCAweGYwODA4MClcbiAgICAgIC5zZXQoXCJsaWdodGN5YW5cIiwgMHhlMGZmZmYpXG4gICAgICAuc2V0KFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIiwgMHhmYWZhZDIpXG4gICAgICAuc2V0KFwibGlnaHRncmF5XCIsIDB4ZDNkM2QzKVxuICAgICAgLnNldChcImxpZ2h0Z3JlZW5cIiwgMHg5MGVlOTApXG4gICAgICAuc2V0KFwibGlnaHRncmV5XCIsIDB4ZDNkM2QzKVxuICAgICAgLnNldChcImxpZ2h0cGlua1wiLCAweGZmYjZjMSlcbiAgICAgIC5zZXQoXCJsaWdodHNhbG1vblwiLCAweGZmYTA3YSlcbiAgICAgIC5zZXQoXCJsaWdodHNlYWdyZWVuXCIsIDB4MjBiMmFhKVxuICAgICAgLnNldChcImxpZ2h0c2t5Ymx1ZVwiLCAweDg3Y2VmYSlcbiAgICAgIC5zZXQoXCJsaWdodHNsYXRlZ3JheVwiLCAweDc3ODg5OSlcbiAgICAgIC5zZXQoXCJsaWdodHNsYXRlZ3JleVwiLCAweDc3ODg5OSlcbiAgICAgIC5zZXQoXCJsaWdodHN0ZWVsYmx1ZVwiLCAweGIwYzRkZSlcbiAgICAgIC5zZXQoXCJsaWdodHllbGxvd1wiLCAweGZmZmZlMClcbiAgICAgIC5zZXQoXCJsaW1lXCIsIDB4MDBmZjAwKVxuICAgICAgLnNldChcImxpbWVncmVlblwiLCAweDMyY2QzMilcbiAgICAgIC5zZXQoXCJsaW5lblwiLCAweGZhZjBlNilcbiAgICAgIC5zZXQoXCJtYWdlbnRhXCIsIDB4ZmYwMGZmKVxuICAgICAgLnNldChcIm1hcm9vblwiLCAweDgwMDAwMClcbiAgICAgIC5zZXQoXCJtZWRpdW1hcXVhbWFyaW5lXCIsIDB4NjZjZGFhKVxuICAgICAgLnNldChcIm1lZGl1bWJsdWVcIiwgMHgwMDAwY2QpXG4gICAgICAuc2V0KFwibWVkaXVtb3JjaGlkXCIsIDB4YmE1NWQzKVxuICAgICAgLnNldChcIm1lZGl1bXB1cnBsZVwiLCAweDkzNzBkYilcbiAgICAgIC5zZXQoXCJtZWRpdW1zZWFncmVlblwiLCAweDNjYjM3MSlcbiAgICAgIC5zZXQoXCJtZWRpdW1zbGF0ZWJsdWVcIiwgMHg3YjY4ZWUpXG4gICAgICAuc2V0KFwibWVkaXVtc3ByaW5nZ3JlZW5cIiwgMHgwMGZhOWEpXG4gICAgICAuc2V0KFwibWVkaXVtdHVycXVvaXNlXCIsIDB4NDhkMWNjKVxuICAgICAgLnNldChcIm1lZGl1bXZpb2xldHJlZFwiLCAweGM3MTU4NSlcbiAgICAgIC5zZXQoXCJtaWRuaWdodGJsdWVcIiwgMHgxOTE5NzApXG4gICAgICAuc2V0KFwibWludGNyZWFtXCIsIDB4ZjVmZmZhKVxuICAgICAgLnNldChcIm1pc3R5cm9zZVwiLCAweGZmZTRlMSlcbiAgICAgIC5zZXQoXCJtb2NjYXNpblwiLCAweGZmZTRiNSlcbiAgICAgIC5zZXQoXCJuYXZham93aGl0ZVwiLCAweGZmZGVhZClcbiAgICAgIC5zZXQoXCJuYXZ5XCIsIDB4MDAwMDgwKVxuICAgICAgLnNldChcIm9sZGxhY2VcIiwgMHhmZGY1ZTYpXG4gICAgICAuc2V0KFwib2xpdmVcIiwgMHg4MDgwMDApXG4gICAgICAuc2V0KFwib2xpdmVkcmFiXCIsIDB4NmI4ZTIzKVxuICAgICAgLnNldChcIm9yYW5nZVwiLCAweGZmYTUwMClcbiAgICAgIC5zZXQoXCJvcmFuZ2VyZWRcIiwgMHhmZjQ1MDApXG4gICAgICAuc2V0KFwib3JjaGlkXCIsIDB4ZGE3MGQ2KVxuICAgICAgLnNldChcInBhbGVnb2xkZW5yb2RcIiwgMHhlZWU4YWEpXG4gICAgICAuc2V0KFwicGFsZWdyZWVuXCIsIDB4OThmYjk4KVxuICAgICAgLnNldChcInBhbGV0dXJxdW9pc2VcIiwgMHhhZmVlZWUpXG4gICAgICAuc2V0KFwicGFsZXZpb2xldHJlZFwiLCAweGRiNzA5MylcbiAgICAgIC5zZXQoXCJwYXBheWF3aGlwXCIsIDB4ZmZlZmQ1KVxuICAgICAgLnNldChcInBlYWNocHVmZlwiLCAweGZmZGFiOSlcbiAgICAgIC5zZXQoXCJwZXJ1XCIsIDB4Y2Q4NTNmKVxuICAgICAgLnNldChcInBpbmtcIiwgMHhmZmMwY2IpXG4gICAgICAuc2V0KFwicGx1bVwiLCAweGRkYTBkZClcbiAgICAgIC5zZXQoXCJwb3dkZXJibHVlXCIsIDB4YjBlMGU2KVxuICAgICAgLnNldChcInB1cnBsZVwiLCAweDgwMDA4MClcbiAgICAgIC5zZXQoXCJyZWJlY2NhcHVycGxlXCIsIDB4NjYzMzk5KVxuICAgICAgLnNldChcInJlZFwiLCAweGZmMDAwMClcbiAgICAgIC5zZXQoXCJyb3N5YnJvd25cIiwgMHhiYzhmOGYpXG4gICAgICAuc2V0KFwicm95YWxibHVlXCIsIDB4NDE2OWUxKVxuICAgICAgLnNldChcInNhZGRsZWJyb3duXCIsIDB4OGI0NTEzKVxuICAgICAgLnNldChcInNhbG1vblwiLCAweGZhODA3MilcbiAgICAgIC5zZXQoXCJzYW5keWJyb3duXCIsIDB4ZjRhNDYwKVxuICAgICAgLnNldChcInNlYWdyZWVuXCIsIDB4MmU4YjU3KVxuICAgICAgLnNldChcInNlYXNoZWxsXCIsIDB4ZmZmNWVlKVxuICAgICAgLnNldChcInNpZW5uYVwiLCAweGEwNTIyZClcbiAgICAgIC5zZXQoXCJzaWx2ZXJcIiwgMHhjMGMwYzApXG4gICAgICAuc2V0KFwic2t5Ymx1ZVwiLCAweDg3Y2VlYilcbiAgICAgIC5zZXQoXCJzbGF0ZWJsdWVcIiwgMHg2YTVhY2QpXG4gICAgICAuc2V0KFwic2xhdGVncmF5XCIsIDB4NzA4MDkwKVxuICAgICAgLnNldChcInNsYXRlZ3JleVwiLCAweDcwODA5MClcbiAgICAgIC5zZXQoXCJzbm93XCIsIDB4ZmZmYWZhKVxuICAgICAgLnNldChcInNwcmluZ2dyZWVuXCIsIDB4MDBmZjdmKVxuICAgICAgLnNldChcInN0ZWVsYmx1ZVwiLCAweDQ2ODJiNClcbiAgICAgIC5zZXQoXCJ0YW5cIiwgMHhkMmI0OGMpXG4gICAgICAuc2V0KFwidGVhbFwiLCAweDAwODA4MClcbiAgICAgIC5zZXQoXCJ0aGlzdGxlXCIsIDB4ZDhiZmQ4KVxuICAgICAgLnNldChcInRvbWF0b1wiLCAweGZmNjM0NylcbiAgICAgIC5zZXQoXCJ0dXJxdW9pc2VcIiwgMHg0MGUwZDApXG4gICAgICAuc2V0KFwidmlvbGV0XCIsIDB4ZWU4MmVlKVxuICAgICAgLnNldChcIndoZWF0XCIsIDB4ZjVkZWIzKVxuICAgICAgLnNldChcIndoaXRlXCIsIDB4ZmZmZmZmKVxuICAgICAgLnNldChcIndoaXRlc21va2VcIiwgMHhmNWY1ZjUpXG4gICAgICAuc2V0KFwieWVsbG93XCIsIDB4ZmZmZjAwKVxuICAgICAgLnNldChcInllbGxvd2dyZWVuXCIsIDB4OWFjZDMyKTtcblxuICB2YXIgZGFya2VyID0gLjc7XG4gIHZhciBicmlnaHRlciA9IDEgLyBkYXJrZXI7XG5cbiAgZnVuY3Rpb24gcmdiKHIsIGcsIGIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKCEociBpbnN0YW5jZW9mIENvbG9yKSkgciA9IGNvbG9yKHIpO1xuICAgICAgaWYgKHIpIHtcbiAgICAgICAgciA9IHIucmdiKCk7XG4gICAgICAgIGIgPSByLmI7XG4gICAgICAgIGcgPSByLmc7XG4gICAgICAgIHIgPSByLnI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByID0gZyA9IGIgPSBOYU47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmdiKHIsIGcsIGIpO1xuICB9XG5cbiAgZnVuY3Rpb24gUmdiKHIsIGcsIGIpIHtcbiAgICB0aGlzLnIgPSArcjtcbiAgICB0aGlzLmcgPSArZztcbiAgICB0aGlzLmIgPSArYjtcbiAgfVxuXG4gIHZhciBfcHJvdG90eXBlID0gcmdiLnByb3RvdHlwZSA9IFJnYi5wcm90b3R5cGUgPSBuZXcgQ29sb3I7XG5cbiAgX3Byb3RvdHlwZS5icmlnaHRlciA9IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogayk7XG4gIH07XG5cbiAgX3Byb3RvdHlwZS5kYXJrZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogayk7XG4gIH07XG5cbiAgX3Byb3RvdHlwZS5yZ2IgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG90eXBlLmRpc3BsYXlhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICgwIDw9IHRoaXMuciAmJiB0aGlzLnIgPD0gMjU1KVxuICAgICAgICAmJiAoMCA8PSB0aGlzLmcgJiYgdGhpcy5nIDw9IDI1NSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5iICYmIHRoaXMuYiA8PSAyNTUpO1xuICB9O1xuXG4gIF9wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZm9ybWF0KHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZvcm1hdChyLCBnLCBiKSB7XG4gICAgcmV0dXJuIFwiI1wiXG4gICAgICAgICsgKGlzTmFOKHIpID8gXCIwMFwiIDogKHIgPSBNYXRoLnJvdW5kKHIpKSA8IDE2ID8gXCIwXCIgKyBNYXRoLm1heCgwLCByKS50b1N0cmluZygxNikgOiBNYXRoLm1pbigyNTUsIHIpLnRvU3RyaW5nKDE2KSlcbiAgICAgICAgKyAoaXNOYU4oZykgPyBcIjAwXCIgOiAoZyA9IE1hdGgucm91bmQoZykpIDwgMTYgPyBcIjBcIiArIE1hdGgubWF4KDAsIGcpLnRvU3RyaW5nKDE2KSA6IE1hdGgubWluKDI1NSwgZykudG9TdHJpbmcoMTYpKVxuICAgICAgICArIChpc05hTihiKSA/IFwiMDBcIiA6IChiID0gTWF0aC5yb3VuZChiKSkgPCAxNiA/IFwiMFwiICsgTWF0aC5tYXgoMCwgYikudG9TdHJpbmcoMTYpIDogTWF0aC5taW4oMjU1LCBiKS50b1N0cmluZygxNikpO1xuICB9XG5cbiAgZnVuY3Rpb24gaHNsKGgsIHMsIGwpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKGggaW5zdGFuY2VvZiBIc2wpIHtcbiAgICAgICAgbCA9IGgubDtcbiAgICAgICAgcyA9IGgucztcbiAgICAgICAgaCA9IGguaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKGggaW5zdGFuY2VvZiBDb2xvcikpIGggPSBjb2xvcihoKTtcbiAgICAgICAgaWYgKGgpIHtcbiAgICAgICAgICBpZiAoaCBpbnN0YW5jZW9mIEhzbCkgcmV0dXJuIGg7XG4gICAgICAgICAgaCA9IGgucmdiKCk7XG4gICAgICAgICAgdmFyIHIgPSBoLnIgLyAyNTUsXG4gICAgICAgICAgICAgIGcgPSBoLmcgLyAyNTUsXG4gICAgICAgICAgICAgIGIgPSBoLmIgLyAyNTUsXG4gICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgICAgICAgICAgcmFuZ2UgPSBtYXggLSBtaW47XG4gICAgICAgICAgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHMgPSBsIDwgLjUgPyByYW5nZSAvIChtYXggKyBtaW4pIDogcmFuZ2UgLyAoMiAtIG1heCAtIG1pbik7XG4gICAgICAgICAgICBpZiAociA9PT0gbWF4KSBoID0gKGcgLSBiKSAvIHJhbmdlICsgKGcgPCBiKSAqIDY7XG4gICAgICAgICAgICBlbHNlIGlmIChnID09PSBtYXgpIGggPSAoYiAtIHIpIC8gcmFuZ2UgKyAyO1xuICAgICAgICAgICAgZWxzZSBoID0gKHIgLSBnKSAvIHJhbmdlICsgNDtcbiAgICAgICAgICAgIGggKj0gNjA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGggPSBOYU47XG4gICAgICAgICAgICBzID0gbCA+IDAgJiYgbCA8IDEgPyAwIDogaDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaCA9IHMgPSBsID0gTmFOO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgSHNsKGgsIHMsIGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gSHNsKGgsIHMsIGwpIHtcbiAgICB0aGlzLmggPSAraDtcbiAgICB0aGlzLnMgPSArcztcbiAgICB0aGlzLmwgPSArbDtcbiAgfVxuXG4gIHZhciBfX3Byb3RvdHlwZSA9IGhzbC5wcm90b3R5cGUgPSBIc2wucHJvdG90eXBlID0gbmV3IENvbG9yO1xuXG4gIF9fcHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogayk7XG4gIH07XG5cbiAgX19wcm90b3R5cGUuZGFya2VyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgSHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrKTtcbiAgfTtcblxuICBfX3Byb3RvdHlwZS5yZ2IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaCA9IHRoaXMuaCAlIDM2MCArICh0aGlzLmggPCAwKSAqIDM2MCxcbiAgICAgICAgcyA9IGlzTmFOKGgpIHx8IGlzTmFOKHRoaXMucykgPyAwIDogdGhpcy5zLFxuICAgICAgICBsID0gdGhpcy5sLFxuICAgICAgICBtMiA9IGwgKyAobCA8IC41ID8gbCA6IDEgLSBsKSAqIHMsXG4gICAgICAgIG0xID0gMiAqIGwgLSBtMjtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIGhzbDJyZ2IoaCA+PSAyNDAgPyBoIC0gMjQwIDogaCArIDEyMCwgbTEsIG0yKSxcbiAgICAgIGhzbDJyZ2IoaCwgbTEsIG0yKSxcbiAgICAgIGhzbDJyZ2IoaCA8IDEyMCA/IGggKyAyNDAgOiBoIC0gMTIwLCBtMSwgbTIpXG4gICAgKTtcbiAgfTtcblxuICBfX3Byb3RvdHlwZS5kaXNwbGF5YWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoMCA8PSB0aGlzLnMgJiYgdGhpcy5zIDw9IDEgfHwgaXNOYU4odGhpcy5zKSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5sICYmIHRoaXMubCA8PSAxKTtcbiAgfTtcblxuICAvKiBGcm9tIEZ2RCAxMy4zNywgQ1NTIENvbG9yIE1vZHVsZSBMZXZlbCAzICovXG4gIGZ1bmN0aW9uIGhzbDJyZ2IoaCwgbTEsIG0yKSB7XG4gICAgcmV0dXJuIChoIDwgNjAgPyBtMSArIChtMiAtIG0xKSAqIGggLyA2MFxuICAgICAgICA6IGggPCAxODAgPyBtMlxuICAgICAgICA6IGggPCAyNDAgPyBtMSArIChtMiAtIG0xKSAqICgyNDAgLSBoKSAvIDYwXG4gICAgICAgIDogbTEpICogMjU1O1xuICB9XG5cbiAgdmFyIEtuID0gMTg7XG5cbiAgdmFyIFhuID0gMC45NTA0NzA7XG4gIHZhciBZbiA9IDE7XG4gIHZhciBabiA9IDEuMDg4ODMwO1xuICB2YXIgdDAgPSA0IC8gMjk7XG4gIHZhciB0MSA9IDYgLyAyOTtcbiAgdmFyIHQyID0gMyAqIHQxICogdDE7XG4gIHZhciB0MyA9IHQxICogdDEgKiB0MTtcblxuICBmdW5jdGlvbiBsYWIobCwgYSwgYikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAobCBpbnN0YW5jZW9mIExhYikge1xuICAgICAgICBiID0gbC5iO1xuICAgICAgICBhID0gbC5hO1xuICAgICAgICBsID0gbC5sO1xuICAgICAgfSBlbHNlIGlmIChsIGluc3RhbmNlb2YgSGNsKSB7XG4gICAgICAgIHZhciBoID0gbC5oICogZGVnMnJhZDtcbiAgICAgICAgYiA9IE1hdGguc2luKGgpICogbC5jO1xuICAgICAgICBhID0gTWF0aC5jb3MoaCkgKiBsLmM7XG4gICAgICAgIGwgPSBsLmw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIShsIGluc3RhbmNlb2YgUmdiKSkgbCA9IHJnYihsKTtcbiAgICAgICAgdmFyIHIgPSByZ2IyeHl6KGwuciksXG4gICAgICAgICAgICBnID0gcmdiMnh5eihsLmcpLFxuICAgICAgICAgICAgYiA9IHJnYjJ4eXoobC5iKSxcbiAgICAgICAgICAgIHggPSB4eXoybGFiKCgwLjQxMjQ1NjQgKiByICsgMC4zNTc1NzYxICogZyArIDAuMTgwNDM3NSAqIGIpIC8gWG4pLFxuICAgICAgICAgICAgeSA9IHh5ejJsYWIoKDAuMjEyNjcyOSAqIHIgKyAwLjcxNTE1MjIgKiBnICsgMC4wNzIxNzUwICogYikgLyBZbiksXG4gICAgICAgICAgICB6ID0geHl6MmxhYigoMC4wMTkzMzM5ICogciArIDAuMTE5MTkyMCAqIGcgKyAwLjk1MDMwNDEgKiBiKSAvIFpuKTtcbiAgICAgICAgYiA9IDIwMCAqICh5IC0geik7XG4gICAgICAgIGEgPSA1MDAgKiAoeCAtIHkpO1xuICAgICAgICBsID0gMTE2ICogeSAtIDE2O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IExhYihsLCBhLCBiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIExhYihsLCBhLCBiKSB7XG4gICAgdGhpcy5sID0gK2w7XG4gICAgdGhpcy5hID0gK2E7XG4gICAgdGhpcy5iID0gK2I7XG4gIH1cblxuICB2YXIgX19fcHJvdG90eXBlID0gbGFiLnByb3RvdHlwZSA9IExhYi5wcm90b3R5cGUgPSBuZXcgQ29sb3I7XG5cbiAgX19fcHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgTGFiKHRoaXMubCArIEtuICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5hLCB0aGlzLmIpO1xuICB9O1xuXG4gIF9fX3Byb3RvdHlwZS5kYXJrZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBMYWIodGhpcy5sIC0gS24gKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLmEsIHRoaXMuYik7XG4gIH07XG5cbiAgX19fcHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB5ID0gKHRoaXMubCArIDE2KSAvIDExNixcbiAgICAgICAgeCA9IGlzTmFOKHRoaXMuYSkgPyB5IDogeSArIHRoaXMuYSAvIDUwMCxcbiAgICAgICAgeiA9IGlzTmFOKHRoaXMuYikgPyB5IDogeSAtIHRoaXMuYiAvIDIwMDtcbiAgICB5ID0gWW4gKiBsYWIyeHl6KHkpO1xuICAgIHggPSBYbiAqIGxhYjJ4eXooeCk7XG4gICAgeiA9IFpuICogbGFiMnh5eih6KTtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIHh5ejJyZ2IoIDMuMjQwNDU0MiAqIHggLSAxLjUzNzEzODUgKiB5IC0gMC40OTg1MzE0ICogeiksIC8vIEQ2NSAtPiBzUkdCXG4gICAgICB4eXoycmdiKC0wLjk2OTI2NjAgKiB4ICsgMS44NzYwMTA4ICogeSArIDAuMDQxNTU2MCAqIHopLFxuICAgICAgeHl6MnJnYiggMC4wNTU2NDM0ICogeCAtIDAuMjA0MDI1OSAqIHkgKyAxLjA1NzIyNTIgKiB6KVxuICAgICk7XG4gIH07XG5cbiAgZnVuY3Rpb24geHl6MmxhYih0KSB7XG4gICAgcmV0dXJuIHQgPiB0MyA/IE1hdGgucG93KHQsIDEgLyAzKSA6IHQgLyB0MiArIHQwO1xuICB9XG5cbiAgZnVuY3Rpb24gbGFiMnh5eih0KSB7XG4gICAgcmV0dXJuIHQgPiB0MSA/IHQgKiB0ICogdCA6IHQyICogKHQgLSB0MCk7XG4gIH1cblxuICBmdW5jdGlvbiB4eXoycmdiKHgpIHtcbiAgICByZXR1cm4gMjU1ICogKHggPD0gMC4wMDMxMzA4ID8gMTIuOTIgKiB4IDogMS4wNTUgKiBNYXRoLnBvdyh4LCAxIC8gMi40KSAtIDAuMDU1KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJnYjJ4eXooeCkge1xuICAgIHJldHVybiAoeCAvPSAyNTUpIDw9IDAuMDQwNDUgPyB4IC8gMTIuOTIgOiBNYXRoLnBvdygoeCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuICB9XG5cbiAgdmFyIGRlZzJyYWQgPSBNYXRoLlBJIC8gMTgwO1xuICB2YXIgcmFkMmRlZyA9IDE4MCAvIE1hdGguUEk7XG5cbiAgZnVuY3Rpb24gaGNsKGgsIGMsIGwpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKGggaW5zdGFuY2VvZiBIY2wpIHtcbiAgICAgICAgbCA9IGgubDtcbiAgICAgICAgYyA9IGguYztcbiAgICAgICAgaCA9IGguaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKGggaW5zdGFuY2VvZiBMYWIpKSBoID0gbGFiKGgpO1xuICAgICAgICBsID0gaC5sO1xuICAgICAgICBjID0gTWF0aC5zcXJ0KGguYSAqIGguYSArIGguYiAqIGguYik7XG4gICAgICAgIGggPSBNYXRoLmF0YW4yKGguYiwgaC5hKSAqIHJhZDJkZWc7XG4gICAgICAgIGlmIChoIDwgMCkgaCArPSAzNjA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgSGNsKGgsIGMsIGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gSGNsKGgsIGMsIGwpIHtcbiAgICB0aGlzLmggPSAraDtcbiAgICB0aGlzLmMgPSArYztcbiAgICB0aGlzLmwgPSArbDtcbiAgfVxuXG4gIHZhciBfX19fcHJvdG90eXBlID0gaGNsLnByb3RvdHlwZSA9IEhjbC5wcm90b3R5cGUgPSBuZXcgQ29sb3I7XG5cbiAgX19fX3Byb3RvdHlwZS5icmlnaHRlciA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IEhjbCh0aGlzLmgsIHRoaXMuYywgdGhpcy5sICsgS24gKiAoayA9PSBudWxsID8gMSA6IGspKTtcbiAgfTtcblxuICBfX19fcHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IEhjbCh0aGlzLmgsIHRoaXMuYywgdGhpcy5sIC0gS24gKiAoayA9PSBudWxsID8gMSA6IGspKTtcbiAgfTtcblxuICBfX19fcHJvdG90eXBlLnJnYiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBsYWIodGhpcykucmdiKCk7XG4gIH07XG5cbiAgdmFyIEEgPSAtMC4xNDg2MTtcbiAgdmFyIEIgPSArMS43ODI3NztcbiAgdmFyIEMgPSAtMC4yOTIyNztcbiAgdmFyIEQgPSAtMC45MDY0OTtcbiAgdmFyIEUgPSArMS45NzI5NDtcbiAgdmFyIEVEID0gRSAqIEQ7XG4gIHZhciBFQiA9IEUgKiBCO1xuICB2YXIgQkNfREEgPSBCICogQyAtIEQgKiBBO1xuXG4gIGZ1bmN0aW9uIGN1YmVoZWxpeChoLCBzLCBsKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChoIGluc3RhbmNlb2YgQ3ViZWhlbGl4KSB7XG4gICAgICAgIGwgPSBoLmw7XG4gICAgICAgIHMgPSBoLnM7XG4gICAgICAgIGggPSBoLmg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIShoIGluc3RhbmNlb2YgUmdiKSkgaCA9IHJnYihoKTtcbiAgICAgICAgdmFyIHIgPSBoLnIgLyAyNTUsIGcgPSBoLmcgLyAyNTUsIGIgPSBoLmIgLyAyNTU7XG4gICAgICAgIGwgPSAoQkNfREEgKiBiICsgRUQgKiByIC0gRUIgKiBnKSAvIChCQ19EQSArIEVEIC0gRUIpO1xuICAgICAgICB2YXIgYmwgPSBiIC0gbCwgayA9IChFICogKGcgLSBsKSAtIEMgKiBibCkgLyBEO1xuICAgICAgICBzID0gTWF0aC5zcXJ0KGsgKiBrICsgYmwgKiBibCkgLyAoRSAqIGwgKiAoMSAtIGwpKTsgLy8gTmFOIGlmIGw9MCBvciBsPTFcbiAgICAgICAgaCA9IHMgPyBNYXRoLmF0YW4yKGssIGJsKSAqIHJhZDJkZWcgLSAxMjAgOiBOYU47XG4gICAgICAgIGlmIChoIDwgMCkgaCArPSAzNjA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ3ViZWhlbGl4KGgsIHMsIGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gQ3ViZWhlbGl4KGgsIHMsIGwpIHtcbiAgICB0aGlzLmggPSAraDtcbiAgICB0aGlzLnMgPSArcztcbiAgICB0aGlzLmwgPSArbDtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGUgPSBjdWJlaGVsaXgucHJvdG90eXBlID0gQ3ViZWhlbGl4LnByb3RvdHlwZSA9IG5ldyBDb2xvcjtcblxuICBwcm90b3R5cGUuYnJpZ2h0ZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgQ3ViZWhlbGl4KHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrKTtcbiAgfTtcblxuICBwcm90b3R5cGUuZGFya2VyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgQ3ViZWhlbGl4KHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrKTtcbiAgfTtcblxuICBwcm90b3R5cGUucmdiID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGggPSBpc05hTih0aGlzLmgpID8gMCA6ICh0aGlzLmggKyAxMjApICogZGVnMnJhZCxcbiAgICAgICAgbCA9ICt0aGlzLmwsXG4gICAgICAgIGEgPSBpc05hTih0aGlzLnMpID8gMCA6IHRoaXMucyAqIGwgKiAoMSAtIGwpLFxuICAgICAgICBjb3NoID0gTWF0aC5jb3MoaCksXG4gICAgICAgIHNpbmggPSBNYXRoLnNpbihoKTtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIDI1NSAqIChsICsgYSAqIChBICogY29zaCArIEIgKiBzaW5oKSksXG4gICAgICAyNTUgKiAobCArIGEgKiAoQyAqIGNvc2ggKyBEICogc2luaCkpLFxuICAgICAgMjU1ICogKGwgKyBhICogKEUgKiBjb3NoKSlcbiAgICApO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlQ3ViZWhlbGl4R2FtbWEoZ2FtbWEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgICAgYSA9IGN1YmVoZWxpeChhKTtcbiAgICAgIGIgPSBjdWJlaGVsaXgoYik7XG4gICAgICB2YXIgYWggPSBpc05hTihhLmgpID8gYi5oIDogYS5oLFxuICAgICAgICAgIGFzID0gaXNOYU4oYS5zKSA/IGIucyA6IGEucyxcbiAgICAgICAgICBhbCA9IGEubCxcbiAgICAgICAgICBiaCA9IGlzTmFOKGIuaCkgPyAwIDogZGVsdGFIdWUoYi5oLCBhaCksXG4gICAgICAgICAgYnMgPSBpc05hTihiLnMpID8gMCA6IGIucyAtIGFzLFxuICAgICAgICAgIGJsID0gYi5sIC0gYWw7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICBhLmggPSBhaCArIGJoICogdDtcbiAgICAgICAgYS5zID0gYXMgKyBicyAqIHQ7XG4gICAgICAgIGEubCA9IGFsICsgYmwgKiBNYXRoLnBvdyh0LCBnYW1tYSk7XG4gICAgICAgIHJldHVybiBhICsgXCJcIjtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlQ3ViZWhlbGl4R2FtbWFMb25nKGdhbW1hKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGEgPSBjdWJlaGVsaXgoYSk7XG4gICAgICBiID0gY3ViZWhlbGl4KGIpO1xuICAgICAgdmFyIGFoID0gaXNOYU4oYS5oKSA/IGIuaCA6IGEuaCxcbiAgICAgICAgICBhcyA9IGlzTmFOKGEucykgPyBiLnMgOiBhLnMsXG4gICAgICAgICAgYWwgPSBhLmwsXG4gICAgICAgICAgYmggPSBpc05hTihiLmgpID8gMCA6IGIuaCAtIGFoLFxuICAgICAgICAgIGJzID0gaXNOYU4oYi5zKSA/IDAgOiBiLnMgLSBhcyxcbiAgICAgICAgICBibCA9IGIubCAtIGFsO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgYS5oID0gYWggKyBiaCAqIHQ7XG4gICAgICAgIGEucyA9IGFzICsgYnMgKiB0O1xuICAgICAgICBhLmwgPSBhbCArIGJsICogTWF0aC5wb3codCwgZ2FtbWEpO1xuICAgICAgICByZXR1cm4gYSArIFwiXCI7XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZUhjbExvbmcoYSwgYikge1xuICAgIGEgPSBoY2woYSk7XG4gICAgYiA9IGhjbChiKTtcbiAgICB2YXIgYWggPSBpc05hTihhLmgpID8gYi5oIDogYS5oLFxuICAgICAgICBhYyA9IGlzTmFOKGEuYykgPyBiLmMgOiBhLmMsXG4gICAgICAgIGFsID0gYS5sLFxuICAgICAgICBiaCA9IGlzTmFOKGIuaCkgPyAwIDogYi5oIC0gYWgsXG4gICAgICAgIGJjID0gaXNOYU4oYi5jKSA/IDAgOiBiLmMgLSBhYyxcbiAgICAgICAgYmwgPSBiLmwgLSBhbDtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgYS5oID0gYWggKyBiaCAqIHQ7XG4gICAgICBhLmMgPSBhYyArIGJjICogdDtcbiAgICAgIGEubCA9IGFsICsgYmwgKiB0O1xuICAgICAgcmV0dXJuIGEgKyBcIlwiO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZUhjbChhLCBiKSB7XG4gICAgYSA9IGhjbChhKTtcbiAgICBiID0gaGNsKGIpO1xuICAgIHZhciBhaCA9IGlzTmFOKGEuaCkgPyBiLmggOiBhLmgsXG4gICAgICAgIGFjID0gaXNOYU4oYS5jKSA/IGIuYyA6IGEuYyxcbiAgICAgICAgYWwgPSBhLmwsXG4gICAgICAgIGJoID0gaXNOYU4oYi5oKSA/IDAgOiBkZWx0YUh1ZShiLmgsIGFoKSxcbiAgICAgICAgYmMgPSBpc05hTihiLmMpID8gMCA6IGIuYyAtIGFjLFxuICAgICAgICBibCA9IGIubCAtIGFsO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBhLmggPSBhaCArIGJoICogdDtcbiAgICAgIGEuYyA9IGFjICsgYmMgKiB0O1xuICAgICAgYS5sID0gYWwgKyBibCAqIHQ7XG4gICAgICByZXR1cm4gYSArIFwiXCI7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlTGFiKGEsIGIpIHtcbiAgICBhID0gbGFiKGEpO1xuICAgIGIgPSBsYWIoYik7XG4gICAgdmFyIGFsID0gYS5sLFxuICAgICAgICBhYSA9IGEuYSxcbiAgICAgICAgYWIgPSBhLmIsXG4gICAgICAgIGJsID0gYi5sIC0gYWwsXG4gICAgICAgIGJhID0gYi5hIC0gYWEsXG4gICAgICAgIGJiID0gYi5iIC0gYWI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGEubCA9IGFsICsgYmwgKiB0O1xuICAgICAgYS5hID0gYWEgKyBiYSAqIHQ7XG4gICAgICBhLmIgPSBhYiArIGJiICogdDtcbiAgICAgIHJldHVybiBhICsgXCJcIjtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGVIc2xMb25nKGEsIGIpIHtcbiAgICBhID0gaHNsKGEpO1xuICAgIGIgPSBoc2woYik7XG4gICAgdmFyIGFoID0gaXNOYU4oYS5oKSA/IGIuaCA6IGEuaCxcbiAgICAgICAgYXMgPSBpc05hTihhLnMpID8gYi5zIDogYS5zLFxuICAgICAgICBhbCA9IGEubCxcbiAgICAgICAgYmggPSBpc05hTihiLmgpID8gMCA6IGIuaCAtIGFoLFxuICAgICAgICBicyA9IGlzTmFOKGIucykgPyAwIDogYi5zIC0gYXMsXG4gICAgICAgIGJsID0gYi5sIC0gYWw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGEuaCA9IGFoICsgYmggKiB0O1xuICAgICAgYS5zID0gYXMgKyBicyAqIHQ7XG4gICAgICBhLmwgPSBhbCArIGJsICogdDtcbiAgICAgIHJldHVybiBhICsgXCJcIjtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGVIc2woYSwgYikge1xuICAgIGEgPSBoc2woYSk7XG4gICAgYiA9IGhzbChiKTtcbiAgICB2YXIgYWggPSBpc05hTihhLmgpID8gYi5oIDogYS5oLFxuICAgICAgICBhcyA9IGlzTmFOKGEucykgPyBiLnMgOiBhLnMsXG4gICAgICAgIGFsID0gYS5sLFxuICAgICAgICBiaCA9IGlzTmFOKGIuaCkgPyAwIDogZGVsdGFIdWUoYi5oLCBhaCksXG4gICAgICAgIGJzID0gaXNOYU4oYi5zKSA/IDAgOiBiLnMgLSBhcyxcbiAgICAgICAgYmwgPSBiLmwgLSBhbDtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgYS5oID0gYWggKyBiaCAqIHQ7XG4gICAgICBhLnMgPSBhcyArIGJzICogdDtcbiAgICAgIGEubCA9IGFsICsgYmwgKiB0O1xuICAgICAgcmV0dXJuIGEgKyBcIlwiO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZVJnYihhLCBiKSB7XG4gICAgYSA9IHJnYihhKTtcbiAgICBiID0gcmdiKGIpO1xuICAgIHZhciBhciA9IGEucixcbiAgICAgICAgYWcgPSBhLmcsXG4gICAgICAgIGFiID0gYS5iLFxuICAgICAgICBiciA9IGIuciAtIGFyLFxuICAgICAgICBiZyA9IGIuZyAtIGFnLFxuICAgICAgICBiYiA9IGIuYiAtIGFiO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gZm9ybWF0KE1hdGgucm91bmQoYXIgKyBiciAqIHQpLCBNYXRoLnJvdW5kKGFnICsgYmcgKiB0KSwgTWF0aC5yb3VuZChhYiArIGJiICogdCkpO1xuICAgIH07XG4gIH1cblxuICBleHBvcnRzLmludGVycG9sYXRlQ3ViZWhlbGl4ID0gaW50ZXJwb2xhdGVDdWJlaGVsaXhHYW1tYSgxKTtcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmcgPSBpbnRlcnBvbGF0ZUN1YmVoZWxpeEdhbW1hTG9uZygxKTtcblxuICBleHBvcnRzLmNvbG9yID0gY29sb3I7XG4gIGV4cG9ydHMucmdiID0gcmdiO1xuICBleHBvcnRzLmhzbCA9IGhzbDtcbiAgZXhwb3J0cy5sYWIgPSBsYWI7XG4gIGV4cG9ydHMuaGNsID0gaGNsO1xuICBleHBvcnRzLmN1YmVoZWxpeCA9IGN1YmVoZWxpeDtcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZVJnYiA9IGludGVycG9sYXRlUmdiO1xuICBleHBvcnRzLmludGVycG9sYXRlSHNsID0gaW50ZXJwb2xhdGVIc2w7XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVIc2xMb25nID0gaW50ZXJwb2xhdGVIc2xMb25nO1xuICBleHBvcnRzLmludGVycG9sYXRlTGFiID0gaW50ZXJwb2xhdGVMYWI7XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVIY2wgPSBpbnRlcnBvbGF0ZUhjbDtcbiAgZXhwb3J0cy5pbnRlcnBvbGF0ZUhjbExvbmcgPSBpbnRlcnBvbGF0ZUhjbExvbmc7XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVDdWJlaGVsaXhHYW1tYSA9IGludGVycG9sYXRlQ3ViZWhlbGl4R2FtbWE7XG4gIGV4cG9ydHMuaW50ZXJwb2xhdGVDdWJlaGVsaXhHYW1tYUxvbmcgPSBpbnRlcnBvbGF0ZUN1YmVoZWxpeEdhbW1hTG9uZztcblxufSkpOyIsImlmICh0eXBlb2YgTWFwID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIE1hcCA9IGZ1bmN0aW9uKCkgeyB0aGlzLmNsZWFyKCk7IH07XG4gIE1hcC5wcm90b3R5cGUgPSB7XG4gICAgc2V0OiBmdW5jdGlvbihrLCB2KSB7IHRoaXMuX1trXSA9IHY7IHJldHVybiB0aGlzOyB9LFxuICAgIGdldDogZnVuY3Rpb24oaykgeyByZXR1cm4gdGhpcy5fW2tdOyB9LFxuICAgIGhhczogZnVuY3Rpb24oaykgeyByZXR1cm4gayBpbiB0aGlzLl87IH0sXG4gICAgZGVsZXRlOiBmdW5jdGlvbihrKSB7IHJldHVybiBrIGluIHRoaXMuXyAmJiBkZWxldGUgdGhpcy5fW2tdOyB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbigpIHsgdGhpcy5fID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfSxcbiAgICBnZXQgc2l6ZSgpIHsgdmFyIG4gPSAwOyBmb3IgKHZhciBrIGluIHRoaXMuXykgKytuOyByZXR1cm4gbjsgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbihjKSB7IGZvciAodmFyIGsgaW4gdGhpcy5fKSBjKHRoaXMuX1trXSwgaywgdGhpcyk7IH1cbiAgfTtcbn0gZWxzZSAoZnVuY3Rpb24oKSB7XG4gIHZhciBtID0gbmV3IE1hcDtcbiAgaWYgKG0uc2V0KDAsIDApICE9PSBtKSB7XG4gICAgbSA9IG0uc2V0O1xuICAgIE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oKSB7IG0uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgcmV0dXJuIHRoaXM7IH07XG4gIH1cbn0pKCk7XG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgZmFjdG9yeSgoZ2xvYmFsLmZvcm1hdCA9IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgemhDbiA9IHtcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB0aG91c2FuZHM6IFwiLFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIsKlXCIsIFwiXCJdXG4gIH07XG5cbiAgdmFyIHJ1UnUgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIlxceGEwXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwiXFx4YTDRgNGD0LEuXCJdXG4gIH07XG5cbiAgdmFyIHB0QnIgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIi5cIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJSJFwiLCBcIlwiXVxuICB9O1xuXG4gIHZhciBwbFBsID0ge1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCIuXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwiesWCXCJdXG4gIH07XG5cbiAgdmFyIG5sTmwgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIi5cIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCLigqxcXHhhMFwiLCBcIlwiXVxuICB9O1xuXG4gIHZhciBta01rID0ge1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCIuXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwiXFx4YTDQtNC10L0uXCJdXG4gIH07XG5cbiAgdmFyIGl0SXQgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIi5cIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCLigqxcIiwgXCJcIl1cbiAgfTtcblxuICB2YXIgaGVJbCA9IHtcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB0aG91c2FuZHM6IFwiLFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIuKCqlwiLCBcIlwiXVxuICB9O1xuXG4gIHZhciBmckZyID0ge1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCIuXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwiXFx4YTDigqxcIl1cbiAgfTtcblxuICB2YXIgZnJDYSA9IHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiXFx4YTBcIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCIkXCJdXG4gIH07XG5cbiAgdmFyIGZpRmkgPSB7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIlxceGEwXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwiXFx4YTDigqxcIl1cbiAgfTtcblxuICB2YXIgZXNFcyA9IHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiLlwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIlwiLCBcIlxceGEw4oKsXCJdXG4gIH07XG5cbiAgdmFyIGVuVXMgPSB7XG4gICAgZGVjaW1hbDogXCIuXCIsXG4gICAgdGhvdXNhbmRzOiBcIixcIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCIkXCIsIFwiXCJdXG4gIH07XG5cbiAgdmFyIGVuR2IgPSB7XG4gICAgZGVjaW1hbDogXCIuXCIsXG4gICAgdGhvdXNhbmRzOiBcIixcIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCLCo1wiLCBcIlwiXVxuICB9O1xuXG4gIHZhciBlbkNhID0ge1xuICAgIGRlY2ltYWw6IFwiLlwiLFxuICAgIHRob3VzYW5kczogXCIsXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiJFwiLCBcIlwiXVxuICB9O1xuXG4gIHZhciBkZURlID0ge1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCIuXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwiXFx4YTDigqxcIl1cbiAgfTtcblxuICB2YXIgY2FFcyA9IHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiLlwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIlwiLCBcIlxceGEw4oKsXCJdXG4gIH07XG5cblxuICAvLyBDb21wdXRlcyB0aGUgZGVjaW1hbCBjb2VmZmljaWVudCBhbmQgZXhwb25lbnQgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgeCB3aXRoXG4gIC8vIHNpZ25pZmljYW50IGRpZ2l0cyBwLCB3aGVyZSB4IGlzIHBvc2l0aXZlIGFuZCBwIGlzIGluIFsxLCAyMV0gb3IgdW5kZWZpbmVkLlxuICAvLyBGb3IgZXhhbXBsZSwgZm9ybWF0RGVjaW1hbCgxLjIzKSByZXR1cm5zIFtcIjEyM1wiLCAwXS5cbiAgZnVuY3Rpb24gZm9ybWF0RGVjaW1hbCh4LCBwKSB7XG4gICAgaWYgKChpID0gKHggPSBwID8geC50b0V4cG9uZW50aWFsKHAgLSAxKSA6IHgudG9FeHBvbmVudGlhbCgpKS5pbmRleE9mKFwiZVwiKSkgPCAwKSByZXR1cm4gbnVsbDsgLy8gTmFOLCDCsUluZmluaXR5XG4gICAgdmFyIGksIGNvZWZmaWNpZW50ID0geC5zbGljZSgwLCBpKTtcblxuICAgIC8vIFRoZSBzdHJpbmcgcmV0dXJuZWQgYnkgdG9FeHBvbmVudGlhbCBlaXRoZXIgaGFzIHRoZSBmb3JtIFxcZFxcLlxcZCtlWy0rXVxcZCtcbiAgICAvLyAoZS5nLiwgMS4yZSszKSBvciB0aGUgZm9ybSBcXGRlWy0rXVxcZCsgKGUuZy4sIDFlKzMpLlxuICAgIHJldHVybiBbXG4gICAgICBjb2VmZmljaWVudC5sZW5ndGggPiAxID8gY29lZmZpY2llbnRbMF0gKyBjb2VmZmljaWVudC5zbGljZSgyKSA6IGNvZWZmaWNpZW50LFxuICAgICAgK3guc2xpY2UoaSArIDEpXG4gICAgXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cG9uZW50KHgpIHtcbiAgICByZXR1cm4geCA9IGZvcm1hdERlY2ltYWwoTWF0aC5hYnMoeCkpLCB4ID8geFsxXSA6IE5hTjtcbiAgfVxuXG4gIHZhciBwcmVmaXhFeHBvbmVudDtcblxuICBmdW5jdGlvbiBmb3JtYXRQcmVmaXhBdXRvKHgsIHApIHtcbiAgICB2YXIgZCA9IGZvcm1hdERlY2ltYWwoeCwgcCk7XG4gICAgaWYgKCFkKSByZXR1cm4geCArIFwiXCI7XG4gICAgdmFyIGNvZWZmaWNpZW50ID0gZFswXSxcbiAgICAgICAgZXhwb25lbnQgPSBkWzFdLFxuICAgICAgICBpID0gZXhwb25lbnQgLSAocHJlZml4RXhwb25lbnQgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCAvIDMpKSkgKiAzKSArIDEsXG4gICAgICAgIG4gPSBjb2VmZmljaWVudC5sZW5ndGg7XG4gICAgcmV0dXJuIGkgPT09IG4gPyBjb2VmZmljaWVudFxuICAgICAgICA6IGkgPiBuID8gY29lZmZpY2llbnQgKyBuZXcgQXJyYXkoaSAtIG4gKyAxKS5qb2luKFwiMFwiKVxuICAgICAgICA6IGkgPiAwID8gY29lZmZpY2llbnQuc2xpY2UoMCwgaSkgKyBcIi5cIiArIGNvZWZmaWNpZW50LnNsaWNlKGkpXG4gICAgICAgIDogXCIwLlwiICsgbmV3IEFycmF5KDEgLSBpKS5qb2luKFwiMFwiKSArIGZvcm1hdERlY2ltYWwoeCwgcCArIGkgLSAxKVswXTsgLy8gbGVzcyB0aGFuIDF5IVxuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0Um91bmRlZCh4LCBwKSB7XG4gICAgdmFyIGQgPSBmb3JtYXREZWNpbWFsKHgsIHApO1xuICAgIGlmICghZCkgcmV0dXJuIHggKyBcIlwiO1xuICAgIHZhciBjb2VmZmljaWVudCA9IGRbMF0sXG4gICAgICAgIGV4cG9uZW50ID0gZFsxXTtcbiAgICByZXR1cm4gZXhwb25lbnQgPCAwID8gXCIwLlwiICsgbmV3IEFycmF5KC1leHBvbmVudCkuam9pbihcIjBcIikgKyBjb2VmZmljaWVudFxuICAgICAgICA6IGNvZWZmaWNpZW50Lmxlbmd0aCA+IGV4cG9uZW50ICsgMSA/IGNvZWZmaWNpZW50LnNsaWNlKDAsIGV4cG9uZW50ICsgMSkgKyBcIi5cIiArIGNvZWZmaWNpZW50LnNsaWNlKGV4cG9uZW50ICsgMSlcbiAgICAgICAgOiBjb2VmZmljaWVudCArIG5ldyBBcnJheShleHBvbmVudCAtIGNvZWZmaWNpZW50Lmxlbmd0aCArIDIpLmpvaW4oXCIwXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0RGVmYXVsdCh4LCBwKSB7XG4gICAgeCA9IHgudG9QcmVjaXNpb24ocCk7XG5cbiAgICBvdXQ6IGZvciAodmFyIG4gPSB4Lmxlbmd0aCwgaSA9IDEsIGkwID0gLTEsIGkxOyBpIDwgbjsgKytpKSB7XG4gICAgICBzd2l0Y2ggKHhbaV0pIHtcbiAgICAgICAgY2FzZSBcIi5cIjogaTAgPSBpMSA9IGk7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiMFwiOiBpZiAoaTAgPT09IDApIGkwID0gaTsgaTEgPSBpOyBicmVhaztcbiAgICAgICAgY2FzZSBcImVcIjogYnJlYWsgb3V0O1xuICAgICAgICBkZWZhdWx0OiBpZiAoaTAgPiAwKSBpMCA9IDA7IGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpMCA+IDAgPyB4LnNsaWNlKDAsIGkwKSArIHguc2xpY2UoaTEgKyAxKSA6IHg7XG4gIH1cblxuICB2YXIgZm9ybWF0VHlwZXMgPSB7XG4gICAgXCJcIjogZm9ybWF0RGVmYXVsdCxcbiAgICBcIiVcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4gKHggKiAxMDApLnRvRml4ZWQocCk7IH0sXG4gICAgXCJiXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMik7IH0sXG4gICAgXCJjXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggKyBcIlwiOyB9LFxuICAgIFwiZFwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDEwKTsgfSxcbiAgICBcImVcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4geC50b0V4cG9uZW50aWFsKHApOyB9LFxuICAgIFwiZlwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvRml4ZWQocCk7IH0sXG4gICAgXCJnXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIHgudG9QcmVjaXNpb24ocCk7IH0sXG4gICAgXCJvXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoOCk7IH0sXG4gICAgXCJwXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIGZvcm1hdFJvdW5kZWQoeCAqIDEwMCwgcCk7IH0sXG4gICAgXCJyXCI6IGZvcm1hdFJvdW5kZWQsXG4gICAgXCJzXCI6IGZvcm1hdFByZWZpeEF1dG8sXG4gICAgXCJYXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IH0sXG4gICAgXCJ4XCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTYpOyB9XG4gIH07XG5cblxuICAvLyBbW2ZpbGxdYWxpZ25dW3NpZ25dW3N5bWJvbF1bMF1bd2lkdGhdWyxdWy5wcmVjaXNpb25dW3R5cGVdXG4gIHZhciByZSA9IC9eKD86KC4pPyhbPD49Xl0pKT8oWytcXC1cXCggXSk/KFskI10pPygwKT8oXFxkKyk/KCwpPyhcXC5cXGQrKT8oW2EteiVdKT8kL2k7XG5cbiAgZnVuY3Rpb24gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikge1xuICAgIHJldHVybiBuZXcgRm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcik7XG4gIH1cblxuICBmdW5jdGlvbiBGb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSB7XG4gICAgaWYgKCEobWF0Y2ggPSByZS5leGVjKHNwZWNpZmllcikpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZvcm1hdDogXCIgKyBzcGVjaWZpZXIpO1xuXG4gICAgdmFyIG1hdGNoLFxuICAgICAgICBmaWxsID0gbWF0Y2hbMV0gfHwgXCIgXCIsXG4gICAgICAgIGFsaWduID0gbWF0Y2hbMl0gfHwgXCI+XCIsXG4gICAgICAgIHNpZ24gPSBtYXRjaFszXSB8fCBcIi1cIixcbiAgICAgICAgc3ltYm9sID0gbWF0Y2hbNF0gfHwgXCJcIixcbiAgICAgICAgemVybyA9ICEhbWF0Y2hbNV0sXG4gICAgICAgIHdpZHRoID0gbWF0Y2hbNl0gJiYgK21hdGNoWzZdLFxuICAgICAgICBjb21tYSA9ICEhbWF0Y2hbN10sXG4gICAgICAgIHByZWNpc2lvbiA9IG1hdGNoWzhdICYmICttYXRjaFs4XS5zbGljZSgxKSxcbiAgICAgICAgdHlwZSA9IG1hdGNoWzldIHx8IFwiXCI7XG5cbiAgICAvLyBUaGUgXCJuXCIgdHlwZSBpcyBhbiBhbGlhcyBmb3IgXCIsZ1wiLlxuICAgIGlmICh0eXBlID09PSBcIm5cIikgY29tbWEgPSB0cnVlLCB0eXBlID0gXCJnXCI7XG5cbiAgICAvLyBNYXAgaW52YWxpZCB0eXBlcyB0byB0aGUgZGVmYXVsdCBmb3JtYXQuXG4gICAgZWxzZSBpZiAoIWZvcm1hdFR5cGVzW3R5cGVdKSB0eXBlID0gXCJcIjtcblxuICAgIC8vIElmIHplcm8gZmlsbCBpcyBzcGVjaWZpZWQsIHBhZGRpbmcgZ29lcyBhZnRlciBzaWduIGFuZCBiZWZvcmUgZGlnaXRzLlxuICAgIGlmICh6ZXJvIHx8IChmaWxsID09PSBcIjBcIiAmJiBhbGlnbiA9PT0gXCI9XCIpKSB6ZXJvID0gdHJ1ZSwgZmlsbCA9IFwiMFwiLCBhbGlnbiA9IFwiPVwiO1xuXG4gICAgdGhpcy5maWxsID0gZmlsbDtcbiAgICB0aGlzLmFsaWduID0gYWxpZ247XG4gICAgdGhpcy5zaWduID0gc2lnbjtcbiAgICB0aGlzLnN5bWJvbCA9IHN5bWJvbDtcbiAgICB0aGlzLnplcm8gPSB6ZXJvO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmNvbW1hID0gY29tbWE7XG4gICAgdGhpcy5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuXG4gIEZvcm1hdFNwZWNpZmllci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5maWxsXG4gICAgICAgICsgdGhpcy5hbGlnblxuICAgICAgICArIHRoaXMuc2lnblxuICAgICAgICArIHRoaXMuc3ltYm9sXG4gICAgICAgICsgKHRoaXMuemVybyA/IFwiMFwiIDogXCJcIilcbiAgICAgICAgKyAodGhpcy53aWR0aCA9PSBudWxsID8gXCJcIiA6IE1hdGgubWF4KDEsIHRoaXMud2lkdGggfCAwKSlcbiAgICAgICAgKyAodGhpcy5jb21tYSA/IFwiLFwiIDogXCJcIilcbiAgICAgICAgKyAodGhpcy5wcmVjaXNpb24gPT0gbnVsbCA/IFwiXCIgOiBcIi5cIiArIE1hdGgubWF4KDAsIHRoaXMucHJlY2lzaW9uIHwgMCkpXG4gICAgICAgICsgdGhpcy50eXBlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZvcm1hdEdyb3VwKGdyb3VwaW5nLCB0aG91c2FuZHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIHdpZHRoKSB7XG4gICAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICB0ID0gW10sXG4gICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgZyA9IGdyb3VwaW5nWzBdLFxuICAgICAgICAgIGxlbmd0aCA9IDA7XG5cbiAgICAgIHdoaWxlIChpID4gMCAmJiBnID4gMCkge1xuICAgICAgICBpZiAobGVuZ3RoICsgZyArIDEgPiB3aWR0aCkgZyA9IE1hdGgubWF4KDEsIHdpZHRoIC0gbGVuZ3RoKTtcbiAgICAgICAgdC5wdXNoKHZhbHVlLnN1YnN0cmluZyhpIC09IGcsIGkgKyBnKSk7XG4gICAgICAgIGlmICgobGVuZ3RoICs9IGcgKyAxKSA+IHdpZHRoKSBicmVhaztcbiAgICAgICAgZyA9IGdyb3VwaW5nW2ogPSAoaiArIDEpICUgZ3JvdXBpbmcubGVuZ3RoXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQucmV2ZXJzZSgpLmpvaW4odGhvdXNhbmRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHByZWZpeGVzID0gW1wieVwiLFwielwiLFwiYVwiLFwiZlwiLFwicFwiLFwiblwiLFwiwrVcIixcIm1cIixcIlwiLFwia1wiLFwiTVwiLFwiR1wiLFwiVFwiLFwiUFwiLFwiRVwiLFwiWlwiLFwiWVwiXTtcblxuICBmdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cblxuICBmdW5jdGlvbiBsb2NhbGUobG9jYWxlKSB7XG4gICAgdmFyIGdyb3VwID0gbG9jYWxlLmdyb3VwaW5nICYmIGxvY2FsZS50aG91c2FuZHMgPyBmb3JtYXRHcm91cChsb2NhbGUuZ3JvdXBpbmcsIGxvY2FsZS50aG91c2FuZHMpIDogaWRlbnRpdHksXG4gICAgICAgIGN1cnJlbmN5ID0gbG9jYWxlLmN1cnJlbmN5LFxuICAgICAgICBkZWNpbWFsID0gbG9jYWxlLmRlY2ltYWw7XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQoc3BlY2lmaWVyKSB7XG4gICAgICBzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKTtcblxuICAgICAgdmFyIGZpbGwgPSBzcGVjaWZpZXIuZmlsbCxcbiAgICAgICAgICBhbGlnbiA9IHNwZWNpZmllci5hbGlnbixcbiAgICAgICAgICBzaWduID0gc3BlY2lmaWVyLnNpZ24sXG4gICAgICAgICAgc3ltYm9sID0gc3BlY2lmaWVyLnN5bWJvbCxcbiAgICAgICAgICB6ZXJvID0gc3BlY2lmaWVyLnplcm8sXG4gICAgICAgICAgd2lkdGggPSBzcGVjaWZpZXIud2lkdGgsXG4gICAgICAgICAgY29tbWEgPSBzcGVjaWZpZXIuY29tbWEsXG4gICAgICAgICAgcHJlY2lzaW9uID0gc3BlY2lmaWVyLnByZWNpc2lvbixcbiAgICAgICAgICB0eXBlID0gc3BlY2lmaWVyLnR5cGU7XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxuICAgICAgLy8gRm9yIFNJLXByZWZpeCwgdGhlIHN1ZmZpeCBpcyBsYXppbHkgY29tcHV0ZWQuXG4gICAgICB2YXIgcHJlZml4ID0gc3ltYm9sID09PSBcIiRcIiA/IGN1cnJlbmN5WzBdIDogc3ltYm9sID09PSBcIiNcIiAmJiAvW2JveFhdLy50ZXN0KHR5cGUpID8gXCIwXCIgKyB0eXBlLnRvTG93ZXJDYXNlKCkgOiBcIlwiLFxuICAgICAgICAgIHN1ZmZpeCA9IHN5bWJvbCA9PT0gXCIkXCIgPyBjdXJyZW5jeVsxXSA6IC9bJXBdLy50ZXN0KHR5cGUpID8gXCIlXCIgOiBcIlwiO1xuXG4gICAgICAvLyBXaGF0IGZvcm1hdCBmdW5jdGlvbiBzaG91bGQgd2UgdXNlP1xuICAgICAgLy8gSXMgdGhpcyBhbiBpbnRlZ2VyIHR5cGU/XG4gICAgICAvLyBDYW4gdGhpcyB0eXBlIGdlbmVyYXRlIGV4cG9uZW50aWFsIG5vdGF0aW9uP1xuICAgICAgdmFyIGZvcm1hdFR5cGUgPSBmb3JtYXRUeXBlc1t0eXBlXSxcbiAgICAgICAgICBtYXliZVN1ZmZpeCA9ICF0eXBlIHx8IC9bZGVmZ3BycyVdLy50ZXN0KHR5cGUpO1xuXG4gICAgICAvLyBTZXQgdGhlIGRlZmF1bHQgcHJlY2lzaW9uIGlmIG5vdCBzcGVjaWZpZWQsXG4gICAgICAvLyBvciBjbGFtcCB0aGUgc3BlY2lmaWVkIHByZWNpc2lvbiB0byB0aGUgc3VwcG9ydGVkIHJhbmdlLlxuICAgICAgLy8gRm9yIHNpZ25pZmljYW50IHByZWNpc2lvbiwgaXQgbXVzdCBiZSBpbiBbMSwgMjFdLlxuICAgICAgLy8gRm9yIGZpeGVkIHByZWNpc2lvbiwgaXQgbXVzdCBiZSBpbiBbMCwgMjBdLlxuICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uID09IG51bGwgPyAodHlwZSA/IDYgOiAxMilcbiAgICAgICAgICA6IC9bZ3Byc10vLnRlc3QodHlwZSkgPyBNYXRoLm1heCgxLCBNYXRoLm1pbigyMSwgcHJlY2lzaW9uKSlcbiAgICAgICAgICA6IE1hdGgubWF4KDAsIE1hdGgubWluKDIwLCBwcmVjaXNpb24pKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciB2YWx1ZVByZWZpeCA9IHByZWZpeCxcbiAgICAgICAgICAgIHZhbHVlU3VmZml4ID0gc3VmZml4O1xuXG4gICAgICAgIGlmICh0eXBlID09PSBcImNcIikge1xuICAgICAgICAgIHZhbHVlU3VmZml4ID0gZm9ybWF0VHlwZSh2YWx1ZSkgKyB2YWx1ZVN1ZmZpeDtcbiAgICAgICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSArdmFsdWU7XG5cbiAgICAgICAgICAvLyBDb252ZXJ0IG5lZ2F0aXZlIHRvIHBvc2l0aXZlLCBhbmQgY29tcHV0ZSB0aGUgcHJlZml4LlxuICAgICAgICAgIC8vIE5vdGUgdGhhdCAtMCBpcyBub3QgbGVzcyB0aGFuIDAsIGJ1dCAxIC8gLTAgaXMhXG4gICAgICAgICAgdmFyIHZhbHVlTmVnYXRpdmUgPSAodmFsdWUgPCAwIHx8IDEgLyB2YWx1ZSA8IDApICYmICh2YWx1ZSAqPSAtMSwgdHJ1ZSk7XG5cbiAgICAgICAgICAvLyBQZXJmb3JtIHRoZSBpbml0aWFsIGZvcm1hdHRpbmcuXG4gICAgICAgICAgdmFsdWUgPSBmb3JtYXRUeXBlKHZhbHVlLCBwcmVjaXNpb24pO1xuXG4gICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gICAgICAgICAgdmFsdWVQcmVmaXggPSAodmFsdWVOZWdhdGl2ZSA/IChzaWduID09PSBcIihcIiA/IHNpZ24gOiBcIi1cIikgOiBzaWduID09PSBcIi1cIiB8fCBzaWduID09PSBcIihcIiA/IFwiXCIgOiBzaWduKSArIHZhbHVlUHJlZml4O1xuICAgICAgICAgIHZhbHVlU3VmZml4ID0gdmFsdWVTdWZmaXggKyAodHlwZSA9PT0gXCJzXCIgPyBwcmVmaXhlc1s4ICsgcHJlZml4RXhwb25lbnQgLyAzXSA6IFwiXCIpICsgKHZhbHVlTmVnYXRpdmUgJiYgc2lnbiA9PT0gXCIoXCIgPyBcIilcIiA6IFwiXCIpO1xuXG4gICAgICAgICAgLy8gQnJlYWsgdGhlIGZvcm1hdHRlZCB2YWx1ZSBpbnRvIHRoZSBpbnRlZ2VyIOKAnHZhbHVl4oCdIHBhcnQgdGhhdCBjYW4gYmVcbiAgICAgICAgICAvLyBncm91cGVkLCBhbmQgZnJhY3Rpb25hbCBvciBleHBvbmVudGlhbCDigJxzdWZmaXjigJ0gcGFydCB0aGF0IGlzIG5vdC5cbiAgICAgICAgICBpZiAobWF5YmVTdWZmaXgpIHtcbiAgICAgICAgICAgIHZhciBpID0gLTEsIG4gPSB2YWx1ZS5sZW5ndGgsIGM7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICBpZiAoYyA9IHZhbHVlLmNoYXJDb2RlQXQoaSksIDQ4ID4gYyB8fCBjID4gNTcpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IChjID09PSA0NiA/IGRlY2ltYWwgKyB2YWx1ZS5zbGljZShpICsgMSkgOiB2YWx1ZS5zbGljZShpKSkgKyB2YWx1ZVN1ZmZpeDtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGZpbGwgY2hhcmFjdGVyIGlzIG5vdCBcIjBcIiwgZ3JvdXBpbmcgaXMgYXBwbGllZCBiZWZvcmUgcGFkZGluZy5cbiAgICAgICAgaWYgKGNvbW1hICYmICF6ZXJvKSB2YWx1ZSA9IGdyb3VwKHZhbHVlLCBJbmZpbml0eSk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcGFkZGluZy5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlUHJlZml4Lmxlbmd0aCArIHZhbHVlLmxlbmd0aCArIHZhbHVlU3VmZml4Lmxlbmd0aCxcbiAgICAgICAgICAgIHBhZGRpbmcgPSBsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgOiBcIlwiO1xuXG4gICAgICAgIC8vIElmIHRoZSBmaWxsIGNoYXJhY3RlciBpcyBcIjBcIiwgZ3JvdXBpbmcgaXMgYXBwbGllZCBhZnRlciBwYWRkaW5nLlxuICAgICAgICBpZiAoY29tbWEgJiYgemVybykgdmFsdWUgPSBncm91cChwYWRkaW5nICsgdmFsdWUsIHBhZGRpbmcubGVuZ3RoID8gd2lkdGggLSB2YWx1ZVN1ZmZpeC5sZW5ndGggOiBJbmZpbml0eSksIHBhZGRpbmcgPSBcIlwiO1xuXG4gICAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBmaW5hbCBvdXRwdXQgYmFzZWQgb24gdGhlIGRlc2lyZWQgYWxpZ25tZW50LlxuICAgICAgICBzd2l0Y2ggKGFsaWduKSB7XG4gICAgICAgICAgY2FzZSBcIjxcIjogcmV0dXJuIHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeCArIHBhZGRpbmc7XG4gICAgICAgICAgY2FzZSBcIj1cIjogcmV0dXJuIHZhbHVlUHJlZml4ICsgcGFkZGluZyArIHZhbHVlICsgdmFsdWVTdWZmaXg7XG4gICAgICAgICAgY2FzZSBcIl5cIjogcmV0dXJuIHBhZGRpbmcuc2xpY2UoMCwgbGVuZ3RoID0gcGFkZGluZy5sZW5ndGggPj4gMSkgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXggKyBwYWRkaW5nLnNsaWNlKGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhZGRpbmcgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXg7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFByZWZpeChzcGVjaWZpZXIsIHZhbHVlKSB7XG4gICAgICB2YXIgZiA9IGZvcm1hdCgoc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllciksIHNwZWNpZmllci50eXBlID0gXCJmXCIsIHNwZWNpZmllcikpLFxuICAgICAgICAgIGUgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyxcbiAgICAgICAgICBrID0gTWF0aC5wb3coMTAsIC1lKSxcbiAgICAgICAgICBwcmVmaXggPSBwcmVmaXhlc1s4ICsgZSAvIDNdO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmKGsgKiB2YWx1ZSkgKyBwcmVmaXg7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICAgIGZvcm1hdFByZWZpeDogZm9ybWF0UHJlZml4XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZWNpc2lvblJvdW5kKHN0ZXAsIG1heCkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBleHBvbmVudChNYXRoLmFicyhtYXgpKSAtIGV4cG9uZW50KE1hdGguYWJzKHN0ZXApKSkgKyAxO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlY2lzaW9uUHJlZml4KHN0ZXAsIHZhbHVlKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50KHZhbHVlKSAvIDMpKSkgKiAzIC0gZXhwb25lbnQoTWF0aC5hYnMoc3RlcCkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZWNpc2lvbkZpeGVkKHN0ZXApIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgLWV4cG9uZW50KE1hdGguYWJzKHN0ZXApKSk7XG4gIH1cblxuICB2YXIgbG9jYWxlRGVmaW5pdGlvbnMgPSAobmV3IE1hcClcbiAgICAgIC5zZXQoXCJjYS1FU1wiLCBjYUVzKVxuICAgICAgLnNldChcImRlLURFXCIsIGRlRGUpXG4gICAgICAuc2V0KFwiZW4tQ0FcIiwgZW5DYSlcbiAgICAgIC5zZXQoXCJlbi1HQlwiLCBlbkdiKVxuICAgICAgLnNldChcImVuLVVTXCIsIGVuVXMpXG4gICAgICAuc2V0KFwiZXMtRVNcIiwgZXNFcylcbiAgICAgIC5zZXQoXCJmaS1GSVwiLCBmaUZpKVxuICAgICAgLnNldChcImZyLUNBXCIsIGZyQ2EpXG4gICAgICAuc2V0KFwiZnItRlJcIiwgZnJGcilcbiAgICAgIC5zZXQoXCJoZS1JTFwiLCBoZUlsKVxuICAgICAgLnNldChcIml0LUlUXCIsIGl0SXQpXG4gICAgICAuc2V0KFwibWstTUtcIiwgbWtNaylcbiAgICAgIC5zZXQoXCJubC1OTFwiLCBubE5sKVxuICAgICAgLnNldChcInBsLVBMXCIsIHBsUGwpXG4gICAgICAuc2V0KFwicHQtQlJcIiwgcHRCcilcbiAgICAgIC5zZXQoXCJydS1SVVwiLCBydVJ1KVxuICAgICAgLnNldChcInpoLUNOXCIsIHpoQ24pO1xuXG4gIHZhciBkZWZhdWx0TG9jYWxlID0gbG9jYWxlKGVuVXMpO1xuICBleHBvcnRzLmZvcm1hdCA9IGRlZmF1bHRMb2NhbGUuZm9ybWF0O1xuICBleHBvcnRzLmZvcm1hdFByZWZpeCA9IGRlZmF1bHRMb2NhbGUuZm9ybWF0UHJlZml4O1xuXG4gIGZ1bmN0aW9uIGxvY2FsZUZvcm1hdChkZWZpbml0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBkZWZpbml0aW9uID0gbG9jYWxlRGVmaW5pdGlvbnMuZ2V0KGRlZmluaXRpb24pO1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZShkZWZpbml0aW9uKTtcbiAgfVxuICA7XG5cbiAgZXhwb3J0cy5sb2NhbGVGb3JtYXQgPSBsb2NhbGVGb3JtYXQ7XG4gIGV4cG9ydHMuZm9ybWF0U3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyO1xuICBleHBvcnRzLnByZWNpc2lvbkZpeGVkID0gcHJlY2lzaW9uRml4ZWQ7XG4gIGV4cG9ydHMucHJlY2lzaW9uUHJlZml4ID0gcHJlY2lzaW9uUHJlZml4O1xuICBleHBvcnRzLnByZWNpc2lvblJvdW5kID0gcHJlY2lzaW9uUm91bmQ7XG5cbn0pKTsiLCJpZiAodHlwZW9mIE1hcCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICBNYXAgPSBmdW5jdGlvbigpIHsgdGhpcy5jbGVhcigpOyB9O1xuICBNYXAucHJvdG90eXBlID0ge1xuICAgIHNldDogZnVuY3Rpb24oaywgdikgeyB0aGlzLl9ba10gPSB2OyByZXR1cm4gdGhpczsgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKGspIHsgcmV0dXJuIHRoaXMuX1trXTsgfSxcbiAgICBoYXM6IGZ1bmN0aW9uKGspIHsgcmV0dXJuIGsgaW4gdGhpcy5fOyB9LFxuICAgIGRlbGV0ZTogZnVuY3Rpb24oaykgeyByZXR1cm4gayBpbiB0aGlzLl8gJiYgZGVsZXRlIHRoaXMuX1trXTsgfSxcbiAgICBjbGVhcjogZnVuY3Rpb24oKSB7IHRoaXMuXyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IH0sXG4gICAgZ2V0IHNpemUoKSB7IHZhciBuID0gMDsgZm9yICh2YXIgayBpbiB0aGlzLl8pICsrbjsgcmV0dXJuIG47IH0sXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oYykgeyBmb3IgKHZhciBrIGluIHRoaXMuXykgYyh0aGlzLl9ba10sIGssIHRoaXMpOyB9XG4gIH07XG59IGVsc2UgKGZ1bmN0aW9uKCkge1xuICB2YXIgbSA9IG5ldyBNYXA7XG4gIGlmIChtLnNldCgwLCAwKSAhPT0gbSkge1xuICAgIG0gPSBtLnNldDtcbiAgICBNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKCkgeyBtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiB0aGlzOyB9O1xuICB9XG59KSgpO1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIGZhY3RvcnkoKGdsb2JhbC50aW1lRm9ybWF0ID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB6aENuID0ge1xuICAgIGRhdGVUaW1lOiBcIiVhICViICVlICVYICVZXCIsXG4gICAgZGF0ZTogXCIlWS8lLW0vJS1kXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIuS4iuWNiFwiLCBcIuS4i+WNiFwiXSxcbiAgICBkYXlzOiBbXCLmmJ/mnJ/ml6VcIiwgXCLmmJ/mnJ/kuIBcIiwgXCLmmJ/mnJ/kuoxcIiwgXCLmmJ/mnJ/kuIlcIiwgXCLmmJ/mnJ/lm5tcIiwgXCLmmJ/mnJ/kupRcIiwgXCLmmJ/mnJ/lha1cIl0sXG4gICAgc2hvcnREYXlzOiBbXCLmmJ/mnJ/ml6VcIiwgXCLmmJ/mnJ/kuIBcIiwgXCLmmJ/mnJ/kuoxcIiwgXCLmmJ/mnJ/kuIlcIiwgXCLmmJ/mnJ/lm5tcIiwgXCLmmJ/mnJ/kupRcIiwgXCLmmJ/mnJ/lha1cIl0sXG4gICAgbW9udGhzOiBbXCLkuIDmnIhcIiwgXCLkuozmnIhcIiwgXCLkuInmnIhcIiwgXCLlm5vmnIhcIiwgXCLkupTmnIhcIiwgXCLlha3mnIhcIiwgXCLkuIPmnIhcIiwgXCLlhavmnIhcIiwgXCLkuZ3mnIhcIiwgXCLljYHmnIhcIiwgXCLljYHkuIDmnIhcIiwgXCLljYHkuozmnIhcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIuS4gOaciFwiLCBcIuS6jOaciFwiLCBcIuS4ieaciFwiLCBcIuWbm+aciFwiLCBcIuS6lOaciFwiLCBcIuWFreaciFwiLCBcIuS4g+aciFwiLCBcIuWFq+aciFwiLCBcIuS5neaciFwiLCBcIuWNgeaciFwiLCBcIuWNgeS4gOaciFwiLCBcIuWNgeS6jOaciFwiXVxuICB9O1xuXG4gIHZhciBydVJ1ID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBLCAlZSAlQiAlWSDQsy4gJVhcIixcbiAgICBkYXRlOiBcIiVkLiVtLiVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgZGF5czogW1wi0LLQvtGB0LrRgNC10YHQtdC90YzQtVwiLCBcItC/0L7QvdC10LTQtdC70YzQvdC40LpcIiwgXCLQstGC0L7RgNC90LjQulwiLCBcItGB0YDQtdC00LBcIiwgXCLRh9C10YLQstC10YDQs1wiLCBcItC/0Y/RgtC90LjRhtCwXCIsIFwi0YHRg9Cx0LHQvtGC0LBcIl0sXG4gICAgc2hvcnREYXlzOiBbXCLQstGBXCIsIFwi0L/QvVwiLCBcItCy0YJcIiwgXCLRgdGAXCIsIFwi0YfRglwiLCBcItC/0YJcIiwgXCLRgdCxXCJdLFxuICAgIG1vbnRoczogW1wi0Y/QvdCy0LDRgNGPXCIsIFwi0YTQtdCy0YDQsNC70Y9cIiwgXCLQvNCw0YDRgtCwXCIsIFwi0LDQv9GA0LXQu9GPXCIsIFwi0LzQsNGPXCIsIFwi0LjRjtC90Y9cIiwgXCLQuNGO0LvRj1wiLCBcItCw0LLQs9GD0YHRgtCwXCIsIFwi0YHQtdC90YLRj9Cx0YDRj1wiLCBcItC+0LrRgtGP0LHRgNGPXCIsIFwi0L3QvtGP0LHRgNGPXCIsIFwi0LTQtdC60LDQsdGA0Y9cIl0sXG4gICAgc2hvcnRNb250aHM6IFtcItGP0L3QslwiLCBcItGE0LXQslwiLCBcItC80LDRgFwiLCBcItCw0L/RgFwiLCBcItC80LDQuVwiLCBcItC40Y7QvVwiLCBcItC40Y7Qu1wiLCBcItCw0LLQs1wiLCBcItGB0LXQvVwiLCBcItC+0LrRglwiLCBcItC90L7Rj1wiLCBcItC00LXQulwiXVxuICB9O1xuXG4gIHZhciBwdEJyID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBLCAlZSBkZSAlQiBkZSAlWS4gJVhcIixcbiAgICBkYXRlOiBcIiVkLyVtLyVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgZGF5czogW1wiRG9taW5nb1wiLCBcIlNlZ3VuZGFcIiwgXCJUZXLDp2FcIiwgXCJRdWFydGFcIiwgXCJRdWludGFcIiwgXCJTZXh0YVwiLCBcIlPDoWJhZG9cIl0sXG4gICAgc2hvcnREYXlzOiBbXCJEb21cIiwgXCJTZWdcIiwgXCJUZXJcIiwgXCJRdWFcIiwgXCJRdWlcIiwgXCJTZXhcIiwgXCJTw6FiXCJdLFxuICAgIG1vbnRoczogW1wiSmFuZWlyb1wiLCBcIkZldmVyZWlyb1wiLCBcIk1hcsOnb1wiLCBcIkFicmlsXCIsIFwiTWFpb1wiLCBcIkp1bmhvXCIsIFwiSnVsaG9cIiwgXCJBZ29zdG9cIiwgXCJTZXRlbWJyb1wiLCBcIk91dHVicm9cIiwgXCJOb3ZlbWJyb1wiLCBcIkRlemVtYnJvXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJKYW5cIiwgXCJGZXZcIiwgXCJNYXJcIiwgXCJBYnJcIiwgXCJNYWlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBZ29cIiwgXCJTZXRcIiwgXCJPdXRcIiwgXCJOb3ZcIiwgXCJEZXpcIl1cbiAgfTtcblxuICB2YXIgcGxQbCA9IHtcbiAgICBkYXRlVGltZTogXCIlQSwgJWUgJUIgJVksICVYXCIsXG4gICAgZGF0ZTogXCIlZC8lbS8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLCAvLyB1bnVzZWRcbiAgICBkYXlzOiBbXCJOaWVkemllbGFcIiwgXCJQb25pZWR6aWHFgmVrXCIsIFwiV3RvcmVrXCIsIFwixZpyb2RhXCIsIFwiQ3p3YXJ0ZWtcIiwgXCJQacSFdGVrXCIsIFwiU29ib3RhXCJdLFxuICAgIHNob3J0RGF5czogW1wiTmllZHouXCIsIFwiUG9uLlwiLCBcIld0LlwiLCBcIsWaci5cIiwgXCJDencuXCIsIFwiUHQuXCIsIFwiU29iLlwiXSxcbiAgICBtb250aHM6IFtcIlN0eWN6ZcWEXCIsIFwiTHV0eVwiLCBcIk1hcnplY1wiLCBcIkt3aWVjaWXFhFwiLCBcIk1halwiLCBcIkN6ZXJ3aWVjXCIsIFwiTGlwaWVjXCIsIFwiU2llcnBpZcWEXCIsIFwiV3J6ZXNpZcWEXCIsIFwiUGHFumR6aWVybmlrXCIsIFwiTGlzdG9wYWRcIiwgXCJHcnVkemllxYRcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIlN0eWN6LlwiLCBcIkx1dHlcIiwgXCJNYXJ6LlwiLCBcIkt3aWUuXCIsIFwiTWFqXCIsIFwiQ3plcncuXCIsIFwiTGlwYy5cIiwgXCJTaWVycC5cIiwgXCJXcnouXCIsIFwiUGHFumR6LlwiLCBcIkxpc3RvcC5cIiwgXCJHcnVkei5cIl0vKiBJbiBQb2xpc2ggbGFuZ3VhZ2UgYWJicmF2aWF0ZWQgbW9udGhzIGFyZSBub3QgY29tbW9ubHkgdXNlZCBzbyB0aGVyZSBpcyBhIGRpc3B1dGUgYWJvdXQgdGhlIHByb3BlciBhYmJyYXZpYXRpb25zLiAqL1xuICB9O1xuXG4gIHZhciBubE5sID0ge1xuICAgIGRhdGVUaW1lOiBcIiVhICVlICVCICVZICVUXCIsXG4gICAgZGF0ZTogXCIlZC0lbS0lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLCAvLyB1bnVzZWRcbiAgICBkYXlzOiBbXCJ6b25kYWdcIiwgXCJtYWFuZGFnXCIsIFwiZGluc2RhZ1wiLCBcIndvZW5zZGFnXCIsIFwiZG9uZGVyZGFnXCIsIFwidnJpamRhZ1wiLCBcInphdGVyZGFnXCJdLFxuICAgIHNob3J0RGF5czogW1wiem9cIiwgXCJtYVwiLCBcImRpXCIsIFwid29cIiwgXCJkb1wiLCBcInZyXCIsIFwiemFcIl0sXG4gICAgbW9udGhzOiBbXCJqYW51YXJpXCIsIFwiZmVicnVhcmlcIiwgXCJtYWFydFwiLCBcImFwcmlsXCIsIFwibWVpXCIsIFwianVuaVwiLCBcImp1bGlcIiwgXCJhdWd1c3R1c1wiLCBcInNlcHRlbWJlclwiLCBcIm9rdG9iZXJcIiwgXCJub3ZlbWJlclwiLCBcImRlY2VtYmVyXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJqYW5cIiwgXCJmZWJcIiwgXCJtcnRcIiwgXCJhcHJcIiwgXCJtZWlcIiwgXCJqdW5cIiwgXCJqdWxcIiwgXCJhdWdcIiwgXCJzZXBcIiwgXCJva3RcIiwgXCJub3ZcIiwgXCJkZWNcIl1cbiAgfTtcblxuICB2YXIgbWtNayA9IHtcbiAgICBkYXRlVGltZTogXCIlQSwgJWUgJUIgJVkg0LMuICVYXCIsXG4gICAgZGF0ZTogXCIlZC4lbS4lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcItC90LXQtNC10LvQsFwiLCBcItC/0L7QvdC10LTQtdC70L3QuNC6XCIsIFwi0LLRgtC+0YDQvdC40LpcIiwgXCLRgdGA0LXQtNCwXCIsIFwi0YfQtdGC0LLRgNGC0L7QulwiLCBcItC/0LXRgtC+0LpcIiwgXCLRgdCw0LHQvtGC0LBcIl0sXG4gICAgc2hvcnREYXlzOiBbXCLQvdC10LRcIiwgXCLQv9C+0L1cIiwgXCLQstGC0L5cIiwgXCLRgdGA0LVcIiwgXCLRh9C10YJcIiwgXCLQv9C10YJcIiwgXCLRgdCw0LFcIl0sXG4gICAgbW9udGhzOiBbXCLRmNCw0L3Rg9Cw0YDQuFwiLCBcItGE0LXQstGA0YPQsNGA0LhcIiwgXCLQvNCw0YDRglwiLCBcItCw0L/RgNC40LtcIiwgXCLQvNCw0ZhcIiwgXCLRmNGD0L3QuFwiLCBcItGY0YPQu9C4XCIsIFwi0LDQstCz0YPRgdGCXCIsIFwi0YHQtdC/0YLQtdC80LLRgNC4XCIsIFwi0L7QutGC0L7QvNCy0YDQuFwiLCBcItC90L7QtdC80LLRgNC4XCIsIFwi0LTQtdC60LXQvNCy0YDQuFwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wi0ZjQsNC9XCIsIFwi0YTQtdCyXCIsIFwi0LzQsNGAXCIsIFwi0LDQv9GAXCIsIFwi0LzQsNGYXCIsIFwi0ZjRg9C9XCIsIFwi0ZjRg9C7XCIsIFwi0LDQstCzXCIsIFwi0YHQtdC/XCIsIFwi0L7QutGCXCIsIFwi0L3QvtC1XCIsIFwi0LTQtdC6XCJdXG4gIH07XG5cbiAgdmFyIGl0SXQgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJUEgJWUgJUIgJVksICVYXCIsXG4gICAgZGF0ZTogXCIlZC8lbS8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLCAvLyB1bnVzZWRcbiAgICBkYXlzOiBbXCJEb21lbmljYVwiLCBcIkx1bmVkw6xcIiwgXCJNYXJ0ZWTDrFwiLCBcIk1lcmNvbGVkw6xcIiwgXCJHaW92ZWTDrFwiLCBcIlZlbmVyZMOsXCIsIFwiU2FiYXRvXCJdLFxuICAgIHNob3J0RGF5czogW1wiRG9tXCIsIFwiTHVuXCIsIFwiTWFyXCIsIFwiTWVyXCIsIFwiR2lvXCIsIFwiVmVuXCIsIFwiU2FiXCJdLFxuICAgIG1vbnRoczogW1wiR2VubmFpb1wiLCBcIkZlYmJyYWlvXCIsIFwiTWFyem9cIiwgXCJBcHJpbGVcIiwgXCJNYWdnaW9cIiwgXCJHaXVnbm9cIiwgXCJMdWdsaW9cIiwgXCJBZ29zdG9cIiwgXCJTZXR0ZW1icmVcIiwgXCJPdHRvYnJlXCIsIFwiTm92ZW1icmVcIiwgXCJEaWNlbWJyZVwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiR2VuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWFnXCIsIFwiR2l1XCIsIFwiTHVnXCIsIFwiQWdvXCIsIFwiU2V0XCIsIFwiT3R0XCIsIFwiTm92XCIsIFwiRGljXCJdXG4gIH07XG5cbiAgdmFyIGhlSWwgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJUEsICVlINeRJUIgJVkgJVhcIixcbiAgICBkYXRlOiBcIiVkLiVtLiVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgZGF5czogW1wi16jXkNep15XXn1wiLCBcItep16DXmVwiLCBcItep15zXmdep15lcIiwgXCLXqNeR15nXoteZXCIsIFwi15fXnteZ16nXmVwiLCBcItep15nXqdeZXCIsIFwi16nXkdeqXCJdLFxuICAgIHNob3J0RGF5czogW1wi15DXs1wiLCBcIteR17NcIiwgXCLXktezXCIsIFwi15PXs1wiLCBcIteU17NcIiwgXCLXldezXCIsIFwi16nXs1wiXSxcbiAgICBtb250aHM6IFtcIteZ16DXldeQ16hcIiwgXCLXpNeR16jXldeQ16hcIiwgXCLXnteo16VcIiwgXCLXkNek16jXmdecXCIsIFwi157XkNeZXCIsIFwi15nXldeg15lcIiwgXCLXmdeV15zXmVwiLCBcIteQ15XXkteV16HXmFwiLCBcIteh16TXmNee15HXqFwiLCBcIteQ15XXp9eY15XXkdeoXCIsIFwi16DXldeR157XkdeoXCIsIFwi15PXptee15HXqFwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wi15nXoNeV17NcIiwgXCLXpNeR16jXs1wiLCBcItee16jXpVwiLCBcIteQ16TXqNezXCIsIFwi157XkNeZXCIsIFwi15nXldeg15lcIiwgXCLXmdeV15zXmVwiLCBcIteQ15XXktezXCIsIFwi16HXpNeY17NcIiwgXCLXkNeV16fXs1wiLCBcIteg15XXkdezXCIsIFwi15PXptee17NcIl1cbiAgfTtcblxuICB2YXIgZnJGciA9IHtcbiAgICBkYXRlVGltZTogXCIlQSwgbGUgJWUgJUIgJVksICVYXCIsXG4gICAgZGF0ZTogXCIlZC8lbS8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLCAvLyB1bnVzZWRcbiAgICBkYXlzOiBbXCJkaW1hbmNoZVwiLCBcImx1bmRpXCIsIFwibWFyZGlcIiwgXCJtZXJjcmVkaVwiLCBcImpldWRpXCIsIFwidmVuZHJlZGlcIiwgXCJzYW1lZGlcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJkaW0uXCIsIFwibHVuLlwiLCBcIm1hci5cIiwgXCJtZXIuXCIsIFwiamV1LlwiLCBcInZlbi5cIiwgXCJzYW0uXCJdLFxuICAgIG1vbnRoczogW1wiamFudmllclwiLCBcImbDqXZyaWVyXCIsIFwibWFyc1wiLCBcImF2cmlsXCIsIFwibWFpXCIsIFwianVpblwiLCBcImp1aWxsZXRcIiwgXCJhb8O7dFwiLCBcInNlcHRlbWJyZVwiLCBcIm9jdG9icmVcIiwgXCJub3ZlbWJyZVwiLCBcImTDqWNlbWJyZVwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiamFudi5cIiwgXCJmw6l2ci5cIiwgXCJtYXJzXCIsIFwiYXZyLlwiLCBcIm1haVwiLCBcImp1aW5cIiwgXCJqdWlsLlwiLCBcImFvw7t0XCIsIFwic2VwdC5cIiwgXCJvY3QuXCIsIFwibm92LlwiLCBcImTDqWMuXCJdXG4gIH07XG5cbiAgdmFyIGZyQ2EgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJWEgJWUgJWIgJVkgJVhcIixcbiAgICBkYXRlOiBcIiVZLSVtLSVkXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIlwiLCBcIlwiXSxcbiAgICBkYXlzOiBbXCJkaW1hbmNoZVwiLCBcImx1bmRpXCIsIFwibWFyZGlcIiwgXCJtZXJjcmVkaVwiLCBcImpldWRpXCIsIFwidmVuZHJlZGlcIiwgXCJzYW1lZGlcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJkaW1cIiwgXCJsdW5cIiwgXCJtYXJcIiwgXCJtZXJcIiwgXCJqZXVcIiwgXCJ2ZW5cIiwgXCJzYW1cIl0sXG4gICAgbW9udGhzOiBbXCJqYW52aWVyXCIsIFwiZsOpdnJpZXJcIiwgXCJtYXJzXCIsIFwiYXZyaWxcIiwgXCJtYWlcIiwgXCJqdWluXCIsIFwianVpbGxldFwiLCBcImFvw7t0XCIsIFwic2VwdGVtYnJlXCIsIFwib2N0b2JyZVwiLCBcIm5vdmVtYnJlXCIsIFwiZMOpY2VtYnJlXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJqYW5cIiwgXCJmw6l2XCIsIFwibWFyXCIsIFwiYXZyXCIsIFwibWFpXCIsIFwianVpXCIsIFwianVsXCIsIFwiYW/Du1wiLCBcInNlcFwiLCBcIm9jdFwiLCBcIm5vdlwiLCBcImTDqWNcIl1cbiAgfTtcblxuICB2YXIgZmlGaSA9IHtcbiAgICBkYXRlVGltZTogXCIlQSwgJS1kLiAlQnRhICVZIGtsbyAlWFwiLFxuICAgIGRhdGU6IFwiJS1kLiUtbS4lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJhLm0uXCIsIFwicC5tLlwiXSxcbiAgICBkYXlzOiBbXCJzdW5udW50YWlcIiwgXCJtYWFuYW50YWlcIiwgXCJ0aWlzdGFpXCIsIFwia2Vza2l2aWlra29cIiwgXCJ0b3JzdGFpXCIsIFwicGVyamFudGFpXCIsIFwibGF1YW50YWlcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJTdVwiLCBcIk1hXCIsIFwiVGlcIiwgXCJLZVwiLCBcIlRvXCIsIFwiUGVcIiwgXCJMYVwiXSxcbiAgICBtb250aHM6IFtcInRhbW1pa3V1XCIsIFwiaGVsbWlrdXVcIiwgXCJtYWFsaXNrdXVcIiwgXCJodWh0aWt1dVwiLCBcInRvdWtva3V1XCIsIFwia2Vzw6RrdXVcIiwgXCJoZWluw6RrdXVcIiwgXCJlbG9rdXVcIiwgXCJzeXlza3V1XCIsIFwibG9rYWt1dVwiLCBcIm1hcnJhc2t1dVwiLCBcImpvdWx1a3V1XCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJUYW1taVwiLCBcIkhlbG1pXCIsIFwiTWFhbGlzXCIsIFwiSHVodGlcIiwgXCJUb3Vrb1wiLCBcIktlc8OkXCIsIFwiSGVpbsOkXCIsIFwiRWxvXCIsIFwiU3l5c1wiLCBcIkxva2FcIiwgXCJNYXJyYXNcIiwgXCJKb3VsdVwiXVxuICB9O1xuXG4gIHZhciBlc0VzID0ge1xuICAgIGRhdGVUaW1lOiBcIiVBLCAlZSBkZSAlQiBkZSAlWSwgJVhcIixcbiAgICBkYXRlOiBcIiVkLyVtLyVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgZGF5czogW1wiZG9taW5nb1wiLCBcImx1bmVzXCIsIFwibWFydGVzXCIsIFwibWnDqXJjb2xlc1wiLCBcImp1ZXZlc1wiLCBcInZpZXJuZXNcIiwgXCJzw6FiYWRvXCJdLFxuICAgIHNob3J0RGF5czogW1wiZG9tXCIsIFwibHVuXCIsIFwibWFyXCIsIFwibWnDqVwiLCBcImp1ZVwiLCBcInZpZVwiLCBcInPDoWJcIl0sXG4gICAgbW9udGhzOiBbXCJlbmVyb1wiLCBcImZlYnJlcm9cIiwgXCJtYXJ6b1wiLCBcImFicmlsXCIsIFwibWF5b1wiLCBcImp1bmlvXCIsIFwianVsaW9cIiwgXCJhZ29zdG9cIiwgXCJzZXB0aWVtYnJlXCIsIFwib2N0dWJyZVwiLCBcIm5vdmllbWJyZVwiLCBcImRpY2llbWJyZVwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiZW5lXCIsIFwiZmViXCIsIFwibWFyXCIsIFwiYWJyXCIsIFwibWF5XCIsIFwianVuXCIsIFwianVsXCIsIFwiYWdvXCIsIFwic2VwXCIsIFwib2N0XCIsIFwibm92XCIsIFwiZGljXCJdXG4gIH07XG5cbiAgdmFyIGVuVXMgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJWEgJWIgJWUgJVggJVlcIixcbiAgICBkYXRlOiBcIiVtLyVkLyVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgZGF5czogW1wiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gICAgbW9udGhzOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdXG4gIH07XG5cbiAgdmFyIGVuR2IgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJWEgJWUgJWIgJVggJVlcIixcbiAgICBkYXRlOiBcIiVkLyVtLyVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgZGF5czogW1wiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gICAgbW9udGhzOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdXG4gIH07XG5cbiAgdmFyIGVuQ2EgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJWEgJWIgJWUgJVggJVlcIixcbiAgICBkYXRlOiBcIiVZLSVtLSVkXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgZGF5czogW1wiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gICAgbW9udGhzOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdXG4gIH07XG5cbiAgdmFyIGRlRGUgPSB7XG4gICAgZGF0ZVRpbWU6IFwiJUEsIGRlciAlZS4gJUIgJVksICVYXCIsXG4gICAgZGF0ZTogXCIlZC4lbS4lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLCAvLyB1bnVzZWRcbiAgICBkYXlzOiBbXCJTb25udGFnXCIsIFwiTW9udGFnXCIsIFwiRGllbnN0YWdcIiwgXCJNaXR0d29jaFwiLCBcIkRvbm5lcnN0YWdcIiwgXCJGcmVpdGFnXCIsIFwiU2Ftc3RhZ1wiXSxcbiAgICBzaG9ydERheXM6IFtcIlNvXCIsIFwiTW9cIiwgXCJEaVwiLCBcIk1pXCIsIFwiRG9cIiwgXCJGclwiLCBcIlNhXCJdLFxuICAgIG1vbnRoczogW1wiSmFudWFyXCIsIFwiRmVicnVhclwiLCBcIk3DpHJ6XCIsIFwiQXByaWxcIiwgXCJNYWlcIiwgXCJKdW5pXCIsIFwiSnVsaVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9rdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlemVtYmVyXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNcnpcIiwgXCJBcHJcIiwgXCJNYWlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPa3RcIiwgXCJOb3ZcIiwgXCJEZXpcIl1cbiAgfTtcblxuICB2YXIgY2FFcyA9IHtcbiAgICBkYXRlVGltZTogXCIlQSwgJWUgZGUgJUIgZGUgJVksICVYXCIsXG4gICAgZGF0ZTogXCIlZC8lbS8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcImRpdW1lbmdlXCIsIFwiZGlsbHVuc1wiLCBcImRpbWFydHNcIiwgXCJkaW1lY3Jlc1wiLCBcImRpam91c1wiLCBcImRpdmVuZHJlc1wiLCBcImRpc3NhYnRlXCJdLFxuICAgIHNob3J0RGF5czogW1wiZGcuXCIsIFwiZGwuXCIsIFwiZHQuXCIsIFwiZGMuXCIsIFwiZGouXCIsIFwiZHYuXCIsIFwiZHMuXCJdLFxuICAgIG1vbnRoczogW1wiZ2VuZXJcIiwgXCJmZWJyZXJcIiwgXCJtYXLDp1wiLCBcImFicmlsXCIsIFwibWFpZ1wiLCBcImp1bnlcIiwgXCJqdWxpb2xcIiwgXCJhZ29zdFwiLCBcInNldGVtYnJlXCIsIFwib2N0dWJyZVwiLCBcIm5vdmVtYnJlXCIsIFwiZGVzZW1icmVcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcImdlbi5cIiwgXCJmZWJyLlwiLCBcIm1hcsOnXCIsIFwiYWJyLlwiLCBcIm1haWdcIiwgXCJqdW55XCIsIFwianVsLlwiLCBcImFnLlwiLCBcInNldC5cIiwgXCJvY3QuXCIsIFwibm92LlwiLCBcImRlcy5cIl1cbiAgfTtcblxuICB2YXIgdDAgPSBuZXcgRGF0ZTtcbiAgdmFyIHQxID0gbmV3IERhdGU7XG5cbiAgZnVuY3Rpb24gbmV3SW50ZXJ2YWwoZmxvb3JpLCBvZmZzZXRpLCBjb3VudCkge1xuXG4gICAgZnVuY3Rpb24gaW50ZXJ2YWwoZGF0ZSkge1xuICAgICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoK2RhdGUpKSwgZGF0ZTtcbiAgICB9XG5cbiAgICBpbnRlcnZhbC5mbG9vciA9IGludGVydmFsO1xuXG4gICAgaW50ZXJ2YWwucm91bmQgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgICB2YXIgZDAgPSBuZXcgRGF0ZSgrZGF0ZSksXG4gICAgICAgICAgZDEgPSBuZXcgRGF0ZShkYXRlIC0gMSk7XG4gICAgICBmbG9vcmkoZDApLCBmbG9vcmkoZDEpLCBvZmZzZXRpKGQxLCAxKTtcbiAgICAgIHJldHVybiBkYXRlIC0gZDAgPCBkMSAtIGRhdGUgPyBkMCA6IGQxO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5jZWlsID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoZGF0ZSAtIDEpKSwgb2Zmc2V0aShkYXRlLCAxKSwgZGF0ZTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwub2Zmc2V0ID0gZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgICAgcmV0dXJuIG9mZnNldGkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSwgc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCkpLCBkYXRlO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBbXTtcbiAgICAgIHN0YXJ0ID0gbmV3IERhdGUoc3RhcnQgLSAxKTtcbiAgICAgIHN0b3AgPSBuZXcgRGF0ZSgrc3RvcCk7XG4gICAgICBzdGVwID0gc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCk7XG4gICAgICBpZiAoIShzdGFydCA8IHN0b3ApIHx8ICEoc3RlcCA+IDApKSByZXR1cm4gcmFuZ2U7IC8vIGFsc28gaGFuZGxlcyBJbnZhbGlkIERhdGVcbiAgICAgIG9mZnNldGkoc3RhcnQsIDEpLCBmbG9vcmkoc3RhcnQpO1xuICAgICAgaWYgKHN0YXJ0IDwgc3RvcCkgcmFuZ2UucHVzaChuZXcgRGF0ZSgrc3RhcnQpKTtcbiAgICAgIHdoaWxlIChvZmZzZXRpKHN0YXJ0LCBzdGVwKSwgZmxvb3JpKHN0YXJ0KSwgc3RhcnQgPCBzdG9wKSByYW5nZS5wdXNoKG5ldyBEYXRlKCtzdGFydCkpO1xuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5maWx0ZXIgPSBmdW5jdGlvbih0ZXN0KSB7XG4gICAgICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICB3aGlsZSAoZmxvb3JpKGRhdGUpLCAhdGVzdChkYXRlKSkgZGF0ZS5zZXRUaW1lKGRhdGUgLSAxKTtcbiAgICAgIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgICAgd2hpbGUgKC0tc3RlcCA+PSAwKSB3aGlsZSAob2Zmc2V0aShkYXRlLCAxKSwgIXRlc3QoZGF0ZSkpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmIChjb3VudCkgaW50ZXJ2YWwuY291bnQgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICB0MC5zZXRUaW1lKCtzdGFydCksIHQxLnNldFRpbWUoK2VuZCk7XG4gICAgICBmbG9vcmkodDApLCBmbG9vcmkodDEpO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoY291bnQodDAsIHQxKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBpbnRlcnZhbDtcbiAgfVxuXG4gIHZhciBkYXkgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCAtIChlbmQuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogNmU0KSAvIDg2NGU1O1xuICB9KTtcblxuICBmdW5jdGlvbiB3ZWVrZGF5KGkpIHtcbiAgICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIChkYXRlLmdldERheSgpICsgNyAtIGkpICUgNyk7XG4gICAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RlcCAqIDcpO1xuICAgIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIDZlNCkgLyA2MDQ4ZTU7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgc3VuZGF5ID0gd2Vla2RheSgwKTtcbiAgdmFyIG1vbmRheSA9IHdlZWtkYXkoMSk7XG5cbiAgdmFyIHllYXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICBkYXRlLnNldE1vbnRoKDAsIDEpO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBlbmQuZ2V0RnVsbFllYXIoKSAtIHN0YXJ0LmdldEZ1bGxZZWFyKCk7XG4gIH0pO1xuXG4gIHZhciB1dGNEYXkgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyA4NjRlNTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gdXRjV2Vla2RheShpKSB7XG4gICAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSAoZGF0ZS5nZXRVVENEYXkoKSArIDcgLSBpKSAlIDcpO1xuICAgIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIHN0ZXAgKiA3KTtcbiAgICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIDYwNDhlNTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciB1dGNTdW5kYXkgPSB1dGNXZWVrZGF5KDApO1xuICB2YXIgdXRjTW9uZGF5ID0gdXRjV2Vla2RheSgxKTtcblxuICB2YXIgdXRjWWVhciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgIGRhdGUuc2V0VVRDTW9udGgoMCwgMSk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGVuZC5nZXRVVENGdWxsWWVhcigpIC0gc3RhcnQuZ2V0VVRDRnVsbFllYXIoKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gbG9jYWxEYXRlKGQpIHtcbiAgICBpZiAoMCA8PSBkLnkgJiYgZC55IDwgMTAwKSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKC0xLCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKTtcbiAgICAgIGRhdGUuc2V0RnVsbFllYXIoZC55KTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoZC55LCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHV0Y0RhdGUoZCkge1xuICAgIGlmICgwIDw9IGQueSAmJiBkLnkgPCAxMDApIHtcbiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoLTEsIGQubSwgZC5kLCBkLkgsIGQuTSwgZC5TLCBkLkwpKTtcbiAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZC55KTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoZC55LCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKSk7XG4gIH1cblxuICBmdW5jdGlvbiBuZXdZZWFyKHkpIHtcbiAgICByZXR1cm4ge3k6IHksIG06IDAsIGQ6IDEsIEg6IDAsIE06IDAsIFM6IDAsIEw6IDB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbG9jYWxlKGxvY2FsZSkge1xuICAgIHZhciBsb2NhbGVfZGF0ZVRpbWUgPSBsb2NhbGUuZGF0ZVRpbWUsXG4gICAgICAgIGxvY2FsZV9kYXRlID0gbG9jYWxlLmRhdGUsXG4gICAgICAgIGxvY2FsZV90aW1lID0gbG9jYWxlLnRpbWUsXG4gICAgICAgIGxvY2FsZV9wZXJpb2RzID0gbG9jYWxlLnBlcmlvZHMsXG4gICAgICAgIGxvY2FsZV93ZWVrZGF5cyA9IGxvY2FsZS5kYXlzLFxuICAgICAgICBsb2NhbGVfc2hvcnRXZWVrZGF5cyA9IGxvY2FsZS5zaG9ydERheXMsXG4gICAgICAgIGxvY2FsZV9tb250aHMgPSBsb2NhbGUubW9udGhzLFxuICAgICAgICBsb2NhbGVfc2hvcnRNb250aHMgPSBsb2NhbGUuc2hvcnRNb250aHM7XG5cbiAgICB2YXIgcGVyaW9kTG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9wZXJpb2RzKSxcbiAgICAgICAgd2Vla2RheVJlID0gZm9ybWF0UmUobG9jYWxlX3dlZWtkYXlzKSxcbiAgICAgICAgd2Vla2RheUxvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfd2Vla2RheXMpLFxuICAgICAgICBzaG9ydFdlZWtkYXlSZSA9IGZvcm1hdFJlKGxvY2FsZV9zaG9ydFdlZWtkYXlzKSxcbiAgICAgICAgc2hvcnRXZWVrZGF5TG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9zaG9ydFdlZWtkYXlzKSxcbiAgICAgICAgbW9udGhSZSA9IGZvcm1hdFJlKGxvY2FsZV9tb250aHMpLFxuICAgICAgICBtb250aExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfbW9udGhzKSxcbiAgICAgICAgc2hvcnRNb250aFJlID0gZm9ybWF0UmUobG9jYWxlX3Nob3J0TW9udGhzKSxcbiAgICAgICAgc2hvcnRNb250aExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfc2hvcnRNb250aHMpO1xuXG4gICAgdmFyIGZvcm1hdHMgPSB7XG4gICAgICBcImFcIjogZm9ybWF0U2hvcnRXZWVrZGF5LFxuICAgICAgXCJBXCI6IGZvcm1hdFdlZWtkYXksXG4gICAgICBcImJcIjogZm9ybWF0U2hvcnRNb250aCxcbiAgICAgIFwiQlwiOiBmb3JtYXRNb250aCxcbiAgICAgIFwiY1wiOiBudWxsLFxuICAgICAgXCJkXCI6IGZvcm1hdERheU9mTW9udGgsXG4gICAgICBcImVcIjogZm9ybWF0RGF5T2ZNb250aCxcbiAgICAgIFwiSFwiOiBmb3JtYXRIb3VyMjQsXG4gICAgICBcIklcIjogZm9ybWF0SG91cjEyLFxuICAgICAgXCJqXCI6IGZvcm1hdERheU9mWWVhcixcbiAgICAgIFwiTFwiOiBmb3JtYXRNaWxsaXNlY29uZHMsXG4gICAgICBcIm1cIjogZm9ybWF0TW9udGhOdW1iZXIsXG4gICAgICBcIk1cIjogZm9ybWF0TWludXRlcyxcbiAgICAgIFwicFwiOiBmb3JtYXRQZXJpb2QsXG4gICAgICBcIlNcIjogZm9ybWF0U2Vjb25kcyxcbiAgICAgIFwiVVwiOiBmb3JtYXRXZWVrTnVtYmVyU3VuZGF5LFxuICAgICAgXCJ3XCI6IGZvcm1hdFdlZWtkYXlOdW1iZXIsXG4gICAgICBcIldcIjogZm9ybWF0V2Vla051bWJlck1vbmRheSxcbiAgICAgIFwieFwiOiBudWxsLFxuICAgICAgXCJYXCI6IG51bGwsXG4gICAgICBcInlcIjogZm9ybWF0WWVhcixcbiAgICAgIFwiWVwiOiBmb3JtYXRGdWxsWWVhcixcbiAgICAgIFwiWlwiOiBmb3JtYXRab25lLFxuICAgICAgXCIlXCI6IGZvcm1hdExpdGVyYWxQZXJjZW50XG4gICAgfTtcblxuICAgIHZhciB1dGNGb3JtYXRzID0ge1xuICAgICAgXCJhXCI6IGZvcm1hdFVUQ1Nob3J0V2Vla2RheSxcbiAgICAgIFwiQVwiOiBmb3JtYXRVVENXZWVrZGF5LFxuICAgICAgXCJiXCI6IGZvcm1hdFVUQ1Nob3J0TW9udGgsXG4gICAgICBcIkJcIjogZm9ybWF0VVRDTW9udGgsXG4gICAgICBcImNcIjogbnVsbCxcbiAgICAgIFwiZFwiOiBmb3JtYXRVVENEYXlPZk1vbnRoLFxuICAgICAgXCJlXCI6IGZvcm1hdFVUQ0RheU9mTW9udGgsXG4gICAgICBcIkhcIjogZm9ybWF0VVRDSG91cjI0LFxuICAgICAgXCJJXCI6IGZvcm1hdFVUQ0hvdXIxMixcbiAgICAgIFwialwiOiBmb3JtYXRVVENEYXlPZlllYXIsXG4gICAgICBcIkxcIjogZm9ybWF0VVRDTWlsbGlzZWNvbmRzLFxuICAgICAgXCJtXCI6IGZvcm1hdFVUQ01vbnRoTnVtYmVyLFxuICAgICAgXCJNXCI6IGZvcm1hdFVUQ01pbnV0ZXMsXG4gICAgICBcInBcIjogZm9ybWF0VVRDUGVyaW9kLFxuICAgICAgXCJTXCI6IGZvcm1hdFVUQ1NlY29uZHMsXG4gICAgICBcIlVcIjogZm9ybWF0VVRDV2Vla051bWJlclN1bmRheSxcbiAgICAgIFwid1wiOiBmb3JtYXRVVENXZWVrZGF5TnVtYmVyLFxuICAgICAgXCJXXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJNb25kYXksXG4gICAgICBcInhcIjogbnVsbCxcbiAgICAgIFwiWFwiOiBudWxsLFxuICAgICAgXCJ5XCI6IGZvcm1hdFVUQ1llYXIsXG4gICAgICBcIllcIjogZm9ybWF0VVRDRnVsbFllYXIsXG4gICAgICBcIlpcIjogZm9ybWF0VVRDWm9uZSxcbiAgICAgIFwiJVwiOiBmb3JtYXRMaXRlcmFsUGVyY2VudFxuICAgIH07XG5cbiAgICB2YXIgcGFyc2VzID0ge1xuICAgICAgXCJhXCI6IHBhcnNlU2hvcnRXZWVrZGF5LFxuICAgICAgXCJBXCI6IHBhcnNlV2Vla2RheSxcbiAgICAgIFwiYlwiOiBwYXJzZVNob3J0TW9udGgsXG4gICAgICBcIkJcIjogcGFyc2VNb250aCxcbiAgICAgIFwiY1wiOiBwYXJzZUxvY2FsZURhdGVUaW1lLFxuICAgICAgXCJkXCI6IHBhcnNlRGF5T2ZNb250aCxcbiAgICAgIFwiZVwiOiBwYXJzZURheU9mTW9udGgsXG4gICAgICBcIkhcIjogcGFyc2VIb3VyMjQsXG4gICAgICBcIklcIjogcGFyc2VIb3VyMjQsXG4gICAgICBcImpcIjogcGFyc2VEYXlPZlllYXIsXG4gICAgICBcIkxcIjogcGFyc2VNaWxsaXNlY29uZHMsXG4gICAgICBcIm1cIjogcGFyc2VNb250aE51bWJlcixcbiAgICAgIFwiTVwiOiBwYXJzZU1pbnV0ZXMsXG4gICAgICBcInBcIjogcGFyc2VQZXJpb2QsXG4gICAgICBcIlNcIjogcGFyc2VTZWNvbmRzLFxuICAgICAgXCJVXCI6IHBhcnNlV2Vla051bWJlclN1bmRheSxcbiAgICAgIFwid1wiOiBwYXJzZVdlZWtkYXlOdW1iZXIsXG4gICAgICBcIldcIjogcGFyc2VXZWVrTnVtYmVyTW9uZGF5LFxuICAgICAgXCJ4XCI6IHBhcnNlTG9jYWxlRGF0ZSxcbiAgICAgIFwiWFwiOiBwYXJzZUxvY2FsZVRpbWUsXG4gICAgICBcInlcIjogcGFyc2VZZWFyLFxuICAgICAgXCJZXCI6IHBhcnNlRnVsbFllYXIsXG4gICAgICBcIlpcIjogcGFyc2Vab25lLFxuICAgICAgXCIlXCI6IHBhcnNlTGl0ZXJhbFBlcmNlbnRcbiAgICB9O1xuXG4gICAgLy8gVGhlc2UgcmVjdXJzaXZlIGRpcmVjdGl2ZSBkZWZpbml0aW9ucyBtdXN0IGJlIGRlZmVycmVkLlxuICAgIGZvcm1hdHMueCA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZSwgZm9ybWF0cyk7XG4gICAgZm9ybWF0cy5YID0gbmV3Rm9ybWF0KGxvY2FsZV90aW1lLCBmb3JtYXRzKTtcbiAgICBmb3JtYXRzLmMgPSBuZXdGb3JtYXQobG9jYWxlX2RhdGVUaW1lLCBmb3JtYXRzKTtcbiAgICB1dGNGb3JtYXRzLnggPSBuZXdGb3JtYXQobG9jYWxlX2RhdGUsIHV0Y0Zvcm1hdHMpO1xuICAgIHV0Y0Zvcm1hdHMuWCA9IG5ld0Zvcm1hdChsb2NhbGVfdGltZSwgdXRjRm9ybWF0cyk7XG4gICAgdXRjRm9ybWF0cy5jID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlVGltZSwgdXRjRm9ybWF0cyk7XG5cbiAgICBmdW5jdGlvbiBuZXdGb3JtYXQoc3BlY2lmaWVyLCBmb3JtYXRzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICB2YXIgc3RyaW5nID0gW10sXG4gICAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgICBqID0gMCxcbiAgICAgICAgICAgIG4gPSBzcGVjaWZpZXIubGVuZ3RoLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIHBhZCxcbiAgICAgICAgICAgIGZvcm1hdDtcblxuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIGlmIChzcGVjaWZpZXIuY2hhckNvZGVBdChpKSA9PT0gMzcpIHtcbiAgICAgICAgICAgIHN0cmluZy5wdXNoKHNwZWNpZmllci5zbGljZShqLCBpKSk7XG4gICAgICAgICAgICBpZiAoKHBhZCA9IHBhZHNbYyA9IHNwZWNpZmllci5jaGFyQXQoKytpKV0pICE9IG51bGwpIGMgPSBzcGVjaWZpZXIuY2hhckF0KCsraSk7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID0gZm9ybWF0c1tjXSkgYyA9IGZvcm1hdChkYXRlLCBwYWQgPT0gbnVsbCA/IChjID09PSBcImVcIiA/IFwiIFwiIDogXCIwXCIpIDogcGFkKTtcbiAgICAgICAgICAgIHN0cmluZy5wdXNoKGMpO1xuICAgICAgICAgICAgaiA9IGkgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmluZy5wdXNoKHNwZWNpZmllci5zbGljZShqLCBpKSk7XG4gICAgICAgIHJldHVybiBzdHJpbmcuam9pbihcIlwiKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmV3UGFyc2Uoc3BlY2lmaWVyLCBuZXdEYXRlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHZhciBkID0gbmV3WWVhcigxOTAwKSxcbiAgICAgICAgICAgIGkgPSBwYXJzZVNwZWNpZmllcihkLCBzcGVjaWZpZXIsIHN0cmluZywgMCk7XG4gICAgICAgIGlmIChpICE9IHN0cmluZy5sZW5ndGgpIHJldHVybiBudWxsO1xuXG4gICAgICAgIC8vIFRoZSBhbS1wbSBmbGFnIGlzIDAgZm9yIEFNLCBhbmQgMSBmb3IgUE0uXG4gICAgICAgIGlmIChcInBcIiBpbiBkKSBkLkggPSBkLkggJSAxMiArIGQucCAqIDEyO1xuXG4gICAgICAgIC8vIElmIGEgdGltZSB6b25lIGlzIHNwZWNpZmllZCwgYWxsIGZpZWxkcyBhcmUgaW50ZXJwcmV0ZWQgYXMgVVRDIGFuZCB0aGVuXG4gICAgICAgIC8vIG9mZnNldCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCB0aW1lIHpvbmUuXG4gICAgICAgIGlmIChcIlpcIiBpbiBkKSB7XG4gICAgICAgICAgaWYgKFwid1wiIGluIGQgJiYgKFwiV1wiIGluIGQgfHwgXCJVXCIgaW4gZCkpIHtcbiAgICAgICAgICAgIHZhciBkYXkgPSB1dGNEYXRlKG5ld1llYXIoZC55KSkuZ2V0VVRDRGF5KCk7XG4gICAgICAgICAgICBpZiAoXCJXXCIgaW4gZCkgZC5VID0gZC5XLCBkLncgPSAoZC53ICsgNikgJSA3LCAtLWRheTtcbiAgICAgICAgICAgIGQubSA9IDA7XG4gICAgICAgICAgICBkLmQgPSBkLncgKyBkLlUgKiA3IC0gKGRheSArIDYpICUgNztcbiAgICAgICAgICB9XG4gICAgICAgICAgZC5IICs9IGQuWiAvIDEwMCB8IDA7XG4gICAgICAgICAgZC5NICs9IGQuWiAlIDEwMDtcbiAgICAgICAgICByZXR1cm4gdXRjRGF0ZShkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgYWxsIGZpZWxkcyBhcmUgaW4gbG9jYWwgdGltZS5cbiAgICAgICAgaWYgKFwid1wiIGluIGQgJiYgKFwiV1wiIGluIGQgfHwgXCJVXCIgaW4gZCkpIHtcbiAgICAgICAgICB2YXIgZGF5ID0gbmV3RGF0ZShuZXdZZWFyKGQueSkpLmdldERheSgpO1xuICAgICAgICAgIGlmIChcIldcIiBpbiBkKSBkLlUgPSBkLlcsIGQudyA9IChkLncgKyA2KSAlIDcsIC0tZGF5O1xuICAgICAgICAgIGQubSA9IDA7XG4gICAgICAgICAgZC5kID0gZC53ICsgZC5VICogNyAtIChkYXkgKyA2KSAlIDc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RhdGUoZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU3BlY2lmaWVyKGQsIHNwZWNpZmllciwgc3RyaW5nLCBqKSB7XG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgbiA9IHNwZWNpZmllci5sZW5ndGgsXG4gICAgICAgICAgbSA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBwYXJzZTtcblxuICAgICAgd2hpbGUgKGkgPCBuKSB7XG4gICAgICAgIGlmIChqID49IG0pIHJldHVybiAtMTtcbiAgICAgICAgYyA9IHNwZWNpZmllci5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIGlmIChjID09PSAzNykge1xuICAgICAgICAgIGMgPSBzcGVjaWZpZXIuY2hhckF0KGkrKyk7XG4gICAgICAgICAgcGFyc2UgPSBwYXJzZXNbYyBpbiBwYWRzID8gc3BlY2lmaWVyLmNoYXJBdChpKyspIDogY107XG4gICAgICAgICAgaWYgKCFwYXJzZSB8fCAoKGogPSBwYXJzZShkLCBzdHJpbmcsIGopKSA8IDApKSByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoYyAhPSBzdHJpbmcuY2hhckNvZGVBdChqKyspKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBqO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU2hvcnRXZWVrZGF5KGQsIHN0cmluZywgaSkge1xuICAgICAgdmFyIG4gPSBzaG9ydFdlZWtkYXlSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgICByZXR1cm4gbiA/IChkLncgPSBzaG9ydFdlZWtkYXlMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoZCwgc3RyaW5nLCBpKSB7XG4gICAgICB2YXIgbiA9IHdlZWtkYXlSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgICByZXR1cm4gbiA/IChkLncgPSB3ZWVrZGF5TG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTaG9ydE1vbnRoKGQsIHN0cmluZywgaSkge1xuICAgICAgdmFyIG4gPSBzaG9ydE1vbnRoUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZC5tID0gc2hvcnRNb250aExvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gICAgICB2YXIgbiA9IG1vbnRoUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZC5tID0gbW9udGhMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUxvY2FsZURhdGVUaW1lKGQsIHN0cmluZywgaSkge1xuICAgICAgcmV0dXJuIHBhcnNlU3BlY2lmaWVyKGQsIGxvY2FsZV9kYXRlVGltZSwgc3RyaW5nLCBpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUxvY2FsZURhdGUoZCwgc3RyaW5nLCBpKSB7XG4gICAgICByZXR1cm4gcGFyc2VTcGVjaWZpZXIoZCwgbG9jYWxlX2RhdGUsIHN0cmluZywgaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VMb2NhbGVUaW1lKGQsIHN0cmluZywgaSkge1xuICAgICAgcmV0dXJuIHBhcnNlU3BlY2lmaWVyKGQsIGxvY2FsZV90aW1lLCBzdHJpbmcsIGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUGVyaW9kKGQsIHN0cmluZywgaSkge1xuICAgICAgdmFyIG4gPSBwZXJpb2RMb29rdXAuZ2V0KHN0cmluZy5zbGljZShpLCBpICs9IDIpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgcmV0dXJuIG4gPT0gbnVsbCA/IC0xIDogKGQucCA9IG4sIGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFNob3J0V2Vla2RheShkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3Nob3J0V2Vla2RheXNbZC5nZXREYXkoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0V2Vla2RheShkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3dlZWtkYXlzW2QuZ2V0RGF5KCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFNob3J0TW9udGgoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV9zaG9ydE1vbnRoc1tkLmdldE1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdE1vbnRoKGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfbW9udGhzW2QuZ2V0TW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0UGVyaW9kKGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfcGVyaW9kc1srKGQuZ2V0SG91cnMoKSA+PSAxMildO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFVUQ1Nob3J0V2Vla2RheShkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3Nob3J0V2Vla2RheXNbZC5nZXRVVENEYXkoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0VVRDV2Vla2RheShkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3dlZWtkYXlzW2QuZ2V0VVRDRGF5KCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFVUQ1Nob3J0TW9udGgoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV9zaG9ydE1vbnRoc1tkLmdldFVUQ01vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFVUQ01vbnRoKGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfbW9udGhzW2QuZ2V0VVRDTW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0VVRDUGVyaW9kKGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfcGVyaW9kc1srKGQuZ2V0VVRDSG91cnMoKSA+PSAxMildO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgICB2YXIgZiA9IG5ld0Zvcm1hdChzcGVjaWZpZXIgKz0gXCJcIiwgZm9ybWF0cyk7XG4gICAgICAgIGYucGFyc2UgPSBuZXdQYXJzZShzcGVjaWZpZXIsIGxvY2FsRGF0ZSk7XG4gICAgICAgIGYudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9LFxuICAgICAgdXRjRm9ybWF0OiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgICAgdmFyIGYgPSBuZXdGb3JtYXQoc3BlY2lmaWVyICs9IFwiXCIsIHV0Y0Zvcm1hdHMpO1xuICAgICAgICBmLnBhcnNlID0gbmV3UGFyc2Uoc3BlY2lmaWVyLCB1dGNEYXRlKTtcbiAgICAgICAgZi50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIHBhZHMgPSB7XCItXCI6IFwiXCIsIFwiX1wiOiBcIiBcIiwgXCIwXCI6IFwiMFwifTtcbiAgdmFyIG51bWJlclJlID0gL15cXHMqXFxkKy87XG4gIHZhciBwZXJjZW50UmUgPSAvXiUvO1xuICB2YXIgcmVxdW90ZVJlID0gL1tcXFxcXFxeXFwkXFwqXFwrXFw/XFx8XFxbXFxdXFwoXFwpXFwuXFx7XFx9XS9nO1xuXG4gIGZ1bmN0aW9uIHBhZCh2YWx1ZSwgZmlsbCwgd2lkdGgpIHtcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMCA/IFwiLVwiIDogXCJcIixcbiAgICAgICAgc3RyaW5nID0gKHNpZ24gPyAtdmFsdWUgOiB2YWx1ZSkgKyBcIlwiLFxuICAgICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgIHJldHVybiBzaWduICsgKGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSArIHN0cmluZyA6IHN0cmluZyk7XG4gIH1cblxuICBmdW5jdGlvbiByZXF1b3RlKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKHJlcXVvdGVSZSwgXCJcXFxcJCZcIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRSZShuYW1lcykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgbmFtZXMubWFwKHJlcXVvdGUpLmpvaW4oXCJ8XCIpICsgXCIpXCIsIFwiaVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdExvb2t1cChuYW1lcykge1xuICAgIHZhciBtYXAgPSBuZXcgTWFwLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIG1hcC5zZXQobmFtZXNbaV0udG9Mb3dlckNhc2UoKSwgaSk7XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlV2Vla2RheU51bWJlcihkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gICAgcmV0dXJuIG4gPyAoZC53ID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlV2Vla051bWJlclN1bmRheShkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLlUgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VXZWVrTnVtYmVyTW9uZGF5KGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQuVyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUZ1bGxZZWFyKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDQpKTtcbiAgICByZXR1cm4gbiA/IChkLnkgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VZZWFyKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkLnkgPSArblswXSArICgrblswXSA+IDY4ID8gMTkwMCA6IDIwMDApLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVpvbmUoZCwgc3RyaW5nLCBpKSB7XG4gICAgcmV0dXJuIC9eWystXVxcZHs0fSQvLnRlc3Qoc3RyaW5nID0gc3RyaW5nLnNsaWNlKGksIGkgKyA1KSlcbiAgICAgICAgPyAoZC5aID0gLXN0cmluZywgaSArIDUpIC8vIHNpZ24gZGlmZmVycyBmcm9tIGdldFRpbWV6b25lT2Zmc2V0IVxuICAgICAgICA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNb250aE51bWJlcihkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5tID0gblswXSAtIDEsIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRGF5T2ZNb250aChkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5kID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRGF5T2ZZZWFyKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcbiAgICByZXR1cm4gbiA/IChkLm0gPSAwLCBkLmQgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VIb3VyMjQoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGQuSCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1pbnV0ZXMoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGQuTSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVNlY29uZHMoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGQuUyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1pbGxpc2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAzKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5MID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTGl0ZXJhbFBlcmNlbnQoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBwZXJjZW50UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgICByZXR1cm4gbiA/IGkgKyBuWzBdLmxlbmd0aCA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0RGF5T2ZNb250aChkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldERhdGUoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRIb3VyMjQoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRIb3VycygpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdEhvdXIxMihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldEhvdXJzKCkgJSAxMiB8fCAxMiwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXREYXlPZlllYXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoMSArIGRheS5jb3VudCh5ZWFyKGQpLCBkKSwgcCwgMyk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRNaWxsaXNlY29uZHMoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRNaWxsaXNlY29uZHMoKSwgcCwgMyk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRNb250aE51bWJlcihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldE1vbnRoKCkgKyAxLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdE1pbnV0ZXMoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRNaW51dGVzKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0U2Vjb25kcyhkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFNlY29uZHMoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyU3VuZGF5KGQsIHApIHtcbiAgICByZXR1cm4gcGFkKHN1bmRheS5jb3VudCh5ZWFyKGQpLCBkKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRXZWVrZGF5TnVtYmVyKGQpIHtcbiAgICByZXR1cm4gZC5nZXREYXkoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXJNb25kYXkoZCwgcCkge1xuICAgIHJldHVybiBwYWQobW9uZGF5LmNvdW50KHllYXIoZCksIGQpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFllYXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRGdWxsWWVhcigpICUgMTAwLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdEZ1bGxZZWFyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMDAwLCBwLCA0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFpvbmUoZCkge1xuICAgIHZhciB6ID0gZC5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgIHJldHVybiAoeiA+IDAgPyBcIi1cIiA6ICh6ICo9IC0xLCBcIitcIikpXG4gICAgICAgICsgcGFkKHogLyA2MCB8IDAsIFwiMFwiLCAyKVxuICAgICAgICArIHBhZCh6ICUgNjAsIFwiMFwiLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ0RheU9mTW9udGgoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENEYXRlKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDSG91cjI0KGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDSG91cnMoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENIb3VyMTIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENIb3VycygpICUgMTIgfHwgMTIsIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDRGF5T2ZZZWFyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKDEgKyB1dGNEYXkuY291bnQodXRjWWVhcihkKSwgZCksIHAsIDMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDTWlsbGlzZWNvbmRzKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCksIHAsIDMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDTW9udGhOdW1iZXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENNb250aCgpICsgMSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENNaW51dGVzKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDTWludXRlcygpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1NlY29uZHMoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENTZWNvbmRzKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDV2Vla051bWJlclN1bmRheShkLCBwKSB7XG4gICAgcmV0dXJuIHBhZCh1dGNTdW5kYXkuY291bnQodXRjWWVhcihkKSwgZCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDV2Vla2RheU51bWJlcihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDRGF5KCk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENXZWVrTnVtYmVyTW9uZGF5KGQsIHApIHtcbiAgICByZXR1cm4gcGFkKHV0Y01vbmRheS5jb3VudCh1dGNZZWFyKGQpLCBkKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENZZWFyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENGdWxsWWVhcihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ0Z1bGxZZWFyKCkgJSAxMDAwMCwgcCwgNCk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENab25lKCkge1xuICAgIHJldHVybiBcIiswMDAwXCI7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRMaXRlcmFsUGVyY2VudCgpIHtcbiAgICByZXR1cm4gXCIlXCI7XG4gIH1cblxuICB2YXIgaXNvU3BlY2lmaWVyID0gXCIlWS0lbS0lZFQlSDolTTolUy4lTFpcIjtcblxuICBmdW5jdGlvbiBmb3JtYXRJc29OYXRpdmUoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCk7XG4gIH1cblxuICBmb3JtYXRJc29OYXRpdmUucGFyc2UgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHN0cmluZyk7XG4gICAgcmV0dXJuIGlzTmFOKGRhdGUpID8gbnVsbCA6IGRhdGU7XG4gIH07XG5cbiAgZm9ybWF0SXNvTmF0aXZlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzb1NwZWNpZmllcjtcbiAgfTtcblxuICB2YXIgZm9ybWF0SXNvID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgJiYgK25ldyBEYXRlKFwiMjAwMC0wMS0wMVQwMDowMDowMC4wMDBaXCIpXG4gICAgICA/IGZvcm1hdElzb05hdGl2ZVxuICAgICAgOiBlblVzLnV0Y0Zvcm1hdChpc29TcGVjaWZpZXIpO1xuXG4gIHZhciBpc29Gb3JtYXQgPSBmb3JtYXRJc287XG5cbiAgdmFyIGxvY2FsZURlZmluaXRpb25zID0gKG5ldyBNYXApXG4gICAgICAuc2V0KFwiY2EtRVNcIiwgY2FFcylcbiAgICAgIC5zZXQoXCJkZS1ERVwiLCBkZURlKVxuICAgICAgLnNldChcImVuLUNBXCIsIGVuQ2EpXG4gICAgICAuc2V0KFwiZW4tR0JcIiwgZW5HYilcbiAgICAgIC5zZXQoXCJlbi1VU1wiLCBlblVzKVxuICAgICAgLnNldChcImVzLUVTXCIsIGVzRXMpXG4gICAgICAuc2V0KFwiZmktRklcIiwgZmlGaSlcbiAgICAgIC5zZXQoXCJmci1DQVwiLCBmckNhKVxuICAgICAgLnNldChcImZyLUZSXCIsIGZyRnIpXG4gICAgICAuc2V0KFwiaGUtSUxcIiwgaGVJbClcbiAgICAgIC5zZXQoXCJpdC1JVFwiLCBpdEl0KVxuICAgICAgLnNldChcIm1rLU1LXCIsIG1rTWspXG4gICAgICAuc2V0KFwibmwtTkxcIiwgbmxObClcbiAgICAgIC5zZXQoXCJwbC1QTFwiLCBwbFBsKVxuICAgICAgLnNldChcInB0LUJSXCIsIHB0QnIpXG4gICAgICAuc2V0KFwicnUtUlVcIiwgcnVSdSlcbiAgICAgIC5zZXQoXCJ6aC1DTlwiLCB6aENuKTtcblxuICB2YXIgZGVmYXVsdExvY2FsZSA9IGxvY2FsZShlblVzKTtcbiAgZXhwb3J0cy5mb3JtYXQgPSBkZWZhdWx0TG9jYWxlLmZvcm1hdDtcbiAgZXhwb3J0cy51dGNGb3JtYXQgPSBkZWZhdWx0TG9jYWxlLnV0Y0Zvcm1hdDtcblxuICBmdW5jdGlvbiBsb2NhbGVGb3JtYXQoZGVmaW5pdGlvbikge1xuICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZGVmaW5pdGlvbiA9IGxvY2FsZURlZmluaXRpb25zLmdldChkZWZpbml0aW9uKTtcbiAgICAgIGlmICghZGVmaW5pdGlvbikgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGUoZGVmaW5pdGlvbik7XG4gIH1cbiAgO1xuXG4gIGV4cG9ydHMubG9jYWxlRm9ybWF0ID0gbG9jYWxlRm9ybWF0O1xuICBleHBvcnRzLmlzb0Zvcm1hdCA9IGlzb0Zvcm1hdDtcblxufSkpOyIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgZmFjdG9yeSgoZ2xvYmFsLnRpbWUgPSB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHQxID0gbmV3IERhdGU7XG5cbiAgdmFyIHQwID0gbmV3IERhdGU7XG5cbiAgZnVuY3Rpb24gbmV3SW50ZXJ2YWwoZmxvb3JpLCBvZmZzZXRpLCBjb3VudCkge1xuXG4gICAgZnVuY3Rpb24gaW50ZXJ2YWwoZGF0ZSkge1xuICAgICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoK2RhdGUpKSwgZGF0ZTtcbiAgICB9XG5cbiAgICBpbnRlcnZhbC5mbG9vciA9IGludGVydmFsO1xuXG4gICAgaW50ZXJ2YWwucm91bmQgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgICB2YXIgZDAgPSBuZXcgRGF0ZSgrZGF0ZSksXG4gICAgICAgICAgZDEgPSBuZXcgRGF0ZShkYXRlIC0gMSk7XG4gICAgICBmbG9vcmkoZDApLCBmbG9vcmkoZDEpLCBvZmZzZXRpKGQxLCAxKTtcbiAgICAgIHJldHVybiBkYXRlIC0gZDAgPCBkMSAtIGRhdGUgPyBkMCA6IGQxO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5jZWlsID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoZGF0ZSAtIDEpKSwgb2Zmc2V0aShkYXRlLCAxKSwgZGF0ZTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwub2Zmc2V0ID0gZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgICAgcmV0dXJuIG9mZnNldGkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSwgc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCkpLCBkYXRlO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBbXTtcbiAgICAgIHN0YXJ0ID0gbmV3IERhdGUoc3RhcnQgLSAxKTtcbiAgICAgIHN0b3AgPSBuZXcgRGF0ZSgrc3RvcCk7XG4gICAgICBzdGVwID0gc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCk7XG4gICAgICBpZiAoIShzdGFydCA8IHN0b3ApIHx8ICEoc3RlcCA+IDApKSByZXR1cm4gcmFuZ2U7IC8vIGFsc28gaGFuZGxlcyBJbnZhbGlkIERhdGVcbiAgICAgIG9mZnNldGkoc3RhcnQsIDEpLCBmbG9vcmkoc3RhcnQpO1xuICAgICAgaWYgKHN0YXJ0IDwgc3RvcCkgcmFuZ2UucHVzaChuZXcgRGF0ZSgrc3RhcnQpKTtcbiAgICAgIHdoaWxlIChvZmZzZXRpKHN0YXJ0LCBzdGVwKSwgZmxvb3JpKHN0YXJ0KSwgc3RhcnQgPCBzdG9wKSByYW5nZS5wdXNoKG5ldyBEYXRlKCtzdGFydCkpO1xuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5maWx0ZXIgPSBmdW5jdGlvbih0ZXN0KSB7XG4gICAgICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICB3aGlsZSAoZmxvb3JpKGRhdGUpLCAhdGVzdChkYXRlKSkgZGF0ZS5zZXRUaW1lKGRhdGUgLSAxKTtcbiAgICAgIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgICAgd2hpbGUgKC0tc3RlcCA+PSAwKSB3aGlsZSAob2Zmc2V0aShkYXRlLCAxKSwgIXRlc3QoZGF0ZSkpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmIChjb3VudCkgaW50ZXJ2YWwuY291bnQgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICB0MC5zZXRUaW1lKCtzdGFydCksIHQxLnNldFRpbWUoK2VuZCk7XG4gICAgICBmbG9vcmkodDApLCBmbG9vcmkodDEpO1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoY291bnQodDAsIHQxKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBpbnRlcnZhbDtcbiAgfVxuXG4gIHZhciBzZWNvbmQgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRNaWxsaXNlY29uZHMoMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogMWUzKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gMWUzO1xuICB9KTtcblxuICBleHBvcnRzLnNlY29uZHMgPSBzZWNvbmQucmFuZ2U7XG5cbiAgdmFyIG1pbnV0ZSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFNlY29uZHMoMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogNmU0KTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gNmU0O1xuICB9KTtcblxuICBleHBvcnRzLm1pbnV0ZXMgPSBtaW51dGUucmFuZ2U7XG5cbiAgdmFyIGhvdXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRNaW51dGVzKDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIDM2ZTUpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyAzNmU1O1xuICB9KTtcblxuICBleHBvcnRzLmhvdXJzID0gaG91ci5yYW5nZTtcblxuICB2YXIgZGF5ID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIDZlNCkgLyA4NjRlNTtcbiAgfSk7XG5cbiAgZXhwb3J0cy5kYXlzID0gZGF5LnJhbmdlO1xuXG4gIGZ1bmN0aW9uIHdlZWtkYXkoaSkge1xuICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gKGRhdGUuZ2V0RGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBzdGVwICogNyk7XG4gICAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIChlbmQgLSBzdGFydCAtIChlbmQuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogNmU0KSAvIDYwNDhlNTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuc3VuZGF5ID0gd2Vla2RheSgwKTtcblxuICBleHBvcnRzLnN1bmRheXMgPSBleHBvcnRzLnN1bmRheS5yYW5nZTtcblxuICBleHBvcnRzLm1vbmRheSA9IHdlZWtkYXkoMSk7XG5cbiAgZXhwb3J0cy5tb25kYXlzID0gZXhwb3J0cy5tb25kYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy50dWVzZGF5ID0gd2Vla2RheSgyKTtcblxuICBleHBvcnRzLnR1ZXNkYXlzID0gZXhwb3J0cy50dWVzZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMud2VkbmVzZGF5ID0gd2Vla2RheSgzKTtcblxuICBleHBvcnRzLndlZG5lc2RheXMgPSBleHBvcnRzLndlZG5lc2RheS5yYW5nZTtcblxuICBleHBvcnRzLnRodXJzZGF5ID0gd2Vla2RheSg0KTtcblxuICBleHBvcnRzLnRodXJzZGF5cyA9IGV4cG9ydHMudGh1cnNkYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy5mcmlkYXkgPSB3ZWVrZGF5KDUpO1xuXG4gIGV4cG9ydHMuZnJpZGF5cyA9IGV4cG9ydHMuZnJpZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMuc2F0dXJkYXkgPSB3ZWVrZGF5KDYpO1xuXG4gIGV4cG9ydHMuc2F0dXJkYXlzID0gZXhwb3J0cy5zYXR1cmRheS5yYW5nZTtcblxuICB2YXIgd2VlayA9IGV4cG9ydHMuc3VuZGF5O1xuXG4gIGV4cG9ydHMud2Vla3MgPSB3ZWVrLnJhbmdlO1xuXG4gIHZhciBtb250aCA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgIGRhdGUuc2V0RGF0ZSgxKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgc3RlcCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZW5kLmdldE1vbnRoKCkgLSBzdGFydC5nZXRNb250aCgpICsgKGVuZC5nZXRGdWxsWWVhcigpIC0gc3RhcnQuZ2V0RnVsbFllYXIoKSkgKiAxMjtcbiAgfSk7XG5cbiAgZXhwb3J0cy5tb250aHMgPSBtb250aC5yYW5nZTtcblxuICB2YXIgeWVhciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgIGRhdGUuc2V0TW9udGgoMCwgMSk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGVuZC5nZXRGdWxsWWVhcigpIC0gc3RhcnQuZ2V0RnVsbFllYXIoKTtcbiAgfSk7XG5cbiAgZXhwb3J0cy55ZWFycyA9IHllYXIucmFuZ2U7XG5cbiAgdmFyIHV0Y1NlY29uZCA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ01pbGxpc2Vjb25kcygwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiAxZTMpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyAxZTM7XG4gIH0pO1xuXG4gIGV4cG9ydHMudXRjU2Vjb25kcyA9IHV0Y1NlY29uZC5yYW5nZTtcblxuICB2YXIgdXRjTWludXRlID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDU2Vjb25kcygwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiA2ZTQpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyA2ZTQ7XG4gIH0pO1xuXG4gIGV4cG9ydHMudXRjTWludXRlcyA9IHV0Y01pbnV0ZS5yYW5nZTtcblxuICB2YXIgdXRjSG91ciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ01pbnV0ZXMoMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogMzZlNSk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIDM2ZTU7XG4gIH0pO1xuXG4gIGV4cG9ydHMudXRjSG91cnMgPSB1dGNIb3VyLnJhbmdlO1xuXG4gIHZhciB1dGNEYXkgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyA4NjRlNTtcbiAgfSk7XG5cbiAgZXhwb3J0cy51dGNEYXlzID0gdXRjRGF5LnJhbmdlO1xuXG4gIGZ1bmN0aW9uIHV0Y1dlZWtkYXkoaSkge1xuICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gKGRhdGUuZ2V0VVRDRGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwICogNyk7XG4gICAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyA2MDQ4ZTU7XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLnV0Y1N1bmRheSA9IHV0Y1dlZWtkYXkoMCk7XG5cbiAgZXhwb3J0cy51dGNTdW5kYXlzID0gZXhwb3J0cy51dGNTdW5kYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy51dGNNb25kYXkgPSB1dGNXZWVrZGF5KDEpO1xuXG4gIGV4cG9ydHMudXRjTW9uZGF5cyA9IGV4cG9ydHMudXRjTW9uZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMudXRjVHVlc2RheSA9IHV0Y1dlZWtkYXkoMik7XG5cbiAgZXhwb3J0cy51dGNUdWVzZGF5cyA9IGV4cG9ydHMudXRjVHVlc2RheS5yYW5nZTtcblxuICBleHBvcnRzLnV0Y1dlZG5lc2RheSA9IHV0Y1dlZWtkYXkoMyk7XG5cbiAgZXhwb3J0cy51dGNXZWRuZXNkYXlzID0gZXhwb3J0cy51dGNXZWRuZXNkYXkucmFuZ2U7XG5cbiAgZXhwb3J0cy51dGNUaHVyc2RheSA9IHV0Y1dlZWtkYXkoNCk7XG5cbiAgZXhwb3J0cy51dGNUaHVyc2RheXMgPSBleHBvcnRzLnV0Y1RodXJzZGF5LnJhbmdlO1xuXG4gIGV4cG9ydHMudXRjRnJpZGF5ID0gdXRjV2Vla2RheSg1KTtcblxuICBleHBvcnRzLnV0Y0ZyaWRheXMgPSBleHBvcnRzLnV0Y0ZyaWRheS5yYW5nZTtcblxuICBleHBvcnRzLnV0Y1NhdHVyZGF5ID0gdXRjV2Vla2RheSg2KTtcblxuICBleHBvcnRzLnV0Y1NhdHVyZGF5cyA9IGV4cG9ydHMudXRjU2F0dXJkYXkucmFuZ2U7XG5cbiAgdmFyIHV0Y1dlZWsgPSBleHBvcnRzLnV0Y1N1bmRheTtcblxuICBleHBvcnRzLnV0Y1dlZWtzID0gdXRjV2Vlay5yYW5nZTtcblxuICB2YXIgdXRjTW9udGggPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICBkYXRlLnNldFVUQ0RhdGUoMSk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ01vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGVuZC5nZXRVVENNb250aCgpIC0gc3RhcnQuZ2V0VVRDTW9udGgoKSArIChlbmQuZ2V0VVRDRnVsbFllYXIoKSAtIHN0YXJ0LmdldFVUQ0Z1bGxZZWFyKCkpICogMTI7XG4gIH0pO1xuXG4gIGV4cG9ydHMudXRjTW9udGhzID0gdXRjTW9udGgucmFuZ2U7XG5cbiAgdmFyIHV0Y1llYXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgICBkYXRlLnNldFVUQ01vbnRoKDAsIDEpO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyBzdGVwKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBlbmQuZ2V0VVRDRnVsbFllYXIoKSAtIHN0YXJ0LmdldFVUQ0Z1bGxZZWFyKCk7XG4gIH0pO1xuXG4gIGV4cG9ydHMudXRjWWVhcnMgPSB1dGNZZWFyLnJhbmdlO1xuXG4gIGV4cG9ydHMuaW50ZXJ2YWwgPSBuZXdJbnRlcnZhbDtcbiAgZXhwb3J0cy5zZWNvbmQgPSBzZWNvbmQ7XG4gIGV4cG9ydHMubWludXRlID0gbWludXRlO1xuICBleHBvcnRzLmhvdXIgPSBob3VyO1xuICBleHBvcnRzLmRheSA9IGRheTtcbiAgZXhwb3J0cy53ZWVrID0gd2VlaztcbiAgZXhwb3J0cy5tb250aCA9IG1vbnRoO1xuICBleHBvcnRzLnllYXIgPSB5ZWFyO1xuICBleHBvcnRzLnV0Y1NlY29uZCA9IHV0Y1NlY29uZDtcbiAgZXhwb3J0cy51dGNNaW51dGUgPSB1dGNNaW51dGU7XG4gIGV4cG9ydHMudXRjSG91ciA9IHV0Y0hvdXI7XG4gIGV4cG9ydHMudXRjRGF5ID0gdXRjRGF5O1xuICBleHBvcnRzLnV0Y1dlZWsgPSB1dGNXZWVrO1xuICBleHBvcnRzLnV0Y01vbnRoID0gdXRjTW9udGg7XG4gIGV4cG9ydHMudXRjWWVhciA9IHV0Y1llYXI7XG5cbn0pKTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgICB0aW1lID0gcmVxdWlyZSgnLi4vdGltZScpLFxuICAgIEVQU0lMT04gPSAxZS0xNTtcblxuZnVuY3Rpb24gYmlucyhvcHQpIHtcbiAgaWYgKCFvcHQpIHsgdGhyb3cgRXJyb3IoXCJNaXNzaW5nIGJpbm5pbmcgb3B0aW9ucy5cIik7IH1cblxuICAvLyBkZXRlcm1pbmUgcmFuZ2VcbiAgdmFyIG1heGIgPSBvcHQubWF4YmlucyB8fCAxNSxcbiAgICAgIGJhc2UgPSBvcHQuYmFzZSB8fCAxMCxcbiAgICAgIGxvZ2IgPSBNYXRoLmxvZyhiYXNlKSxcbiAgICAgIGRpdiA9IG9wdC5kaXYgfHwgWzUsIDJdLCAgICAgIFxuICAgICAgbWluID0gb3B0Lm1pbixcbiAgICAgIG1heCA9IG9wdC5tYXgsXG4gICAgICBzcGFuID0gbWF4IC0gbWluLFxuICAgICAgc3RlcCwgbGV2ZWwsIG1pbnN0ZXAsIHByZWNpc2lvbiwgdiwgaSwgZXBzO1xuXG4gIGlmIChvcHQuc3RlcCkge1xuICAgIC8vIGlmIHN0ZXAgc2l6ZSBpcyBleHBsaWNpdGx5IGdpdmVuLCB1c2UgdGhhdFxuICAgIHN0ZXAgPSBvcHQuc3RlcDtcbiAgfSBlbHNlIGlmIChvcHQuc3RlcHMpIHtcbiAgICAvLyBpZiBwcm92aWRlZCwgbGltaXQgY2hvaWNlIHRvIGFjY2VwdGFibGUgc3RlcCBzaXplc1xuICAgIHN0ZXAgPSBvcHQuc3RlcHNbTWF0aC5taW4oXG4gICAgICBvcHQuc3RlcHMubGVuZ3RoIC0gMSxcbiAgICAgIGJpc2VjdChvcHQuc3RlcHMsIHNwYW4vbWF4YiwgMCwgb3B0LnN0ZXBzLmxlbmd0aClcbiAgICApXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbHNlIHVzZSBzcGFuIHRvIGRldGVybWluZSBzdGVwIHNpemVcbiAgICBsZXZlbCA9IE1hdGguY2VpbChNYXRoLmxvZyhtYXhiKSAvIGxvZ2IpO1xuICAgIG1pbnN0ZXAgPSBvcHQubWluc3RlcCB8fCAwO1xuICAgIHN0ZXAgPSBNYXRoLm1heChcbiAgICAgIG1pbnN0ZXAsXG4gICAgICBNYXRoLnBvdyhiYXNlLCBNYXRoLnJvdW5kKE1hdGgubG9nKHNwYW4pIC8gbG9nYikgLSBsZXZlbClcbiAgICApO1xuICAgIFxuICAgIC8vIGluY3JlYXNlIHN0ZXAgc2l6ZSBpZiB0b28gbWFueSBiaW5zXG4gICAgZG8geyBzdGVwICo9IGJhc2U7IH0gd2hpbGUgKE1hdGguY2VpbChzcGFuL3N0ZXApID4gbWF4Yik7XG5cbiAgICAvLyBkZWNyZWFzZSBzdGVwIHNpemUgaWYgYWxsb3dlZFxuICAgIGZvciAoaT0wOyBpPGRpdi5sZW5ndGg7ICsraSkge1xuICAgICAgdiA9IHN0ZXAgLyBkaXZbaV07XG4gICAgICBpZiAodiA+PSBtaW5zdGVwICYmIHNwYW4gLyB2IDw9IG1heGIpIHN0ZXAgPSB2O1xuICAgIH1cbiAgfVxuXG4gIC8vIHVwZGF0ZSBwcmVjaXNpb24sIG1pbiBhbmQgbWF4XG4gIHYgPSBNYXRoLmxvZyhzdGVwKTtcbiAgcHJlY2lzaW9uID0gdiA+PSAwID8gMCA6IH5+KC12IC8gbG9nYikgKyAxO1xuICBlcHMgPSBNYXRoLnBvdyhiYXNlLCAtcHJlY2lzaW9uIC0gMSk7XG4gIG1pbiA9IE1hdGgubWluKG1pbiwgTWF0aC5mbG9vcihtaW4gLyBzdGVwICsgZXBzKSAqIHN0ZXApO1xuICBtYXggPSBNYXRoLmNlaWwobWF4IC8gc3RlcCkgKiBzdGVwO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IG1pbixcbiAgICBzdG9wOiAgbWF4LFxuICAgIHN0ZXA6ICBzdGVwLFxuICAgIHVuaXQ6ICB7cHJlY2lzaW9uOiBwcmVjaXNpb259LFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBpbmRleDogaW5kZXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gYmlzZWN0KGEsIHgsIGxvLCBoaSkge1xuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgIGlmICh1dGlsLmNtcChhW21pZF0sIHgpIDwgMCkgeyBsbyA9IG1pZCArIDE7IH1cbiAgICBlbHNlIHsgaGkgPSBtaWQ7IH1cbiAgfVxuICByZXR1cm4gbG87XG59XG5cbmZ1bmN0aW9uIHZhbHVlKHYpIHtcbiAgcmV0dXJuIHRoaXMuc3RlcCAqIE1hdGguZmxvb3IodiAvIHRoaXMuc3RlcCArIEVQU0lMT04pO1xufVxuXG5mdW5jdGlvbiBpbmRleCh2KSB7XG4gIHJldHVybiBNYXRoLmZsb29yKCh2IC0gdGhpcy5zdGFydCkgLyB0aGlzLnN0ZXAgKyBFUFNJTE9OKTtcbn1cblxuZnVuY3Rpb24gZGF0ZV92YWx1ZSh2KSB7XG4gIHJldHVybiB0aGlzLnVuaXQuZGF0ZSh2YWx1ZS5jYWxsKHRoaXMsIHYpKTtcbn1cblxuZnVuY3Rpb24gZGF0ZV9pbmRleCh2KSB7XG4gIHJldHVybiBpbmRleC5jYWxsKHRoaXMsIHRoaXMudW5pdC51bml0KHYpKTtcbn1cblxuYmlucy5kYXRlID0gZnVuY3Rpb24ob3B0KSB7XG4gIGlmICghb3B0KSB7IHRocm93IEVycm9yKFwiTWlzc2luZyBkYXRlIGJpbm5pbmcgb3B0aW9ucy5cIik7IH1cblxuICAvLyBmaW5kIHRpbWUgc3RlcCwgdGhlbiBiaW5cbiAgdmFyIHVuaXRzID0gb3B0LnV0YyA/IHRpbWUudXRjIDogdGltZSxcbiAgICAgIGRtaW4gPSBvcHQubWluLFxuICAgICAgZG1heCA9IG9wdC5tYXgsXG4gICAgICBtYXhiID0gb3B0Lm1heGJpbnMgfHwgMjAsXG4gICAgICBtaW5iID0gb3B0Lm1pbmJpbnMgfHwgNCxcbiAgICAgIHNwYW4gPSAoK2RtYXgpIC0gKCtkbWluKSxcbiAgICAgIHVuaXQgPSBvcHQudW5pdCA/IHVuaXRzW29wdC51bml0XSA6IHVuaXRzLmZpbmQoc3BhbiwgbWluYiwgbWF4YiksXG4gICAgICBzcGVjID0gYmlucyh7XG4gICAgICAgIG1pbjogICAgIHVuaXQubWluICE9IG51bGwgPyB1bml0Lm1pbiA6IHVuaXQudW5pdChkbWluKSxcbiAgICAgICAgbWF4OiAgICAgdW5pdC5tYXggIT0gbnVsbCA/IHVuaXQubWF4IDogdW5pdC51bml0KGRtYXgpLFxuICAgICAgICBtYXhiaW5zOiBtYXhiLFxuICAgICAgICBtaW5zdGVwOiB1bml0Lm1pbnN0ZXAsXG4gICAgICAgIHN0ZXBzOiAgIHVuaXQuc3RlcFxuICAgICAgfSk7XG5cbiAgc3BlYy51bml0ID0gdW5pdDtcbiAgc3BlYy5pbmRleCA9IGRhdGVfaW5kZXg7XG4gIGlmICghb3B0LnJhdykgc3BlYy52YWx1ZSA9IGRhdGVfdmFsdWU7XG4gIHJldHVybiBzcGVjO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5zO1xuIiwidmFyIGdlbiA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmdlbi5yZXBlYXQgPSBmdW5jdGlvbih2YWwsIG4pIHtcbiAgdmFyIGEgPSBBcnJheShuKSwgaTtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSBhW2ldID0gdmFsO1xuICByZXR1cm4gYTtcbn07XG5cbmdlbi56ZXJvcyA9IGZ1bmN0aW9uKG4pIHtcbiAgcmV0dXJuIGdlbi5yZXBlYXQoMCwgbik7XG59O1xuXG5nZW4ucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICBzdGVwID0gMTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHN0b3AgPSBzdGFydDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gIH1cbiAgaWYgKChzdG9wIC0gc3RhcnQpIC8gc3RlcCA9PSBJbmZpbml0eSkgdGhyb3cgbmV3IEVycm9yKCdJbmZpbml0ZSByYW5nZScpO1xuICB2YXIgcmFuZ2UgPSBbXSwgaSA9IC0xLCBqO1xuICBpZiAoc3RlcCA8IDApIHdoaWxlICgoaiA9IHN0YXJ0ICsgc3RlcCAqICsraSkgPiBzdG9wKSByYW5nZS5wdXNoKGopO1xuICBlbHNlIHdoaWxlICgoaiA9IHN0YXJ0ICsgc3RlcCAqICsraSkgPCBzdG9wKSByYW5nZS5wdXNoKGopO1xuICByZXR1cm4gcmFuZ2U7XG59O1xuXG5nZW4ucmFuZG9tID0ge307XG5cbmdlbi5yYW5kb20udW5pZm9ybSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xuICAgIG1heCA9IG1pbiA9PT0gdW5kZWZpbmVkID8gMSA6IG1pbjtcbiAgICBtaW4gPSAwO1xuICB9XG4gIHZhciBkID0gbWF4IC0gbWluO1xuICB2YXIgZiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBtaW4gKyBkICogTWF0aC5yYW5kb20oKTtcbiAgfTtcbiAgZi5zYW1wbGVzID0gZnVuY3Rpb24obikgeyByZXR1cm4gZ2VuLnplcm9zKG4pLm1hcChmKTsgfTtcbiAgcmV0dXJuIGY7XG59O1xuXG5nZW4ucmFuZG9tLmludGVnZXIgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICBiID0gYTtcbiAgICBhID0gMDtcbiAgfVxuICB2YXIgZCA9IGIgLSBhO1xuICB2YXIgZiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhICsgTWF0aC5mbG9vcihkICogTWF0aC5yYW5kb20oKSk7XG4gIH07XG4gIGYuc2FtcGxlcyA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIGdlbi56ZXJvcyhuKS5tYXAoZik7IH07XG4gIHJldHVybiBmO1xufTtcblxuZ2VuLnJhbmRvbS5ub3JtYWwgPSBmdW5jdGlvbihtZWFuLCBzdGRldikge1xuICBtZWFuID0gbWVhbiB8fCAwO1xuICBzdGRldiA9IHN0ZGV2IHx8IDE7XG4gIHZhciBuZXh0O1xuICB2YXIgZiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB4ID0gMCwgeSA9IDAsIHJkcywgYztcbiAgICBpZiAobmV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB4ID0gbmV4dDtcbiAgICAgIG5leHQgPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgZG8ge1xuICAgICAgeCA9IE1hdGgucmFuZG9tKCkqMi0xO1xuICAgICAgeSA9IE1hdGgucmFuZG9tKCkqMi0xO1xuICAgICAgcmRzID0geCp4ICsgeSp5O1xuICAgIH0gd2hpbGUgKHJkcyA9PT0gMCB8fCByZHMgPiAxKTtcbiAgICBjID0gTWF0aC5zcXJ0KC0yKk1hdGgubG9nKHJkcykvcmRzKTsgLy8gQm94LU11bGxlciB0cmFuc2Zvcm1cbiAgICBuZXh0ID0gbWVhbiArIHkqYypzdGRldjtcbiAgICByZXR1cm4gbWVhbiArIHgqYypzdGRldjtcbiAgfTtcbiAgZi5zYW1wbGVzID0gZnVuY3Rpb24obikgeyByZXR1cm4gZ2VuLnplcm9zKG4pLm1hcChmKTsgfTtcbiAgcmV0dXJuIGY7XG59OyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgVFlQRVMgPSAnX190eXBlc19fJztcblxudmFyIFBBUlNFUlMgPSB7XG4gIGJvb2xlYW46IHV0aWwuYm9vbGVhbixcbiAgaW50ZWdlcjogdXRpbC5udW1iZXIsXG4gIG51bWJlcjogIHV0aWwubnVtYmVyLFxuICBkYXRlOiAgICB1dGlsLmRhdGUsXG4gIHN0cmluZzogIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg9PT0nJyA/IG51bGwgOiB4OyB9XG59O1xuXG52YXIgVEVTVFMgPSB7XG4gIGJvb2xlYW46IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg9PT0ndHJ1ZScgfHwgeD09PSdmYWxzZScgfHwgdXRpbC5pc0Jvb2xlYW4oeCk7IH0sXG4gIGludGVnZXI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIFRFU1RTLm51bWJlcih4KSAmJiAoeD0reCkgPT09IH5+eDsgfSxcbiAgbnVtYmVyOiBmdW5jdGlvbih4KSB7IHJldHVybiAhaXNOYU4oK3gpICYmICF1dGlsLmlzRGF0ZSh4KTsgfSxcbiAgZGF0ZTogZnVuY3Rpb24oeCkgeyByZXR1cm4gIWlzTmFOKERhdGUucGFyc2UoeCkpOyB9XG59O1xuXG5mdW5jdGlvbiBhbm5vdGF0aW9uKGRhdGEsIHR5cGVzKSB7XG4gIGlmICghdHlwZXMpIHJldHVybiBkYXRhICYmIGRhdGFbVFlQRVNdIHx8IG51bGw7XG4gIGRhdGFbVFlQRVNdID0gdHlwZXM7XG59XG5cbmZ1bmN0aW9uIHR5cGUodmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciB2LCBpLCBuO1xuXG4gIC8vIGlmIGRhdGEgYXJyYXkgaGFzIHR5cGUgYW5ub3RhdGlvbnMsIHVzZSB0aGVtXG4gIGlmICh2YWx1ZXNbVFlQRVNdKSB7XG4gICAgdiA9IGYodmFsdWVzW1RZUEVTXSk7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodikpIHJldHVybiB2O1xuICB9XG5cbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgIXV0aWwuaXNWYWxpZCh2KSAmJiBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICB9XG5cbiAgcmV0dXJuIHV0aWwuaXNEYXRlKHYpID8gJ2RhdGUnIDpcbiAgICB1dGlsLmlzTnVtYmVyKHYpICAgID8gJ251bWJlcicgOlxuICAgIHV0aWwuaXNCb29sZWFuKHYpICAgPyAnYm9vbGVhbicgOlxuICAgIHV0aWwuaXNTdHJpbmcodikgICAgPyAnc3RyaW5nJyA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHR5cGVBbGwoZGF0YSwgZmllbGRzKSB7XG4gIGlmICghZGF0YS5sZW5ndGgpIHJldHVybjtcbiAgZmllbGRzID0gZmllbGRzIHx8IHV0aWwua2V5cyhkYXRhWzBdKTtcbiAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24odHlwZXMsIGYpIHtcbiAgICByZXR1cm4gKHR5cGVzW2ZdID0gdHlwZShkYXRhLCBmKSwgdHlwZXMpO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGluZmVyKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgaSwgaiwgdjtcblxuICAvLyB0eXBlcyB0byB0ZXN0IGZvciwgaW4gcHJlY2VkZW5jZSBvcmRlclxuICB2YXIgdHlwZXMgPSBbJ2Jvb2xlYW4nLCAnaW50ZWdlcicsICdudW1iZXInLCAnZGF0ZSddO1xuXG4gIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIC8vIGdldCBuZXh0IHZhbHVlIHRvIHRlc3RcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICAvLyB0ZXN0IHZhbHVlIGFnYWluc3QgcmVtYWluaW5nIHR5cGVzXG4gICAgZm9yIChqPTA7IGo8dHlwZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmICh1dGlsLmlzVmFsaWQodikgJiYgIVRFU1RTW3R5cGVzW2pdXSh2KSkge1xuICAgICAgICB0eXBlcy5zcGxpY2UoaiwgMSk7XG4gICAgICAgIGogLT0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgbm8gdHlwZXMgbGVmdCwgcmV0dXJuICdzdHJpbmcnXG4gICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICdzdHJpbmcnO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVzWzBdO1xufVxuXG5mdW5jdGlvbiBpbmZlckFsbChkYXRhLCBmaWVsZHMpIHtcbiAgZmllbGRzID0gZmllbGRzIHx8IHV0aWwua2V5cyhkYXRhWzBdKTtcbiAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24odHlwZXMsIGYpIHtcbiAgICB0eXBlc1tmXSA9IGluZmVyKGRhdGEsIGYpO1xuICAgIHJldHVybiB0eXBlcztcbiAgfSwge30pO1xufVxuXG50eXBlLmFubm90YXRpb24gPSBhbm5vdGF0aW9uO1xudHlwZS5hbGwgPSB0eXBlQWxsO1xudHlwZS5pbmZlciA9IGluZmVyO1xudHlwZS5pbmZlckFsbCA9IGluZmVyQWxsO1xudHlwZS5wYXJzZXJzID0gUEFSU0VSUztcbm1vZHVsZS5leHBvcnRzID0gdHlwZTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIHR5cGUgPSByZXF1aXJlKCcuL2ltcG9ydC90eXBlJyk7XG52YXIgZ2VuID0gcmVxdWlyZSgnLi9nZW5lcmF0ZScpO1xudmFyIHN0YXRzID0ge307XG5cbi8vIENvbGxlY3QgdW5pcXVlIHZhbHVlcy5cbi8vIE91dHB1dDogYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gZmlyc3Qtb2JzZXJ2ZWQgb3JkZXJcbnN0YXRzLnVuaXF1ZSA9IGZ1bmN0aW9uKHZhbHVlcywgZiwgcmVzdWx0cykge1xuICBmID0gdXRpbC4kKGYpO1xuICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcbiAgdmFyIHUgPSB7fSwgdiwgaSwgbjtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodiBpbiB1KSBjb250aW51ZTtcbiAgICB1W3ZdID0gMTtcbiAgICByZXN1bHRzLnB1c2godik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW5wdXQgYXJyYXkuXG5zdGF0cy5jb3VudCA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICByZXR1cm4gdmFsdWVzICYmIHZhbHVlcy5sZW5ndGggfHwgMDtcbn07XG5cbi8vIENvdW50IHRoZSBudW1iZXIgb2Ygbm9uLW51bGwsIG5vbi11bmRlZmluZWQsIG5vbi1OYU4gdmFsdWVzLlxuc3RhdHMuY291bnQudmFsaWQgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIHYsIGksIG4sIHZhbGlkID0gMDtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB2YWxpZCArPSAxO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn07XG5cbi8vIENvdW50IHRoZSBudW1iZXIgb2YgbnVsbCBvciB1bmRlZmluZWQgdmFsdWVzLlxuc3RhdHMuY291bnQubWlzc2luZyA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgdiwgaSwgbiwgY291bnQgPSAwO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2ID09IG51bGwpIGNvdW50ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxuLy8gQ291bnQgdGhlIG51bWJlciBvZiBkaXN0aW5jdCB2YWx1ZXMuXG4vLyBOdWxsLCB1bmRlZmluZWQgYW5kIE5hTiBhcmUgZWFjaCBjb25zaWRlcmVkIGRpc3RpbmN0IHZhbHVlcy5cbnN0YXRzLmNvdW50LmRpc3RpbmN0ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciB1ID0ge30sIHYsIGksIG4sIGNvdW50ID0gMDtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodiBpbiB1KSBjb250aW51ZTtcbiAgICB1W3ZdID0gMTtcbiAgICBjb3VudCArPSAxO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn07XG5cbi8vIENvbnN0cnVjdCBhIG1hcCBmcm9tIGRpc3RpbmN0IHZhbHVlcyB0byBvY2N1cnJlbmNlIGNvdW50cy5cbnN0YXRzLmNvdW50Lm1hcCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgbWFwID0ge30sIHYsIGksIG47XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgbWFwW3ZdID0gKHYgaW4gbWFwKSA/IG1hcFt2XSArIDEgOiAxO1xuICB9XG4gIHJldHVybiBtYXA7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtZWRpYW4gb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLm1lZGlhbiA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBpZiAoZikgdmFsdWVzID0gdmFsdWVzLm1hcCh1dGlsLiQoZikpO1xuICB2YWx1ZXMgPSB2YWx1ZXMuZmlsdGVyKHV0aWwuaXNWYWxpZCkuc29ydCh1dGlsLmNtcCk7XG4gIHJldHVybiBzdGF0cy5xdWFudGlsZSh2YWx1ZXMsIDAuNSk7XG59O1xuXG4vLyBDb21wdXRlcyB0aGUgcXVhcnRpbGUgYm91bmRhcmllcyBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMucXVhcnRpbGUgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgaWYgKGYpIHZhbHVlcyA9IHZhbHVlcy5tYXAodXRpbC4kKGYpKTtcbiAgdmFsdWVzID0gdmFsdWVzLmZpbHRlcih1dGlsLmlzVmFsaWQpLnNvcnQodXRpbC5jbXApO1xuICB2YXIgcSA9IHN0YXRzLnF1YW50aWxlO1xuICByZXR1cm4gW3EodmFsdWVzLCAwLjI1KSwgcSh2YWx1ZXMsIDAuNTApLCBxKHZhbHVlcywgMC43NSldO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgcXVhbnRpbGUgb2YgYSBzb3J0ZWQgYXJyYXkgb2YgbnVtYmVycy5cbi8vIEFkYXB0ZWQgZnJvbSB0aGUgRDMuanMgaW1wbGVtZW50YXRpb24uXG5zdGF0cy5xdWFudGlsZSA9IGZ1bmN0aW9uKHZhbHVlcywgZiwgcCkge1xuICBpZiAocCA9PT0gdW5kZWZpbmVkKSB7IHAgPSBmOyBmID0gdXRpbC5pZGVudGl0eTsgfVxuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgSCA9ICh2YWx1ZXMubGVuZ3RoIC0gMSkgKiBwICsgMSxcbiAgICAgIGggPSBNYXRoLmZsb29yKEgpLFxuICAgICAgdiA9ICtmKHZhbHVlc1toIC0gMV0pLFxuICAgICAgZSA9IEggLSBoO1xuICByZXR1cm4gZSA/IHYgKyBlICogKGYodmFsdWVzW2hdKSAtIHYpIDogdjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHN1bSBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMuc3VtID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIGZvciAodmFyIHN1bT0wLCBpPTAsIG49dmFsdWVzLmxlbmd0aCwgdjsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSBzdW0gKz0gdjtcbiAgfVxuICByZXR1cm4gc3VtO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbWVhbiAoYXZlcmFnZSkgb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLm1lYW4gPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIG1lYW4gPSAwLCBkZWx0YSwgaSwgbiwgYywgdjtcbiAgZm9yIChpPTAsIGM9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIGRlbHRhID0gdiAtIG1lYW47XG4gICAgICBtZWFuID0gbWVhbiArIGRlbHRhIC8gKCsrYyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtZWFuO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2FtcGxlIHZhcmlhbmNlIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy52YXJpYW5jZSA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICBpZiAoIXV0aWwuaXNBcnJheSh2YWx1ZXMpIHx8IHZhbHVlcy5sZW5ndGggPCAyKSByZXR1cm4gMDtcbiAgdmFyIG1lYW4gPSAwLCBNMiA9IDAsIGRlbHRhLCBpLCBjLCB2O1xuICBmb3IgKGk9MCwgYz0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIGRlbHRhID0gdiAtIG1lYW47XG4gICAgICBtZWFuID0gbWVhbiArIGRlbHRhIC8gKCsrYyk7XG4gICAgICBNMiA9IE0yICsgZGVsdGEgKiAodiAtIG1lYW4pO1xuICAgIH1cbiAgfVxuICBNMiA9IE0yIC8gKGMgLSAxKTtcbiAgcmV0dXJuIE0yO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2FtcGxlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMuc3RkZXYgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgcmV0dXJuIE1hdGguc3FydChzdGF0cy52YXJpYW5jZSh2YWx1ZXMsIGYpKTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIFBlYXJzb24gbW9kZSBza2V3bmVzcyAoKG1lZGlhbi1tZWFuKS9zdGRldikgb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLm1vZGVza2V3ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHZhciBhdmcgPSBzdGF0cy5tZWFuKHZhbHVlcywgZiksXG4gICAgICBtZWQgPSBzdGF0cy5tZWRpYW4odmFsdWVzLCBmKSxcbiAgICAgIHN0ZCA9IHN0YXRzLnN0ZGV2KHZhbHVlcywgZik7XG4gIHJldHVybiBzdGQgPT09IDAgPyAwIDogKGF2ZyAtIG1lZCkgLyBzdGQ7XG59O1xuXG4vLyBGaW5kIHRoZSBtaW5pbXVtIHZhbHVlIGluIGFuIGFycmF5Llxuc3RhdHMubWluID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHJldHVybiBzdGF0cy5leHRlbnQodmFsdWVzLCBmKVswXTtcbn07XG5cbi8vIEZpbmQgdGhlIG1heGltdW0gdmFsdWUgaW4gYW4gYXJyYXkuXG5zdGF0cy5tYXggPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgcmV0dXJuIHN0YXRzLmV4dGVudCh2YWx1ZXMsIGYpWzFdO1xufTtcblxuLy8gRmluZCB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBvZiBhbiBhcnJheSBvZiB2YWx1ZXMuXG5zdGF0cy5leHRlbnQgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIGEsIGIsIHYsIGksIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7IGEgPSBiID0gdjsgYnJlYWs7IH1cbiAgfVxuICBmb3IgKDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBpZiAodiA8IGEpIGEgPSB2O1xuICAgICAgaWYgKHYgPiBiKSBiID0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFthLCBiXTtcbn07XG5cbi8vIEZpbmQgdGhlIGludGVnZXIgaW5kaWNlcyBvZiB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZXMuXG5zdGF0cy5leHRlbnQuaW5kZXggPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIHggPSAtMSwgeSA9IC0xLCBhLCBiLCB2LCBpLCBuID0gdmFsdWVzLmxlbmd0aDtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkgeyBhID0gYiA9IHY7IHggPSB5ID0gaTsgYnJlYWs7IH1cbiAgfVxuICBmb3IgKDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBpZiAodiA8IGEpIHsgYSA9IHY7IHggPSBpOyB9XG4gICAgICBpZiAodiA+IGIpIHsgYiA9IHY7IHkgPSBpOyB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbeCwgeV07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXG5zdGF0cy5kb3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIHN1bSA9IDAsIGksIHY7XG4gIGlmICghYikge1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoICE9PSBhLmxlbmd0aCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0FycmF5IGxlbmd0aHMgbXVzdCBtYXRjaC4nKTtcbiAgICB9XG4gICAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2ID0gdmFsdWVzW2ldICogYVtpXTtcbiAgICAgIGlmICh2ID09PSB2KSBzdW0gKz0gdjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYSA9IHV0aWwuJChhKTtcbiAgICBiID0gdXRpbC4kKGIpO1xuICAgIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdiA9IGEodmFsdWVzW2ldKSAqIGIodmFsdWVzW2ldKTtcbiAgICAgIGlmICh2ID09PSB2KSBzdW0gKz0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn07XG5cbi8vIENvbXB1dGUgYXNjZW5kaW5nIHJhbmsgc2NvcmVzIGZvciBhbiBhcnJheSBvZiB2YWx1ZXMuXG4vLyBUaWVzIGFyZSBhc3NpZ25lZCB0aGVpciBjb2xsZWN0aXZlIG1lYW4gcmFuay5cbnN0YXRzLnJhbmsgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKSB8fCB1dGlsLmlkZW50aXR5O1xuICB2YXIgYSA9IHZhbHVlcy5tYXAoZnVuY3Rpb24odiwgaSkge1xuICAgICAgcmV0dXJuIHtpZHg6IGksIHZhbDogZih2KX07XG4gICAgfSlcbiAgICAuc29ydCh1dGlsLmNvbXBhcmF0b3IoJ3ZhbCcpKTtcblxuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICByID0gQXJyYXkobiksXG4gICAgICB0aWUgPSAtMSwgcCA9IHt9LCBpLCB2LCBtdTtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICB2ID0gYVtpXS52YWw7XG4gICAgaWYgKHRpZSA8IDAgJiYgcCA9PT0gdikge1xuICAgICAgdGllID0gaSAtIDE7XG4gICAgfSBlbHNlIGlmICh0aWUgPiAtMSAmJiBwICE9PSB2KSB7XG4gICAgICBtdSA9IDEgKyAoaS0xICsgdGllKSAvIDI7XG4gICAgICBmb3IgKDsgdGllPGk7ICsrdGllKSByW2FbdGllXS5pZHhdID0gbXU7XG4gICAgICB0aWUgPSAtMTtcbiAgICB9XG4gICAgclthW2ldLmlkeF0gPSBpICsgMTtcbiAgICBwID0gdjtcbiAgfVxuXG4gIGlmICh0aWUgPiAtMSkge1xuICAgIG11ID0gMSArIChuLTEgKyB0aWUpIC8gMjtcbiAgICBmb3IgKDsgdGllPG47ICsrdGllKSByW2FbdGllXS5pZHhdID0gbXU7XG4gIH1cblxuICByZXR1cm4gcjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHNhbXBsZSBQZWFyc29uIHByb2R1Y3QtbW9tZW50IGNvcnJlbGF0aW9uIG9mIHR3byBhcnJheXMgb2YgbnVtYmVycy5cbnN0YXRzLmNvciA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYikge1xuICB2YXIgZm4gPSBiO1xuICBiID0gZm4gPyB2YWx1ZXMubWFwKHV0aWwuJChiKSkgOiBhO1xuICBhID0gZm4gPyB2YWx1ZXMubWFwKHV0aWwuJChhKSkgOiB2YWx1ZXM7XG5cbiAgdmFyIGRvdCA9IHN0YXRzLmRvdChhLCBiKSxcbiAgICAgIG11YSA9IHN0YXRzLm1lYW4oYSksXG4gICAgICBtdWIgPSBzdGF0cy5tZWFuKGIpLFxuICAgICAgc2RhID0gc3RhdHMuc3RkZXYoYSksXG4gICAgICBzZGIgPSBzdGF0cy5zdGRldihiKSxcbiAgICAgIG4gPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIHJldHVybiAoZG90IC0gbiptdWEqbXViKSAvICgobi0xKSAqIHNkYSAqIHNkYik7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBTcGVhcm1hbiByYW5rIGNvcnJlbGF0aW9uIG9mIHR3byBhcnJheXMgb2YgdmFsdWVzLlxuc3RhdHMuY29yLnJhbmsgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIHJhID0gYiA/IHN0YXRzLnJhbmsodmFsdWVzLCB1dGlsLiQoYSkpIDogc3RhdHMucmFuayh2YWx1ZXMpLFxuICAgICAgcmIgPSBiID8gc3RhdHMucmFuayh2YWx1ZXMsIHV0aWwuJChiKSkgOiBzdGF0cy5yYW5rKGEpLFxuICAgICAgbiA9IHZhbHVlcy5sZW5ndGgsIGksIHMsIGQ7XG5cbiAgZm9yIChpPTAsIHM9MDsgaTxuOyArK2kpIHtcbiAgICBkID0gcmFbaV0gLSByYltpXTtcbiAgICBzICs9IGQgKiBkO1xuICB9XG5cbiAgcmV0dXJuIDEgLSA2KnMgLyAobiAqIChuKm4tMSkpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgZGlzdGFuY2UgY29ycmVsYXRpb24gb2YgdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9jb3JyZWxhdGlvblxuc3RhdHMuY29yLmRpc3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIFggPSBiID8gdmFsdWVzLm1hcCh1dGlsLiQoYSkpIDogdmFsdWVzLFxuICAgICAgWSA9IGIgPyB2YWx1ZXMubWFwKHV0aWwuJChiKSkgOiBhO1xuXG4gIHZhciBBID0gc3RhdHMuZGlzdC5tYXQoWCksXG4gICAgICBCID0gc3RhdHMuZGlzdC5tYXQoWSksXG4gICAgICBuID0gQS5sZW5ndGgsXG4gICAgICBpLCBhYSwgYmIsIGFiO1xuXG4gIGZvciAoaT0wLCBhYT0wLCBiYj0wLCBhYj0wOyBpPG47ICsraSkge1xuICAgIGFhICs9IEFbaV0qQVtpXTtcbiAgICBiYiArPSBCW2ldKkJbaV07XG4gICAgYWIgKz0gQVtpXSpCW2ldO1xuICB9XG5cbiAgcmV0dXJuIE1hdGguc3FydChhYiAvIE1hdGguc3FydChhYSpiYikpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgdmVjdG9yIGRpc3RhbmNlIGJldHdlZW4gdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuLy8gRGVmYXVsdCBpcyBFdWNsaWRlYW4gKGV4cD0yKSBkaXN0YW5jZSwgY29uZmlndXJhYmxlIHZpYSBleHAgYXJndW1lbnQuXG5zdGF0cy5kaXN0ID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBleHApIHtcbiAgdmFyIGYgPSB1dGlsLmlzRnVuY3Rpb24oYikgfHwgdXRpbC5pc1N0cmluZyhiKSxcbiAgICAgIFggPSB2YWx1ZXMsXG4gICAgICBZID0gZiA/IHZhbHVlcyA6IGEsXG4gICAgICBlID0gZiA/IGV4cCA6IGIsXG4gICAgICBMMiA9IGUgPT09IDIgfHwgZSA9PSBudWxsLFxuICAgICAgbiA9IHZhbHVlcy5sZW5ndGgsIHMgPSAwLCBkLCBpO1xuICBpZiAoZikge1xuICAgIGEgPSB1dGlsLiQoYSk7XG4gICAgYiA9IHV0aWwuJChiKTtcbiAgfVxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBkID0gZiA/IChhKFhbaV0pLWIoWVtpXSkpIDogKFhbaV0tWVtpXSk7XG4gICAgcyArPSBMMiA/IGQqZCA6IE1hdGgucG93KE1hdGguYWJzKGQpLCBlKTtcbiAgfVxuICByZXR1cm4gTDIgPyBNYXRoLnNxcnQocykgOiBNYXRoLnBvdyhzLCAxL2UpO1xufTtcblxuLy8gQ29uc3RydWN0IGEgbWVhbi1jZW50ZXJlZCBkaXN0YW5jZSBtYXRyaXggZm9yIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5kaXN0Lm1hdCA9IGZ1bmN0aW9uKFgpIHtcbiAgdmFyIG4gPSBYLmxlbmd0aCxcbiAgICAgIG0gPSBuKm4sXG4gICAgICBBID0gQXJyYXkobSksXG4gICAgICBSID0gZ2VuLnplcm9zKG4pLFxuICAgICAgTSA9IDAsIHYsIGksIGo7XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgQVtpKm4raV0gPSAwO1xuICAgIGZvciAoaj1pKzE7IGo8bjsgKytqKSB7XG4gICAgICBBW2kqbitqXSA9ICh2ID0gTWF0aC5hYnMoWFtpXSAtIFhbal0pKTtcbiAgICAgIEFbaipuK2ldID0gdjtcbiAgICAgIFJbaV0gKz0gdjtcbiAgICAgIFJbal0gKz0gdjtcbiAgICB9XG4gIH1cblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBNICs9IFJbaV07XG4gICAgUltpXSAvPSBuO1xuICB9XG4gIE0gLz0gbTtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBmb3IgKGo9aTsgajxuOyArK2opIHtcbiAgICAgIEFbaSpuK2pdICs9IE0gLSBSW2ldIC0gUltqXTtcbiAgICAgIEFbaipuK2ldID0gQVtpKm4ral07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEE7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBTaGFubm9uIGVudHJvcHkgKGxvZyBiYXNlIDIpIG9mIGFuIGFycmF5IG9mIGNvdW50cy5cbnN0YXRzLmVudHJvcHkgPSBmdW5jdGlvbihjb3VudHMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIGksIHAsIHMgPSAwLCBIID0gMCwgbiA9IGNvdW50cy5sZW5ndGg7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHMgKz0gKGYgPyBmKGNvdW50c1tpXSkgOiBjb3VudHNbaV0pO1xuICB9XG4gIGlmIChzID09PSAwKSByZXR1cm4gMDtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgcCA9IChmID8gZihjb3VudHNbaV0pIDogY291bnRzW2ldKSAvIHM7XG4gICAgaWYgKHApIEggKz0gcCAqIE1hdGgubG9nKHApO1xuICB9XG4gIHJldHVybiAtSCAvIE1hdGguTE4yO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbXV0dWFsIGluZm9ybWF0aW9uIGJldHdlZW4gdHdvIGRpc2NyZXRlIHZhcmlhYmxlcy5cbi8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gW01JLCBNSV9kaXN0YW5jZV0gXG4vLyBNSV9kaXN0YW5jZSBpcyBkZWZpbmVkIGFzIDEgLSBJKGEsYikgLyBIKGEsYikuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL011dHVhbF9pbmZvcm1hdGlvblxuc3RhdHMubXV0dWFsID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBjb3VudHMpIHtcbiAgdmFyIHggPSBjb3VudHMgPyB2YWx1ZXMubWFwKHV0aWwuJChhKSkgOiB2YWx1ZXMsXG4gICAgICB5ID0gY291bnRzID8gdmFsdWVzLm1hcCh1dGlsLiQoYikpIDogYSxcbiAgICAgIHogPSBjb3VudHMgPyB2YWx1ZXMubWFwKHV0aWwuJChjb3VudHMpKSA6IGI7XG5cbiAgdmFyIHB4ID0ge30sXG4gICAgICBweSA9IHt9LFxuICAgICAgbiA9IHoubGVuZ3RoLFxuICAgICAgcyA9IDAsIEkgPSAwLCBIID0gMCwgcCwgdCwgaTtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBweFt4W2ldXSA9IDA7XG4gICAgcHlbeVtpXV0gPSAwO1xuICB9XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgcHhbeFtpXV0gKz0geltpXTtcbiAgICBweVt5W2ldXSArPSB6W2ldO1xuICAgIHMgKz0geltpXTtcbiAgfVxuXG4gIHQgPSAxIC8gKHMgKiBNYXRoLkxOMik7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIGlmICh6W2ldID09PSAwKSBjb250aW51ZTtcbiAgICBwID0gKHMgKiB6W2ldKSAvIChweFt4W2ldXSAqIHB5W3lbaV1dKTtcbiAgICBJICs9IHpbaV0gKiB0ICogTWF0aC5sb2cocCk7XG4gICAgSCArPSB6W2ldICogdCAqIE1hdGgubG9nKHpbaV0vcyk7XG4gIH1cblxuICByZXR1cm4gW0ksIDEgKyBJL0hdO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbXV0dWFsIGluZm9ybWF0aW9uIGJldHdlZW4gdHdvIGRpc2NyZXRlIHZhcmlhYmxlcy5cbnN0YXRzLm11dHVhbC5pbmZvID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBjb3VudHMpIHtcbiAgcmV0dXJuIHN0YXRzLm11dHVhbCh2YWx1ZXMsIGEsIGIsIGNvdW50cylbMF07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtdXR1YWwgaW5mb3JtYXRpb24gZGlzdGFuY2UgYmV0d2VlbiB0d28gZGlzY3JldGUgdmFyaWFibGVzLlxuLy8gTUlfZGlzdGFuY2UgaXMgZGVmaW5lZCBhcyAxIC0gSShhLGIpIC8gSChhLGIpLlxuc3RhdHMubXV0dWFsLmRpc3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIGNvdW50cykge1xuICByZXR1cm4gc3RhdHMubXV0dWFsKHZhbHVlcywgYSwgYiwgY291bnRzKVsxXTtcbn07XG5cbi8vIENvbXB1dGUgYSBwcm9maWxlIG9mIHN1bW1hcnkgc3RhdGlzdGljcyBmb3IgYSB2YXJpYWJsZS5cbnN0YXRzLnByb2ZpbGUgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgdmFyIG1lYW4gPSAwLFxuICAgICAgdmFsaWQgPSAwLFxuICAgICAgbWlzc2luZyA9IDAsXG4gICAgICBkaXN0aW5jdCA9IDAsXG4gICAgICBtaW4gPSBudWxsLFxuICAgICAgbWF4ID0gbnVsbCxcbiAgICAgIE0yID0gMCxcbiAgICAgIHZhbHMgPSBbXSxcbiAgICAgIHUgPSB7fSwgZGVsdGEsIHNkLCBpLCB2LCB4O1xuXG4gIC8vIGNvbXB1dGUgc3VtbWFyeSBzdGF0c1xuICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcblxuICAgIC8vIHVwZGF0ZSB1bmlxdWUgdmFsdWVzXG4gICAgdVt2XSA9ICh2IGluIHUpID8gdVt2XSArIDEgOiAoZGlzdGluY3QgKz0gMSwgMSk7XG5cbiAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICArK21pc3Npbmc7XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIC8vIHVwZGF0ZSBzdGF0c1xuICAgICAgeCA9ICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpID8gdi5sZW5ndGggOiB2O1xuICAgICAgaWYgKG1pbj09PW51bGwgfHwgeCA8IG1pbikgbWluID0geDtcbiAgICAgIGlmIChtYXg9PT1udWxsIHx8IHggPiBtYXgpIG1heCA9IHg7XG4gICAgICBkZWx0YSA9IHggLSBtZWFuO1xuICAgICAgbWVhbiA9IG1lYW4gKyBkZWx0YSAvICgrK3ZhbGlkKTtcbiAgICAgIE0yID0gTTIgKyBkZWx0YSAqICh4IC0gbWVhbik7XG4gICAgICB2YWxzLnB1c2goeCk7XG4gICAgfVxuICB9XG4gIE0yID0gTTIgLyAodmFsaWQgLSAxKTtcbiAgc2QgPSBNYXRoLnNxcnQoTTIpO1xuXG4gIC8vIHNvcnQgdmFsdWVzIGZvciBtZWRpYW4gYW5kIGlxclxuICB2YWxzLnNvcnQodXRpbC5jbXApO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogICAgIHR5cGUodmFsdWVzLCBmKSxcbiAgICB1bmlxdWU6ICAgdSxcbiAgICBjb3VudDogICAgdmFsdWVzLmxlbmd0aCxcbiAgICB2YWxpZDogICAgdmFsaWQsXG4gICAgbWlzc2luZzogIG1pc3NpbmcsXG4gICAgZGlzdGluY3Q6IGRpc3RpbmN0LFxuICAgIG1pbjogICAgICBtaW4sXG4gICAgbWF4OiAgICAgIG1heCxcbiAgICBtZWFuOiAgICAgbWVhbixcbiAgICBzdGRldjogICAgc2QsXG4gICAgbWVkaWFuOiAgICh2ID0gc3RhdHMucXVhbnRpbGUodmFscywgMC41KSksXG4gICAgcTE6ICAgICAgIHN0YXRzLnF1YW50aWxlKHZhbHMsIDAuMjUpLFxuICAgIHEzOiAgICAgICBzdGF0cy5xdWFudGlsZSh2YWxzLCAwLjc1KSxcbiAgICBtb2Rlc2tldzogc2QgPT09IDAgPyAwIDogKG1lYW4gLSB2KSAvIHNkXG4gIH07XG59O1xuXG4vLyBDb21wdXRlIHByb2ZpbGVzIGZvciBhbGwgdmFyaWFibGVzIGluIGEgZGF0YSBzZXQuXG5zdGF0cy5zdW1tYXJ5ID0gZnVuY3Rpb24oZGF0YSwgZmllbGRzKSB7XG4gIGZpZWxkcyA9IGZpZWxkcyB8fCB1dGlsLmtleXMoZGF0YVswXSk7XG4gIHZhciBzID0gZmllbGRzLm1hcChmdW5jdGlvbihmKSB7XG4gICAgdmFyIHAgPSBzdGF0cy5wcm9maWxlKGRhdGEsIHV0aWwuJChmKSk7XG4gICAgcmV0dXJuIChwLmZpZWxkID0gZiwgcCk7XG4gIH0pO1xuICByZXR1cm4gKHMuX19zdW1tYXJ5X18gPSB0cnVlLCBzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhdHM7IiwidmFyIGQzX3RpbWUgPSByZXF1aXJlKCdkMy10aW1lJyk7XG5cbnZhciB0ZW1wRGF0ZSA9IG5ldyBEYXRlKCksXG4gICAgYmFzZURhdGUgPSBuZXcgRGF0ZSgwLCAwLCAxKS5zZXRGdWxsWWVhcigwKSwgLy8gSmFuIDEsIDAgQURcbiAgICB1dGNCYXNlRGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKDAsIDAsIDEpKS5zZXRVVENGdWxsWWVhcigwKTtcblxuZnVuY3Rpb24gZGF0ZShkKSB7XG4gIHJldHVybiAodGVtcERhdGUuc2V0VGltZSgrZCksIHRlbXBEYXRlKTtcbn1cblxuLy8gY3JlYXRlIGEgdGltZSB1bml0IGVudHJ5XG5mdW5jdGlvbiBlbnRyeSh0eXBlLCBkYXRlLCB1bml0LCBzdGVwLCBtaW4sIG1heCkge1xuICB2YXIgZSA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGRhdGU6IGRhdGUsXG4gICAgdW5pdDogdW5pdFxuICB9O1xuICBpZiAoc3RlcCkge1xuICAgIGUuc3RlcCA9IHN0ZXA7XG4gIH0gZWxzZSB7XG4gICAgZS5taW5zdGVwID0gMTtcbiAgfVxuICBpZiAobWluICE9IG51bGwpIGUubWluID0gbWluO1xuICBpZiAobWF4ICE9IG51bGwpIGUubWF4ID0gbWF4O1xuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlKHR5cGUsIHVuaXQsIGJhc2UsIHN0ZXAsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBlbnRyeSh0eXBlLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHVuaXQub2Zmc2V0KGJhc2UsIGQpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHVuaXQuY291bnQoYmFzZSwgZCk7IH0sXG4gICAgc3RlcCwgbWluLCBtYXgpO1xufVxuXG52YXIgbG9jYWxlID0gW1xuICBjcmVhdGUoJ3NlY29uZCcsIGQzX3RpbWUuc2Vjb25kLCBiYXNlRGF0ZSksXG4gIGNyZWF0ZSgnbWludXRlJywgZDNfdGltZS5taW51dGUsIGJhc2VEYXRlKSxcbiAgY3JlYXRlKCdob3VyJywgICBkM190aW1lLmhvdXIsICAgYmFzZURhdGUpLFxuICBjcmVhdGUoJ2RheScsICAgIGQzX3RpbWUuZGF5LCAgICBiYXNlRGF0ZSwgWzEsIDddKSxcbiAgY3JlYXRlKCdtb250aCcsICBkM190aW1lLm1vbnRoLCAgYmFzZURhdGUsIFsxLCAzLCA2XSksXG4gIGNyZWF0ZSgneWVhcicsICAgZDNfdGltZS55ZWFyLCAgIGJhc2VEYXRlKSxcblxuICAvLyBwZXJpb2RpYyB1bml0c1xuICBlbnRyeSgnc2Vjb25kcycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoMTk3MCwgMCwgMSwgMCwgMCwgZCk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXRTZWNvbmRzKCk7IH0sXG4gICAgbnVsbCwgMCwgNTlcbiAgKSxcbiAgZW50cnkoJ21pbnV0ZXMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKDE5NzAsIDAsIDEsIDAsIGQpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0TWludXRlcygpOyB9LFxuICAgIG51bGwsIDAsIDU5XG4gICksXG4gIGVudHJ5KCdob3VycycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoMTk3MCwgMCwgMSwgZCk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXRIb3VycygpOyB9LFxuICAgIG51bGwsIDAsIDIzXG4gICksXG4gIGVudHJ5KCd3ZWVrZGF5cycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoMTk3MCwgMCwgNCtkKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldERheSgpOyB9LFxuICAgIFsxXSwgMCwgNlxuICApLFxuICBlbnRyeSgnZGF0ZXMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKDE5NzAsIDAsIGQpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0RGF0ZSgpOyB9LFxuICAgIFsxXSwgMSwgMzFcbiAgKSxcbiAgZW50cnkoJ21vbnRocycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoMTk3MCwgZCAlIDEyLCAxKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldE1vbnRoKCk7IH0sXG4gICAgWzFdLCAwLCAxMVxuICApXG5dO1xuXG52YXIgdXRjID0gW1xuICBjcmVhdGUoJ3NlY29uZCcsIGQzX3RpbWUudXRjU2Vjb25kLCB1dGNCYXNlRGF0ZSksXG4gIGNyZWF0ZSgnbWludXRlJywgZDNfdGltZS51dGNNaW51dGUsIHV0Y0Jhc2VEYXRlKSxcbiAgY3JlYXRlKCdob3VyJywgICBkM190aW1lLnV0Y0hvdXIsICAgdXRjQmFzZURhdGUpLFxuICBjcmVhdGUoJ2RheScsICAgIGQzX3RpbWUudXRjRGF5LCAgICB1dGNCYXNlRGF0ZSwgWzEsIDddKSxcbiAgY3JlYXRlKCdtb250aCcsICBkM190aW1lLnV0Y01vbnRoLCAgdXRjQmFzZURhdGUsIFsxLCAzLCA2XSksXG4gIGNyZWF0ZSgneWVhcicsICAgZDNfdGltZS51dGNZZWFyLCAgIHV0Y0Jhc2VEYXRlKSxcblxuICAvLyBwZXJpb2RpYyB1bml0c1xuICBlbnRyeSgnc2Vjb25kcycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgMSwgMCwgMCwgZCkpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0VVRDU2Vjb25kcygpOyB9LFxuICAgIG51bGwsIDAsIDU5XG4gICksXG4gIGVudHJ5KCdtaW51dGVzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCAwLCAxLCAwLCBkKSk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXRVVENNaW51dGVzKCk7IH0sXG4gICAgbnVsbCwgMCwgNTlcbiAgKSxcbiAgZW50cnkoJ2hvdXJzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCAwLCAxLCBkKSk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXRVVENIb3VycygpOyB9LFxuICAgIG51bGwsIDAsIDIzXG4gICksXG4gIGVudHJ5KCd3ZWVrZGF5cycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgNCtkKSk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXRVVENEYXkoKTsgfSxcbiAgICBbMV0sIDAsIDZcbiAgKSxcbiAgZW50cnkoJ2RhdGVzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCAwLCBkKSk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXRVVENEYXRlKCk7IH0sXG4gICAgWzFdLCAxLCAzMVxuICApLFxuICBlbnRyeSgnbW9udGhzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCBkICUgMTIsIDEpKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldFVUQ01vbnRoKCk7IH0sXG4gICAgWzFdLCAwLCAxMVxuICApXG5dO1xuXG52YXIgU1RFUFMgPSBbXG4gIFszMTUzNmU2LCA1XSwgIC8vIDEteWVhclxuICBbNzc3NmU2LCA0XSwgICAvLyAzLW1vbnRoXG4gIFsyNTkyZTYsIDRdLCAgIC8vIDEtbW9udGhcbiAgWzEyMDk2ZTUsIDNdLCAgLy8gMi13ZWVrXG4gIFs2MDQ4ZTUsIDNdLCAgIC8vIDEtd2Vla1xuICBbMTcyOGU1LCAzXSwgICAvLyAyLWRheVxuICBbODY0ZTUsIDNdLCAgICAvLyAxLWRheVxuICBbNDMyZTUsIDJdLCAgICAvLyAxMi1ob3VyXG4gIFsyMTZlNSwgMl0sICAgIC8vIDYtaG91clxuICBbMTA4ZTUsIDJdLCAgICAvLyAzLWhvdXJcbiAgWzM2ZTUsIDJdLCAgICAgLy8gMS1ob3VyXG4gIFsxOGU1LCAxXSwgICAgIC8vIDMwLW1pbnV0ZVxuICBbOWU1LCAxXSwgICAgICAvLyAxNS1taW51dGVcbiAgWzNlNSwgMV0sICAgICAgLy8gNS1taW51dGVcbiAgWzZlNCwgMV0sICAgICAgLy8gMS1taW51dGVcbiAgWzNlNCwgMF0sICAgICAgLy8gMzAtc2Vjb25kXG4gIFsxNWUzLCAwXSwgICAgIC8vIDE1LXNlY29uZFxuICBbNWUzLCAwXSwgICAgICAvLyA1LXNlY29uZFxuICBbMWUzLCAwXSAgICAgICAvLyAxLXNlY29uZFxuXTtcblxuZnVuY3Rpb24gZmluZCh1bml0cywgc3BhbiwgbWluYiwgbWF4Yikge1xuICB2YXIgc3RlcCA9IFNURVBTWzBdLCBpLCBuLCBiaW5zO1xuXG4gIGZvciAoaT0xLCBuPVNURVBTLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBzdGVwID0gU1RFUFNbaV07XG4gICAgaWYgKHNwYW4gPiBzdGVwWzBdKSB7XG4gICAgICBiaW5zID0gc3BhbiAvIHN0ZXBbMF07XG4gICAgICBpZiAoYmlucyA+IG1heGIpIHtcbiAgICAgICAgcmV0dXJuIHVuaXRzW1NURVBTW2ktMV1bMV1dO1xuICAgICAgfVxuICAgICAgaWYgKGJpbnMgPj0gbWluYikge1xuICAgICAgICByZXR1cm4gdW5pdHNbc3RlcFsxXV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB1bml0c1tTVEVQU1tuLTFdWzFdXTtcbn1cblxuZnVuY3Rpb24gdG9Vbml0TWFwKHVuaXRzKSB7XG4gIHZhciBtYXAgPSB7fSwgaSwgbjtcbiAgZm9yIChpPTAsIG49dW5pdHMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIG1hcFt1bml0c1tpXS50eXBlXSA9IHVuaXRzW2ldO1xuICB9XG4gIG1hcC5maW5kID0gZnVuY3Rpb24oc3BhbiwgbWluYiwgbWF4Yikge1xuICAgIHJldHVybiBmaW5kKHVuaXRzLCBzcGFuLCBtaW5iLCBtYXhiKTtcbiAgfTtcbiAgcmV0dXJuIG1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1VuaXRNYXAobG9jYWxlKTtcbm1vZHVsZS5leHBvcnRzLnV0YyA9IHRvVW5pdE1hcCh1dGMpO1xuIiwidmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLFxuICAgIHRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKSxcbiAgICB1dGMgPSB0aW1lLnV0YztcblxudmFyIHUgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyB1dGlsaXR5IGZ1bmN0aW9uc1xuXG52YXIgRk5BTUUgPSAnX19uYW1lX18nO1xuXG51Lm5hbWVkZnVuYyA9IGZ1bmN0aW9uKG5hbWUsIGYpIHsgcmV0dXJuIChmW0ZOQU1FXSA9IG5hbWUsIGYpOyB9O1xuXG51Lm5hbWUgPSBmdW5jdGlvbihmKSB7IHJldHVybiBmPT1udWxsID8gbnVsbCA6IGZbRk5BTUVdOyB9O1xuXG51LmlkZW50aXR5ID0gZnVuY3Rpb24oeCkgeyByZXR1cm4geDsgfTtcblxudS50cnVlID0gdS5uYW1lZGZ1bmMoJ3RydWUnLCBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0pO1xuXG51LmZhbHNlID0gdS5uYW1lZGZ1bmMoJ2ZhbHNlJywgZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfSk7XG5cbnUuZHVwbGljYXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufTtcblxudS5lcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKTtcbn07XG5cbnUuZXh0ZW5kID0gZnVuY3Rpb24ob2JqKSB7XG4gIGZvciAodmFyIHgsIG5hbWUsIGk9MSwgbGVuPWFyZ3VtZW50cy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICB4ID0gYXJndW1lbnRzW2ldO1xuICAgIGZvciAobmFtZSBpbiB4KSB7IG9ialtuYW1lXSA9IHhbbmFtZV07IH1cbiAgfVxuICByZXR1cm4gb2JqO1xufTtcblxudS5sZW5ndGggPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4ICE9IG51bGwgJiYgeC5sZW5ndGggIT0gbnVsbCA/IHgubGVuZ3RoIDogbnVsbDtcbn07XG5cbnUua2V5cyA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGtleXMgPSBbXSwgaztcbiAgZm9yIChrIGluIHgpIGtleXMucHVzaChrKTtcbiAgcmV0dXJuIGtleXM7XG59O1xuXG51LnZhbHMgPSBmdW5jdGlvbih4KSB7XG4gIHZhciB2YWxzID0gW10sIGs7XG4gIGZvciAoayBpbiB4KSB2YWxzLnB1c2goeFtrXSk7XG4gIHJldHVybiB2YWxzO1xufTtcblxudS50b01hcCA9IGZ1bmN0aW9uKGxpc3QsIGYpIHtcbiAgcmV0dXJuIChmID0gdS4kKGYpKSA/XG4gICAgbGlzdC5yZWR1Y2UoZnVuY3Rpb24ob2JqLCB4KSB7IHJldHVybiAob2JqW2YoeCldID0gMSwgb2JqKTsgfSwge30pIDpcbiAgICBsaXN0LnJlZHVjZShmdW5jdGlvbihvYmosIHgpIHsgcmV0dXJuIChvYmpbeF0gPSAxLCBvYmopOyB9LCB7fSk7XG59O1xuXG51LmtleXN0ciA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICAvLyB1c2UgdG8gZW5zdXJlIGNvbnNpc3RlbnQga2V5IGdlbmVyYXRpb24gYWNyb3NzIG1vZHVsZXNcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICBpZiAoIW4pIHJldHVybiAnJztcbiAgZm9yICh2YXIgcz1TdHJpbmcodmFsdWVzWzBdKSwgaT0xOyBpPG47ICsraSkge1xuICAgIHMgKz0gJ3wnICsgU3RyaW5nKHZhbHVlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIHM7XG59O1xuXG4vLyB0eXBlIGNoZWNraW5nIGZ1bmN0aW9uc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG51LmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xufTtcblxudS5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG51LmlzU3RyaW5nID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59O1xuXG51LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudS5pc051bWJlciA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ251bWJlcicgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBOdW1iZXJdJztcbn07XG5cbnUuaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xufTtcblxudS5pc0RhdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufTtcblxudS5pc1ZhbGlkID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iajtcbn07XG5cbnUuaXNCdWZmZXIgPSAoYnVmZmVyLkJ1ZmZlciAmJiBidWZmZXIuQnVmZmVyLmlzQnVmZmVyKSB8fCB1LmZhbHNlO1xuXG4vLyB0eXBlIGNvZXJjaW9uIGZ1bmN0aW9uc1xuXG51Lm51bWJlciA9IGZ1bmN0aW9uKHMpIHtcbiAgcmV0dXJuIHMgPT0gbnVsbCB8fCBzID09PSAnJyA/IG51bGwgOiArcztcbn07XG5cbnUuYm9vbGVhbiA9IGZ1bmN0aW9uKHMpIHtcbiAgcmV0dXJuIHMgPT0gbnVsbCB8fCBzID09PSAnJyA/IG51bGwgOiBzPT09J2ZhbHNlJyA/IGZhbHNlIDogISFzO1xufTtcblxudS5kYXRlID0gZnVuY3Rpb24ocykge1xuICByZXR1cm4gcyA9PSBudWxsIHx8IHMgPT09ICcnID8gbnVsbCA6IERhdGUucGFyc2Uocyk7XG59O1xuXG51LmFycmF5ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCAhPSBudWxsID8gKHUuaXNBcnJheSh4KSA/IHggOiBbeF0pIDogW107XG59O1xuXG51LnN0ciA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHUuaXNBcnJheSh4KSA/ICdbJyArIHgubWFwKHUuc3RyKSArICddJ1xuICAgIDogdS5pc09iamVjdCh4KSA/IEpTT04uc3RyaW5naWZ5KHgpXG4gICAgOiB1LmlzU3RyaW5nKHgpID8gKCdcXCcnK3V0aWxfZXNjYXBlX3N0cih4KSsnXFwnJykgOiB4O1xufTtcblxudmFyIGVzY2FwZV9zdHJfcmUgPSAvKF58W15cXFxcXSknL2c7XG5cbmZ1bmN0aW9uIHV0aWxfZXNjYXBlX3N0cih4KSB7XG4gIHJldHVybiB4LnJlcGxhY2UoZXNjYXBlX3N0cl9yZSwgJyQxXFxcXFxcJycpO1xufVxuXG4vLyBkYXRhIGFjY2VzcyBmdW5jdGlvbnNcblxudmFyIGZpZWxkX3JlID0gL1xcWyguKj8pXFxdfFteLlxcW10rL2c7XG5cbnUuZmllbGQgPSBmdW5jdGlvbihmKSB7XG4gIHJldHVybiBTdHJpbmcoZikubWF0Y2goZmllbGRfcmUpLm1hcChmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGRbMF0gIT09ICdbJyA/IGQgOlxuICAgICAgZFsxXSAhPT0gXCInXCIgJiYgZFsxXSAhPT0gJ1wiJyA/IGQuc2xpY2UoMSwgLTEpIDpcbiAgICAgIGQuc2xpY2UoMiwgLTIpLnJlcGxhY2UoL1xcXFwoW1wiJ10pL2csICckMScpO1xuICB9KTtcbn07XG5cbnUuYWNjZXNzb3IgPSBmdW5jdGlvbihmKSB7XG4gIHZhciBzO1xuICByZXR1cm4gZj09bnVsbCB8fCB1LmlzRnVuY3Rpb24oZikgPyBmIDpcbiAgICB1Lm5hbWVkZnVuYyhmLCAocyA9IHUuZmllbGQoZikpLmxlbmd0aCA+IDEgP1xuICAgICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gcy5yZWR1Y2UoZnVuY3Rpb24oeCxmKSB7IHJldHVybiB4W2ZdOyB9LCB4KTsgfSA6XG4gICAgICBmdW5jdGlvbih4KSB7IHJldHVybiB4W2ZdOyB9XG4gICAgKTtcbn07XG5cbi8vIHNob3J0LWN1dCBmb3IgYWNjZXNzb3JcbnUuJCA9IHUuYWNjZXNzb3I7XG5cbnUubXV0YXRvciA9IGZ1bmN0aW9uKGYpIHtcbiAgdmFyIHM7XG4gIHJldHVybiB1LmlzU3RyaW5nKGYpICYmIChzPXUuZmllbGQoZikpLmxlbmd0aCA+IDEgP1xuICAgIGZ1bmN0aW9uKHgsIHYpIHtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxzLmxlbmd0aC0xOyArK2kpIHggPSB4W3NbaV1dO1xuICAgICAgeFtzW2ldXSA9IHY7XG4gICAgfSA6XG4gICAgZnVuY3Rpb24oeCwgdikgeyB4W2ZdID0gdjsgfTtcbn07XG5cblxudS4kZnVuYyA9IGZ1bmN0aW9uKG5hbWUsIG9wKSB7XG4gIHJldHVybiBmdW5jdGlvbihmKSB7XG4gICAgZiA9IHUuJChmKSB8fCB1LmlkZW50aXR5O1xuICAgIHZhciBuID0gbmFtZSArICh1Lm5hbWUoZikgPyAnXycrdS5uYW1lKGYpIDogJycpO1xuICAgIHJldHVybiB1Lm5hbWVkZnVuYyhuLCBmdW5jdGlvbihkKSB7IHJldHVybiBvcChmKGQpKTsgfSk7XG4gIH07XG59O1xuXG51LiR2YWxpZCAgPSB1LiRmdW5jKCd2YWxpZCcsIHUuaXNWYWxpZCk7XG51LiRsZW5ndGggPSB1LiRmdW5jKCdsZW5ndGgnLCB1Lmxlbmd0aCk7XG5cbnUuJGluID0gZnVuY3Rpb24oZiwgdmFsdWVzKSB7XG4gIGYgPSB1LiQoZik7XG4gIHZhciBtYXAgPSB1LmlzQXJyYXkodmFsdWVzKSA/IHUudG9NYXAodmFsdWVzKSA6IHZhbHVlcztcbiAgcmV0dXJuIGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhbWFwW2YoZCldOyB9O1xufTtcblxudS4keWVhciAgID0gdS4kZnVuYygneWVhcicsIHRpbWUueWVhci51bml0KTtcbnUuJG1vbnRoICA9IHUuJGZ1bmMoJ21vbnRoJywgdGltZS5tb250aHMudW5pdCk7XG51LiRkYXRlICAgPSB1LiRmdW5jKCdkYXRlJywgdGltZS5kYXRlcy51bml0KTtcbnUuJGRheSAgICA9IHUuJGZ1bmMoJ2RheScsIHRpbWUud2Vla2RheXMudW5pdCk7XG51LiRob3VyICAgPSB1LiRmdW5jKCdob3VyJywgdGltZS5ob3Vycy51bml0KTtcbnUuJG1pbnV0ZSA9IHUuJGZ1bmMoJ21pbnV0ZScsIHRpbWUubWludXRlcy51bml0KTtcbnUuJHNlY29uZCA9IHUuJGZ1bmMoJ3NlY29uZCcsIHRpbWUuc2Vjb25kcy51bml0KTtcblxudS4kdXRjWWVhciAgID0gdS4kZnVuYygndXRjWWVhcicsIHV0Yy55ZWFyLnVuaXQpO1xudS4kdXRjTW9udGggID0gdS4kZnVuYygndXRjTW9udGgnLCB1dGMubW9udGhzLnVuaXQpO1xudS4kdXRjRGF0ZSAgID0gdS4kZnVuYygndXRjRGF0ZScsIHV0Yy5kYXRlcy51bml0KTtcbnUuJHV0Y0RheSAgICA9IHUuJGZ1bmMoJ3V0Y0RheScsIHV0Yy53ZWVrZGF5cy51bml0KTtcbnUuJHV0Y0hvdXIgICA9IHUuJGZ1bmMoJ3V0Y0hvdXInLCB1dGMuaG91cnMudW5pdCk7XG51LiR1dGNNaW51dGUgPSB1LiRmdW5jKCd1dGNNaW51dGUnLCB1dGMubWludXRlcy51bml0KTtcbnUuJHV0Y1NlY29uZCA9IHUuJGZ1bmMoJ3V0Y1NlY29uZCcsIHV0Yy5zZWNvbmRzLnVuaXQpO1xuXG4vLyBjb21wYXJpc29uIC8gc29ydGluZyBmdW5jdGlvbnNcblxudS5jb21wYXJhdG9yID0gZnVuY3Rpb24oc29ydCkge1xuICB2YXIgc2lnbiA9IFtdO1xuICBpZiAoc29ydCA9PT0gdW5kZWZpbmVkKSBzb3J0ID0gW107XG4gIHNvcnQgPSB1LmFycmF5KHNvcnQpLm1hcChmdW5jdGlvbihmKSB7XG4gICAgdmFyIHMgPSAxO1xuICAgIGlmICAgICAgKGZbMF0gPT09ICctJykgeyBzID0gLTE7IGYgPSBmLnNsaWNlKDEpOyB9XG4gICAgZWxzZSBpZiAoZlswXSA9PT0gJysnKSB7IHMgPSArMTsgZiA9IGYuc2xpY2UoMSk7IH1cbiAgICBzaWduLnB1c2gocyk7XG4gICAgcmV0dXJuIHUuYWNjZXNzb3IoZik7XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24oYSxiKSB7XG4gICAgdmFyIGksIG4sIGYsIHgsIHk7XG4gICAgZm9yIChpPTAsIG49c29ydC5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBmID0gc29ydFtpXTsgeCA9IGYoYSk7IHkgPSBmKGIpO1xuICAgICAgaWYgKHggPCB5KSByZXR1cm4gLTEgKiBzaWduW2ldO1xuICAgICAgaWYgKHggPiB5KSByZXR1cm4gc2lnbltpXTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG59O1xuXG51LmNtcCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoYSA+PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoYSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChiID09PSBudWxsKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIE5hTjtcbn07XG5cbnUubnVtY21wID0gZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSAtIGI7IH07XG5cbnUuc3RhYmxlc29ydCA9IGZ1bmN0aW9uKGFycmF5LCBzb3J0QnksIGtleUZuKSB7XG4gIHZhciBpbmRpY2VzID0gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKGlkeCwgdiwgaSkge1xuICAgIHJldHVybiAoaWR4W2tleUZuKHYpXSA9IGksIGlkeCk7XG4gIH0sIHt9KTtcblxuICBhcnJheS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgc2EgPSBzb3J0QnkoYSksXG4gICAgICAgIHNiID0gc29ydEJ5KGIpO1xuICAgIHJldHVybiBzYSA8IHNiID8gLTEgOiBzYSA+IHNiID8gMVxuICAgICAgICAgOiAoaW5kaWNlc1trZXlGbihhKV0gLSBpbmRpY2VzW2tleUZuKGIpXSk7XG4gIH0pO1xuXG4gIHJldHVybiBhcnJheTtcbn07XG5cblxuLy8gc3RyaW5nIGZ1bmN0aW9uc1xuXG51LnBhZCA9IGZ1bmN0aW9uKHMsIGxlbmd0aCwgcG9zLCBwYWRjaGFyKSB7XG4gIHBhZGNoYXIgPSBwYWRjaGFyIHx8IFwiIFwiO1xuICB2YXIgZCA9IGxlbmd0aCAtIHMubGVuZ3RoO1xuICBpZiAoZCA8PSAwKSByZXR1cm4gcztcbiAgc3dpdGNoIChwb3MpIHtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHJldHVybiBzdHJyZXAoZCwgcGFkY2hhcikgKyBzO1xuICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIHJldHVybiBzdHJyZXAoTWF0aC5mbG9vcihkLzIpLCBwYWRjaGFyKSArXG4gICAgICAgICBzICsgc3RycmVwKE1hdGguY2VpbChkLzIpLCBwYWRjaGFyKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHMgKyBzdHJyZXAoZCwgcGFkY2hhcik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHN0cnJlcChuLCBzdHIpIHtcbiAgdmFyIHMgPSBcIlwiLCBpO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHMgKz0gc3RyO1xuICByZXR1cm4gcztcbn1cblxudS50cnVuY2F0ZSA9IGZ1bmN0aW9uKHMsIGxlbmd0aCwgcG9zLCB3b3JkLCBlbGxpcHNpcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGg7XG4gIGlmIChsZW4gPD0gbGVuZ3RoKSByZXR1cm4gcztcbiAgZWxsaXBzaXMgPSBlbGxpcHNpcyAhPT0gdW5kZWZpbmVkID8gU3RyaW5nKGVsbGlwc2lzKSA6ICdcXHUyMDI2JztcbiAgdmFyIGwgPSBNYXRoLm1heCgwLCBsZW5ndGggLSBlbGxpcHNpcy5sZW5ndGgpO1xuXG4gIHN3aXRjaCAocG9zKSB7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICByZXR1cm4gZWxsaXBzaXMgKyAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbCwxKSA6IHMuc2xpY2UobGVuLWwpKTtcbiAgICBjYXNlICdtaWRkbGUnOlxuICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICB2YXIgbDEgPSBNYXRoLmNlaWwobC8yKSwgbDIgPSBNYXRoLmZsb29yKGwvMik7XG4gICAgICByZXR1cm4gKHdvcmQgPyB0cnVuY2F0ZU9uV29yZChzLGwxKSA6IHMuc2xpY2UoMCxsMSkpICtcbiAgICAgICAgZWxsaXBzaXMgKyAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbDIsMSkgOiBzLnNsaWNlKGxlbi1sMikpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gKHdvcmQgPyB0cnVuY2F0ZU9uV29yZChzLGwpIDogcy5zbGljZSgwLGwpKSArIGVsbGlwc2lzO1xuICB9XG59O1xuXG5mdW5jdGlvbiB0cnVuY2F0ZU9uV29yZChzLCBsZW4sIHJldikge1xuICB2YXIgY250ID0gMCwgdG9rID0gcy5zcGxpdCh0cnVuY2F0ZV93b3JkX3JlKTtcbiAgaWYgKHJldikge1xuICAgIHMgPSAodG9rID0gdG9rLnJldmVyc2UoKSlcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24odykgeyBjbnQgKz0gdy5sZW5ndGg7IHJldHVybiBjbnQgPD0gbGVuOyB9KVxuICAgICAgLnJldmVyc2UoKTtcbiAgfSBlbHNlIHtcbiAgICBzID0gdG9rLmZpbHRlcihmdW5jdGlvbih3KSB7IGNudCArPSB3Lmxlbmd0aDsgcmV0dXJuIGNudCA8PSBsZW47IH0pO1xuICB9XG4gIHJldHVybiBzLmxlbmd0aCA/IHMuam9pbignJykudHJpbSgpIDogdG9rWzBdLnNsaWNlKDAsIGxlbik7XG59XG5cbnZhciB0cnVuY2F0ZV93b3JkX3JlID0gLyhbXFx1MDAwOVxcdTAwMEFcXHUwMDBCXFx1MDAwQ1xcdTAwMERcXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTIwMjhcXHUyMDI5XFx1MzAwMFxcdUZFRkZdKS87XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vZ2xvYmFscycpO1xuXG52YXIgY29uc3RzID0gcmVxdWlyZSgnLi9jb25zdHMnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICB2bGZpZWxkID0gcmVxdWlyZSgnLi9maWVsZCcpLFxuICB2bGVuYyA9IHJlcXVpcmUoJy4vZW5jJyksXG4gIHNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hL3NjaGVtYScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gRW5jb2Rpbmcoc3BlYywgdGhlbWUpIHtcbiAgICB2YXIgZGVmYXVsdHMgPSBzY2hlbWEuaW5zdGFudGlhdGUoKSxcbiAgICAgIHNwZWNFeHRlbmRlZCA9IHNjaGVtYS51dGlsLm1lcmdlKGRlZmF1bHRzLCB0aGVtZSB8fCB7fSwgc3BlYykgO1xuXG4gICAgdGhpcy5fZGF0YSA9IHNwZWNFeHRlbmRlZC5kYXRhO1xuICAgIHRoaXMuX21hcmt0eXBlID0gc3BlY0V4dGVuZGVkLm1hcmt0eXBlO1xuICAgIHRoaXMuX2VuYyA9IHNwZWNFeHRlbmRlZC5lbmNvZGluZztcbiAgICB0aGlzLl9jb25maWcgPSBzcGVjRXh0ZW5kZWQuY29uZmlnO1xuICAgIHRoaXMuX2ZpbHRlciA9IHNwZWNFeHRlbmRlZC5maWx0ZXI7XG4gICAgLy8gdGhpcy5fdmVnYTIgPSB0cnVlO1xuICB9XG5cbiAgdmFyIHByb3RvID0gRW5jb2RpbmcucHJvdG90eXBlO1xuXG4gIEVuY29kaW5nLmZyb21TaG9ydGhhbmQgPSBmdW5jdGlvbihzaG9ydGhhbmQsIGRhdGEsIGNvbmZpZywgdGhlbWUpIHtcbiAgICB2YXIgYyA9IGNvbnN0cy5zaG9ydGhhbmQsXG4gICAgICAgIHNwbGl0ID0gc2hvcnRoYW5kLnNwbGl0KGMuZGVsaW0pLFxuICAgICAgICBtYXJrdHlwZSA9IHNwbGl0LnNoaWZ0KCkuc3BsaXQoYy5hc3NpZ24pWzFdLnRyaW0oKSxcbiAgICAgICAgZW5jID0gdmxlbmMuZnJvbVNob3J0aGFuZChzcGxpdCk7XG5cbiAgICByZXR1cm4gbmV3IEVuY29kaW5nKHtcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBtYXJrdHlwZTogbWFya3R5cGUsXG4gICAgICBlbmNvZGluZzogZW5jLFxuICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICBmaWx0ZXI6IFtdXG4gICAgfSwgdGhlbWUpO1xuICB9O1xuXG4gIEVuY29kaW5nLmZyb21TcGVjID0gZnVuY3Rpb24oc3BlYywgdGhlbWUpIHtcbiAgICByZXR1cm4gbmV3IEVuY29kaW5nKHNwZWMsIHRoZW1lKTtcbiAgfTtcblxuICBwcm90by50b1Nob3J0aGFuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjID0gY29uc3RzLnNob3J0aGFuZDtcbiAgICByZXR1cm4gJ21hcmsnICsgYy5hc3NpZ24gKyB0aGlzLl9tYXJrdHlwZSArXG4gICAgICBjLmRlbGltICsgdmxlbmMuc2hvcnRoYW5kKHRoaXMuX2VuYyk7XG4gIH07XG5cbiAgRW5jb2Rpbmcuc2hvcnRoYW5kID0gZnVuY3Rpb24gKHNwZWMpIHtcbiAgICB2YXIgYyA9IGNvbnN0cy5zaG9ydGhhbmQ7XG4gICAgcmV0dXJuICdtYXJrJyArIGMuYXNzaWduICsgc3BlYy5tYXJrdHlwZSArXG4gICAgICBjLmRlbGltICsgdmxlbmMuc2hvcnRoYW5kKHNwZWMuZW5jb2RpbmcpO1xuICB9O1xuXG4gIEVuY29kaW5nLnNwZWNGcm9tU2hvcnRoYW5kID0gZnVuY3Rpb24oc2hvcnRoYW5kLCBkYXRhLCBjb25maWcsIGV4Y2x1ZGVDb25maWcpIHtcbiAgICByZXR1cm4gRW5jb2RpbmcuZnJvbVNob3J0aGFuZChzaG9ydGhhbmQsIGRhdGEsIGNvbmZpZykudG9TcGVjKGV4Y2x1ZGVDb25maWcpO1xuICB9O1xuXG4gIHByb3RvLnRvU3BlYyA9IGZ1bmN0aW9uKGV4Y2x1ZGVDb25maWcsIGV4Y2x1ZGVEYXRhKSB7XG4gICAgdmFyIGVuYyA9IHV0aWwuZHVwbGljYXRlKHRoaXMuX2VuYyksXG4gICAgICBzcGVjO1xuXG4gICAgc3BlYyA9IHtcbiAgICAgIG1hcmt0eXBlOiB0aGlzLl9tYXJrdHlwZSxcbiAgICAgIGVuY29kaW5nOiBlbmMsXG4gICAgICBmaWx0ZXI6IHRoaXMuX2ZpbHRlclxuICAgIH07XG5cbiAgICBpZiAoIWV4Y2x1ZGVDb25maWcpIHtcbiAgICAgIHNwZWMuY29uZmlnID0gdXRpbC5kdXBsaWNhdGUodGhpcy5fY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAoIWV4Y2x1ZGVEYXRhKSB7XG4gICAgICBzcGVjLmRhdGEgPSB1dGlsLmR1cGxpY2F0ZSh0aGlzLl9kYXRhKTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgZGVmYXVsdHNcbiAgICB2YXIgZGVmYXVsdHMgPSBzY2hlbWEuaW5zdGFudGlhdGUoKTtcbiAgICByZXR1cm4gc2NoZW1hLnV0aWwuc3VidHJhY3Qoc3BlYywgZGVmYXVsdHMpO1xuICB9O1xuXG5cbiAgcHJvdG8ubWFya3R5cGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFya3R5cGU7XG4gIH07XG5cbiAgcHJvdG8uaXMgPSBmdW5jdGlvbihtKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcmt0eXBlID09PSBtO1xuICB9O1xuXG4gIHByb3RvLmhhcyA9IGZ1bmN0aW9uKGVuY1R5cGUpIHtcbiAgICAvLyBlcXVpdmFsZW50IHRvIGNhbGxpbmcgdmxlbmMuaGFzKHRoaXMuX2VuYywgZW5jVHlwZSlcbiAgICByZXR1cm4gdGhpcy5fZW5jW2VuY1R5cGVdLm5hbWUgIT09IHVuZGVmaW5lZDtcbiAgfTtcblxuICBwcm90by5maWVsZCA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF07XG4gIH07XG5cbiAgcHJvdG8uZmlsdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZpbHRlck51bGwgPSBbXSxcbiAgICAgIGZpZWxkcyA9IHRoaXMuZmllbGRzKCksXG4gICAgICBzZWxmID0gdGhpcztcblxuICAgIHV0aWwuZm9yRWFjaChmaWVsZHMsIGZ1bmN0aW9uKGZpZWxkTGlzdCwgZmllbGROYW1lKSB7XG4gICAgICBpZiAoZmllbGROYW1lID09PSAnKicpIHJldHVybjsgLy9jb3VudFxuXG4gICAgICBpZiAoKHNlbGYuY29uZmlnKCdmaWx0ZXJOdWxsJykuUSAmJiBmaWVsZExpc3QuY29udGFpbnNUeXBlW1FdKSB8fFxuICAgICAgICAgIChzZWxmLmNvbmZpZygnZmlsdGVyTnVsbCcpLlQgJiYgZmllbGRMaXN0LmNvbnRhaW5zVHlwZVtUXSkgfHxcbiAgICAgICAgICAoc2VsZi5jb25maWcoJ2ZpbHRlck51bGwnKS5PICYmIGZpZWxkTGlzdC5jb250YWluc1R5cGVbT10pIHx8XG4gICAgICAgICAgKHNlbGYuY29uZmlnKCdmaWx0ZXJOdWxsJykuTiAmJiBmaWVsZExpc3QuY29udGFpbnNUeXBlW05dKSkge1xuICAgICAgICBmaWx0ZXJOdWxsLnB1c2goe1xuICAgICAgICAgIG9wZXJhbmRzOiBbZmllbGROYW1lXSxcbiAgICAgICAgICBvcGVyYXRvcjogJ25vdE51bGwnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZpbHRlck51bGwuY29uY2F0KHRoaXMuX2ZpbHRlcik7XG4gIH07XG5cbiAgLy8gZ2V0IFwiZmllbGRcIiByZWZlcmVuY2UgZm9yIHZlZ2FcbiAgcHJvdG8uZmllbGRSZWYgPSBmdW5jdGlvbihldCwgb3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgIG9wdC5kYXRhID0gIXRoaXMuX3ZlZ2EyICYmIChvcHQuZGF0YSAhPT0gZmFsc2UpO1xuICAgIHJldHVybiB2bGZpZWxkLmZpZWxkUmVmKHRoaXMuX2VuY1tldF0sIG9wdCk7XG4gIH07XG5cbiAgcHJvdG8uZmllbGROYW1lID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5uYW1lO1xuICB9O1xuXG4gIC8qXG4gICAqIHJldHVybiBrZXktdmFsdWUgcGFpcnMgb2YgZmllbGQgbmFtZSBhbmQgbGlzdCBvZiBmaWVsZHMgb2YgdGhhdCBmaWVsZCBuYW1lXG4gICAqL1xuICBwcm90by5maWVsZHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmxlbmMuZmllbGRzKHRoaXMuX2VuYyk7XG4gIH07XG5cbiAgcHJvdG8uZmllbGRUaXRsZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgaWYgKHZsZmllbGQuaXNDb3VudCh0aGlzLl9lbmNbZXRdKSkge1xuICAgICAgcmV0dXJuIHZsZmllbGQuY291bnQuZGlzcGxheU5hbWU7XG4gICAgfVxuICAgIHZhciBmbiA9IHRoaXMuX2VuY1tldF0uYWdncmVnYXRlIHx8IHRoaXMuX2VuY1tldF0udGltZVVuaXQgfHwgKHRoaXMuX2VuY1tldF0uYmluICYmICdiaW4nKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHZhciB1cHBlcmNhc2UgPSBmbiA9PT0gJ2F2ZycgPyAnTUVBTicgOmZuLnRvVXBwZXJDYXNlKCk7XG4gICAgICByZXR1cm4gdXBwZXJjYXNlICsgJygnICsgdGhpcy5fZW5jW2V0XS5uYW1lICsgJyknO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5uYW1lO1xuICAgIH1cbiAgfTtcblxuICBwcm90by5zY2FsZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0uc2NhbGUgfHwge307XG4gIH07XG5cbiAgcHJvdG8uYXhpcyA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0uYXhpcyB8fCB7fTtcbiAgfTtcblxuICBwcm90by5iYW5kU2l6ZSA9IGZ1bmN0aW9uKGVuY1R5cGUsIHVzZVNtYWxsQmFuZCkge1xuICAgIHVzZVNtYWxsQmFuZCA9IHVzZVNtYWxsQmFuZCB8fFxuICAgICAgLy9pc0JhbmRJblNtYWxsTXVsdGlwbGVzXG4gICAgICAoZW5jVHlwZSA9PT0gWSAmJiB0aGlzLmhhcyhST1cpICYmIHRoaXMuaGFzKFkpKSB8fFxuICAgICAgKGVuY1R5cGUgPT09IFggJiYgdGhpcy5oYXMoQ09MKSAmJiB0aGlzLmhhcyhYKSk7XG5cbiAgICAvLyBpZiBiYW5kLnNpemUgaXMgZXhwbGljaXRseSBzcGVjaWZpZWQsIGZvbGxvdyB0aGUgc3BlY2lmaWNhdGlvbiwgb3RoZXJ3aXNlIGRyYXcgdmFsdWUgZnJvbSBjb25maWcuXG4gICAgcmV0dXJuIHRoaXMuZmllbGQoZW5jVHlwZSkuYmFuZC5zaXplIHx8XG4gICAgICB0aGlzLmNvbmZpZyh1c2VTbWFsbEJhbmQgPyAnc21hbGxCYW5kU2l6ZScgOiAnbGFyZ2VCYW5kU2l6ZScpO1xuICB9O1xuXG4gIHByb3RvLmFnZ3JlZ2F0ZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0uYWdncmVnYXRlO1xuICB9O1xuXG4gIC8vIHJldHVybnMgZmFsc2UgaWYgYmlubmluZyBpcyBkaXNhYmxlZCwgb3RoZXJ3aXNlIGFuIG9iamVjdCB3aXRoIGJpbm5pbmcgcHJvcGVydGllc1xuICBwcm90by5iaW4gPSBmdW5jdGlvbihldCkge1xuICAgIHZhciBiaW4gPSB0aGlzLl9lbmNbZXRdLmJpbjtcbiAgICBpZiAoYmluID09PSB7fSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYmluID09PSB0cnVlKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF4Ymluczogc2NoZW1hLk1BWEJJTlNfREVGQVVMVFxuICAgICAgfTtcbiAgICByZXR1cm4gYmluO1xuICB9O1xuXG4gIHByb3RvLnZhbHVlID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS52YWx1ZTtcbiAgfTtcblxuICBwcm90by5udW1iZXJGb3JtYXQgPSBmdW5jdGlvbihmaWVsZFN0YXRzKSB7XG4gICAgdmFyIGZvcm1hdENvbmZpZyA9IGZpZWxkU3RhdHMubWF4ID4gdGhpcy5jb25maWcoJ21heFNtYWxsTnVtYmVyJykgP1xuICAgICAgJ2xhcmdlTnVtYmVyRm9ybWF0JzogJ3NtYWxsTnVtYmVyRm9ybWF0JztcbiAgICByZXR1cm4gdGhpcy5jb25maWcoZm9ybWF0Q29uZmlnKTtcbiAgfTtcblxuICBwcm90by5zb3J0ID0gZnVuY3Rpb24oZXQsIHN0YXRzKSB7XG4gICAgdmFyIHNvcnQgPSB0aGlzLl9lbmNbZXRdLnNvcnQsXG4gICAgICBlbmMgPSB0aGlzLl9lbmMsXG4gICAgICBpc1R5cGVzID0gdmxmaWVsZC5pc1R5cGVzO1xuXG4gICAgaWYgKCghc29ydCB8fCBzb3J0Lmxlbmd0aD09PTApICYmXG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIEVuY29kaW5nLnRvZ2dsZVNvcnQuc3VwcG9ydCh7ZW5jb2Rpbmc6dGhpcy5fZW5jfSwgc3RhdHMsIHRydWUpICYmIC8vSEFDS1xuICAgICAgICB0aGlzLmNvbmZpZygndG9nZ2xlU29ydCcpID09PSBRXG4gICAgICApIHtcbiAgICAgIHZhciBxRmllbGQgPSBpc1R5cGVzKGVuYy54LCBbTiwgT10pID8gZW5jLnkgOiBlbmMueDtcblxuICAgICAgaWYgKGlzVHlwZXMoZW5jW2V0XSwgW04sIE9dKSkge1xuICAgICAgICBzb3J0ID0gW3tcbiAgICAgICAgICBuYW1lOiBxRmllbGQubmFtZSxcbiAgICAgICAgICBhZ2dyZWdhdGU6IHFGaWVsZC5hZ2dyZWdhdGUsXG4gICAgICAgICAgdHlwZTogcUZpZWxkLnR5cGUsXG4gICAgICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgICAgICB9XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc29ydDtcbiAgfTtcblxuICBwcm90by5tYXAgPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIHZsZW5jLm1hcCh0aGlzLl9lbmMsIGYpO1xuICB9O1xuXG4gIHByb3RvLnJlZHVjZSA9IGZ1bmN0aW9uKGYsIGluaXQpIHtcbiAgICByZXR1cm4gdmxlbmMucmVkdWNlKHRoaXMuX2VuYywgZiwgaW5pdCk7XG4gIH07XG5cbiAgcHJvdG8uZm9yRWFjaCA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gdmxlbmMuZm9yRWFjaCh0aGlzLl9lbmMsIGYpO1xuICB9O1xuXG4gIHByb3RvLnR5cGUgPSBmdW5jdGlvbihldCkge1xuICAgIHJldHVybiB0aGlzLmhhcyhldCkgPyB0aGlzLl9lbmNbZXRdLnR5cGUgOiBudWxsO1xuICB9O1xuXG4gIHByb3RvLmlzVHlwZSA9IGZ1bmN0aW9uKGV0LCB0eXBlKSB7XG4gICAgdmFyIGZpZWxkID0gdGhpcy5maWVsZChldCk7XG4gICAgcmV0dXJuIGZpZWxkICYmIHZsZmllbGQuaXNUeXBlKGZpZWxkLCB0eXBlKTtcbiAgfTtcblxuXG4gIHByb3RvLmlzVHlwZXMgPSBmdW5jdGlvbihldCwgdHlwZSkge1xuICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGQoZXQpO1xuICAgIHJldHVybiBmaWVsZCAmJiB2bGZpZWxkLmlzVHlwZXMoZmllbGQsIHR5cGUpO1xuICB9O1xuXG4gIEVuY29kaW5nLmlzT3JkaW5hbFNjYWxlID0gZnVuY3Rpb24oZW5jb2RpbmcsIGVuY1R5cGUpIHtcbiAgICByZXR1cm4gdmxmaWVsZC5pc09yZGluYWxTY2FsZShlbmNvZGluZy5maWVsZChlbmNUeXBlKSk7XG4gIH07XG5cbiAgRW5jb2RpbmcuaXNEaW1lbnNpb24gPSBmdW5jdGlvbihlbmNvZGluZywgZW5jVHlwZSkge1xuICAgIHJldHVybiB2bGZpZWxkLmlzRGltZW5zaW9uKGVuY29kaW5nLmZpZWxkKGVuY1R5cGUpKTtcbiAgfTtcblxuICBFbmNvZGluZy5pc01lYXN1cmUgPSBmdW5jdGlvbihlbmNvZGluZywgZW5jVHlwZSkge1xuICAgIHJldHVybiB2bGZpZWxkLmlzTWVhc3VyZShlbmNvZGluZy5maWVsZChlbmNUeXBlKSk7XG4gIH07XG5cbiAgcHJvdG8uaXNPcmRpbmFsU2NhbGUgPSBmdW5jdGlvbihlbmNUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGVuY1R5cGUpICYmIEVuY29kaW5nLmlzT3JkaW5hbFNjYWxlKHRoaXMsIGVuY1R5cGUpO1xuICB9O1xuXG4gIHByb3RvLmlzRGltZW5zaW9uID0gZnVuY3Rpb24oZW5jVHlwZSkge1xuICAgIHJldHVybiB0aGlzLmhhcyhlbmNUeXBlKSAmJiBFbmNvZGluZy5pc0RpbWVuc2lvbih0aGlzLCBlbmNUeXBlKTtcbiAgfTtcblxuICBwcm90by5pc01lYXN1cmUgPSBmdW5jdGlvbihlbmNUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGVuY1R5cGUpICYmIEVuY29kaW5nLmlzTWVhc3VyZSh0aGlzLCBlbmNUeXBlKTtcbiAgfTtcblxuICBwcm90by5pc0FnZ3JlZ2F0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2bGVuYy5pc0FnZ3JlZ2F0ZSh0aGlzLl9lbmMpO1xuICB9O1xuXG4gIHByb3RvLmRhdGFUYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzQWdncmVnYXRlKCkgPyBBR0dSRUdBVEUgOiBSQVc7XG4gIH07XG5cbiAgRW5jb2RpbmcuaXNBZ2dyZWdhdGUgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgcmV0dXJuIHZsZW5jLmlzQWdncmVnYXRlKHNwZWMuZW5jb2RpbmcpO1xuICB9O1xuXG4gIEVuY29kaW5nLmFsd2F5c05vT2NjbHVzaW9uID0gZnVuY3Rpb24oc3BlYykge1xuICAgIC8vIEZJWE1FIHJhdyBPeFEgd2l0aCAjIG9mIHJvd3MgPSAjIG9mIE9cbiAgICByZXR1cm4gdmxlbmMuaXNBZ2dyZWdhdGUoc3BlYy5lbmNvZGluZyk7XG4gIH07XG5cbiAgRW5jb2RpbmcuaXNTdGFjayA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAvLyBGSVhNRSB1cGRhdGUgdGhpcyBvbmNlIHdlIGhhdmUgY29udHJvbCBmb3Igc3RhY2sgLi4uXG4gICAgcmV0dXJuIChzcGVjLm1hcmt0eXBlID09PSAnYmFyJyB8fCBzcGVjLm1hcmt0eXBlID09PSAnYXJlYScpICYmXG4gICAgICBzcGVjLmVuY29kaW5nLmNvbG9yO1xuICB9O1xuXG4gIHByb3RvLmlzU3RhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBGSVhNRSB1cGRhdGUgdGhpcyBvbmNlIHdlIGhhdmUgY29udHJvbCBmb3Igc3RhY2sgLi4uXG4gICAgcmV0dXJuICh0aGlzLmlzKCdiYXInKSB8fCB0aGlzLmlzKCdhcmVhJykpICYmIHRoaXMuaGFzKCdjb2xvcicpO1xuICB9O1xuXG4gIHByb3RvLmRldGFpbHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZW5jb2RpbmcgPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLnJlZHVjZShmdW5jdGlvbihyZWZzLCBmaWVsZCwgZW5jVHlwZSkge1xuICAgICAgaWYgKCFmaWVsZC5hZ2dyZWdhdGUgJiYgKGVuY1R5cGUgIT09IFggJiYgZW5jVHlwZSAhPT0gWSkpIHtcbiAgICAgICAgcmVmcy5wdXNoKGVuY29kaW5nLmZpZWxkUmVmKGVuY1R5cGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWZzO1xuICAgIH0sIFtdKTtcbiAgfTtcblxuICBwcm90by5mYWNldHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZW5jb2RpbmcgPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLnJlZHVjZShmdW5jdGlvbihyZWZzLCBmaWVsZCwgZW5jVHlwZSkge1xuICAgICAgaWYgKCFmaWVsZC5hZ2dyZWdhdGUgJiYgKGVuY1R5cGUgPT0gUk9XIHx8IGVuY1R5cGUgPT0gQ09MKSkge1xuICAgICAgICByZWZzLnB1c2goZW5jb2RpbmcuZmllbGRSZWYoZW5jVHlwZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlZnM7XG4gICAgfSwgW10pO1xuICB9O1xuXG4gIHByb3RvLmNhcmRpbmFsaXR5ID0gZnVuY3Rpb24oZW5jVHlwZSwgc3RhdHMpIHtcbiAgICByZXR1cm4gdmxmaWVsZC5jYXJkaW5hbGl0eSh0aGlzLmZpZWxkKGVuY1R5cGUpLCBzdGF0cywgdGhpcy5jb25maWcoJ2ZpbHRlck51bGwnKSk7XG4gIH07XG5cbiAgcHJvdG8uaXNSYXcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNBZ2dyZWdhdGUoKTtcbiAgfTtcblxuICBwcm90by5kYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH07XG5cbiAgIC8vIHJldHVybnMgd2hldGhlciB0aGUgZW5jb2RpbmcgaGFzIHZhbHVlcyBlbWJlZGRlZFxuICBwcm90by5oYXNWYWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFscyA9IHRoaXMuZGF0YSgpLnZhbHVlcztcbiAgICByZXR1cm4gdmFscyAmJiB2YWxzLmxlbmd0aDtcbiAgfTtcblxuICBwcm90by5jb25maWcgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZ1tuYW1lXTtcbiAgfTtcblxuICBFbmNvZGluZy50cmFuc3Bvc2UgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgdmFyIG9sZGVuYyA9IHNwZWMuZW5jb2RpbmcsXG4gICAgICBlbmMgPSB1dGlsLmR1cGxpY2F0ZShzcGVjLmVuY29kaW5nKTtcbiAgICBlbmMueCA9IG9sZGVuYy55O1xuICAgIGVuYy55ID0gb2xkZW5jLng7XG4gICAgZW5jLnJvdyA9IG9sZGVuYy5jb2w7XG4gICAgZW5jLmNvbCA9IG9sZGVuYy5yb3c7XG4gICAgc3BlYy5lbmNvZGluZyA9IGVuYztcbiAgICByZXR1cm4gc3BlYztcbiAgfTtcblxuICAvLyBGSVhNRTogUkVNT1ZFIGV2ZXJ5dGhpbmcgYmVsb3cgaGVyZVxuXG4gIEVuY29kaW5nLnRvZ2dsZVNvcnQgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgc3BlYy5jb25maWcgPSBzcGVjLmNvbmZpZyB8fCB7fTtcbiAgICBzcGVjLmNvbmZpZy50b2dnbGVTb3J0ID0gc3BlYy5jb25maWcudG9nZ2xlU29ydCA9PT0gUSA/IE4gOiBRO1xuICAgIHJldHVybiBzcGVjO1xuICB9O1xuXG5cbiAgRW5jb2RpbmcudG9nZ2xlU29ydC5kaXJlY3Rpb24gPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgaWYgKCFFbmNvZGluZy50b2dnbGVTb3J0LnN1cHBvcnQoc3BlYykpIHsgcmV0dXJuOyB9XG4gICAgdmFyIGVuYyA9IHNwZWMuZW5jb2Rpbmc7XG4gICAgcmV0dXJuIGVuYy54LnR5cGUgPT09IE4gPyAneCcgOiAneSc7XG4gIH07XG5cbiAgRW5jb2RpbmcudG9nZ2xlU29ydC5tb2RlID0gZnVuY3Rpb24oc3BlYykge1xuICAgIHJldHVybiBzcGVjLmNvbmZpZy50b2dnbGVTb3J0O1xuICB9O1xuXG4gIEVuY29kaW5nLnRvZ2dsZVNvcnQuc3VwcG9ydCA9IGZ1bmN0aW9uKHNwZWMsIHN0YXRzKSB7XG4gICAgdmFyIGVuYyA9IHNwZWMuZW5jb2RpbmcsXG4gICAgICBpc1R5cGVzID0gdmxmaWVsZC5pc1R5cGVzO1xuXG4gICAgaWYgKHZsZW5jLmhhcyhlbmMsIFJPVykgfHwgdmxlbmMuaGFzKGVuYywgQ09MKSB8fFxuICAgICAgIXZsZW5jLmhhcyhlbmMsIFgpIHx8ICF2bGVuYy5oYXMoZW5jLCBZKSB8fFxuICAgICAgIUVuY29kaW5nLmFsd2F5c05vT2NjbHVzaW9uKHNwZWMsIHN0YXRzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAoIGlzVHlwZXMoZW5jLngsIFtOLE9dKSAmJiB2bGZpZWxkLmlzTWVhc3VyZShlbmMueSkpID8gJ3gnIDpcbiAgICAgICggaXNUeXBlcyhlbmMueSwgW04sT10pICYmIHZsZmllbGQuaXNNZWFzdXJlKGVuYy54KSkgPyAneScgOiBmYWxzZTtcbiAgfTtcblxuICBFbmNvZGluZy50b2dnbGVGaWx0ZXJOdWxsTyA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICBzcGVjLmNvbmZpZyA9IHNwZWMuY29uZmlnIHx8IHt9O1xuICAgIHNwZWMuY29uZmlnLmZpbHRlck51bGwgPSBzcGVjLmNvbmZpZy5maWx0ZXJOdWxsIHx8IHsgLy9GSVhNRVxuICAgICAgVDogdHJ1ZSxcbiAgICAgIFE6IHRydWVcbiAgICB9O1xuICAgIHNwZWMuY29uZmlnLmZpbHRlck51bGwuTyA9ICFzcGVjLmNvbmZpZy5maWx0ZXJOdWxsLk87XG4gICAgcmV0dXJuIHNwZWM7XG4gIH07XG5cbiAgRW5jb2RpbmcudG9nZ2xlRmlsdGVyTnVsbE8uc3VwcG9ydCA9IGZ1bmN0aW9uKHNwZWMsIHN0YXRzKSB7XG4gICAgdmFyIGZpZWxkcyA9IHZsZW5jLmZpZWxkcyhzcGVjLmVuY29kaW5nKTtcbiAgICBmb3IgKHZhciBmaWVsZE5hbWUgaW4gZmllbGRzKSB7XG4gICAgICB2YXIgZmllbGRMaXN0ID0gZmllbGRzW2ZpZWxkTmFtZV07XG4gICAgICBpZiAoZmllbGRMaXN0LmNvbnRhaW5zVHlwZS5PICYmIGZpZWxkTmFtZSBpbiBzdGF0cyAmJiBzdGF0c1tmaWVsZE5hbWVdLm51bGxzID4gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHJldHVybiBFbmNvZGluZztcbn0pKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIHNldHRlciA9IHV0aWwuc2V0dGVyLFxuICBnZXR0ZXIgPSB1dGlsLmdldHRlcixcbiAgdGltZSA9IHJlcXVpcmUoJy4vdGltZScpO1xuXG52YXIgYXhpcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmF4aXMuZGVmID0gZnVuY3Rpb24obmFtZSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMsIG9wdCkge1xuICB2YXIgaXNDb2wgPSBuYW1lID09IENPTCxcbiAgICBpc1JvdyA9IG5hbWUgPT0gUk9XLFxuICAgIHR5cGUgPSBpc0NvbCA/ICd4JyA6IGlzUm93ID8gJ3knIDogbmFtZTtcblxuICB2YXIgZGVmID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgc2NhbGU6IG5hbWUsXG4gICAgcHJvcGVydGllczoge30sXG4gICAgbGF5ZXI6IGVuY29kaW5nLmZpZWxkKG5hbWUpLmF4aXMubGF5ZXIsXG4gICAgb3JpZW50OiBheGlzLm9yaWVudChuYW1lLCBlbmNvZGluZywgc3RhdHMpXG4gIH07XG5cbiAgLy8gQWRkIGF4aXMgbGFiZWwgY3VzdG9tIHNjYWxlIChmb3IgYmluIC8gdGltZSlcbiAgZGVmID0gYXhpcy5sYWJlbHMuc2NhbGUoZGVmLCBlbmNvZGluZywgbmFtZSk7XG4gIGRlZiA9IGF4aXMubGFiZWxzLmZvcm1hdChkZWYsIG5hbWUsIGVuY29kaW5nLCBzdGF0cyk7XG4gIGRlZiA9IGF4aXMubGFiZWxzLmFuZ2xlKGRlZiwgZW5jb2RpbmcsIG5hbWUpO1xuXG4gIC8vIGZvciB4LWF4aXMsIHNldCB0aWNrcyBmb3IgUSBvciByb3RhdGUgc2NhbGUgZm9yIG9yZGluYWwgc2NhbGVcbiAgaWYgKG5hbWUgPT0gWCkge1xuICAgIGlmICgoZW5jb2RpbmcuaXNEaW1lbnNpb24oWCkgfHwgZW5jb2RpbmcuaXNUeXBlKFgsIFQpKSAmJlxuICAgICAgICAhKCdhbmdsZScgaW4gZ2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywgJ2xhYmVscyddKSkpIHtcbiAgICAgIC8vIFRPRE8oa2FuaXR3KTogSnVsIDE5LCAyMDE1IC0gIzUwNiBhZGQgY29uZGl0aW9uIGZvciByb3RhdGlvblxuICAgICAgZGVmID0gYXhpcy5sYWJlbHMucm90YXRlKGRlZik7XG4gICAgfSBlbHNlIHsgLy8gUVxuICAgICAgZGVmLnRpY2tzID0gZW5jb2RpbmcuZmllbGQobmFtZSkuYXhpcy50aWNrcztcbiAgICB9XG4gIH1cblxuICAvLyBUaXRsZU9mZnNldCBkZXBlbmRzIG9uIGxhYmVscyByb3RhdGlvblxuICBkZWYudGl0bGVPZmZzZXQgPSBheGlzLnRpdGxlT2Zmc2V0KGVuY29kaW5nLCBsYXlvdXQsIG5hbWUpO1xuXG4gIC8vZGVmLm9mZnNldCBpcyB1c2VkIGluIGF4aXMuZ3JpZFxuICBpZihpc1JvdykgZGVmLm9mZnNldCA9IGF4aXMudGl0bGVPZmZzZXQoZW5jb2RpbmcsIGxheW91dCwgWSkgKyAyMDtcbiAgLy8gRklYTUUoa2FuaXR3KTogSnVsIDE5LCAyMDE1IC0gb2Zmc2V0IGZvciBjb2x1bW4gd2hlbiB4IGlzIHB1dCBvbiB0b3BcblxuICBkZWYgPSBheGlzLmdyaWQoZGVmLCBuYW1lLCBlbmNvZGluZywgbGF5b3V0KTtcbiAgZGVmID0gYXhpcy50aXRsZShkZWYsIG5hbWUsIGVuY29kaW5nLCBsYXlvdXQsIG9wdCk7XG5cbiAgaWYgKGlzUm93IHx8IGlzQ29sKSBkZWYgPSBheGlzLmhpZGVUaWNrcyhkZWYpO1xuXG4gIHJldHVybiBkZWY7XG59O1xuXG5heGlzLm9yaWVudCA9IGZ1bmN0aW9uKG5hbWUsIGVuY29kaW5nLCBzdGF0cykge1xuICB2YXIgb3JpZW50ID0gZW5jb2RpbmcuZmllbGQobmFtZSkuYXhpcy5vcmllbnQ7XG4gIGlmIChvcmllbnQpIHJldHVybiBvcmllbnQ7XG5cbiAgaWYgKG5hbWU9PT1DT0wpIHJldHVybiAndG9wJztcblxuICAvLyB4LWF4aXMgZm9yIGxvbmcgeSAtIHB1dCBvbiB0b3BcbiAgaWYgKG5hbWU9PT1YICYmIGVuY29kaW5nLmhhcyhZKSAmJiBlbmNvZGluZy5pc09yZGluYWxTY2FsZShZKSAmJiBlbmNvZGluZy5jYXJkaW5hbGl0eShZLCBzdGF0cykgPiAzMCkge1xuICAgIHJldHVybiAndG9wJztcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5heGlzLmdyaWQgPSBmdW5jdGlvbihkZWYsIG5hbWUsIGVuY29kaW5nLCBsYXlvdXQpIHtcbiAgdmFyIGNlbGxQYWRkaW5nID0gbGF5b3V0LmNlbGxQYWRkaW5nLFxuICAgIGlzQ29sID0gbmFtZSA9PSBDT0wsXG4gICAgaXNSb3cgPSBuYW1lID09IFJPVztcblxuICBpZiAoZW5jb2RpbmcuYXhpcyhuYW1lKS5ncmlkKSB7XG4gICAgZGVmLmdyaWQgPSB0cnVlO1xuXG4gICAgaWYgKGlzQ29sKSB7XG4gICAgICAvLyBzZXQgZ3JpZCBwcm9wZXJ0eSAtLSBwdXQgdGhlIGxpbmVzIG9uIHRoZSByaWdodCB0aGUgY2VsbFxuICAgICAgZGVmLnByb3BlcnRpZXMuZ3JpZCA9IHtcbiAgICAgICAgeDoge1xuICAgICAgICAgIG9mZnNldDogbGF5b3V0LmNlbGxXaWR0aCAqICgxKyBjZWxsUGFkZGluZy8yLjApLFxuICAgICAgICAgIC8vIGRlZmF1bHQgdmFsdWUocykgLS0gdmVnYSBkb2Vzbid0IGRvIHJlY3Vyc2l2ZSBtZXJnZVxuICAgICAgICAgIHNjYWxlOiAnY29sJ1xuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgdmFsdWU6IC1sYXlvdXQuY2VsbEhlaWdodCAqIChjZWxsUGFkZGluZy8yKSxcbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlOiB7IHZhbHVlOiBlbmNvZGluZy5jb25maWcoJ2NlbGxHcmlkQ29sb3InKSB9LFxuICAgICAgICBvcGFjaXR5OiB7IHZhbHVlOiBlbmNvZGluZy5jb25maWcoJ2NlbGxHcmlkT3BhY2l0eScpIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpc1Jvdykge1xuICAgICAgLy8gc2V0IGdyaWQgcHJvcGVydHkgLS0gcHV0IHRoZSBsaW5lcyBvbiB0aGUgdG9wXG4gICAgICBkZWYucHJvcGVydGllcy5ncmlkID0ge1xuICAgICAgICB5OiB7XG4gICAgICAgICAgb2Zmc2V0OiAtbGF5b3V0LmNlbGxIZWlnaHQgKiAoY2VsbFBhZGRpbmcvMiksXG4gICAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZShzKSAtLSB2ZWdhIGRvZXNuJ3QgZG8gcmVjdXJzaXZlIG1lcmdlXG4gICAgICAgICAgc2NhbGU6ICdyb3cnXG4gICAgICAgIH0sXG4gICAgICAgIHg6IHtcbiAgICAgICAgICB2YWx1ZTogZGVmLm9mZnNldFxuICAgICAgICB9LFxuICAgICAgICB4Mjoge1xuICAgICAgICAgIG9mZnNldDogZGVmLm9mZnNldCArIChsYXlvdXQuY2VsbFdpZHRoICogMC4wNSksXG4gICAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZShzKSAtLSB2ZWdhIGRvZXNuJ3QgZG8gcmVjdXJzaXZlIG1lcmdlXG4gICAgICAgICAgZ3JvdXA6ICdtYXJrLmdyb3VwLndpZHRoJyxcbiAgICAgICAgICBtdWx0OiAxXG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZTogeyB2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdjZWxsR3JpZENvbG9yJykgfSxcbiAgICAgICAgb3BhY2l0eTogeyB2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdjZWxsR3JpZE9wYWNpdHknKSB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWYucHJvcGVydGllcy5ncmlkID0ge1xuICAgICAgICBzdHJva2U6IHsgdmFsdWU6IGVuY29kaW5nLmNvbmZpZygnZ3JpZENvbG9yJykgfSxcbiAgICAgICAgb3BhY2l0eTogeyB2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdncmlkT3BhY2l0eScpIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWY7XG59O1xuXG5heGlzLmhpZGVUaWNrcyA9IGZ1bmN0aW9uKGRlZikge1xuICBkZWYucHJvcGVydGllcy50aWNrcyA9IHtvcGFjaXR5OiB7dmFsdWU6IDB9fTtcbiAgZGVmLnByb3BlcnRpZXMubWFqb3JUaWNrcyA9IHtvcGFjaXR5OiB7dmFsdWU6IDB9fTtcbiAgZGVmLnByb3BlcnRpZXMuYXhpcyA9IHtvcGFjaXR5OiB7dmFsdWU6IDB9fTtcbiAgcmV0dXJuIGRlZjtcbn07XG5cbmF4aXMudGl0bGUgPSBmdW5jdGlvbiAoZGVmLCBuYW1lLCBlbmNvZGluZywgbGF5b3V0KSB7XG4gIHZhciBheCA9IGVuY29kaW5nLmZpZWxkKG5hbWUpLmF4aXM7XG5cbiAgaWYgKGF4LnRpdGxlKSB7XG4gICAgZGVmLnRpdGxlID0gYXgudGl0bGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgbm90IGRlZmluZWQsIGF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lIGF4aXMgdGl0bGUgZnJvbSBmaWVsZCBkZWZcbiAgICB2YXIgZmllbGRUaXRsZSA9IGVuY29kaW5nLmZpZWxkVGl0bGUobmFtZSksXG4gICAgICBtYXhMZW5ndGg7XG5cbiAgICBpZiAoYXgudGl0bGVNYXhMZW5ndGgpIHtcbiAgICAgIG1heExlbmd0aCA9IGF4LnRpdGxlTWF4TGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAobmFtZT09PVgpIHtcbiAgICAgIG1heExlbmd0aCA9IGxheW91dC5jZWxsV2lkdGggLyBlbmNvZGluZy5jb25maWcoJ2NoYXJhY3RlcldpZHRoJyk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBZKSB7XG4gICAgICBtYXhMZW5ndGggPSBsYXlvdXQuY2VsbEhlaWdodCAvIGVuY29kaW5nLmNvbmZpZygnY2hhcmFjdGVyV2lkdGgnKTtcbiAgICB9XG5cbiAgICBkZWYudGl0bGUgPSBtYXhMZW5ndGggPyB1dGlsLnRydW5jYXRlKGZpZWxkVGl0bGUsIG1heExlbmd0aCkgOiBmaWVsZFRpdGxlO1xuICB9XG5cbiAgaWYgKG5hbWUgPT09IFJPVykge1xuICAgIGRlZi5wcm9wZXJ0aWVzLnRpdGxlID0ge1xuICAgICAgYW5nbGU6IHt2YWx1ZTogMH0sXG4gICAgICBhbGlnbjoge3ZhbHVlOiAncmlnaHQnfSxcbiAgICAgIGJhc2VsaW5lOiB7dmFsdWU6ICdtaWRkbGUnfSxcbiAgICAgIGR5OiB7dmFsdWU6ICgtbGF5b3V0LmhlaWdodC8yKSAtMjB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBkZWY7XG59O1xuXG5heGlzLmxhYmVscyA9IHt9O1xuXG4vKiogYWRkIGN1c3RvbSBsYWJlbCBmb3IgdGltZSB0eXBlIGFuZCBiaW4gKi9cbmF4aXMubGFiZWxzLnNjYWxlID0gZnVuY3Rpb24oZGVmLCBlbmNvZGluZywgbmFtZSkge1xuICAvLyB0aW1lXG4gIHZhciB0aW1lVW5pdCA9IGVuY29kaW5nLmZpZWxkKG5hbWUpLnRpbWVVbml0O1xuICBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFQpICYmIHRpbWVVbml0ICYmICh0aW1lLmhhc1NjYWxlKHRpbWVVbml0KSkpIHtcbiAgICBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCdsYWJlbHMnLCd0ZXh0Jywnc2NhbGUnXSwgJ3RpbWUtJysgdGltZVVuaXQpO1xuICB9XG4gIC8vIEZJWE1FIGJpblxuICByZXR1cm4gZGVmO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgbnVtYmVyIGZvcm1hdCBvciB0cnVuY2F0ZSBpZiBtYXhMYWJlbCBsZW5ndGggaXMgcHJlc2VudGVkLlxuICovXG5heGlzLmxhYmVscy5mb3JtYXQgPSBmdW5jdGlvbiAoZGVmLCBuYW1lLCBlbmNvZGluZywgc3RhdHMpIHtcbiAgdmFyIGZpZWxkU3RhdHMgPSBzdGF0c1tlbmNvZGluZy5maWVsZChuYW1lKS5uYW1lXTtcblxuICBpZiAoZW5jb2RpbmcuYXhpcyhuYW1lKS5mb3JtYXQpIHtcbiAgICBkZWYuZm9ybWF0ID0gZW5jb2RpbmcuYXhpcyhuYW1lKS5mb3JtYXQ7XG4gIH0gZWxzZSBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFEpIHx8IGZpZWxkU3RhdHMudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICBkZWYuZm9ybWF0ID0gZW5jb2RpbmcubnVtYmVyRm9ybWF0KGZpZWxkU3RhdHMpO1xuICB9IGVsc2UgaWYgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBUKSkge1xuICAgIHZhciB0aW1lVW5pdCA9IGVuY29kaW5nLmZpZWxkKG5hbWUpLnRpbWVVbml0O1xuICAgIGlmICghdGltZVVuaXQpIHtcbiAgICAgIGRlZi5mb3JtYXQgPSBlbmNvZGluZy5jb25maWcoJ3RpbWVGb3JtYXQnKTtcbiAgICB9IGVsc2UgaWYgKHRpbWVVbml0ID09PSAneWVhcicpIHtcbiAgICAgIGRlZi5mb3JtYXQgPSAnZCc7XG4gICAgfVxuICB9IGVsc2UgaWYgKGVuY29kaW5nLmlzVHlwZXMobmFtZSwgW04sIE9dKSAmJiBlbmNvZGluZy5heGlzKG5hbWUpLm1heExhYmVsTGVuZ3RoKSB7XG4gICAgc2V0dGVyKGRlZixcbiAgICAgIFsncHJvcGVydGllcycsJ2xhYmVscycsJ3RleHQnLCd0ZW1wbGF0ZSddLFxuICAgICAgJ3t7ZGF0YSB8IHRydW5jYXRlOicgKyBlbmNvZGluZy5heGlzKG5hbWUpLm1heExhYmVsTGVuZ3RoICsgJ319J1xuICAgICAgKTtcbiAgfVxuXG4gIHJldHVybiBkZWY7XG59O1xuXG5heGlzLmxhYmVscy5hbmdsZSA9IGZ1bmN0aW9uKGRlZiwgZW5jb2RpbmcsIG5hbWUpIHtcbiAgdmFyIGFuZ2xlID0gZW5jb2RpbmcuYXhpcyhuYW1lKS5sYWJlbEFuZ2xlO1xuICBpZiAodHlwZW9mIGFuZ2xlID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGRlZjtcblxuICBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCAnbGFiZWxzJywgJ2FuZ2xlJywgJ3ZhbHVlJ10sIGFuZ2xlKTtcbiAgcmV0dXJuIGRlZjtcbn07XG5cbmF4aXMubGFiZWxzLnJvdGF0ZSA9IGZ1bmN0aW9uKGRlZikge1xuIHZhciBhbGlnbiA9IGRlZi5vcmllbnQgPT09J3RvcCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsJ2xhYmVscycsICdhbmdsZScsICd2YWx1ZSddLCAyNzApO1xuIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsJ2xhYmVscycsICdhbGlnbicsICd2YWx1ZSddLCBhbGlnbik7XG4gc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywnbGFiZWxzJywgJ2Jhc2VsaW5lJywgJ3ZhbHVlJ10sICdtaWRkbGUnKTtcbiByZXR1cm4gZGVmO1xufTtcblxuYXhpcy50aXRsZU9mZnNldCA9IGZ1bmN0aW9uIChlbmNvZGluZywgbGF5b3V0LCBuYW1lKSB7XG4gIC8vIHJldHVybiBzcGVjaWZpZWQgdmFsdWUgaWYgc3BlY2lmaWVkXG4gIHZhciB2YWx1ZSA9IGVuY29kaW5nLmF4aXMobmFtZSkudGl0bGVPZmZzZXQ7XG4gIGlmICh2YWx1ZSkgIHJldHVybiB2YWx1ZTtcblxuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAvL0ZJWE1FIG1ha2UgdGhpcyBhZGp1c3RhYmxlXG4gICAgY2FzZSBST1c6IHJldHVybiAwO1xuICAgIGNhc2UgQ09MOiByZXR1cm4gMzU7XG4gIH1cbiAgcmV0dXJuIGdldHRlcihsYXlvdXQsIFtuYW1lLCAnYXhpc1RpdGxlT2Zmc2V0J10pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN1bW1hcnkgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2RhdGFsaWIvc3JjL3N0YXRzJykuc3VtbWFyeTtcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgY29tcGlsZXIgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG52YXIgRW5jb2RpbmcgPSByZXF1aXJlKCcuLi9FbmNvZGluZycpLFxuICBheGlzID0gY29tcGlsZXIuYXhpcyA9IHJlcXVpcmUoJy4vYXhpcycpLFxuICBsZWdlbmQgPSBjb21waWxlci5sZWdlbmQgPSByZXF1aXJlKCcuL2xlZ2VuZCcpLFxuICBtYXJrcyA9IGNvbXBpbGVyLm1hcmtzID0gcmVxdWlyZSgnLi9tYXJrcycpLFxuICBzY2FsZSA9IGNvbXBpbGVyLnNjYWxlID0gcmVxdWlyZSgnLi9zY2FsZScpO1xuXG5jb21waWxlci5kYXRhID0gcmVxdWlyZSgnLi9kYXRhJyk7XG5jb21waWxlci5mYWNldCA9IHJlcXVpcmUoJy4vZmFjZXQnKTtcbmNvbXBpbGVyLmdyb3VwID0gcmVxdWlyZSgnLi9ncm91cCcpO1xuY29tcGlsZXIubGF5b3V0ID0gcmVxdWlyZSgnLi9sYXlvdXQnKTtcbmNvbXBpbGVyLnNvcnQgPSByZXF1aXJlKCcuL3NvcnQnKTtcbmNvbXBpbGVyLnN0YWNrID0gcmVxdWlyZSgnLi9zdGFjaycpO1xuY29tcGlsZXIuc3R5bGUgPSByZXF1aXJlKCcuL3N0eWxlJyk7XG5jb21waWxlci5zdWJmYWNldCA9IHJlcXVpcmUoJy4vc3ViZmFjZXQnKTtcbmNvbXBpbGVyLnRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKTtcblxuY29tcGlsZXIuY29tcGlsZSA9IGZ1bmN0aW9uIChzcGVjLCBzdGF0cywgdGhlbWUpIHtcbiAgcmV0dXJuIGNvbXBpbGVyLmNvbXBpbGVFbmNvZGluZyhFbmNvZGluZy5mcm9tU3BlYyhzcGVjLCB0aGVtZSksIHN0YXRzKTtcbn07XG5cbmNvbXBpbGVyLnNob3J0aGFuZCA9IGZ1bmN0aW9uIChzaG9ydGhhbmQsIHN0YXRzLCBjb25maWcsIHRoZW1lKSB7XG4gIHJldHVybiBjb21waWxlci5jb21waWxlRW5jb2RpbmcoRW5jb2RpbmcuZnJvbVNob3J0aGFuZChzaG9ydGhhbmQsIGNvbmZpZywgdGhlbWUpLCBzdGF0cyk7XG59O1xuXG5cbmNvbXBpbGVyLmNvbXBpbGVFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZywgc3RhdHMpIHtcbiAgLy8gbm8gbmVlZCB0byBwYXNzIHN0YXRzIGlmIHlvdSBwYXNzIGluIHRoZSBkYXRhXG4gIGlmICghc3RhdHMpIHtcbiAgICBpZiAoZW5jb2RpbmcuaGFzVmFsdWVzKCkpIHtcbiAgICAgICAgc3RhdHMgPSBzdW1tYXJ5KGVuY29kaW5nLmRhdGEoKS52YWx1ZXMpLnJlZHVjZShmdW5jdGlvbihzLCBwKSB7XG4gICAgICAgIHNbcC5maWVsZF0gPSBwO1xuICAgICAgICByZXR1cm4gcztcbiAgICAgIH0sIHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignTm8gc3RhdHMgcHJvdmlkZWQgYW5kIGRhdGEgaXMgbm90IGVtYmVkZGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsYXlvdXQgPSBjb21waWxlci5sYXlvdXQoZW5jb2RpbmcsIHN0YXRzKTtcblxuICB2YXIgc3BlYyA9IHtcbiAgICAgIHdpZHRoOiBsYXlvdXQud2lkdGgsXG4gICAgICBoZWlnaHQ6IGxheW91dC5oZWlnaHQsXG4gICAgICBwYWRkaW5nOiAnYXV0bycsXG4gICAgICBkYXRhOiBjb21waWxlci5kYXRhKGVuY29kaW5nKSxcbiAgICAgIC8vIGdsb2JhbCBzY2FsZXMgY29udGFpbnMgb25seSB0aW1lIHVuaXQgc2NhbGVzXG4gICAgICBzY2FsZXM6IGNvbXBpbGVyLnRpbWUuc2NhbGVzKGVuY29kaW5nKVxuICAgIH07XG5cbiAgLy8gRklYTUUgcmVtb3ZlIGNvbXBpbGVyLnNvcnQgYWZ0ZXIgbWlncmF0aW5nIHRvIHZlZ2EgMi5cbiAgc3BlYy5kYXRhID0gY29tcGlsZXIuc29ydChzcGVjLmRhdGEsIGVuY29kaW5nLCBzdGF0cyk7IC8vIGFwcGVuZCBuZXcgZGF0YVxuXG4gIC8vIG1hcmtzXG5cbiAgLy8gVE9ETyB0aGlzIGxpbmUgaXMgdGVtcG9yYXJ5IGFuZCBzaG91bGQgYmUgcmVmYWN0b3JlZFxuICBzcGVjLm1hcmtzID0gW2NvbXBpbGVyLmdyb3VwLmRlZignY2VsbCcsIHtcbiAgICB3aWR0aDogbGF5b3V0LmNlbGxXaWR0aCA/IHt2YWx1ZTogbGF5b3V0LmNlbGxXaWR0aH0gOiB1bmRlZmluZWQsXG4gICAgaGVpZ2h0OiBsYXlvdXQuY2VsbEhlaWdodCA/IHt2YWx1ZTogbGF5b3V0LmNlbGxIZWlnaHR9IDogdW5kZWZpbmVkXG4gIH0pXTtcblxuICB2YXIgc3R5bGUgPSBjb21waWxlci5zdHlsZShlbmNvZGluZywgc3RhdHMpLFxuICAgIGdyb3VwID0gc3BlYy5tYXJrc1swXSxcbiAgICBtZGVmcyA9IG1hcmtzLmRlZihlbmNvZGluZywgbGF5b3V0LCBzdHlsZSwgc3RhdHMpLFxuICAgIG1kZWYgPSBtZGVmc1ttZGVmcy5sZW5ndGggLSAxXTsgIC8vIFRPRE86IHJlbW92ZSB0aGlzIGRpcnR5IGhhY2sgYnkgcmVmYWN0b3JpbmcgdGhlIHdob2xlIGZsb3dcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1kZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgZ3JvdXAubWFya3MucHVzaChtZGVmc1tpXSk7XG4gIH1cblxuICB2YXIgbGluZVR5cGUgPSBtYXJrc1tlbmNvZGluZy5tYXJrdHlwZSgpXS5saW5lO1xuXG4gIC8vIGhhbmRsZSBzdWJmYWNldHNcblxuICB2YXIgZGV0YWlscyA9IGVuY29kaW5nLmRldGFpbHMoKSxcbiAgICBzdGFjayA9IGVuY29kaW5nLmlzQWdncmVnYXRlKCkgJiYgZGV0YWlscy5sZW5ndGggPiAwICYmIGNvbXBpbGVyLnN0YWNrKHNwZWMuZGF0YSwgZW5jb2RpbmcsIG1kZWYpOyAvLyBtb2RpZnkgc3BlYy5kYXRhLCBtZGVmLntmcm9tLHByb3BlcnRpZXN9XG5cbiAgaWYgKGRldGFpbHMubGVuZ3RoID4gMCAmJiAoc3RhY2sgfHwgbGluZVR5cGUpKSB7XG4gICAgLy9zdWJmYWNldCB0byBncm91cCBzdGFjayAvIGxpbmUgdG9nZXRoZXIgaW4gb25lIGdyb3VwXG4gICAgY29tcGlsZXIuc3ViZmFjZXQoZ3JvdXAsIG1kZWYsIGRldGFpbHMsIHN0YWNrLCBlbmNvZGluZyk7XG4gIH1cblxuICAvLyBhdXRvLXNvcnQgbGluZS9hcmVhIHZhbHVlc1xuICBpZiAobGluZVR5cGUgJiYgZW5jb2RpbmcuY29uZmlnKCdhdXRvU29ydExpbmUnKSkge1xuICAgIHZhciBmID0gKGVuY29kaW5nLmlzTWVhc3VyZShYKSAmJiBlbmNvZGluZy5pc0RpbWVuc2lvbihZKSkgPyBZIDogWDtcbiAgICBpZiAoIW1kZWYuZnJvbSkgbWRlZi5mcm9tID0ge307XG4gICAgLy8gVE9ETzogd2h5IC0gP1xuICAgIG1kZWYuZnJvbS50cmFuc2Zvcm0gPSBbe3R5cGU6ICdzb3J0JywgYnk6ICctJyArIGVuY29kaW5nLmZpZWxkUmVmKGYpfV07XG4gIH1cblxuICAvLyBnZXQgYSBmbGF0dGVuZWQgbGlzdCBvZiBhbGwgc2NhbGUgbmFtZXMgdGhhdCBhcmUgdXNlZCBpbiB0aGUgdmwgc3BlY1xuICB2YXIgc2luZ2xlU2NhbGVOYW1lcyA9IFtdLmNvbmNhdC5hcHBseShbXSwgbWRlZnMubWFwKGZ1bmN0aW9uKG1hcmtQcm9wcykge1xuICAgIHJldHVybiBzY2FsZS5uYW1lcyhtYXJrUHJvcHMucHJvcGVydGllcy51cGRhdGUpO1xuICB9KSk7XG5cbiAgLy8gU21hbGwgTXVsdGlwbGVzXG4gIGlmIChlbmNvZGluZy5oYXMoUk9XKSB8fCBlbmNvZGluZy5oYXMoQ09MKSkge1xuICAgIHNwZWMgPSBjb21waWxlci5mYWNldChncm91cCwgZW5jb2RpbmcsIGxheW91dCwgc3BlYywgc2luZ2xlU2NhbGVOYW1lcywgc3RhY2ssIHN0YXRzKTtcbiAgICBzcGVjLmxlZ2VuZHMgPSBsZWdlbmQuZGVmcyhlbmNvZGluZywgc3R5bGUpO1xuICB9IGVsc2Uge1xuICAgIGdyb3VwLnNjYWxlcyA9IHNjYWxlLmRlZnMoc2luZ2xlU2NhbGVOYW1lcywgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMsIHtzdGFjazogc3RhY2t9KTtcblxuICAgIGdyb3VwLmF4ZXMgPSBbXTtcbiAgICBpZiAoZW5jb2RpbmcuaGFzKFgpKSBncm91cC5heGVzLnB1c2goYXhpcy5kZWYoWCwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpKTtcbiAgICBpZiAoZW5jb2RpbmcuaGFzKFkpKSBncm91cC5heGVzLnB1c2goYXhpcy5kZWYoWSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpKTtcblxuICAgIGdyb3VwLmxlZ2VuZHMgPSBsZWdlbmQuZGVmcyhlbmNvZGluZywgc3R5bGUpO1xuICB9XG5cblxuXG4gIHJldHVybiBzcGVjO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGF0YTtcblxudmFyIHZsZmllbGQgPSByZXF1aXJlKCcuLi9maWVsZCcpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICB0aW1lID0gcmVxdWlyZSgnLi90aW1lJyk7XG5cbmZ1bmN0aW9uIGRhdGEoZW5jb2RpbmcpIHtcbiAgdmFyIGRlZiA9IFtkYXRhLnJhdyhlbmNvZGluZyldO1xuXG4gIHZhciBhZ2dyZWdhdGUgPSBkYXRhLmFnZ3JlZ2F0ZShlbmNvZGluZyk7XG4gIGlmIChhZ2dyZWdhdGUpIGRlZi5wdXNoKGRhdGEuYWdncmVnYXRlKGVuY29kaW5nKSk7XG5cbiAgLy8gVE9ETyBhZGQgXCJoYXZpbmdcIiBmaWx0ZXIgaGVyZVxuXG4gIC8vIGFwcGVuZCBub24tcG9zaXRpdmUgZmlsdGVyIGF0IHRoZSBlbmQgZm9yIHRoZSBkYXRhIHRhYmxlXG4gIGRhdGEuZmlsdGVyTm9uUG9zaXRpdmUoZGVmW2RlZi5sZW5ndGggLSAxXSwgZW5jb2RpbmcpO1xuXG4gIHJldHVybiBkZWY7XG59XG5cbmRhdGEucmF3ID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdmFyIHJhdyA9IHtuYW1lOiBSQVd9O1xuXG4gIC8vIERhdGEgc291cmNlICh1cmwgb3IgaW5saW5lKVxuICBpZiAoZW5jb2RpbmcuaGFzVmFsdWVzKCkpIHtcbiAgICByYXcudmFsdWVzID0gZW5jb2RpbmcuZGF0YSgpLnZhbHVlcztcbiAgfSBlbHNlIHtcbiAgICByYXcudXJsID0gZW5jb2RpbmcuZGF0YSgpLnVybDtcbiAgICByYXcuZm9ybWF0ID0ge3R5cGU6IGVuY29kaW5nLmRhdGEoKS5mb3JtYXRUeXBlfTtcbiAgfVxuXG4gIC8vIFNldCBmb3JtYXQucGFyc2UgaWYgbmVlZGVkXG4gIHZhciBwYXJzZSA9IGRhdGEucmF3LmZvcm1hdFBhcnNlKGVuY29kaW5nKTtcbiAgaWYgKHBhcnNlKSB7XG4gICAgcmF3LmZvcm1hdCA9IHJhdy5mb3JtYXQgfHwge307XG4gICAgcmF3LmZvcm1hdC5wYXJzZSA9IHBhcnNlO1xuICB9XG5cbiAgcmF3LnRyYW5zZm9ybSA9IGRhdGEucmF3LnRyYW5zZm9ybShlbmNvZGluZyk7XG4gIHJldHVybiByYXc7XG59O1xuXG5kYXRhLnJhdy5mb3JtYXRQYXJzZSA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHZhciBwYXJzZTtcblxuICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkLnR5cGUgPT0gVCkge1xuICAgICAgcGFyc2UgPSBwYXJzZSB8fCB7fTtcbiAgICAgIHBhcnNlW2ZpZWxkLm5hbWVdID0gJ2RhdGUnO1xuICAgIH0gZWxzZSBpZiAoZmllbGQudHlwZSA9PSBRKSB7XG4gICAgICBpZiAodmxmaWVsZC5pc0NvdW50KGZpZWxkKSkgcmV0dXJuO1xuICAgICAgcGFyc2UgPSBwYXJzZSB8fCB7fTtcbiAgICAgIHBhcnNlW2ZpZWxkLm5hbWVdID0gJ251bWJlcic7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2U7XG59O1xuXG5kYXRhLnJhdy50cmFuc2Zvcm0gPSBmdW5jdGlvbihlbmNvZGluZykge1xuICAvLyB0aW1lIGFuZCBiaW4gc2hvdWxkIGNvbWUgYmVmb3JlIGZpbHRlciBzbyB3ZSBjYW4gZmlsdGVyIGJ5IHRpbWUgYW5kIGJpblxuICByZXR1cm4gZGF0YS5yYXcudHJhbnNmb3JtLnRpbWUoZW5jb2RpbmcpLmNvbmNhdChcbiAgICBkYXRhLnJhdy50cmFuc2Zvcm0uYmluKGVuY29kaW5nKSxcbiAgICBkYXRhLnJhdy50cmFuc2Zvcm0uZmlsdGVyKGVuY29kaW5nKVxuICApO1xufTtcblxudmFyIEJJTkFSWSA9IHtcbiAgJz4nOiAgdHJ1ZSxcbiAgJz49JzogdHJ1ZSxcbiAgJz0nOiAgdHJ1ZSxcbiAgJyE9JzogdHJ1ZSxcbiAgJzwnOiAgdHJ1ZSxcbiAgJzw9JzogdHJ1ZVxufTtcblxuZGF0YS5yYXcudHJhbnNmb3JtLnRpbWUgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICByZXR1cm4gZW5jb2RpbmcucmVkdWNlKGZ1bmN0aW9uKHRyYW5zZm9ybSwgZmllbGQsIGVuY1R5cGUpIHtcbiAgICBpZiAoZmllbGQudHlwZSA9PT0gVCAmJiBmaWVsZC50aW1lVW5pdCkge1xuICAgICAgdHJhbnNmb3JtLnB1c2goe1xuICAgICAgICB0eXBlOiAnZm9ybXVsYScsXG4gICAgICAgIGZpZWxkOiBlbmNvZGluZy5maWVsZFJlZihlbmNUeXBlKSxcbiAgICAgICAgZXhwcjogdGltZS5mb3JtdWxhKGZpZWxkLnRpbWVVbml0LCBlbmNvZGluZy5maWVsZFJlZihlbmNUeXBlLCB7bm9mbjogdHJ1ZSwgZDogdHJ1ZX0pKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm07XG4gIH0sIFtdKTtcbn07XG5cbmRhdGEucmF3LnRyYW5zZm9ybS5iaW4gPSBmdW5jdGlvbihlbmNvZGluZykge1xuICByZXR1cm4gZW5jb2RpbmcucmVkdWNlKGZ1bmN0aW9uKHRyYW5zZm9ybSwgZmllbGQsIGVuY1R5cGUpIHtcbiAgICBpZiAoZW5jb2RpbmcuYmluKGVuY1R5cGUpKSB7XG4gICAgICB0cmFuc2Zvcm0ucHVzaCh7XG4gICAgICAgIHR5cGU6ICdiaW4nLFxuICAgICAgICBmaWVsZDogZW5jb2RpbmcuZmllbGRSZWYoZW5jVHlwZSwge25vZm46IHRydWV9KSxcbiAgICAgICAgb3V0cHV0OiBlbmNvZGluZy5maWVsZFJlZihlbmNUeXBlKSxcbiAgICAgICAgbWF4YmluczogZW5jb2RpbmcuYmluKGVuY1R5cGUpLm1heGJpbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmb3JtO1xuICB9LCBbXSk7XG59O1xuXG5kYXRhLnJhdy50cmFuc2Zvcm0uZmlsdGVyID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdmFyIGZpbHRlcnMgPSBlbmNvZGluZy5maWx0ZXIoKS5yZWR1Y2UoZnVuY3Rpb24oZiwgZmlsdGVyKSB7XG4gICAgdmFyIGNvbmRpdGlvbiA9ICcnO1xuICAgIHZhciBvcGVyYXRvciA9IGZpbHRlci5vcGVyYXRvcjtcbiAgICB2YXIgb3BlcmFuZHMgPSBmaWx0ZXIub3BlcmFuZHM7XG5cbiAgICB2YXIgZCA9ICdkLicgKyAoZW5jb2RpbmcuX3ZlZ2EyID8gJycgOiAnZGF0YS4nKTtcblxuICAgIGlmIChCSU5BUllbb3BlcmF0b3JdKSB7XG4gICAgICAvLyBleHBlY3RzIGEgZmllbGQgYW5kIGEgdmFsdWVcbiAgICAgIGlmIChvcGVyYXRvciA9PT0gJz0nKSB7XG4gICAgICAgIG9wZXJhdG9yID0gJz09JztcbiAgICAgIH1cblxuICAgICAgdmFyIG9wMSA9IG9wZXJhbmRzWzBdO1xuICAgICAgdmFyIG9wMiA9IG9wZXJhbmRzWzFdO1xuICAgICAgY29uZGl0aW9uID0gZCArIG9wMSArICcgJyArIG9wZXJhdG9yICsgJyAnICsgb3AyO1xuICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09ICdub3ROdWxsJykge1xuICAgICAgLy8gZXhwZWN0cyBhIG51bWJlciBvZiBmaWVsZHNcbiAgICAgIGZvciAodmFyIGo9MDsgajxvcGVyYW5kcy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25kaXRpb24gKz0gZCArIG9wZXJhbmRzW2pdICsgJyE9PW51bGwnO1xuICAgICAgICBpZiAoaiA8IG9wZXJhbmRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjb25kaXRpb24gKz0gJyAmJiAnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWwud2FybignVW5zdXBwb3J0ZWQgb3BlcmF0b3I6ICcsIG9wZXJhdG9yKTtcbiAgICAgIHJldHVybiBmO1xuICAgIH1cbiAgICBmLnB1c2goJygnICsgY29uZGl0aW9uICsgJyknKTtcbiAgICByZXR1cm4gZjtcbiAgfSwgW10pO1xuICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcblxuICByZXR1cm4gW3tcbiAgICAgIHR5cGU6ICdmaWx0ZXInLFxuICAgICAgdGVzdDogZmlsdGVycy5qb2luKCcgJiYgJylcbiAgfV07XG59O1xuXG5kYXRhLmFnZ3JlZ2F0ZSA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHZhciBkaW1zID0ge30sIG1lYXMgPSB7fTtcblxuICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBlbmNUeXBlKSB7XG4gICAgaWYgKGZpZWxkLmFnZ3JlZ2F0ZSkge1xuICAgICAgaWYgKGZpZWxkLmFnZ3JlZ2F0ZSA9PT0gJ2NvdW50Jykge1xuICAgICAgICBtZWFzLmNvdW50ID0ge29wOiAnY291bnQnLCBmaWVsZDogJyonfTtcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgbWVhc1tmaWVsZC5hZ2dyZWdhdGUgKyAnfCcgKyBmaWVsZC5uYW1lXSA9IHtcbiAgICAgICAgICBvcDogZmllbGQuYWdncmVnYXRlLFxuICAgICAgICAgIGZpZWxkOiBlbmNvZGluZy5maWVsZFJlZihlbmNUeXBlLCB7bm9mbjogdHJ1ZX0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpbXNbZmllbGQubmFtZV0gPSBlbmNvZGluZy5maWVsZFJlZihlbmNUeXBlKTtcbiAgICB9XG4gIH0pO1xuXG4gIGRpbXMgPSB1dGlsLnZhbHMoZGltcyk7XG4gIG1lYXMgPSB1dGlsLnZhbHMobWVhcyk7XG5cbiAgaWYgKG1lYXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBBR0dSRUdBVEUsXG4gICAgICBzb3VyY2U6IFJBVyxcbiAgICAgIHRyYW5zZm9ybTogW3tcbiAgICAgICAgdHlwZTogJ2FnZ3JlZ2F0ZScsXG4gICAgICAgIGdyb3VwYnk6IGRpbXMsXG4gICAgICAgIGZpZWxkczogbWVhc1xuICAgICAgfV1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5kYXRhLmZpbHRlck5vblBvc2l0aXZlID0gZnVuY3Rpb24oZGF0YVRhYmxlLCBlbmNvZGluZykge1xuICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBlbmNUeXBlKSB7XG4gICAgaWYgKGVuY29kaW5nLnNjYWxlKGVuY1R5cGUpLnR5cGUgPT09ICdsb2cnKSB7XG4gICAgICBkYXRhVGFibGUudHJhbnNmb3JtLnB1c2goe1xuICAgICAgICB0eXBlOiAnZmlsdGVyJyxcbiAgICAgICAgdGVzdDogZW5jb2RpbmcuZmllbGRSZWYoZW5jVHlwZSwge2Q6IDF9KSArICcgPiAwJ1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbnZhciBheGlzID0gcmVxdWlyZSgnLi9heGlzJyksXG4gIGdyb3VwZGVmID0gcmVxdWlyZSgnLi9ncm91cCcpLmRlZixcbiAgc2NhbGUgPSByZXF1aXJlKCcuL3NjYWxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZmFjZXRpbmc7XG5cbmZ1bmN0aW9uIGZhY2V0aW5nKGdyb3VwLCBlbmNvZGluZywgbGF5b3V0LCBzcGVjLCBzaW5nbGVTY2FsZU5hbWVzLCBzdGFjaywgc3RhdHMpIHtcbiAgdmFyIGVudGVyID0gZ3JvdXAucHJvcGVydGllcy5lbnRlcjtcbiAgdmFyIGZhY2V0S2V5cyA9IFtdLCBjZWxsQXhlcyA9IFtdLCBmcm9tLCBheGVzR3JwO1xuXG4gIHZhciBoYXNSb3cgPSBlbmNvZGluZy5oYXMoUk9XKSwgaGFzQ29sID0gZW5jb2RpbmcuaGFzKENPTCk7XG5cbiAgZW50ZXIuZmlsbCA9IHt2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdjZWxsQmFja2dyb3VuZENvbG9yJyl9O1xuXG4gIC8vbW92ZSBcImZyb21cIiB0byBjZWxsIGxldmVsIGFuZCBhZGQgZmFjZXQgdHJhbnNmb3JtXG4gIGdyb3VwLmZyb20gPSB7ZGF0YTogZ3JvdXAubWFya3NbMF0uZnJvbS5kYXRhfTtcblxuICAvLyBIYWNrLCB0aGlzIG5lZWRzIHRvIGJlIHJlZmFjdG9yZWRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5tYXJrcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtYXJrID0gZ3JvdXAubWFya3NbaV07XG4gICAgaWYgKG1hcmsuZnJvbS50cmFuc2Zvcm0pIHtcbiAgICAgIGRlbGV0ZSBtYXJrLmZyb20uZGF0YTsgLy9uZWVkIHRvIGtlZXAgdHJhbnNmb3JtIGZvciBzdWJmYWNldHRpbmcgY2FzZVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgbWFyay5mcm9tO1xuICAgIH1cbiAgfVxuXG4gIGlmIChoYXNSb3cpIHtcbiAgICBpZiAoIWVuY29kaW5nLmlzRGltZW5zaW9uKFJPVykpIHtcbiAgICAgIHV0aWwuZXJyb3IoJ1JvdyBlbmNvZGluZyBzaG91bGQgYmUgb3JkaW5hbC4nKTtcbiAgICB9XG4gICAgZW50ZXIueSA9IHtzY2FsZTogUk9XLCBmaWVsZDogJ2tleXMuJyArIGZhY2V0S2V5cy5sZW5ndGh9O1xuICAgIGVudGVyLmhlaWdodCA9IHsndmFsdWUnOiBsYXlvdXQuY2VsbEhlaWdodH07IC8vIEhBQ0tcblxuICAgIGZhY2V0S2V5cy5wdXNoKGVuY29kaW5nLmZpZWxkUmVmKFJPVykpO1xuXG4gICAgaWYgKGhhc0NvbCkge1xuICAgICAgZnJvbSA9IHV0aWwuZHVwbGljYXRlKGdyb3VwLmZyb20pO1xuICAgICAgZnJvbS50cmFuc2Zvcm0gPSBmcm9tLnRyYW5zZm9ybSB8fCBbXTtcbiAgICAgIGZyb20udHJhbnNmb3JtLnVuc2hpZnQoe3R5cGU6ICdmYWNldCcsIGtleXM6IFtlbmNvZGluZy5maWVsZFJlZihDT0wpXX0pO1xuICAgIH1cblxuICAgIGF4ZXNHcnAgPSBncm91cGRlZigneC1heGVzJywge1xuICAgICAgICBheGVzOiBlbmNvZGluZy5oYXMoWCkgPyBbYXhpcy5kZWYoWCwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgeDogaGFzQ29sID8ge3NjYWxlOiBDT0wsIGZpZWxkOiAna2V5cy4wJ30gOiB7dmFsdWU6IDB9LFxuICAgICAgICB3aWR0aDogaGFzQ29sICYmIHsndmFsdWUnOiBsYXlvdXQuY2VsbFdpZHRofSwgLy9IQUNLP1xuICAgICAgICBmcm9tOiBmcm9tXG4gICAgICB9KTtcblxuICAgIHNwZWMubWFya3MudW5zaGlmdChheGVzR3JwKTsgLy8gbmVlZCB0byBwcmVwZW5kIHNvIGl0IGFwcGVhcnMgdW5kZXIgdGhlIHBsb3RzXG4gICAgKHNwZWMuYXhlcyA9IHNwZWMuYXhlcyB8fCBbXSk7XG4gICAgc3BlYy5heGVzLnB1c2goYXhpcy5kZWYoUk9XLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cykpO1xuICB9IGVsc2UgeyAvLyBkb2Vzbid0IGhhdmUgcm93XG4gICAgaWYgKGVuY29kaW5nLmhhcyhYKSkge1xuICAgICAgLy9rZWVwIHggYXhpcyBpbiB0aGUgY2VsbFxuICAgICAgY2VsbEF4ZXMucHVzaChheGlzLmRlZihYLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cykpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChoYXNDb2wpIHtcbiAgICBpZiAoIWVuY29kaW5nLmlzRGltZW5zaW9uKENPTCkpIHtcbiAgICAgIHV0aWwuZXJyb3IoJ0NvbCBlbmNvZGluZyBzaG91bGQgYmUgb3JkaW5hbC4nKTtcbiAgICB9XG4gICAgZW50ZXIueCA9IHtzY2FsZTogQ09MLCBmaWVsZDogJ2tleXMuJyArIGZhY2V0S2V5cy5sZW5ndGh9O1xuICAgIGVudGVyLndpZHRoID0geyd2YWx1ZSc6IGxheW91dC5jZWxsV2lkdGh9OyAvLyBIQUNLXG5cbiAgICBmYWNldEtleXMucHVzaChlbmNvZGluZy5maWVsZFJlZihDT0wpKTtcblxuICAgIGlmIChoYXNSb3cpIHtcbiAgICAgIGZyb20gPSB1dGlsLmR1cGxpY2F0ZShncm91cC5mcm9tKTtcbiAgICAgIGZyb20udHJhbnNmb3JtID0gZnJvbS50cmFuc2Zvcm0gfHwgW107XG4gICAgICBmcm9tLnRyYW5zZm9ybS51bnNoaWZ0KHt0eXBlOiAnZmFjZXQnLCBrZXlzOiBbZW5jb2RpbmcuZmllbGRSZWYoUk9XKV19KTtcbiAgICB9XG5cbiAgICBheGVzR3JwID0gZ3JvdXBkZWYoJ3ktYXhlcycsIHtcbiAgICAgIGF4ZXM6IGVuY29kaW5nLmhhcyhZKSA/IFtheGlzLmRlZihZLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cyldIDogdW5kZWZpbmVkLFxuICAgICAgeTogaGFzUm93ICYmIHtzY2FsZTogUk9XLCBmaWVsZDogJ2tleXMuMCd9LFxuICAgICAgeDogaGFzUm93ICYmIHt2YWx1ZTogMH0sXG4gICAgICBoZWlnaHQ6IGhhc1JvdyAmJiB7J3ZhbHVlJzogbGF5b3V0LmNlbGxIZWlnaHR9LCAvL0hBQ0s/XG4gICAgICBmcm9tOiBmcm9tXG4gICAgfSk7XG5cbiAgICBzcGVjLm1hcmtzLnVuc2hpZnQoYXhlc0dycCk7IC8vIG5lZWQgdG8gcHJlcGVuZCBzbyBpdCBhcHBlYXJzIHVuZGVyIHRoZSBwbG90c1xuICAgIChzcGVjLmF4ZXMgPSBzcGVjLmF4ZXMgfHwgW10pO1xuICAgIHNwZWMuYXhlcy5wdXNoKGF4aXMuZGVmKENPTCwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpKTtcbiAgfSBlbHNlIHsgLy8gZG9lc24ndCBoYXZlIGNvbFxuICAgIGlmIChlbmNvZGluZy5oYXMoWSkpIHtcbiAgICAgIGNlbGxBeGVzLnB1c2goYXhpcy5kZWYoWSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpKTtcbiAgICB9XG4gIH1cblxuICAvLyBhc3N1bWluZyBlcXVhbCBjZWxsV2lkdGggaGVyZVxuICAvLyBUT0RPOiBzdXBwb3J0IGhldGVyb2dlbm91cyBjZWxsV2lkdGggKG1heWJlIGJ5IHVzaW5nIG11bHRpcGxlIHNjYWxlcz8pXG4gIHNwZWMuc2NhbGVzID0gKHNwZWMuc2NhbGVzIHx8IFtdKS5jb25jYXQoc2NhbGUuZGVmcyhcbiAgICBzY2FsZS5uYW1lcyhlbnRlcikuY29uY2F0KHNpbmdsZVNjYWxlTmFtZXMpLFxuICAgIGVuY29kaW5nLFxuICAgIGxheW91dCxcbiAgICBzdGF0cyxcbiAgICB7c3RhY2s6IHN0YWNrLCBmYWNldDogdHJ1ZX1cbiAgKSk7IC8vIHJvdy9jb2wgc2NhbGVzICsgY2VsbCBzY2FsZXNcblxuICBpZiAoY2VsbEF4ZXMubGVuZ3RoID4gMCkge1xuICAgIGdyb3VwLmF4ZXMgPSBjZWxsQXhlcztcbiAgfVxuXG4gIC8vIGFkZCBmYWNldCB0cmFuc2Zvcm1cbiAgdmFyIHRyYW5zID0gKGdyb3VwLmZyb20udHJhbnNmb3JtIHx8IChncm91cC5mcm9tLnRyYW5zZm9ybSA9IFtdKSk7XG4gIHRyYW5zLnVuc2hpZnQoe3R5cGU6ICdmYWNldCcsIGtleXM6IGZhY2V0S2V5c30pO1xuXG4gIHJldHVybiBzcGVjO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVmOiBncm91cGRlZlxufTtcblxuZnVuY3Rpb24gZ3JvdXBkZWYobmFtZSwgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgcmV0dXJuIHtcbiAgICBfbmFtZTogbmFtZSB8fCB1bmRlZmluZWQsXG4gICAgdHlwZTogJ2dyb3VwJyxcbiAgICBmcm9tOiBvcHQuZnJvbSxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICB4OiBvcHQueCB8fCB1bmRlZmluZWQsXG4gICAgICAgIHk6IG9wdC55IHx8IHVuZGVmaW5lZCxcbiAgICAgICAgd2lkdGg6IG9wdC53aWR0aCB8fCB7Z3JvdXA6ICd3aWR0aCd9LFxuICAgICAgICBoZWlnaHQ6IG9wdC5oZWlnaHQgfHwge2dyb3VwOiAnaGVpZ2h0J31cbiAgICAgIH1cbiAgICB9LFxuICAgIHNjYWxlczogb3B0LnNjYWxlcyB8fCB1bmRlZmluZWQsXG4gICAgYXhlczogb3B0LmF4ZXMgfHwgdW5kZWZpbmVkLFxuICAgIG1hcmtzOiBvcHQubWFya3MgfHwgW11cbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgc2V0dGVyID0gdXRpbC5zZXR0ZXIsXG4gIHRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKSxcbiAgZDNfZm9ybWF0ID0gcmVxdWlyZSgnZDMtZm9ybWF0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdmxsYXlvdXQ7XG5cbmZ1bmN0aW9uIHZsbGF5b3V0KGVuY29kaW5nLCBzdGF0cykge1xuICB2YXIgbGF5b3V0ID0gYm94KGVuY29kaW5nLCBzdGF0cyk7XG4gIGxheW91dCA9IG9mZnNldChlbmNvZGluZywgc3RhdHMsIGxheW91dCk7XG4gIHJldHVybiBsYXlvdXQ7XG59XG5cbi8qXG4gIEhBQ0sgdG8gc2V0IGNoYXJ0IHNpemVcbiAgTk9URTogdGhpcyBmYWlscyBmb3IgcGxvdHMgZHJpdmVuIGJ5IGRlcml2ZWQgdmFsdWVzIChlLmcuLCBhZ2dyZWdhdGVzKVxuICBPbmUgc29sdXRpb24gaXMgdG8gdXBkYXRlIFZlZ2EgdG8gc3VwcG9ydCBhdXRvLXNpemluZ1xuICBJbiB0aGUgbWVhbnRpbWUsIGF1dG8tcGFkZGluZyAobW9zdGx5KSBkb2VzIHRoZSB0cmlja1xuICovXG5mdW5jdGlvbiBib3goZW5jb2RpbmcsIHN0YXRzKSB7XG4gIHZhciBoYXNSb3cgPSBlbmNvZGluZy5oYXMoUk9XKSxcbiAgICAgIGhhc0NvbCA9IGVuY29kaW5nLmhhcyhDT0wpLFxuICAgICAgaGFzWCA9IGVuY29kaW5nLmhhcyhYKSxcbiAgICAgIGhhc1kgPSBlbmNvZGluZy5oYXMoWSksXG4gICAgICBtYXJrdHlwZSA9IGVuY29kaW5nLm1hcmt0eXBlKCk7XG5cbiAgLy8gRklYTUUvSEFDSyB3ZSBuZWVkIHRvIHRha2UgZmlsdGVyIGludG8gYWNjb3VudFxuICB2YXIgeENhcmRpbmFsaXR5ID0gaGFzWCAmJiBlbmNvZGluZy5pc0RpbWVuc2lvbihYKSA/IGVuY29kaW5nLmNhcmRpbmFsaXR5KFgsIHN0YXRzKSA6IDEsXG4gICAgeUNhcmRpbmFsaXR5ID0gaGFzWSAmJiBlbmNvZGluZy5pc0RpbWVuc2lvbihZKSA/IGVuY29kaW5nLmNhcmRpbmFsaXR5KFksIHN0YXRzKSA6IDE7XG5cbiAgdmFyIHVzZVNtYWxsQmFuZCA9IHhDYXJkaW5hbGl0eSA+IGVuY29kaW5nLmNvbmZpZygnbGFyZ2VCYW5kTWF4Q2FyZGluYWxpdHknKSB8fFxuICAgIHlDYXJkaW5hbGl0eSA+IGVuY29kaW5nLmNvbmZpZygnbGFyZ2VCYW5kTWF4Q2FyZGluYWxpdHknKTtcblxuICB2YXIgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCBjZWxsUGFkZGluZyA9IGVuY29kaW5nLmNvbmZpZygnY2VsbFBhZGRpbmcnKTtcblxuICAvLyBzZXQgY2VsbFdpZHRoXG4gIGlmIChoYXNYKSB7XG4gICAgaWYgKGVuY29kaW5nLmlzT3JkaW5hbFNjYWxlKFgpKSB7XG4gICAgICAvLyBmb3Igb3JkaW5hbCwgaGFzQ29sIG9yIG5vdCBkb2Vzbid0IG1hdHRlciAtLSB3ZSBzY2FsZSBiYXNlZCBvbiBjYXJkaW5hbGl0eVxuICAgICAgY2VsbFdpZHRoID0gKHhDYXJkaW5hbGl0eSArIGVuY29kaW5nLmZpZWxkKFgpLmJhbmQucGFkZGluZykgKiBlbmNvZGluZy5iYW5kU2l6ZShYLCB1c2VTbWFsbEJhbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZWxsV2lkdGggPSBoYXNDb2wgfHwgaGFzUm93ID8gZW5jb2RpbmcuZmllbGQoQ09MKS53aWR0aCA6ICBlbmNvZGluZy5jb25maWcoJ3NpbmdsZVdpZHRoJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChtYXJrdHlwZSA9PT0gVEVYVCkge1xuICAgICAgY2VsbFdpZHRoID0gZW5jb2RpbmcuY29uZmlnKCd0ZXh0Q2VsbFdpZHRoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbGxXaWR0aCA9IGVuY29kaW5nLmJhbmRTaXplKFgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBjZWxsSGVpZ2h0XG4gIGlmIChoYXNZKSB7XG4gICAgaWYgKGVuY29kaW5nLmlzT3JkaW5hbFNjYWxlKFkpKSB7XG4gICAgICAvLyBmb3Igb3JkaW5hbCwgaGFzQ29sIG9yIG5vdCBkb2Vzbid0IG1hdHRlciAtLSB3ZSBzY2FsZSBiYXNlZCBvbiBjYXJkaW5hbGl0eVxuICAgICAgY2VsbEhlaWdodCA9ICh5Q2FyZGluYWxpdHkgKyBlbmNvZGluZy5maWVsZChZKS5iYW5kLnBhZGRpbmcpICogZW5jb2RpbmcuYmFuZFNpemUoWSwgdXNlU21hbGxCYW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VsbEhlaWdodCA9IGhhc0NvbCB8fCBoYXNSb3cgPyBlbmNvZGluZy5maWVsZChST1cpLmhlaWdodCA6ICBlbmNvZGluZy5jb25maWcoJ3NpbmdsZUhlaWdodCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjZWxsSGVpZ2h0ID0gZW5jb2RpbmcuYmFuZFNpemUoWSk7XG4gIH1cblxuICAvLyBDZWxsIGJhbmRzIHVzZSByYW5nZUJhbmRzKCkuIFRoZXJlIGFyZSBuLTEgcGFkZGluZy4gIE91dGVycGFkZGluZyA9IDAgZm9yIGNlbGxzXG5cbiAgdmFyIHdpZHRoID0gY2VsbFdpZHRoLCBoZWlnaHQgPSBjZWxsSGVpZ2h0O1xuICBpZiAoaGFzQ29sKSB7XG4gICAgdmFyIGNvbENhcmRpbmFsaXR5ID0gZW5jb2RpbmcuY2FyZGluYWxpdHkoQ09MLCBzdGF0cyk7XG4gICAgd2lkdGggPSBjZWxsV2lkdGggKiAoKDEgKyBjZWxsUGFkZGluZykgKiAoY29sQ2FyZGluYWxpdHkgLSAxKSArIDEpO1xuICB9XG4gIGlmIChoYXNSb3cpIHtcbiAgICB2YXIgcm93Q2FyZGluYWxpdHkgPSAgZW5jb2RpbmcuY2FyZGluYWxpdHkoUk9XLCBzdGF0cyk7XG4gICAgaGVpZ2h0ID0gY2VsbEhlaWdodCAqICgoMSArIGNlbGxQYWRkaW5nKSAqIChyb3dDYXJkaW5hbGl0eSAtIDEpICsgMSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHdob2xlIGNlbGxcbiAgICBjZWxsV2lkdGg6IGNlbGxXaWR0aCxcbiAgICBjZWxsSGVpZ2h0OiBjZWxsSGVpZ2h0LFxuICAgIGNlbGxQYWRkaW5nOiBjZWxsUGFkZGluZyxcbiAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBjaGFydFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAvLyBpbmZvcm1hdGlvbiBhYm91dCB4IGFuZCB5LCBzdWNoIGFzIGJhbmQgc2l6ZVxuICAgIHg6IHt1c2VTbWFsbEJhbmQ6IHVzZVNtYWxsQmFuZH0sXG4gICAgeToge3VzZVNtYWxsQmFuZDogdXNlU21hbGxCYW5kfVxuICB9O1xufVxuXG5cbi8vIEZJWE1FIGZpZWxkU3RhdHMubWF4IGlzbid0IGFsd2F5cyB0aGUgbG9uZ2VzdFxuZnVuY3Rpb24gZ2V0TWF4TnVtYmVyTGVuZ3RoKGVuY29kaW5nLCBldCwgZmllbGRTdGF0cykge1xuICB2YXIgZm9ybWF0ID0gZW5jb2RpbmcubnVtYmVyRm9ybWF0KGV0LCBmaWVsZFN0YXRzKTtcblxuICByZXR1cm4gZDNfZm9ybWF0LmZvcm1hdChmb3JtYXQpKGZpZWxkU3RhdHMubWF4KS5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGdldE1heExlbmd0aChlbmNvZGluZywgc3RhdHMsIGV0KSB7XG4gIHZhciBmaWVsZCA9IGVuY29kaW5nLmZpZWxkKGV0KSxcbiAgICBmaWVsZFN0YXRzID0gc3RhdHNbZmllbGQubmFtZV07XG5cbiAgaWYgKGZpZWxkLmJpbikge1xuICAgIC8vIFRPRE8gb25jZSBiaW4gc3VwcG9ydCByYW5nZSwgbmVlZCB0byB1cGRhdGUgdGhpc1xuICAgIHJldHVybiBnZXRNYXhOdW1iZXJMZW5ndGgoZW5jb2RpbmcsIGV0LCBmaWVsZFN0YXRzKTtcbiAgfSBpZiAoZW5jb2RpbmcuaXNUeXBlKGV0LCBRKSkge1xuICAgIHJldHVybiBnZXRNYXhOdW1iZXJMZW5ndGgoZW5jb2RpbmcsIGV0LCBmaWVsZFN0YXRzKTtcbiAgfSBlbHNlIGlmIChlbmNvZGluZy5pc1R5cGUoZXQsIFQpKSB7XG4gICAgcmV0dXJuIHRpbWUubWF4TGVuZ3RoKGVuY29kaW5nLmZpZWxkKGV0KS50aW1lVW5pdCwgZW5jb2RpbmcpO1xuICB9IGVsc2UgaWYgKGVuY29kaW5nLmlzVHlwZXMoZXQsIFtOLCBPXSkpIHtcbiAgICBpZihmaWVsZFN0YXRzLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gZ2V0TWF4TnVtYmVyTGVuZ3RoKGVuY29kaW5nLCBldCwgZmllbGRTdGF0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihmaWVsZFN0YXRzLm1heCwgZW5jb2RpbmcuYXhpcyhldCkubWF4TGFiZWxMZW5ndGggfHwgSW5maW5pdHkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvZmZzZXQoZW5jb2RpbmcsIHN0YXRzLCBsYXlvdXQpIHtcbiAgW1gsIFldLmZvckVhY2goZnVuY3Rpb24gKGV0KSB7XG4gICAgLy8gVE9ETyhrYW5pdHcpOiBKdWwgMTksIDIwMTUgLSBjcmVhdGUgYSBzZXQgb2YgdmlzdWFsIHRlc3QgZm9yIGV4dHJhT2Zmc2V0XG4gICAgdmFyIGV4dHJhT2Zmc2V0ID0gZXQgPT09IFggPyAyMCA6IDIyLFxuICAgICAgbWF4TGVuZ3RoO1xuICAgIGlmIChlbmNvZGluZy5pc0RpbWVuc2lvbihldCkgfHwgZW5jb2RpbmcuaXNUeXBlKGV0LCBUKSkge1xuICAgICAgbWF4TGVuZ3RoID0gZ2V0TWF4TGVuZ3RoKGVuY29kaW5nLCBzdGF0cywgZXQpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBUT0RPIG9uY2Ugd2UgaGF2ZSAjNTEyIChhbGxvdyB1c2luZyBpbmZlcnJlZCB0eXBlKVxuICAgICAgLy8gTmVlZCB0byBhZGp1c3QgY29uZGl0aW9uIGhlcmUuXG4gICAgICBlbmNvZGluZy5pc1R5cGUoZXQsIFEpIHx8XG4gICAgICBlbmNvZGluZy5hZ2dyZWdhdGUoZXQpID09PSAnY291bnQnXG4gICAgKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGV0PT09WVxuICAgICAgICAvLyB8fCAoZXQ9PT1YICYmIGZhbHNlKVxuICAgICAgICAvLyBGSVhNRSBkZXRlcm1pbmUgd2hlbiBYIHdvdWxkIHJvdGF0ZSwgYnV0IHNob3VsZCBtb3ZlIHRoaXMgdG8gYXhpcy5qcyBmaXJzdCAjNTA2XG4gICAgICApIHtcbiAgICAgICAgbWF4TGVuZ3RoID0gZ2V0TWF4TGVuZ3RoKGVuY29kaW5nLCBzdGF0cywgZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3RoaW5nXG4gICAgfVxuXG4gICAgaWYgKG1heExlbmd0aCkge1xuICAgICAgc2V0dGVyKGxheW91dCxbZXQsICdheGlzVGl0bGVPZmZzZXQnXSwgZW5jb2RpbmcuY29uZmlnKCdjaGFyYWN0ZXJXaWR0aCcpICogIG1heExlbmd0aCArIGV4dHJhT2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgbm8gbWF4IGxlbmd0aCAobm8gcm90YXRpb24gY2FzZSksIHVzZSBtYXhMZW5ndGggPSAzXG4gICAgICBzZXR0ZXIobGF5b3V0LFtldCwgJ2F4aXNUaXRsZU9mZnNldCddLCBlbmNvZGluZy5jb25maWcoJ2NoYXJhY3RlcldpZHRoJykgKiAzICsgZXh0cmFPZmZzZXQpO1xuICAgIH1cblxuICB9KTtcbiAgcmV0dXJuIGxheW91dDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgdGltZSA9IHJlcXVpcmUoJy4vdGltZScpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICBzZXR0ZXIgPSB1dGlsLnNldHRlcixcbiAgZ2V0dGVyID0gdXRpbC5nZXR0ZXI7XG5cbnZhciBsZWdlbmQgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5sZWdlbmQuZGVmcyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBzdHlsZSkge1xuICB2YXIgZGVmcyA9IFtdO1xuXG4gIGlmIChlbmNvZGluZy5oYXMoQ09MT1IpICYmIGVuY29kaW5nLmZpZWxkKENPTE9SKS5sZWdlbmQpIHtcbiAgICBkZWZzLnB1c2gobGVnZW5kLmRlZihDT0xPUiwgZW5jb2RpbmcsIHtcbiAgICAgIGZpbGw6IENPTE9SLFxuICAgICAgb3JpZW50OiAncmlnaHQnXG4gICAgfSwgc3R5bGUpKTtcbiAgfVxuXG4gIGlmIChlbmNvZGluZy5oYXMoU0laRSkgJiYgZW5jb2RpbmcuZmllbGQoU0laRSkubGVnZW5kKSB7XG4gICAgZGVmcy5wdXNoKGxlZ2VuZC5kZWYoU0laRSwgZW5jb2RpbmcsIHtcbiAgICAgIHNpemU6IFNJWkUsXG4gICAgICBvcmllbnQ6IGRlZnMubGVuZ3RoID09PSAxID8gJ2xlZnQnIDogJ3JpZ2h0J1xuICAgIH0sIHN0eWxlKSk7XG4gIH1cblxuICBpZiAoZW5jb2RpbmcuaGFzKFNIQVBFKSAmJiBlbmNvZGluZy5maWVsZChTSEFQRSkubGVnZW5kKSB7XG4gICAgaWYgKGRlZnMubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdWZWdhLWxpdGUgY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgdHdvIGxlZ2VuZHMnKTtcbiAgICB9XG4gICAgZGVmcy5wdXNoKGxlZ2VuZC5kZWYoU0hBUEUsIGVuY29kaW5nLCB7XG4gICAgICBzaGFwZTogU0hBUEUsXG4gICAgICBvcmllbnQ6IGRlZnMubGVuZ3RoID09PSAxID8gJ2xlZnQnIDogJ3JpZ2h0J1xuICAgIH0sIHN0eWxlKSk7XG4gIH1cbiAgcmV0dXJuIGRlZnM7XG59O1xuXG5sZWdlbmQuZGVmID0gZnVuY3Rpb24obmFtZSwgZW5jb2RpbmcsIGRlZiwgc3R5bGUpIHtcbiAgdmFyIHRpbWVVbml0ID0gZW5jb2RpbmcuZmllbGQobmFtZSkudGltZVVuaXQ7XG5cbiAgZGVmLnRpdGxlID0gbGVnZW5kLnRpdGxlKG5hbWUsIGVuY29kaW5nKTtcbiAgZGVmID0gbGVnZW5kLnN0eWxlKG5hbWUsIGVuY29kaW5nLCBkZWYsIHN0eWxlKTtcblxuICBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFQpICYmXG4gICAgdGltZVVuaXQgJiZcbiAgICB0aW1lLmhhc1NjYWxlKHRpbWVVbml0KVxuICApIHtcbiAgICBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCAnbGFiZWxzJywgJ3RleHQnLCAnc2NhbGUnXSwgJ3RpbWUtJysgdGltZVVuaXQpO1xuICB9XG5cbiAgcmV0dXJuIGRlZjtcbn07XG5cbmxlZ2VuZC5zdHlsZSA9IGZ1bmN0aW9uKG5hbWUsIGUsIGRlZiwgc3R5bGUpIHtcbiAgdmFyIHN5bWJvbHMgPSBnZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCAnc3ltYm9scyddKSxcbiAgICBtYXJrdHlwZSA9IGUubWFya3R5cGUoKTtcblxuICBzd2l0Y2ggKG1hcmt0eXBlKSB7XG4gICAgY2FzZSAnYmFyJzpcbiAgICBjYXNlICd0aWNrJzpcbiAgICBjYXNlICd0ZXh0JzpcbiAgICAgIHN5bWJvbHMuc3Ryb2tlID0ge3ZhbHVlOiAndHJhbnNwYXJlbnQnfTtcbiAgICAgIHN5bWJvbHMuc2hhcGUgPSB7dmFsdWU6ICdzcXVhcmUnfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnY2lyY2xlJzpcbiAgICBjYXNlICdzcXVhcmUnOlxuICAgICAgc3ltYm9scy5zaGFwZSA9IHt2YWx1ZTogbWFya3R5cGV9O1xuICAgICAgLyogZmFsbCB0aHJvdWdoICovXG4gICAgY2FzZSAncG9pbnQnOlxuICAgICAgLy8gZmlsbCBvciBzdHJva2VcbiAgICAgIGlmIChlLmZpZWxkKFNIQVBFKS5maWxsZWQpIHtcbiAgICAgICAgaWYgKGUuaGFzKENPTE9SKSAmJiBuYW1lID09PSBDT0xPUikge1xuICAgICAgICAgIHN5bWJvbHMuZmlsbCA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiAnZGF0YSd9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN5bWJvbHMuZmlsbCA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICAgICAgICB9XG4gICAgICAgIHN5bWJvbHMuc3Ryb2tlID0ge3ZhbHVlOiAndHJhbnNwYXJlbnQnfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlLmhhcyhDT0xPUikgJiYgbmFtZSA9PT0gQ09MT1IpIHtcbiAgICAgICAgICBzeW1ib2xzLnN0cm9rZSA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiAnZGF0YSd9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN5bWJvbHMuc3Ryb2tlID0ge3ZhbHVlOiBlLnZhbHVlKENPTE9SKX07XG4gICAgICAgIH1cbiAgICAgICAgc3ltYm9scy5maWxsID0ge3ZhbHVlOiAndHJhbnNwYXJlbnQnfTtcbiAgICAgICAgc3ltYm9scy5zdHJva2VXaWR0aCA9IHt2YWx1ZTogZS5jb25maWcoJ3N0cm9rZVdpZHRoJyl9O1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICBjYXNlICdsaW5lJzpcbiAgICBjYXNlICdhcmVhJzpcbiAgICAgIC8vIFRPRE8gdXNlIHNoYXBlIGhlcmUgYWZ0ZXIgaW1wbGVtZW50aW5nICM1MDhcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdmFyIG9wYWNpdHkgPSBlLmZpZWxkKENPTE9SKS5vcGFjaXR5IHx8IHN0eWxlLm9wYWNpdHk7XG4gIGlmIChvcGFjaXR5KSB7XG4gICAgc3ltYm9scy5vcGFjaXR5ID0ge3ZhbHVlOiBvcGFjaXR5fTtcbiAgfVxuICByZXR1cm4gZGVmO1xufTtcblxubGVnZW5kLnRpdGxlID0gZnVuY3Rpb24obmFtZSwgZW5jb2RpbmcpIHtcbiAgdmFyIGxlZyA9IGVuY29kaW5nLmZpZWxkKG5hbWUpLmxlZ2VuZDtcblxuICBpZiAobGVnLnRpdGxlKSByZXR1cm4gbGVnLnRpdGxlO1xuXG4gIHJldHVybiBlbmNvZGluZy5maWVsZFRpdGxlKG5hbWUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgbWFya3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5tYXJrcy5kZWYgPSBmdW5jdGlvbihlbmNvZGluZywgbGF5b3V0LCBzdHlsZSwgc3RhdHMpIHtcblxuICB2YXIgZGVmcyA9IFtdLFxuICAgIG1hcmsgPSBtYXJrc1tlbmNvZGluZy5tYXJrdHlwZSgpXSxcbiAgICBmcm9tID0gZW5jb2RpbmcuZGF0YVRhYmxlKCk7XG5cbiAgLy8gdG8gYWRkIGEgYmFja2dyb3VuZCB0byB0ZXh0LCB3ZSBuZWVkIHRvIGFkZCBpdCBiZWZvcmUgdGhlIHRleHRcbiAgaWYgKGVuY29kaW5nLm1hcmt0eXBlKCkgPT09IFRFWFQgJiYgZW5jb2RpbmcuaGFzKENPTE9SKSkge1xuICAgIHZhciBiZyA9IHtcbiAgICAgIHg6IHt2YWx1ZTogMH0sXG4gICAgICB5OiB7dmFsdWU6IDB9LFxuICAgICAgeDI6IHt2YWx1ZTogbGF5b3V0LmNlbGxXaWR0aH0sXG4gICAgICB5Mjoge3ZhbHVlOiBsYXlvdXQuY2VsbEhlaWdodH0sXG4gICAgICBmaWxsOiB7c2NhbGU6IENPTE9SLCBmaWVsZDogZW5jb2RpbmcuZmllbGRSZWYoQ09MT1IpfVxuICAgIH07XG4gICAgZGVmcy5wdXNoKHtcbiAgICAgIHR5cGU6ICdyZWN0JyxcbiAgICAgIGZyb206IHtkYXRhOiBmcm9tfSxcbiAgICAgIHByb3BlcnRpZXM6IHtlbnRlcjogYmcsIHVwZGF0ZTogYmd9XG4gICAgfSk7XG4gIH1cblxuICAvLyBhZGQgdGhlIG1hcmsgZGVmIGZvciB0aGUgbWFpbiB0aGluZ1xuICB2YXIgcCA9IG1hcmsucHJvcChlbmNvZGluZywgbGF5b3V0LCBzdHlsZSwgc3RhdHMpO1xuICBkZWZzLnB1c2goe1xuICAgIHR5cGU6IG1hcmsudHlwZSxcbiAgICBmcm9tOiB7ZGF0YTogZnJvbX0sXG4gICAgcHJvcGVydGllczoge2VudGVyOiBwLCB1cGRhdGU6IHB9XG4gIH0pO1xuXG4gIHJldHVybiBkZWZzO1xufTtcblxubWFya3MuYmFyID0ge1xuICB0eXBlOiAncmVjdCcsXG4gIHN0YWNrOiB0cnVlLFxuICBwcm9wOiBiYXJfcHJvcHMsXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OiAxLCBjb2w6IDEsIHg6IDEsIHk6IDEsIHNpemU6IDEsIGNvbG9yOiAxfVxufTtcblxubWFya3MubGluZSA9IHtcbiAgdHlwZTogJ2xpbmUnLFxuICBsaW5lOiB0cnVlLFxuICBwcm9wOiBsaW5lX3Byb3BzLFxuICByZXF1aXJlZEVuY29kaW5nOiBbJ3gnLCAneSddLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCB4OiAxLCB5OiAxLCBjb2xvcjogMSwgZGV0YWlsOjF9XG59O1xuXG5tYXJrcy5hcmVhID0ge1xuICB0eXBlOiAnYXJlYScsXG4gIHN0YWNrOiB0cnVlLFxuICBsaW5lOiB0cnVlLFxuICByZXF1aXJlZEVuY29kaW5nOiBbJ3gnLCAneSddLFxuICBwcm9wOiBhcmVhX3Byb3BzLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCB4OiAxLCB5OiAxLCBjb2xvcjogMX1cbn07XG5cbm1hcmtzLnRpY2sgPSB7XG4gIHR5cGU6ICdyZWN0JyxcbiAgcHJvcDogdGlja19wcm9wcyxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgeDogMSwgeTogMSwgY29sb3I6IDEsIGRldGFpbDogMX1cbn07XG5cbm1hcmtzLmNpcmNsZSA9IHtcbiAgdHlwZTogJ3N5bWJvbCcsXG4gIHByb3A6IGZpbGxlZF9wb2ludF9wcm9wcygnY2lyY2xlJyksXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OiAxLCBjb2w6IDEsIHg6IDEsIHk6IDEsIHNpemU6IDEsIGNvbG9yOiAxLCBkZXRhaWw6IDF9XG59O1xuXG5tYXJrcy5zcXVhcmUgPSB7XG4gIHR5cGU6ICdzeW1ib2wnLFxuICBwcm9wOiBmaWxsZWRfcG9pbnRfcHJvcHMoJ3NxdWFyZScpLFxuICBzdXBwb3J0ZWRFbmNvZGluZzogbWFya3MuY2lyY2xlLnN1cHBvcnRlZEVuY29kaW5nXG59O1xuXG5tYXJrcy5wb2ludCA9IHtcbiAgdHlwZTogJ3N5bWJvbCcsXG4gIHByb3A6IHBvaW50X3Byb3BzLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCB4OiAxLCB5OiAxLCBzaXplOiAxLCBjb2xvcjogMSwgc2hhcGU6IDEsIGRldGFpbDogMX1cbn07XG5cbm1hcmtzLnRleHQgPSB7XG4gIHR5cGU6ICd0ZXh0JyxcbiAgcHJvcDogdGV4dF9wcm9wcyxcbiAgcmVxdWlyZWRFbmNvZGluZzogWyd0ZXh0J10sXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OiAxLCBjb2w6IDEsIHNpemU6IDEsIGNvbG9yOiAxLCB0ZXh0OiAxfVxufTtcblxuZnVuY3Rpb24gYmFyX3Byb3BzKGUsIGxheW91dCwgc3R5bGUpIHtcbiAgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuXG4gIHZhciBwID0ge307XG5cbiAgLy8geCdzIGFuZCB3aWR0aFxuICBpZiAoZS5pc01lYXN1cmUoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkUmVmKFgpfTtcbiAgICBpZiAoIWUuaGFzKFkpIHx8IGUuaXNEaW1lbnNpb24oWSkpIHtcbiAgICAgIHAueDIgPSB7dmFsdWU6IDB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZS5oYXMoWCkpIHsgLy8gaXMgb3JkaW5hbFxuICAgICAgIHAueGMgPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkUmVmKFgpfTtcbiAgICB9IGVsc2Uge1xuICAgICAgIHAueCA9IHt2YWx1ZTogMCwgb2Zmc2V0OiBlLmNvbmZpZygnc2luZ2xlQmFyT2Zmc2V0Jyl9O1xuICAgIH1cbiAgfVxuXG4gIC8vIHdpZHRoXG4gIGlmICghcC54Mikge1xuICAgIGlmICghZS5oYXMoWCkgfHwgZS5pc09yZGluYWxTY2FsZShYKSkgeyAvLyBubyBYIG9yIFggaXMgb3JkaW5hbFxuICAgICAgaWYgKGUuaGFzKFNJWkUpKSB7XG4gICAgICAgIHAud2lkdGggPSB7c2NhbGU6IFNJWkUsIGZpZWxkOiBlLmZpZWxkUmVmKFNJWkUpfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHAud2lkdGggPSB7XG4gICAgICAgICAgdmFsdWU6IGUuYmFuZFNpemUoWCwgbGF5b3V0LngudXNlU21hbGxCYW5kKSxcbiAgICAgICAgICBvZmZzZXQ6IC0xXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gWCBpcyBRdWFudCBvciBUaW1lIFNjYWxlXG4gICAgICBwLndpZHRoID0ge3ZhbHVlOiAyfTtcbiAgICB9XG4gIH1cblxuICAvLyB5J3MgJiBoZWlnaHRcbiAgaWYgKGUuaXNNZWFzdXJlKFkpKSB7XG4gICAgcC55ID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZFJlZihZKX07XG4gICAgcC55MiA9IHtncm91cDogJ2hlaWdodCd9O1xuICB9IGVsc2Uge1xuICAgIGlmIChlLmhhcyhZKSkgeyAvLyBpcyBvcmRpbmFsXG4gICAgICBwLnljID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZFJlZihZKX07XG4gICAgfSBlbHNlIHtcbiAgICAgIHAueTIgPSB7Z3JvdXA6ICdoZWlnaHQnLCBvZmZzZXQ6IC1lLmNvbmZpZygnc2luZ2xlQmFyT2Zmc2V0Jyl9O1xuICAgIH1cblxuICAgIGlmIChlLmhhcyhTSVpFKSkge1xuICAgICAgcC5oZWlnaHQgPSB7c2NhbGU6IFNJWkUsIGZpZWxkOiBlLmZpZWxkUmVmKFNJWkUpfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcC5oZWlnaHQgPSB7XG4gICAgICAgIHZhbHVlOiBlLmJhbmRTaXplKFksIGxheW91dC55LnVzZVNtYWxsQmFuZCksXG4gICAgICAgIG9mZnNldDogLTFcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gZmlsbFxuICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5maWxsID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGRSZWYoQ09MT1IpfTtcbiAgfSBlbHNlIHtcbiAgICBwLmZpbGwgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgfVxuXG4gIC8vIG9wYWNpdHlcbiAgdmFyIG9wYWNpdHkgPSBlLmZpZWxkKENPTE9SKS5vcGFjaXR5O1xuICBpZiAob3BhY2l0eSkgcC5vcGFjaXR5ID0ge3ZhbHVlOiBvcGFjaXR5fTtcblxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gcG9pbnRfcHJvcHMoZSwgbGF5b3V0LCBzdHlsZSkge1xuICB2YXIgcCA9IHt9O1xuXG4gIC8vIHhcbiAgaWYgKGUuaGFzKFgpKSB7XG4gICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZFJlZihYKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFgpKSB7XG4gICAgcC54ID0ge3ZhbHVlOiBlLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCkgLyAyfTtcbiAgfVxuXG4gIC8vIHlcbiAgaWYgKGUuaGFzKFkpKSB7XG4gICAgcC55ID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZFJlZihZKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFkpKSB7XG4gICAgcC55ID0ge3ZhbHVlOiBlLmJhbmRTaXplKFksIGxheW91dC55LnVzZVNtYWxsQmFuZCkgLyAyfTtcbiAgfVxuXG4gIC8vIHNpemVcbiAgaWYgKGUuaGFzKFNJWkUpKSB7XG4gICAgcC5zaXplID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZFJlZihTSVpFKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFNJWkUpKSB7XG4gICAgcC5zaXplID0ge3ZhbHVlOiBlLnZhbHVlKFNJWkUpfTtcbiAgfVxuXG4gIC8vIHNoYXBlXG4gIGlmIChlLmhhcyhTSEFQRSkpIHtcbiAgICBwLnNoYXBlID0ge3NjYWxlOiBTSEFQRSwgZmllbGQ6IGUuZmllbGRSZWYoU0hBUEUpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoU0hBUEUpKSB7XG4gICAgcC5zaGFwZSA9IHt2YWx1ZTogZS52YWx1ZShTSEFQRSl9O1xuICB9XG5cbiAgLy8gZmlsbCBvciBzdHJva2VcbiAgaWYgKGUuZmllbGQoU0hBUEUpLmZpbGxlZCkge1xuICAgIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICAgIHAuZmlsbCA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkUmVmKENPTE9SKX07XG4gICAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgICBwLmZpbGwgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGUuaGFzKENPTE9SKSkge1xuICAgICAgcC5zdHJva2UgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZFJlZihDT0xPUil9O1xuICAgIH0gZWxzZSBpZiAoIWUuaGFzKENPTE9SKSkge1xuICAgICAgcC5zdHJva2UgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgICB9XG4gICAgcC5zdHJva2VXaWR0aCA9IHt2YWx1ZTogZS5jb25maWcoJ3N0cm9rZVdpZHRoJyl9O1xuICB9XG5cbiAgLy8gb3BhY2l0eVxuICB2YXIgb3BhY2l0eSA9IGUuZmllbGQoQ09MT1IpLm9wYWNpdHkgfHwgc3R5bGUub3BhY2l0eTtcbiAgaWYgKG9wYWNpdHkpIHAub3BhY2l0eSA9IHt2YWx1ZTogb3BhY2l0eX07XG5cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIGxpbmVfcHJvcHMoZSxsYXlvdXQsIHN0eWxlKSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmhhcyhYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGRSZWYoWCl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgIHAueCA9IHt2YWx1ZTogMH07XG4gIH1cblxuICAvLyB5XG4gIGlmIChlLmhhcyhZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGRSZWYoWSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhZKSkge1xuICAgIHAueSA9IHtncm91cDogJ2hlaWdodCd9O1xuICB9XG5cbiAgLy8gc3Ryb2tlXG4gIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICBwLnN0cm9rZSA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkUmVmKENPTE9SKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKENPTE9SKSkge1xuICAgIHAuc3Ryb2tlID0ge3ZhbHVlOiBlLnZhbHVlKENPTE9SKX07XG4gIH1cblxuICB2YXIgb3BhY2l0eSA9IGUuZmllbGQoQ09MT1IpLm9wYWNpdHk7XG4gIGlmIChvcGFjaXR5KSBwLm9wYWNpdHkgPSB7dmFsdWU6IG9wYWNpdHl9O1xuXG4gIHAuc3Ryb2tlV2lkdGggPSB7dmFsdWU6IGUuY29uZmlnKCdzdHJva2VXaWR0aCcpfTtcblxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gYXJlYV9wcm9wcyhlLCBsYXlvdXQsIHN0eWxlKSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmlzTWVhc3VyZShYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGRSZWYoWCl9O1xuICAgIGlmIChlLmlzRGltZW5zaW9uKFkpKSB7XG4gICAgICBwLngyID0ge3NjYWxlOiBYLCB2YWx1ZTogMH07XG4gICAgICBwLm9yaWVudCA9IHt2YWx1ZTogJ2hvcml6b250YWwnfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkUmVmKFgpfTtcbiAgfSBlbHNlIHtcbiAgICBwLnggPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5pc01lYXN1cmUoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkUmVmKFkpfTtcbiAgICBwLnkyID0ge3NjYWxlOiBZLCB2YWx1ZTogMH07XG4gIH0gZWxzZSBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkUmVmKFkpfTtcbiAgfSBlbHNlIHtcbiAgICBwLnkgPSB7Z3JvdXA6ICdoZWlnaHQnfTtcbiAgfVxuXG4gIC8vIGZpbGxcbiAgaWYgKGUuaGFzKENPTE9SKSkge1xuICAgIHAuZmlsbCA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkUmVmKENPTE9SKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKENPTE9SKSkge1xuICAgIHAuZmlsbCA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICB9XG5cbiAgdmFyIG9wYWNpdHkgPSBlLmZpZWxkKENPTE9SKS5vcGFjaXR5O1xuICBpZiAob3BhY2l0eSkgcC5vcGFjaXR5ID0ge3ZhbHVlOiBvcGFjaXR5fTtcblxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gdGlja19wcm9wcyhlLCBsYXlvdXQsIHN0eWxlKSB7XG4gIHZhciBwID0ge307XG5cbiAgLy8geFxuICBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkUmVmKFgpfTtcbiAgICBpZiAoZS5pc0RpbWVuc2lvbihYKSkge1xuICAgICAgcC54Lm9mZnNldCA9IC1lLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCkgLyAzO1xuICAgIH1cbiAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkUmVmKFkpfTtcbiAgICBpZiAoZS5pc0RpbWVuc2lvbihZKSkge1xuICAgICAgcC55Lm9mZnNldCA9IC1lLmJhbmRTaXplKFksIGxheW91dC55LnVzZVNtYWxsQmFuZCkgLyAzO1xuICAgIH1cbiAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8gd2lkdGhcbiAgaWYgKCFlLmhhcyhYKSB8fCBlLmlzRGltZW5zaW9uKFgpKSB7XG4gICAgcC53aWR0aCA9IHt2YWx1ZTogZS5iYW5kU2l6ZShYLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMS41fTtcbiAgfSBlbHNlIHtcbiAgICBwLndpZHRoID0ge3ZhbHVlOiAxfTtcbiAgfVxuXG4gIC8vIGhlaWdodFxuICBpZiAoIWUuaGFzKFkpIHx8IGUuaXNEaW1lbnNpb24oWSkpIHtcbiAgICBwLmhlaWdodCA9IHt2YWx1ZTogZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMS41fTtcbiAgfSBlbHNlIHtcbiAgICBwLmhlaWdodCA9IHt2YWx1ZTogMX07XG4gIH1cblxuICAvLyBmaWxsXG4gIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZFJlZihDT0xPUil9O1xuICB9IGVsc2Uge1xuICAgIHAuZmlsbCA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICB9XG5cbiAgdmFyIG9wYWNpdHkgPSBlLmZpZWxkKENPTE9SKS5vcGFjaXR5ICB8fCBzdHlsZS5vcGFjaXR5O1xuICBpZihvcGFjaXR5KSBwLm9wYWNpdHkgPSB7dmFsdWU6IG9wYWNpdHl9O1xuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBmaWxsZWRfcG9pbnRfcHJvcHMoc2hhcGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGUsIGxheW91dCwgc3R5bGUpIHtcbiAgICB2YXIgcCA9IHt9O1xuXG4gICAgLy8geFxuICAgIGlmIChlLmhhcyhYKSkge1xuICAgICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZFJlZihYKX07XG4gICAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICAgIHAueCA9IHt2YWx1ZTogZS5iYW5kU2l6ZShYLCBsYXlvdXQueC51c2VTbWFsbEJhbmQpIC8gMn07XG4gICAgfVxuXG4gICAgLy8geVxuICAgIGlmIChlLmhhcyhZKSkge1xuICAgICAgcC55ID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZFJlZihZKX07XG4gICAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICAgIHAueSA9IHt2YWx1ZTogZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMn07XG4gICAgfVxuXG4gICAgLy8gc2l6ZVxuICAgIGlmIChlLmhhcyhTSVpFKSkge1xuICAgICAgcC5zaXplID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZFJlZihTSVpFKX07XG4gICAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICAgIHAuc2l6ZSA9IHt2YWx1ZTogZS52YWx1ZShTSVpFKX07XG4gICAgfVxuXG4gICAgLy8gc2hhcGVcbiAgICBwLnNoYXBlID0ge3ZhbHVlOiBzaGFwZX07XG5cbiAgICAvLyBmaWxsXG4gICAgaWYgKGUuaGFzKENPTE9SKSkge1xuICAgICAgcC5maWxsID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGRSZWYoQ09MT1IpfTtcbiAgICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICAgIHAuZmlsbCA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICAgIH1cblxuICAgIHZhciBvcGFjaXR5ID0gZS5maWVsZChDT0xPUikub3BhY2l0eSAgfHwgc3R5bGUub3BhY2l0eTtcbiAgICBpZihvcGFjaXR5KSBwLm9wYWNpdHkgPSB7dmFsdWU6IG9wYWNpdHl9O1xuXG4gICAgcmV0dXJuIHA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRfcHJvcHMoZSwgbGF5b3V0LCBzdHlsZSwgc3RhdHMpIHtcbiAgdmFyIHAgPSB7fSxcbiAgICBmaWVsZCA9IGUuZmllbGQoVEVYVCk7XG5cbiAgLy8geFxuICBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkUmVmKFgpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICBpZiAoZS5oYXMoVEVYVCkgJiYgZS5pc1R5cGUoVEVYVCwgUSkpIHtcbiAgICAgIHAueCA9IHt2YWx1ZTogbGF5b3V0LmNlbGxXaWR0aC01fTtcbiAgICB9IGVsc2Uge1xuICAgICAgcC54ID0ge3ZhbHVlOiBlLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCkgLyAyfTtcbiAgICB9XG4gIH1cblxuICAvLyB5XG4gIGlmIChlLmhhcyhZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGRSZWYoWSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhZKSkge1xuICAgIHAueSA9IHt2YWx1ZTogZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMn07XG4gIH1cblxuICAvLyBzaXplXG4gIGlmIChlLmhhcyhTSVpFKSkge1xuICAgIHAuZm9udFNpemUgPSB7c2NhbGU6IFNJWkUsIGZpZWxkOiBlLmZpZWxkUmVmKFNJWkUpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoU0laRSkpIHtcbiAgICBwLmZvbnRTaXplID0ge3ZhbHVlOiBmaWVsZC5mb250LnNpemV9O1xuICB9XG5cbiAgLy8gZmlsbFxuICAvLyBjb2xvciBzaG91bGQgYmUgc2V0IHRvIGJhY2tncm91bmRcbiAgcC5maWxsID0ge3ZhbHVlOiBmaWVsZC5jb2xvcn07XG5cbiAgdmFyIG9wYWNpdHkgPSBlLmZpZWxkKENPTE9SKS5vcGFjaXR5ICB8fCBzdHlsZS5vcGFjaXR5O1xuICBpZihvcGFjaXR5KSBwLm9wYWNpdHkgPSB7dmFsdWU6IG9wYWNpdHl9O1xuXG4gIC8vIHRleHRcbiAgaWYgKGUuaGFzKFRFWFQpKSB7XG4gICAgaWYgKGUuaXNUeXBlKFRFWFQsIFEpKSB7XG4gICAgICB2YXIgZmllbGRTdGF0cyA9IHN0YXRzW2UuZmllbGROYW1lKFRFWFQpXSxcbiAgICAgICAgbnVtYmVyRm9ybWF0ID0gZmllbGQuZm9ybWF0IHx8IGUubnVtYmVyRm9ybWF0KGZpZWxkU3RhdHMpO1xuXG4gICAgICBwLnRleHQgPSB7dGVtcGxhdGU6ICd7eycgKyBlLmZpZWxkUmVmKFRFWFQpICsgJyB8IG51bWJlcjpcXCcnICtcbiAgICAgICAgbnVtYmVyRm9ybWF0ICsnXFwnfX0nfTtcbiAgICAgIHAuYWxpZ24gPSB7dmFsdWU6IGZpZWxkLmFsaWdufTtcbiAgICB9IGVsc2Uge1xuICAgICAgcC50ZXh0ID0ge2ZpZWxkOiBlLmZpZWxkUmVmKFRFWFQpfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcC50ZXh0ID0ge3ZhbHVlOiBmaWVsZC5wbGFjZWhvbGRlcn07XG4gIH1cblxuICBwLmZvbnQgPSB7dmFsdWU6IGZpZWxkLmZvbnQuZmFtaWx5fTtcbiAgcC5mb250V2VpZ2h0ID0ge3ZhbHVlOiBmaWVsZC5mb250LndlaWdodH07XG4gIHAuZm9udFN0eWxlID0ge3ZhbHVlOiBmaWVsZC5mb250LnN0eWxlfTtcbiAgcC5iYXNlbGluZSA9IHt2YWx1ZTogZmllbGQuYmFzZWxpbmV9O1xuXG4gIHJldHVybiBwO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIHRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKSxcbiAgY29sb3JicmV3ZXIgPSByZXF1aXJlKCdjb2xvcmJyZXdlcicpLFxuICBpbnRlcnBvbGF0ZSA9IHJlcXVpcmUoJ2QzLWNvbG9yJykuaW50ZXJwb2xhdGVIc2wsXG4gIHNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYS9zY2hlbWEnKSxcbiAgdmxzb3J0ID0gcmVxdWlyZSgnLi9zb3J0Jyk7XG5cbnZhciBzY2FsZSA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnNjYWxlLm5hbWVzID0gZnVuY3Rpb24ocHJvcHMpIHtcbiAgcmV0dXJuIHV0aWwua2V5cyh1dGlsLmtleXMocHJvcHMpLnJlZHVjZShmdW5jdGlvbihhLCB4KSB7XG4gICAgaWYgKHByb3BzW3hdICYmIHByb3BzW3hdLnNjYWxlKSBhW3Byb3BzW3hdLnNjYWxlXSA9IDE7XG4gICAgcmV0dXJuIGE7XG4gIH0sIHt9KSk7XG59O1xuXG5zY2FsZS5kZWZzID0gZnVuY3Rpb24obmFtZXMsIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gIHJldHVybiBuYW1lcy5yZWR1Y2UoZnVuY3Rpb24oYSwgbmFtZSkge1xuICAgIHZhciBzID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHR5cGU6IHNjYWxlLnR5cGUobmFtZSwgZW5jb2RpbmcpLFxuICAgICAgZG9tYWluOiBzY2FsZS5kb21haW4obmFtZSwgZW5jb2RpbmcsIHN0YXRzLCBvcHQpXG4gICAgfTtcblxuICAgIHMuc29ydCA9IHNjYWxlLnNvcnQocywgZW5jb2RpbmcsIG5hbWUpIHx8IHVuZGVmaW5lZDtcblxuICAgIHNjYWxlLnJhbmdlKHMsIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzLCBvcHQpO1xuXG4gICAgcmV0dXJuIChhLnB1c2gocyksIGEpO1xuICB9LCBbXSk7XG59O1xuXG5zY2FsZS5zb3J0ID0gZnVuY3Rpb24ocywgZW5jb2RpbmcsIG5hbWUpIHtcbiAgcmV0dXJuIHMudHlwZSA9PT0gJ29yZGluYWwnICYmIChcbiAgICAhIWVuY29kaW5nLmJpbihuYW1lKSB8fFxuICAgIGVuY29kaW5nLnNvcnQobmFtZSkubGVuZ3RoID09PSAwXG4gICk7XG59O1xuXG5zY2FsZS50eXBlID0gZnVuY3Rpb24obmFtZSwgZW5jb2RpbmcpIHtcblxuICBzd2l0Y2ggKGVuY29kaW5nLnR5cGUobmFtZSkpIHtcbiAgICBjYXNlIE46IC8vZmFsbCB0aHJvdWdoXG4gICAgY2FzZSBPOiByZXR1cm4gJ29yZGluYWwnO1xuICAgIGNhc2UgVDpcbiAgICAgIHZhciB0aW1lVW5pdCA9IGVuY29kaW5nLmZpZWxkKG5hbWUpLnRpbWVVbml0O1xuICAgICAgcmV0dXJuIHRpbWVVbml0ID8gdGltZS5zY2FsZS50eXBlKHRpbWVVbml0LCBuYW1lKSA6ICd0aW1lJztcbiAgICBjYXNlIFE6XG4gICAgICBpZiAoZW5jb2RpbmcuYmluKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBuYW1lID09PSBDT0xPUiA/ICdsaW5lYXInIDogJ29yZGluYWwnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVuY29kaW5nLnNjYWxlKG5hbWUpLnR5cGU7XG4gIH1cbn07XG5cbnNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uIChuYW1lLCBlbmNvZGluZywgc3RhdHMsIG9wdCkge1xuICB2YXIgZmllbGQgPSBlbmNvZGluZy5maWVsZChuYW1lKTtcblxuICBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFQpKSB7XG4gICAgdmFyIHJhbmdlID0gdGltZS5zY2FsZS5kb21haW4oZmllbGQudGltZVVuaXQsIG5hbWUpO1xuICAgIGlmKHJhbmdlKSByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICBpZiAoZmllbGQuYmluKSB7XG4gICAgLy8gVE9ETyhrYW5pdHcpOiB0aGlzIG11c3QgYmUgY2hhbmdlZCBpbiB2ZzJcbiAgICB2YXIgZmllbGRTdGF0ID0gc3RhdHNbZmllbGQubmFtZV0sXG4gICAgICBiaW5zID0gdXRpbC5nZXRiaW5zKGZpZWxkU3RhdCwgZmllbGQuYmluLm1heGJpbnMgfHwgc2NoZW1hLk1BWEJJTlNfREVGQVVMVCksXG4gICAgICBudW1iaW5zID0gKGJpbnMuc3RvcCAtIGJpbnMuc3RhcnQpIC8gYmlucy5zdGVwO1xuICAgIHJldHVybiB1dGlsLnJhbmdlKG51bWJpbnMpLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gYmlucy5zdGFydCArIGJpbnMuc3RlcCAqIGk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAobmFtZSA9PSBvcHQuc3RhY2spIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogU1RBQ0tFRCxcbiAgICAgIGZpZWxkOiBlbmNvZGluZy5maWVsZFJlZihuYW1lLCB7XG4gICAgICAgIGRhdGE6ICFlbmNvZGluZy5fdmVnYTIsXG4gICAgICAgIHByZWZuOiAob3B0LmZhY2V0ID8gJ21heF8nIDogJycpICsgJ3N1bV8nXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgdmFyIGFnZ3JlZ2F0ZSA9IGVuY29kaW5nLmFnZ3JlZ2F0ZShuYW1lKSxcbiAgICB0aW1lVW5pdCA9IGZpZWxkLnRpbWVVbml0LFxuICAgIHNjYWxlVXNlUmF3RG9tYWluID0gZW5jb2Rpbmcuc2NhbGUobmFtZSkudXNlUmF3RG9tYWluLFxuICAgIHVzZVJhd0RvbWFpbiA9IHNjYWxlVXNlUmF3RG9tYWluICE9PSB1bmRlZmluZWQgP1xuICAgICAgc2NhbGVVc2VSYXdEb21haW4gOiBlbmNvZGluZy5jb25maWcoJ3VzZVJhd0RvbWFpbicpLFxuICAgIG5vdENvdW50T3JTdW0gPSAhYWdncmVnYXRlIHx8IChhZ2dyZWdhdGUgIT09J2NvdW50JyAmJiBhZ2dyZWdhdGUgIT09ICdzdW0nKTtcblxuICAvLyBGSVhNRSByZXZpc2UgdGhpcyBwYXJ0XG5cbiAgaWYgKCB1c2VSYXdEb21haW4gJiYgbm90Q291bnRPclN1bSAmJiAoXG4gICAgICAvLyBRIGFsd2F5cyB1c2VzIG5vbi1vcmRpbmFsIHNjYWxlIGV4Y2VwdCB3aGVuIGl0J3MgYmlubmVkIGFuZCB0aHVzIHVzZXMgb3JkaW5hbCBzY2FsZS5cbiAgICAgIChlbmNvZGluZy5pc1R5cGUobmFtZSwgUSkgJiYgIWZpZWxkLmJpbikgfHxcbiAgICAgIC8vIFQgdXNlcyBub24tb3JkaW5hbCBzY2FsZSB3aGVuIHRoZXJlJ3Mgbm8gdW5pdCBvciB3aGVuIHRoZSB1bml0IGlzIG5vdCBvcmRpbmFsLlxuICAgICAgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBUKSAmJiAoIXRpbWVVbml0IHx8ICF0aW1lLmlzT3JkaW5hbEZuKHRpbWVVbml0KSkpXG4gICAgKVxuICApIHtcbiAgICByZXR1cm4ge2RhdGE6IFJBVywgZmllbGQ6IGVuY29kaW5nLmZpZWxkUmVmKG5hbWUsIHtub2ZuOiAhdGltZVVuaXR9KX07XG4gIH1cblxuICB2YXIgZGF0YSA9IGVuY29kaW5nLnNvcnQobmFtZSwgc3RhdHMpLmxlbmd0aCA+IDAgP1xuICAgIHZsc29ydC5nZXREYXRhTmFtZShuYW1lKTpcbiAgICBlbmNvZGluZy5kYXRhVGFibGUoKTtcblxuICByZXR1cm4ge2RhdGE6IGRhdGEsIGZpZWxkOiBlbmNvZGluZy5maWVsZFJlZihuYW1lKX07XG59O1xuXG5cbnNjYWxlLnJhbmdlID0gZnVuY3Rpb24gKHMsIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSB7XG4gIHZhciBzcGVjID0gZW5jb2Rpbmcuc2NhbGUocy5uYW1lKSxcbiAgICBmaWVsZCA9IGVuY29kaW5nLmZpZWxkKHMubmFtZSksXG4gICAgdGltZVVuaXQgPSBmaWVsZC50aW1lVW5pdDtcblxuICBzd2l0Y2ggKHMubmFtZSkge1xuICAgIGNhc2UgWDpcbiAgICAgIHMucmFuZ2UgPSBsYXlvdXQuY2VsbFdpZHRoID8gWzAsIGxheW91dC5jZWxsV2lkdGhdIDogJ3dpZHRoJztcbiAgICAgIGlmIChzLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICBzLmJhbmRXaWR0aCA9IGVuY29kaW5nLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZW5jb2RpbmcuaXNUeXBlKHMubmFtZSxUKSAmJiB0aW1lVW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgcy56ZXJvID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcy56ZXJvID0gc3BlYy56ZXJvID09PSB1bmRlZmluZWQgPyB0cnVlIDogc3BlYy56ZXJvO1xuICAgICAgICB9XG5cbiAgICAgICAgcy5yZXZlcnNlID0gc3BlYy5yZXZlcnNlO1xuICAgICAgfVxuICAgICAgcy5yb3VuZCA9IHRydWU7XG4gICAgICBpZiAocy50eXBlID09PSAndGltZScpIHtcbiAgICAgICAgcy5uaWNlID0gdGltZVVuaXQgfHwgZW5jb2RpbmcuY29uZmlnKCd0aW1lU2NhbGVOaWNlJyk7XG4gICAgICB9ZWxzZSB7XG4gICAgICAgIHMubmljZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFk6XG4gICAgICBpZiAocy50eXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgcy5yYW5nZSA9IGxheW91dC5jZWxsSGVpZ2h0ID9cbiAgICAgICAgICAoZmllbGQuYmluID8gW2xheW91dC5jZWxsSGVpZ2h0LCAwXSA6IFswLCBsYXlvdXQuY2VsbEhlaWdodF0pIDpcbiAgICAgICAgICAnaGVpZ2h0JztcbiAgICAgICAgcy5iYW5kV2lkdGggPSBlbmNvZGluZy5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcy5yYW5nZSA9IGxheW91dC5jZWxsSGVpZ2h0ID8gW2xheW91dC5jZWxsSGVpZ2h0LCAwXSA6ICdoZWlnaHQnO1xuICAgICAgICBpZiAoZW5jb2RpbmcuaXNUeXBlKHMubmFtZSxUKSAmJiB0aW1lVW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgcy56ZXJvID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcy56ZXJvID0gc3BlYy56ZXJvID09PSB1bmRlZmluZWQgPyB0cnVlIDogc3BlYy56ZXJvO1xuICAgICAgICB9XG5cbiAgICAgICAgcy5yZXZlcnNlID0gc3BlYy5yZXZlcnNlO1xuICAgICAgfVxuXG4gICAgICBzLnJvdW5kID0gdHJ1ZTtcblxuICAgICAgaWYgKHMudHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgIHMubmljZSA9IHRpbWVVbml0IHx8IGVuY29kaW5nLmNvbmZpZygndGltZVNjYWxlTmljZScpO1xuICAgICAgfWVsc2Uge1xuICAgICAgICBzLm5pY2UgPSB0cnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBST1c6IC8vIHN1cHBvcnQgb25seSBvcmRpbmFsXG4gICAgICBzLmJhbmRXaWR0aCA9IGxheW91dC5jZWxsSGVpZ2h0O1xuICAgICAgcy5yb3VuZCA9IHRydWU7XG4gICAgICBzLm5pY2UgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDT0w6IC8vIHN1cHBvcnQgb25seSBvcmRpbmFsXG4gICAgICBzLmJhbmRXaWR0aCA9IGxheW91dC5jZWxsV2lkdGg7XG4gICAgICBzLnJvdW5kID0gdHJ1ZTtcbiAgICAgIHMubmljZSA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNJWkU6XG4gICAgICBpZiAoZW5jb2RpbmcuaXMoJ2JhcicpKSB7XG4gICAgICAgIC8vIEZJWE1FIHRoaXMgaXMgZGVmaW5pdGVseSBpbmNvcnJlY3RcbiAgICAgICAgLy8gYnV0IGxldCdzIGZpeCBpdCBsYXRlciBzaW5jZSBiYXIgc2l6ZSBpcyBhIGJhZCBlbmNvZGluZyBhbnl3YXlcbiAgICAgICAgcy5yYW5nZSA9IFszLCBNYXRoLm1heChlbmNvZGluZy5iYW5kU2l6ZShYKSwgZW5jb2RpbmcuYmFuZFNpemUoWSkpXTtcbiAgICAgIH0gZWxzZSBpZiAoZW5jb2RpbmcuaXMoVEVYVCkpIHtcbiAgICAgICAgcy5yYW5nZSA9IFs4LCA0MF07XG4gICAgICB9IGVsc2UgeyAvL3BvaW50XG4gICAgICAgIHZhciBiYW5kU2l6ZSA9IE1hdGgubWluKGVuY29kaW5nLmJhbmRTaXplKFgpLCBlbmNvZGluZy5iYW5kU2l6ZShZKSkgLSAxO1xuICAgICAgICBzLnJhbmdlID0gWzEwLCAwLjggKiBiYW5kU2l6ZSpiYW5kU2l6ZV07XG4gICAgICB9XG4gICAgICBzLnJvdW5kID0gdHJ1ZTtcbiAgICAgIHMuemVybyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTSEFQRTpcbiAgICAgIHMucmFuZ2UgPSAnc2hhcGVzJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ09MT1I6XG4gICAgICBzLnJhbmdlID0gc2NhbGUuY29sb3IocywgZW5jb2RpbmcsIHN0YXRzKTtcbiAgICAgIGlmIChzLnR5cGUgIT09ICdvcmRpbmFsJykgcy56ZXJvID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nIG5hbWU6ICcrIHMubmFtZSk7XG4gIH1cblxuICAvLyBGSVhNRShrYW5pdHcpOiBKdWwgMjksIDIwMTUgLSBjb25zb2xpZGF0ZSB0aGlzIHdpdGggYWJvdmVcbiAgc3dpdGNoIChzLm5hbWUpIHtcbiAgICBjYXNlIFJPVzpcbiAgICBjYXNlIENPTDpcbiAgICAgIHMucGFkZGluZyA9IGVuY29kaW5nLmNvbmZpZygnY2VsbFBhZGRpbmcnKTtcbiAgICAgIHMub3V0ZXJQYWRkaW5nID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWDpcbiAgICBjYXNlIFk6XG4gICAgICBpZiAocy50eXBlID09PSAnb3JkaW5hbCcpIHsgLy8mJiAhcy5iYW5kV2lkdGhcbiAgICAgICAgcy5wb2ludHMgPSB0cnVlO1xuICAgICAgICBzLnBhZGRpbmcgPSBlbmNvZGluZy5maWVsZChzLm5hbWUpLmJhbmQucGFkZGluZztcbiAgICAgIH1cbiAgfVxufTtcblxuc2NhbGUuY29sb3IgPSBmdW5jdGlvbihzLCBlbmNvZGluZywgc3RhdHMpIHtcbiAgdmFyIGNvbG9yU2NhbGUgPSBlbmNvZGluZy5zY2FsZShDT0xPUiksXG4gICAgcmFuZ2UgPSBjb2xvclNjYWxlLnJhbmdlLFxuICAgIGNhcmRpbmFsaXR5ID0gZW5jb2RpbmcuY2FyZGluYWxpdHkoQ09MT1IsIHN0YXRzKSxcbiAgICB0eXBlID0gZW5jb2RpbmcudHlwZShDT0xPUik7XG5cbiAgaWYgKHJhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgb3JkaW5hbFBhbGV0dGUgPSBjb2xvclNjYWxlLm9yZGluYWxQYWxldHRlLFxuICAgICAgcXVhbnRpdGF0aXZlUmFuZ2UgPSBjb2xvclNjYWxlLnF1YW50aXRhdGl2ZVJhbmdlO1xuXG4gICAgaWYgKHMudHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICBpZiAodHlwZSA9PT0gTikge1xuICAgICAgICAvLyB1c2UgY2F0ZWdvcmljYWwgY29sb3Igc2NhbGVcbiAgICAgICAgaWYgKGNhcmRpbmFsaXR5IDw9IDEwKSB7XG4gICAgICAgICAgcmFuZ2UgPSBjb2xvclNjYWxlLmMxMHBhbGV0dGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmFuZ2UgPSBjb2xvclNjYWxlLmMyMHBhbGV0dGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjYWxlLmNvbG9yLnBhbGV0dGUocmFuZ2UsIGNhcmRpbmFsaXR5LCB0eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcmRpbmFsUGFsZXR0ZSkge1xuICAgICAgICAgIHJldHVybiBzY2FsZS5jb2xvci5wYWxldHRlKG9yZGluYWxQYWxldHRlLCBjYXJkaW5hbGl0eSwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjYWxlLmNvbG9yLmludGVycG9sYXRlKHF1YW50aXRhdGl2ZVJhbmdlWzBdLCBxdWFudGl0YXRpdmVSYW5nZVsxXSwgY2FyZGluYWxpdHkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vdGltZSBvciBxdWFudGl0YXRpdmVcbiAgICAgIHJldHVybiBbcXVhbnRpdGF0aXZlUmFuZ2VbMF0sIHF1YW50aXRhdGl2ZVJhbmdlWzFdXTtcbiAgICB9XG4gIH1cbn07XG5cbnNjYWxlLmNvbG9yLnBhbGV0dGUgPSBmdW5jdGlvbihyYW5nZSwgY2FyZGluYWxpdHksIHR5cGUpIHtcbiAgLy8gRklYTUUoa2FuaXR3KTogSnVsIDI5LCAyMDE1IC0gY2hlY2sgcmFuZ2UgaXMgc3RyaW5nXG4gIHN3aXRjaCAocmFuZ2UpIHtcbiAgICBjYXNlICdjYXRlZ29yeTEwayc6XG4gICAgICAvLyB0YWJsZWF1J3MgY2F0ZWdvcnkgMTAsIG9yZGVyZWQgYnkgcGVyY2VwdHVhbCBrZXJuZWwgc3R1ZHkgcmVzdWx0c1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3V3ZGF0YS9wZXJjZXB0dWFsLWtlcm5lbHNcbiAgICAgIHJldHVybiBbJyMyY2EwMmMnLCAnI2UzNzdjMicsICcjN2Y3ZjdmJywgJyMxN2JlY2YnLCAnIzhjNTY0YicsICcjZDYyNzI4JywgJyNiY2JkMjInLCAnIzk0NjdiZCcsICcjZmY3ZjBlJywgJyMxZjc3YjQnXTtcblxuICAgIC8vIGQzL3RhYmxlYXUgY2F0ZWdvcnkxMC8yMC8yMGIvMjBjXG4gICAgY2FzZSAnY2F0ZWdvcnkxMCc6XG4gICAgICByZXR1cm4gWycjMWY3N2I0JywgJyNmZjdmMGUnLCAnIzJjYTAyYycsICcjZDYyNzI4JywgJyM5NDY3YmQnLCAnIzhjNTY0YicsICcjZTM3N2MyJywgJyM3ZjdmN2YnLCAnI2JjYmQyMicsICcjMTdiZWNmJ107XG5cbiAgICBjYXNlICdjYXRlZ29yeTIwJzpcbiAgICAgIHJldHVybiBbJyMxZjc3YjQnLCAnI2FlYzdlOCcsICcjZmY3ZjBlJywgJyNmZmJiNzgnLCAnIzJjYTAyYycsICcjOThkZjhhJywgJyNkNjI3MjgnLCAnI2ZmOTg5NicsICcjOTQ2N2JkJywgJyNjNWIwZDUnLCAnIzhjNTY0YicsICcjYzQ5Yzk0JywgJyNlMzc3YzInLCAnI2Y3YjZkMicsICcjN2Y3ZjdmJywgJyNjN2M3YzcnLCAnI2JjYmQyMicsICcjZGJkYjhkJywgJyMxN2JlY2YnLCAnIzllZGFlNSddO1xuXG4gICAgY2FzZSAnY2F0ZWdvcnkyMGInOlxuICAgICAgcmV0dXJuIFsnIzM5M2I3OScsICcjNTI1NGEzJywgJyM2YjZlY2YnLCAnIzljOWVkZScsICcjNjM3OTM5JywgJyM4Y2EyNTInLCAnI2I1Y2Y2YicsICcjY2VkYjljJywgJyM4YzZkMzEnLCAnI2JkOWUzOScsICcjZTdiYTUyJywgJyNlN2NiOTQnLCAnIzg0M2MzOScsICcjYWQ0OTRhJywgJyNkNjYxNmInLCAnI2U3OTY5YycsICcjN2I0MTczJywgJyNhNTUxOTQnLCAnI2NlNmRiZCcsICcjZGU5ZWQ2J107XG5cbiAgICBjYXNlICdjYXRlZ29yeTIwYyc6XG4gICAgICByZXR1cm4gWycjMzE4MmJkJywgJyM2YmFlZDYnLCAnIzllY2FlMScsICcjYzZkYmVmJywgJyNlNjU1MGQnLCAnI2ZkOGQzYycsICcjZmRhZTZiJywgJyNmZGQwYTInLCAnIzMxYTM1NCcsICcjNzRjNDc2JywgJyNhMWQ5OWInLCAnI2M3ZTljMCcsICcjNzU2YmIxJywgJyM5ZTlhYzgnLCAnI2JjYmRkYycsICcjZGFkYWViJywgJyM2MzYzNjMnLCAnIzk2OTY5NicsICcjYmRiZGJkJywgJyNkOWQ5ZDknXTtcbiAgfVxuXG4gIC8vIFRPRE8gYWRkIG91ciBvd24gc2V0IG9mIGN1c3RvbSBvcmRpbmFsIGNvbG9yIHBhbGV0dGVcblxuICBpZiAocmFuZ2UgaW4gY29sb3JicmV3ZXIpIHtcbiAgICB2YXIgcGFsZXR0ZSA9IGNvbG9yYnJld2VyW3JhbmdlXTtcblxuICAgIC8vIGlmIGNhcmRpbmFsaXR5IHByZS1kZWZpbmVkLCB1c2UgaXQuXG4gICAgaWYgKGNhcmRpbmFsaXR5IGluIHBhbGV0dGUpIHJldHVybiBwYWxldHRlW2NhcmRpbmFsaXR5XTtcblxuICAgIC8vIGlmIG5vdCwgdXNlIHRoZSBoaWdoZXN0IGNhcmRpbmFsaXR5IG9uZSBmb3Igbm9taW5hbFxuICAgIGlmICh0eXBlID09PSBOKSB7XG4gICAgICByZXR1cm4gcGFsZXR0ZVtNYXRoLm1heC5hcHBseShudWxsLCB1dGlsLmtleXMocGFsZXR0ZSkpXTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UsIGludGVycG9sYXRlXG4gICAgdmFyIHBzID0gY2FyZGluYWxpdHkgPCAzID8gMyA6IE1hdGgubWF4LmFwcGx5KG51bGwsIHV0aWwua2V5cyhwYWxldHRlKSksXG4gICAgICBmcm9tID0gMCAsIHRvID0gcHMgLSAxO1xuICAgIC8vIEZJWE1FIGFkZCBjb25maWcgZm9yIGZyb20gLyB0b1xuXG4gICAgcmV0dXJuIHNjYWxlLmNvbG9yLmludGVycG9sYXRlKHBhbGV0dGVbcHNdW2Zyb21dLCBwYWxldHRlW3BzXVt0b10sIGNhcmRpbmFsaXR5KTtcbiAgfVxuXG4gIHJldHVybiByYW5nZTtcbn07XG5cbnNjYWxlLmNvbG9yLmludGVycG9sYXRlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGNhcmRpbmFsaXR5KSB7XG5cbiAgdmFyIGludGVycG9sYXRvciA9IGludGVycG9sYXRlKHN0YXJ0LCBlbmQpO1xuICByZXR1cm4gdXRpbC5yYW5nZShjYXJkaW5hbGl0eSkubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGludGVycG9sYXRvcihpKjEuMC8oY2FyZGluYWxpdHktMSkpOyB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIHZsZmllbGQgPSByZXF1aXJlKCcuLi9maWVsZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnQ7XG5cbi8vIGFkZHMgbmV3IHRyYW5zZm9ybXMgdGhhdCBwcm9kdWNlIHNvcnRlZCBmaWVsZHNcbmZ1bmN0aW9uIHNvcnQoZGF0YSwgZW5jb2RpbmcsIHN0YXRzLCBvcHQpIHtcbiAgLy8ganNoaW50IHVudXNlZDpmYWxzZVxuXG4gIHZhciBkYXRhc2V0TWFwcGluZyA9IHt9O1xuXG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICB2YXIgc29ydEJ5ID0gZW5jb2Rpbmcuc29ydChlbmNUeXBlLCBzdGF0cyk7XG4gICAgaWYgKHNvcnRCeS5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgZmllbGRzID0gc29ydEJ5Lm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb3A6IGQuYWdncmVnYXRlLFxuICAgICAgICAgIGZpZWxkOiB2bGZpZWxkLmZpZWxkUmVmKGQsIHtub2ZuOiB0cnVlLCBkYXRhOiAhZW5jb2RpbmcuX3ZlZ2EyfSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgYnlDbGF1c2UgPSBzb3J0QnkubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdmFyIHJldmVyc2UgPSAoZC5yZXZlcnNlID8gJy0nIDogJycpO1xuICAgICAgICByZXR1cm4gcmV2ZXJzZSArIHZsZmllbGQuZmllbGRSZWYoZCwge2RhdGE6ICFlbmNvZGluZy5fdmVnYTJ9KTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZGF0YU5hbWUgPSBzb3J0LmdldERhdGFOYW1lKGVuY1R5cGUpO1xuXG4gICAgICB2YXIgdHJhbnNmb3JtcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICdhZ2dyZWdhdGUnLFxuICAgICAgICAgIGdyb3VwYnk6IFsgZW5jb2RpbmcuZmllbGRSZWYoZW5jVHlwZSkgXSxcbiAgICAgICAgICBmaWVsZHM6IGZpZWxkc1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogJ3NvcnQnLFxuICAgICAgICAgIGJ5OiBieUNsYXVzZVxuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICBkYXRhLnB1c2goe1xuICAgICAgICBuYW1lOiBkYXRhTmFtZSxcbiAgICAgICAgc291cmNlOiBSQVcsXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3Jtc1xuICAgICAgfSk7XG5cbiAgICAgIGRhdGFzZXRNYXBwaW5nW2VuY1R5cGVdID0gZGF0YU5hbWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuc29ydC5nZXREYXRhTmFtZSA9IGZ1bmN0aW9uKGVuY1R5cGUpIHtcbiAgcmV0dXJuICdzb3J0ZWQtJyArIGVuY1R5cGU7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyICBtYXJrcyA9IHJlcXVpcmUoJy4vbWFya3MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja2luZztcblxuZnVuY3Rpb24gc3RhY2tpbmcoZGF0YSwgZW5jb2RpbmcsIG1kZWYpIHtcbiAgaWYgKCFtYXJrc1tlbmNvZGluZy5tYXJrdHlwZSgpXS5zdGFjaykgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIFRPRE86IGFkZCB8fCBlbmNvZGluZy5oYXMoTE9EKSBoZXJlIG9uY2UgTE9EIGlzIGltcGxlbWVudGVkXG4gIGlmICghZW5jb2RpbmcuaGFzKENPTE9SKSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBkaW09bnVsbCwgdmFsPW51bGwsIGlkeCA9bnVsbCxcbiAgICBpc1hNZWFzdXJlID0gZW5jb2RpbmcuaXNNZWFzdXJlKFgpLFxuICAgIGlzWU1lYXN1cmUgPSBlbmNvZGluZy5pc01lYXN1cmUoWSksXG4gICAgZmFjZXRzID0gZW5jb2RpbmcuZmFjZXRzKCk7XG5cbiAgaWYgKGlzWE1lYXN1cmUgJiYgIWlzWU1lYXN1cmUpIHtcbiAgICBkaW0gPSBZO1xuICAgIHZhbCA9IFg7XG4gICAgaWR4ID0gMDtcbiAgfSBlbHNlIGlmIChpc1lNZWFzdXJlICYmICFpc1hNZWFzdXJlKSB7XG4gICAgZGltID0gWDtcbiAgICB2YWwgPSBZO1xuICAgIGlkeCA9IDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7IC8vIG5vIHN0YWNrIGVuY29kaW5nXG4gIH1cblxuICAvLyBhZGQgdHJhbnNmb3JtIHRvIGNvbXB1dGUgc3VtcyBmb3Igc2NhbGVcbiAgdmFyIHN0YWNrZWQgPSB7XG4gICAgbmFtZTogU1RBQ0tFRCxcbiAgICBzb3VyY2U6IGVuY29kaW5nLmRhdGFUYWJsZSgpLFxuICAgIHRyYW5zZm9ybTogW3tcbiAgICAgIHR5cGU6ICdhZ2dyZWdhdGUnLFxuICAgICAgZ3JvdXBieTogW2VuY29kaW5nLmZpZWxkUmVmKGRpbSldLmNvbmNhdChmYWNldHMpLCAvLyBkaW0gYW5kIG90aGVyIGZhY2V0c1xuICAgICAgZmllbGRzOiBbe29wOiAnc3VtJywgZmllbGQ6IGVuY29kaW5nLmZpZWxkUmVmKHZhbCl9XSAvLyBUT0RPIGNoZWNrIGlmIGZpZWxkIHdpdGggYWdncmVnYXRlIGlzIGNvcnJlY3Q/XG4gICAgfV1cbiAgfTtcblxuICBpZiAoZmFjZXRzICYmIGZhY2V0cy5sZW5ndGggPiAwKSB7XG4gICAgc3RhY2tlZC50cmFuc2Zvcm0ucHVzaCh7IC8vY2FsY3VsYXRlIG1heCBmb3IgZWFjaCBmYWNldFxuICAgICAgdHlwZTogJ2FnZ3JlZ2F0ZScsXG4gICAgICBncm91cGJ5OiBmYWNldHMsXG4gICAgICBmaWVsZHM6IFt7XG4gICAgICAgIG9wOiAnbWF4JyxcbiAgICAgICAgZmllbGQ6IGVuY29kaW5nLmZpZWxkTmFtZSh2YWwsIHtmbjogJ3N1bSd9KVxuICAgICAgfV1cbiAgICB9KTtcbiAgfVxuXG4gIGRhdGEucHVzaChzdGFja2VkKTtcblxuICAvLyBhZGQgc3RhY2sgdHJhbnNmb3JtIHRvIG1hcmtcbiAgbWRlZi5mcm9tLnRyYW5zZm9ybSA9IFt7XG4gICAgdHlwZTogJ3N0YWNrJyxcbiAgICBwb2ludDogZW5jb2RpbmcuZmllbGRSZWYoZGltKSxcbiAgICBoZWlnaHQ6IGVuY29kaW5nLmZpZWxkUmVmKHZhbCksXG4gICAgb3V0cHV0OiB7eTE6IHZhbCwgeTA6IHZhbCArICcyJ31cbiAgfV07XG5cbiAgLy8gVE9ETzogVGhpcyBpcyBzdXBlciBoYWNrLWlzaCAtLSBjb25zb2xpZGF0ZSBpbnRvIG1vZHVsYXIgbWFyayBwcm9wZXJ0aWVzP1xuICBtZGVmLnByb3BlcnRpZXMudXBkYXRlW3ZhbF0gPSBtZGVmLnByb3BlcnRpZXMuZW50ZXJbdmFsXSA9IHtzY2FsZTogdmFsLCBmaWVsZDogdmFsfTtcbiAgbWRlZi5wcm9wZXJ0aWVzLnVwZGF0ZVt2YWwgKyAnMiddID0gbWRlZi5wcm9wZXJ0aWVzLmVudGVyW3ZhbCArICcyJ10gPSB7c2NhbGU6IHZhbCwgZmllbGQ6IHZhbCArICcyJ307XG5cbiAgcmV0dXJuIHZhbDsgLy9yZXR1cm4gc3RhY2sgZW5jb2Rpbmdcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgdmxmaWVsZCA9IHJlcXVpcmUoJy4uL2ZpZWxkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZW5jb2RpbmcsIHN0YXRzKSB7XG4gIHJldHVybiB7XG4gICAgb3BhY2l0eTogZXN0aW1hdGVPcGFjaXR5KGVuY29kaW5nLCBzdGF0cyksXG4gIH07XG59O1xuXG5mdW5jdGlvbiBlc3RpbWF0ZU9wYWNpdHkoZW5jb2Rpbmcsc3RhdHMpIHtcbiAgaWYgKCFzdGF0cykge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIG51bVBvaW50cyA9IDA7XG5cbiAgaWYgKGVuY29kaW5nLmlzQWdncmVnYXRlKCkpIHsgLy8gYWdncmVnYXRlIHBsb3RcbiAgICBudW1Qb2ludHMgPSAxO1xuXG4gICAgLy8gIGdldCBudW1iZXIgb2YgcG9pbnRzIGluIGVhY2ggXCJjZWxsXCJcbiAgICAvLyAgYnkgY2FsY3VsYXRpbmcgcHJvZHVjdCBvZiBjYXJkaW5hbGl0eVxuICAgIC8vICBmb3IgZWFjaCBub24gZmFjZXRpbmcgYW5kIG5vbi1vcmRpbmFsIFggLyBZIGZpZWxkc1xuICAgIC8vICBub3RlIHRoYXQgb3JkaW5hbCB4LHkgYXJlIG5vdCBpbmNsdWRlIHNpbmNlIHdlIGNhblxuICAgIC8vICBjb25zaWRlciB0aGF0IG9yZGluYWwgeCBhcmUgc3ViZGl2aWRpbmcgdGhlIGNlbGwgaW50byBzdWJjZWxscyBhbnl3YXlcbiAgICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBlbmNUeXBlKSB7XG5cbiAgICAgIGlmIChlbmNUeXBlICE9PSBST1cgJiYgZW5jVHlwZSAhPT0gQ09MICYmXG4gICAgICAgICAgISgoZW5jVHlwZSA9PT0gWCB8fCBlbmNUeXBlID09PSBZKSAmJlxuICAgICAgICAgIHZsZmllbGQuaXNPcmRpbmFsU2NhbGUoZmllbGQpKVxuICAgICAgICApIHtcbiAgICAgICAgbnVtUG9pbnRzICo9IGVuY29kaW5nLmNhcmRpbmFsaXR5KGVuY1R5cGUsIHN0YXRzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9IGVsc2UgeyAvLyByYXcgcGxvdFxuXG4gICAgLy8gVE9ETzogZXJyb3IgaGFuZGxpbmdcbiAgICBpZiAoIXN0YXRzWycqJ10pXG4gICAgICByZXR1cm4gMTtcblxuICAgIG51bVBvaW50cyA9IHN0YXRzWycqJ10ubWF4OyAgLy8gY291bnRcblxuICAgIC8vIHNtYWxsIG11bHRpcGxlcyBkaXZpZGUgbnVtYmVyIG9mIHBvaW50c1xuICAgIHZhciBudW1NdWx0aXBsZXMgPSAxO1xuICAgIGlmIChlbmNvZGluZy5oYXMoUk9XKSkge1xuICAgICAgbnVtTXVsdGlwbGVzICo9IGVuY29kaW5nLmNhcmRpbmFsaXR5KFJPVywgc3RhdHMpO1xuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcuaGFzKENPTCkpIHtcbiAgICAgIG51bU11bHRpcGxlcyAqPSBlbmNvZGluZy5jYXJkaW5hbGl0eShDT0wsIHN0YXRzKTtcbiAgICB9XG4gICAgbnVtUG9pbnRzIC89IG51bU11bHRpcGxlcztcbiAgfVxuXG4gIHZhciBvcGFjaXR5ID0gMDtcbiAgaWYgKG51bVBvaW50cyA8PSAyNSkge1xuICAgIG9wYWNpdHkgPSAxO1xuICB9IGVsc2UgaWYgKG51bVBvaW50cyA8IDIwMCkge1xuICAgIG9wYWNpdHkgPSAwLjg7XG4gIH0gZWxzZSBpZiAobnVtUG9pbnRzIDwgMTAwMCB8fCBlbmNvZGluZy5pcygndGljaycpKSB7XG4gICAgb3BhY2l0eSA9IDAuNztcbiAgfSBlbHNlIHtcbiAgICBvcGFjaXR5ID0gMC4zO1xuICB9XG5cbiAgcmV0dXJuIG9wYWNpdHk7XG59XG5cbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgZ3JvdXBkZWYgPSByZXF1aXJlKCcuL2dyb3VwJykuZGVmO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN1YmZhY2V0aW5nO1xuXG5mdW5jdGlvbiBzdWJmYWNldGluZyhncm91cCwgbWRlZiwgZGV0YWlscywgc3RhY2ssIGVuY29kaW5nKSB7XG4gIHZhciBtID0gZ3JvdXAubWFya3MsXG4gICAgZyA9IGdyb3VwZGVmKCdzdWJmYWNldCcsIHttYXJrczogbX0pO1xuXG4gIGdyb3VwLm1hcmtzID0gW2ddO1xuICBnLmZyb20gPSBtZGVmLmZyb207XG4gIGRlbGV0ZSBtZGVmLmZyb207XG5cbiAgLy9UT0RPIHRlc3QgTE9EIC0tIHdlIHNob3VsZCBzdXBwb3J0IHN0YWNrIC8gbGluZSB3aXRob3V0IGNvbG9yIChMT0QpIGZpZWxkXG4gIHZhciB0cmFucyA9IChnLmZyb20udHJhbnNmb3JtIHx8IChnLmZyb20udHJhbnNmb3JtID0gW10pKTtcbiAgdHJhbnMudW5zaGlmdCh7dHlwZTogJ2ZhY2V0Jywga2V5czogZGV0YWlsc30pO1xuXG4gIGlmIChzdGFjayAmJiBlbmNvZGluZy5oYXMoQ09MT1IpKSB7XG4gICAgdHJhbnMudW5zaGlmdCh7dHlwZTogJ3NvcnQnLCBieTogZW5jb2RpbmcuZmllbGRSZWYoQ09MT1IpfSk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIGQzX3RpbWVfZm9ybWF0ID0gcmVxdWlyZSgnZDMtdGltZS1mb3JtYXQnKTtcblxudmFyIHRpbWUgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG52YXIgTE9OR19EQVRFID0gbmV3IERhdGUoMjAxNCwgOCwgMTcpO1xuXG50aW1lLmNhcmRpbmFsaXR5ID0gZnVuY3Rpb24oZmllbGQsIHN0YXRzLCBmaWx0ZXJOdWxsLCB0eXBlKSB7XG4gIHZhciB0aW1lVW5pdCA9IGZpZWxkLnRpbWVVbml0O1xuICBzd2l0Y2ggKHRpbWVVbml0KSB7XG4gICAgY2FzZSAnc2Vjb25kcyc6IHJldHVybiA2MDtcbiAgICBjYXNlICdtaW51dGVzJzogcmV0dXJuIDYwO1xuICAgIGNhc2UgJ2hvdXJzJzogcmV0dXJuIDI0O1xuICAgIGNhc2UgJ2RheSc6IHJldHVybiA3O1xuICAgIGNhc2UgJ2RhdGUnOiByZXR1cm4gMzE7XG4gICAgY2FzZSAnbW9udGgnOiByZXR1cm4gMTI7XG4gICAgY2FzZSAneWVhcic6XG4gICAgICB2YXIgc3RhdCA9IHN0YXRzW2ZpZWxkLm5hbWVdLFxuICAgICAgICB5ZWFyc3RhdCA9IHN0YXRzWyd5ZWFyXycrZmllbGQubmFtZV07XG5cbiAgICAgIGlmICgheWVhcnN0YXQpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgICAgcmV0dXJuIHllYXJzdGF0LmRpc3RpbmN0IC1cbiAgICAgICAgKHN0YXQubnVsbHMgPiAwICYmIGZpbHRlck51bGxbdHlwZV0gPyAxIDogMCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbnRpbWUuZm9ybXVsYSA9IGZ1bmN0aW9uKHRpbWVVbml0LCBmaWVsZFJlZikge1xuICAvLyBUT0RPKGthbml0dyk6IGFkZCBmb3JtdWxhIHRvIG90aGVyIHRpbWUgZm9ybWF0XG4gIHZhciBmbiA9ICd1dGMnICsgdGltZVVuaXQ7XG4gIHJldHVybiBmbiArICcoJyArIGZpZWxkUmVmICsgJyknO1xufTtcblxudGltZS5tYXhMZW5ndGggPSBmdW5jdGlvbih0aW1lVW5pdCwgZW5jb2RpbmcpIHtcbiAgc3dpdGNoICh0aW1lVW5pdCkge1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdkYXRlJzpcbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgJ21vbnRoJzpcbiAgICBjYXNlICdkYXknOlxuICAgICAgdmFyIHJhbmdlID0gdGltZS5yYW5nZSh0aW1lVW5pdCwgZW5jb2RpbmcpO1xuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIC8vIHJldHVybiB0aGUgbG9uZ2VzdCBuYW1lIGluIHRoZSByYW5nZVxuICAgICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgcmFuZ2UubWFwKGZ1bmN0aW9uKHIpIHtyZXR1cm4gci5sZW5ndGg7fSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSAneWVhcic6XG4gICAgICByZXR1cm4gNDsgLy8nMTk5OCdcbiAgfVxuICAvLyBubyB0aW1lIHVuaXRcbiAgdmFyIHRpbWVGb3JtYXQgPSBlbmNvZGluZy5jb25maWcoJ3RpbWVGb3JtYXQnKTtcbiAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0LnV0Y0Zvcm1hdCh0aW1lRm9ybWF0KShMT05HX0RBVEUpLmxlbmd0aDtcbn07XG5cbnRpbWUucmFuZ2UgPSBmdW5jdGlvbih0aW1lVW5pdCwgZW5jb2RpbmcpIHtcbiAgdmFyIGxhYmVsTGVuZ3RoID0gZW5jb2RpbmcuY29uZmlnKCd0aW1lU2NhbGVMYWJlbExlbmd0aCcpLFxuICAgIHNjYWxlTGFiZWw7XG4gIHN3aXRjaCAodGltZVVuaXQpIHtcbiAgICBjYXNlICdkYXknOlxuICAgICAgc2NhbGVMYWJlbCA9IGVuY29kaW5nLmNvbmZpZygnZGF5U2NhbGVMYWJlbCcpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbW9udGgnOlxuICAgICAgc2NhbGVMYWJlbCA9IGVuY29kaW5nLmNvbmZpZygnbW9udGhTY2FsZUxhYmVsJyk7XG4gICAgICBicmVhaztcbiAgfVxuICBpZiAoc2NhbGVMYWJlbCkge1xuICAgIHJldHVybiBsYWJlbExlbmd0aCA/IHNjYWxlTGFiZWwubWFwKFxuICAgICAgICBmdW5jdGlvbihzKSB7IHJldHVybiBzLnN1YnN0cigwLCBsYWJlbExlbmd0aCk7fVxuICAgICAgKSA6IHNjYWxlTGFiZWw7XG4gIH1cbiAgcmV0dXJuO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSAge09iamVjdH0gZW5jb2RpbmdcbiAqIEByZXR1cm4ge0FycmF5fSAgc2NhbGVzIGZvciB0aW1lIHVuaXQgbmFtZXNcbiAqL1xudGltZS5zY2FsZXMgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB2YXIgc2NhbGVzID0gZW5jb2RpbmcucmVkdWNlKGZ1bmN0aW9uKHNjYWxlcywgZmllbGQpIHtcbiAgICB2YXIgdGltZVVuaXQgPSBmaWVsZC50aW1lVW5pdDtcbiAgICBpZiAoZmllbGQudHlwZSA9PT0gVCAmJiB0aW1lVW5pdCAmJiAhc2NhbGVzW3RpbWVVbml0XSkge1xuICAgICAgdmFyIHNjYWxlID0gdGltZS5zY2FsZS5kZWYoZmllbGQudGltZVVuaXQsIGVuY29kaW5nKTtcbiAgICAgIGlmIChzY2FsZSkgc2NhbGVzW3RpbWVVbml0XSA9IHNjYWxlO1xuICAgIH1cbiAgICByZXR1cm4gc2NhbGVzO1xuICB9LCB7fSk7XG5cbiAgcmV0dXJuIHV0aWwudmFscyhzY2FsZXMpO1xufTtcblxuXG50aW1lLnNjYWxlID0ge307XG5cbi8qKiBhcHBlbmQgY3VzdG9tIHRpbWUgc2NhbGVzIGZvciBheGlzIGxhYmVsICovXG50aW1lLnNjYWxlLmRlZiA9IGZ1bmN0aW9uKHRpbWVVbml0LCBlbmNvZGluZykge1xuICB2YXIgcmFuZ2UgPSB0aW1lLnJhbmdlKHRpbWVVbml0LCBlbmNvZGluZyk7XG5cbiAgaWYgKHJhbmdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6ICd0aW1lLScrdGltZVVuaXQsXG4gICAgICB0eXBlOiAnb3JkaW5hbCcsXG4gICAgICBkb21haW46IHRpbWUuc2NhbGUuZG9tYWluKHRpbWVVbml0KSxcbiAgICAgIHJhbmdlOiByYW5nZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG50aW1lLmlzT3JkaW5hbEZuID0gZnVuY3Rpb24odGltZVVuaXQpIHtcbiAgc3dpdGNoICh0aW1lVW5pdCkge1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2RhdGUnOlxuICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnRpbWUuc2NhbGUudHlwZSA9IGZ1bmN0aW9uKHRpbWVVbml0LCBuYW1lKSB7XG4gIGlmIChuYW1lID09PSBDT0xPUikge1xuICAgIHJldHVybiAnbGluZWFyJzsgLy8gdGltZSBoYXMgb3JkZXIsIHNvIHVzZSBpbnRlcnBvbGF0ZWQgb3JkaW5hbCBjb2xvciBzY2FsZS5cbiAgfVxuXG4gIHJldHVybiB0aW1lLmlzT3JkaW5hbEZuKHRpbWVVbml0KSB8fCBuYW1lID09PSBDT0wgfHwgbmFtZSA9PT0gUk9XID8gJ29yZGluYWwnIDogJ2xpbmVhcic7XG59O1xuXG50aW1lLnNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKHRpbWVVbml0LCBuYW1lKSB7XG4gIHZhciBpc0NvbG9yID0gbmFtZSA9PT0gQ09MT1I7XG4gIHN3aXRjaCAodGltZVVuaXQpIHtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdtaW51dGVzJzogcmV0dXJuIGlzQ29sb3IgPyBbMCw1OV0gOiB1dGlsLnJhbmdlKDAsIDYwKTtcbiAgICBjYXNlICdob3Vycyc6IHJldHVybiBpc0NvbG9yID8gWzAsMjNdIDogdXRpbC5yYW5nZSgwLCAyNCk7XG4gICAgY2FzZSAnZGF5JzogcmV0dXJuIGlzQ29sb3IgPyBbMCw2XSA6IHV0aWwucmFuZ2UoMCwgNyk7XG4gICAgY2FzZSAnZGF0ZSc6IHJldHVybiBpc0NvbG9yID8gWzEsMzFdIDogdXRpbC5yYW5nZSgxLCAzMik7XG4gICAgY2FzZSAnbW9udGgnOiByZXR1cm4gaXNDb2xvciA/IFswLDExXSA6IHV0aWwucmFuZ2UoMCwgMTIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqIHdoZXRoZXIgYSBwYXJ0aWN1bGFyIHRpbWUgZnVuY3Rpb24gaGFzIGN1c3RvbSBzY2FsZSBmb3IgbGFiZWxzIGltcGxlbWVudGVkIGluIHRpbWUuc2NhbGUgKi9cbnRpbWUuaGFzU2NhbGUgPSBmdW5jdGlvbih0aW1lVW5pdCkge1xuICBzd2l0Y2ggKHRpbWVVbml0KSB7XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdtb250aCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL2dsb2JhbHMnKTtcblxudmFyIGNvbnN0cyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmNvbnN0cy5lbmNvZGluZ1R5cGVzID0gW1gsIFksIFJPVywgQ09MLCBTSVpFLCBTSEFQRSwgQ09MT1IsIFRFWFQsIERFVEFJTF07XG5cbmNvbnN0cy5zaG9ydGhhbmQgPSB7XG4gIGRlbGltOiAgJ3wnLFxuICBhc3NpZ246ICc9JyxcbiAgdHlwZTogICAnLCcsXG4gIGZ1bmM6ICAgJ18nXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL2dsb2JhbHMnKTtcblxudmFyIHN0YXRzID0gcmVxdWlyZSgnZGF0YWxpYi9zcmMvc3RhdHMnKTtcblxudmFyIHZsZGF0YSA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKiBNYXBwaW5nIGZyb20gZGF0YWxpYidzIGluZmVycmVkIHR5cGUgdG8gVmVnYS1saXRlJ3MgdHlwZSAqL1xudmxkYXRhLnR5cGVzID0ge1xuICAnYm9vbGVhbic6IE4sXG4gICdudW1iZXInOiBRLFxuICAnaW50ZWdlcic6IFEsXG4gICdkYXRlJzogVCxcbiAgJ3N0cmluZyc6IE5cbn07XG5cbnZsZGF0YS5zdGF0cyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIHN1bW1hcnkgPSBzdGF0cy5zdW1tYXJ5KGRhdGEpO1xuXG4gIHJldHVybiBzdW1tYXJ5LnJlZHVjZShmdW5jdGlvbihzLCBwcm9maWxlKSB7XG4gICAgc1twcm9maWxlLmZpZWxkXSA9IHByb2ZpbGU7XG4gICAgcmV0dXJuIHM7XG4gIH0sIHtcbiAgICAnKic6IHtcbiAgICAgIG1heDogZGF0YS5sZW5ndGgsXG4gICAgICBtaW46IDBcbiAgICB9XG4gIH0pO1xufTsiLCIvLyB1dGlsaXR5IGZvciBlbmNcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29uc3RzID0gcmVxdWlyZSgnLi9jb25zdHMnKSxcbiAgYyA9IGNvbnN0cy5zaG9ydGhhbmQsXG4gIHZsZmllbGQgPSByZXF1aXJlKCcuL2ZpZWxkJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgc2NoZW1hID0gcmVxdWlyZSgnLi9zY2hlbWEvc2NoZW1hJyksXG4gIGVuY1R5cGVzID0gc2NoZW1hLmVuY1R5cGVzO1xuXG52YXIgdmxlbmMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG52bGVuYy5jb3VudFJldGluYWwgPSBmdW5jdGlvbihlbmMpIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgaWYgKGVuYy5jb2xvcikgY291bnQrKztcbiAgaWYgKGVuYy5zaXplKSBjb3VudCsrO1xuICBpZiAoZW5jLnNoYXBlKSBjb3VudCsrO1xuICByZXR1cm4gY291bnQ7XG59O1xuXG52bGVuYy5oYXMgPSBmdW5jdGlvbihlbmMsIGVuY1R5cGUpIHtcbiAgdmFyIGZpZWxkRGVmID0gZW5jICYmIGVuY1tlbmNUeXBlXTtcbiAgcmV0dXJuIGZpZWxkRGVmICYmIGZpZWxkRGVmLm5hbWU7XG59O1xuXG52bGVuYy5pc0FnZ3JlZ2F0ZSA9IGZ1bmN0aW9uKGVuYykge1xuICBmb3IgKHZhciBrIGluIGVuYykge1xuICAgIGlmICh2bGVuYy5oYXMoZW5jLCBrKSAmJiBlbmNba10uYWdncmVnYXRlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmxlbmMuZm9yRWFjaCA9IGZ1bmN0aW9uKGVuYywgZikge1xuICB2YXIgaSA9IDA7XG4gIGVuY1R5cGVzLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIGlmICh2bGVuYy5oYXMoZW5jLCBrKSkge1xuICAgICAgZihlbmNba10sIGssIGkrKyk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZsZW5jLm1hcCA9IGZ1bmN0aW9uKGVuYywgZikge1xuICB2YXIgYXJyID0gW107XG4gIGVuY1R5cGVzLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIGlmICh2bGVuYy5oYXMoZW5jLCBrKSkge1xuICAgICAgYXJyLnB1c2goZihlbmNba10sIGssIGVuYykpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhcnI7XG59O1xuXG52bGVuYy5yZWR1Y2UgPSBmdW5jdGlvbihlbmMsIGYsIGluaXQpIHtcbiAgdmFyIHIgPSBpbml0O1xuICBlbmNUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICBpZiAodmxlbmMuaGFzKGVuYywgaykpIHtcbiAgICAgIHIgPSBmKHIsIGVuY1trXSwgaywgIGVuYyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHI7XG59O1xuXG4vKlxuICogcmV0dXJuIGtleS12YWx1ZSBwYWlycyBvZiBmaWVsZCBuYW1lIGFuZCBsaXN0IG9mIGZpZWxkcyBvZiB0aGF0IGZpZWxkIG5hbWVcbiAqL1xudmxlbmMuZmllbGRzID0gZnVuY3Rpb24oZW5jKSB7XG4gIHJldHVybiB2bGVuYy5yZWR1Y2UoZW5jLCBmdW5jdGlvbiAobSwgZmllbGQpIHtcbiAgICB2YXIgZmllbGRMaXN0ID0gbVtmaWVsZC5uYW1lXSA9IG1bZmllbGQubmFtZV0gfHwgW10sXG4gICAgICBjb250YWluc1R5cGUgPSBmaWVsZExpc3QuY29udGFpbnNUeXBlID0gZmllbGRMaXN0LmNvbnRhaW5zVHlwZSB8fCB7fTtcblxuICAgIGlmIChmaWVsZExpc3QuaW5kZXhPZihmaWVsZCkgPT09IC0xKSB7XG4gICAgICBmaWVsZExpc3QucHVzaChmaWVsZCk7XG4gICAgICAvLyBhdWdtZW50IHRoZSBhcnJheSB3aXRoIGNvbnRhaW5zVHlwZS5RIC8gTyAvIE4gLyBUXG4gICAgICBjb250YWluc1R5cGVbZmllbGQudHlwZV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbTtcbiAgfSwge30pO1xufTtcblxudmxlbmMuc2hvcnRoYW5kID0gZnVuY3Rpb24oZW5jKSB7XG4gIHJldHVybiB2bGVuYy5tYXAoZW5jLCBmdW5jdGlvbihmaWVsZCwgZXQpIHtcbiAgICByZXR1cm4gZXQgKyBjLmFzc2lnbiArIHZsZmllbGQuc2hvcnRoYW5kKGZpZWxkKTtcbiAgfSkuam9pbihjLmRlbGltKTtcbn07XG5cbnZsZW5jLmZyb21TaG9ydGhhbmQgPSBmdW5jdGlvbihzaG9ydGhhbmQpIHtcbiAgdmFyIGVuYyA9IHV0aWwuaXNBcnJheShzaG9ydGhhbmQpID8gc2hvcnRoYW5kIDogc2hvcnRoYW5kLnNwbGl0KGMuZGVsaW0pO1xuICByZXR1cm4gZW5jLnJlZHVjZShmdW5jdGlvbihtLCBlKSB7XG4gICAgdmFyIHNwbGl0ID0gZS5zcGxpdChjLmFzc2lnbiksXG4gICAgICAgIGVuY3R5cGUgPSBzcGxpdFswXS50cmltKCksXG4gICAgICAgIGZpZWxkID0gc3BsaXRbMV07XG5cbiAgICBtW2VuY3R5cGVdID0gdmxmaWVsZC5mcm9tU2hvcnRoYW5kKGZpZWxkKTtcbiAgICByZXR1cm4gbTtcbiAgfSwge30pO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbi8vIHV0aWxpdHkgZm9yIGZpZWxkXG5cbnJlcXVpcmUoJy4vZ2xvYmFscycpO1xuXG52YXIgY29uc3RzID0gcmVxdWlyZSgnLi9jb25zdHMnKSxcbiAgYyA9IGNvbnN0cy5zaG9ydGhhbmQsXG4gIHRpbWUgPSByZXF1aXJlKCcuL2NvbXBpbGVyL3RpbWUnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICBzY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYS9zY2hlbWEnKTtcblxudmFyIHZsZmllbGQgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSBmaWVsZFxuICogQHBhcmFtIG9wdFxuICogICBvcHQubm9mbiAtLSBleGNsdWRlIGJpbiwgYWdncmVnYXRlLCB0aW1lVW5pdFxuICogICBvcHQuZGF0YSAtIGluY2x1ZGUgJ2RhdGEuJ1xuICogICBvcHQuZCAtIGluY2x1ZGUgJ2QuJ1xuICogICBvcHQuZm4gLSByZXBsYWNlIGZuIHdpdGggY3VzdG9tIGZ1bmN0aW9uIHByZWZpeFxuICogICBvcHQucHJlZm4gLSBwcmVwZW5kIGZuIHdpdGggY3VzdG9tIGZ1bmN0aW9uIHByZWZpeFxuXG4gKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xudmxmaWVsZC5maWVsZFJlZiA9IGZ1bmN0aW9uKGZpZWxkLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gIHZhciBmID0gKG9wdC5kID8gJ2QuJyA6ICcnKSArXG4gICAgICAgICAgKG9wdC5kYXRhID8gJ2RhdGEuJyA6ICcnKSArXG4gICAgICAgICAgKG9wdC5wcmVmbiB8fCAnJyksXG4gICAgbm9mbiA9IG9wdC5ub2ZuIHx8IG9wdC5mbixcbiAgICBuYW1lID0gZmllbGQubmFtZTtcblxuICBpZiAodmxmaWVsZC5pc0NvdW50KGZpZWxkKSkge1xuICAgIHJldHVybiBmICsgJ2NvdW50JztcbiAgfSBlbHNlIGlmICghbm9mbiAmJiBmaWVsZC5iaW4pIHtcbiAgICByZXR1cm4gZiArICdiaW5fJyArIG5hbWU7XG4gIH0gZWxzZSBpZiAoIW5vZm4gJiYgZmllbGQuYWdncmVnYXRlKSB7XG4gICAgcmV0dXJuIGYgKyBmaWVsZC5hZ2dyZWdhdGUgKyAnXycgKyBuYW1lO1xuICB9IGVsc2UgaWYgKCFub2ZuICYmIGZpZWxkLnRpbWVVbml0KSB7XG4gICAgcmV0dXJuIGYgKyBmaWVsZC50aW1lVW5pdCArICdfJyArIG5hbWU7XG4gIH0gZWxzZSBpZiAob3B0LmZuKSB7XG4gICAgcmV0dXJuIGYgKyBvcHQuZm4gKyAnXycgKyBuYW1lO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmICsgbmFtZTtcbiAgfVxufTtcblxudmxmaWVsZC5zaG9ydGhhbmQgPSBmdW5jdGlvbihmKSB7XG4gIHZhciBjID0gY29uc3RzLnNob3J0aGFuZDtcbiAgcmV0dXJuIChmLmFnZ3JlZ2F0ZSA/IGYuYWdncmVnYXRlICsgYy5mdW5jIDogJycpICtcbiAgICAoZi50aW1lVW5pdCA/IGYudGltZVVuaXQgKyBjLmZ1bmMgOiAnJykgK1xuICAgIChmLmJpbiA/ICdiaW4nICsgYy5mdW5jIDogJycpICtcbiAgICAoZi5uYW1lIHx8ICcnKSArIGMudHlwZSArIGYudHlwZTtcbn07XG5cbnZsZmllbGQuc2hvcnRoYW5kcyA9IGZ1bmN0aW9uKGZpZWxkcywgZGVsaW0pIHtcbiAgZGVsaW0gPSBkZWxpbSB8fCBjLmRlbGltO1xuICByZXR1cm4gZmllbGRzLm1hcCh2bGZpZWxkLnNob3J0aGFuZCkuam9pbihkZWxpbSk7XG59O1xuXG52bGZpZWxkLmZyb21TaG9ydGhhbmQgPSBmdW5jdGlvbihzaG9ydGhhbmQpIHtcbiAgdmFyIHNwbGl0ID0gc2hvcnRoYW5kLnNwbGl0KGMudHlwZSksIGk7XG4gIHZhciBvID0ge1xuICAgIG5hbWU6IHNwbGl0WzBdLnRyaW0oKSxcbiAgICB0eXBlOiBzcGxpdFsxXS50cmltKClcbiAgfTtcblxuICAvLyBjaGVjayBhZ2dyZWdhdGUgdHlwZVxuICBmb3IgKGkgaW4gc2NoZW1hLmFnZ3JlZ2F0ZS5lbnVtKSB7XG4gICAgdmFyIGEgPSBzY2hlbWEuYWdncmVnYXRlLmVudW1baV07XG4gICAgaWYgKG8ubmFtZS5pbmRleE9mKGEgKyAnXycpID09PSAwKSB7XG4gICAgICBvLm5hbWUgPSBvLm5hbWUuc3Vic3RyKGEubGVuZ3RoICsgMSk7XG4gICAgICBpZiAoYSA9PSAnY291bnQnICYmIG8ubmFtZS5sZW5ndGggPT09IDApIG8ubmFtZSA9ICcqJztcbiAgICAgIG8uYWdncmVnYXRlID0gYTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIHRpbWUgdGltZVVuaXRcbiAgZm9yIChpIGluIHNjaGVtYS50aW1lZm5zKSB7XG4gICAgdmFyIHR1ID0gc2NoZW1hLnRpbWVmbnNbaV07XG4gICAgaWYgKG8ubmFtZSAmJiBvLm5hbWUuaW5kZXhPZih0dSArICdfJykgPT09IDApIHtcbiAgICAgIG8ubmFtZSA9IG8ubmFtZS5zdWJzdHIoby5sZW5ndGggKyAxKTtcbiAgICAgIG8udGltZVVuaXQgPSB0dTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGJpblxuICBpZiAoby5uYW1lICYmIG8ubmFtZS5pbmRleE9mKCdiaW5fJykgPT09IDApIHtcbiAgICBvLm5hbWUgPSBvLm5hbWUuc3Vic3RyKDQpO1xuICAgIG8uYmluID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBvO1xufTtcblxudmFyIGlzVHlwZSA9IHZsZmllbGQuaXNUeXBlID0gZnVuY3Rpb24gKGZpZWxkRGVmLCB0eXBlKSB7XG4gIHJldHVybiBmaWVsZERlZi50eXBlID09PSB0eXBlO1xufTtcblxudmFyIGlzVHlwZXMgPSB2bGZpZWxkLmlzVHlwZXMgPSBmdW5jdGlvbiAoZmllbGREZWYsIHR5cGVzKSB7XG4gIGZvciAodmFyIHQ9MDsgdDx0eXBlcy5sZW5ndGg7IHQrKykge1xuICAgIGlmKGZpZWxkRGVmLnR5cGUgPT09IHR5cGVzW3RdKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKlxuICogTW9zdCBmaWVsZHMgdGhhdCB1c2Ugb3JkaW5hbCBzY2FsZSBhcmUgZGltZW5zaW9ucy5cbiAqIEhvd2V2ZXIsIFlFQVIoVCksIFlFQVJNT05USChUKSB1c2UgdGltZSBzY2FsZSwgbm90IG9yZGluYWwgYnV0IGFyZSBkaW1lbnNpb25zIHRvby5cbiAqL1xudmxmaWVsZC5pc09yZGluYWxTY2FsZSA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiAgaXNUeXBlcyhmaWVsZCwgW04sIE9dKSB8fCBmaWVsZC5iaW4gfHxcbiAgICAoIGlzVHlwZShmaWVsZCwgVCkgJiYgZmllbGQudGltZVVuaXQgJiYgdGltZS5pc09yZGluYWxGbihmaWVsZC50aW1lVW5pdCkgKTtcbn07XG5cbmZ1bmN0aW9uIGlzRGltZW5zaW9uKGZpZWxkKSB7XG4gIHJldHVybiAgaXNUeXBlcyhmaWVsZCwgW04sIE9dKSB8fCAhIWZpZWxkLmJpbiB8fFxuICAgICggaXNUeXBlKGZpZWxkLCBUKSAmJiAhIWZpZWxkLnRpbWVVbml0ICk7XG59XG5cbi8qKlxuICogRm9yIGVuY29kaW5nLCB1c2UgZW5jb2RpbmcuaXNEaW1lbnNpb24oKSB0byBhdm9pZCBjb25mdXNpb24uXG4gKiBPciB1c2UgRW5jb2RpbmcuaXNUeXBlIGlmIHlvdXIgZmllbGQgaXMgZnJvbSBFbmNvZGluZyAoYW5kIHRodXMgaGF2ZSBudW1lcmljIGRhdGEgdHlwZSkuXG4gKiBvdGhlcndpc2UsIGRvIG5vdCBzcGVjaWZpYyBpc1R5cGUgc28gd2UgY2FuIHVzZSB0aGUgZGVmYXVsdCBpc1R5cGVOYW1lIGhlcmUuXG4gKi9cbnZsZmllbGQuaXNEaW1lbnNpb24gPSBmdW5jdGlvbihmaWVsZCkge1xuICByZXR1cm4gZmllbGQgJiYgaXNEaW1lbnNpb24oZmllbGQpO1xufTtcblxudmxmaWVsZC5pc01lYXN1cmUgPSBmdW5jdGlvbihmaWVsZCkge1xuICByZXR1cm4gZmllbGQgJiYgIWlzRGltZW5zaW9uKGZpZWxkKTtcbn07XG5cbnZsZmllbGQuY291bnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtuYW1lOicqJywgYWdncmVnYXRlOiAnY291bnQnLCB0eXBlOiBRLCBkaXNwbGF5TmFtZTogdmxmaWVsZC5jb3VudC5kaXNwbGF5TmFtZX07XG59O1xuXG52bGZpZWxkLmNvdW50LmRpc3BsYXlOYW1lID0gJ051bWJlciBvZiBSZWNvcmRzJztcblxudmxmaWVsZC5pc0NvdW50ID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuIGZpZWxkLmFnZ3JlZ2F0ZSA9PT0gJ2NvdW50Jztcbn07XG5cbi8qKlxuICogRm9yIGVuY29kaW5nLCB1c2UgZW5jb2RpbmcuY2FyZGluYWxpdHkoKSB0byBhdm9pZCBjb25mdXNpb24uICBPciB1c2UgRW5jb2RpbmcuaXNUeXBlIGlmIHlvdXIgZmllbGQgaXMgZnJvbSBFbmNvZGluZyAoYW5kIHRodXMgaGF2ZSBudW1lcmljIGRhdGEgdHlwZSkuXG4gKiBvdGhlcndpc2UsIGRvIG5vdCBzcGVjaWZpYyBpc1R5cGUgc28gd2UgY2FuIHVzZSB0aGUgZGVmYXVsdCBpc1R5cGVOYW1lIGhlcmUuXG4gKi9cbnZsZmllbGQuY2FyZGluYWxpdHkgPSBmdW5jdGlvbihmaWVsZCwgc3RhdHMsIGZpbHRlck51bGwpIHtcbiAgLy8gRklYTUUgbmVlZCB0byB0YWtlIGZpbHRlciBpbnRvIGFjY291bnRcblxuICB2YXIgc3RhdCA9IHN0YXRzW2ZpZWxkLm5hbWVdO1xuICB2YXIgdHlwZSA9IGZpZWxkLnR5cGU7XG5cbiAgZmlsdGVyTnVsbCA9IGZpbHRlck51bGwgfHwge307XG5cbiAgaWYgKGZpZWxkLmJpbikge1xuICAgIHZhciBiaW5zID0gdXRpbC5nZXRiaW5zKHN0YXQsIGZpZWxkLmJpbi5tYXhiaW5zIHx8IHNjaGVtYS5NQVhCSU5TX0RFRkFVTFQpO1xuICAgIHJldHVybiAoYmlucy5zdG9wIC0gYmlucy5zdGFydCkgLyBiaW5zLnN0ZXA7XG4gIH1cbiAgaWYgKGlzVHlwZShmaWVsZCwgVCkpIHtcbiAgICB2YXIgY2FyZGluYWxpdHkgPSB0aW1lLmNhcmRpbmFsaXR5KGZpZWxkLCBzdGF0cywgZmlsdGVyTnVsbCwgdHlwZSk7XG4gICAgaWYoY2FyZGluYWxpdHkgIT09IG51bGwpIHJldHVybiBjYXJkaW5hbGl0eTtcbiAgICAvL290aGVyd2lzZSB1c2UgY2FsY3VsYXRpb24gYmVsb3dcbiAgfVxuICBpZiAoZmllbGQuYWdncmVnYXRlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvLyByZW1vdmUgbnVsbFxuICByZXR1cm4gc3RhdC5kaXN0aW5jdCAtXG4gICAgKHN0YXQubnVsbHMgPiAwICYmIGZpbHRlck51bGxbdHlwZV0gPyAxIDogMCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBkZWNsYXJlIGdsb2JhbCBjb25zdGFudFxudmFyIGcgPSBnbG9iYWwgfHwgd2luZG93O1xuXG5nLkFHR1JFR0FURSA9ICdhZ2dyZWdhdGUnO1xuZy5SQVcgPSAncmF3JztcbmcuU1RBQ0tFRCA9ICdzdGFja2VkJztcbmcuSU5ERVggPSAnaW5kZXgnO1xuXG5nLlggPSAneCc7XG5nLlkgPSAneSc7XG5nLlJPVyA9ICdyb3cnO1xuZy5DT0wgPSAnY29sJztcbmcuU0laRSA9ICdzaXplJztcbmcuU0hBUEUgPSAnc2hhcGUnO1xuZy5DT0xPUiA9ICdjb2xvcic7XG5nLlRFWFQgPSAndGV4dCc7XG5nLkRFVEFJTCA9ICdkZXRhaWwnO1xuXG5nLk4gPSAnTic7XG5nLk8gPSAnTyc7XG5nLlEgPSAnUSc7XG5nLlQgPSAnVCc7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIFRPRE8oa2FuaXR3KTogY2hhdCB3aXRoIFZlZ2EgdGVhbSBhbmQgcG9zc2libHkgbW92ZSB0aGlzIHRvIHZlZ2EtbG9nZ2luZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgLy8gQm9ycm93ZWQgc29tZSBpZGVhcyBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE1NjUzMjYwLzg2Njk4OVxuICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL3BhdGlrL2NvbnNvbGUubG9nLXdyYXBwZXIvYmxvYi9tYXN0ZXIvY29uc29sZWxvZy5qc1xuICB2YXIgTUVUSE9EUyA9IFsnZXJyb3InLCAnaW5mbycsICdkZWJ1ZycsICd3YXJuJywgJ2xvZyddO1xuXG4gIHJldHVybiBNRVRIT0RTLnJlZHVjZShmdW5jdGlvbihsb2dnZXIsIGZuKSB7XG4gICAgdmFyIGNmbiA9IGNvbnNvbGVbZm5dID8gZm4gOiAnbG9nJztcbiAgICBpZiAoY29uc29sZVtjZm5dLmJpbmQgPT09ICd1bmRlZmluZWQnKSB7IC8vIElFIDwgMTBcbiAgICAgICAgbG9nZ2VyW2ZuXSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwoY29uc29sZVtjZm5dLCBjb25zb2xlLCBwcmVmaXgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG9nZ2VyW2ZuXSA9IGNvbnNvbGVbY2ZuXS5iaW5kKGNvbnNvbGUsIHByZWZpeCk7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXI7XG4gIH0sIHt9KTtcbn07IiwiLy8gUGFja2FnZSBvZiBkZWZpbmluZyBWZWdhLWxpdGUgU3BlY2lmaWNhdGlvbidzIGpzb24gc2NoZW1hXG4ndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIHNjaGVtYSA9IG1vZHVsZS5leHBvcnRzID0ge30sXG4gIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIHRvTWFwID0gdXRpbC50b01hcCxcbiAgY29sb3JicmV3ZXIgPSByZXF1aXJlKCdjb2xvcmJyZXdlcicpO1xuXG5zY2hlbWEudXRpbCA9IHJlcXVpcmUoJy4vc2NoZW1hdXRpbCcpO1xuXG5zY2hlbWEubWFya3R5cGUgPSB7XG4gIHR5cGU6ICdzdHJpbmcnLFxuICBlbnVtOiBbJ3BvaW50JywgJ3RpY2snLCAnYmFyJywgJ2xpbmUnLCAnYXJlYScsICdjaXJjbGUnLCAnc3F1YXJlJywgJ3RleHQnXVxufTtcblxuc2NoZW1hLmFnZ3JlZ2F0ZSA9IHtcbiAgdHlwZTogJ3N0cmluZycsXG4gIGVudW06IFsnYXZnJywgJ3N1bScsICdtZWRpYW4nLCAnbWluJywgJ21heCcsICdjb3VudCddLFxuICBzdXBwb3J0ZWRFbnVtczoge1xuICAgIFE6IFsnYXZnJywgJ21lZGlhbicsICdzdW0nLCAnbWluJywgJ21heCcsICdjb3VudCddLFxuICAgIE86IFsnbWVkaWFuJywnbWluJywnbWF4J10sXG4gICAgTjogW10sXG4gICAgVDogWydhdmcnLCAnbWVkaWFuJywgJ21pbicsICdtYXgnXSxcbiAgICAnJzogWydjb3VudCddXG4gIH0sXG4gIHN1cHBvcnRlZFR5cGVzOiB0b01hcChbUSwgTiwgTywgVCwgJyddKVxufTtcblxuc2NoZW1hLmdldFN1cHBvcnRlZFJvbGUgPSBmdW5jdGlvbihlbmNUeXBlKSB7XG4gIHJldHVybiBzY2hlbWEuc2NoZW1hLnByb3BlcnRpZXMuZW5jb2RpbmcucHJvcGVydGllc1tlbmNUeXBlXS5zdXBwb3J0ZWRSb2xlO1xufTtcblxuc2NoZW1hLnRpbWVVbml0cyA9IFsneWVhcicsICdtb250aCcsICdkYXknLCAnZGF0ZScsICdob3VycycsICdtaW51dGVzJywgJ3NlY29uZHMnXTtcblxuc2NoZW1hLmRlZmF1bHRUaW1lRm4gPSAnbW9udGgnO1xuXG5zY2hlbWEudGltZVVuaXQgPSB7XG4gIHR5cGU6ICdzdHJpbmcnLFxuICBlbnVtOiBzY2hlbWEudGltZVVuaXRzLFxuICBzdXBwb3J0ZWRUeXBlczogdG9NYXAoW1RdKVxufTtcblxuc2NoZW1hLnNjYWxlX3R5cGUgPSB7XG4gIHR5cGU6ICdzdHJpbmcnLFxuICAvLyBUT0RPKGthbml0dykgcmVhZCB2ZWdhJ3Mgc2NoZW1hIGhlcmUsIGFkZCBkZXNjcmlwdGlvblxuICBlbnVtOiBbJ2xpbmVhcicsICdsb2cnLCAncG93JywgJ3NxcnQnLCAncXVhbnRpbGUnXSxcbiAgZGVmYXVsdDogJ2xpbmVhcicsXG4gIHN1cHBvcnRlZFR5cGVzOiB0b01hcChbUV0pXG59O1xuXG5zY2hlbWEuZmllbGQgPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgbmFtZToge1xuICAgICAgdHlwZTogJ3N0cmluZydcbiAgICB9XG4gIH1cbn07XG5cbnZhciBjbG9uZSA9IHV0aWwuZHVwbGljYXRlO1xudmFyIG1lcmdlID0gc2NoZW1hLnV0aWwubWVyZ2U7XG5cbnNjaGVtYS5NQVhCSU5TX0RFRkFVTFQgPSAxNTtcblxudmFyIGJpbiA9IHtcbiAgdHlwZTogWydib29sZWFuJywgJ29iamVjdCddLFxuICBkZWZhdWx0OiBmYWxzZSxcbiAgcHJvcGVydGllczoge1xuICAgIG1heGJpbnM6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IHNjaGVtYS5NQVhCSU5TX0RFRkFVTFQsXG4gICAgICBtaW5pbXVtOiAyLFxuICAgICAgZGVzY3JpcHRpb246ICdNYXhpbXVtIG51bWJlciBvZiBiaW5zLidcbiAgICB9XG4gIH0sXG4gIHN1cHBvcnRlZFR5cGVzOiB0b01hcChbUV0pIC8vIFRPRE86IGFkZCBPIGFmdGVyIGZpbmlzaGluZyAjODFcbn07XG5cbnZhciB0eXBpY2FsRmllbGQgPSBtZXJnZShjbG9uZShzY2hlbWEuZmllbGQpLCB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdHlwZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbTiwgTywgUSwgVF1cbiAgICB9LFxuICAgIGFnZ3JlZ2F0ZTogc2NoZW1hLmFnZ3JlZ2F0ZSxcbiAgICB0aW1lVW5pdDogc2NoZW1hLnRpbWVVbml0LFxuICAgIGJpbjogYmluLFxuICAgIHNjYWxlOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgdHlwZTogc2NoZW1hLnNjYWxlX3R5cGUsXG4gICAgICAgIHJldmVyc2U6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgc3VwcG9ydGVkVHlwZXM6IHRvTWFwKFtRLCBUXSlcbiAgICAgICAgfSxcbiAgICAgICAgemVybzoge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0luY2x1ZGUgemVybycsXG4gICAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgICBzdXBwb3J0ZWRUeXBlczogdG9NYXAoW1EsIFRdKVxuICAgICAgICB9LFxuICAgICAgICBuaWNlOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZW51bTogWydzZWNvbmQnLCAnbWludXRlJywgJ2hvdXInLCAnZGF5JywgJ3dlZWsnLCAnbW9udGgnLCAneWVhciddLFxuICAgICAgICAgIHN1cHBvcnRlZFR5cGVzOiB0b01hcChbVF0pXG4gICAgICAgIH0sXG4gICAgICAgIHVzZVJhd0RvbWFpbjoge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdVc2UgdGhlIHJhdyBkYXRhIHJhbmdlIGFzIHNjYWxlIGRvbWFpbiBpbnN0ZWFkIG9mICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAnYWdncmVnYXRlZCBkYXRhIGZvciBhZ2dyZWdhdGUgYXhpcy4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICdUaGlzIG9wdGlvbiBkb2VzIG5vdCB3b3JrIHdpdGggc3VtIG9yIGNvdW50IGFnZ3JlZ2F0ZScgK1xuICAgICAgICAgICAgICAgICAgICAgICAnYXMgdGhleSBtaWdodCBoYXZlIGEgc3Vic3RhbnRpYWxseSBsYXJnZXIgc2NhbGUgcmFuZ2UuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICdCeSBkZWZhdWx0LCB1c2UgdmFsdWUgZnJvbSBjb25maWcudXNlUmF3RG9tYWluLidcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbnZhciBvbmx5T3JkaW5hbEZpZWxkID0gbWVyZ2UoY2xvbmUoc2NoZW1hLmZpZWxkKSwge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkUm9sZToge1xuICAgIGRpbWVuc2lvbjogdHJ1ZVxuICB9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdHlwZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbTiwgTywgUSwgVF0gLy8gb3JkaW5hbC1vbmx5IGZpZWxkIHN1cHBvcnRzIFEgd2hlbiBiaW4gaXMgYXBwbGllZCBhbmQgVCB3aGVuIHRpbWUgdW5pdCBpcyBhcHBsaWVkLlxuICAgIH0sXG4gICAgdGltZVVuaXQ6IHNjaGVtYS50aW1lVW5pdCxcbiAgICBiaW46IGJpbixcbiAgICBhZ2dyZWdhdGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogWydjb3VudCddLFxuICAgICAgc3VwcG9ydGVkVHlwZXM6IHRvTWFwKFtOLCBPXSkgLy8gRklYTUUgdGhpcyBsb29rcyB3ZWlyZCB0byBtZVxuICAgIH1cbiAgfVxufSk7XG5cbnZhciBheGlzTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgdGljazogdHJ1ZSwgYmFyOiB0cnVlLCBsaW5lOiB0cnVlLCBhcmVhOiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZX0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICBheGlzOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQSBmbGFnIGluZGljYXRlIGlmIGdyaWRsaW5lcyBzaG91bGQgYmUgY3JlYXRlZCBpbiBhZGRpdGlvbiB0byB0aWNrcy4nXG4gICAgICAgIH0sXG4gICAgICAgIGxheWVyOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogJ2JhY2snLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQSBzdHJpbmcgaW5kaWNhdGluZyBpZiB0aGUgYXhpcyAoYW5kIGFueSBncmlkbGluZXMpIHNob3VsZCBiZSBwbGFjZWQgYWJvdmUgb3IgYmVsb3cgdGhlIGRhdGEgbWFya3MuJ1xuICAgICAgICB9LFxuICAgICAgICBvcmllbnQ6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgZW51bTogWyd0b3AnLCAncmlnaHQnLCAnbGVmdCcsICdib3R0b20nXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RoZSBvcmllbnRhdGlvbiBvZiB0aGUgYXhpcy4gT25lIG9mIHRvcCwgYm90dG9tLCBsZWZ0IG9yIHJpZ2h0LiBUaGUgb3JpZW50YXRpb24gY2FuIGJlIHVzZWQgdG8gZnVydGhlciBzcGVjaWFsaXplIHRoZSBheGlzIHR5cGUgKGUuZy4sIGEgeSBheGlzIG9yaWVudGVkIGZvciB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgY2hhcnQpLidcbiAgICAgICAgfSxcbiAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgZGVmYXVsdDogNSxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQSBkZXNpcmVkIG51bWJlciBvZiB0aWNrcywgZm9yIGF4ZXMgdmlzdWFsaXppbmcgcXVhbnRpdGF0aXZlIHNjYWxlcy4gVGhlIHJlc3VsdGluZyBudW1iZXIgbWF5IGJlIGRpZmZlcmVudCBzbyB0aGF0IHZhbHVlcyBhcmUgXCJuaWNlXCIgKG11bHRpcGxlcyBvZiAyLCA1LCAxMCkgYW5kIGxpZSB3aXRoaW4gdGhlIHVuZGVybHlpbmcgc2NhbGVcXCdzIHJhbmdlLidcbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdBIHRpdGxlIGZvciB0aGUgYXhpcy4gKFNob3dzIGZpZWxkIG5hbWUgYW5kIGl0cyBmdW5jdGlvbiBieSBkZWZhdWx0LiknXG4gICAgICAgIH0sXG4gICAgICAgIHRpdGxlTWF4TGVuZ3RoOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnTWF4IGxlbmd0aCBmb3IgYXhpcyB0aXRsZSBpZiB0aGUgdGl0bGUgaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgZnJvbSB0aGUgZmllbGRcXCdzIGRlc2NyaXB0aW9uJ1xuICAgICAgICB9LFxuICAgICAgICB0aXRsZU9mZnNldDoge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsICAvLyBhdXRvXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdBIHRpdGxlIG9mZnNldCB2YWx1ZSBmb3IgdGhlIGF4aXMuJ1xuICAgICAgICB9LFxuICAgICAgICBmb3JtYXQ6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsICAvLyBhdXRvXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdUaGUgZm9ybWF0dGluZyBwYXR0ZXJuIGZvciBheGlzIGxhYmVscy4gJytcbiAgICAgICAgICAgICAgICAgICAgICAgJ0lmIG5vdCB1bmRlZmluZWQsIHRoaXMgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAnc21hbGwvbGFyZ2VOdW1iZXJGb3JtYXQgYW5kIHRoZSBtYXggdmFsdWUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICdvZiB0aGUgZmllbGQuJ1xuICAgICAgICB9LFxuICAgICAgICBtYXhMYWJlbExlbmd0aDoge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBkZWZhdWx0OiAyNSxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVHJ1bmNhdGUgbGFiZWxzIHRoYXQgYXJlIHRvbyBsb25nLidcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWxBbmdsZToge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsIC8vIGF1dG9cbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIG1heGltdW06IDM2MCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0FuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSBsYWJlbHMuIFNldCB0byAwIHRvIGZvcmNlIGhvcml6b250YWwuJ1xuICAgICAgICB9LFxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHNvcnRNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBzb3J0OiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgZGVmYXVsdDogW10sXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgc3VwcG9ydGVkVHlwZXM6IHRvTWFwKFtOLCBPXSksXG4gICAgICAgIHJlcXVpcmVkOiBbJ25hbWUnLCAnYWdncmVnYXRlJ10sXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYWdncmVnYXRlOiB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGVudW06IFsnYXZnJywgJ3N1bScsICdtaW4nLCAnbWF4JywgJ2NvdW50J11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHJldmVyc2U6IHtcbiAgICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgYmFuZE1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIGJhbmQ6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBkZWZhdWx0OiAxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBsZWdlbmRNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBsZWdlbmQ6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgZGVzY3JpcHRpb246ICdQcm9wZXJ0aWVzIG9mIGEgbGVnZW5kLicsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQSB0aXRsZSBmb3IgdGhlIGxlZ2VuZC4gKFNob3dzIGZpZWxkIG5hbWUgYW5kIGl0cyBmdW5jdGlvbiBieSBkZWZhdWx0LiknXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciB0ZXh0TWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHsndGV4dCc6IHRydWV9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgYWxpZ246IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogJ3JpZ2h0J1xuICAgIH0sXG4gICAgYmFzZWxpbmU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogJ21pZGRsZSdcbiAgICB9LFxuICAgIGNvbG9yOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJvbGU6ICdjb2xvcicsXG4gICAgICBkZWZhdWx0OiAnIzAwMDAwMCdcbiAgICB9LFxuICAgIG1hcmdpbjoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogNCxcbiAgICAgIG1pbmltdW06IDBcbiAgICB9LFxuICAgIHBsYWNlaG9sZGVyOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlZmF1bHQ6ICdBYmMnXG4gICAgfSxcbiAgICBmb250OiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgd2VpZ2h0OiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZW51bTogWydub3JtYWwnLCAnYm9sZCddLFxuICAgICAgICAgIGRlZmF1bHQ6ICdub3JtYWwnXG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgZGVmYXVsdDogMTAsXG4gICAgICAgICAgbWluaW11bTogMFxuICAgICAgICB9LFxuICAgICAgICBmYW1pbHk6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiAnSGVsdmV0aWNhIE5ldWUnXG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogJ25vcm1hbCcsXG4gICAgICAgICAgZW51bTogWydub3JtYWwnLCAnaXRhbGljJ11cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZm9ybWF0OiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCwgIC8vIGF1dG9cbiAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIGZvcm1hdHRpbmcgcGF0dGVybiBmb3IgdGV4dCB2YWx1ZS4gJytcbiAgICAgICAgICAgICAgICAgICAnSWYgbm90IHVuZGVmaW5lZCwgdGhpcyB3aWxsIGJlIGRldGVybWluZWQgYnkgJyArXG4gICAgICAgICAgICAgICAgICAgJ3NtYWxsL2xhcmdlTnVtYmVyRm9ybWF0IGFuZCB0aGUgbWF4IHZhbHVlICcgK1xuICAgICAgICAgICAgICAgICAgICdvZiB0aGUgZmllbGQuJ1xuICAgIH0sXG4gIH1cbn07XG5cbnZhciBzaXplTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgYmFyOiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZSwgdGV4dDogdHJ1ZX0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMzAsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgZGVzY3JpcHRpb246ICdTaXplIG9mIG1hcmtzLidcbiAgICB9XG4gIH1cbn07XG5cbnZhciBjb2xvck1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7cG9pbnQ6IHRydWUsIHRpY2s6IHRydWUsIGJhcjogdHJ1ZSwgbGluZTogdHJ1ZSwgYXJlYTogdHJ1ZSwgY2lyY2xlOiB0cnVlLCBzcXVhcmU6IHRydWUsICd0ZXh0JzogdHJ1ZX0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByb2xlOiAnY29sb3InLFxuICAgICAgZGVmYXVsdDogJyM0NjgyYjQnLFxuICAgICAgZGVzY3JpcHRpb246ICdDb2xvciB0byBiZSB1c2VkIGZvciBtYXJrcy4nXG4gICAgfSxcbiAgICBvcGFjaXR5OiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCwgIC8vIGF1dG9cbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBtYXhpbXVtOiAxXG4gICAgfSxcbiAgICBzY2FsZToge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgdHlwZTogWydzdHJpbmcnLCAnYXJyYXknXSxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgICAnQ29sb3IgcGFsZXR0ZSwgaWYgdW5kZWZpbmVkIHZlZ2EtbGl0ZSB3aWxsIHVzZSBkYXRhIHByb3BlcnR5JyArXG4gICAgICAgICAgICAndG8gcGljayBvbmUgZnJvbSBjMTBwYWxldHRlLCBjMjBwYWxldHRlLCBvciBvcmRpbmFsUGFsZXR0ZS4nXG4gICAgICAgICAgICAvL0ZJWE1FXG4gICAgICAgIH0sXG4gICAgICAgIGMxMHBhbGV0dGU6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiAnY2F0ZWdvcnkxMCcsXG4gICAgICAgICAgZW51bTogW1xuICAgICAgICAgICAgLy8gVGFibGVhdVxuICAgICAgICAgICAgJ2NhdGVnb3J5MTAnLCAnY2F0ZWdvcnkxMGsnLFxuICAgICAgICAgICAgLy8gQ29sb3IgQnJld2VyXG4gICAgICAgICAgICAnUGFzdGVsMScsICdQYXN0ZWwyJywgJ1NldDEnLCAnU2V0MicsICdTZXQzJ1xuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgYzIwcGFsZXR0ZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6ICdjYXRlZ29yeTIwJyxcbiAgICAgICAgICBlbnVtOiBbJ2NhdGVnb3J5MjAnLCAnY2F0ZWdvcnkyMGInLCAnY2F0ZWdvcnkyMGMnXVxuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsUGFsZXR0ZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0NvbG9yIHBhbGV0dGUgdG8gZW5jb2RlIG9yZGluYWwgdmFyaWFibGVzLicsXG4gICAgICAgICAgZW51bTogdXRpbC5rZXlzKGNvbG9yYnJld2VyKVxuICAgICAgICB9LFxuICAgICAgICBxdWFudGl0YXRpdmVSYW5nZToge1xuICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgZGVmYXVsdDogWycjQUZDNkEzJywgJyMwOTYyMkEnXSwgLy8gdGFibGVhdSBncmVlbnNcbiAgICAgICAgICAvLyBkZWZhdWx0OiBbJyNjY2VjZTYnLCAnIzAwNDQxYiddLCAvLyBCdUduLjkgWzItOF1cbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0NvbG9yIHJhbmdlIHRvIGVuY29kZSBxdWFudGl0YXRpdmUgdmFyaWFibGVzLicsXG4gICAgICAgICAgbWluSXRlbXM6IDIsXG4gICAgICAgICAgbWF4SXRlbXM6IDIsXG4gICAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgcm9sZTogJ2NvbG9yJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHNoYXBlTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgY2lyY2xlOiB0cnVlLCBzcXVhcmU6IHRydWV9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogWydjaXJjbGUnLCAnc3F1YXJlJywgJ2Nyb3NzJywgJ2RpYW1vbmQnLCAndHJpYW5nbGUtdXAnLCAndHJpYW5nbGUtZG93biddLFxuICAgICAgZGVmYXVsdDogJ2NpcmNsZScsXG4gICAgICBkZXNjcmlwdGlvbjogJ01hcmsgdG8gYmUgdXNlZC4nXG4gICAgfSxcbiAgICBmaWxsZWQ6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgZGVzY3JpcHRpb246ICdXaGV0aGVyIHRoZSBzaGFwZVxcJ3MgY29sb3Igc2hvdWxkIGJlIHVzZWQgYXMgZmlsbCBjb2xvciBpbnN0ZWFkIG9mIHN0cm9rZSBjb2xvci4nXG4gICAgfVxuICB9XG59O1xuXG52YXIgZGV0YWlsTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgdGljazogdHJ1ZSwgbGluZTogdHJ1ZSwgY2lyY2xlOiB0cnVlLCBzcXVhcmU6IHRydWV9XG59O1xuXG52YXIgcm93TWl4aW4gPSB7XG4gIHByb3BlcnRpZXM6IHtcbiAgICBoZWlnaHQ6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgbWluaW11bTogMCxcbiAgICAgIGRlZmF1bHQ6IDE1MFxuICAgIH1cbiAgfVxufTtcblxudmFyIGNvbE1peGluID0ge1xuICBwcm9wZXJ0aWVzOiB7XG4gICAgd2lkdGg6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgbWluaW11bTogMCxcbiAgICAgIGRlZmF1bHQ6IDE1MFxuICAgIH0sXG4gICAgYXhpczoge1xuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBtYXhMYWJlbExlbmd0aDoge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBkZWZhdWx0OiAxMixcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVHJ1bmNhdGUgbGFiZWxzIHRoYXQgYXJlIHRvbyBsb25nLidcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGZhY2V0TWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgdGljazogdHJ1ZSwgYmFyOiB0cnVlLCBsaW5lOiB0cnVlLCBhcmVhOiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZSwgdGV4dDogdHJ1ZX0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICBwYWRkaW5nOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBtYXhpbXVtOiAxLFxuICAgICAgZGVmYXVsdDogMC4xXG4gICAgfVxuICB9XG59O1xuXG52YXIgcmVxdWlyZWROYW1lVHlwZSA9IHtcbiAgcmVxdWlyZWQ6IFsnbmFtZScsICd0eXBlJ11cbn07XG5cbnZhciBtdWx0aVJvbGVGaWVsZCA9IG1lcmdlKGNsb25lKHR5cGljYWxGaWVsZCksIHtcbiAgc3VwcG9ydGVkUm9sZToge1xuICAgIG1lYXN1cmU6IHRydWUsXG4gICAgZGltZW5zaW9uOiB0cnVlXG4gIH1cbn0pO1xuXG52YXIgcXVhbnRpdGF0aXZlRmllbGQgPSBtZXJnZShjbG9uZSh0eXBpY2FsRmllbGQpLCB7XG4gIHN1cHBvcnRlZFJvbGU6IHtcbiAgICBtZWFzdXJlOiB0cnVlLFxuICAgIGRpbWVuc2lvbjogJ29yZGluYWwtb25seScgLy8gdXNpbmcgc2l6ZSB0byBlbmNvZGluZyBjYXRlZ29yeSBsZWFkIHRvIG9yZGVyIGludGVycHJldGF0aW9uXG4gIH1cbn0pO1xuXG52YXIgb25seVF1YW50aXRhdGl2ZUZpZWxkID0gbWVyZ2UoY2xvbmUodHlwaWNhbEZpZWxkKSwge1xuICBzdXBwb3J0ZWRSb2xlOiB7XG4gICAgbWVhc3VyZTogdHJ1ZVxuICB9XG59KTtcblxudmFyIHggPSBtZXJnZShjbG9uZShtdWx0aVJvbGVGaWVsZCksIGF4aXNNaXhpbiwgYmFuZE1peGluLCByZXF1aXJlZE5hbWVUeXBlLCBzb3J0TWl4aW4pO1xudmFyIHkgPSBjbG9uZSh4KTtcblxudmFyIGZhY2V0ID0gbWVyZ2UoY2xvbmUob25seU9yZGluYWxGaWVsZCksIHJlcXVpcmVkTmFtZVR5cGUsIGZhY2V0TWl4aW4sIHNvcnRNaXhpbik7XG52YXIgcm93ID0gbWVyZ2UoY2xvbmUoZmFjZXQpLCBheGlzTWl4aW4sIHJvd01peGluKTtcbnZhciBjb2wgPSBtZXJnZShjbG9uZShmYWNldCksIGF4aXNNaXhpbiwgY29sTWl4aW4pO1xuXG52YXIgc2l6ZSA9IG1lcmdlKGNsb25lKHF1YW50aXRhdGl2ZUZpZWxkKSwgbGVnZW5kTWl4aW4sIHNpemVNaXhpbiwgc29ydE1peGluKTtcbnZhciBjb2xvciA9IG1lcmdlKGNsb25lKG11bHRpUm9sZUZpZWxkKSwgbGVnZW5kTWl4aW4sIGNvbG9yTWl4aW4sIHNvcnRNaXhpbik7XG5cbnZhciBzaGFwZSA9IG1lcmdlKGNsb25lKG9ubHlPcmRpbmFsRmllbGQpLCBsZWdlbmRNaXhpbiwgc2hhcGVNaXhpbiwgc29ydE1peGluKTtcbnZhciBkZXRhaWwgPSBtZXJnZShjbG9uZShvbmx5T3JkaW5hbEZpZWxkKSwgZGV0YWlsTWl4aW4sIHNvcnRNaXhpbik7XG5cbi8vIHdlIG9ubHkgcHV0IGFnZ3JlZ2F0ZWQgbWVhc3VyZSBpbiBwaXZvdCB0YWJsZVxudmFyIHRleHQgPSBtZXJnZShjbG9uZShvbmx5UXVhbnRpdGF0aXZlRmllbGQpLCB0ZXh0TWl4aW4sIHNvcnRNaXhpbik7XG5cbi8vIFRPRE8gYWRkIGxhYmVsXG5cbnZhciBmaWx0ZXIgPSB7XG4gIHR5cGU6ICdhcnJheScsXG4gIGl0ZW1zOiB7XG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgb3BlcmFuZHM6IHtcbiAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICB0eXBlOiBbJ3N0cmluZycsICdib29sZWFuJywgJ2ludGVnZXInLCAnbnVtYmVyJ11cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9wZXJhdG9yOiB7XG4gICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICBlbnVtOiBbJz4nLCAnPj0nLCAnPScsICchPScsICc8JywgJzw9JywgJ25vdE51bGwnXVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGRhdGEgPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLy8gZGF0YSBzb3VyY2VcbiAgICBmb3JtYXRUeXBlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGVudW06IFsnanNvbicsICdjc3YnXSxcbiAgICAgIGRlZmF1bHQ6ICdqc29uJ1xuICAgIH0sXG4gICAgdXJsOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgdmFsdWVzOiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgICAgZGVzY3JpcHRpb246ICdQYXNzIGFycmF5IG9mIG9iamVjdHMgaW5zdGVhZCBvZiBhIHVybCB0byBhIGZpbGUuJyxcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGNvbmZpZyA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvLyB0ZW1wbGF0ZVxuICAgIHdpZHRoOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICB9LFxuICAgIGhlaWdodDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICB2aWV3cG9ydDoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIHR5cGU6ICdpbnRlZ2VyJ1xuICAgICAgfSxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgZ3JpZENvbG9yOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJvbGU6ICdjb2xvcicsXG4gICAgICBkZWZhdWx0OiAnIzAwMDAwMCdcbiAgICB9LFxuICAgIGdyaWRPcGFjaXR5OiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBtYXhpbXVtOiAxLFxuICAgICAgZGVmYXVsdDogMC4wOFxuICAgIH0sXG5cbiAgICAvLyBmaWx0ZXIgbnVsbFxuICAgIGZpbHRlck51bGw6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBPOiB7dHlwZTonYm9vbGVhbicsIGRlZmF1bHQ6IGZhbHNlfSxcbiAgICAgICAgUToge3R5cGU6J2Jvb2xlYW4nLCBkZWZhdWx0OiB0cnVlfSxcbiAgICAgICAgVDoge3R5cGU6J2Jvb2xlYW4nLCBkZWZhdWx0OiB0cnVlfVxuICAgICAgfVxuICAgIH0sXG4gICAgdG9nZ2xlU29ydDoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBkZWZhdWx0OiBPXG4gICAgfSxcbiAgICBhdXRvU29ydExpbmU6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuXG4gICAgLy8gc2luZ2xlIHBsb3RcbiAgICBzaW5nbGVIZWlnaHQ6IHtcbiAgICAgIC8vIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgYmFuZFdpZHRoICogKGNhcmRpbmFsaXR5ICsgcGFkZGluZylcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDIwMCxcbiAgICAgIG1pbmltdW06IDBcbiAgICB9LFxuICAgIHNpbmdsZVdpZHRoOiB7XG4gICAgICAvLyB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IGJhbmRXaWR0aCAqIChjYXJkaW5hbGl0eSArIHBhZGRpbmcpXG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAyMDAsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICAvLyBiYW5kIHNpemVcbiAgICBsYXJnZUJhbmRTaXplOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAyMSxcbiAgICAgIG1pbmltdW06IDBcbiAgICB9LFxuICAgIHNtYWxsQmFuZFNpemU6IHtcbiAgICAgIC8vc21hbGwgbXVsdGlwbGVzIG9yIHNpbmdsZSBwbG90IHdpdGggaGlnaCBjYXJkaW5hbGl0eVxuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMTIsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICBsYXJnZUJhbmRNYXhDYXJkaW5hbGl0eToge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMTBcbiAgICB9LFxuICAgIC8vIHNtYWxsIG11bHRpcGxlc1xuICAgIGNlbGxQYWRkaW5nOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIGRlZmF1bHQ6IDAuMVxuICAgIH0sXG4gICAgY2VsbEdyaWRDb2xvcjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByb2xlOiAnY29sb3InLFxuICAgICAgZGVmYXVsdDogJyMwMDAwMDAnXG4gICAgfSxcbiAgICBjZWxsR3JpZE9wYWNpdHk6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgbWluaW11bTogMCxcbiAgICAgIG1heGltdW06IDEsXG4gICAgICBkZWZhdWx0OiAwLjE1XG4gICAgfSxcbiAgICBjZWxsQmFja2dyb3VuZENvbG9yOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJvbGU6ICdjb2xvcicsXG4gICAgICBkZWZhdWx0OiAncmdiYSgwLDAsMCwwKSdcbiAgICB9LFxuICAgIHRleHRDZWxsV2lkdGg6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDkwLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG5cbiAgICAvLyBtYXJrc1xuICAgIHN0cm9rZVdpZHRoOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAyLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgc2luZ2xlQmFyT2Zmc2V0OiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiA1LFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgLy8gc2NhbGVzXG4gICAgdGltZVNjYWxlTGFiZWxMZW5ndGg6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDMsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgZGVzY3JpcHRpb246ICdNYXggbGVuZ3RoIGZvciB2YWx1ZXMgaW4gZGF5U2NhbGVMYWJlbCBhbmQgbW9udGhTY2FsZUxhYmVsLiAgWmVybyBtZWFucyB1c2luZyBmdWxsIG5hbWVzIGluIGRheVNjYWxlTGFiZWwvbW9udGhTY2FsZUxhYmVsLidcbiAgICB9LFxuICAgIGRheVNjYWxlTGFiZWw6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgICAgfSxcbiAgICAgIGRlZmF1bHQ6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQXhpcyBsYWJlbHMgZm9yIGRheSBvZiB3ZWVrLCBzdGFydGluZyBmcm9tIFN1bmRheS4nICtcbiAgICAgICAgJyhDb25zaXN0ZW50IHdpdGggSmF2YXNjcmlwdCAtLSBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9nZXREYXkuJ1xuICAgIH0sXG4gICAgbW9udGhTY2FsZUxhYmVsOiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0OiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQXhpcyBsYWJlbHMgZm9yIG1vbnRoLidcbiAgICB9LFxuICAgIC8vIG90aGVyXG4gICAgY2hhcmFjdGVyV2lkdGg6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDZcbiAgICB9LFxuICAgIG1heFNtYWxsTnVtYmVyOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIGRlZmF1bHQ6IDEwMDAwLFxuICAgICAgZGVzY3JpcHRpb246ICdtYXhpbXVtIG51bWJlciB0aGF0IGEgZmllbGQgd2lsbCBiZSBjb25zaWRlcmVkIHNtYWxsTnVtYmVyLicrXG4gICAgICAgICAgICAgICAgICAgJ1VzZWQgZm9yIGF4aXMgbGFiZWxsaW5nLidcbiAgICB9LFxuICAgIHNtYWxsTnVtYmVyRm9ybWF0OiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlZmF1bHQ6ICcnLFxuICAgICAgZGVzY3JpcHRpb246ICdEMyBOdW1iZXIgZm9ybWF0IGZvciBheGlzIGxhYmVscyBhbmQgdGV4dCB0YWJsZXMgJytcbiAgICAgICAgICAgICAgICAgICAnZm9yIG51bWJlciA8PSBtYXhTbWFsbE51bWJlci4gVXNlZCBmb3IgYXhpcyBsYWJlbGxpbmcuJ1xuICAgIH0sXG4gICAgbGFyZ2VOdW1iZXJGb3JtYXQ6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogJy4zcycsXG4gICAgICBkZXNjcmlwdGlvbjogJ0QzIE51bWJlciBmb3JtYXQgZm9yIGF4aXMgbGFiZWxzIGFuZCB0ZXh0IHRhYmxlcyAnICtcbiAgICAgICAgICAgICAgICAgICAnZm9yIG51bWJlciA+IG1heFNtYWxsTnVtYmVyLidcbiAgICB9LFxuICAgIHRpbWVGb3JtYXQ6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogJyVZLSVtLSVkJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnRGF0ZSBmb3JtYXQgZm9yIGF4aXMgbGFiZWxzLidcbiAgICB9LFxuICAgIHVzZVJhd0RvbWFpbjoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICBkZXNjcmlwdGlvbjogJ1VzZSB0aGUgcmF3IGRhdGEgcmFuZ2UgYXMgc2NhbGUgZG9tYWluIGluc3RlYWQgb2YgJyArXG4gICAgICAgICAgICAgICAgICAgJ2FnZ3JlZ2F0ZWQgZGF0YSBmb3IgYWdncmVnYXRlIGF4aXMuICcgK1xuICAgICAgICAgICAgICAgICAgICdUaGlzIG9wdGlvbiBkb2VzIG5vdCB3b3JrIHdpdGggc3VtIG9yIGNvdW50IGFnZ3JlZ2F0ZScgK1xuICAgICAgICAgICAgICAgICAgICdhcyB0aGV5IG1pZ2h0IGhhdmUgYSBzdWJzdGFudGlhbGx5IGxhcmdlciBzY2FsZSByYW5nZS4nICtcbiAgICAgICAgICAgICAgICAgICAnQnkgZGVmYXVsdCwgdXNlIHZhbHVlIGZyb20gY29uZmlnLnVzZVJhd0RvbWFpbi4nXG4gICAgfVxuICB9XG59O1xuXG4vKiogQHR5cGUgT2JqZWN0IFNjaGVtYSBvZiBhIHZlZ2EtbGl0ZSBzcGVjaWZpY2F0aW9uICovXG5zY2hlbWEuc2NoZW1hID0ge1xuICAkc2NoZW1hOiAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjJyxcbiAgZGVzY3JpcHRpb246ICdTY2hlbWEgZm9yIFZlZ2EtbGl0ZSBzcGVjaWZpY2F0aW9uJyxcbiAgdHlwZTogJ29iamVjdCcsXG4gIHJlcXVpcmVkOiBbJ21hcmt0eXBlJywgJ2VuY29kaW5nJywgJ2RhdGEnXSxcbiAgcHJvcGVydGllczoge1xuICAgIGRhdGE6IGRhdGEsXG4gICAgbWFya3R5cGU6IHNjaGVtYS5tYXJrdHlwZSxcbiAgICBlbmNvZGluZzoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHJvdzogcm93LFxuICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICBzaGFwZTogc2hhcGUsXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIGRldGFpbDogZGV0YWlsXG4gICAgICB9XG4gICAgfSxcbiAgICBmaWx0ZXI6IGZpbHRlcixcbiAgICBjb25maWc6IGNvbmZpZ1xuICB9XG59O1xuXG5zY2hlbWEuZW5jVHlwZXMgPSB1dGlsLmtleXMoc2NoZW1hLnNjaGVtYS5wcm9wZXJ0aWVzLmVuY29kaW5nLnByb3BlcnRpZXMpO1xuXG4vKiogSW5zdGFudGlhdGUgYSB2ZXJib3NlIHZsIHNwZWMgZnJvbSB0aGUgc2NoZW1hICovXG5zY2hlbWEuaW5zdGFudGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHNjaGVtYS51dGlsLmluc3RhbnRpYXRlKHNjaGVtYS5zY2hlbWEpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNjaGVtYXV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IHt9LFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XG59O1xuXG5zY2hlbWF1dGlsLmV4dGVuZCA9IGZ1bmN0aW9uKGluc3RhbmNlLCBzY2hlbWEpIHtcbiAgcmV0dXJuIHNjaGVtYXV0aWwubWVyZ2Uoc2NoZW1hdXRpbC5pbnN0YW50aWF0ZShzY2hlbWEpLCBpbnN0YW5jZSk7XG59O1xuXG4vLyBpbnN0YW50aWF0ZSBhIHNjaGVtYVxuc2NoZW1hdXRpbC5pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uKHNjaGVtYSkge1xuICB2YXIgdmFsO1xuICBpZiAoc2NoZW1hID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKCdkZWZhdWx0JyBpbiBzY2hlbWEpIHtcbiAgICB2YWwgPSBzY2hlbWEuZGVmYXVsdDtcbiAgICByZXR1cm4gdXRpbC5pc09iamVjdCh2YWwpID8gdXRpbC5kdXBsaWNhdGUodmFsKSA6IHZhbDtcbiAgfSBlbHNlIGlmIChzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB7fTtcbiAgICBmb3IgKHZhciBuYW1lIGluIHNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICB2YWwgPSBzY2hlbWF1dGlsLmluc3RhbnRpYXRlKHNjaGVtYS5wcm9wZXJ0aWVzW25hbWVdKTtcbiAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbnN0YW5jZVtuYW1lXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2UgaWYgKHNjaGVtYS50eXBlID09PSAnYXJyYXknKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vLyByZW1vdmUgYWxsIGRlZmF1bHRzIGZyb20gYW4gaW5zdGFuY2VcbnNjaGVtYXV0aWwuc3VidHJhY3QgPSBmdW5jdGlvbihpbnN0YW5jZSwgZGVmYXVsdHMpIHtcbiAgdmFyIGNoYW5nZXMgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBpbnN0YW5jZSkge1xuICAgIHZhciBkZWYgPSBkZWZhdWx0c1twcm9wXTtcbiAgICB2YXIgaW5zID0gaW5zdGFuY2VbcHJvcF07XG4gICAgLy8gTm90ZTogZG9lcyBub3QgcHJvcGVybHkgc3VidHJhY3QgYXJyYXlzXG4gICAgaWYgKCFkZWZhdWx0cyB8fCBkZWYgIT09IGlucykge1xuICAgICAgaWYgKHR5cGVvZiBpbnMgPT09ICdvYmplY3QnICYmICF1dGlsLmlzQXJyYXkoaW5zKSAmJiBkZWYpIHtcbiAgICAgICAgdmFyIGMgPSBzY2hlbWF1dGlsLnN1YnRyYWN0KGlucywgZGVmKTtcbiAgICAgICAgaWYgKCFpc0VtcHR5KGMpKVxuICAgICAgICAgIGNoYW5nZXNbcHJvcF0gPSBjO1xuICAgICAgfSBlbHNlIGlmICghdXRpbC5pc0FycmF5KGlucykgfHwgaW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY2hhbmdlc1twcm9wXSA9IGlucztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoYW5nZXM7XG59O1xuXG5zY2hlbWF1dGlsLm1lcmdlID0gZnVuY3Rpb24oLypkZXN0Kiwgc3JjMCwgc3JjMSwgLi4uKi8pe1xuICB2YXIgZGVzdCA9IGFyZ3VtZW50c1swXTtcbiAgZm9yICh2YXIgaT0xIDsgaTxhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBkZXN0ID0gbWVyZ2UoZGVzdCwgYXJndW1lbnRzW2ldKTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn07XG5cbi8vIHJlY3Vyc2l2ZWx5IG1lcmdlcyBzcmMgaW50byBkZXN0XG5mdW5jdGlvbiBtZXJnZShkZXN0LCBzcmMpIHtcbiAgaWYgKHR5cGVvZiBzcmMgIT09ICdvYmplY3QnIHx8IHNyYyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBkZXN0O1xuICB9XG5cbiAgZm9yICh2YXIgcCBpbiBzcmMpIHtcbiAgICBpZiAoIXNyYy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChzcmNbcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3JjW3BdICE9PSAnb2JqZWN0JyB8fCBzcmNbcF0gPT09IG51bGwpIHtcbiAgICAgIGRlc3RbcF0gPSBzcmNbcF07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVzdFtwXSAhPT0gJ29iamVjdCcgfHwgZGVzdFtwXSA9PT0gbnVsbCkge1xuICAgICAgZGVzdFtwXSA9IG1lcmdlKHNyY1twXS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgPyBbXSA6IHt9LCBzcmNbcF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZShkZXN0W3BdLCBzcmNbcF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVzdDtcbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdkYXRhbGliL3NyYy91dGlsJyk7XG5cbnV0aWwuZXh0ZW5kKHV0aWwsIHJlcXVpcmUoJ2RhdGFsaWIvc3JjL2dlbmVyYXRlJykpO1xudXRpbC5leHRlbmQodXRpbCwgcmVxdWlyZSgnZGF0YWxpYi9zcmMvc3RhdHMnKSk7XG51dGlsLmV4dGVuZCh1dGlsLCByZXF1aXJlKCcuL2xvZ2dlcicpKCdbVkwgRXJyb3JdJykpO1xudXRpbC5iaW4gPSByZXF1aXJlKCdkYXRhbGliL3NyYy9iaW5zL2JpbnMnKTtcblxudXRpbC5pc2luID0gZnVuY3Rpb24oaXRlbSwgYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSkgIT09IC0xO1xufTtcblxudXRpbC5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBmLCB0aGlzQXJnKSB7XG4gIGlmIChvYmouZm9yRWFjaCkge1xuICAgIG9iai5mb3JFYWNoLmNhbGwodGhpc0FyZywgZik7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgIGYuY2FsbCh0aGlzQXJnLCBvYmpba10sIGsgLCBvYmopO1xuICAgIH1cbiAgfVxufTtcblxudXRpbC5yZWR1Y2UgPSBmdW5jdGlvbihvYmosIGYsIGluaXQsIHRoaXNBcmcpIHtcbiAgaWYgKG9iai5yZWR1Y2UpIHtcbiAgICByZXR1cm4gb2JqLnJlZHVjZS5jYWxsKHRoaXNBcmcsIGYsIGluaXQpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICBpbml0ID0gZi5jYWxsKHRoaXNBcmcsIGluaXQsIG9ialtrXSwgaywgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIGluaXQ7XG4gIH1cbn07XG5cbnV0aWwubWFwID0gZnVuY3Rpb24ob2JqLCBmLCB0aGlzQXJnKSB7XG4gIGlmIChvYmoubWFwKSB7XG4gICAgcmV0dXJuIG9iai5tYXAuY2FsbCh0aGlzQXJnLCBmKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgIG91dHB1dC5wdXNoKCBmLmNhbGwodGhpc0FyZywgb2JqW2tdLCBrLCBvYmopKTtcbiAgICB9XG4gIH1cbn07XG5cbnV0aWwuYW55ID0gZnVuY3Rpb24oYXJyLCBmKSB7XG4gIHZhciBpID0gMCwgaztcbiAgZm9yIChrIGluIGFycikge1xuICAgIGlmIChmKGFycltrXSwgaywgaSsrKSkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudXRpbC5hbGwgPSBmdW5jdGlvbihhcnIsIGYpIHtcbiAgdmFyIGkgPSAwLCBrO1xuICBmb3IgKGsgaW4gYXJyKSB7XG4gICAgaWYgKCFmKGFycltrXSwgaywgaSsrKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxudXRpbC5nZXRiaW5zID0gZnVuY3Rpb24oc3RhdHMsIG1heGJpbnMpIHtcbiAgcmV0dXJuIHV0aWwuYmluKHtcbiAgICBtaW46IHN0YXRzLm1pbixcbiAgICBtYXg6IHN0YXRzLm1heCxcbiAgICBtYXhiaW5zOiBtYXhiaW5zXG4gIH0pO1xufTtcblxuLyoqXG4gKiB4W3BbMF1dLi4uW3Bbbl1dID0gdmFsXG4gKiBAcGFyYW0gbm9hdWdtZW50IGRldGVybWluZSB3aGV0aGVyIG5ldyBvYmplY3Qgc2hvdWxkIGJlIGFkZGVkIGZcbiAqIG9yIG5vbi1leGlzdGluZyBwcm9wZXJ0aWVzIGFsb25nIHRoZSBwYXRoXG4gKi9cbnV0aWwuc2V0dGVyID0gZnVuY3Rpb24oeCwgcCwgdmFsLCBub2F1Z21lbnQpIHtcbiAgZm9yICh2YXIgaT0wOyBpPHAubGVuZ3RoLTE7ICsraSkge1xuICAgIGlmICghbm9hdWdtZW50ICYmICEocFtpXSBpbiB4KSl7XG4gICAgICB4ID0geFtwW2ldXSA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geFtwW2ldXTtcbiAgICB9XG4gIH1cbiAgeFtwW2ldXSA9IHZhbDtcbn07XG5cblxuLyoqXG4gKiByZXR1cm5zIHhbcFswXV0uLi5bcFtuXV1cbiAqIEBwYXJhbSBhdWdtZW50IGRldGVybWluZSB3aGV0aGVyIG5ldyBvYmplY3Qgc2hvdWxkIGJlIGFkZGVkIGZcbiAqIG9yIG5vbi1leGlzdGluZyBwcm9wZXJ0aWVzIGFsb25nIHRoZSBwYXRoXG4gKi9cbnV0aWwuZ2V0dGVyID0gZnVuY3Rpb24oeCwgcCwgbm9hdWdtZW50KSB7XG4gIGZvciAodmFyIGk9MDsgaTxwLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCFub2F1Z21lbnQgJiYgIShwW2ldIGluIHgpKXtcbiAgICAgIHggPSB4W3BbaV1dID0ge307XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4W3BbaV1dO1xuICAgIH1cbiAgfVxuICByZXR1cm4geDtcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9nbG9iYWxzJyk7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gICAgY29uc3RzID0gcmVxdWlyZSgnLi9jb25zdHMnKTtcblxudmFyIHZsID0ge307XG5cbnV0aWwuZXh0ZW5kKHZsLCBjb25zdHMsIHV0aWwpO1xuXG52bC5FbmNvZGluZyA9IHJlcXVpcmUoJy4vRW5jb2RpbmcnKTtcbnZsLmNvbXBpbGVyID0gcmVxdWlyZSgnLi9jb21waWxlci9jb21waWxlcicpO1xudmwuY29tcGlsZSA9IHZsLmNvbXBpbGVyLmNvbXBpbGU7XG52bC5kYXRhID0gcmVxdWlyZSgnLi9kYXRhJyk7XG52bC5lbmMgPSByZXF1aXJlKCcuL2VuYycpO1xudmwuZmllbGQgPSByZXF1aXJlKCcuL2ZpZWxkJyk7XG52bC5zY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYS9zY2hlbWEnKTtcbnZsLnRvU2hvcnRoYW5kID0gdmwuRW5jb2Rpbmcuc2hvcnRoYW5kO1xudmwuZm9ybWF0ID0gcmVxdWlyZSgnZDMtZm9ybWF0JykuZm9ybWF0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZsOyJdfQ==\n","// This product includes color specifications and designs developed by Cynthia Brewer (http://colorbrewer.org/).\n// JavaScript specs as packaged in the D3 library (d3js.org). Please see license at http://colorbrewer.org/export/LICENSE.txt\n!function() {\n\nvar colorbrewer = {YlGn: {\n3: [\"#f7fcb9\",\"#addd8e\",\"#31a354\"],\n4: [\"#ffffcc\",\"#c2e699\",\"#78c679\",\"#238443\"],\n5: [\"#ffffcc\",\"#c2e699\",\"#78c679\",\"#31a354\",\"#006837\"],\n6: [\"#ffffcc\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#31a354\",\"#006837\"],\n7: [\"#ffffcc\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#005a32\"],\n8: [\"#ffffe5\",\"#f7fcb9\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#005a32\"],\n9: [\"#ffffe5\",\"#f7fcb9\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#006837\",\"#004529\"]\n},YlGnBu: {\n3: [\"#edf8b1\",\"#7fcdbb\",\"#2c7fb8\"],\n4: [\"#ffffcc\",\"#a1dab4\",\"#41b6c4\",\"#225ea8\"],\n5: [\"#ffffcc\",\"#a1dab4\",\"#41b6c4\",\"#2c7fb8\",\"#253494\"],\n6: [\"#ffffcc\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#2c7fb8\",\"#253494\"],\n7: [\"#ffffcc\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#0c2c84\"],\n8: [\"#ffffd9\",\"#edf8b1\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#0c2c84\"],\n9: [\"#ffffd9\",\"#edf8b1\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#253494\",\"#081d58\"]\n},GnBu: {\n3: [\"#e0f3db\",\"#a8ddb5\",\"#43a2ca\"],\n4: [\"#f0f9e8\",\"#bae4bc\",\"#7bccc4\",\"#2b8cbe\"],\n5: [\"#f0f9e8\",\"#bae4bc\",\"#7bccc4\",\"#43a2ca\",\"#0868ac\"],\n6: [\"#f0f9e8\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#43a2ca\",\"#0868ac\"],\n7: [\"#f0f9e8\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#08589e\"],\n8: [\"#f7fcf0\",\"#e0f3db\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#08589e\"],\n9: [\"#f7fcf0\",\"#e0f3db\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#0868ac\",\"#084081\"]\n},BuGn: {\n3: [\"#e5f5f9\",\"#99d8c9\",\"#2ca25f\"],\n4: [\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#238b45\"],\n5: [\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\"],\n6: [\"#edf8fb\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\"],\n7: [\"#edf8fb\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#005824\"],\n8: [\"#f7fcfd\",\"#e5f5f9\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#005824\"],\n9: [\"#f7fcfd\",\"#e5f5f9\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#006d2c\",\"#00441b\"]\n},PuBuGn: {\n3: [\"#ece2f0\",\"#a6bddb\",\"#1c9099\"],\n4: [\"#f6eff7\",\"#bdc9e1\",\"#67a9cf\",\"#02818a\"],\n5: [\"#f6eff7\",\"#bdc9e1\",\"#67a9cf\",\"#1c9099\",\"#016c59\"],\n6: [\"#f6eff7\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#1c9099\",\"#016c59\"],\n7: [\"#f6eff7\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016450\"],\n8: [\"#fff7fb\",\"#ece2f0\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016450\"],\n9: [\"#fff7fb\",\"#ece2f0\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016c59\",\"#014636\"]\n},PuBu: {\n3: [\"#ece7f2\",\"#a6bddb\",\"#2b8cbe\"],\n4: [\"#f1eef6\",\"#bdc9e1\",\"#74a9cf\",\"#0570b0\"],\n5: [\"#f1eef6\",\"#bdc9e1\",\"#74a9cf\",\"#2b8cbe\",\"#045a8d\"],\n6: [\"#f1eef6\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#2b8cbe\",\"#045a8d\"],\n7: [\"#f1eef6\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#034e7b\"],\n8: [\"#fff7fb\",\"#ece7f2\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#034e7b\"],\n9: [\"#fff7fb\",\"#ece7f2\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#045a8d\",\"#023858\"]\n},BuPu: {\n3: [\"#e0ecf4\",\"#9ebcda\",\"#8856a7\"],\n4: [\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#88419d\"],\n5: [\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#8856a7\",\"#810f7c\"],\n6: [\"#edf8fb\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8856a7\",\"#810f7c\"],\n7: [\"#edf8fb\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#6e016b\"],\n8: [\"#f7fcfd\",\"#e0ecf4\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#6e016b\"],\n9: [\"#f7fcfd\",\"#e0ecf4\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#810f7c\",\"#4d004b\"]\n},RdPu: {\n3: [\"#fde0dd\",\"#fa9fb5\",\"#c51b8a\"],\n4: [\"#feebe2\",\"#fbb4b9\",\"#f768a1\",\"#ae017e\"],\n5: [\"#feebe2\",\"#fbb4b9\",\"#f768a1\",\"#c51b8a\",\"#7a0177\"],\n6: [\"#feebe2\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#c51b8a\",\"#7a0177\"],\n7: [\"#feebe2\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\"],\n8: [\"#fff7f3\",\"#fde0dd\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\"],\n9: [\"#fff7f3\",\"#fde0dd\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\",\"#49006a\"]\n},PuRd: {\n3: [\"#e7e1ef\",\"#c994c7\",\"#dd1c77\"],\n4: [\"#f1eef6\",\"#d7b5d8\",\"#df65b0\",\"#ce1256\"],\n5: [\"#f1eef6\",\"#d7b5d8\",\"#df65b0\",\"#dd1c77\",\"#980043\"],\n6: [\"#f1eef6\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#dd1c77\",\"#980043\"],\n7: [\"#f1eef6\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#91003f\"],\n8: [\"#f7f4f9\",\"#e7e1ef\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#91003f\"],\n9: [\"#f7f4f9\",\"#e7e1ef\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#980043\",\"#67001f\"]\n},OrRd: {\n3: [\"#fee8c8\",\"#fdbb84\",\"#e34a33\"],\n4: [\"#fef0d9\",\"#fdcc8a\",\"#fc8d59\",\"#d7301f\"],\n5: [\"#fef0d9\",\"#fdcc8a\",\"#fc8d59\",\"#e34a33\",\"#b30000\"],\n6: [\"#fef0d9\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#e34a33\",\"#b30000\"],\n7: [\"#fef0d9\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#990000\"],\n8: [\"#fff7ec\",\"#fee8c8\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#990000\"],\n9: [\"#fff7ec\",\"#fee8c8\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#b30000\",\"#7f0000\"]\n},YlOrRd: {\n3: [\"#ffeda0\",\"#feb24c\",\"#f03b20\"],\n4: [\"#ffffb2\",\"#fecc5c\",\"#fd8d3c\",\"#e31a1c\"],\n5: [\"#ffffb2\",\"#fecc5c\",\"#fd8d3c\",\"#f03b20\",\"#bd0026\"],\n6: [\"#ffffb2\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#f03b20\",\"#bd0026\"],\n7: [\"#ffffb2\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#b10026\"],\n8: [\"#ffffcc\",\"#ffeda0\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#b10026\"],\n9: [\"#ffffcc\",\"#ffeda0\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#bd0026\",\"#800026\"]\n},YlOrBr: {\n3: [\"#fff7bc\",\"#fec44f\",\"#d95f0e\"],\n4: [\"#ffffd4\",\"#fed98e\",\"#fe9929\",\"#cc4c02\"],\n5: [\"#ffffd4\",\"#fed98e\",\"#fe9929\",\"#d95f0e\",\"#993404\"],\n6: [\"#ffffd4\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#d95f0e\",\"#993404\"],\n7: [\"#ffffd4\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#8c2d04\"],\n8: [\"#ffffe5\",\"#fff7bc\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#8c2d04\"],\n9: [\"#ffffe5\",\"#fff7bc\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#993404\",\"#662506\"]\n},Purples: {\n3: [\"#efedf5\",\"#bcbddc\",\"#756bb1\"],\n4: [\"#f2f0f7\",\"#cbc9e2\",\"#9e9ac8\",\"#6a51a3\"],\n5: [\"#f2f0f7\",\"#cbc9e2\",\"#9e9ac8\",\"#756bb1\",\"#54278f\"],\n6: [\"#f2f0f7\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#756bb1\",\"#54278f\"],\n7: [\"#f2f0f7\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#4a1486\"],\n8: [\"#fcfbfd\",\"#efedf5\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#4a1486\"],\n9: [\"#fcfbfd\",\"#efedf5\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#54278f\",\"#3f007d\"]\n},Blues: {\n3: [\"#deebf7\",\"#9ecae1\",\"#3182bd\"],\n4: [\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#2171b5\"],\n5: [\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#3182bd\",\"#08519c\"],\n6: [\"#eff3ff\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#3182bd\",\"#08519c\"],\n7: [\"#eff3ff\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#084594\"],\n8: [\"#f7fbff\",\"#deebf7\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#084594\"],\n9: [\"#f7fbff\",\"#deebf7\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#08519c\",\"#08306b\"]\n},Greens: {\n3: [\"#e5f5e0\",\"#a1d99b\",\"#31a354\"],\n4: [\"#edf8e9\",\"#bae4b3\",\"#74c476\",\"#238b45\"],\n5: [\"#edf8e9\",\"#bae4b3\",\"#74c476\",\"#31a354\",\"#006d2c\"],\n6: [\"#edf8e9\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#31a354\",\"#006d2c\"],\n7: [\"#edf8e9\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#005a32\"],\n8: [\"#f7fcf5\",\"#e5f5e0\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#005a32\"],\n9: [\"#f7fcf5\",\"#e5f5e0\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#006d2c\",\"#00441b\"]\n},Oranges: {\n3: [\"#fee6ce\",\"#fdae6b\",\"#e6550d\"],\n4: [\"#feedde\",\"#fdbe85\",\"#fd8d3c\",\"#d94701\"],\n5: [\"#feedde\",\"#fdbe85\",\"#fd8d3c\",\"#e6550d\",\"#a63603\"],\n6: [\"#feedde\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#e6550d\",\"#a63603\"],\n7: [\"#feedde\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#8c2d04\"],\n8: [\"#fff5eb\",\"#fee6ce\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#8c2d04\"],\n9: [\"#fff5eb\",\"#fee6ce\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#a63603\",\"#7f2704\"]\n},Reds: {\n3: [\"#fee0d2\",\"#fc9272\",\"#de2d26\"],\n4: [\"#fee5d9\",\"#fcae91\",\"#fb6a4a\",\"#cb181d\"],\n5: [\"#fee5d9\",\"#fcae91\",\"#fb6a4a\",\"#de2d26\",\"#a50f15\"],\n6: [\"#fee5d9\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#de2d26\",\"#a50f15\"],\n7: [\"#fee5d9\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#99000d\"],\n8: [\"#fff5f0\",\"#fee0d2\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#99000d\"],\n9: [\"#fff5f0\",\"#fee0d2\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#a50f15\",\"#67000d\"]\n},Greys: {\n3: [\"#f0f0f0\",\"#bdbdbd\",\"#636363\"],\n4: [\"#f7f7f7\",\"#cccccc\",\"#969696\",\"#525252\"],\n5: [\"#f7f7f7\",\"#cccccc\",\"#969696\",\"#636363\",\"#252525\"],\n6: [\"#f7f7f7\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#636363\",\"#252525\"],\n7: [\"#f7f7f7\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\"],\n8: [\"#ffffff\",\"#f0f0f0\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\"],\n9: [\"#ffffff\",\"#f0f0f0\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\",\"#000000\"]\n},PuOr: {\n3: [\"#f1a340\",\"#f7f7f7\",\"#998ec3\"],\n4: [\"#e66101\",\"#fdb863\",\"#b2abd2\",\"#5e3c99\"],\n5: [\"#e66101\",\"#fdb863\",\"#f7f7f7\",\"#b2abd2\",\"#5e3c99\"],\n6: [\"#b35806\",\"#f1a340\",\"#fee0b6\",\"#d8daeb\",\"#998ec3\",\"#542788\"],\n7: [\"#b35806\",\"#f1a340\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#998ec3\",\"#542788\"],\n8: [\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\"],\n9: [\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\"],\n10: [\"#7f3b08\",\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\",\"#2d004b\"],\n11: [\"#7f3b08\",\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\",\"#2d004b\"]\n},BrBG: {\n3: [\"#d8b365\",\"#f5f5f5\",\"#5ab4ac\"],\n4: [\"#a6611a\",\"#dfc27d\",\"#80cdc1\",\"#018571\"],\n5: [\"#a6611a\",\"#dfc27d\",\"#f5f5f5\",\"#80cdc1\",\"#018571\"],\n6: [\"#8c510a\",\"#d8b365\",\"#f6e8c3\",\"#c7eae5\",\"#5ab4ac\",\"#01665e\"],\n7: [\"#8c510a\",\"#d8b365\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#5ab4ac\",\"#01665e\"],\n8: [\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\"],\n9: [\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\"],\n10: [\"#543005\",\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\",\"#003c30\"],\n11: [\"#543005\",\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\",\"#003c30\"]\n},PRGn: {\n3: [\"#af8dc3\",\"#f7f7f7\",\"#7fbf7b\"],\n4: [\"#7b3294\",\"#c2a5cf\",\"#a6dba0\",\"#008837\"],\n5: [\"#7b3294\",\"#c2a5cf\",\"#f7f7f7\",\"#a6dba0\",\"#008837\"],\n6: [\"#762a83\",\"#af8dc3\",\"#e7d4e8\",\"#d9f0d3\",\"#7fbf7b\",\"#1b7837\"],\n7: [\"#762a83\",\"#af8dc3\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#7fbf7b\",\"#1b7837\"],\n8: [\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\"],\n9: [\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\"],\n10: [\"#40004b\",\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\",\"#00441b\"],\n11: [\"#40004b\",\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\",\"#00441b\"]\n},PiYG: {\n3: [\"#e9a3c9\",\"#f7f7f7\",\"#a1d76a\"],\n4: [\"#d01c8b\",\"#f1b6da\",\"#b8e186\",\"#4dac26\"],\n5: [\"#d01c8b\",\"#f1b6da\",\"#f7f7f7\",\"#b8e186\",\"#4dac26\"],\n6: [\"#c51b7d\",\"#e9a3c9\",\"#fde0ef\",\"#e6f5d0\",\"#a1d76a\",\"#4d9221\"],\n7: [\"#c51b7d\",\"#e9a3c9\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#a1d76a\",\"#4d9221\"],\n8: [\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\"],\n9: [\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\"],\n10: [\"#8e0152\",\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\",\"#276419\"],\n11: [\"#8e0152\",\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\",\"#276419\"]\n},RdBu: {\n3: [\"#ef8a62\",\"#f7f7f7\",\"#67a9cf\"],\n4: [\"#ca0020\",\"#f4a582\",\"#92c5de\",\"#0571b0\"],\n5: [\"#ca0020\",\"#f4a582\",\"#f7f7f7\",\"#92c5de\",\"#0571b0\"],\n6: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#d1e5f0\",\"#67a9cf\",\"#2166ac\"],\n7: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#67a9cf\",\"#2166ac\"],\n8: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\"],\n9: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\"],\n10: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\",\"#053061\"],\n11: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\",\"#053061\"]\n},RdGy: {\n3: [\"#ef8a62\",\"#ffffff\",\"#999999\"],\n4: [\"#ca0020\",\"#f4a582\",\"#bababa\",\"#404040\"],\n5: [\"#ca0020\",\"#f4a582\",\"#ffffff\",\"#bababa\",\"#404040\"],\n6: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#e0e0e0\",\"#999999\",\"#4d4d4d\"],\n7: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#999999\",\"#4d4d4d\"],\n8: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\"],\n9: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\"],\n10: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\",\"#1a1a1a\"],\n11: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\",\"#1a1a1a\"]\n},RdYlBu: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#91bfdb\"],\n4: [\"#d7191c\",\"#fdae61\",\"#abd9e9\",\"#2c7bb6\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#abd9e9\",\"#2c7bb6\"],\n6: [\"#d73027\",\"#fc8d59\",\"#fee090\",\"#e0f3f8\",\"#91bfdb\",\"#4575b4\"],\n7: [\"#d73027\",\"#fc8d59\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#91bfdb\",\"#4575b4\"],\n8: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\"],\n9: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\"],\n10: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\",\"#313695\"],\n11: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\",\"#313695\"]\n},Spectral: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#99d594\"],\n4: [\"#d7191c\",\"#fdae61\",\"#abdda4\",\"#2b83ba\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#abdda4\",\"#2b83ba\"],\n6: [\"#d53e4f\",\"#fc8d59\",\"#fee08b\",\"#e6f598\",\"#99d594\",\"#3288bd\"],\n7: [\"#d53e4f\",\"#fc8d59\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#99d594\",\"#3288bd\"],\n8: [\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\"],\n9: [\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\"],\n10: [\"#9e0142\",\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\",\"#5e4fa2\"],\n11: [\"#9e0142\",\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\",\"#5e4fa2\"]\n},RdYlGn: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#91cf60\"],\n4: [\"#d7191c\",\"#fdae61\",\"#a6d96a\",\"#1a9641\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#a6d96a\",\"#1a9641\"],\n6: [\"#d73027\",\"#fc8d59\",\"#fee08b\",\"#d9ef8b\",\"#91cf60\",\"#1a9850\"],\n7: [\"#d73027\",\"#fc8d59\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#91cf60\",\"#1a9850\"],\n8: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\"],\n9: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\"],\n10: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\",\"#006837\"],\n11: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\",\"#006837\"]\n},Accent: {\n3: [\"#7fc97f\",\"#beaed4\",\"#fdc086\"],\n4: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\"],\n5: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\"],\n6: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\"],\n7: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\",\"#bf5b17\"],\n8: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\",\"#bf5b17\",\"#666666\"]\n},Dark2: {\n3: [\"#1b9e77\",\"#d95f02\",\"#7570b3\"],\n4: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\"],\n5: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\"],\n6: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\"],\n7: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\",\"#a6761d\"],\n8: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\",\"#a6761d\",\"#666666\"]\n},Paired: {\n3: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\"],\n4: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\"],\n5: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\"],\n6: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\"],\n7: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\"],\n8: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\"],\n9: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\"],\n10: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\"],\n11: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\",\"#ffff99\"],\n12: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\",\"#ffff99\",\"#b15928\"]\n},Pastel1: {\n3: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\"],\n4: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\"],\n5: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\"],\n6: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\"],\n7: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\"],\n8: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\"#fddaec\"],\n9: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\"#fddaec\",\"#f2f2f2\"]\n},Pastel2: {\n3: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\"],\n4: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\"],\n5: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\"],\n6: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\"],\n7: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\",\"#f1e2cc\"],\n8: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\",\"#f1e2cc\",\"#cccccc\"]\n},Set1: {\n3: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\"],\n4: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\"],\n5: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\"],\n6: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\"],\n7: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\"],\n8: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\",\"#f781bf\"],\n9: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\",\"#f781bf\",\"#999999\"]\n},Set2: {\n3: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\"],\n4: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\"],\n5: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\"],\n6: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\"],\n7: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\",\"#e5c494\"],\n8: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\",\"#e5c494\",\"#b3b3b3\"]\n},Set3: {\n3: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\"],\n4: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\"],\n5: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\"],\n6: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\"],\n7: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\"],\n8: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\"],\n9: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\"],\n10: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\"],\n11: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\",\"#ccebc5\"],\n12: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\",\"#ccebc5\",\"#ffed6f\"]\n}};\n\nif (typeof define === \"function\" && define.amd) {\n    define(colorbrewer);\n} else if (typeof module === \"object\" && module.exports) {\n    module.exports = colorbrewer;\n} else {\n    this.colorbrewer = colorbrewer;\n}\n\n}();\n","module.exports = require('./colorbrewer.js');\n","if (typeof Map === \"undefined\") {\n  Map = function() { this.clear(); };\n  Map.prototype = {\n    set: function(k, v) { this._[k] = v; return this; },\n    get: function(k) { return this._[k]; },\n    has: function(k) { return k in this._; },\n    delete: function(k) { return k in this._ && delete this._[k]; },\n    clear: function() { this._ = Object.create(null); },\n    get size() { var n = 0; for (var k in this._) ++n; return n; },\n    forEach: function(c) { for (var k in this._) c(this._[k], k, this); }\n  };\n} else (function() {\n  var m = new Map;\n  if (m.set(0, 0) !== m) {\n    m = m.set;\n    Map.prototype.set = function() { m.apply(this, arguments); return this; };\n  }\n})();\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.color = {}));\n}(this, function (exports) { 'use strict';\n\n  function deltaHue(h1, h0) {\n    var delta = h1 - h0;\n    return delta > 180 || delta < -180\n        ? delta - 360 * Math.round(delta / 360)\n        : delta;\n  }\n\n  function Color() {}\n\n  var reHex3 = /^#([0-9a-f]{3})$/;\n  var reHex6 = /^#([0-9a-f]{6})$/;\n  var reRgbInteger = /^rgb\\(\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*,\\s*([-+]?\\d+)\\s*\\)$/;\n  var reRgbPercent = /^rgb\\(\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n  var reHslPercent = /^hsl\\(\\s*([-+]?\\d+(?:\\.\\d+)?)\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*,\\s*([-+]?\\d+(?:\\.\\d+)?)%\\s*\\)$/;\n\n  color.prototype = Color.prototype = {\n    displayable: function() {\n      return this.rgb().displayable();\n    },\n    toString: function() {\n      return this.rgb() + \"\";\n    }\n  };\n\n  function color(format) {\n    var m;\n    format = (format + \"\").trim().toLowerCase();\n    return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf))) // #f00\n        : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000\n        : (m = reRgbInteger.exec(format)) ? rgb(m[1], m[2], m[3]) // rgb(255,0,0)\n        : (m = reRgbPercent.exec(format)) ? rgb(m[1] * 2.55, m[2] * 2.55, m[3] * 2.55) // rgb(100%,0%,0%)\n        : (m = reHslPercent.exec(format)) ? hsl(m[1], m[2] * .01, m[3] * .01) // hsl(120,50%,50%)\n        : named.has(format) ? rgbn(named.get(format))\n        : null;\n  }\n\n  function rgbn(n) {\n    return rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff);\n  }\n\n  var named = (new Map)\n      .set(\"aliceblue\", 0xf0f8ff)\n      .set(\"antiquewhite\", 0xfaebd7)\n      .set(\"aqua\", 0x00ffff)\n      .set(\"aquamarine\", 0x7fffd4)\n      .set(\"azure\", 0xf0ffff)\n      .set(\"beige\", 0xf5f5dc)\n      .set(\"bisque\", 0xffe4c4)\n      .set(\"black\", 0x000000)\n      .set(\"blanchedalmond\", 0xffebcd)\n      .set(\"blue\", 0x0000ff)\n      .set(\"blueviolet\", 0x8a2be2)\n      .set(\"brown\", 0xa52a2a)\n      .set(\"burlywood\", 0xdeb887)\n      .set(\"cadetblue\", 0x5f9ea0)\n      .set(\"chartreuse\", 0x7fff00)\n      .set(\"chocolate\", 0xd2691e)\n      .set(\"coral\", 0xff7f50)\n      .set(\"cornflowerblue\", 0x6495ed)\n      .set(\"cornsilk\", 0xfff8dc)\n      .set(\"crimson\", 0xdc143c)\n      .set(\"cyan\", 0x00ffff)\n      .set(\"darkblue\", 0x00008b)\n      .set(\"darkcyan\", 0x008b8b)\n      .set(\"darkgoldenrod\", 0xb8860b)\n      .set(\"darkgray\", 0xa9a9a9)\n      .set(\"darkgreen\", 0x006400)\n      .set(\"darkgrey\", 0xa9a9a9)\n      .set(\"darkkhaki\", 0xbdb76b)\n      .set(\"darkmagenta\", 0x8b008b)\n      .set(\"darkolivegreen\", 0x556b2f)\n      .set(\"darkorange\", 0xff8c00)\n      .set(\"darkorchid\", 0x9932cc)\n      .set(\"darkred\", 0x8b0000)\n      .set(\"darksalmon\", 0xe9967a)\n      .set(\"darkseagreen\", 0x8fbc8f)\n      .set(\"darkslateblue\", 0x483d8b)\n      .set(\"darkslategray\", 0x2f4f4f)\n      .set(\"darkslategrey\", 0x2f4f4f)\n      .set(\"darkturquoise\", 0x00ced1)\n      .set(\"darkviolet\", 0x9400d3)\n      .set(\"deeppink\", 0xff1493)\n      .set(\"deepskyblue\", 0x00bfff)\n      .set(\"dimgray\", 0x696969)\n      .set(\"dimgrey\", 0x696969)\n      .set(\"dodgerblue\", 0x1e90ff)\n      .set(\"firebrick\", 0xb22222)\n      .set(\"floralwhite\", 0xfffaf0)\n      .set(\"forestgreen\", 0x228b22)\n      .set(\"fuchsia\", 0xff00ff)\n      .set(\"gainsboro\", 0xdcdcdc)\n      .set(\"ghostwhite\", 0xf8f8ff)\n      .set(\"gold\", 0xffd700)\n      .set(\"goldenrod\", 0xdaa520)\n      .set(\"gray\", 0x808080)\n      .set(\"green\", 0x008000)\n      .set(\"greenyellow\", 0xadff2f)\n      .set(\"grey\", 0x808080)\n      .set(\"honeydew\", 0xf0fff0)\n      .set(\"hotpink\", 0xff69b4)\n      .set(\"indianred\", 0xcd5c5c)\n      .set(\"indigo\", 0x4b0082)\n      .set(\"ivory\", 0xfffff0)\n      .set(\"khaki\", 0xf0e68c)\n      .set(\"lavender\", 0xe6e6fa)\n      .set(\"lavenderblush\", 0xfff0f5)\n      .set(\"lawngreen\", 0x7cfc00)\n      .set(\"lemonchiffon\", 0xfffacd)\n      .set(\"lightblue\", 0xadd8e6)\n      .set(\"lightcoral\", 0xf08080)\n      .set(\"lightcyan\", 0xe0ffff)\n      .set(\"lightgoldenrodyellow\", 0xfafad2)\n      .set(\"lightgray\", 0xd3d3d3)\n      .set(\"lightgreen\", 0x90ee90)\n      .set(\"lightgrey\", 0xd3d3d3)\n      .set(\"lightpink\", 0xffb6c1)\n      .set(\"lightsalmon\", 0xffa07a)\n      .set(\"lightseagreen\", 0x20b2aa)\n      .set(\"lightskyblue\", 0x87cefa)\n      .set(\"lightslategray\", 0x778899)\n      .set(\"lightslategrey\", 0x778899)\n      .set(\"lightsteelblue\", 0xb0c4de)\n      .set(\"lightyellow\", 0xffffe0)\n      .set(\"lime\", 0x00ff00)\n      .set(\"limegreen\", 0x32cd32)\n      .set(\"linen\", 0xfaf0e6)\n      .set(\"magenta\", 0xff00ff)\n      .set(\"maroon\", 0x800000)\n      .set(\"mediumaquamarine\", 0x66cdaa)\n      .set(\"mediumblue\", 0x0000cd)\n      .set(\"mediumorchid\", 0xba55d3)\n      .set(\"mediumpurple\", 0x9370db)\n      .set(\"mediumseagreen\", 0x3cb371)\n      .set(\"mediumslateblue\", 0x7b68ee)\n      .set(\"mediumspringgreen\", 0x00fa9a)\n      .set(\"mediumturquoise\", 0x48d1cc)\n      .set(\"mediumvioletred\", 0xc71585)\n      .set(\"midnightblue\", 0x191970)\n      .set(\"mintcream\", 0xf5fffa)\n      .set(\"mistyrose\", 0xffe4e1)\n      .set(\"moccasin\", 0xffe4b5)\n      .set(\"navajowhite\", 0xffdead)\n      .set(\"navy\", 0x000080)\n      .set(\"oldlace\", 0xfdf5e6)\n      .set(\"olive\", 0x808000)\n      .set(\"olivedrab\", 0x6b8e23)\n      .set(\"orange\", 0xffa500)\n      .set(\"orangered\", 0xff4500)\n      .set(\"orchid\", 0xda70d6)\n      .set(\"palegoldenrod\", 0xeee8aa)\n      .set(\"palegreen\", 0x98fb98)\n      .set(\"paleturquoise\", 0xafeeee)\n      .set(\"palevioletred\", 0xdb7093)\n      .set(\"papayawhip\", 0xffefd5)\n      .set(\"peachpuff\", 0xffdab9)\n      .set(\"peru\", 0xcd853f)\n      .set(\"pink\", 0xffc0cb)\n      .set(\"plum\", 0xdda0dd)\n      .set(\"powderblue\", 0xb0e0e6)\n      .set(\"purple\", 0x800080)\n      .set(\"rebeccapurple\", 0x663399)\n      .set(\"red\", 0xff0000)\n      .set(\"rosybrown\", 0xbc8f8f)\n      .set(\"royalblue\", 0x4169e1)\n      .set(\"saddlebrown\", 0x8b4513)\n      .set(\"salmon\", 0xfa8072)\n      .set(\"sandybrown\", 0xf4a460)\n      .set(\"seagreen\", 0x2e8b57)\n      .set(\"seashell\", 0xfff5ee)\n      .set(\"sienna\", 0xa0522d)\n      .set(\"silver\", 0xc0c0c0)\n      .set(\"skyblue\", 0x87ceeb)\n      .set(\"slateblue\", 0x6a5acd)\n      .set(\"slategray\", 0x708090)\n      .set(\"slategrey\", 0x708090)\n      .set(\"snow\", 0xfffafa)\n      .set(\"springgreen\", 0x00ff7f)\n      .set(\"steelblue\", 0x4682b4)\n      .set(\"tan\", 0xd2b48c)\n      .set(\"teal\", 0x008080)\n      .set(\"thistle\", 0xd8bfd8)\n      .set(\"tomato\", 0xff6347)\n      .set(\"turquoise\", 0x40e0d0)\n      .set(\"violet\", 0xee82ee)\n      .set(\"wheat\", 0xf5deb3)\n      .set(\"white\", 0xffffff)\n      .set(\"whitesmoke\", 0xf5f5f5)\n      .set(\"yellow\", 0xffff00)\n      .set(\"yellowgreen\", 0x9acd32);\n\n  var darker = .7;\n  var brighter = 1 / darker;\n\n  function rgb(r, g, b) {\n    if (arguments.length === 1) {\n      if (!(r instanceof Color)) r = color(r);\n      if (r) {\n        r = r.rgb();\n        b = r.b;\n        g = r.g;\n        r = r.r;\n      } else {\n        r = g = b = NaN;\n      }\n    }\n    return new Rgb(r, g, b);\n  }\n\n  function Rgb(r, g, b) {\n    this.r = +r;\n    this.g = +g;\n    this.b = +b;\n  }\n\n  var _prototype = rgb.prototype = Rgb.prototype = new Color;\n\n  _prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k);\n  };\n\n  _prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k);\n  };\n\n  _prototype.rgb = function() {\n    return this;\n  };\n\n  _prototype.displayable = function() {\n    return (0 <= this.r && this.r <= 255)\n        && (0 <= this.g && this.g <= 255)\n        && (0 <= this.b && this.b <= 255);\n  };\n\n  _prototype.toString = function() {\n    return format(this.r, this.g, this.b);\n  };\n\n  function format(r, g, b) {\n    return \"#\"\n        + (isNaN(r) ? \"00\" : (r = Math.round(r)) < 16 ? \"0\" + Math.max(0, r).toString(16) : Math.min(255, r).toString(16))\n        + (isNaN(g) ? \"00\" : (g = Math.round(g)) < 16 ? \"0\" + Math.max(0, g).toString(16) : Math.min(255, g).toString(16))\n        + (isNaN(b) ? \"00\" : (b = Math.round(b)) < 16 ? \"0\" + Math.max(0, b).toString(16) : Math.min(255, b).toString(16));\n  }\n\n  function hsl(h, s, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Hsl) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n      } else {\n        if (!(h instanceof Color)) h = color(h);\n        if (h) {\n          if (h instanceof Hsl) return h;\n          h = h.rgb();\n          var r = h.r / 255,\n              g = h.g / 255,\n              b = h.b / 255,\n              min = Math.min(r, g, b),\n              max = Math.max(r, g, b),\n              range = max - min;\n          l = (max + min) / 2;\n          if (range) {\n            s = l < .5 ? range / (max + min) : range / (2 - max - min);\n            if (r === max) h = (g - b) / range + (g < b) * 6;\n            else if (g === max) h = (b - r) / range + 2;\n            else h = (r - g) / range + 4;\n            h *= 60;\n          } else {\n            h = NaN;\n            s = l > 0 && l < 1 ? 0 : h;\n          }\n        } else {\n          h = s = l = NaN;\n        }\n      }\n    }\n    return new Hsl(h, s, l);\n  }\n\n  function Hsl(h, s, l) {\n    this.h = +h;\n    this.s = +s;\n    this.l = +l;\n  }\n\n  var __prototype = hsl.prototype = Hsl.prototype = new Color;\n\n  __prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Hsl(this.h, this.s, this.l * k);\n  };\n\n  __prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Hsl(this.h, this.s, this.l * k);\n  };\n\n  __prototype.rgb = function() {\n    var h = this.h % 360 + (this.h < 0) * 360,\n        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,\n        l = this.l,\n        m2 = l + (l < .5 ? l : 1 - l) * s,\n        m1 = 2 * l - m2;\n    return new Rgb(\n      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),\n      hsl2rgb(h, m1, m2),\n      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2)\n    );\n  };\n\n  __prototype.displayable = function() {\n    return (0 <= this.s && this.s <= 1 || isNaN(this.s))\n        && (0 <= this.l && this.l <= 1);\n  };\n\n  /* From FvD 13.37, CSS Color Module Level 3 */\n  function hsl2rgb(h, m1, m2) {\n    return (h < 60 ? m1 + (m2 - m1) * h / 60\n        : h < 180 ? m2\n        : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60\n        : m1) * 255;\n  }\n\n  var Kn = 18;\n\n  var Xn = 0.950470;\n  var Yn = 1;\n  var Zn = 1.088830;\n  var t0 = 4 / 29;\n  var t1 = 6 / 29;\n  var t2 = 3 * t1 * t1;\n  var t3 = t1 * t1 * t1;\n\n  function lab(l, a, b) {\n    if (arguments.length === 1) {\n      if (l instanceof Lab) {\n        b = l.b;\n        a = l.a;\n        l = l.l;\n      } else if (l instanceof Hcl) {\n        var h = l.h * deg2rad;\n        b = Math.sin(h) * l.c;\n        a = Math.cos(h) * l.c;\n        l = l.l;\n      } else {\n        if (!(l instanceof Rgb)) l = rgb(l);\n        var r = rgb2xyz(l.r),\n            g = rgb2xyz(l.g),\n            b = rgb2xyz(l.b),\n            x = xyz2lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / Xn),\n            y = xyz2lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / Yn),\n            z = xyz2lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / Zn);\n        b = 200 * (y - z);\n        a = 500 * (x - y);\n        l = 116 * y - 16;\n      }\n    }\n    return new Lab(l, a, b);\n  }\n\n  function Lab(l, a, b) {\n    this.l = +l;\n    this.a = +a;\n    this.b = +b;\n  }\n\n  var ___prototype = lab.prototype = Lab.prototype = new Color;\n\n  ___prototype.brighter = function(k) {\n    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b);\n  };\n\n  ___prototype.darker = function(k) {\n    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b);\n  };\n\n  ___prototype.rgb = function() {\n    var y = (this.l + 16) / 116,\n        x = isNaN(this.a) ? y : y + this.a / 500,\n        z = isNaN(this.b) ? y : y - this.b / 200;\n    y = Yn * lab2xyz(y);\n    x = Xn * lab2xyz(x);\n    z = Zn * lab2xyz(z);\n    return new Rgb(\n      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB\n      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),\n      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z)\n    );\n  };\n\n  function xyz2lab(t) {\n    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n  }\n\n  function lab2xyz(t) {\n    return t > t1 ? t * t * t : t2 * (t - t0);\n  }\n\n  function xyz2rgb(x) {\n    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n  }\n\n  function rgb2xyz(x) {\n    return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n  }\n\n  var deg2rad = Math.PI / 180;\n  var rad2deg = 180 / Math.PI;\n\n  function hcl(h, c, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Hcl) {\n        l = h.l;\n        c = h.c;\n        h = h.h;\n      } else {\n        if (!(h instanceof Lab)) h = lab(h);\n        l = h.l;\n        c = Math.sqrt(h.a * h.a + h.b * h.b);\n        h = Math.atan2(h.b, h.a) * rad2deg;\n        if (h < 0) h += 360;\n      }\n    }\n    return new Hcl(h, c, l);\n  }\n\n  function Hcl(h, c, l) {\n    this.h = +h;\n    this.c = +c;\n    this.l = +l;\n  }\n\n  var ____prototype = hcl.prototype = Hcl.prototype = new Color;\n\n  ____prototype.brighter = function(k) {\n    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k));\n  };\n\n  ____prototype.darker = function(k) {\n    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k));\n  };\n\n  ____prototype.rgb = function() {\n    return lab(this).rgb();\n  };\n\n  var A = -0.14861;\n  var B = +1.78277;\n  var C = -0.29227;\n  var D = -0.90649;\n  var E = +1.97294;\n  var ED = E * D;\n  var EB = E * B;\n  var BC_DA = B * C - D * A;\n\n  function cubehelix(h, s, l) {\n    if (arguments.length === 1) {\n      if (h instanceof Cubehelix) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n      } else {\n        if (!(h instanceof Rgb)) h = rgb(h);\n        var r = h.r / 255, g = h.g / 255, b = h.b / 255;\n        l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB);\n        var bl = b - l, k = (E * (g - l) - C * bl) / D;\n        s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)); // NaN if l=0 or l=1\n        h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;\n        if (h < 0) h += 360;\n      }\n    }\n    return new Cubehelix(h, s, l);\n  }\n\n  function Cubehelix(h, s, l) {\n    this.h = +h;\n    this.s = +s;\n    this.l = +l;\n  }\n\n  var prototype = cubehelix.prototype = Cubehelix.prototype = new Color;\n\n  prototype.brighter = function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Cubehelix(this.h, this.s, this.l * k);\n  };\n\n  prototype.darker = function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Cubehelix(this.h, this.s, this.l * k);\n  };\n\n  prototype.rgb = function() {\n    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,\n        l = +this.l,\n        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),\n        cosh = Math.cos(h),\n        sinh = Math.sin(h);\n    return new Rgb(\n      255 * (l + a * (A * cosh + B * sinh)),\n      255 * (l + a * (C * cosh + D * sinh)),\n      255 * (l + a * (E * cosh))\n    );\n  };\n\n  function interpolateCubehelixGamma(gamma) {\n    return function(a, b) {\n      a = cubehelix(a);\n      b = cubehelix(b);\n      var ah = isNaN(a.h) ? b.h : a.h,\n          as = isNaN(a.s) ? b.s : a.s,\n          al = a.l,\n          bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n          bs = isNaN(b.s) ? 0 : b.s - as,\n          bl = b.l - al;\n      return function(t) {\n        a.h = ah + bh * t;\n        a.s = as + bs * t;\n        a.l = al + bl * Math.pow(t, gamma);\n        return a + \"\";\n      };\n    };\n  }\n\n  function interpolateCubehelixGammaLong(gamma) {\n    return function(a, b) {\n      a = cubehelix(a);\n      b = cubehelix(b);\n      var ah = isNaN(a.h) ? b.h : a.h,\n          as = isNaN(a.s) ? b.s : a.s,\n          al = a.l,\n          bh = isNaN(b.h) ? 0 : b.h - ah,\n          bs = isNaN(b.s) ? 0 : b.s - as,\n          bl = b.l - al;\n      return function(t) {\n        a.h = ah + bh * t;\n        a.s = as + bs * t;\n        a.l = al + bl * Math.pow(t, gamma);\n        return a + \"\";\n      };\n    };\n  }\n\n  function interpolateHclLong(a, b) {\n    a = hcl(a);\n    b = hcl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        ac = isNaN(a.c) ? b.c : a.c,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : b.h - ah,\n        bc = isNaN(b.c) ? 0 : b.c - ac,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.c = ac + bc * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHcl(a, b) {\n    a = hcl(a);\n    b = hcl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        ac = isNaN(a.c) ? b.c : a.c,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n        bc = isNaN(b.c) ? 0 : b.c - ac,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.c = ac + bc * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateLab(a, b) {\n    a = lab(a);\n    b = lab(b);\n    var al = a.l,\n        aa = a.a,\n        ab = a.b,\n        bl = b.l - al,\n        ba = b.a - aa,\n        bb = b.b - ab;\n    return function(t) {\n      a.l = al + bl * t;\n      a.a = aa + ba * t;\n      a.b = ab + bb * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHslLong(a, b) {\n    a = hsl(a);\n    b = hsl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : b.h - ah,\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateHsl(a, b) {\n    a = hsl(a);\n    b = hsl(b);\n    var ah = isNaN(a.h) ? b.h : a.h,\n        as = isNaN(a.s) ? b.s : a.s,\n        al = a.l,\n        bh = isNaN(b.h) ? 0 : deltaHue(b.h, ah),\n        bs = isNaN(b.s) ? 0 : b.s - as,\n        bl = b.l - al;\n    return function(t) {\n      a.h = ah + bh * t;\n      a.s = as + bs * t;\n      a.l = al + bl * t;\n      return a + \"\";\n    };\n  }\n\n  function interpolateRgb(a, b) {\n    a = rgb(a);\n    b = rgb(b);\n    var ar = a.r,\n        ag = a.g,\n        ab = a.b,\n        br = b.r - ar,\n        bg = b.g - ag,\n        bb = b.b - ab;\n    return function(t) {\n      return format(Math.round(ar + br * t), Math.round(ag + bg * t), Math.round(ab + bb * t));\n    };\n  }\n\n  exports.interpolateCubehelix = interpolateCubehelixGamma(1);\n  exports.interpolateCubehelixLong = interpolateCubehelixGammaLong(1);\n\n  exports.color = color;\n  exports.rgb = rgb;\n  exports.hsl = hsl;\n  exports.lab = lab;\n  exports.hcl = hcl;\n  exports.cubehelix = cubehelix;\n  exports.interpolateRgb = interpolateRgb;\n  exports.interpolateHsl = interpolateHsl;\n  exports.interpolateHslLong = interpolateHslLong;\n  exports.interpolateLab = interpolateLab;\n  exports.interpolateHcl = interpolateHcl;\n  exports.interpolateHclLong = interpolateHclLong;\n  exports.interpolateCubehelixGamma = interpolateCubehelixGamma;\n  exports.interpolateCubehelixGammaLong = interpolateCubehelixGammaLong;\n\n}));","if (typeof Map === \"undefined\") {\n  Map = function() { this.clear(); };\n  Map.prototype = {\n    set: function(k, v) { this._[k] = v; return this; },\n    get: function(k) { return this._[k]; },\n    has: function(k) { return k in this._; },\n    delete: function(k) { return k in this._ && delete this._[k]; },\n    clear: function() { this._ = Object.create(null); },\n    get size() { var n = 0; for (var k in this._) ++n; return n; },\n    forEach: function(c) { for (var k in this._) c(this._[k], k, this); }\n  };\n} else (function() {\n  var m = new Map;\n  if (m.set(0, 0) !== m) {\n    m = m.set;\n    Map.prototype.set = function() { m.apply(this, arguments); return this; };\n  }\n})();\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.format = {}));\n}(this, function (exports) { 'use strict';\n\n  var zhCn = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  };\n\n  var ruRu = {\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0.\"]\n  };\n\n  var ptBr = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"R$\", \"\"]\n  };\n\n  var plPl = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"z\"]\n  };\n\n  var nlNl = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\\xa0\", \"\"]\n  };\n\n  var mkMk = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0.\"]\n  };\n\n  var itIt = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  };\n\n  var heIl = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  };\n\n  var frFr = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  };\n\n  var frCa = {\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"$\"]\n  };\n\n  var fiFi = {\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  };\n\n  var esEs = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  };\n\n  var enUs = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"$\", \"\"]\n  };\n\n  var enGb = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  };\n\n  var enCa = {\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"$\", \"\"]\n  };\n\n  var deDe = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  };\n\n  var caEs = {\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  };\n\n\n  // Computes the decimal coefficient and exponent of the specified number x with\n  // significant digits p, where x is positive and p is in [1, 21] or undefined.\n  // For example, formatDecimal(1.23) returns [\"123\", 0].\n  function formatDecimal(x, p) {\n    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, Infinity\n    var i, coefficient = x.slice(0, i);\n\n    // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n    // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n    return [\n      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n      +x.slice(i + 1)\n    ];\n  }\n\n  function exponent(x) {\n    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;\n  }\n\n  var prefixExponent;\n\n  function formatPrefixAuto(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1],\n        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n        n = coefficient.length;\n    return i === n ? coefficient\n        : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n        : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n        : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimal(x, p + i - 1)[0]; // less than 1y!\n  }\n\n  function formatRounded(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1];\n    return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n        : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n  }\n\n  function formatDefault(x, p) {\n    x = x.toPrecision(p);\n\n    out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {\n      switch (x[i]) {\n        case \".\": i0 = i1 = i; break;\n        case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n        case \"e\": break out;\n        default: if (i0 > 0) i0 = 0; break;\n      }\n    }\n\n    return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;\n  }\n\n  var formatTypes = {\n    \"\": formatDefault,\n    \"%\": function(x, p) { return (x * 100).toFixed(p); },\n    \"b\": function(x) { return Math.round(x).toString(2); },\n    \"c\": function(x) { return x + \"\"; },\n    \"d\": function(x) { return Math.round(x).toString(10); },\n    \"e\": function(x, p) { return x.toExponential(p); },\n    \"f\": function(x, p) { return x.toFixed(p); },\n    \"g\": function(x, p) { return x.toPrecision(p); },\n    \"o\": function(x) { return Math.round(x).toString(8); },\n    \"p\": function(x, p) { return formatRounded(x * 100, p); },\n    \"r\": formatRounded,\n    \"s\": formatPrefixAuto,\n    \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n    \"x\": function(x) { return Math.round(x).toString(16); }\n  };\n\n\n  // [[fill]align][sign][symbol][0][width][,][.precision][type]\n  var re = /^(?:(.)?([<>=^]))?([+\\-\\( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?([a-z%])?$/i;\n\n  function formatSpecifier(specifier) {\n    return new FormatSpecifier(specifier);\n  }\n\n  function FormatSpecifier(specifier) {\n    if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n\n    var match,\n        fill = match[1] || \" \",\n        align = match[2] || \">\",\n        sign = match[3] || \"-\",\n        symbol = match[4] || \"\",\n        zero = !!match[5],\n        width = match[6] && +match[6],\n        comma = !!match[7],\n        precision = match[8] && +match[8].slice(1),\n        type = match[9] || \"\";\n\n    // The \"n\" type is an alias for \",g\".\n    if (type === \"n\") comma = true, type = \"g\";\n\n    // Map invalid types to the default format.\n    else if (!formatTypes[type]) type = \"\";\n\n    // If zero fill is specified, padding goes after sign and before digits.\n    if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n    this.fill = fill;\n    this.align = align;\n    this.sign = sign;\n    this.symbol = symbol;\n    this.zero = zero;\n    this.width = width;\n    this.comma = comma;\n    this.precision = precision;\n    this.type = type;\n  }\n\n  FormatSpecifier.prototype.toString = function() {\n    return this.fill\n        + this.align\n        + this.sign\n        + this.symbol\n        + (this.zero ? \"0\" : \"\")\n        + (this.width == null ? \"\" : Math.max(1, this.width | 0))\n        + (this.comma ? \",\" : \"\")\n        + (this.precision == null ? \"\" : \".\" + Math.max(0, this.precision | 0))\n        + this.type;\n  };\n\n  function formatGroup(grouping, thousands) {\n    return function(value, width) {\n      var i = value.length,\n          t = [],\n          j = 0,\n          g = grouping[0],\n          length = 0;\n\n      while (i > 0 && g > 0) {\n        if (length + g + 1 > width) g = Math.max(1, width - length);\n        t.push(value.substring(i -= g, i + g));\n        if ((length += g + 1) > width) break;\n        g = grouping[j = (j + 1) % grouping.length];\n      }\n\n      return t.reverse().join(thousands);\n    };\n  }\n\n  var prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\n  function identity(x) {\n    return x;\n  }\n\n  function locale(locale) {\n    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,\n        currency = locale.currency,\n        decimal = locale.decimal;\n\n    function format(specifier) {\n      specifier = formatSpecifier(specifier);\n\n      var fill = specifier.fill,\n          align = specifier.align,\n          sign = specifier.sign,\n          symbol = specifier.symbol,\n          zero = specifier.zero,\n          width = specifier.width,\n          comma = specifier.comma,\n          precision = specifier.precision,\n          type = specifier.type;\n\n      // Compute the prefix and suffix.\n      // For SI-prefix, the suffix is lazily computed.\n      var prefix = symbol === \"$\" ? currency[0] : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n          suffix = symbol === \"$\" ? currency[1] : /[%p]/.test(type) ? \"%\" : \"\";\n\n      // What format function should we use?\n      // Is this an integer type?\n      // Can this type generate exponential notation?\n      var formatType = formatTypes[type],\n          maybeSuffix = !type || /[defgprs%]/.test(type);\n\n      // Set the default precision if not specified,\n      // or clamp the specified precision to the supported range.\n      // For significant precision, it must be in [1, 21].\n      // For fixed precision, it must be in [0, 20].\n      precision = precision == null ? (type ? 6 : 12)\n          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n          : Math.max(0, Math.min(20, precision));\n\n      return function(value) {\n        var valuePrefix = prefix,\n            valueSuffix = suffix;\n\n        if (type === \"c\") {\n          valueSuffix = formatType(value) + valueSuffix;\n          value = \"\";\n        } else {\n          value = +value;\n\n          // Convert negative to positive, and compute the prefix.\n          // Note that -0 is not less than 0, but 1 / -0 is!\n          var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);\n\n          // Perform the initial formatting.\n          value = formatType(value, precision);\n\n          // Compute the prefix and suffix.\n          valuePrefix = (valueNegative ? (sign === \"(\" ? sign : \"-\") : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n          valueSuffix = valueSuffix + (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n          // Break the formatted value into the integer value part that can be\n          // grouped, and fractional or exponential suffix part that is not.\n          if (maybeSuffix) {\n            var i = -1, n = value.length, c;\n            while (++i < n) {\n              if (c = value.charCodeAt(i), 48 > c || c > 57) {\n                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n                value = value.slice(0, i);\n                break;\n              }\n            }\n          }\n        }\n\n        // If the fill character is not \"0\", grouping is applied before padding.\n        if (comma && !zero) value = group(value, Infinity);\n\n        // Compute the padding.\n        var length = valuePrefix.length + value.length + valueSuffix.length,\n            padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n        // If the fill character is \"0\", grouping is applied after padding.\n        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n        // Reconstruct the final output based on the desired alignment.\n        switch (align) {\n          case \"<\": return valuePrefix + value + valueSuffix + padding;\n          case \"=\": return valuePrefix + padding + value + valueSuffix;\n          case \"^\": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);\n        }\n        return padding + valuePrefix + value + valueSuffix;\n      };\n    }\n\n    function formatPrefix(specifier, value) {\n      var f = format((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,\n          k = Math.pow(10, -e),\n          prefix = prefixes[8 + e / 3];\n      return function(value) {\n        return f(k * value) + prefix;\n      };\n    }\n\n    return {\n      format: format,\n      formatPrefix: formatPrefix\n    };\n  }\n\n  function precisionRound(step, max) {\n    return Math.max(0, exponent(Math.abs(max)) - exponent(Math.abs(step))) + 1;\n  }\n\n  function precisionPrefix(step, value) {\n    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));\n  }\n\n  function precisionFixed(step) {\n    return Math.max(0, -exponent(Math.abs(step)));\n  }\n\n  var localeDefinitions = (new Map)\n      .set(\"ca-ES\", caEs)\n      .set(\"de-DE\", deDe)\n      .set(\"en-CA\", enCa)\n      .set(\"en-GB\", enGb)\n      .set(\"en-US\", enUs)\n      .set(\"es-ES\", esEs)\n      .set(\"fi-FI\", fiFi)\n      .set(\"fr-CA\", frCa)\n      .set(\"fr-FR\", frFr)\n      .set(\"he-IL\", heIl)\n      .set(\"it-IT\", itIt)\n      .set(\"mk-MK\", mkMk)\n      .set(\"nl-NL\", nlNl)\n      .set(\"pl-PL\", plPl)\n      .set(\"pt-BR\", ptBr)\n      .set(\"ru-RU\", ruRu)\n      .set(\"zh-CN\", zhCn);\n\n  var defaultLocale = locale(enUs);\n  exports.format = defaultLocale.format;\n  exports.formatPrefix = defaultLocale.formatPrefix;\n\n  function localeFormat(definition) {\n    if (typeof definition === \"string\") {\n      definition = localeDefinitions.get(definition);\n      if (!definition) return null;\n    }\n    return locale(definition);\n  }\n  ;\n\n  exports.localeFormat = localeFormat;\n  exports.formatSpecifier = formatSpecifier;\n  exports.precisionFixed = precisionFixed;\n  exports.precisionPrefix = precisionPrefix;\n  exports.precisionRound = precisionRound;\n\n}));","if (typeof Map === \"undefined\") {\n  Map = function() { this.clear(); };\n  Map.prototype = {\n    set: function(k, v) { this._[k] = v; return this; },\n    get: function(k) { return this._[k]; },\n    has: function(k) { return k in this._; },\n    delete: function(k) { return k in this._ && delete this._[k]; },\n    clear: function() { this._ = Object.create(null); },\n    get size() { var n = 0; for (var k in this._) ++n; return n; },\n    forEach: function(c) { for (var k in this._) c(this._[k], k, this); }\n  };\n} else (function() {\n  var m = new Map;\n  if (m.set(0, 0) !== m) {\n    m = m.set;\n    Map.prototype.set = function() { m.apply(this, arguments); return this; };\n  }\n})();\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.timeFormat = {}));\n}(this, function (exports) { 'use strict';\n\n  var zhCn = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%Y/%-m/%-d\",\n    time: \"%H:%M:%S\",\n    periods: [\"\", \"\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  };\n\n  var ruRu = {\n    dateTime: \"%A, %e %B %Y . %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  };\n\n  var ptBr = {\n    dateTime: \"%A, %e de %B de %Y. %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Domingo\", \"Segunda\", \"Tera\", \"Quarta\", \"Quinta\", \"Sexta\", \"Sbado\"],\n    shortDays: [\"Dom\", \"Seg\", \"Ter\", \"Qua\", \"Qui\", \"Sex\", \"Sb\"],\n    months: [\"Janeiro\", \"Fevereiro\", \"Maro\", \"Abril\", \"Maio\", \"Junho\", \"Julho\", \"Agosto\", \"Setembro\", \"Outubro\", \"Novembro\", \"Dezembro\"],\n    shortMonths: [\"Jan\", \"Fev\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\"]\n  };\n\n  var plPl = {\n    dateTime: \"%A, %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Niedziela\", \"Poniedziaek\", \"Wtorek\", \"roda\", \"Czwartek\", \"Pitek\", \"Sobota\"],\n    shortDays: [\"Niedz.\", \"Pon.\", \"Wt.\", \"r.\", \"Czw.\", \"Pt.\", \"Sob.\"],\n    months: [\"Stycze\", \"Luty\", \"Marzec\", \"Kwiecie\", \"Maj\", \"Czerwiec\", \"Lipiec\", \"Sierpie\", \"Wrzesie\", \"Padziernik\", \"Listopad\", \"Grudzie\"],\n    shortMonths: [\"Stycz.\", \"Luty\", \"Marz.\", \"Kwie.\", \"Maj\", \"Czerw.\", \"Lipc.\", \"Sierp.\", \"Wrz.\", \"Padz.\", \"Listop.\", \"Grudz.\"]/* In Polish language abbraviated months are not commonly used so there is a dispute about the proper abbraviations. */\n  };\n\n  var nlNl = {\n    dateTime: \"%a %e %B %Y %T\",\n    date: \"%d-%m-%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"zondag\", \"maandag\", \"dinsdag\", \"woensdag\", \"donderdag\", \"vrijdag\", \"zaterdag\"],\n    shortDays: [\"zo\", \"ma\", \"di\", \"wo\", \"do\", \"vr\", \"za\"],\n    months: [\"januari\", \"februari\", \"maart\", \"april\", \"mei\", \"juni\", \"juli\", \"augustus\", \"september\", \"oktober\", \"november\", \"december\"],\n    shortMonths: [\"jan\", \"feb\", \"mrt\", \"apr\", \"mei\", \"jun\", \"jul\", \"aug\", \"sep\", \"okt\", \"nov\", \"dec\"]\n  };\n\n  var mkMk = {\n    dateTime: \"%A, %e %B %Y . %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  };\n\n  var itIt = {\n    dateTime: \"%A %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Domenica\", \"Luned\", \"Marted\", \"Mercoled\", \"Gioved\", \"Venerd\", \"Sabato\"],\n    shortDays: [\"Dom\", \"Lun\", \"Mar\", \"Mer\", \"Gio\", \"Ven\", \"Sab\"],\n    months: [\"Gennaio\", \"Febbraio\", \"Marzo\", \"Aprile\", \"Maggio\", \"Giugno\", \"Luglio\", \"Agosto\", \"Settembre\", \"Ottobre\", \"Novembre\", \"Dicembre\"],\n    shortMonths: [\"Gen\", \"Feb\", \"Mar\", \"Apr\", \"Mag\", \"Giu\", \"Lug\", \"Ago\", \"Set\", \"Ott\", \"Nov\", \"Dic\"]\n  };\n\n  var heIl = {\n    dateTime: \"%A, %e %B %Y %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  };\n\n  var frFr = {\n    dateTime: \"%A, le %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"],\n    shortDays: [\"dim.\", \"lun.\", \"mar.\", \"mer.\", \"jeu.\", \"ven.\", \"sam.\"],\n    months: [\"janvier\", \"fvrier\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"aot\", \"septembre\", \"octobre\", \"novembre\", \"dcembre\"],\n    shortMonths: [\"janv.\", \"fvr.\", \"mars\", \"avr.\", \"mai\", \"juin\", \"juil.\", \"aot\", \"sept.\", \"oct.\", \"nov.\", \"dc.\"]\n  };\n\n  var frCa = {\n    dateTime: \"%a %e %b %Y %X\",\n    date: \"%Y-%m-%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"\", \"\"],\n    days: [\"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"],\n    shortDays: [\"dim\", \"lun\", \"mar\", \"mer\", \"jeu\", \"ven\", \"sam\"],\n    months: [\"janvier\", \"fvrier\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"aot\", \"septembre\", \"octobre\", \"novembre\", \"dcembre\"],\n    shortMonths: [\"jan\", \"fv\", \"mar\", \"avr\", \"mai\", \"jui\", \"jul\", \"ao\", \"sep\", \"oct\", \"nov\", \"dc\"]\n  };\n\n  var fiFi = {\n    dateTime: \"%A, %-d. %Bta %Y klo %X\",\n    date: \"%-d.%-m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"a.m.\", \"p.m.\"],\n    days: [\"sunnuntai\", \"maanantai\", \"tiistai\", \"keskiviikko\", \"torstai\", \"perjantai\", \"lauantai\"],\n    shortDays: [\"Su\", \"Ma\", \"Ti\", \"Ke\", \"To\", \"Pe\", \"La\"],\n    months: [\"tammikuu\", \"helmikuu\", \"maaliskuu\", \"huhtikuu\", \"toukokuu\", \"keskuu\", \"heinkuu\", \"elokuu\", \"syyskuu\", \"lokakuu\", \"marraskuu\", \"joulukuu\"],\n    shortMonths: [\"Tammi\", \"Helmi\", \"Maalis\", \"Huhti\", \"Touko\", \"Kes\", \"Hein\", \"Elo\", \"Syys\", \"Loka\", \"Marras\", \"Joulu\"]\n  };\n\n  var esEs = {\n    dateTime: \"%A, %e de %B de %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"domingo\", \"lunes\", \"martes\", \"mircoles\", \"jueves\", \"viernes\", \"sbado\"],\n    shortDays: [\"dom\", \"lun\", \"mar\", \"mi\", \"jue\", \"vie\", \"sb\"],\n    months: [\"enero\", \"febrero\", \"marzo\", \"abril\", \"mayo\", \"junio\", \"julio\", \"agosto\", \"septiembre\", \"octubre\", \"noviembre\", \"diciembre\"],\n    shortMonths: [\"ene\", \"feb\", \"mar\", \"abr\", \"may\", \"jun\", \"jul\", \"ago\", \"sep\", \"oct\", \"nov\", \"dic\"]\n  };\n\n  var enUs = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%m/%d/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var enGb = {\n    dateTime: \"%a %e %b %X %Y\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var enCa = {\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%Y-%m-%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  };\n\n  var deDe = {\n    dateTime: \"%A, der %e. %B %Y, %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Sonntag\", \"Montag\", \"Dienstag\", \"Mittwoch\", \"Donnerstag\", \"Freitag\", \"Samstag\"],\n    shortDays: [\"So\", \"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\", \"Sa\"],\n    months: [\"Januar\", \"Februar\", \"Mrz\", \"April\", \"Mai\", \"Juni\", \"Juli\", \"August\", \"September\", \"Oktober\", \"November\", \"Dezember\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mrz\", \"Apr\", \"Mai\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dez\"]\n  };\n\n  var caEs = {\n    dateTime: \"%A, %e de %B de %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"diumenge\", \"dilluns\", \"dimarts\", \"dimecres\", \"dijous\", \"divendres\", \"dissabte\"],\n    shortDays: [\"dg.\", \"dl.\", \"dt.\", \"dc.\", \"dj.\", \"dv.\", \"ds.\"],\n    months: [\"gener\", \"febrer\", \"mar\", \"abril\", \"maig\", \"juny\", \"juliol\", \"agost\", \"setembre\", \"octubre\", \"novembre\", \"desembre\"],\n    shortMonths: [\"gen.\", \"febr.\", \"mar\", \"abr.\", \"maig\", \"juny\", \"jul.\", \"ag.\", \"set.\", \"oct.\", \"nov.\", \"des.\"]\n  };\n\n  var t0 = new Date;\n  var t1 = new Date;\n\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  }\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var sunday = weekday(0);\n  var monday = weekday(1);\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcSunday = utcWeekday(0);\n  var utcMonday = utcWeekday(1);\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  function localDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n      date.setFullYear(d.y);\n      return date;\n    }\n    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n  }\n\n  function utcDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n      date.setUTCFullYear(d.y);\n      return date;\n    }\n    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n  }\n\n  function newYear(y) {\n    return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};\n  }\n\n  function locale(locale) {\n    var locale_dateTime = locale.dateTime,\n        locale_date = locale.date,\n        locale_time = locale.time,\n        locale_periods = locale.periods,\n        locale_weekdays = locale.days,\n        locale_shortWeekdays = locale.shortDays,\n        locale_months = locale.months,\n        locale_shortMonths = locale.shortMonths;\n\n    var periodLookup = formatLookup(locale_periods),\n        weekdayRe = formatRe(locale_weekdays),\n        weekdayLookup = formatLookup(locale_weekdays),\n        shortWeekdayRe = formatRe(locale_shortWeekdays),\n        shortWeekdayLookup = formatLookup(locale_shortWeekdays),\n        monthRe = formatRe(locale_months),\n        monthLookup = formatLookup(locale_months),\n        shortMonthRe = formatRe(locale_shortMonths),\n        shortMonthLookup = formatLookup(locale_shortMonths);\n\n    var formats = {\n      \"a\": formatShortWeekday,\n      \"A\": formatWeekday,\n      \"b\": formatShortMonth,\n      \"B\": formatMonth,\n      \"c\": null,\n      \"d\": formatDayOfMonth,\n      \"e\": formatDayOfMonth,\n      \"H\": formatHour24,\n      \"I\": formatHour12,\n      \"j\": formatDayOfYear,\n      \"L\": formatMilliseconds,\n      \"m\": formatMonthNumber,\n      \"M\": formatMinutes,\n      \"p\": formatPeriod,\n      \"S\": formatSeconds,\n      \"U\": formatWeekNumberSunday,\n      \"w\": formatWeekdayNumber,\n      \"W\": formatWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatYear,\n      \"Y\": formatFullYear,\n      \"Z\": formatZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var utcFormats = {\n      \"a\": formatUTCShortWeekday,\n      \"A\": formatUTCWeekday,\n      \"b\": formatUTCShortMonth,\n      \"B\": formatUTCMonth,\n      \"c\": null,\n      \"d\": formatUTCDayOfMonth,\n      \"e\": formatUTCDayOfMonth,\n      \"H\": formatUTCHour24,\n      \"I\": formatUTCHour12,\n      \"j\": formatUTCDayOfYear,\n      \"L\": formatUTCMilliseconds,\n      \"m\": formatUTCMonthNumber,\n      \"M\": formatUTCMinutes,\n      \"p\": formatUTCPeriod,\n      \"S\": formatUTCSeconds,\n      \"U\": formatUTCWeekNumberSunday,\n      \"w\": formatUTCWeekdayNumber,\n      \"W\": formatUTCWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatUTCYear,\n      \"Y\": formatUTCFullYear,\n      \"Z\": formatUTCZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var parses = {\n      \"a\": parseShortWeekday,\n      \"A\": parseWeekday,\n      \"b\": parseShortMonth,\n      \"B\": parseMonth,\n      \"c\": parseLocaleDateTime,\n      \"d\": parseDayOfMonth,\n      \"e\": parseDayOfMonth,\n      \"H\": parseHour24,\n      \"I\": parseHour24,\n      \"j\": parseDayOfYear,\n      \"L\": parseMilliseconds,\n      \"m\": parseMonthNumber,\n      \"M\": parseMinutes,\n      \"p\": parsePeriod,\n      \"S\": parseSeconds,\n      \"U\": parseWeekNumberSunday,\n      \"w\": parseWeekdayNumber,\n      \"W\": parseWeekNumberMonday,\n      \"x\": parseLocaleDate,\n      \"X\": parseLocaleTime,\n      \"y\": parseYear,\n      \"Y\": parseFullYear,\n      \"Z\": parseZone,\n      \"%\": parseLiteralPercent\n    };\n\n    // These recursive directive definitions must be deferred.\n    formats.x = newFormat(locale_date, formats);\n    formats.X = newFormat(locale_time, formats);\n    formats.c = newFormat(locale_dateTime, formats);\n    utcFormats.x = newFormat(locale_date, utcFormats);\n    utcFormats.X = newFormat(locale_time, utcFormats);\n    utcFormats.c = newFormat(locale_dateTime, utcFormats);\n\n    function newFormat(specifier, formats) {\n      return function(date) {\n        var string = [],\n            i = -1,\n            j = 0,\n            n = specifier.length,\n            c,\n            pad,\n            format;\n\n        while (++i < n) {\n          if (specifier.charCodeAt(i) === 37) {\n            string.push(specifier.slice(j, i));\n            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);\n            if (format = formats[c]) c = format(date, pad == null ? (c === \"e\" ? \" \" : \"0\") : pad);\n            string.push(c);\n            j = i + 1;\n          }\n        }\n\n        string.push(specifier.slice(j, i));\n        return string.join(\"\");\n      };\n    }\n\n    function newParse(specifier, newDate) {\n      return function(string) {\n        var d = newYear(1900),\n            i = parseSpecifier(d, specifier, string, 0);\n        if (i != string.length) return null;\n\n        // The am-pm flag is 0 for AM, and 1 for PM.\n        if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\n        // If a time zone is specified, all fields are interpreted as UTC and then\n        // offset according to the specified time zone.\n        if (\"Z\" in d) {\n          if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n            var day = utcDate(newYear(d.y)).getUTCDay();\n            if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n            d.m = 0;\n            d.d = d.w + d.U * 7 - (day + 6) % 7;\n          }\n          d.H += d.Z / 100 | 0;\n          d.M += d.Z % 100;\n          return utcDate(d);\n        }\n\n        // Otherwise, all fields are in local time.\n        if (\"w\" in d && (\"W\" in d || \"U\" in d)) {\n          var day = newDate(newYear(d.y)).getDay();\n          if (\"W\" in d) d.U = d.W, d.w = (d.w + 6) % 7, --day;\n          d.m = 0;\n          d.d = d.w + d.U * 7 - (day + 6) % 7;\n        }\n        return newDate(d);\n      };\n    }\n\n    function parseSpecifier(d, specifier, string, j) {\n      var i = 0,\n          n = specifier.length,\n          m = string.length,\n          c,\n          parse;\n\n      while (i < n) {\n        if (j >= m) return -1;\n        c = specifier.charCodeAt(i++);\n        if (c === 37) {\n          c = specifier.charAt(i++);\n          parse = parses[c in pads ? specifier.charAt(i++) : c];\n          if (!parse || ((j = parse(d, string, j)) < 0)) return -1;\n        } else if (c != string.charCodeAt(j++)) {\n          return -1;\n        }\n      }\n\n      return j;\n    }\n\n    function parseShortWeekday(d, string, i) {\n      var n = shortWeekdayRe.exec(string.slice(i));\n      return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseWeekday(d, string, i) {\n      var n = weekdayRe.exec(string.slice(i));\n      return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseShortMonth(d, string, i) {\n      var n = shortMonthRe.exec(string.slice(i));\n      return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseMonth(d, string, i) {\n      var n = monthRe.exec(string.slice(i));\n      return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n\n    function parseLocaleDateTime(d, string, i) {\n      return parseSpecifier(d, locale_dateTime, string, i);\n    }\n\n    function parseLocaleDate(d, string, i) {\n      return parseSpecifier(d, locale_date, string, i);\n    }\n\n    function parseLocaleTime(d, string, i) {\n      return parseSpecifier(d, locale_time, string, i);\n    }\n\n    function parsePeriod(d, string, i) {\n      var n = periodLookup.get(string.slice(i, i += 2).toLowerCase());\n      return n == null ? -1 : (d.p = n, i);\n    }\n\n    function formatShortWeekday(d) {\n      return locale_shortWeekdays[d.getDay()];\n    }\n\n    function formatWeekday(d) {\n      return locale_weekdays[d.getDay()];\n    }\n\n    function formatShortMonth(d) {\n      return locale_shortMonths[d.getMonth()];\n    }\n\n    function formatMonth(d) {\n      return locale_months[d.getMonth()];\n    }\n\n    function formatPeriod(d) {\n      return locale_periods[+(d.getHours() >= 12)];\n    }\n\n    function formatUTCShortWeekday(d) {\n      return locale_shortWeekdays[d.getUTCDay()];\n    }\n\n    function formatUTCWeekday(d) {\n      return locale_weekdays[d.getUTCDay()];\n    }\n\n    function formatUTCShortMonth(d) {\n      return locale_shortMonths[d.getUTCMonth()];\n    }\n\n    function formatUTCMonth(d) {\n      return locale_months[d.getUTCMonth()];\n    }\n\n    function formatUTCPeriod(d) {\n      return locale_periods[+(d.getUTCHours() >= 12)];\n    }\n\n    return {\n      format: function(specifier) {\n        var f = newFormat(specifier += \"\", formats);\n        f.parse = newParse(specifier, localDate);\n        f.toString = function() { return specifier; };\n        return f;\n      },\n      utcFormat: function(specifier) {\n        var f = newFormat(specifier += \"\", utcFormats);\n        f.parse = newParse(specifier, utcDate);\n        f.toString = function() { return specifier; };\n        return f;\n      }\n    };\n  }\n\n  var pads = {\"-\": \"\", \"_\": \" \", \"0\": \"0\"};\n  var numberRe = /^\\s*\\d+/;\n  var percentRe = /^%/;\n  var requoteRe = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\n  function pad(value, fill, width) {\n    var sign = value < 0 ? \"-\" : \"\",\n        string = (sign ? -value : value) + \"\",\n        length = string.length;\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n  }\n\n  function requote(s) {\n    return s.replace(requoteRe, \"\\\\$&\");\n  }\n\n  function formatRe(names) {\n    return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n  }\n\n  function formatLookup(names) {\n    var map = new Map, i = -1, n = names.length;\n    while (++i < n) map.set(names[i].toLowerCase(), i);\n    return map;\n  }\n\n  function parseWeekdayNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 1));\n    return n ? (d.w = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberSunday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.U = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberMonday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.W = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseFullYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 4));\n    return n ? (d.y = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n  }\n\n  function parseZone(d, string, i) {\n    return /^[+-]\\d{4}$/.test(string = string.slice(i, i + 5))\n        ? (d.Z = -string, i + 5) // sign differs from getTimezoneOffset!\n        : -1;\n  }\n\n  function parseMonthNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n  }\n\n  function parseDayOfMonth(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseDayOfYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseHour24(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.H = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMinutes(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.M = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseSeconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.S = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMilliseconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.L = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseLiteralPercent(d, string, i) {\n    var n = percentRe.exec(string.slice(i, i + 1));\n    return n ? i + n[0].length : -1;\n  }\n\n  function formatDayOfMonth(d, p) {\n    return pad(d.getDate(), p, 2);\n  }\n\n  function formatHour24(d, p) {\n    return pad(d.getHours(), p, 2);\n  }\n\n  function formatHour12(d, p) {\n    return pad(d.getHours() % 12 || 12, p, 2);\n  }\n\n  function formatDayOfYear(d, p) {\n    return pad(1 + day.count(year(d), d), p, 3);\n  }\n\n  function formatMilliseconds(d, p) {\n    return pad(d.getMilliseconds(), p, 3);\n  }\n\n  function formatMonthNumber(d, p) {\n    return pad(d.getMonth() + 1, p, 2);\n  }\n\n  function formatMinutes(d, p) {\n    return pad(d.getMinutes(), p, 2);\n  }\n\n  function formatSeconds(d, p) {\n    return pad(d.getSeconds(), p, 2);\n  }\n\n  function formatWeekNumberSunday(d, p) {\n    return pad(sunday.count(year(d), d), p, 2);\n  }\n\n  function formatWeekdayNumber(d) {\n    return d.getDay();\n  }\n\n  function formatWeekNumberMonday(d, p) {\n    return pad(monday.count(year(d), d), p, 2);\n  }\n\n  function formatYear(d, p) {\n    return pad(d.getFullYear() % 100, p, 2);\n  }\n\n  function formatFullYear(d, p) {\n    return pad(d.getFullYear() % 10000, p, 4);\n  }\n\n  function formatZone(d) {\n    var z = d.getTimezoneOffset();\n    return (z > 0 ? \"-\" : (z *= -1, \"+\"))\n        + pad(z / 60 | 0, \"0\", 2)\n        + pad(z % 60, \"0\", 2);\n  }\n\n  function formatUTCDayOfMonth(d, p) {\n    return pad(d.getUTCDate(), p, 2);\n  }\n\n  function formatUTCHour24(d, p) {\n    return pad(d.getUTCHours(), p, 2);\n  }\n\n  function formatUTCHour12(d, p) {\n    return pad(d.getUTCHours() % 12 || 12, p, 2);\n  }\n\n  function formatUTCDayOfYear(d, p) {\n    return pad(1 + utcDay.count(utcYear(d), d), p, 3);\n  }\n\n  function formatUTCMilliseconds(d, p) {\n    return pad(d.getUTCMilliseconds(), p, 3);\n  }\n\n  function formatUTCMonthNumber(d, p) {\n    return pad(d.getUTCMonth() + 1, p, 2);\n  }\n\n  function formatUTCMinutes(d, p) {\n    return pad(d.getUTCMinutes(), p, 2);\n  }\n\n  function formatUTCSeconds(d, p) {\n    return pad(d.getUTCSeconds(), p, 2);\n  }\n\n  function formatUTCWeekNumberSunday(d, p) {\n    return pad(utcSunday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCWeekdayNumber(d) {\n    return d.getUTCDay();\n  }\n\n  function formatUTCWeekNumberMonday(d, p) {\n    return pad(utcMonday.count(utcYear(d), d), p, 2);\n  }\n\n  function formatUTCYear(d, p) {\n    return pad(d.getUTCFullYear() % 100, p, 2);\n  }\n\n  function formatUTCFullYear(d, p) {\n    return pad(d.getUTCFullYear() % 10000, p, 4);\n  }\n\n  function formatUTCZone() {\n    return \"+0000\";\n  }\n\n  function formatLiteralPercent() {\n    return \"%\";\n  }\n\n  var isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\n\n  function formatIsoNative(date) {\n    return date.toISOString();\n  }\n\n  formatIsoNative.parse = function(string) {\n    var date = new Date(string);\n    return isNaN(date) ? null : date;\n  };\n\n  formatIsoNative.toString = function() {\n    return isoSpecifier;\n  };\n\n  var formatIso = Date.prototype.toISOString && +new Date(\"2000-01-01T00:00:00.000Z\")\n      ? formatIsoNative\n      : enUs.utcFormat(isoSpecifier);\n\n  var isoFormat = formatIso;\n\n  var localeDefinitions = (new Map)\n      .set(\"ca-ES\", caEs)\n      .set(\"de-DE\", deDe)\n      .set(\"en-CA\", enCa)\n      .set(\"en-GB\", enGb)\n      .set(\"en-US\", enUs)\n      .set(\"es-ES\", esEs)\n      .set(\"fi-FI\", fiFi)\n      .set(\"fr-CA\", frCa)\n      .set(\"fr-FR\", frFr)\n      .set(\"he-IL\", heIl)\n      .set(\"it-IT\", itIt)\n      .set(\"mk-MK\", mkMk)\n      .set(\"nl-NL\", nlNl)\n      .set(\"pl-PL\", plPl)\n      .set(\"pt-BR\", ptBr)\n      .set(\"ru-RU\", ruRu)\n      .set(\"zh-CN\", zhCn);\n\n  var defaultLocale = locale(enUs);\n  exports.format = defaultLocale.format;\n  exports.utcFormat = defaultLocale.utcFormat;\n\n  function localeFormat(definition) {\n    if (typeof definition === \"string\") {\n      definition = localeDefinitions.get(definition);\n      if (!definition) return null;\n    }\n    return locale(definition);\n  }\n  ;\n\n  exports.localeFormat = localeFormat;\n  exports.isoFormat = isoFormat;\n\n}));","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  factory((global.time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t1 = new Date;\n\n  var t0 = new Date;\n\n  function newInterval(floori, offseti, count) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    return interval;\n  }\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  exports.seconds = second.range;\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  exports.minutes = minute.range;\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  exports.hours = hour.range;\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  });\n\n  exports.days = day.range;\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  exports.sunday = weekday(0);\n\n  exports.sundays = exports.sunday.range;\n\n  exports.monday = weekday(1);\n\n  exports.mondays = exports.monday.range;\n\n  exports.tuesday = weekday(2);\n\n  exports.tuesdays = exports.tuesday.range;\n\n  exports.wednesday = weekday(3);\n\n  exports.wednesdays = exports.wednesday.range;\n\n  exports.thursday = weekday(4);\n\n  exports.thursdays = exports.thursday.range;\n\n  exports.friday = weekday(5);\n\n  exports.fridays = exports.friday.range;\n\n  exports.saturday = weekday(6);\n\n  exports.saturdays = exports.saturday.range;\n\n  var week = exports.sunday;\n\n  exports.weeks = week.range;\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  });\n\n  exports.months = month.range;\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  });\n\n  exports.years = year.range;\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  });\n\n  exports.utcSeconds = utcSecond.range;\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  });\n\n  exports.utcMinutes = utcMinute.range;\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  });\n\n  exports.utcHours = utcHour.range;\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  });\n\n  exports.utcDays = utcDay.range;\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  exports.utcSunday = utcWeekday(0);\n\n  exports.utcSundays = exports.utcSunday.range;\n\n  exports.utcMonday = utcWeekday(1);\n\n  exports.utcMondays = exports.utcMonday.range;\n\n  exports.utcTuesday = utcWeekday(2);\n\n  exports.utcTuesdays = exports.utcTuesday.range;\n\n  exports.utcWednesday = utcWeekday(3);\n\n  exports.utcWednesdays = exports.utcWednesday.range;\n\n  exports.utcThursday = utcWeekday(4);\n\n  exports.utcThursdays = exports.utcThursday.range;\n\n  exports.utcFriday = utcWeekday(5);\n\n  exports.utcFridays = exports.utcFriday.range;\n\n  exports.utcSaturday = utcWeekday(6);\n\n  exports.utcSaturdays = exports.utcSaturday.range;\n\n  var utcWeek = exports.utcSunday;\n\n  exports.utcWeeks = utcWeek.range;\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  });\n\n  exports.utcMonths = utcMonth.range;\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  });\n\n  exports.utcYears = utcYear.range;\n\n  exports.interval = newInterval;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.week = week;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcWeek = utcWeek;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n\n}));","var util = require('../util'),\n    time = require('../time'),\n    EPSILON = 1e-15;\n\nfunction bins(opt) {\n  if (!opt) { throw Error(\"Missing binning options.\"); }\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  if (!opt) { throw Error(\"Missing date binning options.\"); }\n\n  // find time step, then bin\n  var units = opt.utc ? time.utc : time,\n      dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n","var gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};","var util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    types[f] = infer(data, f);\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;","var util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length < 2) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (v === v) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (v === v) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance] \n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;","var d3_time = require('d3-time');\n\nvar tempDate = new Date(),\n    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD\n    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);\n\nfunction date(d) {\n  return (tempDate.setTime(+d), tempDate);\n}\n\n// create a time unit entry\nfunction entry(type, date, unit, step, min, max) {\n  var e = {\n    type: type,\n    date: date,\n    unit: unit\n  };\n  if (step) {\n    e.step = step;\n  } else {\n    e.minstep = 1;\n  }\n  if (min != null) e.min = min;\n  if (max != null) e.max = max;\n  return e;\n}\n\nfunction create(type, unit, base, step, min, max) {\n  return entry(type,\n    function(d) { return unit.offset(base, d); },\n    function(d) { return unit.count(base, d); },\n    step, min, max);\n}\n\nvar locale = [\n  create('second', d3_time.second, baseDate),\n  create('minute', d3_time.minute, baseDate),\n  create('hour',   d3_time.hour,   baseDate),\n  create('day',    d3_time.day,    baseDate, [1, 7]),\n  create('month',  d3_time.month,  baseDate, [1, 3, 6]),\n  create('year',   d3_time.year,   baseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(1970, 0, 1, 0, 0, d); },\n    function(d) { return date(d).getSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(1970, 0, 1, 0, d); },\n    function(d) { return date(d).getMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(1970, 0, 1, d); },\n    function(d) { return date(d).getHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(1970, 0, 4+d); },\n    function(d) { return date(d).getDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(1970, 0, d); },\n    function(d) { return date(d).getDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(1970, d % 12, 1); },\n    function(d) { return date(d).getMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar utc = [\n  create('second', d3_time.utcSecond, utcBaseDate),\n  create('minute', d3_time.utcMinute, utcBaseDate),\n  create('hour',   d3_time.utcHour,   utcBaseDate),\n  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),\n  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),\n  create('year',   d3_time.utcYear,   utcBaseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },\n    function(d) { return date(d).getUTCSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },\n    function(d) { return date(d).getUTCMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },\n    function(d) { return date(d).getUTCHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },\n    function(d) { return date(d).getUTCDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(Date.UTC(1970, 0, d)); },\n    function(d) { return date(d).getUTCDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },\n    function(d) { return date(d).getUTCMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction find(units, span, minb, maxb) {\n  var step = STEPS[0], i, n, bins;\n\n  for (i=1, n=STEPS.length; i<n; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return units[STEPS[i-1][1]];\n      }\n      if (bins >= minb) {\n        return units[step[1]];\n      }\n    }\n  }\n  return units[STEPS[n-1][1]];\n}\n\nfunction toUnitMap(units) {\n  var map = {}, i, n;\n  for (i=0, n=units.length; i<n; ++i) {\n    map[units[i].type] = units[i];\n  }\n  map.find = function(span, minb, maxb) {\n    return find(units, span, minb, maxb);\n  };\n  return map;\n}\n\nmodule.exports = toUnitMap(locale);\nmodule.exports.utc = toUnitMap(utc);\n","var buffer = require('buffer'),\n    time = require('./time'),\n    utc = time.utc;\n\nvar u = module.exports = {};\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (buffer.Buffer && buffer.Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\nu.date = function(s) {\n  return s == null || s === '' ? null : Date.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nvar field_re = /\\[(.*?)\\]|[^.\\[]+/g;\n\nu.field = function(f) {\n  return String(f).match(field_re).map(function(d) {\n    return d[0] !== '[' ? d :\n      d[1] !== \"'\" && d[1] !== '\"' ? d.slice(1, -1) :\n      d.slice(2, -2).replace(/\\\\([\"'])/g, '$1');\n  });\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\nu.$year   = u.$func('year', time.year.unit);\nu.$month  = u.$func('month', time.months.unit);\nu.$date   = u.$func('date', time.dates.unit);\nu.$day    = u.$func('day', time.weekdays.unit);\nu.$hour   = u.$func('hour', time.hours.unit);\nu.$minute = u.$func('minute', time.minutes.unit);\nu.$second = u.$func('second', time.seconds.unit);\n\nu.$utcYear   = u.$func('utcYear', utc.year.unit);\nu.$utcMonth  = u.$func('utcMonth', utc.months.unit);\nu.$utcDate   = u.$func('utcDate', utc.dates.unit);\nu.$utcDay    = u.$func('utcDay', utc.weekdays.unit);\nu.$utcHour   = u.$func('utcHour', utc.hours.unit);\nu.$utcMinute = u.$func('utcMinute', utc.minutes.unit);\nu.$utcSecond = u.$func('utcSecond', utc.seconds.unit);\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n","'use strict';\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  util = require('./util'),\n  vlfield = require('./field'),\n  vlenc = require('./enc'),\n  schema = require('./schema/schema');\n\nmodule.exports = (function() {\n  function Encoding(spec, theme) {\n    var defaults = schema.instantiate(),\n      specExtended = schema.util.merge(defaults, theme || {}, spec) ;\n\n    this._data = specExtended.data;\n    this._marktype = specExtended.marktype;\n    this._enc = specExtended.encoding;\n    this._config = specExtended.config;\n    this._filter = specExtended.filter;\n    // this._vega2 = true;\n  }\n\n  var proto = Encoding.prototype;\n\n  Encoding.fromShorthand = function(shorthand, data, config, theme) {\n    var c = consts.shorthand,\n        split = shorthand.split(c.delim),\n        marktype = split.shift().split(c.assign)[1].trim(),\n        enc = vlenc.fromShorthand(split);\n\n    return new Encoding({\n      data: data,\n      marktype: marktype,\n      encoding: enc,\n      config: config,\n      filter: []\n    }, theme);\n  };\n\n  Encoding.fromSpec = function(spec, theme) {\n    return new Encoding(spec, theme);\n  };\n\n  proto.toShorthand = function() {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + this._marktype +\n      c.delim + vlenc.shorthand(this._enc);\n  };\n\n  Encoding.shorthand = function (spec) {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + spec.marktype +\n      c.delim + vlenc.shorthand(spec.encoding);\n  };\n\n  Encoding.specFromShorthand = function(shorthand, data, config, excludeConfig) {\n    return Encoding.fromShorthand(shorthand, data, config).toSpec(excludeConfig);\n  };\n\n  proto.toSpec = function(excludeConfig, excludeData) {\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    spec = {\n      marktype: this._marktype,\n      encoding: enc,\n      filter: this._filter\n    };\n\n    if (!excludeConfig) {\n      spec.config = util.duplicate(this._config);\n    }\n\n    if (!excludeData) {\n      spec.data = util.duplicate(this._data);\n    }\n\n    // remove defaults\n    var defaults = schema.instantiate();\n    return schema.util.subtract(spec, defaults);\n  };\n\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(encType) {\n    // equivalent to calling vlenc.has(this._enc, encType)\n    return this._enc[encType].name !== undefined;\n  };\n\n  proto.field = function(et) {\n    return this._enc[et];\n  };\n\n  proto.filter = function() {\n    var filterNull = [],\n      fields = this.fields(),\n      self = this;\n\n    util.forEach(fields, function(fieldList, fieldName) {\n      if (fieldName === '*') return; //count\n\n      if ((self.config('filterNull').Q && fieldList.containsType[Q]) ||\n          (self.config('filterNull').T && fieldList.containsType[T]) ||\n          (self.config('filterNull').O && fieldList.containsType[O]) ||\n          (self.config('filterNull').N && fieldList.containsType[N])) {\n        filterNull.push({\n          operands: [fieldName],\n          operator: 'notNull'\n        });\n      }\n    });\n\n    return filterNull.concat(this._filter);\n  };\n\n  // get \"field\" reference for vega\n  proto.fieldRef = function(et, opt) {\n    opt = opt || {};\n    opt.data = !this._vega2 && (opt.data !== false);\n    return vlfield.fieldRef(this._enc[et], opt);\n  };\n\n  proto.fieldName = function(et) {\n    return this._enc[et].name;\n  };\n\n  /*\n   * return key-value pairs of field name and list of fields of that field name\n   */\n  proto.fields = function() {\n    return vlenc.fields(this._enc);\n  };\n\n  proto.fieldTitle = function(et) {\n    if (vlfield.isCount(this._enc[et])) {\n      return vlfield.count.displayName;\n    }\n    var fn = this._enc[et].aggregate || this._enc[et].timeUnit || (this._enc[et].bin && 'bin');\n    if (fn) {\n      var uppercase = fn === 'avg' ? 'MEAN' :fn.toUpperCase();\n      return uppercase + '(' + this._enc[et].name + ')';\n    } else {\n      return this._enc[et].name;\n    }\n  };\n\n  proto.scale = function(et) {\n    return this._enc[et].scale || {};\n  };\n\n  proto.axis = function(et) {\n    return this._enc[et].axis || {};\n  };\n\n  proto.bandSize = function(encType, useSmallBand) {\n    useSmallBand = useSmallBand ||\n      //isBandInSmallMultiples\n      (encType === Y && this.has(ROW) && this.has(Y)) ||\n      (encType === X && this.has(COL) && this.has(X));\n\n    // if band.size is explicitly specified, follow the specification, otherwise draw value from config.\n    return this.field(encType).band.size ||\n      this.config(useSmallBand ? 'smallBandSize' : 'largeBandSize');\n  };\n\n  proto.aggregate = function(et) {\n    return this._enc[et].aggregate;\n  };\n\n  // returns false if binning is disabled, otherwise an object with binning properties\n  proto.bin = function(et) {\n    var bin = this._enc[et].bin;\n    if (bin === {})\n      return false;\n    if (bin === true)\n      return {\n        maxbins: schema.MAXBINS_DEFAULT\n      };\n    return bin;\n  };\n\n  proto.value = function(et) {\n    return this._enc[et].value;\n  };\n\n  proto.numberFormat = function(fieldStats) {\n    var formatConfig = fieldStats.max > this.config('maxSmallNumber') ?\n      'largeNumberFormat': 'smallNumberFormat';\n    return this.config(formatConfig);\n  };\n\n  proto.sort = function(et, stats) {\n    var sort = this._enc[et].sort,\n      enc = this._enc,\n      isTypes = vlfield.isTypes;\n\n    if ((!sort || sort.length===0) &&\n        // FIXME\n        Encoding.toggleSort.support({encoding:this._enc}, stats, true) && //HACK\n        this.config('toggleSort') === Q\n      ) {\n      var qField = isTypes(enc.x, [N, O]) ? enc.y : enc.x;\n\n      if (isTypes(enc[et], [N, O])) {\n        sort = [{\n          name: qField.name,\n          aggregate: qField.aggregate,\n          type: qField.type,\n          reverse: true\n        }];\n      }\n    }\n\n    return sort;\n  };\n\n  proto.map = function(f) {\n    return vlenc.map(this._enc, f);\n  };\n\n  proto.reduce = function(f, init) {\n    return vlenc.reduce(this._enc, f, init);\n  };\n\n  proto.forEach = function(f) {\n    return vlenc.forEach(this._enc, f);\n  };\n\n  proto.type = function(et) {\n    return this.has(et) ? this._enc[et].type : null;\n  };\n\n  proto.isType = function(et, type) {\n    var field = this.field(et);\n    return field && vlfield.isType(field, type);\n  };\n\n\n  proto.isTypes = function(et, type) {\n    var field = this.field(et);\n    return field && vlfield.isTypes(field, type);\n  };\n\n  Encoding.isOrdinalScale = function(encoding, encType) {\n    return vlfield.isOrdinalScale(encoding.field(encType));\n  };\n\n  Encoding.isDimension = function(encoding, encType) {\n    return vlfield.isDimension(encoding.field(encType));\n  };\n\n  Encoding.isMeasure = function(encoding, encType) {\n    return vlfield.isMeasure(encoding.field(encType));\n  };\n\n  proto.isOrdinalScale = function(encType) {\n    return this.has(encType) && Encoding.isOrdinalScale(this, encType);\n  };\n\n  proto.isDimension = function(encType) {\n    return this.has(encType) && Encoding.isDimension(this, encType);\n  };\n\n  proto.isMeasure = function(encType) {\n    return this.has(encType) && Encoding.isMeasure(this, encType);\n  };\n\n  proto.isAggregate = function() {\n    return vlenc.isAggregate(this._enc);\n  };\n\n  proto.dataTable = function() {\n    return this.isAggregate() ? AGGREGATE : RAW;\n  };\n\n  Encoding.isAggregate = function(spec) {\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.alwaysNoOcclusion = function(spec) {\n    // FIXME raw OxQ with # of rows = # of O\n    return vlenc.isAggregate(spec.encoding);\n  };\n\n  Encoding.isStack = function(spec) {\n    // FIXME update this once we have control for stack ...\n    return (spec.marktype === 'bar' || spec.marktype === 'area') &&\n      spec.encoding.color;\n  };\n\n  proto.isStack = function() {\n    // FIXME update this once we have control for stack ...\n    return (this.is('bar') || this.is('area')) && this.has('color');\n  };\n\n  proto.details = function() {\n    var encoding = this;\n    return this.reduce(function(refs, field, encType) {\n      if (!field.aggregate && (encType !== X && encType !== Y)) {\n        refs.push(encoding.fieldRef(encType));\n      }\n      return refs;\n    }, []);\n  };\n\n  proto.facets = function() {\n    var encoding = this;\n    return this.reduce(function(refs, field, encType) {\n      if (!field.aggregate && (encType == ROW || encType == COL)) {\n        refs.push(encoding.fieldRef(encType));\n      }\n      return refs;\n    }, []);\n  };\n\n  proto.cardinality = function(encType, stats) {\n    return vlfield.cardinality(this.field(encType), stats, this.config('filterNull'));\n  };\n\n  proto.isRaw = function() {\n    return !this.isAggregate();\n  };\n\n  proto.data = function() {\n    return this._data;\n  };\n\n   // returns whether the encoding has values embedded\n  proto.hasValues = function() {\n    var vals = this.data().values;\n    return vals && vals.length;\n  };\n\n  proto.config = function(name) {\n    return this._config[name];\n  };\n\n  Encoding.transpose = function(spec) {\n    var oldenc = spec.encoding,\n      enc = util.duplicate(spec.encoding);\n    enc.x = oldenc.y;\n    enc.y = oldenc.x;\n    enc.row = oldenc.col;\n    enc.col = oldenc.row;\n    spec.encoding = enc;\n    return spec;\n  };\n\n  // FIXME: REMOVE everything below here\n\n  Encoding.toggleSort = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.toggleSort = spec.config.toggleSort === Q ? N : Q;\n    return spec;\n  };\n\n\n  Encoding.toggleSort.direction = function(spec) {\n    if (!Encoding.toggleSort.support(spec)) { return; }\n    var enc = spec.encoding;\n    return enc.x.type === N ? 'x' : 'y';\n  };\n\n  Encoding.toggleSort.mode = function(spec) {\n    return spec.config.toggleSort;\n  };\n\n  Encoding.toggleSort.support = function(spec, stats) {\n    var enc = spec.encoding,\n      isTypes = vlfield.isTypes;\n\n    if (vlenc.has(enc, ROW) || vlenc.has(enc, COL) ||\n      !vlenc.has(enc, X) || !vlenc.has(enc, Y) ||\n      !Encoding.alwaysNoOcclusion(spec, stats)) {\n      return false;\n    }\n\n    return ( isTypes(enc.x, [N,O]) && vlfield.isMeasure(enc.y)) ? 'x' :\n      ( isTypes(enc.y, [N,O]) && vlfield.isMeasure(enc.x)) ? 'y' : false;\n  };\n\n  Encoding.toggleFilterNullO = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.filterNull = spec.config.filterNull || { //FIXME\n      T: true,\n      Q: true\n    };\n    spec.config.filterNull.O = !spec.config.filterNull.O;\n    return spec;\n  };\n\n  Encoding.toggleFilterNullO.support = function(spec, stats) {\n    var fields = vlenc.fields(spec.encoding);\n    for (var fieldName in fields) {\n      var fieldList = fields[fieldName];\n      if (fieldList.containsType.O && fieldName in stats && stats[fieldName].nulls > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  return Encoding;\n})();\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  getter = util.getter,\n  time = require('./time');\n\nvar axis = module.exports = {};\n\naxis.def = function(name, encoding, layout, stats, opt) {\n  var isCol = name == COL,\n    isRow = name == ROW,\n    type = isCol ? 'x' : isRow ? 'y' : name;\n\n  var def = {\n    type: type,\n    scale: name,\n    properties: {},\n    layer: encoding.field(name).axis.layer,\n    orient: axis.orient(name, encoding, stats)\n  };\n\n  // Add axis label custom scale (for bin / time)\n  def = axis.labels.scale(def, encoding, name);\n  def = axis.labels.format(def, name, encoding, stats);\n  def = axis.labels.angle(def, encoding, name);\n\n  // for x-axis, set ticks for Q or rotate scale for ordinal scale\n  if (name == X) {\n    if ((encoding.isDimension(X) || encoding.isType(X, T)) &&\n        !('angle' in getter(def, ['properties', 'labels']))) {\n      // TODO(kanitw): Jul 19, 2015 - #506 add condition for rotation\n      def = axis.labels.rotate(def);\n    } else { // Q\n      def.ticks = encoding.field(name).axis.ticks;\n    }\n  }\n\n  // TitleOffset depends on labels rotation\n  def.titleOffset = axis.titleOffset(encoding, layout, name);\n\n  //def.offset is used in axis.grid\n  if(isRow) def.offset = axis.titleOffset(encoding, layout, Y) + 20;\n  // FIXME(kanitw): Jul 19, 2015 - offset for column when x is put on top\n\n  def = axis.grid(def, name, encoding, layout);\n  def = axis.title(def, name, encoding, layout, opt);\n\n  if (isRow || isCol) def = axis.hideTicks(def);\n\n  return def;\n};\n\naxis.orient = function(name, encoding, stats) {\n  var orient = encoding.field(name).axis.orient;\n  if (orient) return orient;\n\n  if (name===COL) return 'top';\n\n  // x-axis for long y - put on top\n  if (name===X && encoding.has(Y) && encoding.isOrdinalScale(Y) && encoding.cardinality(Y, stats) > 30) {\n    return 'top';\n  }\n\n  return undefined;\n};\n\naxis.grid = function(def, name, encoding, layout) {\n  var cellPadding = layout.cellPadding,\n    isCol = name == COL,\n    isRow = name == ROW;\n\n  if (encoding.axis(name).grid) {\n    def.grid = true;\n\n    if (isCol) {\n      // set grid property -- put the lines on the right the cell\n      def.properties.grid = {\n        x: {\n          offset: layout.cellWidth * (1+ cellPadding/2.0),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'col'\n        },\n        y: {\n          value: -layout.cellHeight * (cellPadding/2),\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      };\n    } else if (isRow) {\n      // set grid property -- put the lines on the top\n      def.properties.grid = {\n        y: {\n          offset: -layout.cellHeight * (cellPadding/2),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'row'\n        },\n        x: {\n          value: def.offset\n        },\n        x2: {\n          offset: def.offset + (layout.cellWidth * 0.05),\n          // default value(s) -- vega doesn't do recursive merge\n          group: 'mark.group.width',\n          mult: 1\n        },\n        stroke: { value: encoding.config('cellGridColor') },\n        opacity: { value: encoding.config('cellGridOpacity') }\n      };\n    } else {\n      def.properties.grid = {\n        stroke: { value: encoding.config('gridColor') },\n        opacity: { value: encoding.config('gridOpacity') }\n      };\n    }\n  }\n  return def;\n};\n\naxis.hideTicks = function(def) {\n  def.properties.ticks = {opacity: {value: 0}};\n  def.properties.majorTicks = {opacity: {value: 0}};\n  def.properties.axis = {opacity: {value: 0}};\n  return def;\n};\n\naxis.title = function (def, name, encoding, layout) {\n  var ax = encoding.field(name).axis;\n\n  if (ax.title) {\n    def.title = ax.title;\n  } else {\n    // if not defined, automatically determine axis title from field def\n    var fieldTitle = encoding.fieldTitle(name),\n      maxLength;\n\n    if (ax.titleMaxLength) {\n      maxLength = ax.titleMaxLength;\n    } else if (name===X) {\n      maxLength = layout.cellWidth / encoding.config('characterWidth');\n    } else if (name === Y) {\n      maxLength = layout.cellHeight / encoding.config('characterWidth');\n    }\n\n    def.title = maxLength ? util.truncate(fieldTitle, maxLength) : fieldTitle;\n  }\n\n  if (name === ROW) {\n    def.properties.title = {\n      angle: {value: 0},\n      align: {value: 'right'},\n      baseline: {value: 'middle'},\n      dy: {value: (-layout.height/2) -20}\n    };\n  }\n\n  return def;\n};\n\naxis.labels = {};\n\n/** add custom label for time type and bin */\naxis.labels.scale = function(def, encoding, name) {\n  // time\n  var timeUnit = encoding.field(name).timeUnit;\n  if (encoding.isType(name, T) && timeUnit && (time.hasScale(timeUnit))) {\n    setter(def, ['properties','labels','text','scale'], 'time-'+ timeUnit);\n  }\n  // FIXME bin\n  return def;\n};\n\n/**\n * Determine number format or truncate if maxLabel length is presented.\n */\naxis.labels.format = function (def, name, encoding, stats) {\n  var fieldStats = stats[encoding.field(name).name];\n\n  if (encoding.axis(name).format) {\n    def.format = encoding.axis(name).format;\n  } else if (encoding.isType(name, Q) || fieldStats.type === 'number') {\n    def.format = encoding.numberFormat(fieldStats);\n  } else if (encoding.isType(name, T)) {\n    var timeUnit = encoding.field(name).timeUnit;\n    if (!timeUnit) {\n      def.format = encoding.config('timeFormat');\n    } else if (timeUnit === 'year') {\n      def.format = 'd';\n    }\n  } else if (encoding.isTypes(name, [N, O]) && encoding.axis(name).maxLabelLength) {\n    setter(def,\n      ['properties','labels','text','template'],\n      '{{data | truncate:' + encoding.axis(name).maxLabelLength + '}}'\n      );\n  }\n\n  return def;\n};\n\naxis.labels.angle = function(def, encoding, name) {\n  var angle = encoding.axis(name).labelAngle;\n  if (typeof angle === 'undefined') return def;\n\n  setter(def, ['properties', 'labels', 'angle', 'value'], angle);\n  return def;\n};\n\naxis.labels.rotate = function(def) {\n var align = def.orient ==='top' ? 'left' : 'right';\n setter(def, ['properties','labels', 'angle', 'value'], 270);\n setter(def, ['properties','labels', 'align', 'value'], align);\n setter(def, ['properties','labels', 'baseline', 'value'], 'middle');\n return def;\n};\n\naxis.titleOffset = function (encoding, layout, name) {\n  // return specified value if specified\n  var value = encoding.axis(name).titleOffset;\n  if (value)  return value;\n\n  switch (name) {\n    //FIXME make this adjustable\n    case ROW: return 0;\n    case COL: return 35;\n  }\n  return getter(layout, [name, 'axisTitleOffset']);\n};\n","'use strict';\n\nvar summary = module.exports = require('datalib/src/stats').summary;\n\nrequire('../globals');\n\nvar compiler = module.exports = {};\n\nvar Encoding = require('../Encoding'),\n  axis = compiler.axis = require('./axis'),\n  legend = compiler.legend = require('./legend'),\n  marks = compiler.marks = require('./marks'),\n  scale = compiler.scale = require('./scale');\n\ncompiler.data = require('./data');\ncompiler.facet = require('./facet');\ncompiler.group = require('./group');\ncompiler.layout = require('./layout');\ncompiler.sort = require('./sort');\ncompiler.stack = require('./stack');\ncompiler.style = require('./style');\ncompiler.subfacet = require('./subfacet');\ncompiler.time = require('./time');\n\ncompiler.compile = function (spec, stats, theme) {\n  return compiler.compileEncoding(Encoding.fromSpec(spec, theme), stats);\n};\n\ncompiler.shorthand = function (shorthand, stats, config, theme) {\n  return compiler.compileEncoding(Encoding.fromShorthand(shorthand, config, theme), stats);\n};\n\n\ncompiler.compileEncoding = function (encoding, stats) {\n  // no need to pass stats if you pass in the data\n  if (!stats) {\n    if (encoding.hasValues()) {\n        stats = summary(encoding.data().values).reduce(function(s, p) {\n        s[p.field] = p;\n        return s;\n      }, {});\n    } else {\n      console.error('No stats provided and data is not embedded.');\n    }\n  }\n\n  var layout = compiler.layout(encoding, stats);\n\n  var spec = {\n      width: layout.width,\n      height: layout.height,\n      padding: 'auto',\n      data: compiler.data(encoding),\n      // global scales contains only time unit scales\n      scales: compiler.time.scales(encoding)\n    };\n\n  // FIXME remove compiler.sort after migrating to vega 2.\n  spec.data = compiler.sort(spec.data, encoding, stats); // append new data\n\n  // marks\n\n  // TODO this line is temporary and should be refactored\n  spec.marks = [compiler.group.def('cell', {\n    width: layout.cellWidth ? {value: layout.cellWidth} : undefined,\n    height: layout.cellHeight ? {value: layout.cellHeight} : undefined\n  })];\n\n  var style = compiler.style(encoding, stats),\n    group = spec.marks[0],\n    mdefs = marks.def(encoding, layout, style, stats),\n    mdef = mdefs[mdefs.length - 1];  // TODO: remove this dirty hack by refactoring the whole flow\n\n  for (var i = 0; i < mdefs.length; i++) {\n    group.marks.push(mdefs[i]);\n  }\n\n  var lineType = marks[encoding.marktype()].line;\n\n  // handle subfacets\n\n  var details = encoding.details(),\n    stack = encoding.isAggregate() && details.length > 0 && compiler.stack(spec.data, encoding, mdef); // modify spec.data, mdef.{from,properties}\n\n  if (details.length > 0 && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    compiler.subfacet(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  if (lineType && encoding.config('autoSortLine')) {\n    var f = (encoding.isMeasure(X) && encoding.isDimension(Y)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    // TODO: why - ?\n    mdef.from.transform = [{type: 'sort', by: '-' + encoding.fieldRef(f)}];\n  }\n\n  // get a flattened list of all scale names that are used in the vl spec\n  var singleScaleNames = [].concat.apply([], mdefs.map(function(markProps) {\n    return scale.names(markProps.properties.update);\n  }));\n\n  // Small Multiples\n  if (encoding.has(ROW) || encoding.has(COL)) {\n    spec = compiler.facet(group, encoding, layout, spec, singleScaleNames, stack, stats);\n    spec.legends = legend.defs(encoding, style);\n  } else {\n    group.scales = scale.defs(singleScaleNames, encoding, layout, stats, {stack: stack});\n\n    group.axes = [];\n    if (encoding.has(X)) group.axes.push(axis.def(X, encoding, layout, stats));\n    if (encoding.has(Y)) group.axes.push(axis.def(Y, encoding, layout, stats));\n\n    group.legends = legend.defs(encoding, style);\n  }\n\n\n\n  return spec;\n};\n\n","'use strict';\n\nrequire('../globals');\n\nmodule.exports = data;\n\nvar vlfield = require('../field'),\n  util = require('../util'),\n  time = require('./time');\n\nfunction data(encoding) {\n  var def = [data.raw(encoding)];\n\n  var aggregate = data.aggregate(encoding);\n  if (aggregate) def.push(data.aggregate(encoding));\n\n  // TODO add \"having\" filter here\n\n  // append non-positive filter at the end for the data table\n  data.filterNonPositive(def[def.length - 1], encoding);\n\n  return def;\n}\n\ndata.raw = function(encoding) {\n  var raw = {name: RAW};\n\n  // Data source (url or inline)\n  if (encoding.hasValues()) {\n    raw.values = encoding.data().values;\n  } else {\n    raw.url = encoding.data().url;\n    raw.format = {type: encoding.data().formatType};\n  }\n\n  // Set format.parse if needed\n  var parse = data.raw.formatParse(encoding);\n  if (parse) {\n    raw.format = raw.format || {};\n    raw.format.parse = parse;\n  }\n\n  raw.transform = data.raw.transform(encoding);\n  return raw;\n};\n\ndata.raw.formatParse = function(encoding) {\n  var parse;\n\n  encoding.forEach(function(field) {\n    if (field.type == T) {\n      parse = parse || {};\n      parse[field.name] = 'date';\n    } else if (field.type == Q) {\n      if (vlfield.isCount(field)) return;\n      parse = parse || {};\n      parse[field.name] = 'number';\n    }\n  });\n\n  return parse;\n};\n\ndata.raw.transform = function(encoding) {\n  // time and bin should come before filter so we can filter by time and bin\n  return data.raw.transform.time(encoding).concat(\n    data.raw.transform.bin(encoding),\n    data.raw.transform.filter(encoding)\n  );\n};\n\nvar BINARY = {\n  '>':  true,\n  '>=': true,\n  '=':  true,\n  '!=': true,\n  '<':  true,\n  '<=': true\n};\n\ndata.raw.transform.time = function(encoding) {\n  return encoding.reduce(function(transform, field, encType) {\n    if (field.type === T && field.timeUnit) {\n      transform.push({\n        type: 'formula',\n        field: encoding.fieldRef(encType),\n        expr: time.formula(field.timeUnit, encoding.fieldRef(encType, {nofn: true, d: true}))\n      });\n    }\n    return transform;\n  }, []);\n};\n\ndata.raw.transform.bin = function(encoding) {\n  return encoding.reduce(function(transform, field, encType) {\n    if (encoding.bin(encType)) {\n      transform.push({\n        type: 'bin',\n        field: encoding.fieldRef(encType, {nofn: true}),\n        output: encoding.fieldRef(encType),\n        maxbins: encoding.bin(encType).maxbins\n      });\n    }\n    return transform;\n  }, []);\n};\n\ndata.raw.transform.filter = function(encoding) {\n  var filters = encoding.filter().reduce(function(f, filter) {\n    var condition = '';\n    var operator = filter.operator;\n    var operands = filter.operands;\n\n    var d = 'd.' + (encoding._vega2 ? '' : 'data.');\n\n    if (BINARY[operator]) {\n      // expects a field and a value\n      if (operator === '=') {\n        operator = '==';\n      }\n\n      var op1 = operands[0];\n      var op2 = operands[1];\n      condition = d + op1 + ' ' + operator + ' ' + op2;\n    } else if (operator === 'notNull') {\n      // expects a number of fields\n      for (var j=0; j<operands.length; j++) {\n        condition += d + operands[j] + '!==null';\n        if (j < operands.length - 1) {\n          condition += ' && ';\n        }\n      }\n    } else {\n      util.warn('Unsupported operator: ', operator);\n      return f;\n    }\n    f.push('(' + condition + ')');\n    return f;\n  }, []);\n  if (filters.length === 0) return [];\n\n  return [{\n      type: 'filter',\n      test: filters.join(' && ')\n  }];\n};\n\ndata.aggregate = function(encoding) {\n  var dims = {}, meas = {};\n\n  encoding.forEach(function(field, encType) {\n    if (field.aggregate) {\n      if (field.aggregate === 'count') {\n        meas.count = {op: 'count', field: '*'};\n      }else {\n        meas[field.aggregate + '|' + field.name] = {\n          op: field.aggregate,\n          field: encoding.fieldRef(encType, {nofn: true})\n        };\n      }\n    } else {\n      dims[field.name] = encoding.fieldRef(encType);\n    }\n  });\n\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0) {\n    return {\n      name: AGGREGATE,\n      source: RAW,\n      transform: [{\n        type: 'aggregate',\n        groupby: dims,\n        fields: meas\n      }]\n    };\n  }\n\n  return null;\n};\n\ndata.filterNonPositive = function(dataTable, encoding) {\n  encoding.forEach(function(field, encType) {\n    if (encoding.scale(encType).type === 'log') {\n      dataTable.transform.push({\n        type: 'filter',\n        test: encoding.fieldRef(encType, {d: 1}) + ' > 0'\n      });\n    }\n  });\n};\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util');\n\nvar axis = require('./axis'),\n  groupdef = require('./group').def,\n  scale = require('./scale');\n\nmodule.exports = faceting;\n\nfunction faceting(group, encoding, layout, spec, singleScaleNames, stack, stats) {\n  var enter = group.properties.enter;\n  var facetKeys = [], cellAxes = [], from, axesGrp;\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  enter.fill = {value: encoding.config('cellBackgroundColor')};\n\n  //move \"from\" to cell level and add facet transform\n  group.from = {data: group.marks[0].from.data};\n\n  // Hack, this needs to be refactored\n  for (var i = 0; i < group.marks.length; i++) {\n    var mark = group.marks[i];\n    if (mark.from.transform) {\n      delete mark.from.data; //need to keep transform for subfacetting case\n    } else {\n      delete mark.from;\n    }\n  }\n\n  if (hasRow) {\n    if (!encoding.isDimension(ROW)) {\n      util.error('Row encoding should be ordinal.');\n    }\n    enter.y = {scale: ROW, field: 'keys.' + facetKeys.length};\n    enter.height = {'value': layout.cellHeight}; // HACK\n\n    facetKeys.push(encoding.fieldRef(ROW));\n\n    if (hasCol) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.fieldRef(COL)]});\n    }\n\n    axesGrp = groupdef('x-axes', {\n        axes: encoding.has(X) ? [axis.def(X, encoding, layout, stats)] : undefined,\n        x: hasCol ? {scale: COL, field: 'keys.0'} : {value: 0},\n        width: hasCol && {'value': layout.cellWidth}, //HACK?\n        from: from\n      });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push(axis.def(ROW, encoding, layout, stats));\n  } else { // doesn't have row\n    if (encoding.has(X)) {\n      //keep x axis in the cell\n      cellAxes.push(axis.def(X, encoding, layout, stats));\n    }\n  }\n\n  if (hasCol) {\n    if (!encoding.isDimension(COL)) {\n      util.error('Col encoding should be ordinal.');\n    }\n    enter.x = {scale: COL, field: 'keys.' + facetKeys.length};\n    enter.width = {'value': layout.cellWidth}; // HACK\n\n    facetKeys.push(encoding.fieldRef(COL));\n\n    if (hasRow) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.fieldRef(ROW)]});\n    }\n\n    axesGrp = groupdef('y-axes', {\n      axes: encoding.has(Y) ? [axis.def(Y, encoding, layout, stats)] : undefined,\n      y: hasRow && {scale: ROW, field: 'keys.0'},\n      x: hasRow && {value: 0},\n      height: hasRow && {'value': layout.cellHeight}, //HACK?\n      from: from\n    });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push(axis.def(COL, encoding, layout, stats));\n  } else { // doesn't have col\n    if (encoding.has(Y)) {\n      cellAxes.push(axis.def(Y, encoding, layout, stats));\n    }\n  }\n\n  // assuming equal cellWidth here\n  // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n  spec.scales = (spec.scales || []).concat(scale.defs(\n    scale.names(enter).concat(singleScaleNames),\n    encoding,\n    layout,\n    stats,\n    {stack: stack, facet: true}\n  )); // row/col scales + cell scales\n\n  if (cellAxes.length > 0) {\n    group.axes = cellAxes;\n  }\n\n  // add facet transform\n  var trans = (group.from.transform || (group.from.transform = []));\n  trans.unshift({type: 'facet', keys: facetKeys});\n\n  return spec;\n}\n","'use strict';\n\nmodule.exports = {\n  def: groupdef\n};\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: 'group',\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: 'width'},\n        height: opt.height || {group: 'height'}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n","'use strict';\n\nrequire('../globals');\n\nvar util = require('../util'),\n  setter = util.setter,\n  time = require('./time'),\n  d3_format = require('d3-format');\n\nmodule.exports = vllayout;\n\nfunction vllayout(encoding, stats) {\n  var layout = box(encoding, stats);\n  layout = offset(encoding, stats, layout);\n  return layout;\n}\n\n/*\n  HACK to set chart size\n  NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  One solution is to update Vega to support auto-sizing\n  In the meantime, auto-padding (mostly) does the trick\n */\nfunction box(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y),\n      marktype = encoding.marktype();\n\n  // FIXME/HACK we need to take filter into account\n  var xCardinality = hasX && encoding.isDimension(X) ? encoding.cardinality(X, stats) : 1,\n    yCardinality = hasY && encoding.isDimension(Y) ? encoding.cardinality(Y, stats) : 1;\n\n  var useSmallBand = xCardinality > encoding.config('largeBandMaxCardinality') ||\n    yCardinality > encoding.config('largeBandMaxCardinality');\n\n  var cellWidth, cellHeight, cellPadding = encoding.config('cellPadding');\n\n  // set cellWidth\n  if (hasX) {\n    if (encoding.isOrdinalScale(X)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellWidth = (xCardinality + encoding.field(X).band.padding) * encoding.bandSize(X, useSmallBand);\n    } else {\n      cellWidth = hasCol || hasRow ? encoding.field(COL).width :  encoding.config('singleWidth');\n    }\n  } else {\n    if (marktype === TEXT) {\n      cellWidth = encoding.config('textCellWidth');\n    } else {\n      cellWidth = encoding.bandSize(X);\n    }\n  }\n\n  // set cellHeight\n  if (hasY) {\n    if (encoding.isOrdinalScale(Y)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellHeight = (yCardinality + encoding.field(Y).band.padding) * encoding.bandSize(Y, useSmallBand);\n    } else {\n      cellHeight = hasCol || hasRow ? encoding.field(ROW).height :  encoding.config('singleHeight');\n    }\n  } else {\n    cellHeight = encoding.bandSize(Y);\n  }\n\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n\n  var width = cellWidth, height = cellHeight;\n  if (hasCol) {\n    var colCardinality = encoding.cardinality(COL, stats);\n    width = cellWidth * ((1 + cellPadding) * (colCardinality - 1) + 1);\n  }\n  if (hasRow) {\n    var rowCardinality =  encoding.cardinality(ROW, stats);\n    height = cellHeight * ((1 + cellPadding) * (rowCardinality - 1) + 1);\n  }\n\n  return {\n    // width and height of the whole cell\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    cellPadding: cellPadding,\n    // width and height of the chart\n    width: width,\n    height: height,\n    // information about x and y, such as band size\n    x: {useSmallBand: useSmallBand},\n    y: {useSmallBand: useSmallBand}\n  };\n}\n\n\n// FIXME fieldStats.max isn't always the longest\nfunction getMaxNumberLength(encoding, et, fieldStats) {\n  var format = encoding.numberFormat(et, fieldStats);\n\n  return d3_format.format(format)(fieldStats.max).length;\n}\n\nfunction getMaxLength(encoding, stats, et) {\n  var field = encoding.field(et),\n    fieldStats = stats[field.name];\n\n  if (field.bin) {\n    // TODO once bin support range, need to update this\n    return getMaxNumberLength(encoding, et, fieldStats);\n  } if (encoding.isType(et, Q)) {\n    return getMaxNumberLength(encoding, et, fieldStats);\n  } else if (encoding.isType(et, T)) {\n    return time.maxLength(encoding.field(et).timeUnit, encoding);\n  } else if (encoding.isTypes(et, [N, O])) {\n    if(fieldStats.type === 'number') {\n      return getMaxNumberLength(encoding, et, fieldStats);\n    } else {\n      return Math.min(fieldStats.max, encoding.axis(et).maxLabelLength || Infinity);\n    }\n  }\n}\n\nfunction offset(encoding, stats, layout) {\n  [X, Y].forEach(function (et) {\n    // TODO(kanitw): Jul 19, 2015 - create a set of visual test for extraOffset\n    var extraOffset = et === X ? 20 : 22,\n      maxLength;\n    if (encoding.isDimension(et) || encoding.isType(et, T)) {\n      maxLength = getMaxLength(encoding, stats, et);\n    } else if (\n      // TODO once we have #512 (allow using inferred type)\n      // Need to adjust condition here.\n      encoding.isType(et, Q) ||\n      encoding.aggregate(et) === 'count'\n    ) {\n      if (\n        et===Y\n        // || (et===X && false)\n        // FIXME determine when X would rotate, but should move this to axis.js first #506\n      ) {\n        maxLength = getMaxLength(encoding, stats, et);\n      }\n    } else {\n      // nothing\n    }\n\n    if (maxLength) {\n      setter(layout,[et, 'axisTitleOffset'], encoding.config('characterWidth') *  maxLength + extraOffset);\n    } else {\n      // if no max length (no rotation case), use maxLength = 3\n      setter(layout,[et, 'axisTitleOffset'], encoding.config('characterWidth') * 3 + extraOffset);\n    }\n\n  });\n  return layout;\n}\n","'use strict';\n\nrequire('../globals');\n\nvar time = require('./time'),\n  util = require('../util'),\n  setter = util.setter,\n  getter = util.getter;\n\nvar legend = module.exports = {};\n\nlegend.defs = function(encoding, style) {\n  var defs = [];\n\n  if (encoding.has(COLOR) && encoding.field(COLOR).legend) {\n    defs.push(legend.def(COLOR, encoding, {\n      fill: COLOR,\n      orient: 'right'\n    }, style));\n  }\n\n  if (encoding.has(SIZE) && encoding.field(SIZE).legend) {\n    defs.push(legend.def(SIZE, encoding, {\n      size: SIZE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }, style));\n  }\n\n  if (encoding.has(SHAPE) && encoding.field(SHAPE).legend) {\n    if (defs.length === 2) {\n      console.error('Vega-lite currently only supports two legends');\n    }\n    defs.push(legend.def(SHAPE, encoding, {\n      shape: SHAPE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }, style));\n  }\n  return defs;\n};\n\nlegend.def = function(name, encoding, def, style) {\n  var timeUnit = encoding.field(name).timeUnit;\n\n  def.title = legend.title(name, encoding);\n  def = legend.style(name, encoding, def, style);\n\n  if (encoding.isType(name, T) &&\n    timeUnit &&\n    time.hasScale(timeUnit)\n  ) {\n    setter(def, ['properties', 'labels', 'text', 'scale'], 'time-'+ timeUnit);\n  }\n\n  return def;\n};\n\nlegend.style = function(name, e, def, style) {\n  var symbols = getter(def, ['properties', 'symbols']),\n    marktype = e.marktype();\n\n  switch (marktype) {\n    case 'bar':\n    case 'tick':\n    case 'text':\n      symbols.stroke = {value: 'transparent'};\n      symbols.shape = {value: 'square'};\n      break;\n\n    case 'circle':\n    case 'square':\n      symbols.shape = {value: marktype};\n      /* fall through */\n    case 'point':\n      // fill or stroke\n      if (e.field(SHAPE).filled) {\n        if (e.has(COLOR) && name === COLOR) {\n          symbols.fill = {scale: COLOR, field: 'data'};\n        } else {\n          symbols.fill = {value: e.value(COLOR)};\n        }\n        symbols.stroke = {value: 'transparent'};\n      } else {\n        if (e.has(COLOR) && name === COLOR) {\n          symbols.stroke = {scale: COLOR, field: 'data'};\n        } else {\n          symbols.stroke = {value: e.value(COLOR)};\n        }\n        symbols.fill = {value: 'transparent'};\n        symbols.strokeWidth = {value: e.config('strokeWidth')};\n      }\n\n      break;\n    case 'line':\n    case 'area':\n      // TODO use shape here after implementing #508\n      break;\n  }\n\n  var opacity = e.field(COLOR).opacity || style.opacity;\n  if (opacity) {\n    symbols.opacity = {value: opacity};\n  }\n  return def;\n};\n\nlegend.title = function(name, encoding) {\n  var leg = encoding.field(name).legend;\n\n  if (leg.title) return leg.title;\n\n  return encoding.fieldTitle(name);\n};\n","'use strict';\n\nrequire('../globals');\n\nvar marks = module.exports = {};\n\nmarks.def = function(encoding, layout, style, stats) {\n\n  var defs = [],\n    mark = marks[encoding.marktype()],\n    from = encoding.dataTable();\n\n  // to add a background to text, we need to add it before the text\n  if (encoding.marktype() === TEXT && encoding.has(COLOR)) {\n    var bg = {\n      x: {value: 0},\n      y: {value: 0},\n      x2: {value: layout.cellWidth},\n      y2: {value: layout.cellHeight},\n      fill: {scale: COLOR, field: encoding.fieldRef(COLOR)}\n    };\n    defs.push({\n      type: 'rect',\n      from: {data: from},\n      properties: {enter: bg, update: bg}\n    });\n  }\n\n  // add the mark def for the main thing\n  var p = mark.prop(encoding, layout, style, stats);\n  defs.push({\n    type: mark.type,\n    from: {data: from},\n    properties: {enter: p, update: p}\n  });\n\n  return defs;\n};\n\nmarks.bar = {\n  type: 'rect',\n  stack: true,\n  prop: bar_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1}\n};\n\nmarks.line = {\n  type: 'line',\n  line: true,\n  prop: line_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, detail:1}\n};\n\nmarks.area = {\n  type: 'area',\n  stack: true,\n  line: true,\n  requiredEncoding: ['x', 'y'],\n  prop: area_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1}\n};\n\nmarks.tick = {\n  type: 'rect',\n  prop: tick_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, detail: 1}\n};\n\nmarks.circle = {\n  type: 'symbol',\n  prop: filled_point_props('circle'),\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, detail: 1}\n};\n\nmarks.square = {\n  type: 'symbol',\n  prop: filled_point_props('square'),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: 'symbol',\n  prop: point_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, shape: 1, detail: 1}\n};\n\nmarks.text = {\n  type: 'text',\n  prop: text_props,\n  requiredEncoding: ['text'],\n  supportedEncoding: {row: 1, col: 1, size: 1, color: 1, text: 1}\n};\n\nfunction bar_props(e, layout, style) {\n  // jshint unused:false\n\n  var p = {};\n\n  // x's and width\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (!e.has(Y) || e.isDimension(Y)) {\n      p.x2 = {value: 0};\n    }\n  } else {\n    if (e.has(X)) { // is ordinal\n       p.xc = {scale: X, field: e.fieldRef(X)};\n    } else {\n       p.x = {value: 0, offset: e.config('singleBarOffset')};\n    }\n  }\n\n  // width\n  if (!p.x2) {\n    if (!e.has(X) || e.isOrdinalScale(X)) { // no X or X is ordinal\n      if (e.has(SIZE)) {\n        p.width = {scale: SIZE, field: e.fieldRef(SIZE)};\n      } else {\n        p.width = {\n          value: e.bandSize(X, layout.x.useSmallBand),\n          offset: -1\n        };\n      }\n    } else { // X is Quant or Time Scale\n      p.width = {value: 2};\n    }\n  }\n\n  // y's & height\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    p.y2 = {group: 'height'};\n  } else {\n    if (e.has(Y)) { // is ordinal\n      p.yc = {scale: Y, field: e.fieldRef(Y)};\n    } else {\n      p.y2 = {group: 'height', offset: -e.config('singleBarOffset')};\n    }\n\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.fieldRef(SIZE)};\n    } else {\n      p.height = {\n        value: e.bandSize(Y, layout.y.useSmallBand),\n        offset: -1\n      };\n    }\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // opacity\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction point_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.fieldRef(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.value(SIZE)};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.fieldRef(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.value(SHAPE)};\n  }\n\n  // fill or stroke\n  if (e.field(SHAPE).filled) {\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n  } else {\n    if (e.has(COLOR)) {\n      p.stroke = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.stroke = {value: e.value(COLOR)};\n    }\n    p.strokeWidth = {value: e.config('strokeWidth')};\n  }\n\n  // opacity\n  var opacity = e.field(COLOR).opacity || style.opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction line_props(e,layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction area_props(e, layout, style) {\n  // jshint unused:false\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: 'horizontal'};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else {\n    p.y = {group: 'height'};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity;\n  if (opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction tick_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n    if (e.isDimension(X)) {\n      p.x.offset = -e.bandSize(X, layout.x.useSmallBand) / 3;\n    }\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n    if (e.isDimension(Y)) {\n      p.y.offset = -e.bandSize(Y, layout.y.useSmallBand) / 3;\n    }\n  } else if (!e.has(Y)) {\n    p.y = {value: 0};\n  }\n\n  // width\n  if (!e.has(X) || e.isDimension(X)) {\n    p.width = {value: e.bandSize(X, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.width = {value: 1};\n  }\n\n  // height\n  if (!e.has(Y) || e.isDimension(Y)) {\n    p.height = {value: e.bandSize(Y, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.height = {value: 1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  var opacity = e.field(COLOR).opacity  || style.opacity;\n  if(opacity) p.opacity = {value: opacity};\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, layout, style) {\n    var p = {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.fieldRef(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.fieldRef(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.fieldRef(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.value(SIZE)};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.fieldRef(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n\n    var opacity = e.field(COLOR).opacity  || style.opacity;\n    if(opacity) p.opacity = {value: opacity};\n\n    return p;\n  };\n}\n\nfunction text_props(e, layout, style, stats) {\n  var p = {},\n    field = e.field(TEXT);\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.fieldRef(X)};\n  } else if (!e.has(X)) {\n    if (e.has(TEXT) && e.isType(TEXT, Q)) {\n      p.x = {value: layout.cellWidth-5};\n    } else {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.fieldRef(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.fieldRef(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.fontSize = {value: field.font.size};\n  }\n\n  // fill\n  // color should be set to background\n  p.fill = {value: field.color};\n\n  var opacity = e.field(COLOR).opacity  || style.opacity;\n  if(opacity) p.opacity = {value: opacity};\n\n  // text\n  if (e.has(TEXT)) {\n    if (e.isType(TEXT, Q)) {\n      var fieldStats = stats[e.fieldName(TEXT)],\n        numberFormat = field.format || e.numberFormat(fieldStats);\n\n      p.text = {template: '{{' + e.fieldRef(TEXT) + ' | number:\\'' +\n        numberFormat +'\\'}}'};\n      p.align = {value: field.align};\n    } else {\n      p.text = {field: e.fieldRef(TEXT)};\n    }\n  } else {\n    p.text = {value: field.placeholder};\n  }\n\n  p.font = {value: field.font.family};\n  p.fontWeight = {value: field.font.weight};\n  p.fontStyle = {value: field.font.style};\n  p.baseline = {value: field.baseline};\n\n  return p;\n}\n","'use strict';\nrequire('../globals');\nvar util = require('../util'),\n  time = require('./time'),\n  colorbrewer = require('colorbrewer'),\n  interpolate = require('d3-color').interpolateHsl,\n  schema = require('../schema/schema'),\n  vlsort = require('./sort');\n\nvar scale = module.exports = {};\n\nscale.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\nscale.defs = function(names, encoding, layout, stats, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale.type(name, encoding),\n      domain: scale.domain(name, encoding, stats, opt)\n    };\n\n    s.sort = scale.sort(s, encoding, name) || undefined;\n\n    scale.range(s, encoding, layout, stats, opt);\n\n    return (a.push(s), a);\n  }, []);\n};\n\nscale.sort = function(s, encoding, name) {\n  return s.type === 'ordinal' && (\n    !!encoding.bin(name) ||\n    encoding.sort(name).length === 0\n  );\n};\n\nscale.type = function(name, encoding) {\n\n  switch (encoding.type(name)) {\n    case N: //fall through\n    case O: return 'ordinal';\n    case T:\n      var timeUnit = encoding.field(name).timeUnit;\n      return timeUnit ? time.scale.type(timeUnit, name) : 'time';\n    case Q:\n      if (encoding.bin(name)) {\n        return name === COLOR ? 'linear' : 'ordinal';\n      }\n      return encoding.scale(name).type;\n  }\n};\n\nscale.domain = function (name, encoding, stats, opt) {\n  var field = encoding.field(name);\n\n  if (encoding.isType(name, T)) {\n    var range = time.scale.domain(field.timeUnit, name);\n    if(range) return range;\n  }\n\n  if (field.bin) {\n    // TODO(kanitw): this must be changed in vg2\n    var fieldStat = stats[field.name],\n      bins = util.getbins(fieldStat, field.bin.maxbins || schema.MAXBINS_DEFAULT),\n      numbins = (bins.stop - bins.start) / bins.step;\n    return util.range(numbins).map(function(i) {\n      return bins.start + bins.step * i;\n    });\n  }\n\n  if (name == opt.stack) {\n    return {\n      data: STACKED,\n      field: encoding.fieldRef(name, {\n        data: !encoding._vega2,\n        prefn: (opt.facet ? 'max_' : '') + 'sum_'\n      })\n    };\n  }\n  var aggregate = encoding.aggregate(name),\n    timeUnit = field.timeUnit,\n    scaleUseRawDomain = encoding.scale(name).useRawDomain,\n    useRawDomain = scaleUseRawDomain !== undefined ?\n      scaleUseRawDomain : encoding.config('useRawDomain'),\n    notCountOrSum = !aggregate || (aggregate !=='count' && aggregate !== 'sum');\n\n  // FIXME revise this part\n\n  if ( useRawDomain && notCountOrSum && (\n      // Q always uses non-ordinal scale except when it's binned and thus uses ordinal scale.\n      (encoding.isType(name, Q) && !field.bin) ||\n      // T uses non-ordinal scale when there's no unit or when the unit is not ordinal.\n      (encoding.isType(name, T) && (!timeUnit || !time.isOrdinalFn(timeUnit)))\n    )\n  ) {\n    return {data: RAW, field: encoding.fieldRef(name, {nofn: !timeUnit})};\n  }\n\n  var data = encoding.sort(name, stats).length > 0 ?\n    vlsort.getDataName(name):\n    encoding.dataTable();\n\n  return {data: data, field: encoding.fieldRef(name)};\n};\n\n\nscale.range = function (s, encoding, layout, stats) {\n  var spec = encoding.scale(s.name),\n    field = encoding.field(s.name),\n    timeUnit = field.timeUnit;\n\n  switch (s.name) {\n    case X:\n      s.range = layout.cellWidth ? [0, layout.cellWidth] : 'width';\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(X, layout.x.useSmallBand);\n      } else {\n        if (encoding.isType(s.name,T) && timeUnit === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n      s.round = true;\n      if (s.type === 'time') {\n        s.nice = timeUnit || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (s.type === 'ordinal') {\n        s.range = layout.cellHeight ?\n          (field.bin ? [layout.cellHeight, 0] : [0, layout.cellHeight]) :\n          'height';\n        s.bandWidth = encoding.bandSize(Y, layout.y.useSmallBand);\n      } else {\n        s.range = layout.cellHeight ? [layout.cellHeight, 0] : 'height';\n        if (encoding.isType(s.name,T) && timeUnit === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n\n      s.round = true;\n\n      if (s.type === 'time') {\n        s.nice = timeUnit || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case ROW: // support only ordinal\n      s.bandWidth = layout.cellHeight;\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL: // support only ordinal\n      s.bandWidth = layout.cellWidth;\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is('bar')) {\n        // FIXME this is definitely incorrect\n        // but let's fix it later since bar size is a bad encoding anyway\n        s.range = [3, Math.max(encoding.bandSize(X), encoding.bandSize(Y))];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else { //point\n        var bandSize = Math.min(encoding.bandSize(X), encoding.bandSize(Y)) - 1;\n        s.range = [10, 0.8 * bandSize*bandSize];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = 'shapes';\n      break;\n    case COLOR:\n      s.range = scale.color(s, encoding, stats);\n      if (s.type !== 'ordinal') s.zero = false;\n      break;\n    default:\n      throw new Error('Unknown encoding name: '+ s.name);\n  }\n\n  // FIXME(kanitw): Jul 29, 2015 - consolidate this with above\n  switch (s.name) {\n    case ROW:\n    case COL:\n      s.padding = encoding.config('cellPadding');\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (s.type === 'ordinal') { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.field(s.name).band.padding;\n      }\n  }\n};\n\nscale.color = function(s, encoding, stats) {\n  var colorScale = encoding.scale(COLOR),\n    range = colorScale.range,\n    cardinality = encoding.cardinality(COLOR, stats),\n    type = encoding.type(COLOR);\n\n  if (range === undefined) {\n    var ordinalPalette = colorScale.ordinalPalette,\n      quantitativeRange = colorScale.quantitativeRange;\n\n    if (s.type === 'ordinal') {\n      if (type === N) {\n        // use categorical color scale\n        if (cardinality <= 10) {\n          range = colorScale.c10palette;\n        } else {\n          range = colorScale.c20palette;\n        }\n        return scale.color.palette(range, cardinality, type);\n      } else {\n        if (ordinalPalette) {\n          return scale.color.palette(ordinalPalette, cardinality, type);\n        }\n        return scale.color.interpolate(quantitativeRange[0], quantitativeRange[1], cardinality);\n      }\n    } else { //time or quantitative\n      return [quantitativeRange[0], quantitativeRange[1]];\n    }\n  }\n};\n\nscale.color.palette = function(range, cardinality, type) {\n  // FIXME(kanitw): Jul 29, 2015 - check range is string\n  switch (range) {\n    case 'category10k':\n      // tableau's category 10, ordered by perceptual kernel study results\n      // https://github.com/uwdata/perceptual-kernels\n      return ['#2ca02c', '#e377c2', '#7f7f7f', '#17becf', '#8c564b', '#d62728', '#bcbd22', '#9467bd', '#ff7f0e', '#1f77b4'];\n\n    // d3/tableau category10/20/20b/20c\n    case 'category10':\n      return ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];\n\n    case 'category20':\n      return ['#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'];\n\n    case 'category20b':\n      return ['#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39', '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b', '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'];\n\n    case 'category20c':\n      return ['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#e6550d', '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354', '#74c476', '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc', '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9'];\n  }\n\n  // TODO add our own set of custom ordinal color palette\n\n  if (range in colorbrewer) {\n    var palette = colorbrewer[range];\n\n    // if cardinality pre-defined, use it.\n    if (cardinality in palette) return palette[cardinality];\n\n    // if not, use the highest cardinality one for nominal\n    if (type === N) {\n      return palette[Math.max.apply(null, util.keys(palette))];\n    }\n\n    // otherwise, interpolate\n    var ps = cardinality < 3 ? 3 : Math.max.apply(null, util.keys(palette)),\n      from = 0 , to = ps - 1;\n    // FIXME add config for from / to\n\n    return scale.color.interpolate(palette[ps][from], palette[ps][to], cardinality);\n  }\n\n  return range;\n};\n\nscale.color.interpolate = function (start, end, cardinality) {\n\n  var interpolator = interpolate(start, end);\n  return util.range(cardinality).map(function(i) { return interpolator(i*1.0/(cardinality-1)); });\n};\n","'use strict';\n\nrequire('../globals');\n\nvar vlfield = require('../field');\n\nmodule.exports = sort;\n\n// adds new transforms that produce sorted fields\nfunction sort(data, encoding, stats, opt) {\n  // jshint unused:false\n\n  var datasetMapping = {};\n\n  encoding.forEach(function(field, encType) {\n    var sortBy = encoding.sort(encType, stats);\n    if (sortBy.length > 0) {\n      var fields = sortBy.map(function(d) {\n        return {\n          op: d.aggregate,\n          field: vlfield.fieldRef(d, {nofn: true, data: !encoding._vega2})\n        };\n      });\n\n      var byClause = sortBy.map(function(d) {\n        var reverse = (d.reverse ? '-' : '');\n        return reverse + vlfield.fieldRef(d, {data: !encoding._vega2});\n      });\n\n      var dataName = sort.getDataName(encType);\n\n      var transforms = [\n        {\n          type: 'aggregate',\n          groupby: [ encoding.fieldRef(encType) ],\n          fields: fields\n        },\n        {\n          type: 'sort',\n          by: byClause\n        }\n      ];\n\n      data.push({\n        name: dataName,\n        source: RAW,\n        transform: transforms\n      });\n\n      datasetMapping[encType] = dataName;\n    }\n  });\n\n  return data;\n}\n\nsort.getDataName = function(encType) {\n  return 'sorted-' + encType;\n};\n\n","'use strict';\n\nrequire('../globals');\n\nvar  marks = require('./marks');\n\nmodule.exports = stacking;\n\nfunction stacking(data, encoding, mdef) {\n  if (!marks[encoding.marktype()].stack) return false;\n\n  // TODO: add || encoding.has(LOD) here once LOD is implemented\n  if (!encoding.has(COLOR)) return false;\n\n  var dim=null, val=null, idx =null,\n    isXMeasure = encoding.isMeasure(X),\n    isYMeasure = encoding.isMeasure(Y),\n    facets = encoding.facets();\n\n  if (isXMeasure && !isYMeasure) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  } else if (isYMeasure && !isXMeasure) {\n    dim = X;\n    val = Y;\n    idx = 1;\n  } else {\n    return null; // no stack encoding\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: encoding.dataTable(),\n    transform: [{\n      type: 'aggregate',\n      groupby: [encoding.fieldRef(dim)].concat(facets), // dim and other facets\n      fields: [{op: 'sum', field: encoding.fieldRef(val)}] // TODO check if field with aggregate is correct?\n    }]\n  };\n\n  if (facets && facets.length > 0) {\n    stacked.transform.push({ //calculate max for each facet\n      type: 'aggregate',\n      groupby: facets,\n      fields: [{\n        op: 'max',\n        field: encoding.fieldName(val, {fn: 'sum'})\n      }]\n    });\n  }\n\n  data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: 'stack',\n    point: encoding.fieldRef(dim),\n    height: encoding.fieldRef(val),\n    output: {y1: val, y0: val + '2'}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val + '2'] = mdef.properties.enter[val + '2'] = {scale: val, field: val + '2'};\n\n  return val; //return stack encoding\n}\n","'use strict';\n\nrequire('../globals');\n\nvar vlfield = require('../field');\n\nmodule.exports = function(encoding, stats) {\n  return {\n    opacity: estimateOpacity(encoding, stats),\n  };\n};\n\nfunction estimateOpacity(encoding,stats) {\n  if (!stats) {\n    return 1;\n  }\n\n  var numPoints = 0;\n\n  if (encoding.isAggregate()) { // aggregate plot\n    numPoints = 1;\n\n    //  get number of points in each \"cell\"\n    //  by calculating product of cardinality\n    //  for each non faceting and non-ordinal X / Y fields\n    //  note that ordinal x,y are not include since we can\n    //  consider that ordinal x are subdividing the cell into subcells anyway\n    encoding.forEach(function(field, encType) {\n\n      if (encType !== ROW && encType !== COL &&\n          !((encType === X || encType === Y) &&\n          vlfield.isOrdinalScale(field))\n        ) {\n        numPoints *= encoding.cardinality(encType, stats);\n      }\n    });\n\n  } else { // raw plot\n\n    // TODO: error handling\n    if (!stats['*'])\n      return 1;\n\n    numPoints = stats['*'].max;  // count\n\n    // small multiples divide number of points\n    var numMultiples = 1;\n    if (encoding.has(ROW)) {\n      numMultiples *= encoding.cardinality(ROW, stats);\n    }\n    if (encoding.has(COL)) {\n      numMultiples *= encoding.cardinality(COL, stats);\n    }\n    numPoints /= numMultiples;\n  }\n\n  var opacity = 0;\n  if (numPoints <= 25) {\n    opacity = 1;\n  } else if (numPoints < 200) {\n    opacity = 0.8;\n  } else if (numPoints < 1000 || encoding.is('tick')) {\n    opacity = 0.7;\n  } else {\n    opacity = 0.3;\n  }\n\n  return opacity;\n}\n\n","'use strict';\n\nrequire('../globals');\n\nvar groupdef = require('./group').def;\n\nmodule.exports = subfaceting;\n\nfunction subfaceting(group, mdef, details, stack, encoding) {\n  var m = group.marks,\n    g = groupdef('subfacet', {marks: m});\n\n  group.marks = [g];\n  g.from = mdef.from;\n  delete mdef.from;\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: 'facet', keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: 'sort', by: encoding.fieldRef(COLOR)});\n  }\n}\n","'use strict';\n\nvar util = require('../util'),\n  d3_time_format = require('d3-time-format');\n\nvar time = module.exports = {};\n\nvar LONG_DATE = new Date(2014, 8, 17);\n\ntime.cardinality = function(field, stats, filterNull, type) {\n  var timeUnit = field.timeUnit;\n  switch (timeUnit) {\n    case 'seconds': return 60;\n    case 'minutes': return 60;\n    case 'hours': return 24;\n    case 'day': return 7;\n    case 'date': return 31;\n    case 'month': return 12;\n    case 'year':\n      var stat = stats[field.name],\n        yearstat = stats['year_'+field.name];\n\n      if (!yearstat) { return null; }\n\n      return yearstat.distinct -\n        (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n  }\n\n  return null;\n};\n\ntime.formula = function(timeUnit, fieldRef) {\n  // TODO(kanitw): add formula to other time format\n  var fn = 'utc' + timeUnit;\n  return fn + '(' + fieldRef + ')';\n};\n\ntime.maxLength = function(timeUnit, encoding) {\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'date':\n      return 2;\n    case 'month':\n    case 'day':\n      var range = time.range(timeUnit, encoding);\n      if (range) {\n        // return the longest name in the range\n        return Math.max.apply(null, range.map(function(r) {return r.length;}));\n      }\n      return 2;\n    case 'year':\n      return 4; //'1998'\n  }\n  // no time unit\n  var timeFormat = encoding.config('timeFormat');\n  return d3_time_format.utcFormat(timeFormat)(LONG_DATE).length;\n};\n\ntime.range = function(timeUnit, encoding) {\n  var labelLength = encoding.config('timeScaleLabelLength'),\n    scaleLabel;\n  switch (timeUnit) {\n    case 'day':\n      scaleLabel = encoding.config('dayScaleLabel');\n      break;\n    case 'month':\n      scaleLabel = encoding.config('monthScaleLabel');\n      break;\n  }\n  if (scaleLabel) {\n    return labelLength ? scaleLabel.map(\n        function(s) { return s.substr(0, labelLength);}\n      ) : scaleLabel;\n  }\n  return;\n};\n\n\n/**\n * @param  {Object} encoding\n * @return {Array}  scales for time unit names\n */\ntime.scales = function(encoding) {\n  var scales = encoding.reduce(function(scales, field) {\n    var timeUnit = field.timeUnit;\n    if (field.type === T && timeUnit && !scales[timeUnit]) {\n      var scale = time.scale.def(field.timeUnit, encoding);\n      if (scale) scales[timeUnit] = scale;\n    }\n    return scales;\n  }, {});\n\n  return util.vals(scales);\n};\n\n\ntime.scale = {};\n\n/** append custom time scales for axis label */\ntime.scale.def = function(timeUnit, encoding) {\n  var range = time.range(timeUnit, encoding);\n\n  if (range) {\n    return {\n      name: 'time-'+timeUnit,\n      type: 'ordinal',\n      domain: time.scale.domain(timeUnit),\n      range: range\n    };\n  }\n  return null;\n};\n\ntime.isOrdinalFn = function(timeUnit) {\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'day':\n    case 'date':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\ntime.scale.type = function(timeUnit, name) {\n  if (name === COLOR) {\n    return 'linear'; // time has order, so use interpolated ordinal color scale.\n  }\n\n  return time.isOrdinalFn(timeUnit) || name === COL || name === ROW ? 'ordinal' : 'linear';\n};\n\ntime.scale.domain = function(timeUnit, name) {\n  var isColor = name === COLOR;\n  switch (timeUnit) {\n    case 'seconds':\n    case 'minutes': return isColor ? [0,59] : util.range(0, 60);\n    case 'hours': return isColor ? [0,23] : util.range(0, 24);\n    case 'day': return isColor ? [0,6] : util.range(0, 7);\n    case 'date': return isColor ? [1,31] : util.range(1, 32);\n    case 'month': return isColor ? [0,11] : util.range(0, 12);\n  }\n  return null;\n};\n\n/** whether a particular time function has custom scale for labels implemented in time.scale */\ntime.hasScale = function(timeUnit) {\n  switch (timeUnit) {\n    case 'day':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n","'use strict';\n\nrequire('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, TEXT, DETAIL];\n\nconsts.shorthand = {\n  delim:  '|',\n  assign: '=',\n  type:   ',',\n  func:   '_'\n};\n","'use strict';\n\nrequire('./globals');\n\nvar stats = require('datalib/src/stats');\n\nvar vldata = module.exports = {};\n\n/** Mapping from datalib's inferred type to Vega-lite's type */\nvldata.types = {\n  'boolean': N,\n  'number': Q,\n  'integer': Q,\n  'date': T,\n  'string': N\n};\n\nvldata.stats = function(data) {\n  var summary = stats.summary(data);\n\n  return summary.reduce(function(s, profile) {\n    s[profile.field] = profile;\n    return s;\n  }, {\n    '*': {\n      max: data.length,\n      min: 0\n    }\n  });\n};","// utility for enc\n\n'use strict';\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  vlfield = require('./field'),\n  util = require('./util'),\n  schema = require('./schema/schema'),\n  encTypes = schema.encTypes;\n\nvar vlenc = module.exports = {};\n\nvlenc.countRetinal = function(enc) {\n  var count = 0;\n  if (enc.color) count++;\n  if (enc.size) count++;\n  if (enc.shape) count++;\n  return count;\n};\n\nvlenc.has = function(enc, encType) {\n  var fieldDef = enc && enc[encType];\n  return fieldDef && fieldDef.name;\n};\n\nvlenc.isAggregate = function(enc) {\n  for (var k in enc) {\n    if (vlenc.has(enc, k) && enc[k].aggregate) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvlenc.forEach = function(enc, f) {\n  var i = 0;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      f(enc[k], k, i++);\n    }\n  });\n};\n\nvlenc.map = function(enc, f) {\n  var arr = [];\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      arr.push(f(enc[k], k, enc));\n    }\n  });\n  return arr;\n};\n\nvlenc.reduce = function(enc, f, init) {\n  var r = init;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      r = f(r, enc[k], k,  enc);\n    }\n  });\n  return r;\n};\n\n/*\n * return key-value pairs of field name and list of fields of that field name\n */\nvlenc.fields = function(enc) {\n  return vlenc.reduce(enc, function (m, field) {\n    var fieldList = m[field.name] = m[field.name] || [],\n      containsType = fieldList.containsType = fieldList.containsType || {};\n\n    if (fieldList.indexOf(field) === -1) {\n      fieldList.push(field);\n      // augment the array with containsType.Q / O / N / T\n      containsType[field.type] = true;\n    }\n    return m;\n  }, {});\n};\n\nvlenc.shorthand = function(enc) {\n  return vlenc.map(enc, function(field, et) {\n    return et + c.assign + vlfield.shorthand(field);\n  }).join(c.delim);\n};\n\nvlenc.fromShorthand = function(shorthand) {\n  var enc = util.isArray(shorthand) ? shorthand : shorthand.split(c.delim);\n  return enc.reduce(function(m, e) {\n    var split = e.split(c.assign),\n        enctype = split[0].trim(),\n        field = split[1];\n\n    m[enctype] = vlfield.fromShorthand(field);\n    return m;\n  }, {});\n};","'use strict';\n\n// utility for field\n\nrequire('./globals');\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compiler/time'),\n  util = require('./util'),\n  schema = require('./schema/schema');\n\nvar vlfield = module.exports = {};\n\n/**\n * @param field\n * @param opt\n *   opt.nofn -- exclude bin, aggregate, timeUnit\n *   opt.data - include 'data.'\n *   opt.d - include 'd.'\n *   opt.fn - replace fn with custom function prefix\n *   opt.prefn - prepend fn with custom function prefix\n\n * @return {[type]}       [description]\n */\nvlfield.fieldRef = function(field, opt) {\n  opt = opt || {};\n\n  var f = (opt.d ? 'd.' : '') +\n          (opt.data ? 'data.' : '') +\n          (opt.prefn || ''),\n    nofn = opt.nofn || opt.fn,\n    name = field.name;\n\n  if (vlfield.isCount(field)) {\n    return f + 'count';\n  } else if (!nofn && field.bin) {\n    return f + 'bin_' + name;\n  } else if (!nofn && field.aggregate) {\n    return f + field.aggregate + '_' + name;\n  } else if (!nofn && field.timeUnit) {\n    return f + field.timeUnit + '_' + name;\n  } else if (opt.fn) {\n    return f + opt.fn + '_' + name;\n  } else {\n    return f + name;\n  }\n};\n\nvlfield.shorthand = function(f) {\n  var c = consts.shorthand;\n  return (f.aggregate ? f.aggregate + c.func : '') +\n    (f.timeUnit ? f.timeUnit + c.func : '') +\n    (f.bin ? 'bin' + c.func : '') +\n    (f.name || '') + c.type + f.type;\n};\n\nvlfield.shorthands = function(fields, delim) {\n  delim = delim || c.delim;\n  return fields.map(vlfield.shorthand).join(delim);\n};\n\nvlfield.fromShorthand = function(shorthand) {\n  var split = shorthand.split(c.type), i;\n  var o = {\n    name: split[0].trim(),\n    type: split[1].trim()\n  };\n\n  // check aggregate type\n  for (i in schema.aggregate.enum) {\n    var a = schema.aggregate.enum[i];\n    if (o.name.indexOf(a + '_') === 0) {\n      o.name = o.name.substr(a.length + 1);\n      if (a == 'count' && o.name.length === 0) o.name = '*';\n      o.aggregate = a;\n      break;\n    }\n  }\n\n  // check time timeUnit\n  for (i in schema.timefns) {\n    var tu = schema.timefns[i];\n    if (o.name && o.name.indexOf(tu + '_') === 0) {\n      o.name = o.name.substr(o.length + 1);\n      o.timeUnit = tu;\n      break;\n    }\n  }\n\n  // check bin\n  if (o.name && o.name.indexOf('bin_') === 0) {\n    o.name = o.name.substr(4);\n    o.bin = true;\n  }\n\n  return o;\n};\n\nvar isType = vlfield.isType = function (fieldDef, type) {\n  return fieldDef.type === type;\n};\n\nvar isTypes = vlfield.isTypes = function (fieldDef, types) {\n  for (var t=0; t<types.length; t++) {\n    if(fieldDef.type === types[t]) return true;\n  }\n  return false;\n};\n\n/*\n * Most fields that use ordinal scale are dimensions.\n * However, YEAR(T), YEARMONTH(T) use time scale, not ordinal but are dimensions too.\n */\nvlfield.isOrdinalScale = function(field) {\n  return  isTypes(field, [N, O]) || field.bin ||\n    ( isType(field, T) && field.timeUnit && time.isOrdinalFn(field.timeUnit) );\n};\n\nfunction isDimension(field) {\n  return  isTypes(field, [N, O]) || !!field.bin ||\n    ( isType(field, T) && !!field.timeUnit );\n}\n\n/**\n * For encoding, use encoding.isDimension() to avoid confusion.\n * Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.isDimension = function(field) {\n  return field && isDimension(field);\n};\n\nvlfield.isMeasure = function(field) {\n  return field && !isDimension(field);\n};\n\nvlfield.count = function() {\n  return {name:'*', aggregate: 'count', type: Q, displayName: vlfield.count.displayName};\n};\n\nvlfield.count.displayName = 'Number of Records';\n\nvlfield.isCount = function(field) {\n  return field.aggregate === 'count';\n};\n\n/**\n * For encoding, use encoding.cardinality() to avoid confusion.  Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.cardinality = function(field, stats, filterNull) {\n  // FIXME need to take filter into account\n\n  var stat = stats[field.name];\n  var type = field.type;\n\n  filterNull = filterNull || {};\n\n  if (field.bin) {\n    var bins = util.getbins(stat, field.bin.maxbins || schema.MAXBINS_DEFAULT);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  if (isType(field, T)) {\n    var cardinality = time.cardinality(field, stats, filterNull, type);\n    if(cardinality !== null) return cardinality;\n    //otherwise use calculation below\n  }\n  if (field.aggregate) {\n    return 1;\n  }\n\n  // remove null\n  return stat.distinct -\n    (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n};\n","'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.AGGREGATE = 'aggregate';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.N = 'N';\ng.O = 'O';\ng.Q = 'Q';\ng.T = 'T';\n","'use strict';\n\n// TODO(kanitw): chat with Vega team and possibly move this to vega-logging\nmodule.exports = function(prefix) {\n  // Borrowed some ideas from http://stackoverflow.com/a/15653260/866989\n  // and https://github.com/patik/console.log-wrapper/blob/master/consolelog.js\n  var METHODS = ['error', 'info', 'debug', 'warn', 'log'];\n\n  return METHODS.reduce(function(logger, fn) {\n    var cfn = console[fn] ? fn : 'log';\n    if (console[cfn].bind === 'undefined') { // IE < 10\n        logger[fn] = Function.prototype.bind.call(console[cfn], console, prefix);\n    }\n    else {\n        logger[fn] = console[cfn].bind(console, prefix);\n    }\n    return logger;\n  }, {});\n};","// Package of defining Vega-lite Specification's json schema\n'use strict';\n\nrequire('../globals');\n\nvar schema = module.exports = {},\n  util = require('../util'),\n  toMap = util.toMap,\n  colorbrewer = require('colorbrewer');\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: 'string',\n  enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\n};\n\nschema.aggregate = {\n  type: 'string',\n  enum: ['avg', 'sum', 'median', 'min', 'max', 'count'],\n  supportedEnums: {\n    Q: ['avg', 'median', 'sum', 'min', 'max', 'count'],\n    O: ['median','min','max'],\n    N: [],\n    T: ['avg', 'median', 'min', 'max'],\n    '': ['count']\n  },\n  supportedTypes: toMap([Q, N, O, T, ''])\n};\n\nschema.getSupportedRole = function(encType) {\n  return schema.schema.properties.encoding.properties[encType].supportedRole;\n};\n\nschema.timeUnits = ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'];\n\nschema.defaultTimeFn = 'month';\n\nschema.timeUnit = {\n  type: 'string',\n  enum: schema.timeUnits,\n  supportedTypes: toMap([T])\n};\n\nschema.scale_type = {\n  type: 'string',\n  // TODO(kanitw) read vega's schema here, add description\n  enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\n  default: 'linear',\n  supportedTypes: toMap([Q])\n};\n\nschema.field = {\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string'\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nschema.MAXBINS_DEFAULT = 15;\n\nvar bin = {\n  type: ['boolean', 'object'],\n  default: false,\n  properties: {\n    maxbins: {\n      type: 'integer',\n      default: schema.MAXBINS_DEFAULT,\n      minimum: 2,\n      description: 'Maximum number of bins.'\n    }\n  },\n  supportedTypes: toMap([Q]) // TODO: add O after finishing #81\n};\n\nvar typicalField = merge(clone(schema.field), {\n  type: 'object',\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T]\n    },\n    aggregate: schema.aggregate,\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    scale: {\n      type: 'object',\n      properties: {\n        type: schema.scale_type,\n        reverse: {\n          type: 'boolean',\n          default: false,\n          supportedTypes: toMap([Q, T])\n        },\n        zero: {\n          type: 'boolean',\n          description: 'Include zero',\n          default: true,\n          supportedTypes: toMap([Q, T])\n        },\n        nice: {\n          type: 'string',\n          enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\n          supportedTypes: toMap([T])\n        },\n        useRawDomain: {\n          type: 'boolean',\n          default: undefined,\n          description: 'Use the raw data range as scale domain instead of ' +\n                       'aggregated data for aggregate axis. ' +\n                       'This option does not work with sum or count aggregate' +\n                       'as they might have a substantially larger scale range.' +\n                       'By default, use value from config.useRawDomain.'\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: 'object',\n  supportedRole: {\n    dimension: true\n  },\n  properties: {\n    type: {\n      type: 'string',\n      enum: [N, O, Q, T] // ordinal-only field supports Q when bin is applied and T when time unit is applied.\n    },\n    timeUnit: schema.timeUnit,\n    bin: bin,\n    aggregate: {\n      type: 'string',\n      enum: ['count'],\n      supportedTypes: toMap([N, O]) // FIXME this looks weird to me\n    }\n  }\n});\n\nvar axisMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true},\n  properties: {\n    axis: {\n      type: 'object',\n      properties: {\n        grid: {\n          type: 'boolean',\n          default: true,\n          description: 'A flag indicate if gridlines should be created in addition to ticks.'\n        },\n        layer: {\n          type: 'string',\n          default: 'back',\n          description: 'A string indicating if the axis (and any gridlines) should be placed above or below the data marks.'\n        },\n        orient: {\n          type: 'string',\n          default: undefined,\n          enum: ['top', 'right', 'left', 'bottom'],\n          description: 'The orientation of the axis. One of top, bottom, left or right. The orientation can be used to further specialize the axis type (e.g., a y axis oriented for the right edge of the chart).'\n        },\n        ticks: {\n          type: 'integer',\n          default: 5,\n          minimum: 0,\n          description: 'A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale\\'s range.'\n        },\n        title: {\n          type: 'string',\n          default: undefined,\n          description: 'A title for the axis. (Shows field name and its function by default.)'\n        },\n        titleMaxLength: {\n          type: 'integer',\n          default: undefined,\n          minimum: 0,\n          description: 'Max length for axis title if the title is automatically generated from the field\\'s description'\n        },\n        titleOffset: {\n          type: 'integer',\n          default: undefined,  // auto\n          description: 'A title offset value for the axis.'\n        },\n        format: {\n          type: 'string',\n          default: undefined,  // auto\n          description: 'The formatting pattern for axis labels. '+\n                       'If not undefined, this will be determined by ' +\n                       'small/largeNumberFormat and the max value ' +\n                       'of the field.'\n        },\n        maxLabelLength: {\n          type: 'integer',\n          default: 25,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        },\n        labelAngle: {\n          type: 'integer',\n          default: undefined, // auto\n          minimum: 0,\n          maximum: 360,\n          description: 'Angle by which to rotate labels. Set to 0 to force horizontal.'\n        },\n      }\n    }\n  }\n};\n\nvar sortMixin = {\n  type: 'object',\n  properties: {\n    sort: {\n      type: 'array',\n      default: [],\n      items: {\n        type: 'object',\n        supportedTypes: toMap([N, O]),\n        required: ['name', 'aggregate'],\n        properties: {\n          name: {\n            type: 'string'\n          },\n          aggregate: {\n            type: 'string',\n            enum: ['avg', 'sum', 'min', 'max', 'count']\n          },\n          reverse: {\n            type: 'boolean',\n            default: false\n          }\n        }\n      }\n    }\n  }\n};\n\nvar bandMixin = {\n  type: 'object',\n  properties: {\n    band: {\n      type: 'object',\n      properties: {\n        size: {\n          type: 'integer',\n          minimum: 0,\n          default: undefined\n        },\n        padding: {\n          type: 'integer',\n          minimum: 0,\n          default: 1\n        }\n      }\n    }\n  }\n};\n\nvar legendMixin = {\n  type: 'object',\n  properties: {\n    legend: {\n      type: 'object',\n      description: 'Properties of a legend.',\n      properties: {\n        title: {\n          type: 'string',\n          default: undefined,\n          description: 'A title for the legend. (Shows field name and its function by default.)'\n        }\n      }\n    }\n  }\n};\n\nvar textMixin = {\n  type: 'object',\n  supportedMarktypes: {'text': true},\n  properties: {\n    align: {\n      type: 'string',\n      default: 'right'\n    },\n    baseline: {\n      type: 'string',\n      default: 'middle'\n    },\n    color: {\n      type: 'string',\n      role: 'color',\n      default: '#000000'\n    },\n    margin: {\n      type: 'integer',\n      default: 4,\n      minimum: 0\n    },\n    placeholder: {\n      type: 'string',\n      default: 'Abc'\n    },\n    font: {\n      type: 'object',\n      properties: {\n        weight: {\n          type: 'string',\n          enum: ['normal', 'bold'],\n          default: 'normal'\n        },\n        size: {\n          type: 'integer',\n          default: 10,\n          minimum: 0\n        },\n        family: {\n          type: 'string',\n          default: 'Helvetica Neue'\n        },\n        style: {\n          type: 'string',\n          default: 'normal',\n          enum: ['normal', 'italic']\n        }\n      }\n    },\n    format: {\n      type: 'string',\n      default: undefined,  // auto\n      description: 'The formatting pattern for text value. '+\n                   'If not undefined, this will be determined by ' +\n                   'small/largeNumberFormat and the max value ' +\n                   'of the field.'\n    },\n  }\n};\n\nvar sizeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, bar: true, circle: true, square: true, text: true},\n  properties: {\n    value: {\n      type: 'integer',\n      default: 30,\n      minimum: 0,\n      description: 'Size of marks.'\n    }\n  }\n};\n\nvar colorMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'string',\n      role: 'color',\n      default: '#4682b4',\n      description: 'Color to be used for marks.'\n    },\n    opacity: {\n      type: 'number',\n      default: undefined,  // auto\n      minimum: 0,\n      maximum: 1\n    },\n    scale: {\n      type: 'object',\n      properties: {\n        range: {\n          type: ['string', 'array'],\n          default: undefined,\n          description:\n            'Color palette, if undefined vega-lite will use data property' +\n            'to pick one from c10palette, c20palette, or ordinalPalette.'\n            //FIXME\n        },\n        c10palette: {\n          type: 'string',\n          default: 'category10',\n          enum: [\n            // Tableau\n            'category10', 'category10k',\n            // Color Brewer\n            'Pastel1', 'Pastel2', 'Set1', 'Set2', 'Set3'\n          ]\n        },\n        c20palette: {\n          type: 'string',\n          default: 'category20',\n          enum: ['category20', 'category20b', 'category20c']\n        },\n        ordinalPalette: {\n          type: 'string',\n          default: undefined,\n          description: 'Color palette to encode ordinal variables.',\n          enum: util.keys(colorbrewer)\n        },\n        quantitativeRange: {\n          type: 'array',\n          default: ['#AFC6A3', '#09622A'], // tableau greens\n          // default: ['#ccece6', '#00441b'], // BuGn.9 [2-8]\n          description: 'Color range to encode quantitative variables.',\n          minItems: 2,\n          maxItems: 2,\n          items: {\n            type: 'string',\n            role: 'color'\n          }\n        }\n      }\n    }\n  }\n};\n\nvar shapeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, circle: true, square: true},\n  properties: {\n    value: {\n      type: 'string',\n      enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\n      default: 'circle',\n      description: 'Mark to be used.'\n    },\n    filled: {\n      type: 'boolean',\n      default: false,\n      description: 'Whether the shape\\'s color should be used as fill color instead of stroke color.'\n    }\n  }\n};\n\nvar detailMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, line: true, circle: true, square: true}\n};\n\nvar rowMixin = {\n  properties: {\n    height: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    }\n  }\n};\n\nvar colMixin = {\n  properties: {\n    width: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    axis: {\n      properties: {\n        maxLabelLength: {\n          type: 'integer',\n          default: 12,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar facetMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, text: true},\n  properties: {\n    padding: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.1\n    }\n  }\n};\n\nvar requiredNameType = {\n  required: ['name', 'type']\n};\n\nvar multiRoleField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: true\n  }\n});\n\nvar quantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: 'ordinal-only' // using size to encoding category lead to order interpretation\n  }\n});\n\nvar onlyQuantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true\n  }\n});\n\nvar x = merge(clone(multiRoleField), axisMixin, bandMixin, requiredNameType, sortMixin);\nvar y = clone(x);\n\nvar facet = merge(clone(onlyOrdinalField), requiredNameType, facetMixin, sortMixin);\nvar row = merge(clone(facet), axisMixin, rowMixin);\nvar col = merge(clone(facet), axisMixin, colMixin);\n\nvar size = merge(clone(quantitativeField), legendMixin, sizeMixin, sortMixin);\nvar color = merge(clone(multiRoleField), legendMixin, colorMixin, sortMixin);\n\nvar shape = merge(clone(onlyOrdinalField), legendMixin, shapeMixin, sortMixin);\nvar detail = merge(clone(onlyOrdinalField), detailMixin, sortMixin);\n\n// we only put aggregated measure in pivot table\nvar text = merge(clone(onlyQuantitativeField), textMixin, sortMixin);\n\n// TODO add label\n\nvar filter = {\n  type: 'array',\n  items: {\n    type: 'object',\n    properties: {\n      operands: {\n        type: 'array',\n        items: {\n          type: ['string', 'boolean', 'integer', 'number']\n        }\n      },\n      operator: {\n        type: 'string',\n        enum: ['>', '>=', '=', '!=', '<', '<=', 'notNull']\n      }\n    }\n  }\n};\n\nvar data = {\n  type: 'object',\n  properties: {\n    // data source\n    formatType: {\n      type: 'string',\n      enum: ['json', 'csv'],\n      default: 'json'\n    },\n    url: {\n      type: 'string',\n      default: undefined\n    },\n    values: {\n      type: 'array',\n      default: undefined,\n      description: 'Pass array of objects instead of a url to a file.',\n      items: {\n        type: 'object',\n        additionalProperties: true\n      }\n    }\n  }\n};\n\nvar config = {\n  type: 'object',\n  properties: {\n    // template\n    width: {\n      type: 'integer',\n      default: undefined\n    },\n    height: {\n      type: 'integer',\n      default: undefined\n    },\n    viewport: {\n      type: 'array',\n      items: {\n        type: 'integer'\n      },\n      default: undefined\n    },\n    gridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#000000'\n    },\n    gridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.08\n    },\n\n    // filter null\n    filterNull: {\n      type: 'object',\n      properties: {\n        O: {type:'boolean', default: false},\n        Q: {type:'boolean', default: true},\n        T: {type:'boolean', default: true}\n      }\n    },\n    toggleSort: {\n      type: 'string',\n      default: O\n    },\n    autoSortLine: {\n      type: 'boolean',\n      default: true\n    },\n\n    // single plot\n    singleHeight: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    singleWidth: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    // band size\n    largeBandSize: {\n      type: 'integer',\n      default: 21,\n      minimum: 0\n    },\n    smallBandSize: {\n      //small multiples or single plot with high cardinality\n      type: 'integer',\n      default: 12,\n      minimum: 0\n    },\n    largeBandMaxCardinality: {\n      type: 'integer',\n      default: 10\n    },\n    // small multiples\n    cellPadding: {\n      type: 'number',\n      default: 0.1\n    },\n    cellGridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#000000'\n    },\n    cellGridOpacity: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.15\n    },\n    cellBackgroundColor: {\n      type: 'string',\n      role: 'color',\n      default: 'rgba(0,0,0,0)'\n    },\n    textCellWidth: {\n      type: 'integer',\n      default: 90,\n      minimum: 0\n    },\n\n    // marks\n    strokeWidth: {\n      type: 'integer',\n      default: 2,\n      minimum: 0\n    },\n    singleBarOffset: {\n      type: 'integer',\n      default: 5,\n      minimum: 0\n    },\n    // scales\n    timeScaleLabelLength: {\n      type: 'integer',\n      default: 3,\n      minimum: 0,\n      description: 'Max length for values in dayScaleLabel and monthScaleLabel.  Zero means using full names in dayScaleLabel/monthScaleLabel.'\n    },\n    dayScaleLabel: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      default: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n      description: 'Axis labels for day of week, starting from Sunday.' +\n        '(Consistent with Javascript -- See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getDay.'\n    },\n    monthScaleLabel: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      default: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n      description: 'Axis labels for month.'\n    },\n    // other\n    characterWidth: {\n      type: 'integer',\n      default: 6\n    },\n    maxSmallNumber: {\n      type: 'number',\n      default: 10000,\n      description: 'maximum number that a field will be considered smallNumber.'+\n                   'Used for axis labelling.'\n    },\n    smallNumberFormat: {\n      type: 'string',\n      default: '',\n      description: 'D3 Number format for axis labels and text tables '+\n                   'for number <= maxSmallNumber. Used for axis labelling.'\n    },\n    largeNumberFormat: {\n      type: 'string',\n      default: '.3s',\n      description: 'D3 Number format for axis labels and text tables ' +\n                   'for number > maxSmallNumber.'\n    },\n    timeFormat: {\n      type: 'string',\n      default: '%Y-%m-%d',\n      description: 'Date format for axis labels.'\n    },\n    useRawDomain: {\n      type: 'boolean',\n      default: false,\n      description: 'Use the raw data range as scale domain instead of ' +\n                   'aggregated data for aggregate axis. ' +\n                   'This option does not work with sum or count aggregate' +\n                   'as they might have a substantially larger scale range.' +\n                   'By default, use value from config.useRawDomain.'\n    }\n  }\n};\n\n/** @type Object Schema of a vega-lite specification */\nschema.schema = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  description: 'Schema for Vega-lite specification',\n  type: 'object',\n  required: ['marktype', 'encoding', 'data'],\n  properties: {\n    data: data,\n    marktype: schema.marktype,\n    encoding: {\n      type: 'object',\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        shape: shape,\n        text: text,\n        detail: detail\n      }\n    },\n    filter: filter,\n    config: config\n  }\n};\n\nschema.encTypes = util.keys(schema.schema.properties.encoding.properties);\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function() {\n  return schema.util.instantiate(schema.schema);\n};\n","'use strict';\n\nvar schemautil = module.exports = {},\n  util = require('../util');\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\nschemautil.extend = function(instance, schema) {\n  return schemautil.merge(schemautil.instantiate(schema), instance);\n};\n\n// instantiate a schema\nschemautil.instantiate = function(schema) {\n  var val;\n  if (schema === undefined) {\n    return undefined;\n  } else if ('default' in schema) {\n    val = schema.default;\n    return util.isObject(val) ? util.duplicate(val) : val;\n  } else if (schema.type === 'object') {\n    var instance = {};\n    for (var name in schema.properties) {\n      val = schemautil.instantiate(schema.properties[name]);\n      if (val !== undefined) {\n        instance[name] = val;\n      }\n    }\n    return instance;\n  } else if (schema.type === 'array') {\n    return [];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nschemautil.subtract = function(instance, defaults) {\n  var changes = {};\n  for (var prop in instance) {\n    var def = defaults[prop];\n    var ins = instance[prop];\n    // Note: does not properly subtract arrays\n    if (!defaults || def !== ins) {\n      if (typeof ins === 'object' && !util.isArray(ins) && def) {\n        var c = schemautil.subtract(ins, def);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else if (!util.isArray(ins) || ins.length > 0) {\n        changes[prop] = ins;\n      }\n    }\n  }\n  return changes;\n};\n\nschemautil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction merge(dest, src) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (var p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      merge(dest[p], src[p]);\n    }\n  }\n  return dest;\n}","'use strict';\n\nvar util = module.exports = require('datalib/src/util');\n\nutil.extend(util, require('datalib/src/generate'));\nutil.extend(util, require('datalib/src/stats'));\nutil.extend(util, require('./logger')('[VL Error]'));\nutil.bin = require('datalib/src/bins/bins');\n\nutil.isin = function(item, array) {\n  return array.indexOf(item) !== -1;\n};\n\nutil.forEach = function(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  } else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k , obj);\n    }\n  }\n};\n\nutil.reduce = function(obj, f, init, thisArg) {\n  if (obj.reduce) {\n    return obj.reduce.call(thisArg, f, init);\n  } else {\n    for (var k in obj) {\n      init = f.call(thisArg, init, obj[k], k, obj);\n    }\n    return init;\n  }\n};\n\nutil.map = function(obj, f, thisArg) {\n  if (obj.map) {\n    return obj.map.call(thisArg, f);\n  } else {\n    var output = [];\n    for (var k in obj) {\n      output.push( f.call(thisArg, obj[k], k, obj));\n    }\n  }\n};\n\nutil.any = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (f(arr[k], k, i++)) return true;\n  }\n  return false;\n};\n\nutil.all = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (!f(arr[k], k, i++)) return false;\n  }\n  return true;\n};\n\nutil.getbins = function(stats, maxbins) {\n  return util.bin({\n    min: stats.min,\n    max: stats.max,\n    maxbins: maxbins\n  });\n};\n\n/**\n * x[p[0]]...[p[n]] = val\n * @param noaugment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.setter = function(x, p, val, noaugment) {\n  for (var i=0; i<p.length-1; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  x[p[i]] = val;\n};\n\n\n/**\n * returns x[p[0]]...[p[n]]\n * @param augment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.getter = function(x, p, noaugment) {\n  for (var i=0; i<p.length; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  return x;\n};\n\n","'use strict';\n\nrequire('./globals');\n\nvar util = require('./util'),\n    consts = require('./consts');\n\nvar vl = {};\n\nutil.extend(vl, consts, util);\n\nvl.Encoding = require('./Encoding');\nvl.compiler = require('./compiler/compiler');\nvl.compile = vl.compiler.compile;\nvl.data = require('./data');\nvl.enc = require('./enc');\nvl.field = require('./field');\nvl.schema = require('./schema/schema');\nvl.toShorthand = vl.Encoding.shorthand;\nvl.format = require('d3-format').format;\n\nmodule.exports = vl;"],"sourceRoot":"/source/"}